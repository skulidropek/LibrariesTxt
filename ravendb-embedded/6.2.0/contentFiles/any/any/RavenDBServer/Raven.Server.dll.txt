public class Lucene.Net.Search.RegexQuery : MultiTermQuery {
    private Regex _regex;
    [CompilerGeneratedAttribute]
private Term <Term>k__BackingField;
    public Term Term { get; }
    public RegexQuery(Term term, Regex regex);
    [CompilerGeneratedAttribute]
public Term get_Term();
    protected virtual FilteredTermEnum GetEnum(IndexReader reader, IState state);
    public virtual string ToString(string field);
    public sealed virtual bool Equals(RegexQuery other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.RegexTermEnum : FilteredTermEnum {
    private string _sField;
    private bool _bEndEnum;
    private Regex _regex;
    public RegexTermEnum(IndexReader reader, Term term, IState state, Regex regex);
    protected virtual bool TermCompare(Term term);
    public virtual float Difference();
    public virtual bool EndEnum();
}
public abstract class Lucene.Net.Search.Vectorhighlight.BaseFragmentsBuilder : object {
    protected String[] preTags;
    protected String[] postTags;
    public static String[] COLORED_PRE_TAGS;
    public static String[] COLORED_POST_TAGS;
    protected BaseFragmentsBuilder(String[] preTags, String[] postTags);
    private static BaseFragmentsBuilder();
    public abstract virtual List`1<WeightedFragInfo> GetWeightedFragInfoList(List`1<WeightedFragInfo> src);
    public virtual string CreateFragment(IndexReader reader, int docId, string fieldName, FieldFragList fieldFragList, int fragCharSize, IState state);
    public virtual String[] CreateFragments(IndexReader reader, int docId, string fieldName, FieldFragList fieldFragList, int maxNumFragments, int fragCharSize, IState state);
    protected virtual Field[] GetFields(IndexReader reader, int docId, string fieldName, IState state);
    protected virtual string MakeFragment(StringBuilder buffer, Int32[] index, Field[] values, WeightedFragInfo fragInfo, int fragCharSize, IState state);
    private string MakeFragment(WeightedFragInfo fragInfo, string src, int adjustedStart, int fragCharSize);
    private string GetFragmentSource(StringBuilder buffer, Int32[] index, Field[] values, WeightedFragInfo weightedFragInfo, Int32& startOffset, IState state);
    private string TrimEdges(StringBuilder buffer, int startOffset, int endOffset, Int32& retStartOffset, int maxStart, int minEnd);
    protected virtual string GetPreTag(int num);
    protected virtual string GetPostTag(int num);
}
public class Lucene.Net.Search.Vectorhighlight.FastVectorHighlighter : object {
    public static bool DEFAULT_PHRASE_HIGHLIGHT;
    public static bool DEFAULT_FIELD_MATCH;
    private bool phraseHighlight;
    private bool fieldMatch;
    private FragListBuilder fragListBuilder;
    private FragmentsBuilder fragmentsBuilder;
    private int phraseLimit;
    public FastVectorHighlighter(bool phraseHighlight, bool fieldMatch);
    public FastVectorHighlighter(bool phraseHighlight, bool fieldMatch, FragListBuilder fragListBuilder, FragmentsBuilder fragmentsBuilder);
    private static FastVectorHighlighter();
    public FieldQuery GetFieldQuery(Query query);
    public String[] GetBestFragments(FieldQuery fieldQuery, IndexReader reader, int docId, string fieldName, int fragCharSize, int maxNumFragments, IState state);
    private FieldFragList GetFieldFragList(FieldQuery fieldQuery, IndexReader reader, int docId, string fieldName, int fragCharSize, IState state);
}
public class Lucene.Net.Search.Vectorhighlight.FieldFragList : object {
    private int fragCharSize;
    public List`1<WeightedFragInfo> fragInfos;
    public FieldFragList(int fragCharSize);
    public void Add(int startOffset, int endOffset, List`1<WeightedPhraseInfo> phraseInfoList);
}
public class Lucene.Net.Search.Vectorhighlight.FieldPhraseList : object {
    public LinkedList`1<WeightedPhraseInfo> phraseList;
    public FieldPhraseList(FieldTermStack fieldTermStack, FieldQuery fieldQuery);
    public FieldPhraseList(FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit);
    private void AddIfNoOverlap(WeightedPhraseInfo wpi);
}
public class Lucene.Net.Search.Vectorhighlight.FieldQuery : object {
    private bool fieldMatch;
    public HashMap`2<string, QueryPhraseMap> rootMaps;
    public HashMap`2<string, List`1<string>> termSetMap;
    private int termOrPhraseNumber;
    public FieldQuery(Query query, bool phraseHighlight, bool fieldMatch);
    public void flatten(Query sourceQuery, Dictionary`2<Query, Query> flatQueries);
    public Dictionary`2<Query, Query> expand(Dictionary`2<Query, Query> flatQueries);
    private void CheckOverlap(Dictionary`2<Query, Query> expandQueries, PhraseQuery a, PhraseQuery b);
    private void CheckOverlap(Dictionary`2<Query, Query> expandQueries, Term[] src, Term[] dest, int slop, float boost);
    public QueryPhraseMap getRootMap(Query query);
    private string GetKey(Query query);
    private void SaveTerms(Dictionary`2<Query, Query> flatQueries);
    private List`1<string> GetTermSet(Query query);
    public List`1<string> getTermSet(string field);
    public QueryPhraseMap GetFieldTermMap(string fieldName, string term);
    public QueryPhraseMap RetrieveQueryFromSubMap(QueryPhraseMap rootMap, string term);
    public QueryPhraseMap SearchPhrase(string fieldName, List`1<TermInfo> phraseCandidate);
    private QueryPhraseMap GetRootMap(string fieldName);
    private int NextTermOrPhraseNumber();
}
public class Lucene.Net.Search.Vectorhighlight.FieldTermStack : object {
    private string fieldName;
    public LinkedList`1<TermInfo> termList;
    public string FieldName { get; }
    public FieldTermStack(IndexReader reader, int docId, string fieldName, FieldQuery fieldQuery, IState state);
    private void Sort(LinkedList`1<TermInfo> linkList);
    private int PosComparer(TermInfo t1, TermInfo t2);
    public string get_FieldName();
    public TermInfo Pop();
    public void Push(TermInfo termInfo);
    public bool IsEmpty();
}
public interface Lucene.Net.Search.Vectorhighlight.FragListBuilder {
    public abstract virtual FieldFragList CreateFieldFragList(FieldPhraseList fieldPhraseList, int fragCharSize);
}
public interface Lucene.Net.Search.Vectorhighlight.FragmentsBuilder {
    public abstract virtual string CreateFragment(IndexReader reader, int docId, string fieldName, FieldFragList fieldFragList, int fragCharSize, IState state);
    public abstract virtual String[] CreateFragments(IndexReader reader, int docId, string fieldName, FieldFragList fieldFragList, int maxNumFragments, int fragCharSize, IState state);
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Search.Vectorhighlight.HashMap`2 : Dictionary`2<K, V> {
    private V _NullKeyValue;
    public int Count { get; }
    public V Item { get; public set; }
    public void Add(K key, V value);
    public int get_Count();
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public V Get(K key);
    public void Put(K key, V val);
}
public class Lucene.Net.Search.Vectorhighlight.ScoreOrderFragmentsBuilder : BaseFragmentsBuilder {
    public ScoreOrderFragmentsBuilder(String[] preTags, String[] postTags);
    public virtual List`1<WeightedFragInfo> GetWeightedFragInfoList(List`1<WeightedFragInfo> src);
}
public class Lucene.Net.Search.Vectorhighlight.SimpleFragListBuilder : object {
    public static int MARGIN;
    public static int MIN_FRAG_CHAR_SIZE;
    private static SimpleFragListBuilder();
    public sealed virtual FieldFragList CreateFieldFragList(FieldPhraseList fieldPhraseList, int fragCharSize);
}
public static class Lucene.Net.Search.Vectorhighlight.StringUtils : object {
    public static bool TermStringMatch(string term, string termToMatch);
}
public abstract class Raven.Server.Background.BackgroundWorkBase : object {
    private CancellationToken _shutdown;
    protected CancellationTokenSource Cts;
    private Task _currentTask;
    protected Logger Logger;
    protected CancellationToken CancellationToken { get; }
    private static Lazy`1<CancellationToken> CanceledToken { get; }
    protected BackgroundWorkBase(string resourceName, CancellationToken shutdown);
    protected CancellationToken get_CancellationToken();
    private static Lazy`1<CancellationToken> get_CanceledToken();
    public void Start();
    public void Stop();
    [AsyncStateMachineAttribute("Raven.Server.Background.BackgroundWorkBase/<WaitOrThrowOperationCanceled>d__11")]
protected Task WaitOrThrowOperationCanceled(TimeSpan time);
    [AsyncStateMachineAttribute("Raven.Server.Background.BackgroundWorkBase/<Run>d__12")]
protected Task Run();
    protected virtual void InitializeWork();
    protected abstract virtual Task DoWork();
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <WaitOrThrowOperationCanceled>g__ThrowOperationCanceledExceptionIfNeeded|11_0();
}
public static class Raven.Server.Commercial.ApiHttpClient : object {
    public static RavenHttpClient Instance;
    public static string ApiRavenDbNet { get; }
    private static ApiHttpClient();
    public static string get_ApiRavenDbNet();
}
public class Raven.Server.Commercial.ClaimDomainInfo : object {
    [CompilerGeneratedAttribute]
private License <License>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    public License License { get; public set; }
    public string Domain { get; public set; }
    [CompilerGeneratedAttribute]
public License get_License();
    [CompilerGeneratedAttribute]
public void set_License(License value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.CompleteClusterConfigurationResult : object {
    public string Domain;
    public Byte[] CertBytes;
    public Byte[] ServerCertBytes;
    public X509Certificate2 ServerCert;
    public X509Certificate2 ClientCert;
    public string PublicServerUrl;
    public CertificateDefinition CertificateDefinition;
}
public class Raven.Server.Commercial.ContinueSetupInfo : object {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RegisterClientCert>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Zip>k__BackingField;
    public string NodeTag { get; public set; }
    public bool RegisterClientCert { get; public set; }
    public string Zip { get; public set; }
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public bool get_RegisterClientCert();
    [CompilerGeneratedAttribute]
public void set_RegisterClientCert(bool value);
    [CompilerGeneratedAttribute]
public string get_Zip();
    [CompilerGeneratedAttribute]
public void set_Zip(string value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.CreateSetupPackageParameters : object {
    public string SetupJsonPath;
    public string PackageOutputPath;
    public CommandLineApplication Command;
    public SetupInfo SetupInfo;
    public UnsecuredSetupInfo UnsecuredSetupInfo;
    public string Mode;
    public string CertificatePath;
    public string CertPassword;
    public string HelmValuesOutputPath;
    public SetupProgressAndResult Progress;
    public bool RegisterTcpDnsRecords;
    public string AcmeUrl;
    public CancellationToken CancellationToken;
}
public class Raven.Server.Commercial.DatabaseLicenseLimitsUsage : object {
    [CompilerGeneratedAttribute]
private int <NumberOfStaticIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfAutoIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfCustomSorters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfAnalyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfSubscriptions>k__BackingField;
    public int NumberOfStaticIndexes { get; public set; }
    public int NumberOfAutoIndexes { get; public set; }
    public int NumberOfCustomSorters { get; public set; }
    public int NumberOfAnalyzers { get; public set; }
    public long NumberOfSubscriptions { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumberOfStaticIndexes();
    [CompilerGeneratedAttribute]
public void set_NumberOfStaticIndexes(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfAutoIndexes();
    [CompilerGeneratedAttribute]
public void set_NumberOfAutoIndexes(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfCustomSorters();
    [CompilerGeneratedAttribute]
public void set_NumberOfCustomSorters(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfAnalyzers();
    [CompilerGeneratedAttribute]
public void set_NumberOfAnalyzers(int value);
    [CompilerGeneratedAttribute]
public long get_NumberOfSubscriptions();
    [CompilerGeneratedAttribute]
public void set_NumberOfSubscriptions(long value);
    public sealed virtual DynamicJsonValue ToJson();
    public static DatabaseLicenseLimitsUsage CreateFor(TransactionOperationContext`1<TTransaction> context, RawDatabaseRecord databaseRecord);
    public static DatabaseLicenseLimitsUsage CreateFor(TransactionOperationContext`1<TTransaction> context, ServerStore serverStore, string databaseName);
}
public class Raven.Server.Commercial.DetailsPerNode : object {
    public int UtilizedCores;
    public Nullable`1<int> MaxUtilizedCores;
    public int NumberOfCores;
    public double InstalledMemoryInGb;
    public double UsableMemoryInGb;
    public BuildNumber BuildInfo;
    public OsInfo OsInfo;
    public int MaxCoresToUtilize { get; }
    public int get_MaxCoresToUtilize();
    public sealed virtual DynamicJsonValue ToJson();
    public int GetMaxCoresToUtilize(int requestedCores, Nullable`1<int> maxCoresPerNode);
}
public class Raven.Server.Commercial.EmailValidator : object {
    public static bool IsValid(string email);
}
public class Raven.Server.Commercial.FeedbackSender : object {
    [AsyncStateMachineAttribute("Raven.Server.Commercial.FeedbackSender/<SendFeedback>d__0")]
public Task SendFeedback(FeedbackForm feedback);
}
public class Raven.Server.Commercial.GetSetupZipFileParameters : object {
    public CompleteClusterConfigurationResult CompleteClusterConfigurationResult;
    public SetupProgressAndResult Progress;
    public bool ZipOnly;
    public Action`1<IOperationProgress> OnProgress;
    public Func`1<string> OnSettingsPath;
    public SetupInfo SetupInfo;
    public UnsecuredSetupInfo UnsecuredSetupInfo;
    public SetupMode SetupMode;
    public Func`2<string, string> OnGetCertificatePath;
    public CancellationToken Token;
    public Func`2<StudioEnvironment, Task> OnPutServerWideStudioConfigurationValues;
    public Action`1<string> OnWriteSettingsJsonLocally;
}
public class Raven.Server.Commercial.LeasedLicense : object {
    [CompilerGeneratedAttribute]
private License <License>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private NotificationSeverity <NotificationSeverity>k__BackingField;
    public License License { get; public set; }
    public string Title { get; public set; }
    public string Message { get; public set; }
    public string ErrorMessage { get; public set; }
    public NotificationSeverity NotificationSeverity { get; public set; }
    [CompilerGeneratedAttribute]
public License get_License();
    [CompilerGeneratedAttribute]
public void set_License(License value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public NotificationSeverity get_NotificationSeverity();
    [CompilerGeneratedAttribute]
public void set_NotificationSeverity(NotificationSeverity value);
}
public class Raven.Server.Commercial.LeaseLicenseInfo : object {
    [CompilerGeneratedAttribute]
private License <License>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildNumber <BuildInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClusterId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UtilizedCores>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private StudioEnvironment <StudioEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private OsInfo <OsInfo>k__BackingField;
    public License License { get; public set; }
    public BuildNumber BuildInfo { get; public set; }
    public string ClusterId { get; public set; }
    public int UtilizedCores { get; public set; }
    public string NodeTag { get; public set; }
    public StudioEnvironment StudioEnvironment { get; public set; }
    public OsInfo OsInfo { get; public set; }
    [CompilerGeneratedAttribute]
public License get_License();
    [CompilerGeneratedAttribute]
public void set_License(License value);
    [CompilerGeneratedAttribute]
public BuildNumber get_BuildInfo();
    [CompilerGeneratedAttribute]
public void set_BuildInfo(BuildNumber value);
    [CompilerGeneratedAttribute]
public string get_ClusterId();
    [CompilerGeneratedAttribute]
public void set_ClusterId(string value);
    [CompilerGeneratedAttribute]
public int get_UtilizedCores();
    [CompilerGeneratedAttribute]
public void set_UtilizedCores(int value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public StudioEnvironment get_StudioEnvironment();
    [CompilerGeneratedAttribute]
public void set_StudioEnvironment(StudioEnvironment value);
    [CompilerGeneratedAttribute]
public OsInfo get_OsInfo();
    [CompilerGeneratedAttribute]
public void set_OsInfo(OsInfo value);
}
public enum Raven.Server.Commercial.LeaseStatus : Enum {
    public int value__;
    public static LeaseStatus Updated;
    public static LeaseStatus NotModified;
}
public class Raven.Server.Commercial.LetsEncrypt.CompleteClusterConfigurationParameters : object {
    public SetupProgressAndResult Progress;
    public Action`1<IOperationProgress> OnProgress;
    public Func`1<string> OnSettingsPath;
    public SetupInfo SetupInfo;
    public UnsecuredSetupInfo UnsecuredSetupInfo;
    public Func`3<string, string, Task> OnBeforeAddingNodesToCluster;
    public Func`2<string, Task> AddNodeToCluster;
    public Action`3<Action`1<IOperationProgress>, SetupProgressAndResult, X509Certificate2> RegisterClientCertInOs;
    public Func`2<StudioEnvironment, Task> OnPutServerWideStudioConfigurationValues;
    public Action`1<string> OnWriteSettingsJsonLocally;
    public Func`2<string, string> OnGetCertificatePath;
    public Func`3<X509Certificate2, CertificateDefinition, Task> PutCertificateInCluster;
    public SetupMode SetupMode;
    public bool CertificateValidationKeyUsages;
    public LicenseType LicenseType;
    public CancellationToken Token;
}
public class Raven.Server.Commercial.LetsEncrypt.LetsEncryptCertificateUtil : object {
    internal static ValueTuple`3<Byte[], CertificateDefinition, X509Certificate2> GenerateClientCertificateTask(CertificateHolder certificateHolder, string certificateName, SetupInfo setupInfo);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.LetsEncryptCertificateUtil/<WriteCertificateAsPemToZipArchiveAsync>d__1")]
public static Task WriteCertificateAsPemToZipArchiveAsync(string name, Byte[] rawBytes, string exportPassword, ZipArchive archive);
}
public class Raven.Server.Commercial.LetsEncrypt.LetsEncryptSimulationHelper : object {
    internal static Logger Logger;
    private static LetsEncryptSimulationHelper();
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.LetsEncryptSimulationHelper/<SimulateRunningServer>d__2")]
public static Task SimulateRunningServer(ServerStore serverStore, X509Certificate2 serverCertificate, string serverUrl, string nodeTag, IPEndPoint[] addresses, int port, string settingsPath, SetupMode setupMode, CancellationToken token);
}
public class Raven.Server.Commercial.LetsEncrypt.LetsEncryptValidationHelper : object {
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.LetsEncryptValidationHelper/<AssertLocalNodeCanListenToEndpoints>d__0")]
private static Task AssertLocalNodeCanListenToEndpoints(SetupInfoBase setupInfoBase, ServerStore serverStore);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.LetsEncryptValidationHelper/<ValidateServerCanRunOnThisNode>d__1")]
internal static Task ValidateServerCanRunOnThisNode(BlittableJsonReaderObject settingsJsonObject, X509Certificate2 cert, ServerStore serverStore, string nodeTag, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.LetsEncryptValidationHelper/<ValidateSetupInfo>d__2")]
internal static Task ValidateSetupInfo(SetupMode setupMode, SetupInfo setupInfo, ServerStore serverStore);
    private static bool IsValidDomain(string domain);
}
public class Raven.Server.Commercial.LetsEncrypt.RavenDnsRecordHelper : object {
    private static string GoogleDnsApi;
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.RavenDnsRecordHelper/<UpdateDnsRecordsTask>d__1")]
public static Task UpdateDnsRecordsTask(UpdateDnsRecordParameters parameters);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.RavenDnsRecordHelper/<AssertDnsUpdatedSuccessfully>d__2")]
public static Task AssertDnsUpdatedSuccessfully(string serverUrl, IPEndPoint[] expectedAddresses, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.RavenDnsRecordHelper/<CanResolveHostNameLocally>d__3")]
public static Task`1<bool> CanResolveHostNameLocally(string serverUrl, IPEndPoint[] expectedAddresses);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.RavenDnsRecordHelper/<UpdateDnsRecordsForCertificateRefreshTask>d__4")]
public static Task UpdateDnsRecordsForCertificateRefreshTask(string challenge, SetupInfo setupInfo, Logger logger, CancellationToken token);
}
public static class Raven.Server.Commercial.LetsEncrypt.SettingsZipFileHelper : object {
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.SettingsZipFileHelper/<GetSetupZipFileSecuredSetup>d__0")]
internal static Task`1<Byte[]> GetSetupZipFileSecuredSetup(GetSetupZipFileParameters parameters);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncrypt.SettingsZipFileHelper/<GetSetupZipFileUnsecuredSetup>d__1")]
internal static Task`1<Byte[]> GetSetupZipFileUnsecuredSetup(GetSetupZipFileParameters parameters);
    public static void WriteSettingsJsonLocally(string settingsPath, string json);
    public static string CreateReadmeTextUnsecured(string nodeTag, string publicServerUrl, bool isCluster, bool zipOnly, bool isContinueFlow);
    public static string CreateReadmeTextSecured(string nodeTag, string publicServerUrl, bool isCluster, bool registerClientCert, bool zipOnly, bool isContinueFlow);
    private static string CreateReadmeForCluster();
    private static string CreateReadmeForClientCertificate(string publicServerUrl, bool registerClientCert, string nodeTag);
    internal static string IpAddressToUrl(string address, int port, string scheme);
}
public class Raven.Server.Commercial.LetsEncrypt.UpdateDnsRecordParameters : object {
    public Action`1<IOperationProgress> OnProgress;
    public SetupProgressAndResult Progress;
    public string Challenge;
    public SetupInfo SetupInfo;
    public bool RegisterTcpDnsRecords;
    public CancellationToken Token;
}
public class Raven.Server.Commercial.LetsEncryptClient : object {
    private static JsonSerializerSettings jsonSettings;
    private static Dictionary`2<string, RavenHttpClient> _cachedClients;
    private static object Locker;
    private Jws _jws;
    private string _path;
    private string _url;
    private string _directoryPath;
    private string _nonce;
    private RSACryptoServiceProvider _accountKey;
    private RegistrationCache _cache;
    private RavenHttpClient _client;
    private Directory _directory;
    private List`1<AuthorizationChallenge> _challenges;
    private Order _currentOrder;
    public LetsEncryptClient(string url);
    private static LetsEncryptClient();
    private static RavenHttpClient GetCachedClient(string url);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncryptClient/<Init>d__16")]
public Task Init(string email, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncryptClient/<SendAsync>d__17`1")]
private Task`1<ValueTuple`2<TResult, string>> SendAsync(HttpMethod method, Uri uri, object message, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncryptClient/<SendAsyncInternal>d__18")]
private Task`1<HttpResponseMessage> SendAsyncInternal(HttpMethod method, Uri uri, object message, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncryptClient/<NewOrder>d__19")]
public Task`1<Dictionary`2<string, string>> NewOrder(String[] hostnames, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncryptClient/<CompleteChallenges>d__20")]
public Task CompleteChallenges(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncryptClient/<GetCertificate>d__21")]
public Task`1<ValueTuple`2<X509Certificate2, RSA>> GetCertificate(RSA existingKey, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LetsEncryptClient/<WaitForStatusAsync>d__23")]
private Task WaitForStatusAsync(Uri uri, List`1<string> statusesToWaitFor, CancellationToken token);
    public bool TryGetCachedCertificate(string host, CachedCertificateResult& value);
    public string GetTermsOfServiceUri(CancellationToken token);
    public void ResetCachedCertificate(IEnumerable`1<string> hostsToRemove);
    internal static string GetCachePath(string acmeUrl);
}
public class Raven.Server.Commercial.License : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Keys>k__BackingField;
    public Guid Id { get; public set; }
    public string Name { get; public set; }
    public List`1<string> Keys { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Keys();
    [CompilerGeneratedAttribute]
public void set_Keys(List`1<string> value);
    public DynamicJsonValue ToJson();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum Raven.Server.Commercial.LicenseAttribute : Enum {
    public int value__;
    public static LicenseAttribute Type;
    public static LicenseAttribute Version;
    public static LicenseAttribute Expiration;
    public static LicenseAttribute Memory;
    public static LicenseAttribute Cores;
    public static LicenseAttribute Redist;
    public static LicenseAttribute Encryption;
    public static LicenseAttribute Snmp;
    public static LicenseAttribute DistributedCluster;
    public static LicenseAttribute MaxClusterSize;
    public static LicenseAttribute SnapshotBackup;
    public static LicenseAttribute CloudBackup;
    public static LicenseAttribute DynamicNodesDistribution;
    public static LicenseAttribute ExternalReplication;
    public static LicenseAttribute DelayedExternalReplication;
    public static LicenseAttribute RavenEtl;
    public static LicenseAttribute SqlEtl;
    public static LicenseAttribute HighlyAvailableTasks;
    public static LicenseAttribute PullReplicationHub;
    public static LicenseAttribute PullReplicationSink;
    public static LicenseAttribute EncryptedBackup;
    public static LicenseAttribute LetsEncryptAutoRenewal;
    public static LicenseAttribute Cloud;
    public static LicenseAttribute DocumentsCompression;
    public static LicenseAttribute TimeSeriesRollupsAndRetention;
    public static LicenseAttribute AdditionalAssembliesNuget;
    public static LicenseAttribute MonitoringEndpoints;
    public static LicenseAttribute OlapEtl;
    public static LicenseAttribute ReadOnlyCertificates;
    public static LicenseAttribute TcpDataCompression;
    public static LicenseAttribute ConcurrentSubscriptions;
    public static LicenseAttribute ElasticSearchEtl;
    public static LicenseAttribute PowerBI;
    public static LicenseAttribute PostgreSqlIntegration;
    public static LicenseAttribute CanBeActivatedUntil;
    public static LicenseAttribute QueueEtl;
    public static LicenseAttribute ServerWideBackups;
    public static LicenseAttribute ServerWideExternalReplications;
    public static LicenseAttribute ServerWideCustomSorters;
    public static LicenseAttribute ServerWideAnalyzers;
    public static LicenseAttribute IndexCleanup;
    public static LicenseAttribute PeriodicBackup;
    public static LicenseAttribute ClientConfiguration;
    public static LicenseAttribute StudioConfiguration;
    public static LicenseAttribute QueueSink;
    public static LicenseAttribute DataArchival;
    public static LicenseAttribute RevisionsInSubscriptions;
    public static LicenseAttribute MultiNodeSharding;
    public static LicenseAttribute SetupDefaultRevisionsConfiguration;
    public static LicenseAttribute MaxCoresPerNode;
    public static LicenseAttribute MaxNumberOfRevisionsToKeep;
    public static LicenseAttribute MaxNumberOfRevisionAgeToKeepInDays;
    public static LicenseAttribute MinPeriodForExpirationInHours;
    public static LicenseAttribute MinPeriodForRefreshInHours;
    public static LicenseAttribute MaxReplicationFactorForSharding;
    public static LicenseAttribute MaxNumberOfStaticIndexesPerDatabase;
    public static LicenseAttribute MaxNumberOfStaticIndexesPerCluster;
    public static LicenseAttribute MaxNumberOfAutoIndexesPerDatabase;
    public static LicenseAttribute MaxNumberOfAutoIndexesPerCluster;
    public static LicenseAttribute MaxNumberOfSubscriptionsPerDatabase;
    public static LicenseAttribute MaxNumberOfSubscriptionsPerCluster;
    public static LicenseAttribute MaxNumberOfCustomSortersPerDatabase;
    public static LicenseAttribute MaxNumberOfCustomSortersPerCluster;
    public static LicenseAttribute MaxNumberOfCustomAnalyzersPerDatabase;
    public static LicenseAttribute MaxNumberOfCustomAnalyzersPerCluster;
}
public class Raven.Server.Commercial.LicenseExpiredException : Exception {
    public LicenseExpiredException(string message);
    public LicenseExpiredException(string message, Exception innerException);
}
public class Raven.Server.Commercial.LicenseHelper : object {
    private static Logger Logger;
    public static string LicenseStringConfigurationName;
    private ServerStore _serverStore;
    private SemaphoreSlim _sm;
    public LicenseHelper(ServerStore serverStore);
    private static LicenseHelper();
    public void UpdateLocalLicense(License newLicense, RSAParameters rsaParameters);
    public License TryGetLicenseFromString(bool throwOnFailure);
    public License TryGetLicenseFromPath(bool throwOnFailure);
    private static License DeserializeLicense(Stream stream);
    private static License DeserializeLicense(string licenseString);
    internal static bool TryDeserializeLicense(string licenseString, License& license);
    private void UpdateLicenseString(License newLicense, RSAParameters rsaParameters);
    private static void UpdateEnvironmentVariableLicenseString(License newLicense, RSAParameters rsaParameters);
    private static bool ValidateLicense(License oldLicense, RSAParameters rsaParameters, License newLicense);
    private bool TryUpdatingSettingsJson(License newLicense, RSAParameters rsaParameters);
    private void UpdateLicenseFromPath(License oldLicense, License newLicense, RSAParameters rsaParameters);
    internal static bool TryValidateLicenseExpirationDate(License license, DateTime& expirationDate);
    internal static void ValidateLicenseVersionOrThrow(License license, ServerStore serverStore, TransactionContextPool contextPool, bool usingApi);
    private static string GetLicenseJson(ServerStore serverStore);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseHelper/<GetLicenseFromApi>d__19")]
private static Task`1<License> GetLicenseFromApi(License license, TransactionContextPool contextPool, CancellationToken token);
    public static bool TryValidateAndHandleLicense(ServerStore serverStore, string licenseJson, Nullable`1<Guid> inStorageLicenseId, LicenseVerificationErrorBuilder verificationErrorBuilder, TransactionContextPool contextPool);
    [CompilerGeneratedAttribute]
internal static string <UpdateEnvironmentVariableLicenseString>g__GetLicenseString|12_0(<>c__DisplayClass12_0& );
}
public class Raven.Server.Commercial.LicenseLeaseResult : object {
    [CompilerGeneratedAttribute]
private LeaseStatus <Status>k__BackingField;
    public LeaseStatus Status { get; public set; }
    [CompilerGeneratedAttribute]
public LeaseStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(LeaseStatus value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.LicenseLimits : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DetailsPerNode> <NodeLicenseDetails>k__BackingField;
    public Dictionary`2<string, DetailsPerNode> NodeLicenseDetails { get; public set; }
    public int TotalUtilizedCores { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DetailsPerNode> get_NodeLicenseDetails();
    [CompilerGeneratedAttribute]
public void set_NodeLicenseDetails(Dictionary`2<string, DetailsPerNode> value);
    public int get_TotalUtilizedCores();
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.LicenseLimitsUsage : object {
    [CompilerGeneratedAttribute]
private int <NumberOfStaticIndexesInCluster>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfAutoIndexesInCluster>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfCustomSortersInCluster>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfAnalyzersInCluster>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfSubscriptionsInCluster>k__BackingField;
    public int NumberOfStaticIndexesInCluster { get; public set; }
    public int NumberOfAutoIndexesInCluster { get; public set; }
    public int NumberOfCustomSortersInCluster { get; public set; }
    public int NumberOfAnalyzersInCluster { get; public set; }
    public long NumberOfSubscriptionsInCluster { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumberOfStaticIndexesInCluster();
    [CompilerGeneratedAttribute]
public void set_NumberOfStaticIndexesInCluster(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfAutoIndexesInCluster();
    [CompilerGeneratedAttribute]
public void set_NumberOfAutoIndexesInCluster(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfCustomSortersInCluster();
    [CompilerGeneratedAttribute]
public void set_NumberOfCustomSortersInCluster(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfAnalyzersInCluster();
    [CompilerGeneratedAttribute]
public void set_NumberOfAnalyzersInCluster(int value);
    [CompilerGeneratedAttribute]
public long get_NumberOfSubscriptionsInCluster();
    [CompilerGeneratedAttribute]
public void set_NumberOfSubscriptionsInCluster(long value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.LicenseManager : object {
    private static Logger Logger;
    private static RSAParameters _rsaParameters;
    private LicenseStorage _licenseStorage;
    private Timer _leaseLicenseTimer;
    private ServerStore _serverStore;
    private LicenseHelper _licenseHelper;
    private SemaphoreSlim _leaseLicenseSemaphore;
    private SemaphoreSlim _licenseLimitsSemaphore;
    private bool _skipLeasingErrorsLogging;
    private Nullable`1<DateTime> _lastPerformanceHint;
    private bool _eulaAcceptedButHasPendingRestart;
    private SemaphoreSlim _locker;
    private LicenseSupportInfo _lastKnownSupportInfo;
    [CompilerGeneratedAttribute]
private Action LicenseChanged;
    [CompilerGeneratedAttribute]
private Action OnBeforeInitialize;
    public static OsInfo OsInfo;
    public static BuildNumber BuildInfo;
    [CompilerGeneratedAttribute]
private LicenseStatus <LicenseStatus>k__BackingField;
    internal static bool IgnoreProcessorAffinityChanges;
    internal static bool AddLicenseStatusToLicenseLimitsException;
    public LicenseStatus LicenseStatus { get; private set; }
    public bool IsEulaAccepted { get; }
    private static LicenseManager();
    public LicenseManager(ServerStore serverStore);
    [CompilerGeneratedAttribute]
public void add_LicenseChanged(Action value);
    [CompilerGeneratedAttribute]
public void remove_LicenseChanged(Action value);
    [CompilerGeneratedAttribute]
public void add_OnBeforeInitialize(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnBeforeInitialize(Action value);
    [CompilerGeneratedAttribute]
public LicenseStatus get_LicenseStatus();
    [CompilerGeneratedAttribute]
private void set_LicenseStatus(LicenseStatus value);
    public bool get_IsEulaAccepted();
    public void Initialize(StorageEnvironment environment, TransactionContextPool contextPool);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<PutMyNodeInfoAsync>d__32")]
public Task PutMyNodeInfoAsync();
    public void ReloadLicense(bool firstRun);
    private void CreateAgplAlert();
    private void RemoveAgplAlert();
    public void ReloadLicenseLimits(bool firstRun);
    public int GetCoresLimitForNode(LicenseLimits& licenseLimits, bool shouldPutNodeInfoIfNotExist);
    private int GetClusterSize();
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<ChangeLicenseLimits>d__39")]
public Task ChangeLicenseLimits(string nodeTag, Nullable`1<int> maxUtilizedCores, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<GetNodeInfo>d__40")]
private Task`1<NodeInfo> GetNodeInfo(string nodeUrl, TransactionOperationContext ctx);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<ActivateAsync>d__41")]
public Task ActivateAsync(License license, string raftRequestId, bool skipGettingUpdatedLicense, bool fromApi);
    private void ResetLicense(string error);
    private void SetLicense(LicenseStatus licenseStatus);
    public static LicenseStatus GetLicenseStatus(License license);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<TryActivateLicenseAsync>d__45")]
public Task TryActivateLicenseAsync(bool throwOnActivationFailure);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<GetUpdatedLicenseResponseMessage>d__46")]
public static Task`1<HttpResponseMessage> GetUpdatedLicenseResponseMessage(License currentLicense, TransactionContextPool contextPool, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<GetUpdatedLicense>d__47")]
public Task`1<License> GetUpdatedLicense(License currentLicense);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<ConvertResponseToLeasedLicense>d__48")]
public static Task`1<LeasedLicense> ConvertResponseToLeasedLicense(HttpResponseMessage httpResponseMessage, CancellationToken token);
    private static LeaseLicenseInfo GetLeaseLicenseInfo(License license, TransactionContextPool contextPool);
    private static int GetUtilizedCores(TransactionOperationContext context);
    private static StudioEnvironment GetStudioEnvironment(TransactionOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<GetUpdatedLicenseForActivation>d__52")]
private Task`1<ValueTuple`2<License, bool>> GetUpdatedLicenseForActivation(License currentLicense);
    private License TryGetUpdatedLicenseFromStringOrPath(License currentLicense);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<ExecuteTasks>d__54")]
private Task ExecuteTasks();
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<RenewLicense>d__55")]
public Task`1<LicenseRenewalResult> RenewLicense();
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<LeaseLicense>d__56")]
public Task`1<LicenseLeaseResult> LeaseLicense(string raftRequestId, bool throwOnError);
    private void ValidateLicenseStatus();
    private void AddLeaseLicenseError(string errorMessage, Exception exception);
    private void SetAffinity(Process process, int cores, LicenseLimits licenseLimits);
    private bool ShouldIgnoreProcessorAffinityChanges(int cores, LicenseLimits licenseLimits);
    private static void SetMaxWorkingSet(Process process, double ramInGb);
    public sealed virtual void Dispose();
    private void ThrowIfCannotActivateLicense(LicenseStatus newLicenseStatus);
    private static string GenerateDetails(int count, string feature);
    private static string Pluralize(int count);
    private static bool HasRavenEtl(List`1<RavenEtlConfiguration> ravenEtls, Dictionary`2<string, RavenConnectionString> ravenConnectionStrings);
    private static bool HasDocumentsCompression(DocumentsCompressionConfiguration documentsCompression);
    private static bool HasRevisionCompression(DocumentsCompressionConfiguration documentsCompression);
    private static bool HasTimeSeriesRollupsAndRetention(TimeSeriesConfiguration configuration);
    internal static bool HasAdditionalAssembliesFromNuGet(Dictionary`2<string, IndexDefinition> indexes);
    private static bool HasAdditionalAssembliesFromNuGet(IndexDefinition indexDefinition);
    internal static ValueTuple`3<bool, bool, bool> GetBackupTypes(IEnumerable`1<PeriodicBackupConfiguration> periodicBackups);
    public void AssertCanAddNode();
    public void AssertCanAddAdditionalAssembliesFromNuGet(IndexDefinition indexDefinition);
    public void AssertCanAddPeriodicBackup(BackupConfiguration configuration);
    public static bool HasEncryptedBackup(BackupConfiguration configuration);
    public void AssertCanAddExternalReplication(TimeSpan delayReplicationFor);
    public void AssertCanDelayReplication(TimeSpan delayReplicationFor);
    public void AssertCanUseDocumentsCompression(DocumentsCompressionConfiguration documentsCompression);
    public void AssertCanAddPullReplicationAsHub();
    public void AssertCanAddPullReplicationAsSink();
    public void AssertCanAddTimeSeriesRollupsAndRetention(TimeSeriesConfiguration configuration);
    public void AssertCanAddRavenEtl();
    public void AssertCanAddSqlEtl();
    public void AssertCanAddElasticSearchEtl();
    public void AssertCanAddQueueEtl();
    public void AssertCanAddConcurrentDataSubscriptions();
    public void AssertCanAddOlapEtl();
    public void AssertCanUseMonitoringEndpoints();
    public void AssertCanAddReadOnlyCertificates(CertificateDefinition certificate);
    public bool CanUseOpenTelemetryMonitoring(bool withNotification, bool startUp);
    public bool CanUseSnmpMonitoring(bool withNotification);
    public bool CanUsePostgreSqlIntegration(bool withNotification);
    public bool CanUsePowerBi(bool withNotification, LicenseLimitException& licenseLimitException);
    public bool CanDynamicallyDistributeNodes(bool withNotification, LicenseLimitException& licenseLimit);
    public bool HasHighlyAvailableTasks();
    public static AlertRaised CreateHighlyAvailableTasksAlert(DatabaseTopology databaseTopology, IDatabaseTask databaseTask, string lastResponsibleNode);
    private static string GetTaskType(IDatabaseTask databaseTask, bool lower);
    private static string GetMentorNodeState(IDatabaseTask databaseTask, DatabaseTopology databaseTopology, string nodeState);
    private static string GetNodeState(DatabaseTopology databaseTopology, string nodeTag);
    public void AssertCanCreateEncryptedDatabase();
    private void DismissLicenseLimit(LimitType limitType);
    private LicenseLimitException GenerateLicenseLimit(LimitType limitType, string message, bool addNotification);
    private bool IsValid(LicenseLimitException& licenseLimit);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<GetLicenseSupportInfo>d__105")]
public Task`1<LicenseSupportInfo> GetLicenseSupportInfo();
    private LicenseSupportInfo GetDefaultLicenseSupportInfo();
    [AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<AcceptEulaAsync>d__107")]
public Task AcceptEulaAsync();
    public int GetNumberOfUtilizedCores();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <Initialize>b__31_0(object state);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Raven.Server.Commercial.LicenseManager/<<GetCoresLimitForNode>b__37_0>d")]
[CompilerGeneratedAttribute]
private Task <GetCoresLimitForNode>b__37_0();
}
public class Raven.Server.Commercial.LicenseRenewalResult : object {
    [CompilerGeneratedAttribute]
private string <SentToEmail>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <NewExpirationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public string SentToEmail { get; public set; }
    public Nullable`1<DateTime> NewExpirationDate { get; public set; }
    public string Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SentToEmail();
    [CompilerGeneratedAttribute]
public void set_SentToEmail(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_NewExpirationDate();
    [CompilerGeneratedAttribute]
public void set_NewExpirationDate(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.LicenseStatus : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicensedTo>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<LicenseAttribute, object> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <FirstServerStartDate>k__BackingField;
    public Nullable`1<Guid> Id { get; public set; }
    public string LicensedTo { get; public set; }
    public Dictionary`2<LicenseAttribute, object> Attributes { get; public set; }
    public string ErrorMessage { get; public set; }
    public string Status { get; }
    public DateTime FirstServerStartDate { get; public set; }
    public string FormattedExpiration { get; }
    public bool Expired { get; }
    public double Ratio { get; }
    private int MaxClusterSizeInternal { get; }
    public LicenseType Type { get; }
    public Version Version { get; }
    public bool UpgradeRequired { get; }
    public Nullable`1<DateTime> Expiration { get; }
    public int MaxMemory { get; }
    public int MaxCores { get; }
    public Nullable`1<int> MaxCoresPerNode { get; }
    public int MaxClusterSize { get; }
    public bool IsIsv { get; }
    public bool HasEncryption { get; }
    public bool HasSnmpMonitoring { get; }
    public bool DistributedCluster { get; }
    public bool HasSnapshotBackups { get; }
    public bool HasCloudBackups { get; }
    public bool HasDynamicNodesDistribution { get; }
    public bool HasExternalReplication { get; }
    public bool HasDelayedExternalReplication { get; }
    public bool HasRavenEtl { get; }
    public bool HasSqlEtl { get; }
    public bool HasHighlyAvailableTasks { get; }
    public bool HasPullReplicationAsHub { get; }
    public bool HasPullReplicationAsSink { get; }
    public bool HasEncryptedBackups { get; }
    public bool CanAutoRenewLetsEncryptCertificate { get; }
    public bool IsCloud { get; }
    public bool HasDocumentsCompression { get; }
    public bool HasTimeSeriesRollupsAndRetention { get; }
    public bool HasAdditionalAssembliesFromNuGet { get; }
    public bool HasMonitoringEndpoints { get; }
    public bool HasOlapEtl { get; }
    public bool HasReadOnlyCertificates { get; }
    public bool HasTcpDataCompression { get; }
    public bool HasConcurrentDataSubscriptions { get; }
    public bool HasElasticSearchEtl { get; }
    public bool HasQueueEtl { get; }
    public bool HasPowerBI { get; }
    public bool HasPostgreSqlIntegration { get; }
    public bool HasServerWideBackups { get; }
    public bool HasServerWideExternalReplications { get; }
    public bool HasServerWideCustomSorters { get; }
    public bool HasServerWideAnalyzers { get; }
    public bool HasIndexCleanup { get; }
    public bool HasPeriodicBackup { get; }
    public bool HasClientConfiguration { get; }
    public bool HasStudioConfiguration { get; }
    public bool HasQueueSink { get; }
    public bool HasDataArchival { get; }
    public bool HasRevisionsInSubscriptions { get; }
    public bool HasMultiNodeSharding { get; }
    public bool CanSetupDefaultRevisionsConfiguration { get; }
    public Nullable`1<int> MaxNumberOfRevisionsToKeep { get; }
    public Nullable`1<int> MaxNumberOfRevisionAgeToKeepInDays { get; }
    public Nullable`1<int> MinPeriodForExpirationInHours { get; }
    public Nullable`1<int> MinPeriodForRefreshInHours { get; }
    public Nullable`1<int> MaxReplicationFactorForSharding { get; }
    public Nullable`1<int> MaxNumberOfStaticIndexesPerDatabase { get; }
    public Nullable`1<int> MaxNumberOfStaticIndexesPerCluster { get; }
    public Nullable`1<int> MaxNumberOfAutoIndexesPerDatabase { get; }
    public Nullable`1<int> MaxNumberOfAutoIndexesPerCluster { get; }
    public Nullable`1<int> MaxNumberOfSubscriptionsPerDatabase { get; }
    public Nullable`1<int> MaxNumberOfSubscriptionsPerCluster { get; }
    public Nullable`1<int> MaxNumberOfCustomSortersPerDatabase { get; }
    public Nullable`1<int> MaxNumberOfCustomSortersPerCluster { get; }
    public Nullable`1<int> MaxNumberOfCustomAnalyzersPerDatabase { get; }
    public Nullable`1<int> MaxNumberOfCustomAnalyzersPerCluster { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public string get_LicensedTo();
    [CompilerGeneratedAttribute]
public void set_LicensedTo(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<LicenseAttribute, object> get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(Dictionary`2<LicenseAttribute, object> value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    public string get_Status();
    [CompilerGeneratedAttribute]
public DateTime get_FirstServerStartDate();
    [CompilerGeneratedAttribute]
public void set_FirstServerStartDate(DateTime value);
    private T GetValue(LicenseAttribute attributeName, T agplValue);
    private bool Enabled(LicenseAttribute attribute);
    public bool CanActivate(Nullable`1& canBeActivateUntil);
    public string get_FormattedExpiration();
    public bool get_Expired();
    public double get_Ratio();
    private int get_MaxClusterSizeInternal();
    public LicenseType get_Type();
    public Version get_Version();
    public bool get_UpgradeRequired();
    public Nullable`1<DateTime> get_Expiration();
    public int get_MaxMemory();
    public int get_MaxCores();
    public Nullable`1<int> get_MaxCoresPerNode();
    public int get_MaxClusterSize();
    public bool get_IsIsv();
    public bool get_HasEncryption();
    public bool get_HasSnmpMonitoring();
    public bool get_DistributedCluster();
    public bool get_HasSnapshotBackups();
    public bool get_HasCloudBackups();
    public bool get_HasDynamicNodesDistribution();
    public bool get_HasExternalReplication();
    public bool get_HasDelayedExternalReplication();
    public bool get_HasRavenEtl();
    public bool get_HasSqlEtl();
    public bool get_HasHighlyAvailableTasks();
    public bool get_HasPullReplicationAsHub();
    public bool get_HasPullReplicationAsSink();
    public bool get_HasEncryptedBackups();
    public bool get_CanAutoRenewLetsEncryptCertificate();
    public bool get_IsCloud();
    public bool get_HasDocumentsCompression();
    public bool get_HasTimeSeriesRollupsAndRetention();
    public bool get_HasAdditionalAssembliesFromNuGet();
    public bool get_HasMonitoringEndpoints();
    public bool get_HasOlapEtl();
    public bool get_HasReadOnlyCertificates();
    public bool get_HasTcpDataCompression();
    public bool get_HasConcurrentDataSubscriptions();
    public bool get_HasElasticSearchEtl();
    public bool get_HasQueueEtl();
    public bool get_HasPowerBI();
    public bool get_HasPostgreSqlIntegration();
    public bool get_HasServerWideBackups();
    public bool get_HasServerWideExternalReplications();
    public bool get_HasServerWideCustomSorters();
    public bool get_HasServerWideAnalyzers();
    public bool get_HasIndexCleanup();
    public bool get_HasPeriodicBackup();
    public bool get_HasClientConfiguration();
    public bool get_HasStudioConfiguration();
    public bool get_HasQueueSink();
    public bool get_HasDataArchival();
    public bool get_HasRevisionsInSubscriptions();
    public bool get_HasMultiNodeSharding();
    public bool get_CanSetupDefaultRevisionsConfiguration();
    public Nullable`1<int> get_MaxNumberOfRevisionsToKeep();
    public Nullable`1<int> get_MaxNumberOfRevisionAgeToKeepInDays();
    public Nullable`1<int> get_MinPeriodForExpirationInHours();
    public Nullable`1<int> get_MinPeriodForRefreshInHours();
    public Nullable`1<int> get_MaxReplicationFactorForSharding();
    public Nullable`1<int> get_MaxNumberOfStaticIndexesPerDatabase();
    public Nullable`1<int> get_MaxNumberOfStaticIndexesPerCluster();
    public Nullable`1<int> get_MaxNumberOfAutoIndexesPerDatabase();
    public Nullable`1<int> get_MaxNumberOfAutoIndexesPerCluster();
    public Nullable`1<int> get_MaxNumberOfSubscriptionsPerDatabase();
    public Nullable`1<int> get_MaxNumberOfSubscriptionsPerCluster();
    public Nullable`1<int> get_MaxNumberOfCustomSortersPerDatabase();
    public Nullable`1<int> get_MaxNumberOfCustomSortersPerCluster();
    public Nullable`1<int> get_MaxNumberOfCustomAnalyzersPerDatabase();
    public Nullable`1<int> get_MaxNumberOfCustomAnalyzersPerCluster();
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.LicenseStorage : object {
    private StorageEnvironment _environment;
    private TransactionContextPool _contextPool;
    private TableSchema _licenseStorageSchema;
    private static string FirstServerStartDateKey;
    public void Initialize(StorageEnvironment environment, TransactionContextPool contextPool);
    public void SetFirstServerStartDate(DateTime date);
    public Nullable`1<DateTime> GetFirstServerStartDate();
    public void SetBuildInfo(BuildNumber buildNumber);
    public BuildNumber GetBuildInfo();
    private static BlittableJsonReaderObject Read(JsonOperationContext context, TableValueReader& reader);
}
public class Raven.Server.Commercial.LicenseSupportInfo : object {
    [CompilerGeneratedAttribute]
private Status <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <EndsAt>k__BackingField;
    public Status Status { get; public set; }
    public Nullable`1<DateTimeOffset> EndsAt { get; public set; }
    [CompilerGeneratedAttribute]
public Status get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(Status value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_EndsAt();
    [CompilerGeneratedAttribute]
public void set_EndsAt(Nullable`1<DateTimeOffset> value);
    public DynamicJsonValue ToJson();
}
public enum Raven.Server.Commercial.LicenseType : Enum {
    public int value__;
    public static LicenseType Invalid;
    public static LicenseType None;
    public static LicenseType Community;
    public static LicenseType Reserved;
    public static LicenseType Professional;
    public static LicenseType Enterprise;
    public static LicenseType Developer;
    public static LicenseType Essential;
}
public static class Raven.Server.Commercial.LicenseValidator : object {
    private static int TypeBitsToShift;
    private static int Mask;
    private static LicenseAttribute[] Terms;
    private static LicenseValidator();
    private static DateTime FromDosDate(ushort number);
    private static Byte[] GetBytesFromBase64String(string str);
    public static Dictionary`2<LicenseAttribute, object> Validate(License licenseKey, RSAParameters rsaParameters);
    private static bool TryGetTermIndexAndType(BinaryReader br, LicenseAttribute& licenseProperty, ValueType& type);
    private static Keys ExtractKeys(IEnumerable`1<string> keys);
}
public class Raven.Server.Commercial.NodeDetails : object {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AssignedCores>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfCores>k__BackingField;
    [CompilerGeneratedAttribute]
private double <InstalledMemoryInGb>k__BackingField;
    [CompilerGeneratedAttribute]
private double <UsableMemoryInGb>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildNumber <BuildInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private OsInfo <OsInfo>k__BackingField;
    public string NodeTag { get; public set; }
    public int AssignedCores { get; public set; }
    public int NumberOfCores { get; public set; }
    public double InstalledMemoryInGb { get; public set; }
    public double UsableMemoryInGb { get; public set; }
    public BuildNumber BuildInfo { get; public set; }
    public OsInfo OsInfo { get; public set; }
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public int get_AssignedCores();
    [CompilerGeneratedAttribute]
public void set_AssignedCores(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfCores();
    [CompilerGeneratedAttribute]
public void set_NumberOfCores(int value);
    [CompilerGeneratedAttribute]
public double get_InstalledMemoryInGb();
    [CompilerGeneratedAttribute]
public void set_InstalledMemoryInGb(double value);
    [CompilerGeneratedAttribute]
public double get_UsableMemoryInGb();
    [CompilerGeneratedAttribute]
public void set_UsableMemoryInGb(double value);
    [CompilerGeneratedAttribute]
public BuildNumber get_BuildInfo();
    [CompilerGeneratedAttribute]
public void set_BuildInfo(BuildNumber value);
    [CompilerGeneratedAttribute]
public OsInfo get_OsInfo();
    [CompilerGeneratedAttribute]
public void set_OsInfo(OsInfo value);
}
public class Raven.Server.Commercial.NodeInfo : object {
    [CompilerGeneratedAttribute]
private string <PublicServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublicTcpServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TcpPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExternalIpAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExternalPort>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExternalTcpPort>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Addresses>k__BackingField;
    public string PublicServerUrl { get; public set; }
    public string PublicTcpServerUrl { get; public set; }
    public int Port { get; public set; }
    public int TcpPort { get; public set; }
    public string ExternalIpAddress { get; public set; }
    public int ExternalPort { get; public set; }
    public int ExternalTcpPort { get; public set; }
    public List`1<string> Addresses { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PublicServerUrl();
    [CompilerGeneratedAttribute]
public void set_PublicServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_PublicTcpServerUrl();
    [CompilerGeneratedAttribute]
public void set_PublicTcpServerUrl(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public int get_TcpPort();
    [CompilerGeneratedAttribute]
public void set_TcpPort(int value);
    [CompilerGeneratedAttribute]
public string get_ExternalIpAddress();
    [CompilerGeneratedAttribute]
public void set_ExternalIpAddress(string value);
    [CompilerGeneratedAttribute]
public int get_ExternalPort();
    [CompilerGeneratedAttribute]
public void set_ExternalPort(int value);
    [CompilerGeneratedAttribute]
public int get_ExternalTcpPort();
    [CompilerGeneratedAttribute]
public void set_ExternalTcpPort(int value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Addresses();
    [CompilerGeneratedAttribute]
public void set_Addresses(List`1<string> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.NodeLicenseLimits : object {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private DetailsPerNode <DetailsPerNode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LicensedCores>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxCoresPerNode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AllNodes>k__BackingField;
    public string NodeTag { get; public set; }
    public DetailsPerNode DetailsPerNode { get; public set; }
    public int LicensedCores { get; public set; }
    public Nullable`1<int> MaxCoresPerNode { get; public set; }
    public List`1<string> AllNodes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public DetailsPerNode get_DetailsPerNode();
    [CompilerGeneratedAttribute]
public void set_DetailsPerNode(DetailsPerNode value);
    [CompilerGeneratedAttribute]
public int get_LicensedCores();
    [CompilerGeneratedAttribute]
public void set_LicensedCores(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxCoresPerNode();
    [CompilerGeneratedAttribute]
public void set_MaxCoresPerNode(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_AllNodes();
    [CompilerGeneratedAttribute]
public void set_AllNodes(List`1<string> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public static class Raven.Server.Commercial.OsInfoExtensions : object {
    private static Logger Logger;
    private static OsInfoExtensions();
    public static OsInfo GetOsInfo();
    private static OsInfo GetWindowsOsInfo();
    private static OsInfo GetDefaultWindowsOsInformation();
    private static bool IsOS(int os);
    private static bool VerifyVersionInfoW(OSVERSIONINFOEXW& lpVersionInformation, UInt32 dwTypeMask, ulong dwlConditionMask);
    private static ulong VerSetConditionMask(ulong dwlConditionMask, UInt32 dwTypeBitMask, byte dwConditionMask);
    private static OsInfo GetMacOsInfo();
    private static string GetMacOsName(string osInfoVersion);
    private static OsInfo GetLinuxOsInfo();
    private static string GetVersionByDistro(string name);
    private static string ReadAllTextWithoutError(string path);
    private static string ReadBuildVersion();
    [CompilerGeneratedAttribute]
internal static bool <GetDefaultWindowsOsInformation>g__IsWindowsServer|3_0();
}
public class Raven.Server.Commercial.RegistrationInfo : object {
    [CompilerGeneratedAttribute]
private License <License>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Challenge>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RegistrationNodeInfo> <SubDomains>k__BackingField;
    public License License { get; public set; }
    public string Domain { get; public set; }
    public string RootDomain { get; public set; }
    public string Challenge { get; public set; }
    public List`1<RegistrationNodeInfo> SubDomains { get; public set; }
    [CompilerGeneratedAttribute]
public License get_License();
    [CompilerGeneratedAttribute]
public void set_License(License value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_RootDomain();
    [CompilerGeneratedAttribute]
public void set_RootDomain(string value);
    [CompilerGeneratedAttribute]
public string get_Challenge();
    [CompilerGeneratedAttribute]
public void set_Challenge(string value);
    [CompilerGeneratedAttribute]
public List`1<RegistrationNodeInfo> get_SubDomains();
    [CompilerGeneratedAttribute]
public void set_SubDomains(List`1<RegistrationNodeInfo> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.RegistrationNodeInfo : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Ips>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubDomain>k__BackingField;
    public List`1<string> Ips { get; public set; }
    public string SubDomain { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Ips();
    [CompilerGeneratedAttribute]
public void set_Ips(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_SubDomain();
    [CompilerGeneratedAttribute]
public void set_SubDomain(string value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.RegistrationResult : object {
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    public string Status { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(string value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.RSAPublicParameters : object {
    [CompilerGeneratedAttribute]
private RSAKeyValue <RsaKeyValue>k__BackingField;
    public RSAKeyValue RsaKeyValue { get; public set; }
    [CompilerGeneratedAttribute]
public RSAKeyValue get_RsaKeyValue();
    [CompilerGeneratedAttribute]
public void set_RsaKeyValue(RSAKeyValue value);
}
public class Raven.Server.Commercial.SetupInfo : SetupInfoBase {
    [CompilerGeneratedAttribute]
private bool <RegisterClientCert>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ClientCertNotAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private License <License>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Email>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public bool RegisterClientCert { get; public set; }
    public Nullable`1<DateTime> ClientCertNotAfter { get; public set; }
    public License License { get; public set; }
    public string Email { get; public set; }
    public string Domain { get; public set; }
    public string RootDomain { get; public set; }
    public string Certificate { get; public set; }
    public string Password { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RegisterClientCert();
    [CompilerGeneratedAttribute]
public void set_RegisterClientCert(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ClientCertNotAfter();
    [CompilerGeneratedAttribute]
public void set_ClientCertNotAfter(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public License get_License();
    [CompilerGeneratedAttribute]
public void set_License(License value);
    [CompilerGeneratedAttribute]
public string get_Email();
    [CompilerGeneratedAttribute]
public void set_Email(string value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_RootDomain();
    [CompilerGeneratedAttribute]
public void set_RootDomain(string value);
    [CompilerGeneratedAttribute]
public string get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    public virtual DynamicJsonValue ToJson();
    public virtual void ValidateInfo(CreateSetupPackageParameters parameters);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupInfo/<GenerateZipFile>d__34")]
public virtual Task`1<Byte[]> GenerateZipFile(CreateSetupPackageParameters parameters);
    public X509Certificate2 GetX509Certificate();
}
public abstract class Raven.Server.Commercial.SetupInfoBase : object {
    [CompilerGeneratedAttribute]
private bool <EnableExperimentalFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private StudioEnvironment <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, NodeInfo> <NodeSetupInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalNodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ZipOnly>k__BackingField;
    public bool EnableExperimentalFeatures { get; public set; }
    public StudioEnvironment Environment { get; public set; }
    public Dictionary`2<string, NodeInfo> NodeSetupInfos { get; public set; }
    public string LocalNodeTag { get; public set; }
    public bool ZipOnly { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EnableExperimentalFeatures();
    [CompilerGeneratedAttribute]
public void set_EnableExperimentalFeatures(bool value);
    [CompilerGeneratedAttribute]
public StudioEnvironment get_Environment();
    [CompilerGeneratedAttribute]
public void set_Environment(StudioEnvironment value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, NodeInfo> get_NodeSetupInfos();
    [CompilerGeneratedAttribute]
public void set_NodeSetupInfos(Dictionary`2<string, NodeInfo> value);
    [CompilerGeneratedAttribute]
public string get_LocalNodeTag();
    [CompilerGeneratedAttribute]
public void set_LocalNodeTag(string value);
    [CompilerGeneratedAttribute]
public bool get_ZipOnly();
    [CompilerGeneratedAttribute]
public void set_ZipOnly(bool value);
    public abstract virtual Task`1<Byte[]> GenerateZipFile(CreateSetupPackageParameters parameters);
    public abstract virtual void ValidateInfo(CreateSetupPackageParameters parameters);
    public virtual DynamicJsonValue ToJson();
}
public static class Raven.Server.Commercial.SetupManager : object {
    internal static Logger Logger;
    private static SetupManager();
    private static string BuildHostName(string nodeTag, string userDomain, string rootDomain);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<LetsEncryptAgreement>d__2")]
public static Task`1<string> LetsEncryptAgreement(string email, ServerStore serverStore);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<SetupUnsecuredTask>d__3")]
public static Task`1<IOperationResult> SetupUnsecuredTask(Action`1<IOperationProgress> onProgress, UnsecuredSetupInfo unsecuredSetupInfo, ServerStore serverStore, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<SetupSecuredTask>d__4")]
public static Task`1<IOperationResult> SetupSecuredTask(Action`1<IOperationProgress> onProgress, SetupInfo setupInfo, ServerStore serverStore, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<RefreshLetsEncryptTask>d__5")]
public static Task`1<X509Certificate2> RefreshLetsEncryptTask(SetupInfo setupInfo, ServerStore serverStore, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<ContinueUnsecuredClusterSetupTask>d__6")]
public static Task`1<IOperationResult> ContinueUnsecuredClusterSetupTask(Action`1<IOperationProgress> onProgress, ContinueSetupInfo continueSetupInfo, ServerStore serverStore, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<ContinueClusterSetupTask>d__7")]
public static Task`1<IOperationResult> ContinueClusterSetupTask(Action`1<IOperationProgress> onProgress, ContinueSetupInfo continueSetupInfo, ServerStore serverStore, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<GetUpdatedLicenseStatus>d__8")]
public static Task`1<LicenseStatus> GetUpdatedLicenseStatus(ServerStore serverStore, License currentLicense, Reference`1<License> updatedLicense);
    private static void AssertNoClusterDefined(ServerStore serverStore);
    [DoesNotReturnAttribute]
private static void LogErrorAndThrow(Action`1<IOperationProgress> onProgress, SetupProgressAndResult progress, string msg, Exception e);
    internal static Task ValidateUnsecuredServerCanRunWithSuppliedSettings(UnsecuredSetupInfo unsecuredSetupInfo, ServerStore serverStore, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<ValidateServerCanRunWithSuppliedSettings>d__12")]
internal static Task ValidateServerCanRunWithSuppliedSettings(SetupInfo setupInfo, ServerStore serverStore, SetupMode setupMode, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<SetupLetsEncryptTask>d__13")]
public static Task`1<IOperationResult> SetupLetsEncryptTask(Action`1<IOperationProgress> onProgress, SetupInfo setupInfo, ServerStore serverStore, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<CompleteSecuredConfigurationForNewNode>d__14")]
private static Task CompleteSecuredConfigurationForNewNode(Action`1<IOperationProgress> onProgress, SetupProgressAndResult progress, ContinueSetupInfo continueSetupInfo, BlittableJsonReaderObject settingsJsonObject, Byte[] serverCertBytes, X509Certificate2 serverCert, X509Certificate2 clientCert, ServerStore serverStore, string firstNodeTag, Dictionary`2<string, string> otherNodesUrls, License license, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<CompleteUnsecuredConfigurationForNewNode>d__15")]
private static Task CompleteUnsecuredConfigurationForNewNode(Action`1<IOperationProgress> onProgress, SetupProgressAndResult progress, ContinueSetupInfo continueSetupInfo, BlittableJsonReaderObject settingsJsonObject, ServerStore serverStore, string firstNodeTag, Dictionary`2<string, string> otherNodesUrls, License license, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<CompleteClusterConfigurationUnsecuredSetup>d__16")]
private static Task`1<CompleteClusterConfigurationResult> CompleteClusterConfigurationUnsecuredSetup(Action`1<IOperationProgress> onProgress, SetupProgressAndResult progress, SetupMode setupMode, UnsecuredSetupInfo unsecuredSetupInfo, ServerStore serverStore, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<CompleteClusterConfigurationAndGetSettingsZipSecuredSetup>d__17")]
private static Task`1<CompleteClusterConfigurationResult> CompleteClusterConfigurationAndGetSettingsZipSecuredSetup(Action`1<IOperationProgress> onProgress, SetupProgressAndResult progress, SetupMode setupMode, SetupInfo setupInfo, ServerStore serverStore, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<GenerateCertificateTask>d__18")]
public static Task`1<Byte[]> GenerateCertificateTask(string name, ServerStore serverStore, SetupInfo setupInfo);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupManager/<DeleteAllExistingCertificates>d__19")]
internal static Task DeleteAllExistingCertificates(ServerStore serverStore);
    public static BlittableJsonReaderObject ExtractCertificatesAndSettingsJsonFromZip(Byte[] zipBytes, string currentNodeTag, JsonOperationContext context, Byte[]& certBytes, X509Certificate2& serverCert, X509Certificate2& clientCert, String& firstNodeTag, Dictionary`2& otherNodesUrls, License& license, bool isSecured);
}
public enum Raven.Server.Commercial.SetupMode : Enum {
    public int value__;
    public static SetupMode None;
    public static SetupMode Initial;
    public static SetupMode LetsEncrypt;
    public static SetupMode Secured;
    public static SetupMode Unsecured;
}
public class Raven.Server.Commercial.SetupParameters : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FixedServerPortNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FixedServerTcpPortNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDocker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DockerHostname>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAws>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAzure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningOnPosix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningOnMacOsx>k__BackingField;
    private static string AzureUrl;
    private static string AwsUrl;
    private static Lazy`1<RavenHttpClient> HttpClient;
    public Nullable`1<int> FixedServerPortNumber { get; public set; }
    public Nullable`1<int> FixedServerTcpPortNumber { get; public set; }
    public bool IsDocker { get; public set; }
    public string DockerHostname { get; public set; }
    public bool IsAws { get; public set; }
    public bool IsAzure { get; public set; }
    public bool RunningOnPosix { get; public set; }
    public bool RunningOnMacOsx { get; public set; }
    private static SetupParameters();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FixedServerPortNumber();
    [CompilerGeneratedAttribute]
public void set_FixedServerPortNumber(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FixedServerTcpPortNumber();
    [CompilerGeneratedAttribute]
public void set_FixedServerTcpPortNumber(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_IsDocker();
    [CompilerGeneratedAttribute]
public void set_IsDocker(bool value);
    [CompilerGeneratedAttribute]
public string get_DockerHostname();
    [CompilerGeneratedAttribute]
public void set_DockerHostname(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAws();
    [CompilerGeneratedAttribute]
public void set_IsAws(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAzure();
    [CompilerGeneratedAttribute]
public void set_IsAzure(bool value);
    [CompilerGeneratedAttribute]
public bool get_RunningOnPosix();
    [CompilerGeneratedAttribute]
public void set_RunningOnPosix(bool value);
    [CompilerGeneratedAttribute]
public bool get_RunningOnMacOsx();
    [CompilerGeneratedAttribute]
public void set_RunningOnMacOsx(bool value);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupParameters/<Get>d__35")]
public static Task`1<SetupParameters> Get(ServerStore serverStore);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupParameters/<DetectIfRunningInAws>d__36")]
private static Task`1<bool> DetectIfRunningInAws();
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupParameters/<DetectIfRunningInAzure>d__37")]
private static Task`1<bool> DetectIfRunningInAzure();
    private static void DetermineFixedPortNumber(ServerStore serverStore, SetupParameters result);
    private static void DetermineFixedTcpPortNumber(ServerStore serverStore, SetupParameters result);
}
public class Raven.Server.Commercial.SetupProgressAndResult : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<ValueTuple`2<string, Exception>> _onMessage;
    [CompilerGeneratedAttribute]
private long <Processed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Total>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Readme>k__BackingField;
    public ConcurrentQueue`1<string> Messages;
    public Byte[] SettingsZipFile;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public long Processed { get; public set; }
    public long Total { get; public set; }
    public string Certificate { get; public set; }
    public string Readme { get; public set; }
    public string Message { get; private set; }
    private bool Raven.Client.Documents.Operations.IOperationProgress.CanMerge { get; }
    private bool Raven.Client.Documents.Operations.IOperationResult.CanMerge { get; }
    public bool ShouldPersist { get; }
    public SetupProgressAndResult(Action`1<ValueTuple`2<string, Exception>> onMessage);
    [CompilerGeneratedAttribute]
public long get_Processed();
    [CompilerGeneratedAttribute]
public void set_Processed(long value);
    [CompilerGeneratedAttribute]
public long get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(long value);
    [CompilerGeneratedAttribute]
public string get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(string value);
    [CompilerGeneratedAttribute]
public string get_Readme();
    [CompilerGeneratedAttribute]
public void set_Readme(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    public sealed virtual DynamicJsonValue ToJson();
    private sealed virtual override IOperationProgress Raven.Client.Documents.Operations.IOperationProgress.Clone();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationProgress.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationResult.MergeWith(IOperationResult result);
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationResult.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationProgress.MergeWith(IOperationProgress progress);
    public void AddWarning(string message);
    public void AddInfo(string message);
    public void AddError(string message, Exception ex);
    private void AddMessage(string type, string message, Exception ex);
    public sealed virtual bool get_ShouldPersist();
}
public class Raven.Server.Commercial.SetupSettings : object {
    public Node[] Nodes;
    public DynamicJsonValue ToJson();
}
public enum Raven.Server.Commercial.SetupStage : Enum {
    public int value__;
    public static SetupStage Initial;
    public static SetupStage Agreement;
    public static SetupStage Setup;
    public static SetupStage Validation;
    public static SetupStage GenerateCertificate;
    public static SetupStage Finish;
}
public class Raven.Server.Commercial.SetupWizard.CompleteAuthorizationAndGetCertificateParameters : object {
    public Action OnValidationSuccessful;
    public SetupInfo SetupInfo;
    public LetsEncryptClient Client;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<string, CachedCertificateResult> ChallengeResult;
    public CancellationToken Token;
    public RSA ExistingPrivateKey;
}
public static class Raven.Server.Commercial.SetupWizard.LetsEncryptSetupUtils : object {
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupWizard.LetsEncryptSetupUtils/<Setup>d__0")]
public static Task`1<Byte[]> Setup(SetupInfo setupInfo, SetupProgressAndResult progress, bool registerTcpDnsRecords, string acmeUrl, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupWizard.LetsEncryptSetupUtils/<InitialLetsEncryptChallenge>d__1")]
public static Task`1<ValueTuple`2<string, CachedCertificateResult>> InitialLetsEncryptChallenge(SetupInfo setupInfo, LetsEncryptClient client, CancellationToken token);
}
public class Raven.Server.Commercial.SetupWizard.OwnCertificateSetupUtils : object {
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupWizard.OwnCertificateSetupUtils/<Setup>d__0")]
public static Task`1<Byte[]> Setup(SetupInfo setupInfo, SetupProgressAndResult progress, CancellationToken token);
}
public static class Raven.Server.Commercial.SetupWizard.SetupWizardUtils : object {
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupWizard.SetupWizardUtils/<CompleteClusterConfigurationSecuredSetup>d__0")]
public static Task`1<CompleteClusterConfigurationResult> CompleteClusterConfigurationSecuredSetup(CompleteClusterConfigurationParameters parameters);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupWizard.SetupWizardUtils/<CompleteClusterConfigurationUnsecuredSetup>d__1")]
public static Task`1<CompleteClusterConfigurationResult> CompleteClusterConfigurationUnsecuredSetup(CompleteClusterConfigurationParameters parameters);
    public static bool IsValidNodeTag(string str);
}
public class Raven.Server.Commercial.SetupWizard.UnsecuredSetupUtils : object {
    [AsyncStateMachineAttribute("Raven.Server.Commercial.SetupWizard.UnsecuredSetupUtils/<Setup>d__0")]
public static Task`1<Byte[]> Setup(UnsecuredSetupInfo unsecuredSetupInfo, SetupProgressAndResult progress, CancellationToken token);
}
public enum Raven.Server.Commercial.Status : Enum {
    public int value__;
    public static Status NoSupport;
    public static Status PartialSupport;
    public static Status ProfessionalSupport;
    public static Status ProductionSupport;
    public static Status LicenseNotFound;
    public static Status InvalidStateSupportNotFound;
}
public class Raven.Server.Commercial.SubDomainAndIps : object {
    [CompilerGeneratedAttribute]
private string <SubDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Ips>k__BackingField;
    public string SubDomain { get; public set; }
    public List`1<string> Ips { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SubDomain();
    [CompilerGeneratedAttribute]
public void set_SubDomain(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Ips();
    [CompilerGeneratedAttribute]
public void set_Ips(List`1<string> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.UnsecuredSetupInfo : SetupInfoBase {
    public virtual void ValidateInfo(CreateSetupPackageParameters parameters);
    [AsyncStateMachineAttribute("Raven.Server.Commercial.UnsecuredSetupInfo/<GenerateZipFile>d__1")]
public virtual Task`1<Byte[]> GenerateZipFile(CreateSetupPackageParameters parameters);
}
public class Raven.Server.Commercial.UserDomainsAndLicenseInfo : object {
    [CompilerGeneratedAttribute]
private UserDomainsWithIps <UserDomainsWithIps>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxClusterSize>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseType <LicenseType>k__BackingField;
    public UserDomainsWithIps UserDomainsWithIps { get; public set; }
    public int MaxClusterSize { get; public set; }
    public LicenseType LicenseType { get; public set; }
    [CompilerGeneratedAttribute]
public UserDomainsWithIps get_UserDomainsWithIps();
    [CompilerGeneratedAttribute]
public void set_UserDomainsWithIps(UserDomainsWithIps value);
    [CompilerGeneratedAttribute]
public int get_MaxClusterSize();
    [CompilerGeneratedAttribute]
public void set_MaxClusterSize(int value);
    [CompilerGeneratedAttribute]
public LicenseType get_LicenseType();
    [CompilerGeneratedAttribute]
public void set_LicenseType(LicenseType value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.UserDomainsResult : object {
    [CompilerGeneratedAttribute]
private String[] <Emails>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <RootDomains>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <Domains>k__BackingField;
    public String[] Emails { get; public set; }
    public String[] RootDomains { get; public set; }
    public Dictionary`2<string, List`1<string>> Domains { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Emails();
    [CompilerGeneratedAttribute]
public void set_Emails(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_RootDomains();
    [CompilerGeneratedAttribute]
public void set_RootDomains(String[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_Domains();
    [CompilerGeneratedAttribute]
public void set_Domains(Dictionary`2<string, List`1<string>> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.UserDomainsWithIps : object {
    [CompilerGeneratedAttribute]
private String[] <Emails>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <RootDomains>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<SubDomainAndIps>> <Domains>k__BackingField;
    public String[] Emails { get; public set; }
    public String[] RootDomains { get; public set; }
    public Dictionary`2<string, List`1<SubDomainAndIps>> Domains { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Emails();
    [CompilerGeneratedAttribute]
public void set_Emails(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_RootDomains();
    [CompilerGeneratedAttribute]
public void set_RootDomains(String[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<SubDomainAndIps>> get_Domains();
    [CompilerGeneratedAttribute]
public void set_Domains(Dictionary`2<string, List`1<SubDomainAndIps>> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Commercial.UserRegistrationInfo : object {
    [CompilerGeneratedAttribute]
private string <FirstName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Email>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Company>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildNumber <BuildInfo>k__BackingField;
    public string FirstName { get; public set; }
    public string LastName { get; public set; }
    public string Email { get; public set; }
    public string Company { get; public set; }
    public BuildNumber BuildInfo { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FirstName();
    [CompilerGeneratedAttribute]
public void set_FirstName(string value);
    [CompilerGeneratedAttribute]
public string get_LastName();
    [CompilerGeneratedAttribute]
public void set_LastName(string value);
    [CompilerGeneratedAttribute]
public string get_Email();
    [CompilerGeneratedAttribute]
public void set_Email(string value);
    [CompilerGeneratedAttribute]
public string get_Company();
    [CompilerGeneratedAttribute]
public void set_Company(string value);
    [CompilerGeneratedAttribute]
public BuildNumber get_BuildInfo();
    [CompilerGeneratedAttribute]
public void set_BuildInfo(BuildNumber value);
}
[AttributeUsageAttribute("128")]
public class Raven.Server.Config.Attributes.ConfigurationEntryAttribute : Attribute {
    public string Key;
    public int Order;
    public bool SetDefaultValueIfNeeded;
    public bool IsSecured;
    public ConfigurationEntryScope Scope;
    public ConfigurationEntryAttribute(string key, ConfigurationEntryScope scope, int order, bool setDefaultValueIfNeeded, bool isSecured);
}
public enum Raven.Server.Config.Attributes.ConfigurationEntryScope : Enum {
    public int value__;
    public static ConfigurationEntryScope ServerWideOnly;
    public static ConfigurationEntryScope ServerWideOrPerDatabase;
    public static ConfigurationEntryScope ServerWideOrPerDatabaseOrPerIndex;
}
[AttributeUsageAttribute("128")]
public class Raven.Server.Config.Attributes.MinValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Int32Value>k__BackingField;
    public int Int32Value { get; public set; }
    public MinValueAttribute(int value);
    [CompilerGeneratedAttribute]
public int get_Int32Value();
    [CompilerGeneratedAttribute]
public void set_Int32Value(int value);
}
[AttributeUsageAttribute("128")]
public class Raven.Server.Config.Attributes.SizeUnitAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SizeUnit <Unit>k__BackingField;
    public SizeUnit Unit { get; public set; }
    public SizeUnitAttribute(SizeUnit unit);
    [CompilerGeneratedAttribute]
public SizeUnit get_Unit();
    [CompilerGeneratedAttribute]
public void set_Unit(SizeUnit value);
}
[AttributeUsageAttribute("128")]
public class Raven.Server.Config.Attributes.TimeUnitAttribute : Attribute {
    [CompilerGeneratedAttribute]
private TimeUnit <Unit>k__BackingField;
    public TimeUnit Unit { get; public set; }
    public TimeUnitAttribute(TimeUnit unit);
    [CompilerGeneratedAttribute]
public TimeUnit get_Unit();
    [CompilerGeneratedAttribute]
public void set_Unit(TimeUnit value);
}
[ConfigurationCategoryAttribute("1")]
public class Raven.Server.Config.Categories.BackupConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private PathSetting <LocalRootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private PathSetting <TempPath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AllowedDestinations>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AllowedAwsRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxNumberOfConcurrentBackups>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <ConcurrentBackupsDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <LowMemoryBackupDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CloudStorageOperationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AzureLegacy>k__BackingField;
    [CompilerGeneratedAttribute]
private BackupCompressionAlgorithm <CompressionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private SnapshotBackupCompressionAlgorithm <SnapshotCompressionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <SnapshotCompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MoveToNewResponsibleNodeGracePeriod>k__BackingField;
    internal static HashSet`1<string> _allDestinations;
    private static string _noneDestination;
    [DescriptionAttribute("Local backups can only be created under this root path.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Backup.LocalRootPath", "0", "21", "True", "False")]
public PathSetting LocalRootPath { get; public set; }
    [DescriptionAttribute("You can use this setting to specify a different path to the temporary backup files (used when the local destination isn't specified). By default it is empty, which means that temporary files will be created at the same location as the data file.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Backup.TempPath", "1", "26", "True", "False")]
public PathSetting TempPath { get; public set; }
    [DescriptionAttribute("Semicolon seperated list of allowed backup destinations. If not specified, all destinations are allowed. Possible values: None, Local, Azure, AmazonGlacier, AmazonS3,GoogleCloud , FTP. Example list: "Local;AmazonGlacier;AmazonS3".")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Backup.AllowedDestinations", "0", "31", "True", "False")]
public String[] AllowedDestinations { get; public set; }
    [DescriptionAttribute("Semicolon seperated list of allowed AWS regions. If not specified, all regions are allowed. Example list: "ap-northeast-1;ap-northeast-2;ap-south-1".")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Backup.AllowedAwsRegions", "0", "36", "True", "False")]
public String[] AllowedAwsRegions { get; public set; }
    [DescriptionAttribute("Maximum number of concurrent backup tasks")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Backup.MaxNumberOfConcurrentBackups", "0", "41", "True", "False")]
public Nullable`1<int> MaxNumberOfConcurrentBackups { get; public set; }
    [DescriptionAttribute("Number of seconds to delay the backup after hitting the maximum number of concurrent backups limit")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Backup.ConcurrentBackupsDelayInSec", "0", "47", "True", "False")]
public TimeSetting ConcurrentBackupsDelay { get; public set; }
    [DescriptionAttribute("Number of minutes to delay the backup after entering the low memory state by the Server.")]
[DefaultValueAttribute("10")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Backup.LowMemoryBackupDelayInMin", "0", "53", "True", "False")]
public TimeSetting LowMemoryBackupDelay { get; public set; }
    [DescriptionAttribute("Number of minutes after which the backup operation will timeout when cloud storage is used (in minutes).")]
[DefaultValueAttribute("720")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Backup.CloudStorageOperationTimeoutInMin", "1", "59", "True", "False")]
public TimeSetting CloudStorageOperationTimeout { get; public set; }
    [DescriptionAttribute("EXPERT: Indicates which library to use when doing Azure backups.")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Backup.Azure.Legacy", "0", "64", "True", "False")]
public bool AzureLegacy { get; public set; }
    [DescriptionAttribute("Compression algorithm that is used to perform backups.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Backup.Compression.Algorithm", "1", "69", "True", "False")]
public BackupCompressionAlgorithm CompressionAlgorithm { get; public set; }
    [DescriptionAttribute("Compression level that is used to perform backups.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Backup.Compression.Level", "1", "74", "True", "False")]
public CompressionLevel CompressionLevel { get; public set; }
    [DescriptionAttribute("Compression algorithm that is used to perform snapshot backups.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Backup.Snapshot.Compression.Algorithm", "1", "79", "True", "False")]
public SnapshotBackupCompressionAlgorithm SnapshotCompressionAlgorithm { get; public set; }
    [DescriptionAttribute("Compression level that is used to perform snapshot backups.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Backup.Snapshot.Compression.Level", "1", "84", "True", "False")]
public CompressionLevel SnapshotCompressionLevel { get; public set; }
    [DescriptionAttribute("Number of minutes, after which we will switch to a new responsible node for backup.")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Backup.MoveToNewResponsibleNodeGracePeriodInMin", "0", "90", "True", "False")]
public TimeSetting MoveToNewResponsibleNodeGracePeriod { get; public set; }
    private static BackupConfiguration();
    [CompilerGeneratedAttribute]
public PathSetting get_LocalRootPath();
    [CompilerGeneratedAttribute]
public void set_LocalRootPath(PathSetting value);
    [CompilerGeneratedAttribute]
public PathSetting get_TempPath();
    [CompilerGeneratedAttribute]
public void set_TempPath(PathSetting value);
    [CompilerGeneratedAttribute]
public String[] get_AllowedDestinations();
    [CompilerGeneratedAttribute]
public void set_AllowedDestinations(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_AllowedAwsRegions();
    [CompilerGeneratedAttribute]
public void set_AllowedAwsRegions(String[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxNumberOfConcurrentBackups();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfConcurrentBackups(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TimeSetting get_ConcurrentBackupsDelay();
    [CompilerGeneratedAttribute]
public void set_ConcurrentBackupsDelay(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_LowMemoryBackupDelay();
    [CompilerGeneratedAttribute]
public void set_LowMemoryBackupDelay(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CloudStorageOperationTimeout();
    [CompilerGeneratedAttribute]
public void set_CloudStorageOperationTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public bool get_AzureLegacy();
    [CompilerGeneratedAttribute]
public void set_AzureLegacy(bool value);
    [CompilerGeneratedAttribute]
public BackupCompressionAlgorithm get_CompressionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_CompressionAlgorithm(BackupCompressionAlgorithm value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public SnapshotBackupCompressionAlgorithm get_SnapshotCompressionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_SnapshotCompressionAlgorithm(SnapshotBackupCompressionAlgorithm value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_SnapshotCompressionLevel();
    [CompilerGeneratedAttribute]
public void set_SnapshotCompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MoveToNewResponsibleNodeGracePeriod();
    [CompilerGeneratedAttribute]
public void set_MoveToNewResponsibleNodeGracePeriod(TimeSetting value);
    public virtual void Initialize(IConfigurationRoot settings, HashSet`1<string> settingsNames, IConfigurationRoot serverWideSettings, HashSet`1<string> serverWideSettingsNames, ResourceType type, string resourceName);
    private void ValidateLocalRootPath();
    internal void ValidateAllowedDestinations();
    private void ValidateAllowedRegions();
    public void AssertRegionAllowed(string region);
    public void AssertDestinationAllowed(string dest);
}
[ConfigurationCategoryAttribute("2")]
public class Raven.Server.Config.Categories.ClusterConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private TimeSetting <ElectionTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <WorkerSamplePeriod>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <SupervisorSamplePeriod>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <ReceiveFromWorkerTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <OnErrorDelayTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <OperationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <StabilizationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <AddReplicaTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MoveToRehabGraceTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <RotatePreferredNodeGraceTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <TcpConnectionTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <TcpSendBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <TcpReceiveBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HardDeleteOnReplacement>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximalAllowedClusterVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CompareExchangeTombstonesCleanupInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MaxClusterTransactionCompareExchangeTombstoneCheckInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LogHistoryMaxEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CompareExchangeExpiredCleanupInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxChangeVectorDistance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableAtomicDocumentWrites>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <MaxSizeOfSingleRaftCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxClusterTransactionsBatchSize>k__BackingField;
    [DescriptionAttribute("Timeout in which the node expects to receive a heartbeat from the leader")]
[DefaultValueAttribute("300")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("Cluster.ElectionTimeoutInMs", "0", "14", "True", "False")]
public TimeSetting ElectionTimeout { get; public set; }
    [DescriptionAttribute("How frequently we sample the information about the databases and send it to the maintenance supervisor.")]
[DefaultValueAttribute("250")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("Cluster.WorkerSamplePeriodInMs", "0", "20", "True", "False")]
public TimeSetting WorkerSamplePeriod { get; public set; }
    [DescriptionAttribute("As the maintenance supervisor, how frequent we sample the information received from the nodes.")]
[DefaultValueAttribute("500")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("Cluster.SupervisorSamplePeriodInMs", "0", "26", "True", "False")]
public TimeSetting SupervisorSamplePeriod { get; public set; }
    [DescriptionAttribute("As the maintenance supervisor, how long we wait to hear from a worker before it is time out.")]
[DefaultValueAttribute("5000")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("Cluster.ReceiveFromWorkerTimeoutInMs", "0", "32", "True", "False")]
public TimeSetting ReceiveFromWorkerTimeout { get; public set; }
    [DescriptionAttribute("As the maintenance supervisor, how long we wait after we received an exception from a worker. Before we retry.")]
[DefaultValueAttribute("5000")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("Cluster.OnErrorDelayTimeInMs", "0", "38", "True", "False")]
public TimeSetting OnErrorDelayTime { get; public set; }
    [DescriptionAttribute("As a cluster node, how long it takes to timeout operation between two cluster nodes.")]
[DefaultValueAttribute("15")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Cluster.OperationTimeoutInSec", "0", "44", "True", "False")]
public TimeSetting OperationTimeout { get; public set; }
    [DescriptionAttribute("The time we give to the cluster stats to stabilize after a database topology change.")]
[DefaultValueAttribute("5")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Cluster.StatsStabilizationTimeInSec", "0", "50", "True", "False")]
public TimeSetting StabilizationTime { get; public set; }
    [DescriptionAttribute("The time we give to a database instance to be in a good and responsive state, before we adding a replica to match the replication factor.")]
[DefaultValueAttribute("900")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Cluster.TimeBeforeAddingReplicaInSec", "0", "56", "True", "False")]
public TimeSetting AddReplicaTimeout { get; public set; }
    [DescriptionAttribute("The grace time we give to a node before it will be moved to rehab.")]
[DefaultValueAttribute("60")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Cluster.TimeBeforeMovingToRehabInSec", "0", "62", "True", "False")]
public TimeSetting MoveToRehabGraceTime { get; public set; }
    [DescriptionAttribute("The grace time we give to the preferred node before we move him to the end of the members list.")]
[DefaultValueAttribute("5")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Cluster.TimeBeforeRotatingPreferredNodeInSec", "0", "68", "True", "False")]
public TimeSetting RotatePreferredNodeGraceTime { get; public set; }
    [DescriptionAttribute("Tcp connection read/write timeout.")]
[DefaultValueAttribute("15000")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("Cluster.TcpTimeoutInMs", "0", "74", "True", "False")]
public TimeSetting TcpConnectionTimeout { get; public set; }
    [DescriptionAttribute("Tcp connection send buffer size in bytes")]
[DefaultValueAttribute("32768")]
[SizeUnitAttribute("0")]
[ConfigurationEntryAttribute("Cluster.TcpSendBufferSizeInBytes", "0", "80", "True", "False")]
public Size TcpSendBufferSize { get; public set; }
    [DescriptionAttribute("Tcp connection receive buffer size in bytes")]
[DefaultValueAttribute("32768")]
[SizeUnitAttribute("0")]
[ConfigurationEntryAttribute("Cluster.TcpReceiveBufferSizeInBytes", "0", "86", "True", "False")]
public Size TcpReceiveBufferSize { get; public set; }
    [DescriptionAttribute("Set hard/soft delete for a database that was removed by the observer form the cluster topology in order to maintain the replication factor.")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Cluster.HardDeleteOnReplacement", "0", "91", "True", "False")]
public bool HardDeleteOnReplacement { get; public set; }
    [DescriptionAttribute("EXPERT: If exceeded, clamp the cluster to the specified version.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Cluster.MaximalAllowedClusterVersion", "0", "96", "True", "False")]
public Nullable`1<int> MaximalAllowedClusterVersion { get; public set; }
    [DescriptionAttribute("Time (in minutes) between compare exchange tombstones cleanup")]
[DefaultValueAttribute("10")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Cluster.CompareExchangeTombstonesCleanupIntervalInMin", "0", "102", "True", "False")]
public TimeSetting CompareExchangeTombstonesCleanupInterval { get; public set; }
    [DescriptionAttribute("The maximum interval (in minutes) between checks for compare exchange tombstones performed by the cluster-wide transaction mechanism")]
[DefaultValueAttribute("5")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Cluster.MaxClusterTransactionCompareExchangeTombstoneCheckIntervalInMin", "0", "108", "True", "False")]
public TimeSetting MaxClusterTransactionCompareExchangeTombstoneCheckInterval { get; public set; }
    [DescriptionAttribute("Maximum number of log entires to keep in the history log table.")]
[DefaultValueAttribute("2048")]
[ConfigurationEntryAttribute("Cluster.LogHistoryMaxEntries", "0", "113", "True", "False")]
public int LogHistoryMaxEntries { get; public set; }
    [DescriptionAttribute("Time (in seconds) between expired compare exchange cleanup")]
[DefaultValueAttribute("60")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Cluster.CompareExchangeExpiredDeleteFrequencyInSec", "0", "119", "True", "False")]
public TimeSetting CompareExchangeExpiredCleanupInterval { get; public set; }
    [DescriptionAttribute("Excceding the allowed change vector distance between two nodes, will move the lagged node to rehab.")]
[DefaultValueAttribute("65536")]
[ConfigurationEntryAttribute("Cluster.MaxChangeVectorDistance", "0", "124", "True", "False")]
public long MaxChangeVectorDistance { get; public set; }
    [DescriptionAttribute("EXPERT: Disable automatic atomic writes with cluster write transactions. If set to 'true', will only consider explicitly added compare exchange values to validate cluster wide transactions.")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Cluster.DisableAtomicDocumentWrites", "1", "129", "True", "False")]
public bool DisableAtomicDocumentWrites { get; public set; }
    [DescriptionAttribute("EXPERT: The maximum allowed size allowed for a single raft command (in megabytes)")]
[DefaultValueAttribute("128")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Cluster.MaxSizeOfSingleRaftCommandInMb", "0", "135", "True", "False")]
public Nullable`1<Size> MaxSizeOfSingleRaftCommand { get; public set; }
    [DescriptionAttribute("EXPERT: Specifies the max size of cluster transaction batch to be executed on the database at once")]
[DefaultValueAttribute("256")]
[ConfigurationEntryAttribute("Cluster.MaxClusterTransactionBatchSize", "1", "140", "True", "False")]
public int MaxClusterTransactionsBatchSize { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSetting get_ElectionTimeout();
    [CompilerGeneratedAttribute]
public void set_ElectionTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_WorkerSamplePeriod();
    [CompilerGeneratedAttribute]
public void set_WorkerSamplePeriod(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_SupervisorSamplePeriod();
    [CompilerGeneratedAttribute]
public void set_SupervisorSamplePeriod(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_ReceiveFromWorkerTimeout();
    [CompilerGeneratedAttribute]
public void set_ReceiveFromWorkerTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_OnErrorDelayTime();
    [CompilerGeneratedAttribute]
public void set_OnErrorDelayTime(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_StabilizationTime();
    [CompilerGeneratedAttribute]
public void set_StabilizationTime(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_AddReplicaTimeout();
    [CompilerGeneratedAttribute]
public void set_AddReplicaTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MoveToRehabGraceTime();
    [CompilerGeneratedAttribute]
public void set_MoveToRehabGraceTime(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_RotatePreferredNodeGraceTime();
    [CompilerGeneratedAttribute]
public void set_RotatePreferredNodeGraceTime(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_TcpConnectionTimeout();
    [CompilerGeneratedAttribute]
public void set_TcpConnectionTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public Size get_TcpSendBufferSize();
    [CompilerGeneratedAttribute]
public void set_TcpSendBufferSize(Size value);
    [CompilerGeneratedAttribute]
public Size get_TcpReceiveBufferSize();
    [CompilerGeneratedAttribute]
public void set_TcpReceiveBufferSize(Size value);
    [CompilerGeneratedAttribute]
public bool get_HardDeleteOnReplacement();
    [CompilerGeneratedAttribute]
public void set_HardDeleteOnReplacement(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximalAllowedClusterVersion();
    [CompilerGeneratedAttribute]
public void set_MaximalAllowedClusterVersion(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CompareExchangeTombstonesCleanupInterval();
    [CompilerGeneratedAttribute]
public void set_CompareExchangeTombstonesCleanupInterval(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxClusterTransactionCompareExchangeTombstoneCheckInterval();
    [CompilerGeneratedAttribute]
public void set_MaxClusterTransactionCompareExchangeTombstoneCheckInterval(TimeSetting value);
    [CompilerGeneratedAttribute]
public int get_LogHistoryMaxEntries();
    [CompilerGeneratedAttribute]
public void set_LogHistoryMaxEntries(int value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CompareExchangeExpiredCleanupInterval();
    [CompilerGeneratedAttribute]
public void set_CompareExchangeExpiredCleanupInterval(TimeSetting value);
    [CompilerGeneratedAttribute]
public long get_MaxChangeVectorDistance();
    [CompilerGeneratedAttribute]
public void set_MaxChangeVectorDistance(long value);
    [CompilerGeneratedAttribute]
public bool get_DisableAtomicDocumentWrites();
    [CompilerGeneratedAttribute]
public void set_DisableAtomicDocumentWrites(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_MaxSizeOfSingleRaftCommand();
    [CompilerGeneratedAttribute]
public void set_MaxSizeOfSingleRaftCommand(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public int get_MaxClusterTransactionsBatchSize();
    [CompilerGeneratedAttribute]
public void set_MaxClusterTransactionsBatchSize(int value);
}
public abstract class Raven.Server.Config.Categories.ConfigurationCategory : object {
    private static ConcurrentDictionary`2<Type, List`1<ConfigurationProperty>> _configurationPropertiesCache;
    public static string DefaultValueSetInConstructor;
    [CompilerGeneratedAttribute]
private bool <Initialized>k__BackingField;
    protected internal bool Initialized { get; protected internal set; }
    private static ConfigurationCategory();
    [CompilerGeneratedAttribute]
protected internal bool get_Initialized();
    [CompilerGeneratedAttribute]
protected internal void set_Initialized(bool value);
    protected internal static string GetValue(IConfiguration cfg, string name);
    protected internal static string GetValueForKey(string keyName, IConfiguration cfg);
    public virtual void Initialize(IConfigurationRoot settings, HashSet`1<string> settingsNames, IConfigurationRoot serverWideSettings, HashSet`1<string> serverWideSettingsNames, ResourceType type, string resourceName);
    public void Initialize(Func`2<string, SettingValue> getSetting, string serverDataDir, ResourceType type, string resourceName, bool throwIfThereIsNoSetMethod);
    protected virtual void ValidateProperty(PropertyInfo property);
    [DoesNotReturnAttribute]
protected static void ThrowMissingDefaultValue(PropertyInfo property);
    protected List`1<ConfigurationProperty> GetConfigurationProperties();
    private List`1<ConfigurationProperty> GetConfigurationPropertiesInternal(Type type);
    public object GetDefaultValue(Expression`1<Func`2<T, object>> getValue);
    private static String[] SplitValue(string value);
    [CompilerGeneratedAttribute]
internal static string <Initialize>g__GetConfigurationValue|9_0(IConfigurationRoot cfg, HashSet`1<string> cfgNames, string keyName, Boolean& keyExistsInConfiguration);
}
[AttributeUsageAttribute("4")]
public class Raven.Server.Config.Categories.ConfigurationCategoryAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ConfigurationCategoryType <Type>k__BackingField;
    public ConfigurationCategoryType Type { get; public set; }
    public ConfigurationCategoryAttribute(ConfigurationCategoryType type);
    [CompilerGeneratedAttribute]
public ConfigurationCategoryType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ConfigurationCategoryType value);
}
public enum Raven.Server.Config.Categories.ConfigurationCategoryType : Enum {
    public int value__;
    public static ConfigurationCategoryType None;
    public static ConfigurationCategoryType Backup;
    public static ConfigurationCategoryType Cluster;
    public static ConfigurationCategoryType Core;
    public static ConfigurationCategoryType Database;
    public static ConfigurationCategoryType Embedded;
    [DescriptionAttribute("ETL")]
public static ConfigurationCategoryType Etl;
    public static ConfigurationCategoryType Http;
    public static ConfigurationCategoryType Indexing;
    public static ConfigurationCategoryType Integrations;
    public static ConfigurationCategoryType License;
    public static ConfigurationCategoryType Logs;
    public static ConfigurationCategoryType Memory;
    public static ConfigurationCategoryType Migration;
    public static ConfigurationCategoryType Monitoring;
    public static ConfigurationCategoryType Notifications;
    public static ConfigurationCategoryType Patching;
    [DescriptionAttribute("Performance Hints")]
public static ConfigurationCategoryType PerformanceHints;
    public static ConfigurationCategoryType Query;
    public static ConfigurationCategoryType Replication;
    public static ConfigurationCategoryType Security;
    public static ConfigurationCategoryType Server;
    public static ConfigurationCategoryType Sharding;
    public static ConfigurationCategoryType Storage;
    public static ConfigurationCategoryType Studio;
    public static ConfigurationCategoryType Subscriptions;
    public static ConfigurationCategoryType Tombstones;
    [DescriptionAttribute("Transaction Merger")]
public static ConfigurationCategoryType TransactionMerger;
    public static ConfigurationCategoryType Updates;
    [DescriptionAttribute("Traffic Watch")]
public static ConfigurationCategoryType TrafficWatch;
    [DescriptionAttribute("Queue Sink")]
public static ConfigurationCategoryType QueueSink;
    [DescriptionAttribute("Export & Import")]
public static ConfigurationCategoryType ExportImport;
    public static ConfigurationCategoryType Debug;
}
[ConfigurationCategoryAttribute("3")]
public class Raven.Server.Config.Categories.CoreConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private String[] <ServerUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TcpServerUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UriSetting> <ClusterServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private UriSetting[] <ClusterPublicTcpServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private UriSetting[] <ExternalPublicTcpServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UriSetting> <PublicServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UriSetting> <PublicTcpServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExternalIp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunInMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private PathSetting <DataDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnforceDataDirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private SetupMode <SetupMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SetupResultingServerCertificatePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AcmeUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfAnyIndexCannotBeOpened>k__BackingField;
    [CompilerGeneratedAttribute]
private FeaturesAvailability <FeaturesAvailability>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <EchoSocketPort>k__BackingField;
    [DescriptionAttribute("The URLs which the server should listen to. By default we listen to localhost:8080")]
[DefaultValueAttribute("http://localhost:8080")]
[ConfigurationEntryAttribute("ServerUrl", "0", "20", "True", "False")]
public String[] ServerUrls { get; public set; }
    [DescriptionAttribute("If not specified, will use the server url host and random port. If it just a number specify, will use that port. Otherwise, will bind to the host & port specified")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("ServerUrl.Tcp", "0", "25", "True", "False")]
public String[] TcpServerUrls { get; public set; }
    [DescriptionAttribute("When provided those URLs are used for Server->Server communications to this node. This is meant to allow inter-cluster communication via private IPs, while external clients will use external IPs.  The provided URL can be raw IPs or utilize hostnames.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("ServerUrl.Cluster", "0", "30", "True", "False")]
public Nullable`1<UriSetting> ClusterServerUrl { get; public set; }
    [DescriptionAttribute("When provided those URLs are used for Server->Server TCP communications to this node. The list is used in the order provided, and the first URL that can be successfully connected to will be used. This is meant to allow inter-cluster communication via private IPs, while external clients will use external IPs.  The provided URLs can be raw IPs or utilize hostnames.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("PublicServerUrl.Tcp.Cluster", "0", "35", "True", "False")]
public UriSetting[] ClusterPublicTcpServerUrl { get; public set; }
    [DescriptionAttribute("When provided those URLs are used for Client->Server TCP communications to this node. The list is used in the order provided, and the first URL that can be successfully connected to will be used. This is meant to allow inter-network communication via private IPs for clients.  The provided URLs can be raw IPs or utilize hostnames.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("PublicServerUrl.Tcp.External", "0", "40", "True", "False")]
public UriSetting[] ExternalPublicTcpServerUrl { get; public set; }
    [DescriptionAttribute("The URL under which server is publicly available, used for inter-node communication and access from behind a firewall, proxy etc.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("PublicServerUrl", "0", "45", "True", "False")]
public Nullable`1<UriSetting> PublicServerUrl { get; public set; }
    [DescriptionAttribute("Public TCP address")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("PublicServerUrl.Tcp", "0", "50", "True", "False")]
public Nullable`1<UriSetting> PublicTcpServerUrl { get; public set; }
    [DescriptionAttribute("External IP address")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("ExternalIp", "0", "55", "True", "False")]
public string ExternalIp { get; public set; }
    [DescriptionAttribute("Whether the database should run purely in memory. When running in memory, nothing is written to disk and if the server is restarted all data will be lost. This is mostly useful for testing.")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("RunInMemory", "1", "60", "True", "False")]
public bool RunInMemory { get; public set; }
    [DescriptionAttribute("The directory for the RavenDB resource. Relative path will be located under the application base directory.")]
[DefaultValueAttribute("Databases/{name}")]
[ConfigurationEntryAttribute("DataDir", "1", "65", "True", "False")]
public PathSetting DataDirectory { get; public set; }
    [DescriptionAttribute("Databases can only be created under the DataDir path.")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("DataDir.EnforcePath", "0", "70", "True", "False")]
public bool EnforceDataDirectoryPath { get; public set; }
    [DescriptionAttribute("Determines what kind of security was chosen during setup.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Setup.Mode", "0", "75", "True", "False")]
public SetupMode SetupMode { get; public set; }
    [DescriptionAttribute("Determines where to save the initial server certificate during setup.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Setup.Certificate.Path", "0", "80", "True", "False")]
public string SetupResultingServerCertificatePath { get; public set; }
    [DescriptionAttribute("The URLs which the server should contact when requesting certificates with the ACME protocol.")]
[DefaultValueAttribute("https://acme-v02.api.letsencrypt.org/directory")]
[ConfigurationEntryAttribute("AcmeUrl", "0", "85", "True", "False")]
public string AcmeUrl { get; public set; }
    [DescriptionAttribute("Indicates if we should throw an exception if any index could not be opened")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("ThrowIfAnyIndexCannotBeOpened", "1", "90", "True", "False")]
public bool ThrowIfAnyIndexCannotBeOpened { get; public set; }
    [DescriptionAttribute("Indicates what set of features should be available")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Features.Availability", "0", "95", "True", "False")]
public FeaturesAvailability FeaturesAvailability { get; public set; }
    [DescriptionAttribute("EXPERT: Allow to test network status of the system to discover kernel level issues")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Testing.EchoSocket.Port", "0", "100", "True", "False")]
public Nullable`1<int> EchoSocketPort { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_ServerUrls();
    [CompilerGeneratedAttribute]
public void set_ServerUrls(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_TcpServerUrls();
    [CompilerGeneratedAttribute]
public void set_TcpServerUrls(String[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<UriSetting> get_ClusterServerUrl();
    [CompilerGeneratedAttribute]
public void set_ClusterServerUrl(Nullable`1<UriSetting> value);
    [CompilerGeneratedAttribute]
public UriSetting[] get_ClusterPublicTcpServerUrl();
    [CompilerGeneratedAttribute]
public void set_ClusterPublicTcpServerUrl(UriSetting[] value);
    [CompilerGeneratedAttribute]
public UriSetting[] get_ExternalPublicTcpServerUrl();
    [CompilerGeneratedAttribute]
public void set_ExternalPublicTcpServerUrl(UriSetting[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<UriSetting> get_PublicServerUrl();
    [CompilerGeneratedAttribute]
public void set_PublicServerUrl(Nullable`1<UriSetting> value);
    [CompilerGeneratedAttribute]
public Nullable`1<UriSetting> get_PublicTcpServerUrl();
    [CompilerGeneratedAttribute]
public void set_PublicTcpServerUrl(Nullable`1<UriSetting> value);
    [CompilerGeneratedAttribute]
public string get_ExternalIp();
    [CompilerGeneratedAttribute]
public void set_ExternalIp(string value);
    [CompilerGeneratedAttribute]
public bool get_RunInMemory();
    [CompilerGeneratedAttribute]
public void set_RunInMemory(bool value);
    [CompilerGeneratedAttribute]
public PathSetting get_DataDirectory();
    [CompilerGeneratedAttribute]
public void set_DataDirectory(PathSetting value);
    [CompilerGeneratedAttribute]
public bool get_EnforceDataDirectoryPath();
    [CompilerGeneratedAttribute]
public void set_EnforceDataDirectoryPath(bool value);
    [CompilerGeneratedAttribute]
public SetupMode get_SetupMode();
    [CompilerGeneratedAttribute]
public void set_SetupMode(SetupMode value);
    [CompilerGeneratedAttribute]
public string get_SetupResultingServerCertificatePath();
    [CompilerGeneratedAttribute]
public void set_SetupResultingServerCertificatePath(string value);
    [CompilerGeneratedAttribute]
public string get_AcmeUrl();
    [CompilerGeneratedAttribute]
public void set_AcmeUrl(string value);
    [CompilerGeneratedAttribute]
public bool get_ThrowIfAnyIndexCannotBeOpened();
    [CompilerGeneratedAttribute]
public void set_ThrowIfAnyIndexCannotBeOpened(bool value);
    [CompilerGeneratedAttribute]
public FeaturesAvailability get_FeaturesAvailability();
    [CompilerGeneratedAttribute]
public void set_FeaturesAvailability(FeaturesAvailability value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_EchoSocketPort();
    [CompilerGeneratedAttribute]
public void set_EchoSocketPort(Nullable`1<int> value);
    public virtual void Initialize(IConfigurationRoot settings, HashSet`1<string> settingsNames, IConfigurationRoot serverWideSettings, HashSet`1<string> serverWideSettingsNames, ResourceType type, string resourceName);
    internal string GetNodeHttpServerUrl(string serverWebUrl);
    internal string GetNodeTcpServerUrl(string serverWebUrl, int actualPort);
    private string GetNodeHost(Uri serverWebUri, string serverUrlSettingValue);
    internal void ValidateServerUrls();
    internal void ValidatePublicUrls();
    private static void ValidateServerUrl(String[] urls, String[] expectedSchemes, string configurationKey);
    private void ValidateSchemePublicVsBoundUrl();
    private void ValidatePublicUrl(string uriString, string optName);
}
[ConfigurationCategoryAttribute("4")]
public class Raven.Server.Config.Categories.DatabaseConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private TimeSetting <QueryTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <QueryOperationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <OperationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CollectionOperationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompressRevisionsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompressAllCollectionsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <ConcurrentLoadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrentLoads>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MaxIdleTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <FrequencyToCheckForIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <PulseReadTransactionLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <DeepCleanupThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <RegularCleanupThreshold>k__BackingField;
    [DescriptionAttribute("The time in seconds to wait before canceling query")]
[DefaultValueAttribute("300")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Databases.QueryTimeoutInSec", "1", "40", "True", "False")]
public TimeSetting QueryTimeout { get; public set; }
    [DescriptionAttribute("The time in seconds to wait before canceling query related operation (patch/delete query)")]
[DefaultValueAttribute("300")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Databases.QueryOperationTimeoutInSec", "1", "49", "True", "False")]
public TimeSetting QueryOperationTimeout { get; public set; }
    [DescriptionAttribute("The time in seconds to wait before canceling specific operations (such as indexing terms)")]
[DefaultValueAttribute("300")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Databases.OperationTimeoutInSec", "1", "58", "True", "False")]
public TimeSetting OperationTimeout { get; public set; }
    [DescriptionAttribute("The time in seconds to wait before canceling several collection operations (such as batch delete documents from studio)")]
[DefaultValueAttribute("300")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Databases.CollectionOperationTimeoutInSec", "1", "67", "True", "False")]
public TimeSetting CollectionOperationTimeout { get; public set; }
    [DescriptionAttribute("Whether revisions compression should be on by default or not on new databases")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Databases.Compression.CompressRevisionsDefault", "0", "77", "True", "False")]
public bool CompressRevisionsDefault { get; public set; }
    [DescriptionAttribute("Whether collections compression should be on by default or not on new databases")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Databases.Compression.CompressAllCollectionsDefault", "0", "86", "True", "False")]
public bool CompressAllCollectionsDefault { get; public set; }
    [DescriptionAttribute("The time in seconds to wait for a database to start loading when under load")]
[DefaultValueAttribute("60")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Databases.ConcurrentLoadTimeoutInSec", "0", "95", "True", "False")]
public TimeSetting ConcurrentLoadTimeout { get; public set; }
    [DescriptionAttribute("Specifies the maximum number of databases that can be loaded simultaneously")]
[DefaultValueAttribute("8")]
[ConfigurationEntryAttribute("Databases.MaxConcurrentLoads", "0", "103", "True", "False")]
public int MaxConcurrentLoads { get; public set; }
    [DescriptionAttribute("Specifies the maximum idle time for the database. After this time an idle database will be unloaded from memeory.")]
[DefaultValueAttribute("900")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Databases.MaxIdleTimeInSec", "1", "113", "True", "False")]
public TimeSetting MaxIdleTime { get; public set; }
    [DescriptionAttribute("The time in seconds to check for an idle database")]
[DefaultValueAttribute("60")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Databases.FrequencyToCheckForIdleInSec", "0", "122", "True", "False")]
public TimeSetting FrequencyToCheckForIdle { get; public set; }
    [DescriptionAttribute("Number of megabytes occupied by encryption buffers (if database is encrypted) or mapped 32 bites buffers (when running on 32 bits) after which a read transaction will be renewed to reduce memory usage during long running operations like backups or streaming")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Databases.PulseReadTransactionLimitInMb", "1", "132", "True", "False")]
public Size PulseReadTransactionLimit { get; public set; }
    [DescriptionAttribute("EXPERT: A deep database cleanup will be done when this number of minutes has passed since the last time work was done on the database.")]
[DefaultValueAttribute("5")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Databases.DeepCleanupThresholdInMin", "1", "141", "True", "False")]
public TimeSetting DeepCleanupThreshold { get; public set; }
    [DescriptionAttribute("EXPERT: A regular database cleanup will be done when this number of minutes has passed since the last database idle time.")]
[DefaultValueAttribute("10")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Databases.RegularCleanupThresholdInMin", "1", "150", "True", "False")]
public TimeSetting RegularCleanupThreshold { get; public set; }
    public DatabaseConfiguration(bool forceUsing32BitsPager);
    [CompilerGeneratedAttribute]
public TimeSetting get_QueryTimeout();
    [CompilerGeneratedAttribute]
public void set_QueryTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_QueryOperationTimeout();
    [CompilerGeneratedAttribute]
public void set_QueryOperationTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CollectionOperationTimeout();
    [CompilerGeneratedAttribute]
public void set_CollectionOperationTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public bool get_CompressRevisionsDefault();
    [CompilerGeneratedAttribute]
public void set_CompressRevisionsDefault(bool value);
    [CompilerGeneratedAttribute]
public bool get_CompressAllCollectionsDefault();
    [CompilerGeneratedAttribute]
public void set_CompressAllCollectionsDefault(bool value);
    [CompilerGeneratedAttribute]
public TimeSetting get_ConcurrentLoadTimeout();
    [CompilerGeneratedAttribute]
public void set_ConcurrentLoadTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrentLoads();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrentLoads(int value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxIdleTime();
    [CompilerGeneratedAttribute]
public void set_MaxIdleTime(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_FrequencyToCheckForIdle();
    [CompilerGeneratedAttribute]
public void set_FrequencyToCheckForIdle(TimeSetting value);
    [CompilerGeneratedAttribute]
public Size get_PulseReadTransactionLimit();
    [CompilerGeneratedAttribute]
public void set_PulseReadTransactionLimit(Size value);
    [CompilerGeneratedAttribute]
public TimeSetting get_DeepCleanupThreshold();
    [CompilerGeneratedAttribute]
public void set_DeepCleanupThreshold(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_RegularCleanupThreshold();
    [CompilerGeneratedAttribute]
public void set_RegularCleanupThreshold(TimeSetting value);
}
[ConfigurationCategoryAttribute("32")]
public class Raven.Server.Config.Categories.DebugConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private EventListenerMode <EventListenerMode>k__BackingField;
    [CompilerGeneratedAttribute]
private EventType[] <EventTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MinimumDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <AllocationsLoggingInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AllocationsLoggingCount>k__BackingField;
    [DescriptionAttribute("Event listener logging mode.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Debug.EventListener.Mode", "0", "13", "True", "False")]
public EventListenerMode EventListenerMode { get; public set; }
    [DescriptionAttribute("A semicolon-separated list of event types by which the event listener logging entities will be filtered. If not specified, event listener entities with any type will be included. Example list: "GC;GCSuspend;GCRestart;GCFinalizers;Contention".")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Debug.EventListener.EventTypes", "0", "18", "True", "False")]
public EventType[] EventTypes { get; public set; }
    [DescriptionAttribute("Minimum duration by which the event listenter logging entities will be filtered.")]
[DefaultValueAttribute("0")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("Debug.EventListener.MinimumDurationInMs", "0", "24", "True", "False")]
public TimeSetting MinimumDuration { get; public set; }
    [DescriptionAttribute("The duration on which we'll collect the allocations info.")]
[DefaultValueAttribute("5000")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("Debug.EventListener.AllocationsLoggingIntervalInMs", "0", "30", "True", "False")]
public TimeSetting AllocationsLoggingInterval { get; public set; }
    [DescriptionAttribute("Number of top allocation events to log")]
[DefaultValueAttribute("5")]
[ConfigurationEntryAttribute("Debug.EventListener.AllocationsLoggingCount", "0", "35", "True", "False")]
public int AllocationsLoggingCount { get; public set; }
    [CompilerGeneratedAttribute]
public EventListenerMode get_EventListenerMode();
    [CompilerGeneratedAttribute]
public void set_EventListenerMode(EventListenerMode value);
    [CompilerGeneratedAttribute]
public EventType[] get_EventTypes();
    [CompilerGeneratedAttribute]
public void set_EventTypes(EventType[] value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MinimumDuration();
    [CompilerGeneratedAttribute]
public void set_MinimumDuration(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_AllocationsLoggingInterval();
    [CompilerGeneratedAttribute]
public void set_AllocationsLoggingInterval(TimeSetting value);
    [CompilerGeneratedAttribute]
public int get_AllocationsLoggingCount();
    [CompilerGeneratedAttribute]
public void set_AllocationsLoggingCount(int value);
}
[ConfigurationCategoryAttribute("5")]
public class Raven.Server.Config.Categories.EmbeddedConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ParentProcessId>k__BackingField;
    [DescriptionAttribute("Watch the parent process id and exit when it exited as well")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Embedded.ParentProcessId", "0", "11", "True", "False")]
[ConfigurationEntryAttribute("Testing.ParentProcessId", "0", "12", "True", "False")]
public Nullable`1<int> ParentProcessId { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ParentProcessId();
    [CompilerGeneratedAttribute]
public void set_ParentProcessId(Nullable`1<int> value);
}
[ConfigurationCategoryAttribute("6")]
public class Raven.Server.Config.Categories.EtlConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSetting> <SqlCommandTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <ExtractAndTransformTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxNumberOfExtractedDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxNumberOfExtractedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MaxFallbackTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <MaxBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <OlapMaxNumberOfExtractedDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <KafkaInitTransactionsTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <AzureQueueStorageTimeToLive>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <AzureQueueStorageVisibilityTimeout>k__BackingField;
    [DescriptionAttribute("Number of seconds after which SQL command will timeout. Default: null (use provider default). Can be overriden by setting CommandTimeout property value in SQL ETL configuration.")]
[DefaultValueAttribute("")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("ETL.SQL.CommandTimeoutInSec", "1", "14", "True", "False")]
public Nullable`1<TimeSetting> SqlCommandTimeout { get; public set; }
    [DescriptionAttribute("Number of seconds after which extraction and transformation will end and loading will start.")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("ETL.ExtractAndTransformTimeoutInSec", "1", "20", "True", "False")]
public TimeSetting ExtractAndTransformTimeout { get; public set; }
    [DescriptionAttribute("Max number of extracted documents in ETL batch")]
[DefaultValueAttribute("8192")]
[ConfigurationEntryAttribute("ETL.MaxNumberOfExtractedDocuments", "1", "25", "True", "False")]
public Nullable`1<int> MaxNumberOfExtractedDocuments { get; public set; }
    [DescriptionAttribute("Max number of extracted items in ETL batch")]
[DefaultValueAttribute("8192")]
[ConfigurationEntryAttribute("ETL.MaxNumberOfExtractedItems", "1", "30", "True", "False")]
public Nullable`1<int> MaxNumberOfExtractedItems { get; public set; }
    [DescriptionAttribute("Maximum number of seconds ETL process will be in a fallback mode after a load connection failure to a destination. The fallback mode means suspending the process.")]
[DefaultValueAttribute("900")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("ETL.MaxFallbackTimeInSec", "1", "36", "True", "False")]
public TimeSetting MaxFallbackTime { get; public set; }
    [DescriptionAttribute("Maximum batch size of data (documents and attachments) in megabytes after transformation that will be sent to the destination in a single batch")]
[DefaultValueAttribute("64")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("ETL.MaxBatchSizeInMb", "1", "42", "True", "False")]
public Nullable`1<Size> MaxBatchSize { get; public set; }
    [DescriptionAttribute("Max number of extracted documents in OLAP ETL batch")]
[DefaultValueAttribute("65536")]
[ConfigurationEntryAttribute("ETL.OLAP.MaxNumberOfExtractedDocuments", "1", "47", "True", "False")]
public Nullable`1<int> OlapMaxNumberOfExtractedDocuments { get; public set; }
    [DescriptionAttribute("Timeout to initialize transactions for the Kafka producer")]
[DefaultValueAttribute("60")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("ETL.Queue.Kafka.InitTransactionsTimeoutInSec", "1", "53", "True", "False")]
public TimeSetting KafkaInitTransactionsTimeout { get; public set; }
    [DescriptionAttribute("Lifespan of a message in the queue")]
[DefaultValueAttribute("604800")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("ETL.Queue.AzureQueueStorage.TimeToLiveInSec", "1", "59", "True", "False")]
public TimeSetting AzureQueueStorageTimeToLive { get; public set; }
    [DescriptionAttribute("How long a message is hidden after being retrieved but not deleted")]
[DefaultValueAttribute("0")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("ETL.Queue.AzureQueueStorage.VisibilityTimeoutInSec", "1", "65", "True", "False")]
public TimeSetting AzureQueueStorageVisibilityTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSetting> get_SqlCommandTimeout();
    [CompilerGeneratedAttribute]
public void set_SqlCommandTimeout(Nullable`1<TimeSetting> value);
    [CompilerGeneratedAttribute]
public TimeSetting get_ExtractAndTransformTimeout();
    [CompilerGeneratedAttribute]
public void set_ExtractAndTransformTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxNumberOfExtractedDocuments();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfExtractedDocuments(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxNumberOfExtractedItems();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfExtractedItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxFallbackTime();
    [CompilerGeneratedAttribute]
public void set_MaxFallbackTime(TimeSetting value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_MaxBatchSize();
    [CompilerGeneratedAttribute]
public void set_MaxBatchSize(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_OlapMaxNumberOfExtractedDocuments();
    [CompilerGeneratedAttribute]
public void set_OlapMaxNumberOfExtractedDocuments(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TimeSetting get_KafkaInitTransactionsTimeout();
    [CompilerGeneratedAttribute]
public void set_KafkaInitTransactionsTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_AzureQueueStorageTimeToLive();
    [CompilerGeneratedAttribute]
public void set_AzureQueueStorageTimeToLive(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_AzureQueueStorageVisibilityTimeout();
    [CompilerGeneratedAttribute]
public void set_AzureQueueStorageVisibilityTimeout(TimeSetting value);
}
[ConfigurationCategoryAttribute("31")]
public class Raven.Server.Config.Categories.ExportImportConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private ExportCompressionAlgorithm <CompressionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    [DescriptionAttribute("Compression algorithm that is used to perform exports.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Export.Compression.Algorithm", "1", "13", "True", "False")]
public ExportCompressionAlgorithm CompressionAlgorithm { get; public set; }
    [DescriptionAttribute("Compression level that is used to perform exports.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Export.Compression.Level", "1", "18", "True", "False")]
public CompressionLevel CompressionLevel { get; public set; }
    [CompilerGeneratedAttribute]
public ExportCompressionAlgorithm get_CompressionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_CompressionAlgorithm(ExportCompressionAlgorithm value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
}
[ConfigurationCategoryAttribute("7")]
public class Raven.Server.Config.Categories.HttpConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <MinDataRatePerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSetting> <MinDataRateGracePeriod>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <MaxRequestBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxRequestLineSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSetting> <KeepAlivePingTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSetting> <KeepAlivePingDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxStreamsPerConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseResponseCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowResponseCompressionOverHttps>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <GzipResponseCompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <DeflateResponseCompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <ZstdResponseCompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <StaticFilesResponseCompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpProtocols <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSynchronousIo>k__BackingField;
    [DescriptionAttribute("Set Kestrel's minimum required data rate in bytes per second. This option must be configured together with 'Http.MinDataRateGracePeriod'.")]
[DefaultValueAttribute("")]
[SizeUnitAttribute("0")]
[ConfigurationEntryAttribute("Http.MinDataRateBytesPerSec", "0", "22", "True", "False")]
public Nullable`1<Size> MinDataRatePerSecond { get; public set; }
    [DescriptionAttribute("Set Kestrel's allowed request and response grace in seconds. This option must be configured together with 'Http.MinDataRateBytesPerSec'.")]
[DefaultValueAttribute("")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Http.MinDataRateGracePeriodInSec", "0", "28", "True", "False")]
public Nullable`1<TimeSetting> MinDataRateGracePeriod { get; public set; }
    [DescriptionAttribute("Set Kestrel's MaxRequestBufferSize")]
[DefaultValueAttribute("")]
[SizeUnitAttribute("1")]
[ConfigurationEntryAttribute("Http.MaxRequestBufferSizeInKb", "0", "34", "True", "False")]
public Nullable`1<Size> MaxRequestBufferSize { get; public set; }
    [DescriptionAttribute("Set Kestrel's MaxRequestLineSize")]
[DefaultValueAttribute("16")]
[SizeUnitAttribute("1")]
[ConfigurationEntryAttribute("Http.MaxRequestLineSizeInKb", "0", "40", "True", "False")]
public Size MaxRequestLineSize { get; public set; }
    [DescriptionAttribute("Set Kestrel's HTTP2 keep alive ping timeout")]
[DefaultValueAttribute("")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Http.Http2.KeepAlivePingTimeoutInSec", "0", "46", "True", "False")]
public Nullable`1<TimeSetting> KeepAlivePingTimeout { get; public set; }
    [DescriptionAttribute("Set Kestrel's HTTP2 keep alive ping delay")]
[DefaultValueAttribute("")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Http.Http2.KeepAlivePingDelayInSec", "0", "52", "True", "False")]
public Nullable`1<TimeSetting> KeepAlivePingDelay { get; public set; }
    [DescriptionAttribute("Set Kestrel's HTTP2 max streams per connection. This limits the number of concurrent request streams per HTTP/2 connection. Excess streams will be refused.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Http.Http2.MaxStreamsPerConnection", "0", "57", "True", "False")]
public Nullable`1<int> MaxStreamsPerConnection { get; public set; }
    [DescriptionAttribute("Set whether Raven's HTTP server should compress its responses")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Http.UseResponseCompression", "0", "62", "True", "False")]
public bool UseResponseCompression { get; public set; }
    [DescriptionAttribute("Set whether Raven's HTTP server should allow response compression to happen when HTTPS is enabled.")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Http.AllowResponseCompressionOverHttps", "0", "67", "True", "False")]
public bool AllowResponseCompressionOverHttps { get; public set; }
    [DescriptionAttribute("Compression level to be used when compressing HTTP responses with GZip")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Http.GzipResponseCompressionLevel", "0", "72", "True", "False")]
public CompressionLevel GzipResponseCompressionLevel { get; public set; }
    [DescriptionAttribute("Compression level to be used when compressing HTTP responses with Deflate")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Http.DeflateResponseCompressionLevel", "0", "77", "True", "False")]
public CompressionLevel DeflateResponseCompressionLevel { get; public set; }
    [DescriptionAttribute("Compression level to be used when compressing HTTP responses with Zstd")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Http.ZstdResponseCompressionLevel", "0", "89", "True", "False")]
public CompressionLevel ZstdResponseCompressionLevel { get; public set; }
    [DescriptionAttribute("Compression level to be used when compressing static files")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Http.StaticFilesResponseCompressionLevel", "0", "94", "True", "False")]
public CompressionLevel StaticFilesResponseCompressionLevel { get; public set; }
    [DescriptionAttribute("Set HTTP protocols that should be supported by the server")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[ConfigurationEntryAttribute("Http.Protocols", "0", "99", "True", "False")]
public HttpProtocols Protocols { get; public set; }
    [DescriptionAttribute("Set a value that controls whether synchronous IO is allowed for the Request and Response")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Http.AllowSynchronousIO", "0", "104", "True", "False")]
public bool AllowSynchronousIo { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_MinDataRatePerSecond();
    [CompilerGeneratedAttribute]
public void set_MinDataRatePerSecond(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSetting> get_MinDataRateGracePeriod();
    [CompilerGeneratedAttribute]
public void set_MinDataRateGracePeriod(Nullable`1<TimeSetting> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_MaxRequestBufferSize();
    [CompilerGeneratedAttribute]
public void set_MaxRequestBufferSize(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public Size get_MaxRequestLineSize();
    [CompilerGeneratedAttribute]
public void set_MaxRequestLineSize(Size value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSetting> get_KeepAlivePingTimeout();
    [CompilerGeneratedAttribute]
public void set_KeepAlivePingTimeout(Nullable`1<TimeSetting> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSetting> get_KeepAlivePingDelay();
    [CompilerGeneratedAttribute]
public void set_KeepAlivePingDelay(Nullable`1<TimeSetting> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxStreamsPerConnection();
    [CompilerGeneratedAttribute]
public void set_MaxStreamsPerConnection(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_UseResponseCompression();
    [CompilerGeneratedAttribute]
public void set_UseResponseCompression(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowResponseCompressionOverHttps();
    [CompilerGeneratedAttribute]
public void set_AllowResponseCompressionOverHttps(bool value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_GzipResponseCompressionLevel();
    [CompilerGeneratedAttribute]
public void set_GzipResponseCompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_DeflateResponseCompressionLevel();
    [CompilerGeneratedAttribute]
public void set_DeflateResponseCompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_ZstdResponseCompressionLevel();
    [CompilerGeneratedAttribute]
public void set_ZstdResponseCompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_StaticFilesResponseCompressionLevel();
    [CompilerGeneratedAttribute]
public void set_StaticFilesResponseCompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public HttpProtocols get_Protocols();
    [CompilerGeneratedAttribute]
public void set_Protocols(HttpProtocols value);
    [CompilerGeneratedAttribute]
public bool get_AllowSynchronousIo();
    [CompilerGeneratedAttribute]
public void set_AllowSynchronousIo(bool value);
}
[ConfigurationCategoryAttribute("8")]
public class Raven.Server.Config.Categories.IndexingConfiguration : ConfigurationCategory {
    private Nullable`1<bool> _runInMemory;
    private RavenConfiguration _root;
    private PathSetting _indexStoragePath;
    public static Lazy`1<HashSet`1<string>> ValidIndexingConfigurationKeys;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexDeploymentMode <StaticIndexDeploymentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexDeploymentMode <AutoIndexDeploymentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchivedDataProcessingBehavior <AutoIndexArchivedDataProcessingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchivedDataProcessingBehavior <StaticIndexArchivedDataProcessingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private PathSetting <TempPath>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MaxTimeForDocumentTransactionToRemainOpen>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <TimeBeforeDeletionOfSupersededAutoIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <TimeToWaitBeforeMarkingAutoIndexAsIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableQueryOptimizerGeneratedIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <TimeToWaitBeforeDeletingAutoIndexMarkedAsIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinNumberOfMapAttemptsAfterWhichBatchWillBeCanceledIfRunningLowOnMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfConcurrentStoppedBatchesIfRunningLowOnMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MapTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <QueryClauseCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QueryClauseCacheDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <QueryClauseCacheExpirationScanFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QueryClauseCacheRepeatedQueriesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <QueryClauseCacheRepeatedQueriesTimeFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MapBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MapTimeoutAfterEtagReached>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxStepsForScript>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowStringCompilation>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CleanupInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinGram>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxGram>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <ManagedAllocationsBatchLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaximumSizePerSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MergeFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <LargeSegmentSizeToMerge>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfLargeSegmentsToMergeInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MaxTimeForMergesToKeepRunning>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <TransactionSizeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <EncryptedTransactionSizeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <ScratchSpaceLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <GlobalScratchSpaceLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MaxTimeToWaitAfterFlushAndSyncWhenExceedingScratchSpaceLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndexMissingFieldsAsNull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndexEmptyEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorIndexStartupBehaviorType <ErrorIndexStartupBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexStartupBehaviorType <IndexStartupBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxNumberOfConcurrentlyRunningIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private PathSetting <NuGetPackagesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuGetPackageSourceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NuGetAllowPreleasePackages>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HistoryRevisionsNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultAnalyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultExactAnalyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultSearchAnalyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSetting> <ThrottlingTimeInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchEngineType <AutoIndexingEngineType>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchEngineType <StaticIndexingEngineType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocumentsLimitForCompressionDictionaryCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<AnalyzerFactory> <DefaultAnalyzerType>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<AnalyzerFactory> <DefaultExactAnalyzerType>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<AnalyzerFactory> <DefaultSearchAnalyzerType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipDatabaseIdValidationOnIndexOpening>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <TimeSinceLastQueryAfterWhichDeepCleanupCanBeExecuted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireAdminToDeployJavaScriptIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OrderByScoreAutomaticallyWhenBoostingIsInvolved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LuceneUseCompoundFileInMerging>k__BackingField;
    [CompilerGeneratedAttribute]
private LuceneIndexInputType <LuceneIndexInput>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MaxTimeToWaitAfterFlushAndSyncWhenReplacingSideBySideIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MinimumTotalSizeOfJournalsToRunFlushAndSyncWhenReplacingSideBySideIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OrderByTicksAutomaticallyWhenDatesAreInvolved>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReaderTermsIndexDivisor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CoraxIncludeDocumentScore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CoraxIncludeSpatialDistance>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxMemoizationSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxAllocationsAtDictionaryTraining>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexResetMode <ResetMode>k__BackingField;
    [CompilerGeneratedAttribute]
private CoraxComplexFieldIndexingBehavior <CoraxStaticIndexComplexFieldIndexingBehavior>k__BackingField;
    [DefaultValueAttribute("False")]
[DescriptionAttribute("Set whether the indexes should run purely in memory. When running in memory, nothing is written to disk and if the server is restarted all data will be lost. This is mostly useful for testing.")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.RunInMemory", "1", "104", "False", "False")]
public bool RunInMemory { get; protected set; }
    [DescriptionAttribute("Set whether to disable all indexes in the database")]
[DefaultValueAttribute("False")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.Disable", "1", "121", "True", "False")]
public bool Disabled { get; protected set; }
    [DescriptionAttribute("The default deployment mode for static indexes")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Static.DeploymentMode", "1", "127", "True", "False")]
public IndexDeploymentMode StaticIndexDeploymentMode { get; protected set; }
    [DescriptionAttribute("The default deployment mode for auto indexes")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Auto.DeploymentMode", "1", "133", "True", "False")]
public IndexDeploymentMode AutoIndexDeploymentMode { get; protected set; }
    [DescriptionAttribute("The default archived data processing behavior for auto indexes")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.Auto.ArchivedDataProcessingBehavior", "1", "140", "True", "False")]
public ArchivedDataProcessingBehavior AutoIndexArchivedDataProcessingBehavior { get; protected set; }
    [DescriptionAttribute("The default archived data processing behavior for static indexes")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.Static.ArchivedDataProcessingBehavior", "1", "147", "True", "False")]
public ArchivedDataProcessingBehavior StaticIndexArchivedDataProcessingBehavior { get; protected set; }
    [DescriptionAttribute("Indicate if indexing performance metrics are gathered")]
[DefaultValueAttribute("True")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Metrics.Enabled", "2", "154", "True", "False")]
public bool EnableMetrics { get; protected set; }
    [ReadOnlyPathAttribute]
public PathSetting StoragePath { get; }
    [DescriptionAttribute("Use this setting to specify a different path for the indexes' temporary files. By default, temporary files are created under the Temp folder inside the index data directory.")]
[DefaultValueAttribute("")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.TempPath", "1", "163", "True", "False")]
public PathSetting TempPath { get; protected set; }
    [DescriptionAttribute("How long indexing will keep document transaction open when indexing. After this the transaction will be reopened.")]
[DefaultValueAttribute("15")]
[TimeUnitAttribute("1")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.MaxTimeForDocumentTransactionToRemainOpenInSec", "2", "170", "True", "False")]
public TimeSetting MaxTimeForDocumentTransactionToRemainOpen { get; protected set; }
    [DescriptionAttribute("How long a superseded auto index should be kept")]
[DefaultValueAttribute("15")]
[TimeUnitAttribute("1")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.TimeBeforeDeletionOfSupersededAutoIndexInSec", "1", "177", "True", "False")]
public TimeSetting TimeBeforeDeletionOfSupersededAutoIndex { get; protected set; }
    [DescriptionAttribute("How long the database should wait before marking an auto index with the idle flag")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("2")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.TimeToWaitBeforeMarkingAutoIndexAsIdleInMin", "1", "184", "True", "False")]
public TimeSetting TimeToWaitBeforeMarkingAutoIndexAsIdle { get; protected set; }
    [DescriptionAttribute("EXPERT: Disable query optimizer generated indexes (auto-indexes). Dynamic queries will not be supported.")]
[DefaultValueAttribute("False")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.DisableQueryOptimizerGeneratedIndexes", "1", "190", "True", "False")]
public bool DisableQueryOptimizerGeneratedIndexes { get; protected set; }
    [DescriptionAttribute("How long the database should wait before deleting an auto index with the idle flag")]
[DefaultValueAttribute("72")]
[TimeUnitAttribute("3")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.TimeToWaitBeforeDeletingAutoIndexMarkedAsIdleInHrs", "1", "197", "True", "False")]
public TimeSetting TimeToWaitBeforeDeletingAutoIndexMarkedAsIdle { get; protected set; }
    [DescriptionAttribute("EXPERT: Set minimum number of map attempts after which batch will be canceled if running low on memory")]
[DefaultValueAttribute("512")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.MinNumberOfMapAttemptsAfterWhichBatchWillBeCanceledIfRunningLowOnMemory", "2", "203", "True", "False")]
public int MinNumberOfMapAttemptsAfterWhichBatchWillBeCanceledIfRunningLowOnMemory { get; protected set; }
    [DescriptionAttribute("EXPERT: Number of concurrent stopped batches if running low on memory")]
[DefaultValueAttribute("2")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.NumberOfConcurrentStoppedBatchesIfRunningLowOnMemory", "2", "209", "True", "False")]
public int NumberOfConcurrentStoppedBatchesIfRunningLowOnMemory { get; protected set; }
    [DescriptionAttribute("Number of seconds after which mapping will end even if there is more to map. By default we will map everything we can in single batch.")]
[DefaultValueAttribute("-1")]
[TimeUnitAttribute("1")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.MapTimeoutInSec", "2", "216", "True", "False")]
public TimeSetting MapTimeout { get; protected set; }
    [DescriptionAttribute("EXPERT: Maximum size that the query clause cache will utilize for caching partial query clauses, defaulting to 10% of the system memory on 64-bit machines.")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.QueryClauseCache.SizeInMb", "0", "223", "True", "False")]
public Size QueryClauseCacheSize { get; protected set; }
    [DescriptionAttribute("EXPERT: Disable the query clause cache for a server, database, or a single index.")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.QueryClauseCache.Disabled", "2", "229", "True", "False")]
public bool QueryClauseCacheDisabled { get; protected set; }
    [DescriptionAttribute("EXPERT: The frequency by which to scan the query clause cache for expired values.")]
[DefaultValueAttribute("180")]
[TimeUnitAttribute("1")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.QueryClauseCache.ExpirationScanFrequencyInSec", "0", "236", "True", "False")]
public TimeSetting QueryClauseCacheExpirationScanFrequency { get; protected set; }
    [DescriptionAttribute("EXPERT: The number of recent queries that we will keep to identify repeated queries, relevant for caching.")]
[DefaultValueAttribute("512")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.QueryClauseCache.RepeatedQueriesCount", "0", "242", "True", "False")]
public int QueryClauseCacheRepeatedQueriesCount { get; protected set; }
    [DescriptionAttribute("EXPERT: The time frame for a query to repeat itself for us to consider it worth caching.")]
[DefaultValueAttribute("300")]
[TimeUnitAttribute("1")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.QueryClauseCache.RepeatedQueriesTimeFrameInSec", "2", "249", "True", "False")]
public TimeSetting QueryClauseCacheRepeatedQueriesTimeFrame { get; protected set; }
    [DescriptionAttribute("Maximum number of documents to be processed by the index per indexing batch. Cannot be less than 128. By default 'null' - no limit.")]
[DefaultValueAttribute("")]
[MinValueAttribute("128")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.MapBatchSize", "2", "256", "True", "False")]
public Nullable`1<int> MapBatchSize { get; protected set; }
    [DescriptionAttribute("Number of minutes after which mapping will end even if there is more to map. This will only be applied if we pass the last etag we saw in the collection when the batch was started.")]
[DefaultValueAttribute("15")]
[TimeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.MapTimeoutAfterEtagReachedInMin", "2", "263", "True", "False")]
public TimeSetting MapTimeoutAfterEtagReached { get; protected set; }
    [DescriptionAttribute("Max number of steps in the script execution of a JavaScript index")]
[DefaultValueAttribute("10000")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.MaxStepsForScript", "2", "269", "True", "False")]
public int MaxStepsForScript { get; public set; }
    [DescriptionAttribute("Enables calling 'eval' with custom code and function constructors taking function code as string")]
[DefaultValueAttribute("False")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.AllowStringCompilation", "2", "275", "True", "False")]
public bool AllowStringCompilation { get; public set; }
    [DescriptionAttribute("Time (in minutes) between auto-index cleanup")]
[DefaultValueAttribute("10")]
[TimeUnitAttribute("2")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.CleanupIntervalInMin", "0", "282", "True", "False")]
public TimeSetting CleanupInterval { get; public set; }
    [DescriptionAttribute("Smallest n-gram to generate when NGram analyzer is used")]
[DefaultValueAttribute("2")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.Lucene.Analyzers.NGram.MinGram", "2", "288", "True", "False")]
[ConfigurationEntryAttribute("Indexing.Analyzers.NGram.MinGram", "2", "289", "True", "False")]
public int MinGram { get; public set; }
    [DescriptionAttribute("Largest n-gram to generate when NGram analyzer is used")]
[DefaultValueAttribute("6")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.Lucene.Analyzers.NGram.MaxGram", "2", "295", "True", "False")]
[ConfigurationEntryAttribute("Indexing.Analyzers.NGram.MaxGram", "2", "296", "True", "False")]
public int MaxGram { get; public set; }
    [DescriptionAttribute("Managed allocations limit in an indexing batch after which the batch will complete and an index will continue by starting a new one")]
[DefaultValueAttribute("2048")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.ManagedAllocationsBatchSizeLimitInMb", "2", "303", "True", "False")]
public Nullable`1<Size> ManagedAllocationsBatchLimit { get; protected set; }
    [DescriptionAttribute("EXPERT: The maximum size in MB that we'll consider for segments merging")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Lucene.MaximumSizePerSegmentInMb", "2", "310", "True", "False")]
[ConfigurationEntryAttribute("Indexing.MaximumSizePerSegmentInMb", "2", "311", "True", "False")]
public Size MaximumSizePerSegment { get; protected set; }
    [DescriptionAttribute("EXPERT: Set how often index segments are merged into larger ones. The merge process will start when the number of segments in an index reaches this number. With smaller values, less RAM is used while indexing, and searches on unoptimized indexes are faster, but indexing speed is slower.")]
[DefaultValueAttribute("10")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Lucene.MergeFactor", "2", "318", "True", "False")]
[ConfigurationEntryAttribute("Indexing.MergeFactor", "2", "319", "True", "False")]
public int MergeFactor { get; protected set; }
    [DescriptionAttribute("EXPERT: The definition of a large segment in MB. We wont merge more than NumberOfLargeSegmentsToMergeInSingleBatch in a single batch")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Lucene.LargeSegmentSizeToMergeInMb", "2", "326", "True", "False")]
[ConfigurationEntryAttribute("Indexing.LargeSegmentSizeToMergeInMb", "2", "327", "True", "False")]
public Size LargeSegmentSizeToMerge { get; protected set; }
    [DescriptionAttribute("EXPERT: Number of large segments (defined by LargeSegmentSizeToMerge) to merge in a single batch")]
[DefaultValueAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Lucene.NumberOfLargeSegmentsToMergeInSingleBatch", "2", "333", "True", "False")]
[ConfigurationEntryAttribute("Indexing.NumberOfLargeSegmentsToMergeInSingleBatch", "2", "334", "True", "False")]
public int NumberOfLargeSegmentsToMergeInSingleBatch { get; protected set; }
    [DescriptionAttribute("EXPERT: How long will we let merges to run before we close the transaction")]
[DefaultValueAttribute("15")]
[TimeUnitAttribute("1")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Lucene.MaxTimeForMergesToKeepRunningInSec", "2", "341", "True", "False")]
[ConfigurationEntryAttribute("Indexing.MaxTimeForMergesToKeepRunningInSec", "2", "342", "True", "False")]
public TimeSetting MaxTimeForMergesToKeepRunning { get; protected set; }
    [DescriptionAttribute("Transaction size limit after which an index will stop and complete the current batch")]
[DefaultValueAttribute("")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.TransactionSizeLimitInMb", "2", "349", "True", "False")]
public Nullable`1<Size> TransactionSizeLimit { get; protected set; }
    [DescriptionAttribute("Transaction size limit, for encrypted database only, after which an index will stop and complete the current batch")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Encrypted.TransactionSizeLimitInMb", "2", "356", "True", "False")]
public Nullable`1<Size> EncryptedTransactionSizeLimit { get; protected set; }
    [DescriptionAttribute("Amount of scratch space that we allow to use for the index storage. After exceeding this limit the current indexing batch will complete and the index will force flush and sync storage environment.")]
[DefaultValueAttribute("")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.ScratchSpaceLimitInMb", "2", "363", "True", "False")]
public Nullable`1<Size> ScratchSpaceLimit { get; protected set; }
    [DescriptionAttribute("Maximum amount of scratch space that we allow to use for all index storages per server. After exceeding this limit the indexes will complete their current indexing batches and force flush and sync storage environments.")]
[DefaultValueAttribute("")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.GlobalScratchSpaceLimitInMb", "0", "370", "True", "False")]
public Nullable`1<Size> GlobalScratchSpaceLimit { get; protected set; }
    [DescriptionAttribute("Max time to wait when forcing the storage environment flush and sync after exceeding scratch space limit")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.MaxTimeToWaitAfterFlushAndSyncWhenExceedingScratchSpaceLimitInSec", "0", "377", "True", "False")]
[ConfigurationEntryAttribute("Indexing.MaxTimeToWaitAfterFlushAndSyncWhenExceedingScratchSpaceLimit", "0", "378", "True", "False")]
public TimeSetting MaxTimeToWaitAfterFlushAndSyncWhenExceedingScratchSpaceLimit { get; protected set; }
    [DescriptionAttribute("Set how the indexing process should handle fields that are missing. When set to true, missing fields will be indexed with a null value.")]
[DefaultValueAttribute("False")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.IndexMissingFieldsAsNull", "2", "384", "True", "False")]
public bool IndexMissingFieldsAsNull { get; public set; }
    [DescriptionAttribute("Set how the indexing process should handle documents that are missing fields. When set to true, the indexing process will index documents even if they lack the fields that are supposed to be indexed.")]
[DefaultValueAttribute("False")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.IndexEmptyEntries", "2", "390", "True", "False")]
public bool IndexEmptyEntries { get; public set; }
    [DescriptionAttribute("Set how faulty indexes should behave on database startup when they are loaded. By default they are not started.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.ErrorIndexStartupBehavior", "1", "396", "True", "False")]
public ErrorIndexStartupBehaviorType ErrorIndexStartupBehavior { get; public set; }
    [DescriptionAttribute("Indicates how indexes should behave on database startup when they are loaded. By default they are started immediately.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.IndexStartupBehavior", "1", "402", "True", "False")]
public IndexStartupBehaviorType IndexStartupBehavior { get; public set; }
    [DescriptionAttribute("Set how many indexes can run concurrently on the server. Default: null (no limit).")]
[DefaultValueAttribute("")]
[MinValueAttribute("1")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.MaxNumberOfConcurrentlyRunningIndexes", "0", "409", "True", "False")]
public Nullable`1<int> MaxNumberOfConcurrentlyRunningIndexes { get; public set; }
    [DescriptionAttribute("Location of NuGet packages cache")]
[DefaultValueAttribute("Packages/NuGet")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.NuGetPackagesPath", "0", "415", "True", "False")]
public PathSetting NuGetPackagesPath { get; public set; }
    [DescriptionAttribute("Default NuGet source URL")]
[DefaultValueAttribute("https://api.nuget.org/v3/index.json")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.NuGetPackageSourceUrl", "0", "421", "True", "False")]
public string NuGetPackageSourceUrl { get; public set; }
    [DescriptionAttribute("Allow installation of NuGet prerelease packages")]
[DefaultValueAttribute("False")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.NuGetAllowPreReleasePackages", "0", "427", "True", "False")]
[ConfigurationEntryAttribute("Indexing.NuGetAllowPreleasePackages", "0", "428", "True", "False")]
public bool NuGetAllowPreleasePackages { get; public set; }
    [DescriptionAttribute("Number of index history revisions to keep per index")]
[DefaultValueAttribute("10")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.History.NumberOfRevisions", "1", "434", "True", "False")]
public int HistoryRevisionsNumber { get; public set; }
    [DescriptionAttribute("Default analyzer that will be used for fields.")]
[DefaultValueAttribute("LowerCaseKeywordAnalyzer")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.Analyzers.Default", "2", "440", "True", "False")]
public string DefaultAnalyzer { get; public set; }
    [DescriptionAttribute("Default analyzer that will be used for exact fields.")]
[DefaultValueAttribute("KeywordAnalyzer")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.Analyzers.Exact.Default", "2", "446", "True", "False")]
public string DefaultExactAnalyzer { get; public set; }
    [DescriptionAttribute("Default analyzer that will be used for search fields.")]
[DefaultValueAttribute("RavenStandardAnalyzer")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.Analyzers.Search.Default", "2", "452", "True", "False")]
public string DefaultSearchAnalyzer { get; public set; }
    [DescriptionAttribute("How long the index should delay processing after new work is detected")]
[DefaultValueAttribute("")]
[TimeUnitAttribute("0")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Throttling.TimeIntervalInMs", "2", "459", "True", "False")]
public Nullable`1<TimeSetting> ThrottlingTimeInterval { get; protected set; }
    [DescriptionAttribute("Search engine for auto indexes")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.Auto.SearchEngineType", "1", "465", "True", "False")]
public SearchEngineType AutoIndexingEngineType { get; protected set; }
    [DescriptionAttribute("Search engine for static indexes")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.Static.SearchEngineType", "2", "471", "True", "False")]
public SearchEngineType StaticIndexingEngineType { get; protected set; }
    [DescriptionAttribute("Corax index compression max documents used for dictionary creation.")]
[DefaultValueAttribute("100000")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.Corax.DocumentsLimitForCompressionDictionaryCreation", "2", "477", "True", "False")]
public int DocumentsLimitForCompressionDictionaryCreation { get; protected set; }
    public Lazy`1<AnalyzerFactory> DefaultAnalyzerType { get; private set; }
    public Lazy`1<AnalyzerFactory> DefaultExactAnalyzerType { get; private set; }
    public Lazy`1<AnalyzerFactory> DefaultSearchAnalyzerType { get; private set; }
    [DescriptionAttribute("EXPERT: Allows to open an index without checking if current Database ID matched the one for which index was created.")]
[DefaultValueAttribute("False")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.SkipDatabaseIdValidationOnIndexOpening", "1", "489", "True", "False")]
public bool SkipDatabaseIdValidationOnIndexOpening { get; public set; }
    [DescriptionAttribute("Time since last query after which a deep cleanup can be executed and additional items will be released (e.g. readers).")]
[DefaultValueAttribute("10")]
[TimeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.TimeSinceLastQueryAfterWhichDeepCleanupCanBeExecutedInMin", "2", "496", "True", "False")]
public TimeSetting TimeSinceLastQueryAfterWhichDeepCleanupCanBeExecuted { get; public set; }
    [DescriptionAttribute("Require database admin clearance to deploy JavaScript indexes")]
[DefaultValueAttribute("False")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.Static.RequireAdminToDeployJavaScriptIndexes", "1", "502", "True", "False")]
public bool RequireAdminToDeployJavaScriptIndexes { get; public set; }
    [DescriptionAttribute("Order by score automatically when boosting is inside index definition or query.")]
[DefaultValueAttribute("True")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.OrderByScoreAutomaticallyWhenBoostingIsInvolved", "2", "508", "True", "False")]
public bool OrderByScoreAutomaticallyWhenBoostingIsInvolved { get; public set; }
    [DescriptionAttribute("EXPERT: Use compound file in merging")]
[DefaultValueAttribute("True")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Lucene.UseCompoundFileInMerging", "2", "514", "True", "False")]
[ConfigurationEntryAttribute("Indexing.UseCompoundFileInMerging", "2", "515", "True", "False")]
public bool LuceneUseCompoundFileInMerging { get; public set; }
    [DescriptionAttribute("Lucene index input")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Lucene.IndexInputType", "2", "521", "True", "False")]
public LuceneIndexInputType LuceneIndexInput { get; public set; }
    [DescriptionAttribute("Max time to wait when forcing the storage environment flush and sync when replacing side-by-side index.")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.MaxTimeToWaitAfterFlushAndSyncWhenReplacingSideBySideIndexInSec", "2", "528", "True", "False")]
public TimeSetting MaxTimeToWaitAfterFlushAndSyncWhenReplacingSideBySideIndex { get; protected set; }
    [DescriptionAttribute("Minimum total size of journals to run flush and sync when replacing side by side index.")]
[DefaultValueAttribute("512")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.MinimumTotalSizeOfJournalsToRunFlushAndSyncWhenReplacingSideBySideIndexInMb", "2", "535", "True", "False")]
public Size MinimumTotalSizeOfJournalsToRunFlushAndSyncWhenReplacingSideBySideIndex { get; public set; }
    [DescriptionAttribute("Sort by ticks when field contains dates. When sorting in descending order, null dates are returned at the end with this option enabled.")]
[DefaultValueAttribute("True")]
[IndexUpdateTypeAttribute("0")]
[ConfigurationEntryAttribute("Indexing.OrderByTicksAutomaticallyWhenDatesAreInvolved", "2", "542", "True", "False")]
public bool OrderByTicksAutomaticallyWhenDatesAreInvolved { get; public set; }
    [DescriptionAttribute("EXPERT: Controls how many terms we'll keep in the cache for each field. Higher values reduce the memory usage at the expense of increased search time for each term.")]
[DefaultValueAttribute("1")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Lucene.ReaderTermsIndexDivisor", "2", "548", "True", "False")]
public int ReaderTermsIndexDivisor { get; public set; }
    [DescriptionAttribute("Include score value in the metadata when sorting by score. Disabling this option could enhance query performance.")]
[ConfigurationEntryAttribute("Indexing.Corax.IncludeDocumentScore", "2", "552", "True", "False")]
[DefaultValueAttribute("False")]
[IndexUpdateTypeAttribute("1")]
public bool CoraxIncludeDocumentScore { get; public set; }
    [DescriptionAttribute("Include spatial information in the metadata when sorting by distance. Disabling this option could enhance query performance.")]
[ConfigurationEntryAttribute("Indexing.Corax.IncludeSpatialDistance", "2", "558", "True", "False")]
[DefaultValueAttribute("False")]
[IndexUpdateTypeAttribute("1")]
public bool CoraxIncludeSpatialDistance { get; public set; }
    [DescriptionAttribute("The maximum amount of memory that Corax can use for a memoization clause during query processing")]
[DefaultValueAttribute("512")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Indexing.Corax.MaxMemoizationSizeInMb", "2", "567", "True", "False")]
public Size MaxMemoizationSize { get; public set; }
    [DescriptionAttribute("Expert: The maximum amount of MB that we'll allocate for training indexing dictionaries.")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[SizeUnitAttribute("2")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.Corax.MaxAllocationsAtDictionaryTrainingInMb", "2", "574", "True", "False")]
public Size MaxAllocationsAtDictionaryTraining { get; protected set; }
    [DescriptionAttribute("The default mode of the index reset operation.")]
[ConfigurationEntryAttribute("Indexing.ResetMode", "1", "578", "True", "False")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IndexUpdateTypeAttribute("0")]
public IndexResetMode ResetMode { get; public set; }
    [DescriptionAttribute("The default complex field indexing behavior for static Corax indexes")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IndexUpdateTypeAttribute("2")]
[ConfigurationEntryAttribute("Indexing.Corax.Static.ComplexFieldIndexingBehavior", "2", "586", "True", "False")]
public CoraxComplexFieldIndexingBehavior CoraxStaticIndexComplexFieldIndexingBehavior { get; protected set; }
    public IndexingConfiguration(RavenConfiguration root);
    private static IndexingConfiguration();
    private static HashSet`1<string> GetValidIndexingConfigurationKeys();
    public virtual bool get_RunInMemory();
    protected virtual void set_RunInMemory(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_Disabled();
    [CompilerGeneratedAttribute]
protected virtual void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public IndexDeploymentMode get_StaticIndexDeploymentMode();
    [CompilerGeneratedAttribute]
protected void set_StaticIndexDeploymentMode(IndexDeploymentMode value);
    [CompilerGeneratedAttribute]
public IndexDeploymentMode get_AutoIndexDeploymentMode();
    [CompilerGeneratedAttribute]
protected void set_AutoIndexDeploymentMode(IndexDeploymentMode value);
    [CompilerGeneratedAttribute]
public ArchivedDataProcessingBehavior get_AutoIndexArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
protected void set_AutoIndexArchivedDataProcessingBehavior(ArchivedDataProcessingBehavior value);
    [CompilerGeneratedAttribute]
public ArchivedDataProcessingBehavior get_StaticIndexArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
protected void set_StaticIndexArchivedDataProcessingBehavior(ArchivedDataProcessingBehavior value);
    [CompilerGeneratedAttribute]
public virtual bool get_EnableMetrics();
    [CompilerGeneratedAttribute]
protected virtual void set_EnableMetrics(bool value);
    public virtual PathSetting get_StoragePath();
    [CompilerGeneratedAttribute]
public virtual PathSetting get_TempPath();
    [CompilerGeneratedAttribute]
protected virtual void set_TempPath(PathSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxTimeForDocumentTransactionToRemainOpen();
    [CompilerGeneratedAttribute]
protected void set_MaxTimeForDocumentTransactionToRemainOpen(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_TimeBeforeDeletionOfSupersededAutoIndex();
    [CompilerGeneratedAttribute]
protected void set_TimeBeforeDeletionOfSupersededAutoIndex(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_TimeToWaitBeforeMarkingAutoIndexAsIdle();
    [CompilerGeneratedAttribute]
protected void set_TimeToWaitBeforeMarkingAutoIndexAsIdle(TimeSetting value);
    [CompilerGeneratedAttribute]
public bool get_DisableQueryOptimizerGeneratedIndexes();
    [CompilerGeneratedAttribute]
protected void set_DisableQueryOptimizerGeneratedIndexes(bool value);
    [CompilerGeneratedAttribute]
public TimeSetting get_TimeToWaitBeforeDeletingAutoIndexMarkedAsIdle();
    [CompilerGeneratedAttribute]
protected void set_TimeToWaitBeforeDeletingAutoIndexMarkedAsIdle(TimeSetting value);
    [CompilerGeneratedAttribute]
public int get_MinNumberOfMapAttemptsAfterWhichBatchWillBeCanceledIfRunningLowOnMemory();
    [CompilerGeneratedAttribute]
protected void set_MinNumberOfMapAttemptsAfterWhichBatchWillBeCanceledIfRunningLowOnMemory(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfConcurrentStoppedBatchesIfRunningLowOnMemory();
    [CompilerGeneratedAttribute]
protected void set_NumberOfConcurrentStoppedBatchesIfRunningLowOnMemory(int value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MapTimeout();
    [CompilerGeneratedAttribute]
protected void set_MapTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public Size get_QueryClauseCacheSize();
    [CompilerGeneratedAttribute]
protected void set_QueryClauseCacheSize(Size value);
    [CompilerGeneratedAttribute]
public bool get_QueryClauseCacheDisabled();
    [CompilerGeneratedAttribute]
protected void set_QueryClauseCacheDisabled(bool value);
    [CompilerGeneratedAttribute]
public TimeSetting get_QueryClauseCacheExpirationScanFrequency();
    [CompilerGeneratedAttribute]
protected void set_QueryClauseCacheExpirationScanFrequency(TimeSetting value);
    [CompilerGeneratedAttribute]
public int get_QueryClauseCacheRepeatedQueriesCount();
    [CompilerGeneratedAttribute]
protected void set_QueryClauseCacheRepeatedQueriesCount(int value);
    [CompilerGeneratedAttribute]
public TimeSetting get_QueryClauseCacheRepeatedQueriesTimeFrame();
    [CompilerGeneratedAttribute]
protected void set_QueryClauseCacheRepeatedQueriesTimeFrame(TimeSetting value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MapBatchSize();
    [CompilerGeneratedAttribute]
protected void set_MapBatchSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MapTimeoutAfterEtagReached();
    [CompilerGeneratedAttribute]
protected void set_MapTimeoutAfterEtagReached(TimeSetting value);
    [CompilerGeneratedAttribute]
public int get_MaxStepsForScript();
    [CompilerGeneratedAttribute]
public void set_MaxStepsForScript(int value);
    [CompilerGeneratedAttribute]
public bool get_AllowStringCompilation();
    [CompilerGeneratedAttribute]
public void set_AllowStringCompilation(bool value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CleanupInterval();
    [CompilerGeneratedAttribute]
public void set_CleanupInterval(TimeSetting value);
    [CompilerGeneratedAttribute]
public int get_MinGram();
    [CompilerGeneratedAttribute]
public void set_MinGram(int value);
    [CompilerGeneratedAttribute]
public int get_MaxGram();
    [CompilerGeneratedAttribute]
public void set_MaxGram(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_ManagedAllocationsBatchLimit();
    [CompilerGeneratedAttribute]
protected void set_ManagedAllocationsBatchLimit(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public Size get_MaximumSizePerSegment();
    [CompilerGeneratedAttribute]
protected void set_MaximumSizePerSegment(Size value);
    [CompilerGeneratedAttribute]
public int get_MergeFactor();
    [CompilerGeneratedAttribute]
protected void set_MergeFactor(int value);
    [CompilerGeneratedAttribute]
public Size get_LargeSegmentSizeToMerge();
    [CompilerGeneratedAttribute]
protected void set_LargeSegmentSizeToMerge(Size value);
    [CompilerGeneratedAttribute]
public int get_NumberOfLargeSegmentsToMergeInSingleBatch();
    [CompilerGeneratedAttribute]
protected void set_NumberOfLargeSegmentsToMergeInSingleBatch(int value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxTimeForMergesToKeepRunning();
    [CompilerGeneratedAttribute]
protected void set_MaxTimeForMergesToKeepRunning(TimeSetting value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_TransactionSizeLimit();
    [CompilerGeneratedAttribute]
protected void set_TransactionSizeLimit(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_EncryptedTransactionSizeLimit();
    [CompilerGeneratedAttribute]
protected void set_EncryptedTransactionSizeLimit(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_ScratchSpaceLimit();
    [CompilerGeneratedAttribute]
protected void set_ScratchSpaceLimit(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_GlobalScratchSpaceLimit();
    [CompilerGeneratedAttribute]
protected void set_GlobalScratchSpaceLimit(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxTimeToWaitAfterFlushAndSyncWhenExceedingScratchSpaceLimit();
    [CompilerGeneratedAttribute]
protected void set_MaxTimeToWaitAfterFlushAndSyncWhenExceedingScratchSpaceLimit(TimeSetting value);
    [CompilerGeneratedAttribute]
public bool get_IndexMissingFieldsAsNull();
    [CompilerGeneratedAttribute]
public void set_IndexMissingFieldsAsNull(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndexEmptyEntries();
    [CompilerGeneratedAttribute]
public void set_IndexEmptyEntries(bool value);
    [CompilerGeneratedAttribute]
public ErrorIndexStartupBehaviorType get_ErrorIndexStartupBehavior();
    [CompilerGeneratedAttribute]
public void set_ErrorIndexStartupBehavior(ErrorIndexStartupBehaviorType value);
    [CompilerGeneratedAttribute]
public IndexStartupBehaviorType get_IndexStartupBehavior();
    [CompilerGeneratedAttribute]
public void set_IndexStartupBehavior(IndexStartupBehaviorType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxNumberOfConcurrentlyRunningIndexes();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfConcurrentlyRunningIndexes(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public PathSetting get_NuGetPackagesPath();
    [CompilerGeneratedAttribute]
public void set_NuGetPackagesPath(PathSetting value);
    [CompilerGeneratedAttribute]
public string get_NuGetPackageSourceUrl();
    [CompilerGeneratedAttribute]
public void set_NuGetPackageSourceUrl(string value);
    [CompilerGeneratedAttribute]
public bool get_NuGetAllowPreleasePackages();
    [CompilerGeneratedAttribute]
public void set_NuGetAllowPreleasePackages(bool value);
    [CompilerGeneratedAttribute]
public int get_HistoryRevisionsNumber();
    [CompilerGeneratedAttribute]
public void set_HistoryRevisionsNumber(int value);
    [CompilerGeneratedAttribute]
public string get_DefaultAnalyzer();
    [CompilerGeneratedAttribute]
public void set_DefaultAnalyzer(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultExactAnalyzer();
    [CompilerGeneratedAttribute]
public void set_DefaultExactAnalyzer(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultSearchAnalyzer();
    [CompilerGeneratedAttribute]
public void set_DefaultSearchAnalyzer(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSetting> get_ThrottlingTimeInterval();
    [CompilerGeneratedAttribute]
protected void set_ThrottlingTimeInterval(Nullable`1<TimeSetting> value);
    [CompilerGeneratedAttribute]
public SearchEngineType get_AutoIndexingEngineType();
    [CompilerGeneratedAttribute]
protected void set_AutoIndexingEngineType(SearchEngineType value);
    [CompilerGeneratedAttribute]
public SearchEngineType get_StaticIndexingEngineType();
    [CompilerGeneratedAttribute]
protected void set_StaticIndexingEngineType(SearchEngineType value);
    [CompilerGeneratedAttribute]
public int get_DocumentsLimitForCompressionDictionaryCreation();
    [CompilerGeneratedAttribute]
protected void set_DocumentsLimitForCompressionDictionaryCreation(int value);
    [CompilerGeneratedAttribute]
public Lazy`1<AnalyzerFactory> get_DefaultAnalyzerType();
    [CompilerGeneratedAttribute]
private void set_DefaultAnalyzerType(Lazy`1<AnalyzerFactory> value);
    [CompilerGeneratedAttribute]
public Lazy`1<AnalyzerFactory> get_DefaultExactAnalyzerType();
    [CompilerGeneratedAttribute]
private void set_DefaultExactAnalyzerType(Lazy`1<AnalyzerFactory> value);
    [CompilerGeneratedAttribute]
public Lazy`1<AnalyzerFactory> get_DefaultSearchAnalyzerType();
    [CompilerGeneratedAttribute]
private void set_DefaultSearchAnalyzerType(Lazy`1<AnalyzerFactory> value);
    [CompilerGeneratedAttribute]
public bool get_SkipDatabaseIdValidationOnIndexOpening();
    [CompilerGeneratedAttribute]
public void set_SkipDatabaseIdValidationOnIndexOpening(bool value);
    [CompilerGeneratedAttribute]
public TimeSetting get_TimeSinceLastQueryAfterWhichDeepCleanupCanBeExecuted();
    [CompilerGeneratedAttribute]
public void set_TimeSinceLastQueryAfterWhichDeepCleanupCanBeExecuted(TimeSetting value);
    [CompilerGeneratedAttribute]
public bool get_RequireAdminToDeployJavaScriptIndexes();
    [CompilerGeneratedAttribute]
public void set_RequireAdminToDeployJavaScriptIndexes(bool value);
    [CompilerGeneratedAttribute]
public bool get_OrderByScoreAutomaticallyWhenBoostingIsInvolved();
    [CompilerGeneratedAttribute]
public void set_OrderByScoreAutomaticallyWhenBoostingIsInvolved(bool value);
    [CompilerGeneratedAttribute]
public bool get_LuceneUseCompoundFileInMerging();
    [CompilerGeneratedAttribute]
public void set_LuceneUseCompoundFileInMerging(bool value);
    [CompilerGeneratedAttribute]
public LuceneIndexInputType get_LuceneIndexInput();
    [CompilerGeneratedAttribute]
public void set_LuceneIndexInput(LuceneIndexInputType value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxTimeToWaitAfterFlushAndSyncWhenReplacingSideBySideIndex();
    [CompilerGeneratedAttribute]
protected void set_MaxTimeToWaitAfterFlushAndSyncWhenReplacingSideBySideIndex(TimeSetting value);
    [CompilerGeneratedAttribute]
public Size get_MinimumTotalSizeOfJournalsToRunFlushAndSyncWhenReplacingSideBySideIndex();
    [CompilerGeneratedAttribute]
public void set_MinimumTotalSizeOfJournalsToRunFlushAndSyncWhenReplacingSideBySideIndex(Size value);
    [CompilerGeneratedAttribute]
public bool get_OrderByTicksAutomaticallyWhenDatesAreInvolved();
    [CompilerGeneratedAttribute]
public void set_OrderByTicksAutomaticallyWhenDatesAreInvolved(bool value);
    [CompilerGeneratedAttribute]
public int get_ReaderTermsIndexDivisor();
    [CompilerGeneratedAttribute]
public void set_ReaderTermsIndexDivisor(int value);
    [CompilerGeneratedAttribute]
public bool get_CoraxIncludeDocumentScore();
    [CompilerGeneratedAttribute]
public void set_CoraxIncludeDocumentScore(bool value);
    [CompilerGeneratedAttribute]
public bool get_CoraxIncludeSpatialDistance();
    [CompilerGeneratedAttribute]
public void set_CoraxIncludeSpatialDistance(bool value);
    [CompilerGeneratedAttribute]
public Size get_MaxMemoizationSize();
    [CompilerGeneratedAttribute]
public void set_MaxMemoizationSize(Size value);
    [CompilerGeneratedAttribute]
public Size get_MaxAllocationsAtDictionaryTraining();
    [CompilerGeneratedAttribute]
protected void set_MaxAllocationsAtDictionaryTraining(Size value);
    [CompilerGeneratedAttribute]
public IndexResetMode get_ResetMode();
    [CompilerGeneratedAttribute]
public void set_ResetMode(IndexResetMode value);
    [CompilerGeneratedAttribute]
public CoraxComplexFieldIndexingBehavior get_CoraxStaticIndexComplexFieldIndexingBehavior();
    [CompilerGeneratedAttribute]
protected void set_CoraxStaticIndexComplexFieldIndexingBehavior(CoraxComplexFieldIndexingBehavior value);
    protected virtual void ValidateProperty(PropertyInfo property);
    public virtual void Initialize(IConfigurationRoot settings, HashSet`1<string> settingsNames, IConfigurationRoot serverWideSettings, HashSet`1<string> serverWideSettingsNames, ResourceType type, string resourceName);
    public void InitializeAnalyzers(string resourceName);
}
[ConfigurationCategoryAttribute("9")]
public class Raven.Server.Config.Categories.IntegrationsConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private PostgreSqlConfiguration <PostgreSql>k__BackingField;
    public PostgreSqlConfiguration PostgreSql { get; }
    [CompilerGeneratedAttribute]
public PostgreSqlConfiguration get_PostgreSql();
    public virtual void Initialize(IConfigurationRoot settings, HashSet`1<string> settingsNames, IConfigurationRoot serverWideSettings, HashSet`1<string> serverWideSettingsNames, ResourceType type, string resourceName);
}
[ConfigurationCategoryAttribute("10")]
public class Raven.Server.Config.Categories.LicenseConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private string <License>k__BackingField;
    [CompilerGeneratedAttribute]
private PathSetting <LicensePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EulaAccepted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanActivate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanForceUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRenew>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipLeasingErrorsLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableAutoUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableAutoUpdateFromApi>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableLicenseSupportCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowOnInvalidOrMissingLicense>k__BackingField;
    [DescriptionAttribute("The full license string for RavenDB. If License is specified, it overrides the License.Path configuration.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("License", "1", "15", "True", "True")]
public string License { get; public set; }
    [DescriptionAttribute("The path to the license file for RavenDB, default for license.json")]
[ReadOnlyPathAttribute]
[DefaultValueAttribute("license.json")]
[ConfigurationEntryAttribute("License.Path", "1", "21", "True", "False")]
public PathSetting LicensePath { get; public set; }
    [DescriptionAttribute("Indicates if End-User License Agreement was accepted")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("License.Eula.Accepted", "0", "26", "True", "False")]
public bool EulaAccepted { get; public set; }
    [DescriptionAttribute("EXPERT ONLY. Indicates if license can be activated")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("License.CanActivate", "0", "31", "True", "False")]
public bool CanActivate { get; public set; }
    [DescriptionAttribute("EXPERT ONLY. Indicates if license can be updated from api.ravendb.net")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("License.CanForceUpdate", "0", "36", "True", "False")]
public bool CanForceUpdate { get; public set; }
    [DescriptionAttribute("EXPERT ONLY. Indicates if license can be renewed from api.ravendb.net")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("License.CanRenew", "0", "41", "True", "False")]
[ConfigurationEntryAttribute("License.CanRenewLicense", "0", "42", "True", "False")]
public bool CanRenew { get; public set; }
    [DescriptionAttribute("EXPERT ONLY. Skip logging of lease license errors")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("License.SkipLeasingErrorsLogging", "0", "47", "True", "False")]
public bool SkipLeasingErrorsLogging { get; public set; }
    [DescriptionAttribute("EXPERT ONLY. Disable automatic updating of the license")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("License.DisableAutoUpdate", "0", "52", "True", "False")]
public bool DisableAutoUpdate { get; public set; }
    [DescriptionAttribute("EXPERT ONLY. Disable automatic updating of the license from api.ravendb.net")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("License.DisableAutoUpdateFromApi", "0", "57", "True", "False")]
public bool DisableAutoUpdateFromApi { get; public set; }
    [DescriptionAttribute("EXPERT ONLY. Disable checking the support options for the license")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("License.DisableLicenseSupportCheck", "0", "62", "True", "False")]
public bool DisableLicenseSupportCheck { get; public set; }
    [DescriptionAttribute("EXPERT ONLY. Throws an exception if the license cannot be activated or is not present")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("License.ThrowOnInvalidOrMissingLicense", "0", "67", "True", "False")]
public bool ThrowOnInvalidOrMissingLicense { get; public set; }
    [CompilerGeneratedAttribute]
public string get_License();
    [CompilerGeneratedAttribute]
public void set_License(string value);
    [CompilerGeneratedAttribute]
public PathSetting get_LicensePath();
    [CompilerGeneratedAttribute]
public void set_LicensePath(PathSetting value);
    [CompilerGeneratedAttribute]
public bool get_EulaAccepted();
    [CompilerGeneratedAttribute]
public void set_EulaAccepted(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanActivate();
    [CompilerGeneratedAttribute]
public void set_CanActivate(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanForceUpdate();
    [CompilerGeneratedAttribute]
public void set_CanForceUpdate(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanRenew();
    [CompilerGeneratedAttribute]
public void set_CanRenew(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipLeasingErrorsLogging();
    [CompilerGeneratedAttribute]
public void set_SkipLeasingErrorsLogging(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableAutoUpdate();
    [CompilerGeneratedAttribute]
public void set_DisableAutoUpdate(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableAutoUpdateFromApi();
    [CompilerGeneratedAttribute]
public void set_DisableAutoUpdateFromApi(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableLicenseSupportCheck();
    [CompilerGeneratedAttribute]
public void set_DisableLicenseSupportCheck(bool value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnInvalidOrMissingLicense();
    [CompilerGeneratedAttribute]
public void set_ThrowOnInvalidOrMissingLicense(bool value);
}
[ConfigurationCategoryAttribute("11")]
public class Raven.Server.Config.Categories.LogsConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private PathSetting <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private LogMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSetting> <RetentionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <RetentionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Compress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableMicrosoftLogs>k__BackingField;
    [CompilerGeneratedAttribute]
private PathSetting <MicrosoftLogsConfigurationPath>k__BackingField;
    [DescriptionAttribute("The path to the directory where the RavenDB server logs will be stored")]
[DefaultValueAttribute("Logs")]
[ConfigurationEntryAttribute("Logs.Path", "0", "14", "True", "False")]
public PathSetting Path { get; public set; }
    [DescriptionAttribute("The level of logs that will be written to the log files (None, Operations or Information)")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Logs.Mode", "0", "19", "True", "False")]
public LogMode Mode { get; public set; }
    [DescriptionAttribute("Determine whether logs are timestamped in UTC or with server-local time")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Logs.UseUtcTime", "0", "24", "True", "False")]
public bool UseUtcTime { get; public set; }
    [DescriptionAttribute("The maximum log file size in megabytes")]
[DefaultValueAttribute("128")]
[MinValueAttribute("16")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Logs.MaxFileSizeInMb", "0", "31", "True", "False")]
public Size MaxFileSize { get; public set; }
    [DescriptionAttribute("The number of hours logs are kept before they are deleted")]
[DefaultValueAttribute("72")]
[MinValueAttribute("24")]
[TimeUnitAttribute("3")]
[ConfigurationEntryAttribute("Logs.RetentionTimeInHrs", "0", "38", "True", "False")]
public Nullable`1<TimeSetting> RetentionTime { get; public set; }
    [DescriptionAttribute("The maximum log size after which older files will be deleted. No log files will be deleted if this configuration is not set.")]
[DefaultValueAttribute("")]
[MinValueAttribute("256")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Logs.RetentionSizeInMb", "0", "45", "True", "False")]
public Nullable`1<Size> RetentionSize { get; public set; }
    [DescriptionAttribute("Determine whether to compress the log files")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Logs.Compress", "0", "50", "True", "False")]
public bool Compress { get; public set; }
    [DescriptionAttribute("Determine whether to disable Microsoft logs")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Logs.Microsoft.Disable", "0", "56", "True", "False")]
public bool DisableMicrosoftLogs { get; public set; }
    [DescriptionAttribute("The path to the JSON configuration file for Microsoft logs")]
[ReadOnlyPathAttribute]
[DefaultValueAttribute("settings.logs.microsoft.json")]
[ConfigurationEntryAttribute("Logs.Microsoft.ConfigurationPath", "0", "62", "True", "False")]
public PathSetting MicrosoftLogsConfigurationPath { get; public set; }
    [CompilerGeneratedAttribute]
public PathSetting get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(PathSetting value);
    [CompilerGeneratedAttribute]
public LogMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(LogMode value);
    [CompilerGeneratedAttribute]
public bool get_UseUtcTime();
    [CompilerGeneratedAttribute]
public void set_UseUtcTime(bool value);
    [CompilerGeneratedAttribute]
public Size get_MaxFileSize();
    [CompilerGeneratedAttribute]
public void set_MaxFileSize(Size value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSetting> get_RetentionTime();
    [CompilerGeneratedAttribute]
public void set_RetentionTime(Nullable`1<TimeSetting> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_RetentionSize();
    [CompilerGeneratedAttribute]
public void set_RetentionSize(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public bool get_Compress();
    [CompilerGeneratedAttribute]
public void set_Compress(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableMicrosoftLogs();
    [CompilerGeneratedAttribute]
public void set_DisableMicrosoftLogs(bool value);
    [CompilerGeneratedAttribute]
public PathSetting get_MicrosoftLogsConfigurationPath();
    [CompilerGeneratedAttribute]
public void set_MicrosoftLogsConfigurationPath(PathSetting value);
}
[ConfigurationCategoryAttribute("12")]
public class Raven.Server.Config.Categories.MemoryConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private Size <LowMemoryLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <LowMemoryCommitLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxContextSizeToKeep>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MinimumFreeCommittedMemoryPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxFreeCommittedMemoryToKeep>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseTotalDirtyMemInsteadOfMemUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableHighTemporaryDirtyMemoryUse>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TemporaryDirtyMemoryAllowedPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <TemporaryDirtyMemoryChecksPeriod>k__BackingField;
    [CompilerGeneratedAttribute]
private float <LargeObjectHeapCompactionThresholdPercentage>k__BackingField;
    [DescriptionAttribute("The minimum amount of available memory RavenDB will attempt to achieve (free memory lower than this value will trigger low memory behavior)")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Memory.LowMemoryLimitInMb", "0", "29", "True", "False")]
public Size LowMemoryLimit { get; public set; }
    [DescriptionAttribute("The minimum amount of available commited memory RavenDB will attempt to achieve (free commited memory lower than this value will trigger low memory behavior)")]
[DefaultValueAttribute("512")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Memory.LowMemoryCommitLimitInMb", "0", "35", "True", "False")]
public Size LowMemoryCommitLimit { get; public set; }
    [DescriptionAttribute("The maximum size of context to keep in the pool after dispose")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Memory.MaxContextSizeToKeepInMb", "0", "41", "True", "False")]
public Size MaxContextSizeToKeep { get; public set; }
    [DescriptionAttribute("EXPERT: The minimum amount of committed memory percentage that RavenDB will attempt to ensure remains available. Reducing this value too much may cause RavenDB to fail if there is not enough memory available for the operation system to handle operations.")]
[DefaultValueAttribute("0,05")]
[ConfigurationEntryAttribute("Memory.MinimumFreeCommittedMemoryPercentage", "0", "46", "True", "False")]
public float MinimumFreeCommittedMemoryPercentage { get; public set; }
    [DescriptionAttribute("EXPERT: The maximum amount of committed memory that RavenDB will attempt to ensure remains available. Reducing this value too much may cause RavenDB to fail if there is not enough memory available for the operation system to handle operations.")]
[DefaultValueAttribute("128")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Memory.MaxFreeCommittedMemoryToKeepInMb", "0", "52", "True", "False")]
public Size MaxFreeCommittedMemoryToKeep { get; public set; }
    [DescriptionAttribute("EXPERT: Use entire process dirty memory instead of 'memory.usage_in_bytes minus Shared Clean Memory' value to determine machine memory usage. Applicable only when running on Linux. Default: 'true' when 'RAVEN_IN_DOCKER' environment variable is set to 'true', 'false' otherwise.")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[ConfigurationEntryAttribute("Memory.UseTotalDirtyMemInsteadOfMemUsage", "0", "57", "True", "False")]
public bool UseTotalDirtyMemInsteadOfMemUsage { get; public set; }
    [DescriptionAttribute("EXPERT: Whether the high temporary dirty memory check is enabled. Default: true if the system has more than 2GB RAM")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[ConfigurationEntryAttribute("Memory.EnableHighTemporaryDirtyMemoryUse", "0", "62", "True", "False")]
public bool EnableHighTemporaryDirtyMemoryUse { get; public set; }
    [DescriptionAttribute("EXPERT: Threshold percentage of memory for activating 'High Dirty Memory' mechanism (server will return 'Service Unavailable' for writes when scratch files dirty memory exeeds this threshold). Default: 25%")]
[DefaultValueAttribute("0,25")]
[ConfigurationEntryAttribute("Memory.TemporaryDirtyMemoryAllowedPercentage", "0", "67", "True", "False")]
public float TemporaryDirtyMemoryAllowedPercentage { get; public set; }
    [DescriptionAttribute("EXPERT: Period in seconds between 'High Dirty Memory' checks. Default: 30 seconds")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Memory.TemporaryDirtyMemoryChecksPeriodInSec", "0", "73", "True", "False")]
public TimeSetting TemporaryDirtyMemoryChecksPeriod { get; public set; }
    [DescriptionAttribute("EXPERT: Force the compaction of Large Object Heap during the next generation 2 GC if its size exceeds the given threshold percentage of installed memory. Default: 25%")]
[DefaultValueAttribute("0,25")]
[ConfigurationEntryAttribute("Memory.GC.LargeObjectHeapCompactionThresholdPercentage", "0", "78", "True", "False")]
public float LargeObjectHeapCompactionThresholdPercentage { get; public set; }
    [CompilerGeneratedAttribute]
public Size get_LowMemoryLimit();
    [CompilerGeneratedAttribute]
public void set_LowMemoryLimit(Size value);
    [CompilerGeneratedAttribute]
public Size get_LowMemoryCommitLimit();
    [CompilerGeneratedAttribute]
public void set_LowMemoryCommitLimit(Size value);
    [CompilerGeneratedAttribute]
public Size get_MaxContextSizeToKeep();
    [CompilerGeneratedAttribute]
public void set_MaxContextSizeToKeep(Size value);
    [CompilerGeneratedAttribute]
public float get_MinimumFreeCommittedMemoryPercentage();
    [CompilerGeneratedAttribute]
public void set_MinimumFreeCommittedMemoryPercentage(float value);
    [CompilerGeneratedAttribute]
public Size get_MaxFreeCommittedMemoryToKeep();
    [CompilerGeneratedAttribute]
public void set_MaxFreeCommittedMemoryToKeep(Size value);
    [CompilerGeneratedAttribute]
public bool get_UseTotalDirtyMemInsteadOfMemUsage();
    [CompilerGeneratedAttribute]
public void set_UseTotalDirtyMemInsteadOfMemUsage(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableHighTemporaryDirtyMemoryUse();
    [CompilerGeneratedAttribute]
public void set_EnableHighTemporaryDirtyMemoryUse(bool value);
    [CompilerGeneratedAttribute]
public float get_TemporaryDirtyMemoryAllowedPercentage();
    [CompilerGeneratedAttribute]
public void set_TemporaryDirtyMemoryAllowedPercentage(float value);
    [CompilerGeneratedAttribute]
public TimeSetting get_TemporaryDirtyMemoryChecksPeriod();
    [CompilerGeneratedAttribute]
public void set_TemporaryDirtyMemoryChecksPeriod(TimeSetting value);
    [CompilerGeneratedAttribute]
public float get_LargeObjectHeapCompactionThresholdPercentage();
    [CompilerGeneratedAttribute]
public void set_LargeObjectHeapCompactionThresholdPercentage(float value);
}
[ConfigurationCategoryAttribute("13")]
public class Raven.Server.Config.Categories.MigrationConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private PathSetting <MigratorPath>k__BackingField;
    [DescriptionAttribute("The full path of the directory containing the Raven.Migrator executable. Setting this option here will disable the ability to set a path in the Studio.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Migration.MigratorPath", "0", "12", "True", "False")]
public PathSetting MigratorPath { get; public set; }
    [CompilerGeneratedAttribute]
public PathSetting get_MigratorPath();
    [CompilerGeneratedAttribute]
public void set_MigratorPath(PathSetting value);
}
[ConfigurationCategoryAttribute("14")]
public class Raven.Server.Config.Categories.MonitoringConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private string <CpuUsageMonitorExec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CpuUsageMonitorExecArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MinDiskStatsInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private SnmpConfiguration <Snmp>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenTelemetryConfiguration <OpenTelemetry>k__BackingField;
    [DescriptionAttribute("A command or executable to run which will provide machine cpu usage and total machine cores to standard output. If specified, RavenDB will use this information for monitoring cpu usage.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Monitoring.Cpu.Exec", "0", "18", "True", "False")]
public string CpuUsageMonitorExec { get; public set; }
    [DescriptionAttribute("The command line arguments for the 'Monitoring.Cpu.Exec' command or executable. The arguments must be escaped for the command line.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Monitoring.Cpu.Exec.Arguments", "0", "23", "True", "True")]
public string CpuUsageMonitorExecArguments { get; public set; }
    [DescriptionAttribute("The minimum interval between measures to calculate the disk stats")]
[DefaultValueAttribute("1000")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("Monitoring.Disk.ReadStatsDebounceTimeInMs", "0", "29", "True", "False")]
public TimeSetting MinDiskStatsInterval { get; public set; }
    public SnmpConfiguration Snmp { get; }
    public OpenTelemetryConfiguration OpenTelemetry { get; }
    [CompilerGeneratedAttribute]
public string get_CpuUsageMonitorExec();
    [CompilerGeneratedAttribute]
public void set_CpuUsageMonitorExec(string value);
    [CompilerGeneratedAttribute]
public string get_CpuUsageMonitorExecArguments();
    [CompilerGeneratedAttribute]
public void set_CpuUsageMonitorExecArguments(string value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MinDiskStatsInterval();
    [CompilerGeneratedAttribute]
public void set_MinDiskStatsInterval(TimeSetting value);
    [CompilerGeneratedAttribute]
public SnmpConfiguration get_Snmp();
    [CompilerGeneratedAttribute]
public OpenTelemetryConfiguration get_OpenTelemetry();
    public virtual void Initialize(IConfigurationRoot settings, HashSet`1<string> settingsNames, IConfigurationRoot serverWideSettings, HashSet`1<string> serverWideSettingsNames, ResourceType type, string resourceName);
}
[ConfigurationCategoryAttribute("15")]
public class Raven.Server.Config.Categories.NotificationsConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <FilteredOutNotifications>k__BackingField;
    [DescriptionAttribute("Semicolon seperated list of notification names which will not be shown in the Studio. If not specified, all notifications are allowed. Example: "SlowIO;Server_NewVersionAvailable;ClusterTopologyWarning".")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Notifications.FilterOut", "0", "13", "True", "False")]
public HashSet`1<string> FilteredOutNotifications { get; public set; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_FilteredOutNotifications();
    [CompilerGeneratedAttribute]
public void set_FilteredOutNotifications(HashSet`1<string> value);
    public bool ShouldFilterOut(Notification notification);
}
[ConfigurationCategoryAttribute("16")]
public class Raven.Server.Config.Categories.PatchingConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private int <MaxStepsForScript>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowStringCompilation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictMode>k__BackingField;
    [DescriptionAttribute("Max number of steps in the script execution of a JavaScript patch")]
[DefaultValueAttribute("10000")]
[ConfigurationEntryAttribute("Patching.MaxStepsForScript", "1", "15", "True", "False")]
public int MaxStepsForScript { get; public set; }
    [DescriptionAttribute("Enables calling 'eval' with custom code and function constructors taking function code as string")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Patching.AllowStringCompilation", "1", "20", "True", "False")]
public bool AllowStringCompilation { get; public set; }
    [DescriptionAttribute("Enables Strict Mode in JavaScript engine. Default: true")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Patching.StrictMode", "1", "25", "True", "False")]
public bool StrictMode { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxStepsForScript();
    [CompilerGeneratedAttribute]
public void set_MaxStepsForScript(int value);
    [CompilerGeneratedAttribute]
public bool get_AllowStringCompilation();
    [CompilerGeneratedAttribute]
public void set_AllowStringCompilation(bool value);
    [CompilerGeneratedAttribute]
public bool get_StrictMode();
    [CompilerGeneratedAttribute]
public void set_StrictMode(bool value);
}
[ConfigurationCategoryAttribute("17")]
public class Raven.Server.Config.Categories.PerformanceHintsConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private Size <HugeDocumentSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HugeDocumentsCollectionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxWarnIndexOutputsPerDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfResults>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <TooLongRequestThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MinSwapSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfLoadsPerReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlertWhenSourceDocumentIncludedInOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDepthOfRecursionInLinqSelect>k__BackingField;
    [DescriptionAttribute("The size of a document after which it will get into the huge documents collection")]
[DefaultValueAttribute("5")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("PerformanceHints.Documents.HugeDocumentSizeInMb", "1", "27", "True", "False")]
public Size HugeDocumentSize { get; public set; }
    [DescriptionAttribute("The maximum size of the huge documents collection")]
[DefaultValueAttribute("100")]
[ConfigurationEntryAttribute("PerformanceHints.Documents.HugeDocumentsCollectionSize", "1", "32", "True", "False")]
public int HugeDocumentsCollectionSize { get; public set; }
    [DescriptionAttribute("The maximum number of index outputs per document after which we will create a performance hint")]
[DefaultValueAttribute("1024")]
[ConfigurationEntryAttribute("PerformanceHints.Indexing.MaxIndexOutputsPerDocument", "1", "37", "True", "False")]
public int MaxWarnIndexOutputsPerDocument { get; public set; }
    [DescriptionAttribute("The maximum number of query results after which we will create a performance hint")]
[DefaultValueAttribute("2048")]
[ConfigurationEntryAttribute("PerformanceHints.MaxNumberOfResults", "1", "42", "True", "False")]
public int MaxNumberOfResults { get; public set; }
    [DescriptionAttribute("Request latency threshold before the server would issue a performance hint")]
[ConfigurationEntryAttribute("PerformanceHints.TooLongRequestThresholdInSec", "1", "46", "True", "False")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
public TimeSetting TooLongRequestThreshold { get; public set; }
    [DescriptionAttribute("The minimum swap size (for Linux only). If the swap size is lower a notification will arise")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("PerformanceHints.Memory.MinSwapSizeInMb", "0", "54", "True", "False")]
public Size MinSwapSize { get; public set; }
    [DescriptionAttribute("The maximum number of LoadDocument()/LoadCompareExchangeValue() calls per a reference document/compare exchange value after which we will create a performance hint")]
[DefaultValueAttribute("1024")]
[ConfigurationEntryAttribute("PerformanceHints.Indexing.MaxNumberOfLoadsPerReference", "1", "59", "True", "False")]
public int MaxNumberOfLoadsPerReference { get; public set; }
    [DescriptionAttribute("Alert when source document in indexed as field.")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("PerformanceHints.Indexing.AlertWhenSourceDocumentIncludedInOutput", "1", "64", "True", "False")]
public bool AlertWhenSourceDocumentIncludedInOutput { get; public set; }
    [DescriptionAttribute("Maximum depth of recursion in LINQ Select clause.")]
[DefaultValueAttribute("32")]
[ConfigurationEntryAttribute("PerformanceHints.Indexing.MaxDepthOfRecursionInLinqSelect", "1", "69", "True", "False")]
public int MaxDepthOfRecursionInLinqSelect { get; public set; }
    [CompilerGeneratedAttribute]
public Size get_HugeDocumentSize();
    [CompilerGeneratedAttribute]
public void set_HugeDocumentSize(Size value);
    [CompilerGeneratedAttribute]
public int get_HugeDocumentsCollectionSize();
    [CompilerGeneratedAttribute]
public void set_HugeDocumentsCollectionSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxWarnIndexOutputsPerDocument();
    [CompilerGeneratedAttribute]
public void set_MaxWarnIndexOutputsPerDocument(int value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfResults();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfResults(int value);
    [CompilerGeneratedAttribute]
public TimeSetting get_TooLongRequestThreshold();
    [CompilerGeneratedAttribute]
public void set_TooLongRequestThreshold(TimeSetting value);
    [CompilerGeneratedAttribute]
public Size get_MinSwapSize();
    [CompilerGeneratedAttribute]
public void set_MinSwapSize(Size value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfLoadsPerReference();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfLoadsPerReference(int value);
    [CompilerGeneratedAttribute]
public bool get_AlertWhenSourceDocumentIncludedInOutput();
    [CompilerGeneratedAttribute]
public void set_AlertWhenSourceDocumentIncludedInOutput(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxDepthOfRecursionInLinqSelect();
    [CompilerGeneratedAttribute]
public void set_MaxDepthOfRecursionInLinqSelect(int value);
}
[ConfigurationCategoryAttribute("18")]
public class Raven.Server.Config.Categories.QueryConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxClauseCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <RegexTimeout>k__BackingField;
    [DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Query.MaxClauseCount", "0", "12", "True", "False")]
public Nullable`1<int> MaxClauseCount { get; public set; }
    [DescriptionAttribute("Timeout for Regex in regex query.")]
[TimeUnitAttribute("0")]
[DefaultValueAttribute("100")]
[IndexUpdateTypeAttribute("1")]
[ConfigurationEntryAttribute("Query.RegexTimeoutInMs", "2", "19", "True", "False")]
public TimeSetting RegexTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxClauseCount();
    [CompilerGeneratedAttribute]
public void set_MaxClauseCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TimeSetting get_RegexTimeout();
    [CompilerGeneratedAttribute]
public void set_RegexTimeout(TimeSetting value);
}
[ConfigurationCategoryAttribute("30")]
public class Raven.Server.Config.Categories.QueueSinkConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MaxFallbackTime>k__BackingField;
    [DescriptionAttribute("Max number of pulled messages consumed in a single batch")]
[DefaultValueAttribute("8192")]
[ConfigurationEntryAttribute("QueueSink.MaxBatchSize", "1", "12", "True", "False")]
public Nullable`1<int> MaxBatchSize { get; protected set; }
    [DescriptionAttribute("Maximum number of seconds Queue Sink process will be in a fallback mode after a connection failure. The fallback mode means suspending the process.")]
[DefaultValueAttribute("900")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("QueueSink.MaxFallbackTimeInSec", "1", "18", "True", "False")]
public TimeSetting MaxFallbackTime { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxBatchSize();
    [CompilerGeneratedAttribute]
protected void set_MaxBatchSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxFallbackTime();
    [CompilerGeneratedAttribute]
public void set_MaxFallbackTime(TimeSetting value);
}
public enum Raven.Server.Config.Categories.ReleaseChannel : Enum {
    public int value__;
    public static ReleaseChannel Stable;
    public static ReleaseChannel Patch;
    public static ReleaseChannel Dev;
}
[ConfigurationCategoryAttribute("19")]
public class Raven.Server.Config.Categories.ReplicationConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private TimeSetting <ActiveConnectionTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <ReplicationMinimalHeartbeat>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <RetryReplicateAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <RetryMaxTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxItemsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <MaxSizeToSend>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfEnumeratedDocumentsToCheckIfPulseLimitExceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfAttachmentsTrackedForDeduplication>k__BackingField;
    [DescriptionAttribute("Threshold under which an incoming replication connection is considered active. If an incoming connection receives messages within this time-span, new connection coming from the same source would be rejected (as the existing connection is considered active)")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Replication.ActiveConnectionTimeoutInSec", "1", "14", "True", "False")]
public TimeSetting ActiveConnectionTimeout { get; public set; }
    [DescriptionAttribute("Minimal time in seconds before sending another heartbeat")]
[DefaultValueAttribute("15")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Replication.ReplicationMinimalHeartbeatInSec", "1", "20", "True", "False")]
public TimeSetting ReplicationMinimalHeartbeat { get; public set; }
    [DescriptionAttribute("If the replication failed, we try to replicate again after the specified time elapsed.")]
[DefaultValueAttribute("15")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Replication.RetryReplicateAfterInSec", "1", "26", "True", "False")]
public TimeSetting RetryReplicateAfter { get; public set; }
    [DescriptionAttribute("Max retry timeout in seconds on replication failure.")]
[DefaultValueAttribute("300")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Replication.RetryMaxTimeoutInSec", "1", "32", "True", "False")]
public TimeSetting RetryMaxTimeout { get; public set; }
    [DescriptionAttribute("Maximum number of items replication will send in single batch, null means we will not cut the batch by number of items")]
[DefaultValueAttribute("16384")]
[ConfigurationEntryAttribute("Replication.MaxItemsCount", "1", "37", "True", "False")]
public Nullable`1<int> MaxItemsCount { get; public set; }
    [DescriptionAttribute("Maximum number of data size replication will send in single batch, null means we will not cut the batch by the size")]
[DefaultValueAttribute("64")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Replication.MaxSizeToSendInMb", "1", "43", "True", "False")]
public Nullable`1<Size> MaxSizeToSend { get; public set; }
    [DescriptionAttribute("Maximum number of documents that will require pulsing new transaction, when loading docs before replication.")]
[DefaultValueAttribute("1024")]
[ConfigurationEntryAttribute("Replication.NumberOfEnumeratedDocumentsToCheckIfPulseLimitExceeded", "1", "48", "True", "False")]
public int NumberOfEnumeratedDocumentsToCheckIfPulseLimitExceeded { get; public set; }
    [DescriptionAttribute("The number of duplicate attachments that should be tracked for de-duplication per outgoing replication connection.")]
[DefaultValueAttribute("16384")]
[ConfigurationEntryAttribute("Replication.MaxNumberOfAttachmentsTrackedForDeduplication", "1", "53", "True", "False")]
public int MaxNumberOfAttachmentsTrackedForDeduplication { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSetting get_ActiveConnectionTimeout();
    [CompilerGeneratedAttribute]
public void set_ActiveConnectionTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_ReplicationMinimalHeartbeat();
    [CompilerGeneratedAttribute]
public void set_ReplicationMinimalHeartbeat(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_RetryReplicateAfter();
    [CompilerGeneratedAttribute]
public void set_RetryReplicateAfter(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_RetryMaxTimeout();
    [CompilerGeneratedAttribute]
public void set_RetryMaxTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxItemsCount();
    [CompilerGeneratedAttribute]
public void set_MaxItemsCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_MaxSizeToSend();
    [CompilerGeneratedAttribute]
public void set_MaxSizeToSend(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public int get_NumberOfEnumeratedDocumentsToCheckIfPulseLimitExceeded();
    [CompilerGeneratedAttribute]
public void set_NumberOfEnumeratedDocumentsToCheckIfPulseLimitExceeded(int value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfAttachmentsTrackedForDeduplication();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfAttachmentsTrackedForDeduplication(int value);
}
[ConfigurationCategoryAttribute("20")]
public class Raven.Server.Config.Categories.SecurityConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private bool <DisableHttpsRedirection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableHsts>k__BackingField;
    [CompilerGeneratedAttribute]
private PathSetting <AuditLogPath>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <AuditLogRetentionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <AuditLogRetentionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AuditLogCompress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DoNotConsiderMemoryLockFailureAsCatastrophicError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePassword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateExec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateLoadExec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateRenewExec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateChangeExec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateLoadExecArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateRenewExecArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateChangeExecArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CertificateExecTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateLetsEncryptEmail>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MasterKeyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MasterKeyExec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MasterKeyExecArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MasterKeyExecTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private UnsecuredAccessAddressRange <UnsecuredAccessAllowed>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WellKnownAdminCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WellKnownIssuers>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WellKnownIssuerHashes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateValidationExec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateValidationExecArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CertificateValidationExecTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TlsCipherSuite[] <TlsCipherSuites>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CertificateValidationKeyUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableCsrfFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CsrfTrustedOrigins>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CsrfAdditionalOriginHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <DefaultTwoFactorSessionDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MaxTwoFactorSessionDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CertificateExpiringThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsUnsecureAccessSetupValid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnsecureAccessWarningMessage>k__BackingField;
    [DescriptionAttribute("Disable automatic redirection when listening to HTTPS. By default, when using port 443, RavenDB redirects all incoming HTTP traffic on port 80 to HTTPS on port 443.")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Security.DisableHttpsRedirection", "0", "18", "True", "False")]
public bool DisableHttpsRedirection { get; public set; }
    [DescriptionAttribute("Disable HTTP Strict Transport Security")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Security.DisableHsts", "0", "23", "True", "False")]
public bool DisableHsts { get; public set; }
    [DescriptionAttribute("The path to a folder where RavenDB will store the access audit logs")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.AuditLog.FolderPath", "0", "28", "True", "False")]
public PathSetting AuditLogPath { get; public set; }
    [DescriptionAttribute("How far back we should retain audit log entries")]
[DefaultValueAttribute("8760")]
[TimeUnitAttribute("3")]
[ConfigurationEntryAttribute("Security.AuditLog.RetentionTimeInHours", "0", "34", "True", "False")]
[ConfigurationEntryAttribute("Security.AuditLog.RetentionTimeInHrs", "0", "35", "True", "False")]
public TimeSetting AuditLogRetentionTime { get; public set; }
    [DescriptionAttribute("The maximum size of the audit log after which the old files will be deleted")]
[DefaultValueAttribute("")]
[MinValueAttribute("256")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Security.AuditLog.RetentionSizeInMb", "0", "42", "True", "False")]
public Nullable`1<Size> AuditLogRetentionSize { get; public set; }
    [DescriptionAttribute("Will determine whether to compress the audit log files")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Security.AuditLog.Compress", "0", "47", "True", "False")]
public bool AuditLogCompress { get; public set; }
    [DescriptionAttribute("The path to .pfx certificate file. If specified, RavenDB will use HTTPS/SSL for all network activities. Certificate setting priority order: 1) Path 2) Executable")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Path", "0", "52", "True", "False")]
public string CertificatePath { get; public set; }
    [DescriptionAttribute("EXPERT: Whether RavenDB will consider memory lock error to be catastrophic. This is used with encrypted databases to ensure that temporary buffers are never written to disk and are locked to memory. Setting this to true is not recommended and should be done only after proper security analysis has been performed.")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Security.DoNotConsiderMemoryLockFailureAsCatastrophicError", "1", "57", "True", "False")]
public bool DoNotConsiderMemoryLockFailureAsCatastrophicError { get; public set; }
    [DescriptionAttribute("The (optional) password of the .pfx certificate file.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Password", "0", "62", "True", "True")]
public string CertificatePassword { get; public set; }
    [DescriptionAttribute("Deprecated. Use Security.Certificate.Load.Exec along with Security.Certificate.Renew.Exec and Security.Certificate.Change.Exec")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Exec", "0", "67", "True", "False")]
public string CertificateExec { get; public set; }
    [DescriptionAttribute("A command or executable providing a .pfx cluster certificate when invoked by RavenDB. If specified, RavenDB will use HTTPS/SSL for all network activities. The certificate path setting takes precedence over executable configuration option.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Load.Exec", "0", "72", "True", "False")]
public string CertificateLoadExec { get; public set; }
    [DescriptionAttribute("A command or executable to handle automatic renewals, providing a renewed .pfx cluster certificate. The leader node will invoke the executable once every hour and if a new certificate is received, it will be sent to the other nodes. The executable specified in Security.Certificate.Change.Exec will then be used to persist the certificate across the cluster.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Renew.Exec", "0", "77", "True", "False")]
public string CertificateRenewExec { get; public set; }
    [DescriptionAttribute("A command or executable handling a change in the cluster certificate. When invoked, RavenDB will send the new cluster certificate to this executable, giving the follower nodes a way to persist the new certificate.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Change.Exec", "0", "82", "True", "False")]
public string CertificateChangeExec { get; public set; }
    [DescriptionAttribute("The command line arguments for the 'Security.Certificate.Load.Exec' command or executable.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Load.Exec.Arguments", "0", "87", "True", "True")]
public string CertificateLoadExecArguments { get; public set; }
    [DescriptionAttribute("The command line arguments for the 'Security.Certificate.Renew.Exec' command or executable.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Renew.Exec.Arguments", "0", "92", "True", "True")]
public string CertificateRenewExecArguments { get; public set; }
    [DescriptionAttribute("The command line arguments for the 'Security.Certificate.Change.Exec' command or executable.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Change.Exec.Arguments", "0", "97", "True", "True")]
public string CertificateChangeExecArguments { get; public set; }
    [DescriptionAttribute("The number of seconds to wait for the certificate executable to exit. Default: 30 seconds")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Security.Certificate.Exec.TimeoutInSec", "0", "103", "True", "False")]
public TimeSetting CertificateExecTimeout { get; public set; }
    [DescriptionAttribute("The E-mail address associated with the Let's Encrypt certificate. Used for renewal requests.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.LetsEncrypt.Email", "0", "108", "True", "False")]
public string CertificateLetsEncryptEmail { get; public set; }
    [DescriptionAttribute("The path of the (256-bit) Master Key. If specified, RavenDB will use this key to protect secrets.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.MasterKey.Path", "0", "113", "True", "False")]
public string MasterKeyPath { get; public set; }
    [DescriptionAttribute("A command or executable to run which will provide a (256-bit) Master Key, If specified, RavenDB will use this key to protect secrets.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.MasterKey.Exec", "0", "118", "True", "False")]
public string MasterKeyExec { get; public set; }
    [DescriptionAttribute("The command line arguments for the 'Security.MasterKey.Exec' command or executable.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.MasterKey.Exec.Arguments", "0", "123", "True", "True")]
public string MasterKeyExecArguments { get; public set; }
    [DescriptionAttribute("The number of seconds to wait for the Master Key executable to exit. Default: 30 seconds")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Security.MasterKey.Exec.TimeoutInSec", "0", "129", "True", "False")]
public TimeSetting MasterKeyExecTimeout { get; public set; }
    [DescriptionAttribute("If authentication is disabled, set address range type for which server access is unsecured (None | Local | PrivateNetwork | PublicNetwork).")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Security.UnsecuredAccessAllowed", "0", "134", "True", "False")]
public UnsecuredAccessAddressRange UnsecuredAccessAllowed { get; public set; }
    [DescriptionAttribute("Well known certificate thumbprints that will be trusted by the server as cluster admins.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.WellKnownCertificates.Admin", "0", "139", "True", "False")]
public String[] WellKnownAdminCertificates { get; public set; }
    [DescriptionAttribute("Well known issuer certificate in base 64 format or a file path that will be used to validate a new client certificate when the issuer's certificate has changed.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.WellKnownIssuers.Admin", "0", "145", "True", "False")]
public String[] WellKnownIssuers { get; public set; }
    [DescriptionAttribute("OBSOLETE: This is no longer supported or used, use 'Security.WellKnownIssuers.Admin' instead.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.WellKnownIssuerHashes.Admin", "0", "151", "True", "False")]
public String[] WellKnownIssuerHashes { get; public set; }
    [DescriptionAttribute("EXPERT: A command or executable to validate a server authentication request. RavenDB will execute: command [user-arg-1] ... [user-arg-n] <sender-url> <base64-certificate> <errors>. The executable will return a case-insensitive boolean string through the standard output (e.g. true, false) indicating whether to approve the connection.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Validation.Exec", "0", "158", "True", "False")]
public string CertificateValidationExec { get; public set; }
    [DescriptionAttribute("EXPERT: The optional user arguments for the 'Security.Certificate.Validation.Exec' command or executable. The arguments must be escaped for the command line.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Certificate.Validation.Exec.Arguments", "0", "163", "True", "True")]
public string CertificateValidationExecArguments { get; public set; }
    [DescriptionAttribute("The number of seconds to wait for the 'Security.Certificate.Validation.Exec' executable to exit. Default: 5 seconds")]
[DefaultValueAttribute("5")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Security.Certificate.Validation.Exec.TimeoutInSec", "0", "169", "True", "False")]
public TimeSetting CertificateValidationExecTimeout { get; public set; }
    [DescriptionAttribute("EXPERT: Defines a list of supported TLS Cipher Suites. Values must be semicolon separated. Default: null (Operating System defaults)")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.TlsCipherSuites", "0", "174", "True", "False")]
public TlsCipherSuite[] TlsCipherSuites { get; public set; }
    [DescriptionAttribute("EXPERT: Indicates if 'KeyUsage' validation of certificates should be turned on or off")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Security.Certificate.Validation.KeyUsages", "0", "179", "True", "False")]
public bool CertificateValidationKeyUsages { get; public set; }
    [DescriptionAttribute("Indicates if CSRF filter is enabled or not. Default: true")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Security.Csrf.Enabled", "0", "184", "True", "False")]
public bool EnableCsrfFilter { get; public set; }
    [DescriptionAttribute("List of Trusted Origins for CSRF filter")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Csrf.TrustedOrigins", "0", "189", "True", "False")]
public String[] CsrfTrustedOrigins { get; public set; }
    [DescriptionAttribute("List of Request Headers to look for Origin, ex. X-Forwarded-Host")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Security.Csrf.AdditionalOriginHeaders", "0", "194", "True", "False")]
public String[] CsrfAdditionalOriginHeaders { get; public set; }
    [DescriptionAttribute("Default (in minutes) two-factor session duration")]
[DefaultValueAttribute("120")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Security.TwoFactor.DefaultSessionDurationInMin", "0", "200", "True", "False")]
public TimeSetting DefaultTwoFactorSessionDuration { get; public set; }
    [DescriptionAttribute("Maximum (in minutes) two-factor session duration")]
[DefaultValueAttribute("1440")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Security.TwoFactor.MaxSessionDurationInMin", "0", "206", "True", "False")]
public TimeSetting MaxTwoFactorSessionDuration { get; public set; }
    [DescriptionAttribute("The number of days before certificate expiration when it will be considered expiring. Default: 14")]
[DefaultValueAttribute("14")]
[TimeUnitAttribute("4")]
[ConfigurationEntryAttribute("Security.Certificate.ExpiringThresholdInDays", "0", "212", "True", "False")]
public TimeSetting CertificateExpiringThreshold { get; public set; }
    internal Nullable`1<bool> IsUnsecureAccessSetupValid { get; private set; }
    internal string UnsecureAccessWarningMessage { get; private set; }
    public bool IsCertificateConfigured { get; }
    public bool AuthenticationEnabled { get; }
    [CompilerGeneratedAttribute]
public bool get_DisableHttpsRedirection();
    [CompilerGeneratedAttribute]
public void set_DisableHttpsRedirection(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableHsts();
    [CompilerGeneratedAttribute]
public void set_DisableHsts(bool value);
    [CompilerGeneratedAttribute]
public PathSetting get_AuditLogPath();
    [CompilerGeneratedAttribute]
public void set_AuditLogPath(PathSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_AuditLogRetentionTime();
    [CompilerGeneratedAttribute]
public void set_AuditLogRetentionTime(TimeSetting value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_AuditLogRetentionSize();
    [CompilerGeneratedAttribute]
public void set_AuditLogRetentionSize(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public bool get_AuditLogCompress();
    [CompilerGeneratedAttribute]
public void set_AuditLogCompress(bool value);
    [CompilerGeneratedAttribute]
public string get_CertificatePath();
    [CompilerGeneratedAttribute]
public void set_CertificatePath(string value);
    [CompilerGeneratedAttribute]
public bool get_DoNotConsiderMemoryLockFailureAsCatastrophicError();
    [CompilerGeneratedAttribute]
public void set_DoNotConsiderMemoryLockFailureAsCatastrophicError(bool value);
    [CompilerGeneratedAttribute]
public string get_CertificatePassword();
    [CompilerGeneratedAttribute]
public void set_CertificatePassword(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateExec();
    [CompilerGeneratedAttribute]
public void set_CertificateExec(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateLoadExec();
    [CompilerGeneratedAttribute]
public void set_CertificateLoadExec(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateRenewExec();
    [CompilerGeneratedAttribute]
public void set_CertificateRenewExec(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateChangeExec();
    [CompilerGeneratedAttribute]
public void set_CertificateChangeExec(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateLoadExecArguments();
    [CompilerGeneratedAttribute]
public void set_CertificateLoadExecArguments(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateRenewExecArguments();
    [CompilerGeneratedAttribute]
public void set_CertificateRenewExecArguments(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateChangeExecArguments();
    [CompilerGeneratedAttribute]
public void set_CertificateChangeExecArguments(string value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CertificateExecTimeout();
    [CompilerGeneratedAttribute]
public void set_CertificateExecTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public string get_CertificateLetsEncryptEmail();
    [CompilerGeneratedAttribute]
public void set_CertificateLetsEncryptEmail(string value);
    [CompilerGeneratedAttribute]
public string get_MasterKeyPath();
    [CompilerGeneratedAttribute]
public void set_MasterKeyPath(string value);
    [CompilerGeneratedAttribute]
public string get_MasterKeyExec();
    [CompilerGeneratedAttribute]
public void set_MasterKeyExec(string value);
    [CompilerGeneratedAttribute]
public string get_MasterKeyExecArguments();
    [CompilerGeneratedAttribute]
public void set_MasterKeyExecArguments(string value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MasterKeyExecTimeout();
    [CompilerGeneratedAttribute]
public void set_MasterKeyExecTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public UnsecuredAccessAddressRange get_UnsecuredAccessAllowed();
    [CompilerGeneratedAttribute]
public void set_UnsecuredAccessAllowed(UnsecuredAccessAddressRange value);
    [CompilerGeneratedAttribute]
public String[] get_WellKnownAdminCertificates();
    [CompilerGeneratedAttribute]
public void set_WellKnownAdminCertificates(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_WellKnownIssuers();
    [CompilerGeneratedAttribute]
public void set_WellKnownIssuers(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_WellKnownIssuerHashes();
    [CompilerGeneratedAttribute]
public void set_WellKnownIssuerHashes(String[] value);
    [CompilerGeneratedAttribute]
public string get_CertificateValidationExec();
    [CompilerGeneratedAttribute]
public void set_CertificateValidationExec(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateValidationExecArguments();
    [CompilerGeneratedAttribute]
public void set_CertificateValidationExecArguments(string value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CertificateValidationExecTimeout();
    [CompilerGeneratedAttribute]
public void set_CertificateValidationExecTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public TlsCipherSuite[] get_TlsCipherSuites();
    [CompilerGeneratedAttribute]
public void set_TlsCipherSuites(TlsCipherSuite[] value);
    [CompilerGeneratedAttribute]
public bool get_CertificateValidationKeyUsages();
    [CompilerGeneratedAttribute]
public void set_CertificateValidationKeyUsages(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableCsrfFilter();
    [CompilerGeneratedAttribute]
public void set_EnableCsrfFilter(bool value);
    [CompilerGeneratedAttribute]
public String[] get_CsrfTrustedOrigins();
    [CompilerGeneratedAttribute]
public void set_CsrfTrustedOrigins(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_CsrfAdditionalOriginHeaders();
    [CompilerGeneratedAttribute]
public void set_CsrfAdditionalOriginHeaders(String[] value);
    [CompilerGeneratedAttribute]
public TimeSetting get_DefaultTwoFactorSessionDuration();
    [CompilerGeneratedAttribute]
public void set_DefaultTwoFactorSessionDuration(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxTwoFactorSessionDuration();
    [CompilerGeneratedAttribute]
public void set_MaxTwoFactorSessionDuration(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CertificateExpiringThreshold();
    [CompilerGeneratedAttribute]
public void set_CertificateExpiringThreshold(TimeSetting value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_IsUnsecureAccessSetupValid();
    [CompilerGeneratedAttribute]
private void set_IsUnsecureAccessSetupValid(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal string get_UnsecureAccessWarningMessage();
    [CompilerGeneratedAttribute]
private void set_UnsecureAccessWarningMessage(string value);
    public bool get_IsCertificateConfigured();
    public bool get_AuthenticationEnabled();
    internal static void Validate(RavenConfiguration configuration);
    private static IPAddress[] DetermineServerIp(Uri serverUri);
}
[ConfigurationCategoryAttribute("21")]
public class Raven.Server.Config.Categories.ServerConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private TimeSetting <MaxTimeForTaskToWaitForDatabaseToLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ProcessAffinityMask>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <IndexingAffinityMask>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfUnusedCoresByIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <CpuCreditsBase>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <CpuCreditsMax>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <CpuCreditsExhaustionBackgroundTasksThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <CpuCreditsExhaustionFailoverThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CpuCreditsExhaustionBackupDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CpuCreditsExec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CpuCreditsExecArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CpuCreditsExecSyncInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CpuCreditsExecTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ThreadPoolMinWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ThreadPoolMinCompletionPortThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ThreadPoolMaxWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ThreadPoolMaxCompletionPortThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableAdminChannel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableLogsStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableTcpCompression>k__BackingField;
    [DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Server.MaxTimeForTaskToWaitForDatabaseToLoadInSec", "0", "12", "True", "False")]
public TimeSetting MaxTimeForTaskToWaitForDatabaseToLoad { get; public set; }
    [DescriptionAttribute("The server name")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.Name", "0", "17", "True", "False")]
public string Name { get; public set; }
    [DescriptionAttribute("EXPERT: The process affinity mask")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.ProcessAffinityMask", "0", "22", "True", "False")]
public Nullable`1<long> ProcessAffinityMask { get; public set; }
    [DescriptionAttribute("EXPERT: The affinity mask to be used for indexing. Overrides the Server.NumberOfUnusedCoresByIndexes value. Should only be used if you also set Server.ProcessAffinityMask.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.IndexingAffinityMask", "0", "27", "True", "False")]
public Nullable`1<long> IndexingAffinityMask { get; public set; }
    [DescriptionAttribute("EXPERT: The numbers of cores that will be NOT run indexing. Defaults to 1 core that is kept for all other tasks and will not run indexing.")]
[DefaultValueAttribute("1")]
[ConfigurationEntryAttribute("Server.NumberOfUnusedCoresByIndexes", "0", "32", "True", "False")]
public int NumberOfUnusedCoresByIndexes { get; public set; }
    [DescriptionAttribute("EXPERT: To let RavenDB manage burstable instance performance by scaling down background operations")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.CpuCredits.Base", "0", "37", "True", "False")]
public Nullable`1<double> CpuCreditsBase { get; public set; }
    [DescriptionAttribute("EXPERT: To let RavenDB manage burstable instance performance by scaling down background operations")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.CpuCredits.Max", "0", "42", "True", "False")]
public Nullable`1<double> CpuCreditsMax { get; public set; }
    [DescriptionAttribute("EXPERT: When CPU credits are exhausted to the threshold, start stopping background tasks.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.CpuCredits.ExhaustionBackgroundTasksThreshold", "0", "47", "True", "False")]
public Nullable`1<double> CpuCreditsExhaustionBackgroundTasksThreshold { get; public set; }
    [DescriptionAttribute("EXPERT: When CPU credits are exhausted to the threshold, start rejecting requests to databases.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.CpuCredits.ExhaustionFailoverThreshold", "0", "52", "True", "False")]
public Nullable`1<double> CpuCreditsExhaustionFailoverThreshold { get; public set; }
    [DescriptionAttribute("EXPERT: When CPU credits are exhausted backups are canceled. This value indicates after how many minutes the backup task will re-try.")]
[DefaultValueAttribute("10")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Server.CpuCredits.ExhaustionBackupDelayInMin", "0", "58", "True", "False")]
public TimeSetting CpuCreditsExhaustionBackupDelay { get; public set; }
    [DescriptionAttribute("EXPERT: A command or executable that will provide RavenDB with the current CPU credits balance.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.CpuCredits.Exec", "0", "63", "True", "False")]
public string CpuCreditsExec { get; public set; }
    [DescriptionAttribute("EXPERT: The command line arguments for the Server.CpuCredits.Exec command or executable.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.CpuCredits.Exec.Arguments", "0", "68", "True", "True")]
public string CpuCreditsExecArguments { get; public set; }
    [DescriptionAttribute("EXPERT: The number of minutes between every invocation of the CPU Credits executable. Default: 30 minutes.")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Server.CpuCredits.Exec.SyncIntervalInMin", "0", "74", "True", "False")]
public TimeSetting CpuCreditsExecSyncInterval { get; public set; }
    [DescriptionAttribute("EXPERT: The number of seconds to wait for the CPU Credits executable to exit. Default: 30 seconds.")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Server.CpuCredits.Exec.TimeoutInSec", "0", "80", "True", "False")]
public TimeSetting CpuCreditsExecTimeout { get; public set; }
    [DescriptionAttribute("EXPERT: Sets the minimum number of worker threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.ThreadPool.MinWorkerThreads", "0", "85", "True", "False")]
public Nullable`1<int> ThreadPoolMinWorkerThreads { get; public set; }
    [DescriptionAttribute("EXPERT: Sets the minimum number of asynchronous I/O threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.ThreadPool.MinCompletionPortThreads", "0", "90", "True", "False")]
public Nullable`1<int> ThreadPoolMinCompletionPortThreads { get; public set; }
    [DescriptionAttribute("EXPERT: Sets the maximum number of worker threads in the thread pool.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.ThreadPool.MaxWorkerThreads", "0", "95", "True", "False")]
public Nullable`1<int> ThreadPoolMaxWorkerThreads { get; public set; }
    [DescriptionAttribute("EXPERT: Sets the maximum number of asynchronous I/O threads in the thread pool.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Server.ThreadPool.MaxCompletionPortThreads", "0", "100", "True", "False")]
public Nullable`1<int> ThreadPoolMaxCompletionPortThreads { get; public set; }
    [DescriptionAttribute("EXPERT: Disable rvn admin-channel access.")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Server.AdminChannel.Disable", "0", "105", "True", "False")]
public bool DisableAdminChannel { get; public set; }
    [DescriptionAttribute("EXPERT: Disable rvn logstream access.")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Server.LogsStream.Disable", "0", "110", "True", "False")]
public bool DisableLogsStream { get; public set; }
    [DescriptionAttribute("EXPERT: Disable TCP data compression")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Server.Tcp.Compression.Disable", "0", "115", "True", "False")]
public bool DisableTcpCompression { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxTimeForTaskToWaitForDatabaseToLoad();
    [CompilerGeneratedAttribute]
public void set_MaxTimeForTaskToWaitForDatabaseToLoad(TimeSetting value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ProcessAffinityMask();
    [CompilerGeneratedAttribute]
public void set_ProcessAffinityMask(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_IndexingAffinityMask();
    [CompilerGeneratedAttribute]
public void set_IndexingAffinityMask(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public int get_NumberOfUnusedCoresByIndexes();
    [CompilerGeneratedAttribute]
public void set_NumberOfUnusedCoresByIndexes(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_CpuCreditsBase();
    [CompilerGeneratedAttribute]
public void set_CpuCreditsBase(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_CpuCreditsMax();
    [CompilerGeneratedAttribute]
public void set_CpuCreditsMax(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_CpuCreditsExhaustionBackgroundTasksThreshold();
    [CompilerGeneratedAttribute]
public void set_CpuCreditsExhaustionBackgroundTasksThreshold(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_CpuCreditsExhaustionFailoverThreshold();
    [CompilerGeneratedAttribute]
public void set_CpuCreditsExhaustionFailoverThreshold(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CpuCreditsExhaustionBackupDelay();
    [CompilerGeneratedAttribute]
public void set_CpuCreditsExhaustionBackupDelay(TimeSetting value);
    [CompilerGeneratedAttribute]
public string get_CpuCreditsExec();
    [CompilerGeneratedAttribute]
public void set_CpuCreditsExec(string value);
    [CompilerGeneratedAttribute]
public string get_CpuCreditsExecArguments();
    [CompilerGeneratedAttribute]
public void set_CpuCreditsExecArguments(string value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CpuCreditsExecSyncInterval();
    [CompilerGeneratedAttribute]
public void set_CpuCreditsExecSyncInterval(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CpuCreditsExecTimeout();
    [CompilerGeneratedAttribute]
public void set_CpuCreditsExecTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ThreadPoolMinWorkerThreads();
    [CompilerGeneratedAttribute]
public void set_ThreadPoolMinWorkerThreads(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ThreadPoolMinCompletionPortThreads();
    [CompilerGeneratedAttribute]
public void set_ThreadPoolMinCompletionPortThreads(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ThreadPoolMaxWorkerThreads();
    [CompilerGeneratedAttribute]
public void set_ThreadPoolMaxWorkerThreads(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ThreadPoolMaxCompletionPortThreads();
    [CompilerGeneratedAttribute]
public void set_ThreadPoolMaxCompletionPortThreads(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_DisableAdminChannel();
    [CompilerGeneratedAttribute]
public void set_DisableAdminChannel(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableLogsStream();
    [CompilerGeneratedAttribute]
public void set_DisableLogsStream(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableTcpCompression();
    [CompilerGeneratedAttribute]
public void set_DisableTcpCompression(bool value);
}
[ConfigurationCategoryAttribute("22")]
public class Raven.Server.Config.Categories.ShardingConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShardExecutorUseHttpDecompression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShardExecutorUseHttpCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <OrchestratorTimeout>k__BackingField;
    [DescriptionAttribute("The compression level to use when sending import streams to shards during smuggler import")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Sharding.Import.CompressionLevel", "1", "19", "True", "False")]
public CompressionLevel CompressionLevel { get; public set; }
    [DescriptionAttribute("Accept compressed HTTP responses from shards")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Sharding.ShardExecutor.UseHttpDecompression", "0", "24", "True", "False")]
public bool ShardExecutorUseHttpDecompression { get; public set; }
    [DescriptionAttribute("Use compression when sending HTTP requests to shards")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Sharding.ShardExecutor.UseHttpCompression", "0", "29", "True", "False")]
public bool ShardExecutorUseHttpCompression { get; public set; }
    [DescriptionAttribute("Enable the timeout of the orchestrator's requests to the shards")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Sharding.OrchestratorTimeoutInMin", "0", "35", "True", "False")]
public TimeSetting OrchestratorTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public bool get_ShardExecutorUseHttpDecompression();
    [CompilerGeneratedAttribute]
public void set_ShardExecutorUseHttpDecompression(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShardExecutorUseHttpCompression();
    [CompilerGeneratedAttribute]
public void set_ShardExecutorUseHttpCompression(bool value);
    [CompilerGeneratedAttribute]
public TimeSetting get_OrchestratorTimeout();
    [CompilerGeneratedAttribute]
public void set_OrchestratorTimeout(TimeSetting value);
}
[ConfigurationCategoryAttribute("23")]
public class Raven.Server.Config.Categories.StorageConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private bool <DiscardVirtualMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private PathSetting <TempPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceUsing32BitsPager>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePrefetching>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableIoMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <TransactionsModeDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrentFlushes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <TimeToSyncAfterFlush>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfConcurrentSyncsPerPhysicalDrive>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <CompressTxAboveSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <MaxScratchBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <PrefetchBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <PrefetchResetThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FreeSpaceAlertThresholdInPercentages>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Size> <FreeSpaceAlertThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SyncJournalsCountThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <IoMetricsCleanupInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OnDirectoryInitializeExec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OnDirectoryInitializeExecArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <OnDirectoryInitializeExecTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IgnoreInvalidJournalErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipChecksumValidationOnDatabaseLoading>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableEncryptionBuffersPooling>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfRecyclableJournals>k__BackingField;
    [DescriptionAttribute("You can use this setting to specify whether to disable or enable discard virtual memory. By default, on windows, it will be disabled.")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[ConfigurationEntryAttribute("Storage.DiscardVirtualMemory", "1", "21", "True", "False")]
public bool DiscardVirtualMemory { get; public set; }
    [DescriptionAttribute("You can use this setting to specify a different path to temporary files. By default it is empty, which means that temporary files will be created at same location as data file.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Storage.TempPath", "1", "26", "True", "False")]
public PathSetting TempPath { get; public set; }
    [DescriptionAttribute("Use the 32 bits memory mapped pager, even when running in 64 bits")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Storage.ForceUsing32BitsPager", "0", "31", "True", "False")]
public bool ForceUsing32BitsPager { get; public set; }
    [DescriptionAttribute("Enables memory prefetching mechanism if OS supports it")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Storage.EnablePrefetching", "0", "36", "True", "False")]
public bool EnablePrefetching { get; public set; }
    [DescriptionAttribute("Enable metrics collections for each I/O operation made by RavenDB")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Storage.IO.Metrics.Enabled", "0", "41", "True", "False")]
public bool EnableIoMetrics { get; public set; }
    [DescriptionAttribute("How long transaction mode (Danger/Lazy) last before returning to Safe mode. Value in Minutes. Default one day. Zero for infinite time")]
[DefaultValueAttribute("1440")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Storage.TransactionsModeDurationInMin", "1", "47", "True", "False")]
public TimeSetting TransactionsModeDuration { get; public set; }
    [DescriptionAttribute("Maximum concurrent flushes")]
[DefaultValueAttribute("10")]
[ConfigurationEntryAttribute("Storage.MaxConcurrentFlushes", "1", "52", "True", "False")]
public int MaxConcurrentFlushes { get; public set; }
    [DescriptionAttribute("Time to sync after flash in seconds")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Storage.TimeToSyncAfterFlushInSec", "1", "58", "True", "False")]
[ConfigurationEntryAttribute("Storage.TimeToSyncAfterFlashInSec", "1", "59", "True", "False")]
public TimeSetting TimeToSyncAfterFlush { get; public set; }
    [DescriptionAttribute("Number of concurrent syncs per physical drive")]
[MinValueAttribute("3")]
[DefaultValueAttribute("3")]
[ConfigurationEntryAttribute("Storage.NumberOfConcurrentSyncsPerPhysicalDrive", "0", "65", "True", "False")]
public int NumberOfConcurrentSyncsPerPhysicalDrive { get; public set; }
    [DescriptionAttribute("Compress transactions above size (value in KB)")]
[DefaultValueAttribute("512")]
[SizeUnitAttribute("1")]
[ConfigurationEntryAttribute("Storage.CompressTxAboveSizeInKb", "1", "71", "True", "False")]
public Size CompressTxAboveSize { get; public set; }
    [DescriptionAttribute("Max size of .buffers files")]
[DefaultValueAttribute("")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Storage.MaxScratchBufferSizeInMb", "1", "77", "True", "False")]
public Nullable`1<Size> MaxScratchBufferSize { get; public set; }
    [DescriptionAttribute("Size of the batch that will be requested to the OS from disk when prefetching (value in powers of 2). Some OSs may not honor certain values. Experts only.")]
[DefaultValueAttribute("1024")]
[SizeUnitAttribute("1")]
[ConfigurationEntryAttribute("Storage.PrefetchBatchSizeInKb", "1", "83", "True", "False")]
public Size PrefetchBatchSize { get; public set; }
    [DescriptionAttribute("How many gigabytes of memory should be prefetched before restarting the prefetch tracker table. Experts only.")]
[DefaultValueAttribute("8")]
[SizeUnitAttribute("3")]
[ConfigurationEntryAttribute("Storage.PrefetchResetThresholdInGb", "1", "89", "True", "False")]
public Size PrefetchResetThreshold { get; public set; }
    [DescriptionAttribute("Minimal available free space in percentages on any disk used by a database before creating an alert. Set to null to disable.")]
[DefaultValueAttribute("15")]
[ConfigurationEntryAttribute("Storage.FreeSpaceAlertThresholdInPercentages", "1", "94", "True", "False")]
public Nullable`1<int> FreeSpaceAlertThresholdInPercentages { get; public set; }
    [DescriptionAttribute("Minimal available free space in megabytes on any disk used by a database before creating an alert. Set to null to disable.")]
[DefaultValueAttribute("1024")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("Storage.FreeSpaceAlertThresholdInMb", "1", "100", "True", "False")]
public Nullable`1<Size> FreeSpaceAlertThreshold { get; public set; }
    [DescriptionAttribute("Number of Journals files for each storage, before forcing a sync and removing unused journal files.")]
[DefaultValueAttribute("2")]
[ConfigurationEntryAttribute("Storage.SyncJournalsCountThreshold", "1", "105", "True", "False")]
public int SyncJournalsCountThreshold { get; public set; }
    [DescriptionAttribute("Time (in hours) between IO Metrics cleanup")]
[DefaultValueAttribute("24")]
[TimeUnitAttribute("3")]
[ConfigurationEntryAttribute("Storage.IoMetricsCleanupIntervalInHrs", "1", "114", "True", "False")]
public TimeSetting IoMetricsCleanupInterval { get; public set; }
    [DescriptionAttribute("EXPERT: A command or executable to run when creating/opening a directory (storage environment). RavenDB will execute: command [user-arg-1] ... [user-arg-n] <environment-type> <database-name> <data-dir-path> <temp-dir-path> <journal-dir-path>")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Storage.OnDirectoryInitialize.Exec", "1", "119", "True", "False")]
[ConfigurationEntryAttribute("Storage.OnCreateDirectory.Exec", "1", "120", "True", "False")]
public string OnDirectoryInitializeExec { get; public set; }
    [DescriptionAttribute("EXPERT: The optional user arguments for the 'Storage.OnDirectoryInitialize.Exec' command or executable. The arguments must be escaped for the command line.")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Storage.OnDirectoryInitialize.Exec.Arguments", "1", "125", "True", "True")]
[ConfigurationEntryAttribute("Storage.OnCreateDirectory.Exec.Arguments", "1", "126", "True", "True")]
public string OnDirectoryInitializeExecArguments { get; public set; }
    [DescriptionAttribute("EXPERT: The number of seconds to wait for the OnDirectoryInitialize executable to exit. Default: 30 seconds")]
[DefaultValueAttribute("30")]
[TimeUnitAttribute("1")]
[ConfigurationEntryAttribute("Storage.OnDirectoryInitialize.Exec.TimeoutInSec", "1", "132", "True", "False")]
[ConfigurationEntryAttribute("Storage.OnCreateDirectory.Exec.TimeoutInSec", "1", "133", "True", "False")]
public TimeSetting OnDirectoryInitializeExecTimeout { get; public set; }
    [DescriptionAttribute("EXPERT: Allows to load a database regardless journal errors that can be thrown during the recovery operation on startup. Since journals are mandatory to properly start a database, the usage of this option is dangerous")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Storage.Dangerous.IgnoreInvalidJournalErrors", "0", "138", "True", "False")]
public Nullable`1<bool> IgnoreInvalidJournalErrors { get; public set; }
    [DescriptionAttribute("EXPERT: Skip checksum validation on database loading process")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Storage.Dangerous.SkipChecksumValidationOnDatabaseLoading", "0", "143", "True", "False")]
public bool SkipChecksumValidationOnDatabaseLoading { get; public set; }
    [DescriptionAttribute("EXPERT: Allows to load a database regardless encountered data integrity errors of already synced transactions in journals during the recovery operation on startup")]
[DefaultValueAttribute("True")]
[ConfigurationEntryAttribute("Storage.IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions", "0", "148", "True", "False")]
public bool IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions { get; public set; }
    [DescriptionAttribute("EXPERT: Disable encryption buffer pooling.")]
[DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Storage.Encrypted.DisableBuffersPooling", "0", "153", "True", "False")]
public bool DisableEncryptionBuffersPooling { get; public set; }
    [DescriptionAttribute("Max number of recyclable journals that will be reused. ")]
[DefaultValueAttribute("32")]
[MinValueAttribute("0")]
[ConfigurationEntryAttribute("Storage.MaxNumberOfRecyclableJournals", "1", "159", "True", "False")]
public int MaxNumberOfRecyclableJournals { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DiscardVirtualMemory();
    [CompilerGeneratedAttribute]
public void set_DiscardVirtualMemory(bool value);
    [CompilerGeneratedAttribute]
public PathSetting get_TempPath();
    [CompilerGeneratedAttribute]
public void set_TempPath(PathSetting value);
    [CompilerGeneratedAttribute]
public bool get_ForceUsing32BitsPager();
    [CompilerGeneratedAttribute]
public void set_ForceUsing32BitsPager(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnablePrefetching();
    [CompilerGeneratedAttribute]
public void set_EnablePrefetching(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableIoMetrics();
    [CompilerGeneratedAttribute]
public void set_EnableIoMetrics(bool value);
    [CompilerGeneratedAttribute]
public TimeSetting get_TransactionsModeDuration();
    [CompilerGeneratedAttribute]
public void set_TransactionsModeDuration(TimeSetting value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrentFlushes();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrentFlushes(int value);
    [CompilerGeneratedAttribute]
public TimeSetting get_TimeToSyncAfterFlush();
    [CompilerGeneratedAttribute]
public void set_TimeToSyncAfterFlush(TimeSetting value);
    [CompilerGeneratedAttribute]
public int get_NumberOfConcurrentSyncsPerPhysicalDrive();
    [CompilerGeneratedAttribute]
public void set_NumberOfConcurrentSyncsPerPhysicalDrive(int value);
    [CompilerGeneratedAttribute]
public Size get_CompressTxAboveSize();
    [CompilerGeneratedAttribute]
public void set_CompressTxAboveSize(Size value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_MaxScratchBufferSize();
    [CompilerGeneratedAttribute]
public void set_MaxScratchBufferSize(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public Size get_PrefetchBatchSize();
    [CompilerGeneratedAttribute]
public void set_PrefetchBatchSize(Size value);
    [CompilerGeneratedAttribute]
public Size get_PrefetchResetThreshold();
    [CompilerGeneratedAttribute]
public void set_PrefetchResetThreshold(Size value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FreeSpaceAlertThresholdInPercentages();
    [CompilerGeneratedAttribute]
public void set_FreeSpaceAlertThresholdInPercentages(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Size> get_FreeSpaceAlertThreshold();
    [CompilerGeneratedAttribute]
public void set_FreeSpaceAlertThreshold(Nullable`1<Size> value);
    [CompilerGeneratedAttribute]
public int get_SyncJournalsCountThreshold();
    [CompilerGeneratedAttribute]
public void set_SyncJournalsCountThreshold(int value);
    [CompilerGeneratedAttribute]
public TimeSetting get_IoMetricsCleanupInterval();
    [CompilerGeneratedAttribute]
public void set_IoMetricsCleanupInterval(TimeSetting value);
    [CompilerGeneratedAttribute]
public string get_OnDirectoryInitializeExec();
    [CompilerGeneratedAttribute]
public void set_OnDirectoryInitializeExec(string value);
    [CompilerGeneratedAttribute]
public string get_OnDirectoryInitializeExecArguments();
    [CompilerGeneratedAttribute]
public void set_OnDirectoryInitializeExecArguments(string value);
    [CompilerGeneratedAttribute]
public TimeSetting get_OnDirectoryInitializeExecTimeout();
    [CompilerGeneratedAttribute]
public void set_OnDirectoryInitializeExecTimeout(TimeSetting value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IgnoreInvalidJournalErrors();
    [CompilerGeneratedAttribute]
public void set_IgnoreInvalidJournalErrors(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_SkipChecksumValidationOnDatabaseLoading();
    [CompilerGeneratedAttribute]
public void set_SkipChecksumValidationOnDatabaseLoading(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions();
    [CompilerGeneratedAttribute]
public void set_IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableEncryptionBuffersPooling();
    [CompilerGeneratedAttribute]
public void set_DisableEncryptionBuffersPooling(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfRecyclableJournals();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfRecyclableJournals(int value);
}
[ConfigurationCategoryAttribute("24")]
public class Raven.Server.Config.Categories.StudioConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [DescriptionAttribute("The directory in which RavenDB will search the studio files, defaults to the base directory")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("Studio.Path", "0", "11", "True", "False")]
public string Path { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
}
[ConfigurationCategoryAttribute("25")]
public class Raven.Server.Config.Categories.SubscriptionsConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private int <MaxNumberOfConcurrentConnections>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchivedDataProcessingBehavior <ArchivedDataProcessingBehavior>k__BackingField;
    [DefaultValueAttribute("1000")]
[ConfigurationEntryAttribute("Subscriptions.MaxNumberOfConcurrentConnections", "1", "12", "True", "False")]
[DescriptionAttribute("Amount of concurrent subscription connections per database")]
public int MaxNumberOfConcurrentConnections { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Subscriptions.ArchivedDataProcessingBehavior", "1", "17", "True", "False")]
[DescriptionAttribute("The default subscriptions archived data processing behavior per database")]
public ArchivedDataProcessingBehavior ArchivedDataProcessingBehavior { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfConcurrentConnections();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfConcurrentConnections(int value);
    [CompilerGeneratedAttribute]
public ArchivedDataProcessingBehavior get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(ArchivedDataProcessingBehavior value);
}
[ConfigurationCategoryAttribute("26")]
public class Raven.Server.Config.Categories.TombstoneConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private TimeSetting <CleanupInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <RetentionTimeWithReplicationHub>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <CleanupIntervalWithReplicationHub>k__BackingField;
    [DefaultValueAttribute("5")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Tombstones.CleanupIntervalInMin", "1", "13", "True", "False")]
[DescriptionAttribute("Time (in minutes) between tombstone cleanups.")]
public TimeSetting CleanupInterval { get; public set; }
    [DefaultValueAttribute("336")]
[TimeUnitAttribute("3")]
[ConfigurationEntryAttribute("Tombstones.RetentionTimeWithReplicationHubInHrs", "1", "19", "True", "False")]
[DescriptionAttribute("Time (in hours) to save tombsones when we have hub replication definition.")]
public TimeSetting RetentionTimeWithReplicationHub { get; public set; }
    [DefaultValueAttribute("1440")]
[TimeUnitAttribute("2")]
[ConfigurationEntryAttribute("Tombstones.CleanupIntervalWithReplicationHubInMin", "1", "25", "True", "False")]
[DescriptionAttribute("Time (in minutes) for new check for tombstone cleanup with hub definition.")]
public TimeSetting CleanupIntervalWithReplicationHub { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSetting get_CleanupInterval();
    [CompilerGeneratedAttribute]
public void set_CleanupInterval(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_RetentionTimeWithReplicationHub();
    [CompilerGeneratedAttribute]
public void set_RetentionTimeWithReplicationHub(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_CleanupIntervalWithReplicationHub();
    [CompilerGeneratedAttribute]
public void set_CleanupIntervalWithReplicationHub(TimeSetting value);
}
[ConfigurationCategoryAttribute("29")]
public class Raven.Server.Config.Categories.TrafficWatchConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private TrafficWatchMode <TrafficWatchMode>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Databases>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<int> <StatusCodes>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MinimumResponseSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MinimumRequestSize>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MinimumDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <HttpMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private TrafficWatchChangeType[] <ChangeTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CertificateThumbprints>k__BackingField;
    [DescriptionAttribute("Traffic Watch logging mode.")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("TrafficWatch.Mode", "0", "17", "True", "False")]
public TrafficWatchMode TrafficWatchMode { get; public set; }
    [DescriptionAttribute("A semicolon-separated list of database names by which the Traffic Watch logging entities will be filtered. If not specified, Traffic Watch entities of all databases will be included. Example list: "test-database;another-database;the-third-database".")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("TrafficWatch.Databases", "0", "22", "True", "False")]
public String[] Databases { get; public set; }
    [DescriptionAttribute("A semicolon-separated list of response status codes by which the Traffic Watch logging entities will be filtered. If not specified, Traffic Watch entities with any response status code will be included. Example list: "200;500;404".")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("TrafficWatch.StatusCodes", "0", "27", "True", "False")]
public HashSet`1<int> StatusCodes { get; public set; }
    [DescriptionAttribute("Minimum response size by which the Traffic Watch logging entities will be filtered.")]
[DefaultValueAttribute("0")]
[MinValueAttribute("0")]
[SizeUnitAttribute("0")]
[ConfigurationEntryAttribute("TrafficWatch.MinimumResponseSizeInBytes", "0", "34", "True", "False")]
public Size MinimumResponseSize { get; public set; }
    [DescriptionAttribute("Minimum request size by which the Traffic Watch logging entities will be filtered.")]
[DefaultValueAttribute("0")]
[MinValueAttribute("0")]
[SizeUnitAttribute("0")]
[ConfigurationEntryAttribute("TrafficWatch.MinimumRequestSizeInBytes", "0", "41", "True", "False")]
public Size MinimumRequestSize { get; public set; }
    [DescriptionAttribute("Minimum duration by which the Traffic Watch logging entities will be filtered.")]
[DefaultValueAttribute("0")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("TrafficWatch.MinimumDurationInMs", "0", "47", "True", "False")]
public TimeSetting MinimumDuration { get; public set; }
    [DescriptionAttribute("A semicolon-separated list of request HTTP methods by which the Traffic Watch logging entities will be filtered. If not specified, Traffic Watch entities with any HTTP request method will be included. Example list: "GET;POST".")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("TrafficWatch.HttpMethods", "0", "52", "True", "False")]
public String[] HttpMethods { get; public set; }
    [DescriptionAttribute("A semicolon-separated list of Traffic Watch change types by which the Traffic Watch logging entities will be filtered. If not specified, Traffic Watch entities with any change type will be included. Example list: "Queries;Documents".")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("TrafficWatch.ChangeTypes", "0", "57", "True", "False")]
public TrafficWatchChangeType[] ChangeTypes { get; public set; }
    [DescriptionAttribute("A semicolon-separated list of specific client certificate thumbprints by which the Traffic Watch logging entities will be filtered. If not specified, Traffic Watch entities with any certificate thumbprint will be included, including those without any thumbprint. Example list: "0123456789ABCDEF0123456789ABCDEF01234567;FEDCBA9876543210FEDCBA9876543210FEDCBA98".")]
[DefaultValueAttribute("")]
[ConfigurationEntryAttribute("TrafficWatch.CertificateThumbprints", "0", "62", "True", "False")]
public String[] CertificateThumbprints { get; public set; }
    [CompilerGeneratedAttribute]
public TrafficWatchMode get_TrafficWatchMode();
    [CompilerGeneratedAttribute]
public void set_TrafficWatchMode(TrafficWatchMode value);
    [CompilerGeneratedAttribute]
public String[] get_Databases();
    [CompilerGeneratedAttribute]
public void set_Databases(String[] value);
    [CompilerGeneratedAttribute]
public HashSet`1<int> get_StatusCodes();
    [CompilerGeneratedAttribute]
public void set_StatusCodes(HashSet`1<int> value);
    [CompilerGeneratedAttribute]
public Size get_MinimumResponseSize();
    [CompilerGeneratedAttribute]
public void set_MinimumResponseSize(Size value);
    [CompilerGeneratedAttribute]
public Size get_MinimumRequestSize();
    [CompilerGeneratedAttribute]
public void set_MinimumRequestSize(Size value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MinimumDuration();
    [CompilerGeneratedAttribute]
public void set_MinimumDuration(TimeSetting value);
    [CompilerGeneratedAttribute]
public String[] get_HttpMethods();
    [CompilerGeneratedAttribute]
public void set_HttpMethods(String[] value);
    [CompilerGeneratedAttribute]
public TrafficWatchChangeType[] get_ChangeTypes();
    [CompilerGeneratedAttribute]
public void set_ChangeTypes(TrafficWatchChangeType[] value);
    [CompilerGeneratedAttribute]
public String[] get_CertificateThumbprints();
    [CompilerGeneratedAttribute]
public void set_CertificateThumbprints(String[] value);
}
[ConfigurationCategoryAttribute("27")]
public class Raven.Server.Config.Categories.TransactionMergerConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private TimeSetting <MaxTimeToWaitForPreviousTx>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSetting <MaxTimeToWaitForPreviousTxBeforeRejecting>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxTxSize>k__BackingField;
    [DescriptionAttribute("EXPERT: Time to wait after the previous async commit is completed before checking for the tx size")]
[DefaultValueAttribute("0")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("TransactionMerger.MaxTimeToWaitForPreviousTxInMs", "1", "29", "True", "False")]
public TimeSetting MaxTimeToWaitForPreviousTx { get; public set; }
    [DescriptionAttribute("EXPERT: Time to wait for the previous async commit transaction before rejecting the request due to long duration IO")]
[DefaultValueAttribute("5000")]
[TimeUnitAttribute("0")]
[ConfigurationEntryAttribute("TransactionMerger.MaxTimeToWaitForPreviousTxBeforeRejectingInMs", "1", "35", "True", "False")]
public TimeSetting MaxTimeToWaitForPreviousTxBeforeRejecting { get; public set; }
    [DescriptionAttribute("EXPERT: Maximum size for the merged transaction")]
[DefaultValueAttribute("default-value-set-in-constructor")]
[SizeUnitAttribute("2")]
[ConfigurationEntryAttribute("TransactionMerger.MaxTxSizeInMb", "1", "41", "True", "False")]
public Size MaxTxSize { get; public set; }
    public TransactionMergerConfiguration(bool forceUsing32BitsPager);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxTimeToWaitForPreviousTx();
    [CompilerGeneratedAttribute]
public void set_MaxTimeToWaitForPreviousTx(TimeSetting value);
    [CompilerGeneratedAttribute]
public TimeSetting get_MaxTimeToWaitForPreviousTxBeforeRejecting();
    [CompilerGeneratedAttribute]
public void set_MaxTimeToWaitForPreviousTxBeforeRejecting(TimeSetting value);
    [CompilerGeneratedAttribute]
public Size get_MaxTxSize();
    [CompilerGeneratedAttribute]
public void set_MaxTxSize(Size value);
}
[FlagsAttribute]
public enum Raven.Server.Config.Categories.UnsecuredAccessAddressRange : Enum {
    public int value__;
    public static UnsecuredAccessAddressRange None;
    public static UnsecuredAccessAddressRange Local;
    public static UnsecuredAccessAddressRange PrivateNetwork;
    public static UnsecuredAccessAddressRange PublicNetwork;
}
[ConfigurationCategoryAttribute("28")]
public class Raven.Server.Config.Categories.UpdatesConfiguration : ConfigurationCategory {
    [CompilerGeneratedAttribute]
private ReleaseChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BackgroundChecksDisabled>k__BackingField;
    [DescriptionAttribute("Indicates what release channel should be used to perform latest version checks")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[ConfigurationEntryAttribute("Updates.Channel", "0", "11", "True", "False")]
public ReleaseChannel Channel { get; public set; }
    [DefaultValueAttribute("False")]
[ConfigurationEntryAttribute("Updates.BackgroundChecks.Disable", "0", "15", "True", "False")]
public bool BackgroundChecksDisabled { get; public set; }
    [CompilerGeneratedAttribute]
public ReleaseChannel get_Channel();
    [CompilerGeneratedAttribute]
public void set_Channel(ReleaseChannel value);
    [CompilerGeneratedAttribute]
public bool get_BackgroundChecksDisabled();
    [CompilerGeneratedAttribute]
public void set_BackgroundChecksDisabled(bool value);
}
public class Raven.Server.Config.ConfigurationEntryDatabaseValue : ConfigurationEntryServerValue {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ConfigurationEntrySingleValue> <DatabaseValues>k__BackingField;
    public Dictionary`2<string, ConfigurationEntrySingleValue> DatabaseValues { get; }
    public ConfigurationEntryDatabaseValue(RavenConfiguration configuration, DatabaseRecord dbRecord, ConfigurationEntryMetadata metadata, AuthenticationStatus authenticationStatus);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ConfigurationEntrySingleValue> get_DatabaseValues();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Config.ConfigurationEntryMetadata : object {
    public string Category;
    public String[] Keys;
    public ConfigurationEntryScope Scope;
    public string DefaultValue;
    public bool IsDefaultValueDynamic;
    public string Description;
    public ConfigurationEntryType Type;
    [CompilerGeneratedAttribute]
private Nullable`1<SizeUnit> <SizeUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeUnit> <TimeUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSecured>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AvailableValues>k__BackingField;
    public Nullable`1<SizeUnit> SizeUnit { get; private set; }
    public Nullable`1<TimeUnit> TimeUnit { get; private set; }
    public Nullable`1<int> MinValue { get; private set; }
    public bool IsArray { get; private set; }
    public bool IsNullable { get; private set; }
    public bool IsSecured { get; private set; }
    public String[] AvailableValues { get; private set; }
    public ConfigurationEntryMetadata(PropertyInfo configurationCategoryProperty, PropertyInfo configurationProperty, RavenConfiguration configuration);
    [CompilerGeneratedAttribute]
public Nullable`1<SizeUnit> get_SizeUnit();
    [CompilerGeneratedAttribute]
private void set_SizeUnit(Nullable`1<SizeUnit> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeUnit> get_TimeUnit();
    [CompilerGeneratedAttribute]
private void set_TimeUnit(Nullable`1<TimeUnit> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinValue();
    [CompilerGeneratedAttribute]
private void set_MinValue(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_IsArray();
    [CompilerGeneratedAttribute]
private void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNullable();
    [CompilerGeneratedAttribute]
private void set_IsNullable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSecured();
    [CompilerGeneratedAttribute]
private void set_IsSecured(bool value);
    [CompilerGeneratedAttribute]
public String[] get_AvailableValues();
    [CompilerGeneratedAttribute]
private void set_AvailableValues(String[] value);
    internal bool IsMatch(string key);
    public sealed virtual DynamicJsonValue ToJson();
    private string GetDefaultValue(PropertyInfo configurationCategoryProperty, PropertyInfo configurationProperty, RavenConfiguration configuration, Boolean& isDefaultValueDynamic);
    private ConfigurationEntryType GetConfigurationEntryType(PropertyInfo property);
    [CompilerGeneratedAttribute]
internal static bool <GetConfigurationEntryType>g__CalculateIsArray|39_0(string key, Type typeToCheck, Type& elementType);
}
public class Raven.Server.Config.ConfigurationEntryServerValue : ConfigurationEntryValue {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ConfigurationEntrySingleValue> <ServerValues>k__BackingField;
    public Dictionary`2<string, ConfigurationEntrySingleValue> ServerValues { get; }
    public ConfigurationEntryServerValue(IConfiguration configuration, ConfigurationEntryMetadata metadata, AuthenticationStatus authenticationStatus);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ConfigurationEntrySingleValue> get_ServerValues();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Config.ConfigurationEntrySinglePendingValue : object {
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueDeleted>k__BackingField;
    public bool HasValue { get; public set; }
    public string Value { get; public set; }
    public bool ValueDeleted { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    [CompilerGeneratedAttribute]
public void set_HasValue(bool value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public bool get_ValueDeleted();
    [CompilerGeneratedAttribute]
public void set_ValueDeleted(bool value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Config.ConfigurationEntrySingleValue : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationEntrySinglePendingValue <PendingValue>k__BackingField;
    public string Value { get; public set; }
    public bool HasValue { get; public set; }
    public bool HasAccess { get; public set; }
    public ConfigurationEntrySinglePendingValue PendingValue { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    [CompilerGeneratedAttribute]
public void set_HasValue(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasAccess();
    [CompilerGeneratedAttribute]
public void set_HasAccess(bool value);
    [CompilerGeneratedAttribute]
public ConfigurationEntrySinglePendingValue get_PendingValue();
    [CompilerGeneratedAttribute]
public void set_PendingValue(ConfigurationEntrySinglePendingValue value);
    public sealed virtual DynamicJsonValue ToJson();
}
public enum Raven.Server.Config.ConfigurationEntryType : Enum {
    public int value__;
    public static ConfigurationEntryType Unknown;
    public static ConfigurationEntryType String;
    public static ConfigurationEntryType Boolean;
    public static ConfigurationEntryType Enum;
    public static ConfigurationEntryType Uri;
    public static ConfigurationEntryType Path;
    public static ConfigurationEntryType Size;
    public static ConfigurationEntryType Time;
    public static ConfigurationEntryType Integer;
    public static ConfigurationEntryType Double;
}
public abstract class Raven.Server.Config.ConfigurationEntryValue : object {
    [CompilerGeneratedAttribute]
private ConfigurationEntryMetadata <Metadata>k__BackingField;
    public ConfigurationEntryMetadata Metadata { get; }
    protected ConfigurationEntryValue(ConfigurationEntryMetadata metadata);
    [CompilerGeneratedAttribute]
public ConfigurationEntryMetadata get_Metadata();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Config.ConfigurationEnumValueException : Exception {
    private Type _enumType;
    private string _attemptedValue;
    private string _message;
    public string Message { get; }
    public ConfigurationEnumValueException(string attemptedValue, Type enumType);
    public virtual string get_Message();
    private string FormatMessage();
    private String[] GetPossibleEnumValues();
    private bool IsFlag();
}
public class Raven.Server.Config.JsonConfigFileModifier : object {
    private static Logger Logger;
    private JsonOperationContext _context;
    private string _path;
    private bool _overwriteWholeFile;
    private BlittableJsonReaderObject _originJson;
    public DynamicJsonValue Modifications { get; }
    protected JsonConfigFileModifier(JsonOperationContext context, string path, bool overwriteWholeFile);
    private static JsonConfigFileModifier();
    public DynamicJsonValue get_Modifications();
    public static JsonConfigFileModifier Create(JsonOperationContext context, string path, bool overwriteWholeFile);
    protected void Initialize();
    [AsyncStateMachineAttribute("Raven.Server.Config.JsonConfigFileModifier/<ExecuteAsync>d__10")]
public Task ExecuteAsync();
    protected virtual void Validate(string path);
    private BlittableJsonReaderObject ReadBlittableFromFile(JsonOperationContext context);
    private void FillJsonFromFile(DynamicJsonValue jsonConfig);
    private static FileStream OpenFile(string path, FileMode fileMode, FileAccess fileAccess);
    [AsyncStateMachineAttribute("Raven.Server.Config.JsonConfigFileModifier/<PersistConfigurationAsync>d__15")]
private Task PersistConfigurationAsync(BlittableJsonReaderObject json);
    private void SwitchTempWithOriginalAndCreateBackup(string tempPath);
    protected bool IsOriginalValue(string key, T value);
    public sealed virtual void Dispose();
}
public class Raven.Server.Config.RavenConfiguration : object {
    internal static RavenConfiguration Default;
    private Logger _logger;
    private string _customConfigPath;
    private IConfigurationBuilder _configBuilder;
    [CompilerGeneratedAttribute]
private bool <Initialized>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseConfiguration <Licensing>k__BackingField;
    [CompilerGeneratedAttribute]
private CoreConfiguration <Core>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityConfiguration <Security>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpConfiguration <Http>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlConfiguration <Etl>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueSinkConfiguration <QueueSink>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationConfiguration <Replication>k__BackingField;
    [CompilerGeneratedAttribute]
private ClusterConfiguration <Cluster>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageConfiguration <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private BackupConfiguration <Backup>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingConfiguration <Indexing>k__BackingField;
    [CompilerGeneratedAttribute]
private MonitoringConfiguration <Monitoring>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryConfiguration <Queries>k__BackingField;
    [CompilerGeneratedAttribute]
private PatchingConfiguration <Patching>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerConfiguration <Server>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedConfiguration <Embedded>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryConfiguration <Memory>k__BackingField;
    [CompilerGeneratedAttribute]
private StudioConfiguration <Studio>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseConfiguration <Databases>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceHintsConfiguration <PerformanceHints>k__BackingField;
    [CompilerGeneratedAttribute]
private TombstoneConfiguration <Tombstones>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionsConfiguration <Subscriptions>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionMergerConfiguration <TransactionMergerConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private NotificationsConfiguration <Notifications>k__BackingField;
    [CompilerGeneratedAttribute]
private UpdatesConfiguration <Updates>k__BackingField;
    [CompilerGeneratedAttribute]
private MigrationConfiguration <Migration>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegrationsConfiguration <Integrations>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigurationRoot <ServerWideSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigurationRoot <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private TrafficWatchConfiguration <TrafficWatch>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugConfiguration <DebugConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private ExportImportConfiguration <ExportImport>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardingConfiguration <Sharding>k__BackingField;
    [CompilerGeneratedAttribute]
private LogsConfiguration <Logs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceType <ResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseType <LicenseType>k__BackingField;
    internal Lazy`1<HashSet`1<ConfigurationEntryMetadata>> _allConfigurationEntries;
    internal static Lazy`1<HashSet`1<ConfigurationEntryMetadata>> AllConfigurationEntriesForConfigurationNamesAndDebug;
    private static int _pathCounter;
    [CompilerGeneratedAttribute]
private static string <EnvironmentVariableLicenseString>k__BackingField;
    public bool Initialized { get; private set; }
    public LicenseConfiguration Licensing { get; }
    public CoreConfiguration Core { get; }
    public SecurityConfiguration Security { get; }
    public HttpConfiguration Http { get; }
    public EtlConfiguration Etl { get; }
    public QueueSinkConfiguration QueueSink { get; }
    public ReplicationConfiguration Replication { get; }
    public ClusterConfiguration Cluster { get; }
    public StorageConfiguration Storage { get; }
    public BackupConfiguration Backup { get; }
    public IndexingConfiguration Indexing { get; public set; }
    public MonitoringConfiguration Monitoring { get; }
    public QueryConfiguration Queries { get; }
    public PatchingConfiguration Patching { get; }
    public ServerConfiguration Server { get; }
    public EmbeddedConfiguration Embedded { get; }
    public MemoryConfiguration Memory { get; }
    public StudioConfiguration Studio { get; }
    public DatabaseConfiguration Databases { get; }
    public PerformanceHintsConfiguration PerformanceHints { get; }
    public TombstoneConfiguration Tombstones { get; }
    public SubscriptionsConfiguration Subscriptions { get; }
    public TransactionMergerConfiguration TransactionMergerConfiguration { get; }
    public NotificationsConfiguration Notifications { get; }
    public UpdatesConfiguration Updates { get; }
    public MigrationConfiguration Migration { get; }
    public IntegrationsConfiguration Integrations { get; }
    internal IConfigurationRoot ServerWideSettings { get; internal set; }
    internal IConfigurationRoot Settings { get; internal set; }
    public TrafficWatchConfiguration TrafficWatch { get; }
    public DebugConfiguration DebugConfiguration { get; }
    public ExportImportConfiguration ExportImport { get; }
    public ShardingConfiguration Sharding { get; public set; }
    internal string ConfigPath { get; }
    internal CommandLineConfigurationSource CommandLineSettings { get; }
    public LogsConfiguration Logs { get; public set; }
    public string ResourceName { get; }
    public ResourceType ResourceType { get; }
    public LicenseType LicenseType { get; private set; }
    public static string EnvironmentVariableLicenseString { get; private set; }
    private RavenConfiguration(string resourceName, ResourceType resourceType, string customConfigPath, bool skipEnvironmentVariables, LicenseType licenseType);
    private static RavenConfiguration();
    [CompilerGeneratedAttribute]
public bool get_Initialized();
    [CompilerGeneratedAttribute]
private void set_Initialized(bool value);
    [CompilerGeneratedAttribute]
public LicenseConfiguration get_Licensing();
    [CompilerGeneratedAttribute]
public CoreConfiguration get_Core();
    [CompilerGeneratedAttribute]
public SecurityConfiguration get_Security();
    [CompilerGeneratedAttribute]
public HttpConfiguration get_Http();
    [CompilerGeneratedAttribute]
public EtlConfiguration get_Etl();
    [CompilerGeneratedAttribute]
public QueueSinkConfiguration get_QueueSink();
    [CompilerGeneratedAttribute]
public ReplicationConfiguration get_Replication();
    [CompilerGeneratedAttribute]
public ClusterConfiguration get_Cluster();
    [CompilerGeneratedAttribute]
public StorageConfiguration get_Storage();
    [CompilerGeneratedAttribute]
public BackupConfiguration get_Backup();
    [CompilerGeneratedAttribute]
public IndexingConfiguration get_Indexing();
    [CompilerGeneratedAttribute]
public void set_Indexing(IndexingConfiguration value);
    [CompilerGeneratedAttribute]
public MonitoringConfiguration get_Monitoring();
    [CompilerGeneratedAttribute]
public QueryConfiguration get_Queries();
    [CompilerGeneratedAttribute]
public PatchingConfiguration get_Patching();
    [CompilerGeneratedAttribute]
public ServerConfiguration get_Server();
    [CompilerGeneratedAttribute]
public EmbeddedConfiguration get_Embedded();
    [CompilerGeneratedAttribute]
public MemoryConfiguration get_Memory();
    [CompilerGeneratedAttribute]
public StudioConfiguration get_Studio();
    [CompilerGeneratedAttribute]
public DatabaseConfiguration get_Databases();
    [CompilerGeneratedAttribute]
public PerformanceHintsConfiguration get_PerformanceHints();
    [CompilerGeneratedAttribute]
public TombstoneConfiguration get_Tombstones();
    [CompilerGeneratedAttribute]
public SubscriptionsConfiguration get_Subscriptions();
    [CompilerGeneratedAttribute]
public TransactionMergerConfiguration get_TransactionMergerConfiguration();
    [CompilerGeneratedAttribute]
public NotificationsConfiguration get_Notifications();
    [CompilerGeneratedAttribute]
public UpdatesConfiguration get_Updates();
    [CompilerGeneratedAttribute]
public MigrationConfiguration get_Migration();
    [CompilerGeneratedAttribute]
public IntegrationsConfiguration get_Integrations();
    [CompilerGeneratedAttribute]
internal IConfigurationRoot get_ServerWideSettings();
    [CompilerGeneratedAttribute]
internal void set_ServerWideSettings(IConfigurationRoot value);
    [CompilerGeneratedAttribute]
internal IConfigurationRoot get_Settings();
    [CompilerGeneratedAttribute]
internal void set_Settings(IConfigurationRoot value);
    [CompilerGeneratedAttribute]
public TrafficWatchConfiguration get_TrafficWatch();
    [CompilerGeneratedAttribute]
public DebugConfiguration get_DebugConfiguration();
    [CompilerGeneratedAttribute]
public ExportImportConfiguration get_ExportImport();
    [CompilerGeneratedAttribute]
public ShardingConfiguration get_Sharding();
    [CompilerGeneratedAttribute]
public void set_Sharding(ShardingConfiguration value);
    internal string get_ConfigPath();
    internal CommandLineConfigurationSource get_CommandLineSettings();
    private void AddJsonConfigurationVariables(string customConfigPath);
    private void AddEnvironmentVariables();
    [CompilerGeneratedAttribute]
public LogsConfiguration get_Logs();
    [CompilerGeneratedAttribute]
public void set_Logs(LogsConfiguration value);
    [CompilerGeneratedAttribute]
public string get_ResourceName();
    [CompilerGeneratedAttribute]
public ResourceType get_ResourceType();
    [CompilerGeneratedAttribute]
public LicenseType get_LicenseType();
    [CompilerGeneratedAttribute]
private void set_LicenseType(LicenseType value);
    public RavenConfiguration Initialize();
    public void PostInit();
    internal void UpdateLicenseType(LicenseType licenseType);
    public void SetSetting(string key, string value);
    public string GetSetting(string key);
    public string GetServerWideSetting(string key);
    internal static HashSet`1<ConfigurationEntryMetadata> GetAllConfigurationEntries(RavenConfiguration configuration);
    public static bool ContainsKey(string key);
    public static string GetKey(Expression`1<Func`2<RavenConfiguration, T>> getKey);
    public static object GetDefaultValue(Expression`1<Func`2<RavenConfiguration, T>> getKey);
    public static object GetValue(Expression`1<Func`2<RavenConfiguration, T>> getKey, RavenConfiguration serverConfiguration, Dictionary`2<string, string> settings);
    public static string GetDataDirectoryPath(CoreConfiguration coreConfiguration, string name, ResourceType type);
    public static RavenConfiguration CreateForServer(string name, string customConfigPath);
    public static RavenConfiguration CreateForDatabase(RavenConfiguration parent, string name);
    internal static RavenConfiguration CreateForTesting(string name, ResourceType resourceType, string customConfigPath);
    private static string GenerateDefaultDataDirectory(string template, ResourceType type, string name);
    public void AddCommandLine(String[] args);
    public void CheckDirectoryPermissions();
    [CompilerGeneratedAttribute]
private static void set_EnvironmentVariableLicenseString(string value);
    [CompilerGeneratedAttribute]
public static string get_EnvironmentVariableLicenseString();
    public bool DoesKeyExistInSettings(string keyName, bool serverWide);
    [CompilerGeneratedAttribute]
private HashSet`1<ConfigurationEntryMetadata> <UpdateLicenseType>b__134_2();
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Config.RavenConfigurationSection : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Item { get; public set; }
    public string Key { get; }
    public string Path { get; }
    public string Value { get; public set; }
    public RavenConfigurationSection(string key, string path, string value);
    public sealed virtual IConfigurationSection GetSection(string key);
    public sealed virtual IEnumerable`1<IConfigurationSection> GetChildren();
    public sealed virtual IChangeToken GetReloadToken();
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Value(string value);
}
public class Raven.Server.Config.Settings.PathSetting : PathSettingBase`1<PathSetting> {
    public PathSetting(string path, string baseDataDir);
    public PathSetting(string path, ResourceType type, string resourceName);
    public virtual PathSetting Combine(string path);
    public virtual PathSetting Combine(PathSetting path);
    private static string EnsureResourceInfo(string path, ResourceType type, string name);
}
[AttributeUsageAttribute("128")]
public class Raven.Server.Config.Settings.ReadOnlyPathAttribute : Attribute {
}
public class Raven.Server.Config.Settings.TimeSetting : ValueType {
    public TimeSpan AsTimeSpan;
    public TimeSetting(long value, TimeUnit unit);
    public TimeSetting(TimeSpan timeSpan);
    internal long GetValue(TimeUnit requestedUnit);
    public string GetValueAsString(TimeUnit requestedUnit);
}
public enum Raven.Server.Config.Settings.TimeUnit : Enum {
    public int value__;
    public static TimeUnit Milliseconds;
    public static TimeUnit Seconds;
    public static TimeUnit Minutes;
    public static TimeUnit Hours;
    public static TimeUnit Days;
}
public class Raven.Server.Config.Settings.UriSetting : ValueType {
    public string UriValue;
    public UriSetting(string uri);
    public virtual string ToString();
}
public class Raven.Server.Config.SettingsJsonModifier : JsonConfigFileModifier {
    private SettingsJsonModifier(JsonOperationContext context, string path, bool overwriteWholeFile);
    public static SettingsJsonModifier Create(JsonOperationContext context, string path, bool reset);
    protected virtual void Validate(string path);
    public void SetOrRemoveIfDefault(T1 value, Expression`1<Func`2<RavenConfiguration, T>> getKey);
    public void CollectionSetOrRemoveIfDefault(IEnumerable`1<T1> value, Expression`1<Func`2<RavenConfiguration, T>> getKey);
    private bool CheckIfDefault(T value, object defaultValue);
}
public class Raven.Server.Config.SettingsResult : object {
    [CompilerGeneratedAttribute]
private List`1<ConfigurationEntryValue> <Settings>k__BackingField;
    public List`1<ConfigurationEntryValue> Settings { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ConfigurationEntryValue> get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(List`1<ConfigurationEntryValue> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public abstract class Raven.Server.Dashboard.AbstractDashboardNotification : object {
}
public class Raven.Server.Dashboard.CanAccessDatabase : MulticastDelegate {
    public CanAccessDatabase(object object, IntPtr method);
    public virtual bool Invoke(string databaseName, bool requiresWrite);
    public virtual IAsyncResult BeginInvoke(string databaseName, bool requiresWrite, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class Raven.Server.Dashboard.Cluster.AbstractClusterDashboardNotification : object {
    [CompilerGeneratedAttribute]
private DateTime <Date>k__BackingField;
    public ClusterDashboardNotificationType Type { get; }
    public DateTime Date { get; }
    public abstract virtual ClusterDashboardNotificationType get_Type();
    [CompilerGeneratedAttribute]
public DateTime get_Date();
    public virtual DynamicJsonValue ToJson();
    public abstract virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public abstract class Raven.Server.Dashboard.Cluster.AbstractClusterDashboardNotificationSender : BackgroundWorkBase {
    private int _widgetId;
    private ConnectedWatcher _watcher;
    private DateTime _lastSentNotification;
    protected TimeSpan NotificationInterval { get; }
    protected AbstractClusterDashboardNotificationSender(int widgetId, ConnectedWatcher watcher, CancellationToken shutdown);
    protected abstract virtual TimeSpan get_NotificationInterval();
    protected abstract virtual AbstractClusterDashboardNotification CreateNotification();
    [AsyncStateMachineAttribute("Raven.Server.Dashboard.Cluster.AbstractClusterDashboardNotificationSender/<DoWork>d__7")]
protected virtual Task DoWork();
}
public class Raven.Server.Dashboard.Cluster.ClusterDashboardNotifications : NotificationsBase {
    private RavenServer _server;
    private CancellationToken _shutdown;
    private DatabasesInfoRetriever _databasesInfoRetriever;
    public ClusterDashboardNotifications(RavenServer server, CanAccessDatabase canAccessDatabase, CancellationToken shutdown);
    [AsyncStateMachineAttribute("Raven.Server.Dashboard.Cluster.ClusterDashboardNotifications/<CreateNotificationSender>d__4")]
public Task`1<AbstractClusterDashboardNotificationSender> CreateNotificationSender(int topicId, ClusterDashboardNotificationType type);
    [AsyncStateMachineAttribute("Raven.Server.Dashboard.Cluster.ClusterDashboardNotifications/<EnsureWatcher>d__5")]
public Task`1<ConnectedWatcher> EnsureWatcher();
}
public enum Raven.Server.Dashboard.Cluster.ClusterDashboardNotificationType : Enum {
    public int value__;
    public static ClusterDashboardNotificationType Unknown;
    public static ClusterDashboardNotificationType ServerTime;
    public static ClusterDashboardNotificationType CpuUsage;
    public static ClusterDashboardNotificationType MemoryUsage;
    public static ClusterDashboardNotificationType IoStats;
    public static ClusterDashboardNotificationType StorageUsage;
    public static ClusterDashboardNotificationType DatabaseStorageUsage;
    public static ClusterDashboardNotificationType Traffic;
    public static ClusterDashboardNotificationType DatabaseTraffic;
    public static ClusterDashboardNotificationType Indexing;
    public static ClusterDashboardNotificationType DatabaseIndexing;
    public static ClusterDashboardNotificationType ClusterOverview;
    public static ClusterDashboardNotificationType DatabaseOverview;
    public static ClusterDashboardNotificationType OngoingTasks;
}
public enum Raven.Server.Dashboard.Cluster.Notifications.ClusterDashboardPayloadType : Enum {
    public int value__;
    public static ClusterDashboardPayloadType Unknown;
    public static ClusterDashboardPayloadType Server;
    public static ClusterDashboardPayloadType Database;
}
public class Raven.Server.Dashboard.Cluster.Notifications.ClusterOverviewNotificationSender : AbstractClusterDashboardNotificationSender {
    private RavenServer _server;
    private TimeSpan _defaultInterval;
    protected TimeSpan NotificationInterval { get; }
    public ClusterOverviewNotificationSender(int widgetId, RavenServer server, ConnectedWatcher watcher, CancellationToken shutdown);
    protected virtual TimeSpan get_NotificationInterval();
    protected virtual AbstractClusterDashboardNotification CreateNotification();
}
public class Raven.Server.Dashboard.Cluster.Notifications.ClusterOverviewPayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private RachisState <NodeState>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OsName>k__BackingField;
    [CompilerGeneratedAttribute]
private OSType <OsType>k__BackingField;
    public string NodeTag { get; public set; }
    public string NodeUrl { get; public set; }
    public string NodeType { get; public set; }
    public RachisState NodeState { get; public set; }
    public DateTime StartTime { get; public set; }
    public string ServerVersion { get; public set; }
    public string OsName { get; public set; }
    public OSType OsType { get; public set; }
    public ClusterDashboardNotificationType Type { get; }
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public string get_NodeUrl();
    [CompilerGeneratedAttribute]
public void set_NodeUrl(string value);
    [CompilerGeneratedAttribute]
public string get_NodeType();
    [CompilerGeneratedAttribute]
public void set_NodeType(string value);
    [CompilerGeneratedAttribute]
public RachisState get_NodeState();
    [CompilerGeneratedAttribute]
public void set_NodeState(RachisState value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public string get_ServerVersion();
    [CompilerGeneratedAttribute]
public void set_ServerVersion(string value);
    [CompilerGeneratedAttribute]
public string get_OsName();
    [CompilerGeneratedAttribute]
public void set_OsName(string value);
    [CompilerGeneratedAttribute]
public OSType get_OsType();
    [CompilerGeneratedAttribute]
public void set_OsType(OSType value);
    public virtual ClusterDashboardNotificationType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.CpuUsageNotificationSender : AbstractClusterDashboardNotificationSender {
    private RavenServer _server;
    private TimeSpan _defaultInterval;
    private DetailsPerNode _nodeLicenseLimits;
    protected TimeSpan NotificationInterval { get; }
    public CpuUsageNotificationSender(int widgetId, RavenServer server, ConnectedWatcher watcher, CancellationToken shutdown);
    protected virtual void InitializeWork();
    private void TryFillNodeLicenseLimits();
    protected virtual TimeSpan get_NotificationInterval();
    protected virtual AbstractClusterDashboardNotification CreateNotification();
}
public class Raven.Server.Dashboard.Cluster.Notifications.CpuUsagePayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private int <MachineCpuUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessCpuUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UtilizedCores>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfCores>k__BackingField;
    public int MachineCpuUsage { get; public set; }
    public int ProcessCpuUsage { get; public set; }
    public int UtilizedCores { get; public set; }
    public int NumberOfCores { get; public set; }
    public ClusterDashboardNotificationType Type { get; }
    [CompilerGeneratedAttribute]
public int get_MachineCpuUsage();
    [CompilerGeneratedAttribute]
public void set_MachineCpuUsage(int value);
    [CompilerGeneratedAttribute]
public int get_ProcessCpuUsage();
    [CompilerGeneratedAttribute]
public void set_ProcessCpuUsage(int value);
    [CompilerGeneratedAttribute]
public int get_UtilizedCores();
    [CompilerGeneratedAttribute]
public void set_UtilizedCores(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfCores();
    [CompilerGeneratedAttribute]
public void set_NumberOfCores(int value);
    public virtual ClusterDashboardNotificationType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.DatabaseIndexingSpeedPayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<IndexingSpeedItem> <Items>k__BackingField;
    public ClusterDashboardNotificationType Type { get; }
    public List`1<IndexingSpeedItem> Items { get; public set; }
    public virtual ClusterDashboardNotificationType get_Type();
    [CompilerGeneratedAttribute]
public List`1<IndexingSpeedItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<IndexingSpeedItem> value);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.DatabaseOverviewNotificationSender : AbstractClusterDashboardNotificationSender {
    private DatabasesInfoRetriever _databasesInfoRetriever;
    protected TimeSpan NotificationInterval { get; }
    public DatabaseOverviewNotificationSender(int widgetId, DatabasesInfoRetriever databasesInfoRetriever, ConnectedWatcher watcher, CancellationToken shutdown);
    protected virtual TimeSpan get_NotificationInterval();
    protected virtual AbstractClusterDashboardNotification CreateNotification();
}
public class Raven.Server.Dashboard.Cluster.Notifications.DatabaseOverviewPayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<DatabaseInfoItem> <Items>k__BackingField;
    public ClusterDashboardNotificationType Type { get; }
    public List`1<DatabaseInfoItem> Items { get; public set; }
    public virtual ClusterDashboardNotificationType get_Type();
    [CompilerGeneratedAttribute]
public List`1<DatabaseInfoItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<DatabaseInfoItem> value);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.DatabaseStorageUsagePayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<DatabaseDiskUsage> <Items>k__BackingField;
    public List`1<DatabaseDiskUsage> Items { get; public set; }
    public ClusterDashboardNotificationType Type { get; }
    [CompilerGeneratedAttribute]
public List`1<DatabaseDiskUsage> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<DatabaseDiskUsage> value);
    public virtual ClusterDashboardNotificationType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.DatabaseTrafficWatchPayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<TrafficWatchItem> <Items>k__BackingField;
    public ClusterDashboardNotificationType Type { get; }
    public List`1<TrafficWatchItem> Items { get; public set; }
    public virtual ClusterDashboardNotificationType get_Type();
    [CompilerGeneratedAttribute]
public List`1<TrafficWatchItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<TrafficWatchItem> value);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.IndexingSpeedNotificationSender : AbstractClusterDashboardNotificationSender {
    private ClusterDashboardPayloadType _payloadType;
    private DatabasesInfoRetriever _databasesInfoRetriever;
    protected TimeSpan NotificationInterval { get; }
    public IndexingSpeedNotificationSender(int widgetId, ClusterDashboardPayloadType payloadType, DatabasesInfoRetriever databasesInfoRetriever, ConnectedWatcher watcher, CancellationToken shutdown);
    protected virtual TimeSpan get_NotificationInterval();
    protected virtual AbstractClusterDashboardNotification CreateNotification();
}
public class Raven.Server.Dashboard.Cluster.Notifications.IndexingSpeedPayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private double <IndexedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MappedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ReducedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IndexingSpeedItem> <IndexingSpeedPerDatabase>k__BackingField;
    public double IndexedPerSecond { get; public set; }
    public double MappedPerSecond { get; public set; }
    public double ReducedPerSecond { get; public set; }
    internal List`1<IndexingSpeedItem> IndexingSpeedPerDatabase { get; internal set; }
    public ClusterDashboardNotificationType Type { get; }
    [CompilerGeneratedAttribute]
public double get_IndexedPerSecond();
    [CompilerGeneratedAttribute]
public void set_IndexedPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_MappedPerSecond();
    [CompilerGeneratedAttribute]
public void set_MappedPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_ReducedPerSecond();
    [CompilerGeneratedAttribute]
public void set_ReducedPerSecond(double value);
    [CompilerGeneratedAttribute]
internal List`1<IndexingSpeedItem> get_IndexingSpeedPerDatabase();
    [CompilerGeneratedAttribute]
internal void set_IndexingSpeedPerDatabase(List`1<IndexingSpeedItem> value);
    public virtual ClusterDashboardNotificationType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
    private DynamicJsonValue ToJsonInternal();
    private void Add(IndexingSpeedItem item);
}
public class Raven.Server.Dashboard.Cluster.Notifications.IoStatsNotificationSender : AbstractClusterDashboardNotificationSender {
    private DatabasesInfoRetriever _databasesInfoRetriever;
    private TimeSpan _defaultInterval;
    protected TimeSpan NotificationInterval { get; }
    public IoStatsNotificationSender(int widgetId, DatabasesInfoRetriever databasesInfoRetriever, ConnectedWatcher watcher, CancellationToken shutdown);
    protected virtual TimeSpan get_NotificationInterval();
    protected virtual AbstractClusterDashboardNotification CreateNotification();
}
public class Raven.Server.Dashboard.Cluster.Notifications.IoStatsPayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<IoStatsResult> <Items>k__BackingField;
    public List`1<IoStatsResult> Items { get; public set; }
    public ClusterDashboardNotificationType Type { get; }
    [CompilerGeneratedAttribute]
public List`1<IoStatsResult> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<IoStatsResult> value);
    public virtual ClusterDashboardNotificationType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.MemoryUsageNotificationSender : AbstractClusterDashboardNotificationSender {
    private RavenServer _server;
    private LowMemoryMonitor _lowMemoryMonitor;
    private TimeSpan _defaultInterval;
    protected TimeSpan NotificationInterval { get; }
    public MemoryUsageNotificationSender(int widgetId, RavenServer server, ConnectedWatcher watcher, CancellationToken shutdown);
    protected virtual TimeSpan get_NotificationInterval();
    protected virtual AbstractClusterDashboardNotification CreateNotification();
}
public class Raven.Server.Dashboard.Cluster.Notifications.MemoryUsagePayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private LowMemorySeverity <LowMemorySeverity>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PhysicalMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <WorkingSet>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ManagedAllocations>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UnmanagedAllocations>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SystemCommitLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EncryptionBuffersInUse>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EncryptionBuffersPool>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MemoryMapped>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DirtyMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AvailableMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AvailableMemoryForProcessing>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSwapUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LuceneManagedTermCacheAllocations>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LuceneUnmanagedAllocations>k__BackingField;
    public DateTime Time { get; public set; }
    public LowMemorySeverity LowMemorySeverity { get; public set; }
    public long PhysicalMemory { get; public set; }
    public long WorkingSet { get; public set; }
    public long ManagedAllocations { get; public set; }
    public long UnmanagedAllocations { get; public set; }
    public long SystemCommitLimit { get; public set; }
    public long EncryptionBuffersInUse { get; public set; }
    public long EncryptionBuffersPool { get; public set; }
    public long MemoryMapped { get; public set; }
    public long DirtyMemory { get; public set; }
    public long AvailableMemory { get; public set; }
    public long AvailableMemoryForProcessing { get; public set; }
    public long TotalSwapUsage { get; public set; }
    public long LuceneManagedTermCacheAllocations { get; public set; }
    public long LuceneUnmanagedAllocations { get; public set; }
    public ClusterDashboardNotificationType Type { get; }
    [CompilerGeneratedAttribute]
public DateTime get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(DateTime value);
    [CompilerGeneratedAttribute]
public LowMemorySeverity get_LowMemorySeverity();
    [CompilerGeneratedAttribute]
public void set_LowMemorySeverity(LowMemorySeverity value);
    [CompilerGeneratedAttribute]
public long get_PhysicalMemory();
    [CompilerGeneratedAttribute]
public void set_PhysicalMemory(long value);
    [CompilerGeneratedAttribute]
public long get_WorkingSet();
    [CompilerGeneratedAttribute]
public void set_WorkingSet(long value);
    [CompilerGeneratedAttribute]
public long get_ManagedAllocations();
    [CompilerGeneratedAttribute]
public void set_ManagedAllocations(long value);
    [CompilerGeneratedAttribute]
public long get_UnmanagedAllocations();
    [CompilerGeneratedAttribute]
public void set_UnmanagedAllocations(long value);
    [CompilerGeneratedAttribute]
public long get_SystemCommitLimit();
    [CompilerGeneratedAttribute]
public void set_SystemCommitLimit(long value);
    [CompilerGeneratedAttribute]
public long get_EncryptionBuffersInUse();
    [CompilerGeneratedAttribute]
public void set_EncryptionBuffersInUse(long value);
    [CompilerGeneratedAttribute]
public long get_EncryptionBuffersPool();
    [CompilerGeneratedAttribute]
public void set_EncryptionBuffersPool(long value);
    [CompilerGeneratedAttribute]
public long get_MemoryMapped();
    [CompilerGeneratedAttribute]
public void set_MemoryMapped(long value);
    [CompilerGeneratedAttribute]
public long get_DirtyMemory();
    [CompilerGeneratedAttribute]
public void set_DirtyMemory(long value);
    [CompilerGeneratedAttribute]
public long get_AvailableMemory();
    [CompilerGeneratedAttribute]
public void set_AvailableMemory(long value);
    [CompilerGeneratedAttribute]
public long get_AvailableMemoryForProcessing();
    [CompilerGeneratedAttribute]
public void set_AvailableMemoryForProcessing(long value);
    [CompilerGeneratedAttribute]
public long get_TotalSwapUsage();
    [CompilerGeneratedAttribute]
public void set_TotalSwapUsage(long value);
    [CompilerGeneratedAttribute]
public long get_LuceneManagedTermCacheAllocations();
    [CompilerGeneratedAttribute]
public void set_LuceneManagedTermCacheAllocations(long value);
    [CompilerGeneratedAttribute]
public long get_LuceneUnmanagedAllocations();
    [CompilerGeneratedAttribute]
public void set_LuceneUnmanagedAllocations(long value);
    public virtual ClusterDashboardNotificationType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.OngoingTasksNotificationSender : AbstractClusterDashboardNotificationSender {
    private DatabasesInfoRetriever _databasesInfoRetriever;
    protected TimeSpan NotificationInterval { get; }
    public OngoingTasksNotificationSender(int widgetId, DatabasesInfoRetriever databasesInfoRetriever, ConnectedWatcher watcher, CancellationToken shutdown);
    protected virtual TimeSpan get_NotificationInterval();
    protected virtual AbstractClusterDashboardNotification CreateNotification();
}
public class Raven.Server.Dashboard.Cluster.Notifications.OngoingTasksPayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<DatabaseOngoingTasksInfoItem> <Items>k__BackingField;
    public ClusterDashboardNotificationType Type { get; }
    public List`1<DatabaseOngoingTasksInfoItem> Items { get; public set; }
    public virtual ClusterDashboardNotificationType get_Type();
    [CompilerGeneratedAttribute]
public List`1<DatabaseOngoingTasksInfoItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<DatabaseOngoingTasksInfoItem> value);
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.ServerTimePayload : AbstractClusterDashboardNotification {
    public ClusterDashboardNotificationType Type { get; }
    public virtual ClusterDashboardNotificationType get_Type();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.StorageUsageNotificationSender : AbstractClusterDashboardNotificationSender {
    private ClusterDashboardPayloadType _payloadType;
    private DatabasesInfoRetriever _databasesInfoRetriever;
    private TimeSpan _defaultInterval;
    protected TimeSpan NotificationInterval { get; }
    public StorageUsageNotificationSender(int widgetId, ClusterDashboardPayloadType payloadType, DatabasesInfoRetriever databasesInfoRetriever, ConnectedWatcher watcher, CancellationToken shutdown);
    protected virtual TimeSpan get_NotificationInterval();
    protected virtual AbstractClusterDashboardNotification CreateNotification();
}
public class Raven.Server.Dashboard.Cluster.Notifications.StorageUsagePayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<MountPointUsage> <Items>k__BackingField;
    public List`1<MountPointUsage> Items { get; public set; }
    public ClusterDashboardNotificationType Type { get; }
    [CompilerGeneratedAttribute]
public List`1<MountPointUsage> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<MountPointUsage> value);
    public virtual ClusterDashboardNotificationType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.Cluster.Notifications.TrafficNotificationSender : AbstractClusterDashboardNotificationSender {
    private ClusterDashboardPayloadType _payloadType;
    private DatabasesInfoRetriever _databasesInfoRetriever;
    protected TimeSpan NotificationInterval { get; }
    public TrafficNotificationSender(int widgetId, ClusterDashboardPayloadType payloadType, DatabasesInfoRetriever databasesInfoRetriever, ConnectedWatcher watcher, CancellationToken shutdown);
    protected virtual TimeSpan get_NotificationInterval();
    protected virtual AbstractClusterDashboardNotification CreateNotification();
}
public class Raven.Server.Dashboard.Cluster.Notifications.TrafficWatchPayload : AbstractClusterDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<TrafficWatchItem> <TrafficPerDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequestsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocumentWritesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AttachmentWritesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CounterWritesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeSeriesWritesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DocumentsWriteBytesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AttachmentsWriteBytesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CountersWriteBytesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TimeSeriesWriteBytesPerSecond>k__BackingField;
    internal List`1<TrafficWatchItem> TrafficPerDatabase { get; internal set; }
    public int RequestsPerSecond { get; public set; }
    public int DocumentWritesPerSecond { get; public set; }
    public int AttachmentWritesPerSecond { get; public set; }
    public int CounterWritesPerSecond { get; public set; }
    public int TimeSeriesWritesPerSecond { get; public set; }
    public double DocumentsWriteBytesPerSecond { get; public set; }
    public double AttachmentsWriteBytesPerSecond { get; public set; }
    public double CountersWriteBytesPerSecond { get; public set; }
    public double TimeSeriesWriteBytesPerSecond { get; public set; }
    public ClusterDashboardNotificationType Type { get; }
    [CompilerGeneratedAttribute]
internal List`1<TrafficWatchItem> get_TrafficPerDatabase();
    [CompilerGeneratedAttribute]
internal void set_TrafficPerDatabase(List`1<TrafficWatchItem> value);
    [CompilerGeneratedAttribute]
public int get_RequestsPerSecond();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSecond(int value);
    [CompilerGeneratedAttribute]
public int get_DocumentWritesPerSecond();
    [CompilerGeneratedAttribute]
public void set_DocumentWritesPerSecond(int value);
    [CompilerGeneratedAttribute]
public int get_AttachmentWritesPerSecond();
    [CompilerGeneratedAttribute]
public void set_AttachmentWritesPerSecond(int value);
    [CompilerGeneratedAttribute]
public int get_CounterWritesPerSecond();
    [CompilerGeneratedAttribute]
public void set_CounterWritesPerSecond(int value);
    [CompilerGeneratedAttribute]
public int get_TimeSeriesWritesPerSecond();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesWritesPerSecond(int value);
    [CompilerGeneratedAttribute]
public double get_DocumentsWriteBytesPerSecond();
    [CompilerGeneratedAttribute]
public void set_DocumentsWriteBytesPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_AttachmentsWriteBytesPerSecond();
    [CompilerGeneratedAttribute]
public void set_AttachmentsWriteBytesPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_CountersWriteBytesPerSecond();
    [CompilerGeneratedAttribute]
public void set_CountersWriteBytesPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_TimeSeriesWriteBytesPerSecond();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesWriteBytesPerSecond(double value);
    public virtual ClusterDashboardNotificationType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
    private DynamicJsonValue ToJsonInternal();
    private void Add(TrafficWatchItem item);
}
public class Raven.Server.Dashboard.Cluster.WidgetMessage : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicJsonValue <Data>k__BackingField;
    public int Id { get; public set; }
    public DynamicJsonValue Data { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public DynamicJsonValue get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(DynamicJsonValue value);
}
public class Raven.Server.Dashboard.Cluster.WidgetRequest : object {
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ClusterDashboardNotificationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Config>k__BackingField;
    public string Command { get; public set; }
    public int Id { get; public set; }
    public ClusterDashboardNotificationType Type { get; public set; }
    public object Config { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(string value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public ClusterDashboardNotificationType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ClusterDashboardNotificationType value);
    [CompilerGeneratedAttribute]
public object get_Config();
    [CompilerGeneratedAttribute]
public void set_Config(object value);
}
public class Raven.Server.Dashboard.DatabaseDiskUsage : object {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TempBuffersSize>k__BackingField;
    public string Database { get; public set; }
    public long Size { get; public set; }
    public long TempBuffersSize { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(long value);
    [CompilerGeneratedAttribute]
public long get_TempBuffersSize();
    [CompilerGeneratedAttribute]
public void set_TempBuffersSize(long value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Dashboard.DatabaseInfoItem : object {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DocumentsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <IndexesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ErroredIndexesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AlertsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PerformanceHintsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplicationFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Online>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Irrelevant>k__BackingField;
    [CompilerGeneratedAttribute]
private long <IndexingErrorsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private BackupInfo <BackupInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OngoingTasksCount>k__BackingField;
    public string Database { get; public set; }
    public long DocumentsCount { get; public set; }
    public long IndexesCount { get; public set; }
    public long ErroredIndexesCount { get; public set; }
    public long AlertsCount { get; public set; }
    public long PerformanceHintsCount { get; public set; }
    public int ReplicationFactor { get; public set; }
    public bool Online { get; public set; }
    public bool Disabled { get; public set; }
    public bool Irrelevant { get; public set; }
    public long IndexingErrorsCount { get; public set; }
    public BackupInfo BackupInfo { get; public set; }
    public long OngoingTasksCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public long get_DocumentsCount();
    [CompilerGeneratedAttribute]
public void set_DocumentsCount(long value);
    [CompilerGeneratedAttribute]
public long get_IndexesCount();
    [CompilerGeneratedAttribute]
public void set_IndexesCount(long value);
    [CompilerGeneratedAttribute]
public long get_ErroredIndexesCount();
    [CompilerGeneratedAttribute]
public void set_ErroredIndexesCount(long value);
    [CompilerGeneratedAttribute]
public long get_AlertsCount();
    [CompilerGeneratedAttribute]
public void set_AlertsCount(long value);
    [CompilerGeneratedAttribute]
public long get_PerformanceHintsCount();
    [CompilerGeneratedAttribute]
public void set_PerformanceHintsCount(long value);
    [CompilerGeneratedAttribute]
public int get_ReplicationFactor();
    [CompilerGeneratedAttribute]
public void set_ReplicationFactor(int value);
    [CompilerGeneratedAttribute]
public bool get_Online();
    [CompilerGeneratedAttribute]
public void set_Online(bool value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_Irrelevant();
    [CompilerGeneratedAttribute]
public void set_Irrelevant(bool value);
    [CompilerGeneratedAttribute]
public long get_IndexingErrorsCount();
    [CompilerGeneratedAttribute]
public void set_IndexingErrorsCount(long value);
    [CompilerGeneratedAttribute]
public BackupInfo get_BackupInfo();
    [CompilerGeneratedAttribute]
public void set_BackupInfo(BackupInfo value);
    [CompilerGeneratedAttribute]
public long get_OngoingTasksCount();
    [CompilerGeneratedAttribute]
public void set_OngoingTasksCount(long value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Dashboard.DatabaseOngoingTasksInfoItem : object {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExternalReplicationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReplicationHubCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReplicationSinkCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RavenEtlCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SqlEtlCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ElasticSearchEtlCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OlapEtlCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <KafkaEtlCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RabbitMqEtlCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AzureQueueStorageEtlCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PeriodicBackupCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SubscriptionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <KafkaSinkCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RabbitMqSinkCount>k__BackingField;
    public string Database { get; public set; }
    public long ExternalReplicationCount { get; public set; }
    public long ReplicationHubCount { get; public set; }
    public long ReplicationSinkCount { get; public set; }
    public long RavenEtlCount { get; public set; }
    public long SqlEtlCount { get; public set; }
    public long ElasticSearchEtlCount { get; public set; }
    public long OlapEtlCount { get; public set; }
    public long KafkaEtlCount { get; public set; }
    public long RabbitMqEtlCount { get; public set; }
    public long AzureQueueStorageEtlCount { get; public set; }
    public long PeriodicBackupCount { get; public set; }
    public long SubscriptionCount { get; public set; }
    public long KafkaSinkCount { get; public set; }
    public long RabbitMqSinkCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public long get_ExternalReplicationCount();
    [CompilerGeneratedAttribute]
public void set_ExternalReplicationCount(long value);
    [CompilerGeneratedAttribute]
public long get_ReplicationHubCount();
    [CompilerGeneratedAttribute]
public void set_ReplicationHubCount(long value);
    [CompilerGeneratedAttribute]
public long get_ReplicationSinkCount();
    [CompilerGeneratedAttribute]
public void set_ReplicationSinkCount(long value);
    [CompilerGeneratedAttribute]
public long get_RavenEtlCount();
    [CompilerGeneratedAttribute]
public void set_RavenEtlCount(long value);
    [CompilerGeneratedAttribute]
public long get_SqlEtlCount();
    [CompilerGeneratedAttribute]
public void set_SqlEtlCount(long value);
    [CompilerGeneratedAttribute]
public long get_ElasticSearchEtlCount();
    [CompilerGeneratedAttribute]
public void set_ElasticSearchEtlCount(long value);
    [CompilerGeneratedAttribute]
public long get_OlapEtlCount();
    [CompilerGeneratedAttribute]
public void set_OlapEtlCount(long value);
    [CompilerGeneratedAttribute]
public long get_KafkaEtlCount();
    [CompilerGeneratedAttribute]
public void set_KafkaEtlCount(long value);
    [CompilerGeneratedAttribute]
public long get_RabbitMqEtlCount();
    [CompilerGeneratedAttribute]
public void set_RabbitMqEtlCount(long value);
    [CompilerGeneratedAttribute]
public long get_AzureQueueStorageEtlCount();
    [CompilerGeneratedAttribute]
public void set_AzureQueueStorageEtlCount(long value);
    [CompilerGeneratedAttribute]
public long get_PeriodicBackupCount();
    [CompilerGeneratedAttribute]
public void set_PeriodicBackupCount(long value);
    [CompilerGeneratedAttribute]
public long get_SubscriptionCount();
    [CompilerGeneratedAttribute]
public void set_SubscriptionCount(long value);
    [CompilerGeneratedAttribute]
public long get_KafkaSinkCount();
    [CompilerGeneratedAttribute]
public void set_KafkaSinkCount(long value);
    [CompilerGeneratedAttribute]
public long get_RabbitMqSinkCount();
    [CompilerGeneratedAttribute]
public void set_RabbitMqSinkCount(long value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Dashboard.DatabasesInfo : AbstractDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<DatabaseInfoItem> <Items>k__BackingField;
    public List`1<DatabaseInfoItem> Items { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<DatabaseInfoItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<DatabaseInfoItem> value);
}
public class Raven.Server.Dashboard.DatabasesInfoRetriever : MetricCacher {
    private ServerStore _serverStore;
    private CanAccessDatabase _canAccessDatabase;
    private static string DatabasesInfoKey;
    [CompilerGeneratedAttribute]
private static TimeSpan <RefreshRate>k__BackingField;
    private static ConcurrentDictionary`2<string, DatabaseInfoCache> CachedDatabaseInfo;
    private static SystemInfoCache CachedSystemInfo;
    public static TimeSpan RefreshRate { get; }
    public DatabasesInfoRetriever(ServerStore serverStore, CanAccessDatabase canAccessDatabase);
    private static DatabasesInfoRetriever();
    [CompilerGeneratedAttribute]
public static TimeSpan get_RefreshRate();
    public void Initialize();
    private List`1<AbstractDashboardNotification> CreateDatabasesInfo();
    public DatabasesInfo GetDatabasesInfo();
    public DatabasesOngoingTasksInfo GetDatabasesOngoingTasksInfo();
    public IndexingSpeed GetIndexingSpeed();
    public TrafficWatch GetTrafficWatch();
    public DrivesUsage GetDrivesUsage();
    [IteratorStateMachineAttribute("Raven.Server.Dashboard.DatabasesInfoRetriever/<FetchDatabasesInfo>d__15")]
public static IEnumerable`1<AbstractDashboardNotification> FetchDatabasesInfo(ServerStore serverStore, CanAccessDatabase isValidFor, bool collectOngoingTasks, CancellationToken token);
    private static void AddInfoForDatabase(ServerStore serverStore, bool collectOngoingTasks, AggregatedWatchInfo trafficWatchInfo, ClusterOperationContext context, RawDatabaseRecord rawRecord, CancellationToken token);
    private static DatabaseOngoingTasksInfoItem GetOngoingTasksInfoItem(DocumentDatabase database, ServerStore serverStore, ClusterOperationContext context, Int64& ongoingTasksCount);
    private static long GetTaskCountOnNode(DocumentDatabase database, DatabaseRecord dbRecord, ServerStore serverStore, IEnumerable`1<IDatabaseTask> tasks, Func`2<T, IDatabaseTaskStatus> getTaskStatus, Func`2<T, bool> filter);
    private static long GetSubscriptionCountOnNode(DocumentDatabase database, DatabaseRecord dbRecord, ServerStore serverStore, ClusterOperationContext context);
    private static void DiskUsageCheck(DatabaseInfoCache item, DocumentDatabase database, DrivesUsage drivesUsage, CancellationToken token);
    private static void UpdateMountPoint(StorageConfiguration storageConfiguration, MountPointUsage mountPointUsage, string databaseName, DrivesUsage drivesUsage);
    private static void SetOfflineDatabaseInfo(ServerStore serverStore, ClusterOperationContext context, string databaseName, DatabasesInfo existingDatabasesInfo, DrivesUsage existingDrivesUsage, bool disabled);
    private static void UpdateDatabaseInfo(RawDatabaseRecord databaseRecord, ServerStore serverStore, string databaseName, DrivesUsage existingDrivesUsage, DatabaseInfoItem databaseInfoItem);
}
public class Raven.Server.Dashboard.DatabasesOngoingTasksInfo : AbstractDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<DatabaseOngoingTasksInfoItem> <Items>k__BackingField;
    public List`1<DatabaseOngoingTasksInfoItem> Items { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<DatabaseOngoingTasksInfoItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<DatabaseOngoingTasksInfoItem> value);
}
public class Raven.Server.Dashboard.DrivesUsage : AbstractDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<MountPointUsage> <Items>k__BackingField;
    public List`1<MountPointUsage> Items { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<MountPointUsage> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<MountPointUsage> value);
}
public class Raven.Server.Dashboard.ExtendedDatabaseInfo : DatabaseInfo {
    [CompilerGeneratedAttribute]
private List`1<MountPointUsage> <MountPointsUsage>k__BackingField;
    public List`1<MountPointUsage> MountPointsUsage { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<MountPointUsage> get_MountPointsUsage();
    [CompilerGeneratedAttribute]
public void set_MountPointsUsage(List`1<MountPointUsage> value);
}
public class Raven.Server.Dashboard.IndexingSpeed : AbstractDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<IndexingSpeedItem> <Items>k__BackingField;
    public List`1<IndexingSpeedItem> Items { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<IndexingSpeedItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<IndexingSpeedItem> value);
}
public class Raven.Server.Dashboard.IndexingSpeedItem : object {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IndexedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MappedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ReducedPerSecond>k__BackingField;
    public string Database { get; public set; }
    public double IndexedPerSecond { get; public set; }
    public double MappedPerSecond { get; public set; }
    public double ReducedPerSecond { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public double get_IndexedPerSecond();
    [CompilerGeneratedAttribute]
public void set_IndexedPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_MappedPerSecond();
    [CompilerGeneratedAttribute]
public void set_MappedPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_ReducedPerSecond();
    [CompilerGeneratedAttribute]
public void set_ReducedPerSecond(double value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Dashboard.MountPointUsage : object {
    [CompilerGeneratedAttribute]
private string <MountPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VolumeLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FreeSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLowSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RavenSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RavenTempBuffersSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IoStatsResult <IoStatsResult>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DatabaseDiskUsage> <Items>k__BackingField;
    public string MountPoint { get; public set; }
    public string VolumeLabel { get; public set; }
    public long TotalCapacity { get; public set; }
    public long FreeSpace { get; public set; }
    public bool IsLowSpace { get; public set; }
    public long RavenSize { get; public set; }
    public long RavenTempBuffersSize { get; public set; }
    public IoStatsResult IoStatsResult { get; public set; }
    public List`1<DatabaseDiskUsage> Items { get; public set; }
    [CompilerGeneratedAttribute]
public string get_MountPoint();
    [CompilerGeneratedAttribute]
public void set_MountPoint(string value);
    [CompilerGeneratedAttribute]
public string get_VolumeLabel();
    [CompilerGeneratedAttribute]
public void set_VolumeLabel(string value);
    [CompilerGeneratedAttribute]
public long get_TotalCapacity();
    [CompilerGeneratedAttribute]
public void set_TotalCapacity(long value);
    [CompilerGeneratedAttribute]
public long get_FreeSpace();
    [CompilerGeneratedAttribute]
public void set_FreeSpace(long value);
    [CompilerGeneratedAttribute]
public bool get_IsLowSpace();
    [CompilerGeneratedAttribute]
public void set_IsLowSpace(bool value);
    [CompilerGeneratedAttribute]
public long get_RavenSize();
    [CompilerGeneratedAttribute]
public void set_RavenSize(long value);
    [CompilerGeneratedAttribute]
public long get_RavenTempBuffersSize();
    [CompilerGeneratedAttribute]
public void set_RavenTempBuffersSize(long value);
    [CompilerGeneratedAttribute]
public IoStatsResult get_IoStatsResult();
    [CompilerGeneratedAttribute]
public void set_IoStatsResult(IoStatsResult value);
    [CompilerGeneratedAttribute]
public List`1<DatabaseDiskUsage> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<DatabaseDiskUsage> value);
    private DynamicJsonValue ToJsonInternal();
    public sealed virtual DynamicJsonValue ToJson();
    public DynamicJsonValue ToJsonWithFilter(CanAccessDatabase filter);
}
public class Raven.Server.Dashboard.ThreadInfo : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CpuUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ManagedThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <UnmanagedAllocationsInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TotalProcessorTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <PrivilegedProcessorTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <UserProcessorTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ThreadState> <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ThreadPriorityLevel> <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ThreadWaitReason> <WaitReason>k__BackingField;
    public int Id { get; public set; }
    public double CpuUsage { get; public set; }
    public string Name { get; public set; }
    public Nullable`1<int> ManagedThreadId { get; public set; }
    public Nullable`1<long> UnmanagedAllocationsInBytes { get; public set; }
    public Nullable`1<DateTime> StartingTime { get; public set; }
    public double Duration { get; public set; }
    public TimeSpan TotalProcessorTime { get; public set; }
    public TimeSpan PrivilegedProcessorTime { get; public set; }
    public TimeSpan UserProcessorTime { get; public set; }
    public Nullable`1<ThreadState> State { get; public set; }
    public Nullable`1<ThreadPriorityLevel> Priority { get; public set; }
    public Nullable`1<ThreadWaitReason> WaitReason { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public double get_CpuUsage();
    [CompilerGeneratedAttribute]
public void set_CpuUsage(double value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ManagedThreadId();
    [CompilerGeneratedAttribute]
public void set_ManagedThreadId(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_UnmanagedAllocationsInBytes();
    [CompilerGeneratedAttribute]
public void set_UnmanagedAllocationsInBytes(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StartingTime();
    [CompilerGeneratedAttribute]
public void set_StartingTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public double get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TotalProcessorTime();
    [CompilerGeneratedAttribute]
public void set_TotalProcessorTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_PrivilegedProcessorTime();
    [CompilerGeneratedAttribute]
public void set_PrivilegedProcessorTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_UserProcessorTime();
    [CompilerGeneratedAttribute]
public void set_UserProcessorTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public Nullable`1<ThreadState> get_State();
    [CompilerGeneratedAttribute]
public void set_State(Nullable`1<ThreadState> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ThreadPriorityLevel> get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(Nullable`1<ThreadPriorityLevel> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ThreadWaitReason> get_WaitReason();
    [CompilerGeneratedAttribute]
public void set_WaitReason(Nullable`1<ThreadWaitReason> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Dashboard.ThreadsInfo : object {
    private Nullable`1<int> _take;
    [CompilerGeneratedAttribute]
private SortedSet`1<ThreadInfo> <List>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CpuUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ProcessCpuUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ActiveCores>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DedicatedThreadsCount>k__BackingField;
    public DateTime Date { get; }
    public SortedSet`1<ThreadInfo> List { get; }
    public double CpuUsage { get; public set; }
    public double ProcessCpuUsage { get; public set; }
    public long ActiveCores { get; public set; }
    public long ThreadsCount { get; }
    public int DedicatedThreadsCount { get; public set; }
    public ThreadsInfo(Nullable`1<int> take);
    public DateTime get_Date();
    [CompilerGeneratedAttribute]
public SortedSet`1<ThreadInfo> get_List();
    [CompilerGeneratedAttribute]
public double get_CpuUsage();
    [CompilerGeneratedAttribute]
public void set_CpuUsage(double value);
    [CompilerGeneratedAttribute]
public double get_ProcessCpuUsage();
    [CompilerGeneratedAttribute]
public void set_ProcessCpuUsage(double value);
    [CompilerGeneratedAttribute]
public long get_ActiveCores();
    [CompilerGeneratedAttribute]
public void set_ActiveCores(long value);
    public long get_ThreadsCount();
    [CompilerGeneratedAttribute]
public int get_DedicatedThreadsCount();
    [CompilerGeneratedAttribute]
public void set_DedicatedThreadsCount(int value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Dashboard.ThreadsInfoNotifications : NotificationsBase {
    public ThreadsInfoNotifications(CancellationToken shutdown);
}
public class Raven.Server.Dashboard.ThreadsInfoNotificationSender : BackgroundWorkBase {
    private ConcurrentSet`1<ConnectedWatcher> _watchers;
    private TimeSpan _notificationsThrottle;
    private ThreadsUsage _threadsUsage;
    private DateTime _lastSentNotification;
    public ThreadsInfoNotificationSender(string resourceName, ConcurrentSet`1<ConnectedWatcher> watchers, TimeSpan notificationsThrottle, CancellationToken shutdown);
    [AsyncStateMachineAttribute("Raven.Server.Dashboard.ThreadsInfoNotificationSender/<DoWork>d__5")]
protected virtual Task DoWork();
}
public class Raven.Server.Dashboard.ThreadsInfoOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <ThreadsInfoThrottle>k__BackingField;
    public TimeSpan ThreadsInfoThrottle { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_ThreadsInfoThrottle();
    [CompilerGeneratedAttribute]
public void set_ThreadsInfoThrottle(TimeSpan value);
}
public class Raven.Server.Dashboard.TrafficWatch : AbstractDashboardNotification {
    [CompilerGeneratedAttribute]
private List`1<TrafficWatchItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AverageRequestDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequestsPerSecond>k__BackingField;
    public List`1<TrafficWatchItem> Items { get; public set; }
    public double AverageRequestDuration { get; public set; }
    public int RequestsPerSecond { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TrafficWatchItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<TrafficWatchItem> value);
    [CompilerGeneratedAttribute]
public double get_AverageRequestDuration();
    [CompilerGeneratedAttribute]
public void set_AverageRequestDuration(double value);
    [CompilerGeneratedAttribute]
public int get_RequestsPerSecond();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSecond(int value);
}
public class Raven.Server.Dashboard.TrafficWatchItem : object {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequestsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AverageRequestDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocumentWritesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AttachmentWritesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CounterWritesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeSeriesWritesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DocumentsWriteBytesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AttachmentsWriteBytesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CountersWriteBytesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TimeSeriesWriteBytesPerSecond>k__BackingField;
    public string Database { get; public set; }
    public int RequestsPerSecond { get; public set; }
    public double AverageRequestDuration { get; public set; }
    public int DocumentWritesPerSecond { get; public set; }
    public int AttachmentWritesPerSecond { get; public set; }
    public int CounterWritesPerSecond { get; public set; }
    public int TimeSeriesWritesPerSecond { get; public set; }
    public double DocumentsWriteBytesPerSecond { get; public set; }
    public double AttachmentsWriteBytesPerSecond { get; public set; }
    public double CountersWriteBytesPerSecond { get; public set; }
    public double TimeSeriesWriteBytesPerSecond { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public int get_RequestsPerSecond();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSecond(int value);
    [CompilerGeneratedAttribute]
public double get_AverageRequestDuration();
    [CompilerGeneratedAttribute]
public void set_AverageRequestDuration(double value);
    [CompilerGeneratedAttribute]
public int get_DocumentWritesPerSecond();
    [CompilerGeneratedAttribute]
public void set_DocumentWritesPerSecond(int value);
    [CompilerGeneratedAttribute]
public int get_AttachmentWritesPerSecond();
    [CompilerGeneratedAttribute]
public void set_AttachmentWritesPerSecond(int value);
    [CompilerGeneratedAttribute]
public int get_CounterWritesPerSecond();
    [CompilerGeneratedAttribute]
public void set_CounterWritesPerSecond(int value);
    [CompilerGeneratedAttribute]
public int get_TimeSeriesWritesPerSecond();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesWritesPerSecond(int value);
    [CompilerGeneratedAttribute]
public double get_DocumentsWriteBytesPerSecond();
    [CompilerGeneratedAttribute]
public void set_DocumentsWriteBytesPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_AttachmentsWriteBytesPerSecond();
    [CompilerGeneratedAttribute]
public void set_AttachmentsWriteBytesPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_CountersWriteBytesPerSecond();
    [CompilerGeneratedAttribute]
public void set_CountersWriteBytesPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_TimeSeriesWriteBytesPerSecond();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesWriteBytesPerSecond(double value);
    public sealed virtual DynamicJsonValue ToJson();
}
public abstract class Raven.Server.Documents.AbstractBackgroundWorkStorage : object {
    protected DocumentDatabase Database;
    protected string MetadataPropertyName;
    private string _treeName;
    protected AbstractBackgroundWorkStorage(Transaction tx, DocumentDatabase database, string treeName, string metadataPropertyName);
    public void Put(DocumentsOperationContext context, Slice lowerId, string processDateString);
    [DoesNotReturnAttribute]
private void ThrowWrongDateFormat(Slice lowerId, string expirationDate);
    public Queue`1<DocumentExpirationInfo> GetDocuments(BackgroundWorkParameters options, Int32& totalCount, Stopwatch& duration, CancellationToken cancellationToken);
    protected abstract virtual void HandleDocumentConflict(BackgroundWorkParameters options, Slice ticksAsSlice, Slice clonedId, Queue`1<DocumentExpirationInfo> expiredDocs, Int32& totalCount);
    protected static bool ShouldHandleWorkOnCurrentNode(DatabaseTopology topology, string nodeTag);
    public static bool HasPassed(BlittableJsonReaderObject metadata, DateTime currentTime, string metadataPropertyToCheck);
    protected abstract virtual void ProcessDocument(DocumentsOperationContext context, Slice lowerId, string id, DateTime currentTime);
    public int ProcessDocuments(DocumentsOperationContext context, Queue`1<DocumentExpirationInfo> toProcess, DateTime currentTime);
}
public abstract class Raven.Server.Documents.AbstractCompareExchangeStorage : object {
    private ServerStore _serverStore;
    private string _databaseName;
    private bool _initialized;
    protected AbstractCompareExchangeStorage(ServerStore serverStore);
    public void Initialize(string databaseName);
    public IEnumerable`1<ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject>> GetCompareExchangeFromPrefix(ClusterOperationContext context, long fromIndex, long take);
    public IEnumerable`1<ValueTuple`2<CompareExchangeKey, long>> GetCompareExchangeTombstonesByKey(ClusterOperationContext context, long fromIndex, long take);
    public bool HasCompareExchangeTombstonesWithEtagGreaterThanStartAndLowerThanOrEqualToEnd(ClusterOperationContext context, long start, long end);
    public ValueTuple`2<long, BlittableJsonReaderObject> GetCompareExchangeValue(TransactionOperationContext`1<TRavenTransaction> context, string key);
    public long GetLastCompareExchangeIndex(ClusterOperationContext context);
    public long GetLastCompareExchangeTombstoneIndex(ClusterOperationContext context);
    public bool ShouldHandleChange(CompareExchangeChange change);
    public string GetCompareExchangeStorageKey(string key);
    [IteratorStateMachineAttribute("Raven.Server.Documents.AbstractCompareExchangeStorage/<GetCompareExchangeValuesStartsWith>d__13")]
public IEnumerable`1<ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject>> GetCompareExchangeValuesStartsWith(ClusterOperationContext context, string prefix, long start, long pageSize);
    [ConditionalAttribute("DEBUG")]
private void AssertInitialized();
}
public abstract class Raven.Server.Documents.AbstractDatabaseRequestHandler`1 : RequestHandler {
    public Logger Logger;
    public JsonContextPoolBase`1<TOperationContext> ContextPool;
    public string DatabaseName { get; }
    public char IdentityPartsSeparator { get; }
    public abstract virtual string get_DatabaseName();
    public abstract virtual char get_IdentityPartsSeparator();
    public abstract virtual OperationCancelToken CreateHttpRequestBoundTimeLimitedOperationToken();
    public abstract virtual OperationCancelToken CreateHttpRequestBoundTimeLimitedOperationTokenForQuery();
    public abstract virtual OperationCancelToken CreateTimeLimitedBackgroundOperationTokenForQueryOperation();
    public abstract virtual OperationCancelToken CreateTimeLimitedBackgroundOperationTokenForCollectionOperation();
    public abstract virtual OperationCancelToken CreateTimeLimitedBackgroundOperationToken();
    public abstract virtual Task WaitForIndexNotificationAsync(long index);
    public abstract virtual bool ShouldAddPagingPerformanceHint(long numberOfResults);
    public abstract virtual void AddPagingPerformanceHint(PagingOperationType operation, string action, string details, long numberOfResults, long pageSize, long duration, long totalDocumentsSizeInBytes);
}
public class Raven.Server.Documents.Attachment : object {
    public long StorageId;
    public LazyStringValue Key;
    public long Etag;
    public string ChangeVector;
    public LazyStringValue Name;
    public LazyStringValue ContentType;
    public Slice Base64Hash;
    public Stream Stream;
    public short TransactionMarker;
    public long Size;
}
public class Raven.Server.Documents.AttachmentDetailsServer : AttachmentDetails {
    public CollectionName CollectionName;
}
public class Raven.Server.Documents.AttachmentOrTombstone : object {
    public Attachment Attachment;
    public Tombstone Tombstone;
    public bool Missing { get; }
    public string ChangeVector { get; }
    public bool get_Missing();
    public string get_ChangeVector();
    public static AttachmentOrTombstone GetAttachmentOrTombstone(DocumentsOperationContext context, Slice attachmentKey);
}
public class Raven.Server.Documents.AttachmentsStorage : object {
    internal TableSchema AttachmentsSchema;
    private DocumentDatabase _documentDatabase;
    private DocumentsStorage _documentsStorage;
    public AttachmentsStorage(DocumentDatabase database, Transaction tx, TableSchema schema);
    public static long ReadLastEtag(Transaction tx);
    [IteratorStateMachineAttribute("Raven.Server.Documents.AttachmentsStorage/<GetAttachmentsFrom>d__5")]
public IEnumerable`1<ReplicationBatchItem> GetAttachmentsFrom(DocumentsOperationContext context, long etag);
    [IteratorStateMachineAttribute("Raven.Server.Documents.AttachmentsStorage/<GetAllAttachmentsStreamHashes>d__6")]
public IEnumerable`1<string> GetAllAttachmentsStreamHashes(DocumentsOperationContext context);
    public long GetCountOfAttachmentsForHash(DocumentsOperationContext context, Slice hash);
    [IteratorStateMachineAttribute("Raven.Server.Documents.AttachmentsStorage/<GetAttachmentsMetadataForDocumentWithCounts>d__8")]
internal IEnumerable`1<AttachmentNameWithCount> GetAttachmentsMetadataForDocumentWithCounts(DocumentsOperationContext context, string lowerDocumentId);
    public AttachmentDetailsServer PutAttachment(DocumentsOperationContext context, string documentId, string name, string contentType, string hash, string expectedChangeVector, Stream stream, bool updateDocument, bool extractCollectionName, bool fromSmuggler);
    public void PutDirect(DocumentsOperationContext context, Slice key, Slice name, Slice contentType, Slice base64Hash, string changeVector);
    private CollectionName GetDocumentCollectionName(DocumentsOperationContext context, TableValueReader tvr);
    private string UpdateDocumentAfterAttachmentChange(DocumentsOperationContext context, Slice lowerDocumentId, string documentId, TableValueReader tvr, string changeVector, bool extractCollectionName, CollectionName& collectionName);
    public string UpdateDocumentAfterAttachmentChange(DocumentsOperationContext context, string documentId);
    public void DeleteAttachmentBeforeRevert(DocumentsOperationContext context, LazyStringValue lowerDocId);
    public void RevisionAttachments(DocumentsOperationContext context, BlittableJsonReaderObject document, Slice lowerId, Slice changeVector);
    public void PutAttachmentRevert(DocumentsOperationContext context, LazyStringValue id, BlittableJsonReaderObject document, Boolean& hasAttachments);
    private void PutRevisionAttachment(DocumentsOperationContext context, Byte* lowerId, int lowerIdSize, Slice changeVector, AttachmentName attachment);
    public void PutAttachmentStream(DocumentsOperationContext context, Slice key, Slice base64Hash, Stream stream);
    private void DeleteAttachmentStream(DocumentsOperationContext context, Slice hash, int expectedCount);
    private bool TryGetDocumentTableValueReaderForAttachment(DocumentsOperationContext context, string documentId, string name, Slice lowerDocumentId, TableValueReader& tvr);
    [IteratorStateMachineAttribute("Raven.Server.Documents.AttachmentsStorage/<GetAttachmentsForDocument>d__21")]
public IEnumerable`1<Attachment> GetAttachmentsForDocument(DocumentsOperationContext context, Slice prefixSlice, bool includeStreams);
    [IteratorStateMachineAttribute("Raven.Server.Documents.AttachmentsStorage/<GetAttachmentsForDocument>d__22")]
public IEnumerable`1<Attachment> GetAttachmentsForDocument(DocumentsOperationContext context, AttachmentType type, LazyStringValue documentId, string changeVector);
    public DynamicJsonArray GetAttachmentsMetadataForDocument(DocumentsOperationContext context, Slice lowerDocumentId);
    public List`1<AttachmentDetails> GetAttachmentDetailsForDocument(DocumentsOperationContext context, Slice lowerDocumentId);
    public DynamicJsonArray GetAttachmentsMetadataForDocument(DocumentsOperationContext context, string docId);
    public ValueTuple`2<long, long> GetNumberOfAttachments(DocumentsOperationContext context);
    public Attachment GetAttachment(DocumentsOperationContext context, string documentId, string name, AttachmentType type, string changeVector, string hash, string contentType, bool usePartialKey);
    public bool AttachmentExists(DocumentsOperationContext context, LazyStringValue hash);
    public bool AttachmentExists(DocumentsOperationContext context, Slice base64Hash);
    private Attachment GetAttachmentDirect(DocumentsOperationContext context, string documentId, string name, AttachmentType type, string changeVector, string hash, string contentType, bool usePartialKey);
    public Attachment GetAttachmentByKey(DocumentsOperationContext context, Slice key);
    public Stream GetAttachmentStream(DocumentsOperationContext context, Slice hashSlice);
    public Stream GetAttachmentStream(DocumentsOperationContext context, Slice hashSlice, String& tag);
    public static long GetAttachmentStreamLength(DocumentsOperationContext context, Slice hashSlice);
    public InternalScope<ByteStringMemoryCache> GetAttachmentKey(DocumentsOperationContext context, Byte* lowerId, int lowerIdSize, Byte* lowerName, int lowerNameSize, Slice base64Hash, Byte* lowerContentTypePtr, int lowerContentTypeSize, AttachmentType type, Slice changeVector, Slice& keySlice);
    public InternalScope<ByteStringMemoryCache> GetAttachmentPartialKey(DocumentsOperationContext context, Byte* lowerId, int lowerIdSize, Byte* lowerName, int lowerNameSize, AttachmentType type, string changeVector, Slice& partialKeySlice);
    public ExternalScope<ByteStringMemoryCache> GetAttachmentPartialKey(DocumentsOperationContext context, Slice key, int base64HashSize, int lowerContentTypeSize, Slice& partialKeySlice);
    public InternalScope<ByteStringMemoryCache> GetAttachmentPrefix(DocumentsOperationContext context, Byte* lowerId, int lowerIdSize, AttachmentType type, Slice changeVector, Slice& prefixSlice);
    public InternalScope<ByteStringMemoryCache> GetAttachmentPrefix(DocumentsOperationContext context, Slice lowerId, AttachmentType type, Slice changeVector, Slice& prefixSlice);
    private InternalScope<ByteStringMemoryCache> GetAttachmentKeyInternal(DocumentsOperationContext context, Byte* lowerId, int lowerIdSize, Byte* lowerName, int lowerNameSize, Slice base64Hash, Byte* lowerContentTypePtr, int lowerContentTypeSize, KeyType keyType, AttachmentType type, Slice changeVector, Slice& keySlice);
    public static AttachmentType GetAttachmentTypeByKey(Slice keySlice);
    public static Attachment TableValueToAttachment(DocumentsOperationContext context, TableValueReader& tvr);
    [DoesNotReturnAttribute]
private static void ThrowMissingAttachment(ValueTuple`2<LazyStringValue, LazyStringValue> details);
    [DoesNotReturnAttribute]
private static void ThrowConcurrentException(string documentId, string name, string expectedChangeVector, string oldChangeVector);
    [DoesNotReturnAttribute]
private static void ThrowConcurrentExceptionOnMissingAttachment(string documentId, string name, string expectedChangeVector);
    public AttachmentDetailsServer CopyAttachment(DocumentsOperationContext context, string documentId, string name, string destinationId, string destinationName, LazyStringValue changeVector, AttachmentType attachmentType, bool extractCollectionName);
    public MoveAttachmentDetailsServer MoveAttachment(DocumentsOperationContext context, string sourceDocumentId, string sourceName, string destinationDocumentId, string destinationName, LazyStringValue changeVector, string hash, string contentType, bool usePartialKey, bool updateDocument, bool extractCollectionName);
    public string ResolveAttachmentName(DocumentsOperationContext context, Slice lowerId, string name);
    public void DeleteAttachment(DocumentsOperationContext context, string documentId, string name, LazyStringValue expectedChangeVector, CollectionName& collectionName, bool updateDocument, string hash, string contentType, bool usePartialKey, bool extractCollectionName);
    public void DeleteAttachmentConflicts(DocumentsOperationContext context, Slice lowerId, BlittableJsonReaderObject document, BlittableJsonReaderObject conflictDocument, string changeVector);
    private void DeleteAttachmentDirect(DocumentsOperationContext context, Slice lowerId, LazyStringValue conflictName, LazyStringValue conflictContentType, LazyStringValue conflictHash, string changeVector);
    public Tombstone GetAttachmentTombstoneByKey(DocumentsOperationContext context, Slice key);
    public void DeleteAttachmentDirect(DocumentsOperationContext context, Slice key, bool isPartialKey, string name, string expectedChangeVector, string changeVector, long lastModifiedTicks);
    private void DeleteInternal(DocumentsOperationContext context, Slice key, long etag, Slice hash, string changeVector, long lastModifiedTicks, DocumentFlags flags);
    private void DeleteTombstoneIfNeeded(DocumentsOperationContext context, Slice keySlice);
    private void CreateTombstone(DocumentsOperationContext context, Slice keySlice, long attachmentEtag, string changeVector, long lastModifiedTicks, DocumentFlags flags);
    private void DeleteAttachmentsOfDocumentInternal(DocumentsOperationContext context, Slice prefixSlice, string changeVector, long lastModifiedTicks, DocumentFlags flags);
    public void DeleteRevisionAttachments(DocumentsOperationContext context, Document revision, ChangeVector changeVector, long lastModifiedTicks, DocumentFlags flags);
    public void DeleteAttachmentsOfDocument(DocumentsOperationContext context, Slice lowerId, string changeVector, long lastModifiedTicks, DocumentFlags flags);
    public StreamsTempFile GetTempFile(string prefix);
    public static ValueTuple`2<LazyStringValue, LazyStringValue> GetDocIdAndAttachmentName(JsonOperationContext context, LazyStringValue attachmentKey);
    public static ValueTuple`2<string, string> ExtractDocIdAndAttachmentNameFromTombstone(Slice attachmentTombstoneId);
    public static int GetSizeOfDocId(ReadOnlySpan`1<byte> key);
    private static void ExtractDocIdAndAttachmentNameFromTombstone(Byte* p, int size, Int32& sizeOfDocId, Int32& attachmentNameIndex, Int32& sizeOfAttachmentName);
    [IteratorStateMachineAttribute("Raven.Server.Documents.AttachmentsStorage/<GetAttachmentsFromDocumentMetadata>d__66")]
public static IEnumerable`1<BlittableJsonReaderObject> GetAttachmentsFromDocumentMetadata(BlittableJsonReaderObject document);
    public void RemoveAttachmentStreamsWithoutReferences(DocumentsOperationContext context, List`1<Slice> attachmentHashesToMaybeDelete);
    [IteratorStateMachineAttribute("Raven.Server.Documents.AttachmentsStorage/<GetAttachmentsByBucketFrom>d__68")]
public IEnumerable`1<AttachmentReplicationItem> GetAttachmentsByBucketFrom(DocumentsOperationContext context, int bucket, long etag);
    [StorageIndexEntryKeyGeneratorAttribute]
internal static Scope<ByteStringMemoryCache> GenerateBucketAndEtagIndexKeyForAttachments(Transaction tx, TableValueReader& tvr, Slice& slice);
    [StorageIndexEntryKeyGeneratorAttribute]
internal static Scope<ByteStringMemoryCache> GenerateBucketAndHashForAttachments(Transaction tx, TableValueReader& tvr, Slice& slice);
    private static Scope<ByteStringMemoryCache> GenerateBucketAndHash(Transaction tx, int keyIndex, int hashIndex, TableValueReader& tvr, Slice& slice);
    private static int GetBucketFromAttachmentKey(int keyIndex, TableValueReader tvr, ShardedDocumentDatabase database);
    public ValueTuple`2<long, int> GetStreamInfoForBucket(Transaction tx, int bucket);
    internal static void UpdateBucketStatsForAttachments(Transaction tx, Slice key, TableValueReader& oldValue, TableValueReader& newValue);
    [CompilerGeneratedAttribute]
internal static void <PutAttachment>g__SetTableValue|9_0(TableValueBuilder tvb, Slice cv, <>c__DisplayClass9_0& , <>c__DisplayClass9_1& , <>c__DisplayClass9_2& , <>c__DisplayClass9_3& , <>c__DisplayClass9_4& );
}
public static class Raven.Server.Documents.AttachmentsStorageHelper : object {
    [AsyncStateMachineAttribute("Raven.Server.Documents.AttachmentsStorageHelper/<CopyStreamToFileAndCalculateHash>d__0")]
public static Task`1<string> CopyStreamToFileAndCalculateHash(JsonOperationContext context, Stream requestStream, Stream file, CancellationToken cancellationToken);
    private static void InitComputeHash(MemoryBuffer cryptoState);
    private static string FinalizeGetHash(MemoryBuffer cryptoState, MemoryBuffer buffer);
    private static void PartialComputeHash(MemoryBuffer cryptoState, MemoryBuffer buffer, int bufferRead);
}
public class Raven.Server.Documents.BackgroundWorkParameters : object {
    public DocumentsOperationContext Context;
    public DateTime CurrentTime;
    public DatabaseTopology DatabaseTopology;
    public string NodeTag;
    public long AmountToTake;
    public long MaxItemsToProcess;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public BackgroundWorkParameters(DocumentsOperationContext Context, DateTime CurrentTime, DatabaseTopology DatabaseTopology, string NodeTag, long AmountToTake, long MaxItemsToProcess);
    [CompilerGeneratedAttribute]
protected BackgroundWorkParameters(BackgroundWorkParameters original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(BackgroundWorkParameters left, BackgroundWorkParameters right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(BackgroundWorkParameters left, BackgroundWorkParameters right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(BackgroundWorkParameters other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual BackgroundWorkParameters <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(DocumentsOperationContext& Context, DateTime& CurrentTime, DatabaseTopology& DatabaseTopology, String& NodeTag, Int64& AmountToTake, Int64& MaxItemsToProcess);
}
public class Raven.Server.Documents.BlittableMetadataModifier : object {
    private bool _disposed;
    private bool _readingMetadataObject;
    private int _depth;
    private State _state;
    private bool _verifyStartArray;
    public LazyStringValue Id;
    public string ChangeVector;
    public DocumentFlags Flags;
    public NonPersistentDocumentFlags NonPersistentFlags;
    public Nullable`1<DateTime> LastModified;
    public bool ReadFirstEtagOfLegacyRevision;
    public bool ReadLegacyEtag;
    public DatabaseItemType OperateOnTypes;
    [CompilerGeneratedAttribute]
private string <LegacyEtag>k__BackingField;
    public string FirstEtagOfLegacyRevision;
    public long LegacyRevisionsCount;
    public bool SeenCounters;
    public bool SeenAttachments;
    public bool SeenTimeSeries;
    private JsonOperationContext _ctx;
    private LazyStringValue _metadataCollections;
    private LazyStringValue _metadataExpires;
    private FastList`1<AllocatedMemoryData> _allocations;
    private static string LegacyLastModified;
    private static string LegacyRevisionState;
    private static string LegacyHasRevisionsDocumentState;
    public string LegacyEtag { get; private set; }
    public BlittableMetadataModifier(JsonOperationContext context);
    public BlittableMetadataModifier(JsonOperationContext context, bool legacyImport, bool readLegacyEtag, DatabaseItemType operateOnTypes);
    [CompilerGeneratedAttribute]
public string get_LegacyEtag();
    [CompilerGeneratedAttribute]
private void set_LegacyEtag(string value);
    private DocumentFlags ReadFlags(JsonParserState state);
    private DateTime ReadDateTime(JsonParserState jsonParserState, IJsonParser reader, State state);
    private LazyStringValue CreateLazyStringValueFromParserState(JsonParserState state);
    public sealed virtual void StartObject();
    public sealed virtual void EndObject();
    public sealed virtual bool AboutToReadPropertyName(IJsonParser reader, JsonParserState state);
    private bool AboutToReadPropertyNameInternal(UnmanagedJsonParser reader, JsonParserState state);
    private bool AboutToReadPropertyNameInternal(ObjectJsonParser reader, JsonParserState state);
    private bool AboutToReadPropertyNameInternal(IJsonParser reader, JsonParserState state);
    private bool AboutToReadPropertyNameInMetadataUnlikely(IJsonParser reader, JsonParserState state, Boolean& aboutToReadPropertyName);
    private bool AboutToReadWithStateUnlikely(IJsonParser reader, JsonParserState state);
    [DoesNotReturnAttribute]
private void ThrowInvalidMetadataProperty(JsonParserState state, IJsonParser reader);
    [DoesNotReturnAttribute]
private void ThrowExpectedFieldTypeOfString(string field, JsonParserState state, IJsonParser reader);
    [DoesNotReturnAttribute]
private void ThrowInvalidLastModifiedProperty(State state, LazyStringValue str, IJsonParser reader);
    [DoesNotReturnAttribute]
private void ThrowInvalidEtagType(JsonParserState state, IJsonParser reader);
    [DoesNotReturnAttribute]
private void ThrowInvalidReplicationHistoryType(JsonParserState state, IJsonParser reader);
    [DoesNotReturnAttribute]
private void ThrowInvalidArrayType(JsonParserState state, IJsonParser reader);
    public sealed virtual void Dispose();
    public sealed virtual void Reset(JsonOperationContext ctx);
    [ConditionalAttribute("DEBUG")]
private void AssertNotDisposed();
}
internal class Raven.Server.Documents.BucketStats : ValueType {
    public long Size;
    public long NumberOfDocuments;
    public long LastModifiedTicks;
    public static string GetMergedChangeVector(ValueReader reader);
}
public class Raven.Server.Documents.CatastrophicFailureHandler : object {
    internal TimeSpan TimeToWaitBeforeUnloadingDatabase;
    internal int MaxDatabaseUnloads;
    internal TimeSpan NoFailurePeriod;
    private ConcurrentDictionary`2<Guid, FailureStats> _errorsPerEnvironment;
    private DatabasesLandlord _databasesLandlord;
    private ServerStore _serverStore;
    private Logger _logger;
    public CatastrophicFailureHandler(DatabasesLandlord databasesLandlord, ServerStore serverStore);
    public bool TryGetStats(Guid environmentId, FailureStats& stats);
    public void Execute(string databaseName, Exception e, Guid environmentId, string path, string stacktrace);
}
public abstract class Raven.Server.Documents.Changes.AbstractChangesClientConnection`1 : object {
    private WebSocket _webSocket;
    private AsyncQueue`1<SendQueueItem<TOperationContext>> _sendQueue;
    private MultipleUseFlag _lowMemoryFlag;
    private CancellationTokenSource _cts;
    private DateTime _startedAt;
    private object _skippedMessage;
    private DateTime _lastSendMessage;
    protected JsonContextPoolBase`1<TOperationContext> ContextPool;
    private bool _throttleConnection;
    private ConcurrentSet`1<long> _matchingOperations;
    private int _watchAllOperations;
    private bool _watchTopology;
    public long Id;
    [CompilerGeneratedAttribute]
private bool <IsChangesConnectionOriginatedFromStudio>k__BackingField;
    private SingleUseFlag _isDisposed;
    public CancellationToken DisposeToken { get; }
    public TimeSpan Age { get; }
    public bool IsChangesConnectionOriginatedFromStudio { get; }
    public bool IsDisposed { get; }
    protected AbstractChangesClientConnection`1(WebSocket webSocket, JsonContextPoolBase`1<TOperationContext> contextPool, CancellationToken databaseShutdown, bool throttleConnection, bool fromStudio);
    public CancellationToken get_DisposeToken();
    public TimeSpan get_Age();
    private ValueTask WatchTopologyAsync();
    protected abstract virtual ValueTask WatchDocumentAsync(string docId, CancellationToken token);
    protected abstract virtual ValueTask UnwatchDocumentAsync(string docId, CancellationToken token);
    protected abstract virtual ValueTask WatchAllDocumentsAsync(CancellationToken token);
    protected abstract virtual ValueTask UnwatchAllDocumentsAsync(CancellationToken token);
    protected abstract virtual ValueTask WatchCounterAsync(string name, CancellationToken token);
    protected abstract virtual ValueTask UnwatchCounterAsync(string name, CancellationToken token);
    protected abstract virtual ValueTask WatchDocumentCountersAsync(string docId, CancellationToken token);
    protected abstract virtual ValueTask UnwatchDocumentCountersAsync(string docId, CancellationToken token);
    protected abstract virtual ValueTask WatchDocumentCounterAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    protected abstract virtual ValueTask UnwatchDocumentCounterAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    protected abstract virtual ValueTask WatchAllCountersAsync(CancellationToken token);
    protected abstract virtual ValueTask UnwatchAllCountersAsync(CancellationToken token);
    protected abstract virtual ValueTask WatchTimeSeriesAsync(string name, CancellationToken token);
    protected abstract virtual ValueTask UnwatchTimeSeriesAsync(string name, CancellationToken token);
    protected abstract virtual ValueTask WatchAllDocumentTimeSeriesAsync(string docId, CancellationToken token);
    protected abstract virtual ValueTask UnwatchAllDocumentTimeSeriesAsync(string docId, CancellationToken token);
    protected abstract virtual ValueTask WatchDocumentTimeSeriesAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    protected abstract virtual ValueTask UnwatchDocumentTimeSeriesAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    protected abstract virtual ValueTask WatchAllTimeSeriesAsync(CancellationToken token);
    protected abstract virtual ValueTask UnwatchAllTimeSeriesAsync(CancellationToken token);
    protected abstract virtual ValueTask WatchDocumentPrefixAsync(string name, CancellationToken token);
    protected abstract virtual ValueTask UnwatchDocumentPrefixAsync(string name, CancellationToken token);
    protected abstract virtual ValueTask WatchDocumentInCollectionAsync(string name, CancellationToken token);
    protected abstract virtual ValueTask UnwatchDocumentInCollectionAsync(string name, CancellationToken token);
    protected abstract virtual ValueTask WatchAllIndexesAsync(CancellationToken token);
    protected abstract virtual ValueTask UnwatchAllIndexesAsync(CancellationToken token);
    protected abstract virtual ValueTask WatchIndexAsync(string name, CancellationToken token);
    protected abstract virtual ValueTask UnwatchIndexAsync(string name, CancellationToken token);
    protected abstract virtual ValueTask WatchAggressiveCachingAsync(CancellationToken token);
    protected abstract virtual ValueTask UnwatchAggressiveCachingAsync(CancellationToken token);
    private ValueTask WatchOperationAsync(long operationId);
    private ValueTask UnwatchOperationAsync(long operationId);
    private ValueTask WatchAllOperationsAsync();
    private ValueTask UnwatchAllOperationsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Changes.AbstractChangesClientConnection`1/<StartSendingNotificationsAsync>d__53")]
public Task StartSendingNotificationsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Changes.AbstractChangesClientConnection`1/<WaitForSendTaskAsync>d__54")]
private Task WaitForSendTaskAsync(Task sendTask, Stopwatch sp, int messagesCount, MemoryStream ms);
    protected virtual Message<TOperationContext> CreateMessage(object message);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Changes.AbstractChangesClientConnection`1/<GetNextMessage>d__56")]
private ValueTask`1<Message<TOperationContext>> GetNextMessage();
    [CompilerGeneratedAttribute]
public bool get_IsChangesConnectionOriginatedFromStudio();
    public bool get_IsDisposed();
    public virtual void Dispose();
    public void Confirm(int commandId);
    public void SendSupportedFeatures();
    protected void AddToQueue(SendQueueItem<TOperationContext> item, bool addIfEmpty);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Changes.AbstractChangesClientConnection`1/<HandleCommandAsync>d__67")]
public ValueTask HandleCommandAsync(string command, string commandParameter, BlittableJsonReaderArray commandParameters, CancellationToken token);
    public void SendOperationStatusChangeNotification(OperationStatusChange change);
    public void SendTopologyChanges(TopologyChange change);
    private void Send(OperationStatusChange change);
    private void Send(TopologyChange change);
    private static bool Match(string x, string y);
    public virtual DynamicJsonValue GetDebugInfo();
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    protected static DynamicJsonValue CreateValueToSend(string type, DynamicJsonValue value);
    protected static DocumentIdAndNamePair<TOperationContext> GetParameters(BlittableJsonReaderArray parameters);
}
public class Raven.Server.Documents.Changes.ChangesClientConnection : AbstractChangesClientConnection`1<DocumentsOperationContext> {
    private ConcurrentSet`1<string> _matchingDocuments;
    private ConcurrentSet`1<string> _matchingIndexes;
    private ConcurrentSet`1<string> _matchingDocumentPrefixes;
    private ConcurrentSet`1<string> _matchingDocumentsInCollection;
    private ConcurrentSet`1<string> _matchingCounters;
    private ConcurrentSet`1<string> _matchingDocumentCounters;
    private ConcurrentSet`1<DocumentIdAndNamePair<DocumentsOperationContext>> _matchingDocumentCounter;
    private ConcurrentSet`1<string> _matchingTimeSeries;
    private ConcurrentSet`1<string> _matchingAllDocumentTimeSeries;
    private ConcurrentSet`1<DocumentIdAndNamePair<DocumentsOperationContext>> _matchingDocumentTimeSeries;
    private int _watchAllDocuments;
    private int _watchAllIndexes;
    private int _watchAllCounters;
    private int _watchAllTimeSeries;
    private bool _aggressiveChanges;
    internal static SendQueueItem<DocumentsOperationContext> AggressiveCachingPulseValue;
    public ChangesClientConnection(WebSocket webSocket, DocumentDatabase database, bool throttleConnection, bool fromStudio);
    private static ChangesClientConnection();
    public void SendCounterChanges(CounterChange change);
    public void SendTimeSeriesChanges(TimeSeriesChange change);
    public void SendDocumentChanges(DocumentChange change);
    public void SendIndexChanges(IndexChange change);
    private void PulseAggressiveCaching();
    private void Send(CounterChange change);
    private void Send(TimeSeriesChange change);
    private void Send(DocumentChange change);
    private void Send(IndexChange change);
    private static bool HasItemStartingWith(ConcurrentSet`1<string> set, string value);
    private static bool HasItemEqualsTo(ConcurrentSet`1<string> set, string value);
    protected virtual ValueTask WatchDocumentAsync(string docId, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentAsync(string docId, CancellationToken token);
    protected virtual ValueTask WatchAllDocumentsAsync(CancellationToken token);
    protected virtual ValueTask UnwatchAllDocumentsAsync(CancellationToken token);
    protected virtual ValueTask WatchCounterAsync(string name, CancellationToken token);
    protected virtual ValueTask UnwatchCounterAsync(string name, CancellationToken token);
    protected virtual ValueTask WatchDocumentCountersAsync(string docId, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentCountersAsync(string docId, CancellationToken token);
    protected virtual ValueTask WatchDocumentCounterAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentCounterAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    protected virtual ValueTask WatchAllCountersAsync(CancellationToken token);
    protected virtual ValueTask UnwatchAllCountersAsync(CancellationToken token);
    protected virtual ValueTask WatchTimeSeriesAsync(string name, CancellationToken token);
    protected virtual ValueTask UnwatchTimeSeriesAsync(string name, CancellationToken token);
    protected virtual ValueTask WatchAllDocumentTimeSeriesAsync(string docId, CancellationToken token);
    protected virtual ValueTask UnwatchAllDocumentTimeSeriesAsync(string docId, CancellationToken token);
    protected virtual ValueTask WatchDocumentTimeSeriesAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentTimeSeriesAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    protected virtual ValueTask WatchAllTimeSeriesAsync(CancellationToken token);
    protected virtual ValueTask UnwatchAllTimeSeriesAsync(CancellationToken token);
    protected virtual ValueTask WatchDocumentPrefixAsync(string name, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentPrefixAsync(string name, CancellationToken token);
    protected virtual ValueTask WatchDocumentInCollectionAsync(string name, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentInCollectionAsync(string name, CancellationToken token);
    protected virtual ValueTask WatchAllIndexesAsync(CancellationToken token);
    protected virtual ValueTask UnwatchAllIndexesAsync(CancellationToken token);
    protected virtual ValueTask WatchIndexAsync(string name, CancellationToken token);
    protected virtual ValueTask UnwatchIndexAsync(string name, CancellationToken token);
    protected virtual ValueTask WatchAggressiveCachingAsync(CancellationToken token);
    protected virtual ValueTask UnwatchAggressiveCachingAsync(CancellationToken token);
    public virtual DynamicJsonValue GetDebugInfo();
}
public static class Raven.Server.Documents.Changes.ChangesClientConnectionId : object {
    private static long Counter;
    public static long GetNextId();
}
public class Raven.Server.Documents.Changes.DocumentsChanges : DocumentsChangesBase`2<ChangesClientConnection, DocumentsOperationContext> {
    [CompilerGeneratedAttribute]
private Action`1<DocumentChange> OnDocumentChange;
    [CompilerGeneratedAttribute]
private Action`1<CounterChange> OnCounterChange;
    [CompilerGeneratedAttribute]
private Action`1<TimeSeriesChange> OnTimeSeriesChange;
    [CompilerGeneratedAttribute]
private Action`1<IndexChange> OnIndexChange;
    [CompilerGeneratedAttribute]
public void add_OnDocumentChange(Action`1<DocumentChange> value);
    [CompilerGeneratedAttribute]
public void remove_OnDocumentChange(Action`1<DocumentChange> value);
    [CompilerGeneratedAttribute]
public void add_OnCounterChange(Action`1<CounterChange> value);
    [CompilerGeneratedAttribute]
public void remove_OnCounterChange(Action`1<CounterChange> value);
    [CompilerGeneratedAttribute]
public void add_OnTimeSeriesChange(Action`1<TimeSeriesChange> value);
    [CompilerGeneratedAttribute]
public void remove_OnTimeSeriesChange(Action`1<TimeSeriesChange> value);
    [CompilerGeneratedAttribute]
public void add_OnIndexChange(Action`1<IndexChange> value);
    [CompilerGeneratedAttribute]
public void remove_OnIndexChange(Action`1<IndexChange> value);
    public void RaiseNotifications(IndexChange indexChange);
    public void RaiseNotifications(DocumentChange documentChange);
    public void RaiseNotifications(CounterChange counterChange);
    public void RaiseNotifications(TimeSeriesChange timeSeriesChange);
}
public abstract class Raven.Server.Documents.Changes.DocumentsChangesBase`2 : object {
    public ConcurrentDictionary`2<long, TChangesClientConnection> Connections;
    [CompilerGeneratedAttribute]
private Action`1<OperationStatusChange> OnOperationStatusChange;
    [CompilerGeneratedAttribute]
private Action`1<TopologyChange> OnTopologyChange;
    [CompilerGeneratedAttribute]
public void add_OnOperationStatusChange(Action`1<OperationStatusChange> value);
    [CompilerGeneratedAttribute]
public void remove_OnOperationStatusChange(Action`1<OperationStatusChange> value);
    [CompilerGeneratedAttribute]
public void add_OnTopologyChange(Action`1<TopologyChange> value);
    [CompilerGeneratedAttribute]
public void remove_OnTopologyChange(Action`1<TopologyChange> value);
    public void Connect(TChangesClientConnection connection);
    public void Disconnect(long id);
    public sealed virtual void RaiseNotifications(TopologyChange topologyChange);
    public sealed virtual void RaiseNotifications(OperationStatusChange operationStatusChange);
}
public interface Raven.Server.Documents.Changes.IDocumentsChanges {
    public abstract virtual void RaiseNotifications(TopologyChange topologyChange);
    public abstract virtual void RaiseNotifications(OperationStatusChange operationStatusChange);
}
public class Raven.Server.Documents.CollectionName : object {
    public static string HiLoCollection;
    public static StringSegment EmptyCollectionSegment;
    public static StringSegment MetadataKeySegment;
    public static StringSegment MetadataCollectionSegment;
    private string _documents;
    private string _tombstones;
    public string Name;
    private string _revisions;
    private string _counters;
    private string _counterGroups;
    private string _counterTombstones;
    private string _timeseries;
    private string _deletedRanges;
    private string _timeSeriesStats;
    private Nullable`1<bool> _isHiLo;
    public bool IsHiLo { get; }
    private static CollectionName();
    public CollectionName(string name);
    public bool get_IsHiLo();
    public string GetTableName(CollectionTableType type);
    public virtual string ToString();
    private bool Equals(CollectionName other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CollectionName left, CollectionName right);
    public static bool op_Inequality(CollectionName left, CollectionName right);
    public static bool IsHiLoCollection(string name);
    public static bool IsHiLoCollection(LazyStringValue name);
    public static bool IsHiLoCollection(Byte* buffer, int length);
    public static string GetCollectionName(DynamicBlittableJson document);
    public static string GetCollectionName(BlittableJsonReaderObject document);
    public static string GetTablePrefix(CollectionTableType type);
    private string GetName(CollectionTableType type);
}
public class Raven.Server.Documents.CollectionNameComparer : object {
    public static CollectionNameComparer Instance;
    private static CollectionNameComparer();
    public sealed virtual bool Equals(CollectionName x, CollectionName y);
    public sealed virtual int GetHashCode(CollectionName obj);
}
internal class Raven.Server.Documents.CollectionRunner : object {
    internal static int OperationBatchSize;
    private IndexQueryServerSide _collectionQuery;
    private IndexQueryServerSide _operationQuery;
    protected DocumentsOperationContext Context;
    protected DocumentDatabase Database;
    public CollectionRunner(DocumentDatabase database, DocumentsOperationContext context, IndexQueryServerSide collectionQuery);
    public virtual Task`1<IOperationResult> ExecuteDelete(string collectionName, long start, long take, CollectionOperationOptions options, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    public Task`1<IOperationResult> ExecutePatch(string collectionName, long start, long take, CollectionOperationOptions options, PatchRequest patch, BlittableJsonReaderObject patchArgs, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.CollectionRunner/<ExecuteOperation>d__8")]
protected Task`1<IOperationResult> ExecuteOperation(string collectionName, long start, long take, CollectionOperationOptions options, DocumentsOperationContext context, Action`1<DeterminateProgress> onProgress, Func`2<string, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> action, OperationCancelToken token);
    protected IEnumerable`1<Document> GetDocuments(DocumentsOperationContext context, string collectionName, long startEtag, string startAfterId, Reference`1<long> alreadySeenIdsCount, int batchSize, bool isAllDocs, DocumentFields fields, Boolean& isStartsWithOrIdQuery, CancellationToken token);
    protected long GetTotalCountForCollection(DocumentsOperationContext context, string collectionName, bool isAllDocs);
    protected long GetLastEtagForCollection(DocumentsOperationContext context, string collection, bool isAllDocs);
    private static IndexQueryServerSide ConvertToOperationQuery(IndexQueryServerSide query, int pageSize);
    [CompilerGeneratedAttribute]
private MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> <ExecuteDelete>b__6_0(string key);
}
public enum Raven.Server.Documents.CollectionTableType : Enum {
    public int value__;
    public static CollectionTableType Documents;
    public static CollectionTableType Tombstones;
    public static CollectionTableType Revisions;
    [ObsoleteAttribute("For migration purposes only from versions where Counters were experimental feature (prior to 4.2)")]
public static CollectionTableType Counters;
    public static CollectionTableType CounterGroups;
    public static CollectionTableType CounterTombstones;
    public static CollectionTableType TimeSeries;
    public static CollectionTableType TimeSeriesDeletedRanges;
    public static CollectionTableType TimeSeriesStats;
}
internal class Raven.Server.Documents.Commands.Attachments.GetAttachmentHashCountCommand : RavenCommand`1<Response> {
    private string _hash;
    public bool IsReadRequest { get; }
    public GetAttachmentHashCountCommand(string hash);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Server.Documents.Commands.Attachments.GetAttachmentMetadataWithCountsCommand : RavenCommand`1<Response> {
    private string _documentId;
    public bool IsReadRequest { get; }
    public GetAttachmentMetadataWithCountsCommand(string documentId);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Server.Documents.Commands.DocumentsCompression.GetDocumentsCompressionConfigurationOperation : object {
    public sealed virtual RavenCommand`1<DocumentsCompressionConfiguration> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
internal class Raven.Server.Documents.Commands.ETL.ElasticSearchEtlTestCommand : RavenCommand {
    private DocumentConventions _conventions;
    private BlittableJsonReaderObject _testScript;
    public bool IsReadRequest { get; }
    public ElasticSearchEtlTestCommand(DocumentConventions conventions, BlittableJsonReaderObject testScript);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Server.Documents.Commands.ETL.GetEtlTaskDebugStatsCommand : RavenCommand`1<EtlTaskDebugStats[]> {
    private String[] _names;
    public bool IsReadRequest { get; }
    public GetEtlTaskDebugStatsCommand(String[] names, string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Server.Documents.Commands.ETL.GetEtlTaskPerformanceStatsCommand : RavenCommand`1<EtlTaskPerformanceStats[]> {
    private String[] _names;
    public bool IsReadRequest { get; }
    public GetEtlTaskPerformanceStatsCommand(String[] names, string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Server.Documents.Commands.ETL.GetEtlTaskProgressCommand : RavenCommand`1<EtlTaskProgress[]> {
    private String[] _names;
    public bool IsReadRequest { get; }
    public GetEtlTaskProgressCommand(String[] names, string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Server.Documents.Commands.ETL.GetEtlTaskStatsCommand : RavenCommand`1<EtlTaskStats[]> {
    private String[] _names;
    public bool IsReadRequest { get; }
    public GetEtlTaskStatsCommand(String[] names, string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Server.Documents.Commands.ETL.OlapEtlTestCommand : RavenCommand {
    private DocumentConventions _conventions;
    private BlittableJsonReaderObject _testScript;
    public bool IsReadRequest { get; }
    public OlapEtlTestCommand(DocumentConventions conventions, BlittableJsonReaderObject testScript);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
public class Raven.Server.Documents.Commands.ETL.QueueEtlTestCommand : RavenCommand {
    private DocumentConventions _conventions;
    private BlittableJsonReaderObject _testScript;
    public bool IsReadRequest { get; }
    public QueueEtlTestCommand(DocumentConventions conventions, BlittableJsonReaderObject testScript);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Server.Documents.Commands.ETL.RavenEtlTestCommand : RavenCommand {
    private DocumentConventions _conventions;
    private BlittableJsonReaderObject _testConfig;
    public bool IsReadRequest { get; }
    public RavenEtlTestCommand(DocumentConventions conventions, BlittableJsonReaderObject testConfig);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Server.Documents.Commands.ETL.SqlEtlTestCommand : RavenCommand {
    private DocumentConventions _conventions;
    private BlittableJsonReaderObject _testScript;
    public bool IsReadRequest { get; }
    public SqlEtlTestCommand(DocumentConventions conventions, BlittableJsonReaderObject testScript);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Server.Documents.Commands.Expiration.GetDocumentsExpirationConfigurationOperation : object {
    public sealed virtual RavenCommand`1<ExpirationConfiguration> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Server.Documents.Commands.GenerateClassFromDocumentCommand : RavenCommand`1<string> {
    private string _id;
    private string _lang;
    public bool IsReadRequest { get; }
    public GenerateClassFromDocumentCommand(string id, string lang);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponseRaw(HttpResponseMessage response, Stream stream, JsonOperationContext context);
}
public class Raven.Server.Documents.Commands.Indexes.GenerateCSharpIndexDefinitionCommand : RavenCommand`1<string> {
    private string _indexName;
    public bool IsReadRequest { get; }
    public GenerateCSharpIndexDefinitionCommand(string indexName, string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponseRaw(HttpResponseMessage response, Stream stream, JsonOperationContext context);
}
public class Raven.Server.Documents.Commands.Indexes.GetIndexDebugCommand : RavenCommand {
    private string _indexName;
    private string _op;
    private String[] _docIds;
    private string _startsWith;
    private Nullable`1<int> _start;
    private Nullable`1<int> _pageSize;
    public GetIndexDebugCommand(string indexName, string op, String[] docIds, string startsWith, Nullable`1<int> start, Nullable`1<int> pageSize, string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public static GetIndexDebugCommand GetMapReduceTree(string indexName, String[] docIds, string nodeTag);
    public static GetIndexDebugCommand GetSourceDocIds(string indexName, string startsWith, int start, int pageSize, string nodeTag);
    public static GetIndexDebugCommand GetEntriesFields(string indexName, string nodeTag);
}
internal class Raven.Server.Documents.Commands.Indexes.GetIndexErrorsCountCommand : RavenCommand`1<IndexErrorsCount[]> {
    private String[] _indexNames;
    public bool IsReadRequest { get; }
    internal GetIndexErrorsCountCommand(String[] indexNames, string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Server.Documents.Commands.Indexes.GetIndexesProgressCommand : RavenCommand`1<IndexProgress[]> {
    public bool IsReadRequest { get; }
    public GetIndexesProgressCommand(string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
internal class Raven.Server.Documents.Commands.Indexes.GetIndexesTotalTimeCommand : RavenCommand`1<IndexTotalTime[]> {
    private String[] _indexNames;
    public bool IsReadRequest { get; }
    public GetIndexesTotalTimeCommand(String[] indexNames, string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Server.Documents.Commands.Indexes.GetIndexStalenessCommand : RavenCommand`1<IndexStaleness> {
    private string _indexName;
    public bool IsReadRequest { get; }
    public GetIndexStalenessCommand(string indexName, string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Server.Documents.Commands.Indexes.OpenFaultyIndexCommand : RavenCommand {
    private string _indexName;
    public bool IsReadRequest { get; }
    public OpenFaultyIndexCommand(string indexName, string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual bool get_IsReadRequest();
}
public class Raven.Server.Documents.Commands.Indexes.ReplaceIndexCommand : RavenCommand {
    private string _indexName;
    public ReplaceIndexCommand(string indexName, string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Server.Documents.Commands.Indexes.TestIndexCommand : RavenCommand`1<BlittableJsonReaderObject> {
    private TestIndexParameters _parameters;
    private DocumentConventions _documentConventions;
    public bool IsReadRequest { get; }
    public TestIndexCommand(DocumentConventions documentConventions, string nodeTag, TestIndexParameters parameters);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Server.Documents.Commands.OngoingTasks.GetOngoingTasksCommand : RavenCommand`1<OngoingTasksResult> {
    public bool IsReadRequest { get; }
    public GetOngoingTasksCommand(string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual bool get_IsReadRequest();
}
internal class Raven.Server.Documents.Commands.OngoingTasks.GetPeriodicBackupTimersCommand : RavenCommand`1<PeriodicBackupTimersResponse> {
    public bool IsReadRequest { get; }
    public GetPeriodicBackupTimersCommand(string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Server.Documents.Commands.Queries.PatchByQueryTestCommand : RavenCommand`1<Response> {
    private DocumentConventions _conventions;
    private string _id;
    private IndexQueryServerSide _query;
    public bool IsReadRequest { get; }
    public PatchByQueryTestCommand(DocumentConventions conventions, string id, IndexQueryServerSide query);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Server.Documents.Commands.Replication.GetConflictsOperation : object {
    private long _start;
    private Nullable`1<int> _pageSize;
    private string _token;
    public GetConflictsOperation(long start);
    public GetConflictsOperation(long start, int pageSize);
    public GetConflictsOperation(string continuationToken);
    public sealed virtual RavenCommand`1<GetConflictsPreviewResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
internal class Raven.Server.Documents.Commands.Replication.GetIncomingReplicationRejectionInfoCommand : RavenCommand`1<ReplicationIncomingRejectionInfoPreview> {
    public bool IsReadRequest { get; }
    public GetIncomingReplicationRejectionInfoCommand(string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
internal class Raven.Server.Documents.Commands.Replication.GetReplicationActiveConnectionsInfoCommand : RavenCommand`1<ReplicationActiveConnectionsPreview> {
    public bool IsReadRequest { get; }
    public GetReplicationActiveConnectionsInfoCommand(string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
internal class Raven.Server.Documents.Commands.Replication.GetReplicationIncomingActivityTimesInfoCommand : RavenCommand`1<ReplicationIncomingLastActivityTimePreview> {
    public bool IsReadRequest { get; }
    public GetReplicationIncomingActivityTimesInfoCommand(string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
internal class Raven.Server.Documents.Commands.Replication.GetReplicationOutgoingReconnectionQueueCommand : RavenCommand`1<ReplicationOutgoingReconnectionQueuePreview> {
    public bool IsReadRequest { get; }
    public GetReplicationOutgoingReconnectionQueueCommand(string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
internal class Raven.Server.Documents.Commands.Replication.GetReplicationOutgoingsFailureInfoCommand : RavenCommand`1<ReplicationOutgoingsFailurePreview> {
    public bool IsReadRequest { get; }
    public GetReplicationOutgoingsFailureInfoCommand(string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Commands.Replication.GetReplicationOutgoingsFailureInfoCommand/<ProcessResponse>d__3")]
public virtual Task`1<ResponseDisposeHandling> ProcessResponse(JsonOperationContext context, HttpCache cache, HttpResponseMessage response, string url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Server.Documents.Commands.Revisions.GetResolvedRevisionsCommand : RavenCommand`1<ResolvedRevisions> {
    private Nullable`1<DateTime> _since;
    private Nullable`1<int> _take;
    public bool IsReadRequest { get; }
    public GetResolvedRevisionsCommand(Nullable`1<DateTime> since, Nullable`1<int> take);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Server.Documents.Commands.Revisions.GetRevisionsDebugCommand : RavenCommand`1<BlittableJsonReaderObject> {
    private Nullable`1<long> _start;
    private Nullable`1<int> _pageSize;
    public bool IsReadRequest { get; }
    public GetRevisionsDebugCommand(string nodeTag, Nullable`1<long> start, Nullable`1<int> pageSize);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Server.Documents.Commands.Revisions.ResolvedRevisions : object {
    [CompilerGeneratedAttribute]
private BlittableJsonReaderArray <Results>k__BackingField;
    public BlittableJsonReaderArray Results { get; public set; }
    [CompilerGeneratedAttribute]
public BlittableJsonReaderArray get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(BlittableJsonReaderArray value);
}
internal class Raven.Server.Documents.Commands.Storage.GetEnvironmentStorageReportCommand : RavenCommand {
    private string _name;
    private StorageEnvironmentType _type;
    private bool _details;
    public GetEnvironmentStorageReportCommand(string name, StorageEnvironmentType type, bool details, string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Server.Documents.Commands.Storage.GetStorageReportCommand : RavenCommand {
    public GetStorageReportCommand(string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
public class Raven.Server.Documents.Commands.Streaming.PostQueryStreamCommand : RavenCommand`1<StreamResult> {
    private DocumentConventions _conventions;
    private BlittableJsonReaderObject _query;
    private string _debug;
    private bool _ignoreLimit;
    public bool IsReadRequest { get; }
    public PostQueryStreamCommand(DocumentConventions conventions, BlittableJsonReaderObject query, string debug, bool ignoreLimit);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Commands.Streaming.PostQueryStreamCommand/<ProcessResponse>d__8")]
public virtual Task`1<ResponseDisposeHandling> ProcessResponse(JsonOperationContext context, HttpCache cache, HttpResponseMessage response, string url);
}
public class Raven.Server.Documents.Commands.Studio.DeleteStudioCollectionOperation : object {
    private Nullable`1<long> _operationId;
    private string _collectionName;
    private List`1<string> _excludeIds;
    public DeleteStudioCollectionOperation(Nullable`1<long> operationId, string collectionName, List`1<string> excludeIds);
    public sealed virtual RavenCommand`1<OperationIdResult> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Server.Documents.Commands.Studio.GetStudioFooterStatisticsOperation : object {
    public sealed virtual RavenCommand`1<FooterStatistics> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Server.Documents.Commands.Subscriptions.GetSubscriptionConnectionsDetailsCommand : RavenCommand`1<SubscriptionConnectionsDetails> {
    private string _subscriptionName;
    public bool IsReadRequest { get; }
    public GetSubscriptionConnectionsDetailsCommand(string subscriptionName, string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Server.Documents.Commands.TimeSeries.GetTimeSeriesCommand : RavenCommand {
    private string _docId;
    private string _name;
    private Nullable`1<DateTime> _from;
    private Nullable`1<DateTime> _to;
    private Nullable`1<TimeSpan> _offset;
    public bool IsReadRequest { get; }
    public GetTimeSeriesCommand(string docId, string name, Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<TimeSpan> offset);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Server.Documents.Commands.TimeSeries.GetTimeSeriesConfigurationOperation : object {
    public sealed virtual RavenCommand`1<TimeSeriesConfiguration> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Server.Documents.Commands.Tombstones.CleanupTombstonesCommand : RavenCommand`1<Response> {
    public bool IsReadRequest { get; }
    public CleanupTombstonesCommand(string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Server.Documents.Commands.Tombstones.GetTombstonesStateCommand : RavenCommand`1<Response> {
    public bool IsReadRequest { get; }
    public GetTombstonesStateCommand(string nodeTag);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
internal class Raven.Server.Documents.Commands.ValidateUnusedIdsCommand : RavenCommand {
    private Parameters _parameters;
    internal ValidateUnusedIdsCommand(Parameters parameters);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Server.Documents.Commands.WaitForIndexNotificationCommand : RavenCommand {
    private List`1<long> _indexes;
    public bool IsReadRequest { get; }
    public WaitForIndexNotificationCommand(long index);
    public WaitForIndexNotificationCommand(List`1<long> indexes);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Server.Documents.Commands.WaitForIndexNotificationOperation : object {
    private long _index;
    public WaitForIndexNotificationOperation(long index);
    public sealed virtual RavenCommand GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Server.Documents.Commands.WaitForIndexNotificationRequest : object {
    [CompilerGeneratedAttribute]
private List`1<long> <RaftCommandIndexes>k__BackingField;
    public List`1<long> RaftCommandIndexes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<long> get_RaftCommandIndexes();
    [CompilerGeneratedAttribute]
public void set_RaftCommandIndexes(List`1<long> value);
}
public class Raven.Server.Documents.CompactDatabaseTask : object {
    private static string ResourceName;
    private static Logger Logger;
    private ServerStore _serverStore;
    private string _database;
    private CancellationToken _token;
    private bool _isCompactionInProgress;
    public CompactDatabaseTask(ServerStore serverStore, string database, CancellationToken token);
    private static CompactDatabaseTask();
    [AsyncStateMachineAttribute("Raven.Server.Documents.CompactDatabaseTask/<Execute>d__7")]
public Task Execute(Action`1<IOperationProgress> onProgress, CompactionResult result);
    private static void EnsureDirectoriesPermission(String[] directories);
    private static void InitializeOptions(StorageEnvironmentOptions options, RavenConfiguration configuration, DocumentDatabase documentDatabase, Byte[] key);
    private static void SwitchDatabaseDirectories(string basePath, string backupDirectory, string compactDirectory);
    [DoesNotReturnAttribute]
private static void ThrowCantMoveDirectory(string src, string dst, Exception e, string databasePath);
}
public class Raven.Server.Documents.CompareExchangeStorage : AbstractCompareExchangeStorage {
    public CompareExchangeStorage(DocumentDatabase database);
}
public static class Raven.Server.Documents.CompoundKeyHelper : object {
    public static string ExtractDocumentId(ReadOnlySpan`1<byte> key);
}
public static class Raven.Server.Documents.ComputeHttpEtags : object {
    public static string ComputeEtagForDocuments(List`1<Document> documents, List`1<Document> includes, IncludeCountersCommand includeCounters, IncludeTimeSeriesCommand includeTimeSeries, IncludeCompareExchangeValuesCommand includeCompareExchangeValues);
    public static string ComputeEtagForRevisions(Document[] revisions);
    public static string CombineEtags(IEnumerable`1<string> etags);
    public static string CombineEtags(Dictionary`2<int, ShardExecutionResult`1<T>> cmds);
    [IteratorStateMachineAttribute("Raven.Server.Documents.ComputeHttpEtags/<EnumerateEtags>d__4`1")]
public static IEnumerable`1<string> EnumerateEtags(Dictionary`2<int, ShardExecutionResult`1<T>> cmds);
    internal static void HashChangeVector(Byte* state, string changeVector);
    private static void HashNumber(Byte* state, int num);
    public static void HashNumber(Byte* state, long num);
    internal static string FinalizeHash(UIntPtr size, Byte* state);
    [DoesNotReturnAttribute]
private static void ThrowFailedToFinalizeHash();
    [DoesNotReturnAttribute]
internal static void ThrowFailToInitHash();
    [DoesNotReturnAttribute]
private static void ThrowFailedToUpdateHash();
}
public class Raven.Server.Documents.ConfigurationStorage : object {
    private DocumentDatabase _db;
    private static string ResourceName;
    private static Logger Logger;
    [CompilerGeneratedAttribute]
private TransactionContextPool <ContextPool>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationsStorage <OperationsStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageEnvironment <Environment>k__BackingField;
    public TransactionContextPool ContextPool { get; private set; }
    public OperationsStorage OperationsStorage { get; }
    public StorageEnvironment Environment { get; private set; }
    public ConfigurationStorage(DocumentDatabase db);
    private static ConfigurationStorage();
    [CompilerGeneratedAttribute]
public TransactionContextPool get_ContextPool();
    [CompilerGeneratedAttribute]
private void set_ContextPool(TransactionContextPool value);
    [CompilerGeneratedAttribute]
public OperationsStorage get_OperationsStorage();
    [CompilerGeneratedAttribute]
public StorageEnvironment get_Environment();
    [CompilerGeneratedAttribute]
private void set_Environment(StorageEnvironment value);
    public void Initialize();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.ConflictsStorage : object {
    public TableSchema ConflictsSchema;
    public long ConflictsCount;
    private DocumentDatabase _documentDatabase;
    private DocumentsStorage _documentsStorage;
    private Logger _logger;
    public ConflictsStorage(DocumentDatabase documentDatabase, Transaction tx, TableSchema schema);
    private static InternalScope<ByteStringMemoryCache> GetConflictsIdPrefix(DocumentsOperationContext context, Slice lowerId, Slice& prefixSlice);
    private static InternalScope<ByteStringMemoryCache> GetConflictsIdPrefix(DocumentsOperationContext context, Byte* lowerId, int lowerIdSize, Slice& prefixSlice);
    [IteratorStateMachineAttribute("Raven.Server.Documents.ConflictsStorage/<GetAllConflictsBySameId>d__8")]
public IEnumerable`1<List`1<DocumentConflict>> GetAllConflictsBySameId(DocumentsOperationContext context);
    [IteratorStateMachineAttribute("Raven.Server.Documents.ConflictsStorage/<GetConflictsFrom>d__9")]
public IEnumerable`1<DocumentConflict> GetConflictsFrom(DocumentsOperationContext context, long etag, long skip);
    internal GetConflictsPreviewResult GetConflictsPreviewResult(DocumentsOperationContext context, long skip, int pageSize);
    private static DocumentConflict TableValueToConflictDocument(DocumentsOperationContext context, TableValueReader& tvr);
    public static DocumentConflict ParseRawDataSectionConflictWithValidation(JsonOperationContext context, TableValueReader& tvr, int expectedSize, Int64& etag);
    public void ThrowOnDocumentConflict(DocumentsOperationContext context, Slice lowerId);
    [DoesNotReturnAttribute]
private static void ThrowDocumentConflictException(string docId, long etag);
    public long GetConflictsMaxEtagFor(DocumentsOperationContext context, Slice prefixSlice);
    public bool HasHigherChangeVector(DocumentsOperationContext context, Slice prefixSlice, string expectedChangeVector);
    public ValueTuple`2<List`1<string>, NonPersistentDocumentFlags> DeleteConflictsFor(DocumentsOperationContext context, Slice lowerId, BlittableJsonReaderObject document);
    private NonPersistentDocumentFlags DeleteAttachmentConflicts(DocumentsOperationContext context, Slice lowerId, BlittableJsonReaderObject document, TableValueHolder before, string changeVector);
    public void DeleteConflictsFor(DocumentsOperationContext context, string changeVector);
    public bool HasConflictsFor(DocumentsOperationContext context, LazyStringValue id);
    public IReadOnlyList`1<DocumentConflict> GetConflictsFor(DocumentsOperationContext context, string id);
    public IReadOnlyList`1<DocumentConflict> GetConflictsFor(DocumentsOperationContext context, Slice prefixSlice);
    public ChangeVector GetMergedConflictChangeVectorsAndDeleteConflicts(DocumentsOperationContext context, Slice lowerId, long newEtag, string existingChangeVector);
    private ChangeVector MergeVectorsWithoutConflicts(DocumentsOperationContext context, long newEtag, string existing);
    public bool ShouldThrowConcurrencyExceptionOnConflict(DocumentsOperationContext context, Slice lowerId, Nullable`1<long> expectedEtag, Nullable`1& currentMaxConflictEtag);
    public ValueTuple`2<ChangeVector, NonPersistentDocumentFlags> MergeConflictChangeVectorIfNeededAndDeleteConflicts(ChangeVector documentChangeVector, DocumentsOperationContext context, Slice lowerId, long newEtag, BlittableJsonReaderObject document);
    public void AddConflict(DocumentsOperationContext context, string id, long lastModifiedTicks, BlittableJsonReaderObject incomingDoc, string incomingChangeVector, string incomingTombstoneCollection, DocumentFlags flags, NonPersistentDocumentFlags nonPersistentFlags);
    [ConditionalAttribute("DEBUG")]
private static void ThrowIfNoConflictsWereFound(bool fromSmuggler, int conflictsCount, string id);
    public void ThrowConcurrencyExceptionOnConflictIfNeeded(DocumentsOperationContext context, Slice lowerId, string expectedChangeVector);
    public static ConflictStatus GetConflictStatusForDocument(DocumentsOperationContext context, string id, string changeVector, Boolean& hasLocalClusterTx);
    public long GetNumberOfDocumentsConflicts(DocumentsOperationContext context);
    public long GetNumberOfConflicts(DocumentsOperationContext context);
    public string GetCollection(DocumentsOperationContext context, string id);
    public string GetFirstOrNullCollection(DocumentsOperationContext context, string id);
    [IteratorStateMachineAttribute("Raven.Server.Documents.ConflictsStorage/<GetConflictsByBucketFrom>d__35")]
public IEnumerable`1<DocumentConflict> GetConflictsByBucketFrom(DocumentsOperationContext context, int bucket, long etag);
    [StorageIndexEntryKeyGeneratorAttribute]
internal static Scope<ByteStringMemoryCache> GenerateBucketAndEtagIndexKeyForConflicts(Transaction tx, TableValueReader& tvr, Slice& slice);
    [CompilerGeneratedAttribute]
private void <DeleteConflictsFor>b__19_0(LowLevelTransaction _);
    [CompilerGeneratedAttribute]
private void <AddConflict>g__AddToConflictsTable|27_0(string changeVector, string col, Byte* data, int dataSize, long lastModified, int documentFlags, <>c__DisplayClass27_0& , <>c__DisplayClass27_1& );
}
public class Raven.Server.Documents.CounterGroupItemMetadata : object {
    private bool _disposed;
    private IDisposable _keyScope;
    public LazyStringValue Key;
    public LazyStringValue LuceneKey;
    public LazyStringValue DocumentId;
    public LazyStringValue CounterName;
    public long Etag;
    public int Size;
    public CounterGroupItemMetadata(LazyStringValue key, IDisposable keyScope, LazyStringValue luceneKey, LazyStringValue documentId, LazyStringValue counterName, long etag, int size);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.CounterInfo : object {
    public long Value;
    public long Etag;
    public string DbId;
    public string Name;
}
public class Raven.Server.Documents.CounterPartialValue : ValueType {
    public long PartialValue;
    public long Etag;
    public string ChangeVector;
    public CounterPartialValue(long partialValue, long etag, string changeVector);
}
public class Raven.Server.Documents.CountersStorage : object {
    public static int DbIdAsBase64Size;
    public static int MaxCounterDocumentSize;
    public static string DbIds;
    public static string Values;
    public static string CounterNames;
    public static int SizeOfCounterValues;
    public IndexingMethods Indexing;
    internal List`1<InternalScope<ByteStringMemoryCache>> _counterModificationMemoryScopes;
    internal TableSchema CountersSchema;
    internal TableSchema CounterTombstonesSchema;
    private DocumentDatabase _documentDatabase;
    private DocumentsStorage _documentsStorage;
    private ObjectPool`1<Dictionary`2<LazyStringValue, PutCountersData>> _dictionariesPool;
    private HashSet`1<string> _tableCreated;
    public CountersStorage(DocumentDatabase documentDatabase, Transaction tx, TableSchema schema, TableSchema tombstoneSchema);
    private static CountersStorage();
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCountersFrom>d__16")]
public IEnumerable`1<ReplicationBatchItem> GetCountersFrom(DocumentsOperationContext context, long etag, bool caseInsensitiveNames);
    private static CounterReplicationItem ConvertToCaseSensitiveFormat(DocumentsOperationContext context, CounterReplicationItem countersItem);
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCountersFrom>d__18")]
public IEnumerable`1<CounterGroupDetail> GetCountersFrom(DocumentsOperationContext context, long etag, long skip, long take);
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCountersFrom>d__19")]
public IEnumerable`1<CounterGroupDetail> GetCountersFrom(DocumentsOperationContext context, string collection, long etag, long skip, long take);
    public long GetNumberOfCounterGroupsToProcess(DocumentsOperationContext context, string collection, long afterEtag, Int64& totalCount, Stopwatch overallDuration);
    public static CounterGroupDetail TableValueToCounterGroupDetail(JsonOperationContext context, TableValueReader& tvr);
    public static CounterTombstoneDetail TableValueToCounterTombstoneDetail(JsonOperationContext context, TableValueReader& tvr);
    internal static CounterReplicationItem CreateReplicationBatchItem(DocumentsOperationContext context, TableValueReader& reader);
    public string IncrementCounter(DocumentsOperationContext context, string documentId, string collection, string name, long delta, Boolean& exists);
    public string PutCounter(DocumentsOperationContext context, string documentId, string collection, string name, long delta);
    public string PutOrIncrementCounter(DocumentsOperationContext context, string documentId, string collection, string name, long delta, Boolean& exists, bool overrideExisting);
    [DoesNotReturnAttribute]
internal static void ThrowMissingProperty(Slice counterKeySlice, string property);
    [DoesNotReturnAttribute]
private static void ThrowCounterNameTooBig(string name);
    private static void SplitCounterGroup(DocumentsOperationContext context, CollectionName collectionName, Table table, Slice documentKeyPrefix, Slice countersGroupKey, BlittableJsonReaderObject values, BlittableJsonReaderArray dbIds, BlittableJsonReaderObject originalNames, string changeVector);
    private int GetOrAddLocalDbIdIndex(BlittableJsonReaderArray dbIds);
    private void CreateNewCounterOrOverrideExisting(DocumentsOperationContext context, string lowerName, int dbIdIndex, long value, long newETag, BlittableJsonReaderObject counters);
    private bool IncrementExistingCounter(DocumentsOperationContext context, string documentId, string lowerName, string originalName, long delta, RawBlob existingCounter, int dbIdIndex, long newETag, BlittableJsonReaderObject counters, Int64& value);
    private BlittableJsonReaderObject WriteNewCountersDocument(DocumentsOperationContext context, string originalName, string lowerName, long value);
    internal static ValueTuple`2<BlittableJsonReaderObject, BlittableJsonReaderObject> SplitCounterDocument(DocumentsOperationContext context, BlittableJsonReaderObject values, BlittableJsonReaderArray dbIds, BlittableJsonReaderObject originalNames);
    private static InternalScope<ByteStringMemoryCache> ReWriteBlob(DocumentsOperationContext context, RawBlob blob, HashSet`1<int> usedDbIndexes, RawBlob& newBlob);
    private static BlittableJsonReaderObject CreateHalfDocument(DocumentsOperationContext context, BlittableJsonReaderObject values, int start, int end, BlittableJsonReaderArray dbIds, BlittableJsonReaderObject originalNames);
    public bool PutCounters(DocumentsOperationContext context, string documentId, string collection, ChangeVector changeVector, BlittableJsonReaderObject sourceData);
    private void UpdateMetricsForNewCounterGroup(BlittableJsonReaderObject data);
    internal bool MergeCounterIfNeeded(DocumentsOperationContext context, BlittableJsonReaderObject localCounters, PropertyDetails& incomingCountersProp, DbIdsHolder dbIdsHolder, BlittableJsonReaderArray sourceDbIds, BlittableJsonReaderObject sourceCounterNames, BlittableJsonReaderObject localCounterNames, string docId, RawBlob& localCounterValues, CounterChangeTypes& changeType);
    private static void AddNewCounterName(DocumentsOperationContext context, LazyStringValue propName, BlittableJsonReaderObject sourceCounterNames, BlittableJsonReaderObject localCounterNames, string loweredName);
    private static LazyStringValue GetOriginalName(DocumentsOperationContext context, BlittableJsonReaderObject counterNames, string counterName);
    private static LazyStringValue GetLazyStringCounterName(string key, object value);
    private void MergeBlobAndDeleteVector(DocumentsOperationContext context, DbIdsHolder dbIdsHolder, RawBlob localCounterValues, ChangeVectorEntry[] deletedCv);
    internal static long InternalGetCounterValue(RawBlob localCounterValues, string docId, string counterName, bool capOnOverflow);
    private static List`1<LazyStringValue> DbIdsToList(BlittableJsonReaderArray dbIds);
    private CounterChangeTypes InternalPutCounter(DocumentsOperationContext context, BlittableJsonReaderObject counters, string counterName, DbIdsHolder localDbIds, BlittableJsonReaderArray sourceDbIds, RawBlob existingCounter, RawBlob source);
    private RawBlob AddPartialValueToExistingCounter(DocumentsOperationContext context, RawBlob existingCounter, int dbIdIndex, long sourceValue, long sourceEtag);
    private void UpdateMetrics(Slice counterKey, string counterName, string changeVector, string collection);
    public Table GetCountersTable(Transaction tx, CollectionName collection);
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCountersForDocument>d__52")]
public IEnumerable`1<string> GetCountersForDocument(DocumentsOperationContext context, string docId);
    internal long GetNumberOfCountersAndDeletedCountersForDocument(DocumentsOperationContext context, string docId);
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCountersForDocumentInternal>d__54")]
internal static IEnumerable`1<string> GetCountersForDocumentInternal(DocumentsOperationContext context, string docId, Table table);
    private static List`1<LazyStringValue> GetCountersOriginalCasing(DocumentsOperationContext context, Table table, Slice key);
    public DynamicJsonArray GetCountersForDocumentList(DocumentsOperationContext context, string docId);
    internal static BlittableJsonReaderObject GetCounterValuesData(JsonOperationContext context, TableValueReader& existing);
    internal Nullable`1<CounterValues> GetCounterValue(DocumentsOperationContext context, string docId, string counterName, bool capOnOverflow);
    private bool TryGetRawBlob(DocumentsOperationContext context, string docId, string counterName, Int64& etag, RawBlob& blob);
    internal static ExternalScope<ByteStringMemoryCache> CreateCounterKeySlice(DocumentsOperationContext context, ByteString buffer, Slice documentIdPrefix, Slice counterName, Slice& counterKeySlice);
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCounterPartialValues>d__61")]
public IEnumerable`1<CounterPartialValue> GetCounterPartialValues(DocumentsOperationContext context, string docId, string counterName);
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCountersFromCounterGroup>d__62")]
internal IEnumerable`1<CounterInfo> GetCountersFromCounterGroup(CounterGroupDetail counterGroup);
    private static long GetCounterGroupEtag(TableValueReader& tvr);
    internal static CounterValues GetPartialValue(int index, RawBlob counterValues);
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCounterValuesForDocument>d__65")]
internal IEnumerable`1<CounterGroupDetail> GetCounterValuesForDocument(DocumentsOperationContext context, string docId);
    public void DeleteCountersForDocument(DocumentsOperationContext context, string documentId, CollectionName collection);
    public string DeleteCounter(DocumentsOperationContext context, string documentId, string collection, string counterName);
    internal string GenerateDeleteChangeVectorFromRawBlob(BlittableJsonReaderObject data, RawBlob counterToDelete);
    private Table GetOrCreateCounterTombstonesTable(Transaction tx, CollectionName collection);
    internal Table GetOrCreateTable(Transaction tx, TableSchema tableSchema, CollectionName collection, CollectionTableType type);
    private void CreateCounterTombstone(DocumentsOperationContext context, Slice documentKeyPrefix, Slice counterNameSlice, CollectionName collectionName, ChangeVector remoteChangeVector);
    private static ChangeVector ExtractCounterTombstoneChangeVector(DocumentsOperationContext context, TableValueReader& reader);
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCounterTombstonesFrom>d__73")]
public IEnumerable`1<CounterTombstoneDetail> GetCounterTombstonesFrom(DocumentsOperationContext context, long etag, long toEtag);
    public long PurgeCountersAndCounterTombstones(DocumentsOperationContext context, string collection, long upto, long numberOfEntriesToDelete);
    private long PurgeCounters(long upto, DocumentsOperationContext context, CollectionName collectionName, long numberOfEntriesToDelete);
    private long PurgeCounterTombstones(Int64& upto, DocumentsOperationContext context, CollectionName collectionName, long numberOfEntriesToDelete);
    private static void AppendDbIdAndEtag(StringBuilder sb, string dbId, long etag);
    public long GetNumberOfCounterTombstoneEntries(DocumentsOperationContext context);
    public static LazyStringValue ExtractDocId(JsonOperationContext context, TableValueReader& tvr);
    public static void ExtractDocIdAndCounterNameFromCounterTombstoneKey(JsonOperationContext context, TableValueReader& tvr, LazyStringValue& docId, LazyStringValue& counterName);
    public string UpdateDocumentCounters(DocumentsOperationContext context, Document document, string docId, SortedSet`1<string> countersToAdd, HashSet`1<string> countersToRemove, NonPersistentDocumentFlags nonPersistentDocumentFlags);
    internal static BlittableJsonReaderObject ApplyCounterUpdatesToMetadata(JsonOperationContext context, BlittableJsonReaderObject data, string docId, SortedSet`1<string> countersToAdd, HashSet`1<string> countersToRemove, DocumentFlags& flags);
    private static SortedSet`1<string> GetCountersForDocument(BlittableJsonReaderArray metadataCounters, SortedSet`1<string> countersToAdd, HashSet`1<string> countersToRemove, Boolean& modified);
    public static void ConvertFromBlobToNumbers(JsonOperationContext context, CounterGroupDetail counterGroupDetail);
    private static ConflictStatus CompareCounterValuesAndDeletedCounter(RawBlob counterValues, string deletedCounter, List`1<LazyStringValue> dbIds, bool remoteDelete, string docId, string counterName, ChangeVectorEntry[]& deletedCv);
    private static ChangeVectorEntry[] DeletedCounterToChangeVectorEntries(string changeVector, string docId, string counterName);
    private static string MergeDeletedCounterVectors(string deletedA, string deletedB, string docId, string counterName);
    private static void MergeDeletedCounterVector(string deletedCounterVector, List`1<ChangeVectorEntry> entries, string docId, string counterName);
    public long GetNumberOfCounterEntries(DocumentsOperationContext context);
    public long GetLastCounterEtag(DocumentsOperationContext context, string collection);
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCountersByBucketFrom>d__93")]
public IEnumerable`1<ReplicationBatchItem> GetCountersByBucketFrom(DocumentsOperationContext context, int bucket, long etag);
    [IteratorStateMachineAttribute("Raven.Server.Documents.CountersStorage/<GetCounterTombstonesByBucketFrom>d__94")]
public IEnumerable`1<CounterTombstoneDetail> GetCounterTombstonesByBucketFrom(DocumentsOperationContext context, int bucket, long etag);
    [StorageIndexEntryKeyGeneratorAttribute]
internal static Scope<ByteStringMemoryCache> GenerateBucketAndEtagIndexKeyForCounters(Transaction tx, TableValueReader& tvr, Slice& slice);
    [StorageIndexEntryKeyGeneratorAttribute]
internal static Scope<ByteStringMemoryCache> GenerateBucketAndEtagIndexKeyForCounterTombstones(Transaction tx, TableValueReader& tvr, Slice& slice);
    internal static void UpdateBucketStatsForCounters(Transaction tx, Slice key, TableValueReader& oldValue, TableValueReader& newValue);
    internal static void UpdateBucketStatsForCounterTombstones(Transaction tx, Slice key, TableValueReader& oldValue, TableValueReader& newValue);
}
public class Raven.Server.Documents.CounterTombstoneDetail : object {
    [CompilerGeneratedAttribute]
private LazyStringValue <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private LazyStringValue <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private LazyStringValue <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Etag>k__BackingField;
    public LazyStringValue DocumentId { get; public set; }
    public LazyStringValue ChangeVector { get; public set; }
    public LazyStringValue Name { get; public set; }
    public long Etag { get; public set; }
    [CompilerGeneratedAttribute]
public LazyStringValue get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(LazyStringValue value);
    [CompilerGeneratedAttribute]
public LazyStringValue get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(LazyStringValue value);
    [CompilerGeneratedAttribute]
public LazyStringValue get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(LazyStringValue value);
    [CompilerGeneratedAttribute]
public long get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(long value);
    public sealed virtual void Dispose();
}
internal class Raven.Server.Documents.DataArchival.ArchiveDocumentsCommand : MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> {
    private Queue`1<DocumentExpirationInfo> _toArchive;
    private DocumentDatabase _database;
    private DateTime _currentTime;
    public int ArchivedDocsCount;
    public ArchiveDocumentsCommand(Queue`1<DocumentExpirationInfo> toArchive, DocumentDatabase database, DateTime currentTime);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    [PreserveBaseOverridesAttribute]
public virtual override IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, ArchiveDocumentsCommand> ToDto(DocumentsOperationContext context);
}
internal class Raven.Server.Documents.DataArchival.ArchiveDocumentsCommandDto : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`3[] <ToArchive>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CurrentTime>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`3[] ToArchive { get; public set; }
    public DateTime CurrentTime { get; public set; }
    public sealed virtual ArchiveDocumentsCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
    [CompilerGeneratedAttribute]
public ValueTuple`3[] get_ToArchive();
    [CompilerGeneratedAttribute]
public void set_ToArchive(ValueTuple`3[] value);
    [CompilerGeneratedAttribute]
public DateTime get_CurrentTime();
    [CompilerGeneratedAttribute]
public void set_CurrentTime(DateTime value);
}
public class Raven.Server.Documents.DataArchival.DataArchivalStorage : AbstractBackgroundWorkStorage {
    private static string DocumentsByArchiveAtDateTime;
    public DataArchivalStorage(DocumentDatabase database, Transaction tx);
    protected virtual void ProcessDocument(DocumentsOperationContext context, Slice lowerId, string id, DateTime currentTime);
    protected virtual void HandleDocumentConflict(BackgroundWorkParameters options, Slice ticksAsSlice, Slice clonedId, Queue`1<DocumentExpirationInfo> expiredDocs, Int32& totalCount);
}
public class Raven.Server.Documents.DataArchival.DataArchivist : BackgroundWorkBase {
    internal static int BatchSize;
    internal static int DefaultMaxItemsToProcessInSingleRun;
    private DocumentDatabase _database;
    private TimeSpan _archivePeriod;
    [CompilerGeneratedAttribute]
private DataArchivalConfiguration <DataArchivalConfiguration>k__BackingField;
    public DataArchivalConfiguration DataArchivalConfiguration { get; }
    private DataArchivist(DocumentDatabase database, DataArchivalConfiguration dataArchivalConfiguration);
    private static DataArchivist();
    [CompilerGeneratedAttribute]
public DataArchivalConfiguration get_DataArchivalConfiguration();
    public static DataArchivist LoadConfiguration(DocumentDatabase database, DatabaseRecord dbRecord, DataArchivist dataArchivist);
    protected virtual Task DoWork();
    [AsyncStateMachineAttribute("Raven.Server.Documents.DataArchival.DataArchivist/<DoArchiveWork>d__10")]
private Task DoArchiveWork();
    internal Task ArchiveDocs(Nullable`1<int> batchSize);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DataArchival.DataArchivist/<ArchiveDocs>d__12")]
private Task ArchiveDocs(int batchSize, long maxItemsToProcess);
}
public enum Raven.Server.Documents.DatabaseCleanupMode : Enum {
    public int value__;
    public static DatabaseCleanupMode None;
    public static DatabaseCleanupMode Regular;
    public static DatabaseCleanupMode Deep;
}
public class Raven.Server.Documents.DatabaseInfoCache : object {
    private static Logger Logger;
    private StorageEnvironment _environment;
    private TransactionContextPool _contextPool;
    private TableSchema _databaseInfoSchema;
    private static DatabaseInfoCache();
    public void Initialize(StorageEnvironment environment, TransactionContextPool contextPool);
    public void InsertDatabaseInfo(DynamicJsonValue databaseInfo, string databaseName);
    public bool TryGet(string databaseName, Action`1<BlittableJsonReaderObject> action);
    private static BlittableJsonReaderObject Read(JsonOperationContext context, TableValueReader& reader);
    private void DeleteInternal(TransactionOperationContext ctx, Slice databaseName);
    public void Delete(string databaseName);
}
public class Raven.Server.Documents.DatabaseMetricCacher : MetricCacher {
    private DocumentDatabase _database;
    public DatabaseMetricCacher(DocumentDatabase database);
    public void Initialize();
    private object CalculateDiskSpaceInfo();
}
public class Raven.Server.Documents.DatabaseRaftIndexNotifications : AbstractRaftIndexNotifications`1<RaftIndexNotification> {
    private RachisLogIndexNotifications _clusterStateMachineLogIndexNotifications;
    public DatabaseRaftIndexNotifications(RachisLogIndexNotifications clusterStateMachineLogIndexNotifications, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DatabaseRaftIndexNotifications/<WaitForTaskCompletion>d__2")]
public virtual Task`1<bool> WaitForTaskCompletion(long index, Lazy`1<Task> waitingTask);
    public virtual void NotifyListenersAbout(long index, Exception e);
}
public abstract class Raven.Server.Documents.DatabaseRequestHandler : AbstractDatabaseRequestHandler`1<DocumentsOperationContext> {
    public DocumentDatabase Database;
    public string DatabaseName { get; }
    public char IdentityPartsSeparator { get; }
    public virtual string get_DatabaseName();
    public virtual void Init(RequestHandlerContext context);
    public virtual char get_IdentityPartsSeparator();
    [AsyncStateMachineAttribute("Raven.Server.Documents.DatabaseRequestHandler/<ExecuteRemoteAsync>d__7`1")]
public Task`1<TResult> ExecuteRemoteAsync(RavenCommand`1<TResult> command, CancellationToken token);
    public virtual Task CheckForChanges(RequestHandlerContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DatabaseRequestHandler/<WaitForIndexToBeAppliedAsync>d__9")]
public virtual Task WaitForIndexToBeAppliedAsync(TransactionOperationContext context, long index);
    public virtual bool IsShutdownRequested();
    [DoesNotReturnAttribute]
public virtual void ThrowShutdownException(Exception inner);
    public virtual OperationCancelToken CreateHttpRequestBoundTimeLimitedOperationToken();
    public virtual OperationCancelToken CreateHttpRequestBoundTimeLimitedOperationTokenForQuery();
    public virtual OperationCancelToken CreateHttpRequestBoundTimeLimitedOperationToken(TimeSpan cancelAfter);
    public virtual OperationCancelToken CreateHttpRequestBoundOperationToken();
    public virtual OperationCancelToken CreateHttpRequestBoundOperationToken(CancellationToken token);
    public virtual OperationCancelToken CreateTimeLimitedBackgroundOperationTokenForQueryOperation();
    public virtual OperationCancelToken CreateTimeLimitedBackgroundOperationTokenForCollectionOperation();
    public virtual OperationCancelToken CreateTimeLimitedBackgroundOperationToken();
    public virtual OperationCancelToken CreateBackgroundOperationToken();
    public virtual bool ShouldAddPagingPerformanceHint(long numberOfResults);
    public virtual void AddPagingPerformanceHint(PagingOperationType operation, string action, string details, long numberOfResults, long pageSize, long duration, long totalDocumentsSizeInBytes);
    public virtual Task WaitForIndexNotificationAsync(long index);
}
public class Raven.Server.Documents.DatabasesLandlord : object {
    public static string Init;
    public static string DoNotRemove;
    private AsyncGuard _disposing;
    public ConcurrentDictionary`2<StringSegment, DateTime> LastRecentlyUsed;
    private ConcurrentDictionary`2<string, Timer> _wakeupTimers;
    public ResourceCache`1<DocumentDatabase> DatabasesCache;
    public ResourceCache`1<ShardedDatabaseContext> ShardedDatabasesCache;
    private Logger _logger;
    private ServerStore _serverStore;
    internal bool SkipShouldContinueDisposeCheck;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Action`1<ValueTuple`2<DocumentDatabase, string>> AfterDatabaseCreation;
    internal SemaphoreSlim _databaseSemaphore;
    internal TimeSpan _concurrentDatabaseLoadTimeout;
    internal int _dueTimeOnRetry;
    [CompilerGeneratedAttribute]
private CatastrophicFailureHandler <CatastrophicFailureHandler>k__BackingField;
    internal TestingStuff ForTestingPurposes;
    [CompilerGeneratedAttribute]
private Action`1<string> OnDatabaseLoaded;
    public ConcurrentDictionary`2<string, ConcurrentQueue`1<string>> InitLog;
    public CatastrophicFailureHandler CatastrophicFailureHandler { get; }
    public TimeSpan DatabaseLoadTimeout { get; }
    public DatabasesLandlord(ServerStore serverStore);
    [CompilerGeneratedAttribute]
public CatastrophicFailureHandler get_CatastrophicFailureHandler();
    public Task ClusterOnDatabaseChanged(string databaseName, long index, string type, ClusterDatabaseChangeType changeType, object changeState);
    internal TestingStuff ForTestingPurposesOnly();
    [AsyncStateMachineAttribute("Raven.Server.Documents.DatabasesLandlord/<HandleClusterDatabaseChanged>d__22")]
private Task HandleClusterDatabaseChanged(string databaseName, long index, string type, ClusterDatabaseChangeType changeType, object changeState);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DatabasesLandlord/<HandleSpecificClusterDatabaseChanged>d__23")]
private Task HandleSpecificClusterDatabaseChanged(string databaseName, long index, string type, ClusterDatabaseChangeType changeType, TransactionOperationContext context, RawDatabaseRecord rawRecord, object changeState);
    private bool PreventWakeUpIdleDatabase(string databaseName, string type);
    private void UnloadDatabase(string databaseName, bool dbRecordIsNull);
    public static bool IsDatabaseDisabled(BlittableJsonReaderObject databaseRecord);
    private void UnloadDatabaseInternal(string databaseName, string caller);
    private void UnloadDatabaseInternal(string databaseName, Task databaseTask);
    public bool ShouldDeleteDatabase(TransactionOperationContext context, string dbName, RawDatabaseRecord rawRecord, bool fromReplication);
    public void DeleteDatabase(string dbName, DeletionInProgressStatus deletionInProgress, DatabaseRecord record);
    [DoesNotReturnAttribute]
private static void ThrowUnknownClusterDatabaseChangeType(ClusterDatabaseChangeType type);
    private void NotifyLeaderAboutRemoval(string dbName, string databaseId, string requestId);
    public TimeSpan get_DatabaseLoadTimeout();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public void add_OnDatabaseLoaded(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_OnDatabaseLoaded(Action`1<string> value);
    public bool IsDatabaseLoaded(StringSegment databaseName);
    public bool TryGetDatabaseIfLoaded(StringSegment databaseName, DocumentDatabase& database);
    public DatabaseSearchResult TryGetOrCreateDatabase(StringSegment databaseName);
    private ShardedDatabaseContext GetOrAddShardedDatabaseContext(StringSegment databaseName, RawDatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DatabasesLandlord/<TryGetOrCreateShardedResourcesStore>d__44")]
public IEnumerable`1<Task`1<ShardedDocumentDatabase>> TryGetOrCreateShardedResourcesStore(StringSegment databaseName, Nullable`1<DateTime> wakeup, bool ignoreDisabledDatabase, bool ignoreBeenDeleted, bool ignoreNotRelevant);
    public Task`1<ShardedDocumentDatabase> TryGetOrCreateShardedResourceStore(StringSegment databaseName, Nullable`1<DateTime> wakeup, bool ignoreDisabledDatabase, bool ignoreBeenDeleted, bool ignoreNotRelevant, Action`1<string> addToInitLog, string caller);
    public Task`1<DocumentDatabase> TryGetOrCreateResourceStore(StringSegment databaseName, Nullable`1<DateTime> wakeup, bool ignoreDisabledDatabase, bool ignoreBeenDeleted, bool ignoreNotRelevant, Action`1<string> addToInitLog, string caller);
    private bool TryGetResourceStore(StringSegment databaseName, Task`1& database);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DatabasesLandlord/<RestartDatabaseAsync>d__48")]
public Task RestartDatabaseAsync(string databaseName);
    internal static bool IsLockedDatabase(AggregateException exception);
    [DoesNotReturnAttribute]
private static void ThrowServerIsBeingDisposed(StringSegment databaseName);
    private Task`1<DocumentDatabase> CreateDatabase(StringSegment databaseName, Nullable`1<DateTime> wakeup, bool ignoreDisabledDatabase, bool ignoreBeenDeleted, bool ignoreNotRelevant, string caller, Action`1<string> addToInitLog);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DatabasesLandlord/<UnlikelyCreateDatabaseUnderContention>d__52")]
private Task`1<DocumentDatabase> UnlikelyCreateDatabaseUnderContention(StringSegment databaseName, RavenConfiguration config, Nullable`1<DateTime> wakeup, string caller);
    private Task`1<DocumentDatabase> CreateDatabaseUnderResourceSemaphore(StringSegment databaseName, RavenConfiguration config, Nullable`1<DateTime> wakeup, Action`1<string> addToInitLog, string caller);
    private DocumentDatabase ActuallyCreateDatabase(StringSegment databaseName, RavenConfiguration config, Nullable`1<DateTime> wakeup, Action`1<string> addToInitLog);
    public void DeleteIfNeeded(StringSegment databaseName, bool fromReplication);
    public static DocumentDatabase CreateDocumentDatabase(string name, RavenConfiguration configuration, ServerStore serverStore, Action`2<LogMode, string> addToInitLog);
    private DocumentDatabase CreateDocumentsStorage(StringSegment databaseName, RavenConfiguration config, Nullable`1<DateTime> wakeup, Action`1<string> addToInitLog);
    private void DeleteDatabaseNotifications(string databaseName, bool throwOnError);
    private void DeleteDatabaseCachedInfo(string databaseName, bool throwOnError);
    public RavenConfiguration CreateDatabaseConfiguration(StringSegment databaseName, bool ignoreDisabledDatabase, bool ignoreBeenDeleted, bool ignoreNotRelevant);
    public RavenConfiguration CreateDatabaseConfiguration(StringSegment databaseName, bool ignoreDisabledDatabase, bool ignoreBeenDeleted, bool ignoreNotRelevant, DatabaseRecord databaseRecord);
    private static bool TryGetDeletionInProgress(Dictionary`2<string, DeletionInProgressStatus> deletionInProgress, string databaseName, string nodeTag, DeletionInProgressStatus& status);
    public static RavenConfiguration CreateDatabaseConfiguration(ServerStore serverStore, string databaseName, Dictionary`2<string, string> settings);
    public DateTime LastWork(DocumentDatabase resource);
    public Task`1<IDisposable> UnloadAndLockDatabase(string dbName, string reason);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DatabasesLandlord/<UnloadAndLockDatabaseImpl>d__67`1")]
internal static Task`1<IDisposable> UnloadAndLockDatabaseImpl(ResourceCache`1<T> resourceCache, string dbName, Action`1<T> unloadDatabaseOnSuccess, string reason);
    public bool UnloadDirectly(StringSegment databaseName, Nullable`1<DateTime> wakeup, string caller);
    public bool UnloadDirectly(StringSegment databaseName, IdleDatabaseActivity idleDatabaseActivity, string caller);
    private void LogUnloadFailureReason(StringSegment databaseName, string reason);
    public void RescheduleNextIdleDatabaseActivity(string databaseName, IdleDatabaseActivity idleDatabaseActivity);
    private void NextScheduledActivityCallback(string databaseName, IdleDatabaseActivity nextIdleDatabaseActivity);
    private bool ShouldContinueDispose(string name, IdleDatabaseActivity idleDatabaseActivity);
    private void CompleteDatabaseUnloading(DocumentDatabase database);
    private void CheckDatabasePathsIntersection(string databaseName, RavenConfiguration configuration);
    private void CheckConfigurationPaths(RavenConfiguration parentConfiguration, RavenConfiguration currentConfiguration, string databaseName, string currentDatabaseName);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DatabasesLandlord/<NotifyFeaturesAboutStateChangeAsync>d__78")]
public static ValueTask NotifyFeaturesAboutStateChangeAsync(DatabaseRecord record, long index, StateChange state, string type, Nullable`1<ClusterDatabaseChangeType> changeType);
    [CompilerGeneratedAttribute]
internal static bool <NotifyFeaturesAboutStateChangeAsync>g__CanSkipDatabaseRecordChange|78_0(<>c__DisplayClass78_0& );
}
internal class Raven.Server.Documents.DeleteTombstonesCommandDto : object {
    public Dictionary`2<string, StateHolder> Tombstones;
    public long MinAllDocsEtag;
    public long MinAllTimeSeriesEtag;
    public long MinAllCountersEtag;
    public Nullable`1<long> NumberOfTombstonesToDeleteInBatch;
    public sealed virtual DeleteTombstonesCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public class Raven.Server.Documents.Document : object {
    public static Document ExplicitNull;
    public LazyStringValue Id;
    public LazyStringValue LowerId;
    public BlittableJsonReaderObject Data;
    public string ChangeVector;
    public TimeSeriesStream TimeSeriesStream;
    public Nullable`1<SpatialResult> Distance;
    private Nullable`1<ulong> _hash;
    public long Etag;
    public long StorageId;
    public Nullable`1<float> IndexScore;
    public DateTime LastModified;
    public DocumentFlags Flags;
    public NonPersistentDocumentFlags NonPersistentFlags;
    public short TransactionMarker;
    public bool IgnoreDispose;
    private bool _metadataEnsured;
    private bool _disposed;
    public ulong DataHash { get; }
    private static Document();
    public ulong get_DataHash();
    public bool TryGetMetadata(BlittableJsonReaderObject& metadata);
    public void EnsureDocumentId();
    public void EnsureMetadata();
    public void ResetModifications();
    public Document Clone(JsonOperationContext context);
    public Document CloneWith(JsonOperationContext context, BlittableJsonReaderObject newData);
    public sealed virtual void Dispose();
    public virtual string ToString();
}
public static class Raven.Server.Documents.DocumentCompare : object {
    public static DocumentCompareResult IsEqualTo(BlittableJsonReaderObject original, BlittableJsonReaderObject modified, DocumentCompareOptions& options);
    private static DocumentCompareResult IsMetadataEqualTo(BlittableJsonReaderObject current, BlittableJsonReaderObject modified, DocumentCompareOptions& options);
    [DoesNotReturnAttribute]
private static void ThrowAttachmentsModificationsDetected();
    private static DocumentCompareResult ComparePropertiesExceptStartingWithAt(BlittableJsonReaderObject current, BlittableJsonReaderObject modified, bool isMetadata, DocumentCompareOptions& options);
    private static bool ShouldResolveAttachmentsConflict(BlittableJsonReaderObject currentMetadata, BlittableJsonReaderObject modifiedMetadata, DocumentCompareOptions& options);
    private static bool ShouldResolveCountersConflict(BlittableJsonReaderObject currentMetadata, BlittableJsonReaderObject modifiedMetadata);
    private static bool ShouldResolveTimeSeriesConflict(BlittableJsonReaderObject currentMetadata, BlittableJsonReaderObject modifiedMetadata);
}
[FlagsAttribute]
public enum Raven.Server.Documents.DocumentCompareResult : Enum {
    public int value__;
    public static DocumentCompareResult None;
    public static DocumentCompareResult NotEqual;
    public static DocumentCompareResult Equal;
    public static DocumentCompareResult AttachmentsNotEqual;
    public static DocumentCompareResult CountersNotEqual;
    public static DocumentCompareResult TimeSeriesNotEqual;
}
public class Raven.Server.Documents.DocumentConflict : object {
    private bool _disposed;
    public LazyStringValue LowerId;
    public LazyStringValue Id;
    public BlittableJsonReaderObject Doc;
    public long StorageId;
    public string ChangeVector;
    public LazyStringValue Collection;
    public DateTime LastModified;
    public DocumentFlags Flags;
    public long Etag;
    public DocumentConflict Clone();
    public sealed virtual void Dispose();
    public static DocumentConflict From(JsonOperationContext ctx, Document doc);
    public static DocumentConflict From(Tombstone tombstone);
}
public class Raven.Server.Documents.DocumentDatabase : object {
    private ServerStore _serverStore;
    private Action`2<LogMode, string> _addToInitLog;
    private Logger _logger;
    private DisposeOnce`1<SingleAttempt> _disposeOnce;
    internal TestingStuff ForTestingPurposes;
    private CancellationTokenSource _databaseShutdown;
    private object _idleLocker;
    private SemaphoreSlim _updateValuesLocker;
    private Task _indexStoreTask;
    private long _usages;
    private ManualResetEventSlim _waitForUsagesOnDisposal;
    private long _lastIdleTicks;
    private DateTime _nextIoMetricsCleanupTime;
    private long _lastTopologyIndex;
    private long _preventUnloadCounter;
    public string DatabaseGroupId;
    public string ClusterTransactionId;
    private Lazy`1<RequestExecutor> _proxyRequestExecutor;
    private StateChange _databaseStateChange;
    private DocumentsCompressionConfiguration _documentsCompression;
    private HashSet`1<string> _compressedCollections;
    internal Size _maxTransactionSize;
    public bool DisableOngoingTasks;
    public DateTime LastAccessTime;
    [CompilerGeneratedAttribute]
private DatabaseInfoCache <DatabaseInfoCache>k__BackingField;
    public SystemTime Time;
    public ScriptRunnerCache Scripts;
    public DocumentsTransactionOperationsMerger TxMerger;
    [CompilerGeneratedAttribute]
private SubscriptionStorage <SubscriptionStorage>k__BackingField;
    public string Name;
    [CompilerGeneratedAttribute]
private RavenConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryRunner <QueryRunner>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncManualResetEvent <DatabaseShutdownCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentsStorage <DocumentsStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpiredDocumentsCleaner <ExpiredDocumentsCleaner>k__BackingField;
    [CompilerGeneratedAttribute]
private DataArchivist <DataArchivist>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesPolicyRunner <TimeSeriesPolicyRunner>k__BackingField;
    [CompilerGeneratedAttribute]
private PeriodicBackupRunner <PeriodicBackupRunner>k__BackingField;
    [CompilerGeneratedAttribute]
private TombstoneCleaner <TombstoneCleaner>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentsChanges <Changes>k__BackingField;
    [CompilerGeneratedAttribute]
private IoChangesNotifications <IoChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private CatastrophicFailureNotification <CatastrophicFailureNotification>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseNotificationCenter <NotificationCenter>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseOperations <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private HugeDocuments <HugeDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricCounters <Metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexStore <IndexStore>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationStorage <ConfigurationStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationLoader <ReplicationLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlLoader <EtlLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueSinkLoader <QueueSinkLoader>k__BackingField;
    public ConcurrentSet`1<TcpConnectionOptions> RunningTcpConnections;
    public DateTime StartTime;
    public DatabaseRaftIndexNotifications RachisLogIndexNotifications;
    [CompilerGeneratedAttribute]
private Byte[] <MasterKey>k__BackingField;
    private Nullable`1<char> _localIdentityPartsSeparator;
    [CompilerGeneratedAttribute]
private ClientConfiguration <ClientConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private StudioConfiguration <StudioConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private CompareExchangeStorage <CompareExchangeStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private OngoingTasks <OngoingTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Is32Bits>k__BackingField;
    private long _lastValueChangeIndex;
    public QueryMetadataCache QueryMetadataCache;
    [CompilerGeneratedAttribute]
private AbstractDatabaseSmugglerFactory <Smuggler>k__BackingField;
    private ManualResetEventSlim _hasClusterTransaction;
    public DatabaseMetricCacher MetricCacher;
    protected Nullable`1<long> _nextClusterCommand;
    private long _lastCompletedClusterTransaction;
    public RaftIndexWaiter ClusterWideTransactionIndexWaiter;
    private LongRunningWork _clusterTransactionsThread;
    private int _clusterTransactionDelayOnFailure;
    private FileLocker _fileLocker;
    private static List`1<StorageEnvironmentType> DefaultStorageEnvironmentTypes;
    private static List`1<StorageEnvironmentType> DefaultStorageEnvironmentTypesForBackup;
    [CompilerGeneratedAttribute]
private Action`1<DatabaseRecord> DatabaseRecordChanged;
    public Action`2<LogMode, string> AddToInitLog { get; }
    public DocumentsCompressionConfiguration DocumentsCompression { get; }
    public ServerStore ServerStore { get; }
    public RequestExecutor RequestExecutor { get; }
    private bool IsRequestExecutorCreated { get; }
    public DateTime LastIdleTime { get; }
    public DatabaseInfoCache DatabaseInfoCache { get; public set; }
    public SubscriptionStorage SubscriptionStorage { get; }
    public Guid DbId { get; }
    public string DbBase64Id { get; }
    public RavenConfiguration Configuration { get; }
    public QueryRunner QueryRunner { get; }
    public CancellationToken DatabaseShutdown { get; }
    public AsyncManualResetEvent DatabaseShutdownCompleted { get; }
    public DocumentsStorage DocumentsStorage { get; private set; }
    public ExpiredDocumentsCleaner ExpiredDocumentsCleaner { get; private set; }
    public DataArchivist DataArchivist { get; private set; }
    public TimeSeriesPolicyRunner TimeSeriesPolicyRunner { get; private set; }
    public PeriodicBackupRunner PeriodicBackupRunner { get; private set; }
    public TombstoneCleaner TombstoneCleaner { get; private set; }
    public DocumentsChanges Changes { get; }
    public IoChangesNotifications IoChanges { get; }
    public CatastrophicFailureNotification CatastrophicFailureNotification { get; }
    public DatabaseNotificationCenter NotificationCenter { get; private set; }
    public DatabaseOperations Operations { get; private set; }
    public HugeDocuments HugeDocuments { get; }
    public MetricCounters Metrics { get; }
    public IndexStore IndexStore { get; private set; }
    public ConfigurationStorage ConfigurationStorage { get; }
    public ReplicationLoader ReplicationLoader { get; internal set; }
    public EtlLoader EtlLoader { get; private set; }
    public QueueSinkLoader QueueSinkLoader { get; private set; }
    public Byte[] MasterKey { get; private set; }
    public char IdentityPartsSeparator { get; }
    public ClientConfiguration ClientConfiguration { get; private set; }
    public StudioConfiguration StudioConfiguration { get; private set; }
    public CompareExchangeStorage CompareExchangeStorage { get; private set; }
    public OngoingTasks OngoingTasks { get; private set; }
    public bool Is32Bits { get; }
    public long LastValueChangeIndex { get; private set; }
    public bool CanUnload { get; }
    public long LastTransactionId { get; }
    public AbstractDatabaseSmugglerFactory Smuggler { get; protected set; }
    public long LastCompletedClusterTransaction { get; }
    public bool IsEncrypted { get; }
    internal bool IsDisposed { get; }
    public DocumentDatabase(string name, RavenConfiguration configuration, ServerStore serverStore, Action`2<LogMode, string> addToInitLog);
    private static DocumentDatabase();
    public Action`2<LogMode, string> get_AddToInitLog();
    public DocumentsCompressionConfiguration get_DocumentsCompression();
    public void ResetIdleTime();
    protected virtual DocumentsStorage CreateDocumentsStorage(Action`2<LogMode, string> addToInitLog);
    protected virtual IndexStore CreateIndexStore(ServerStore serverStore);
    protected virtual SubscriptionStorage CreateSubscriptionStorage(ServerStore serverStore);
    protected virtual Byte[] ReadSecretKey(TransactionOperationContext context);
    private void EnsureValidSecretKey();
    public void SetIds(RawDatabaseRecord record);
    public void SetIds(DatabaseRecord record);
    internal virtual void SetIds(DatabaseTopology topology, string shardedDatabaseId);
    public ServerStore get_ServerStore();
    public RequestExecutor get_RequestExecutor();
    private bool get_IsRequestExecutorCreated();
    public DateTime get_LastIdleTime();
    [CompilerGeneratedAttribute]
public DatabaseInfoCache get_DatabaseInfoCache();
    [CompilerGeneratedAttribute]
public void set_DatabaseInfoCache(DatabaseInfoCache value);
    [CompilerGeneratedAttribute]
public SubscriptionStorage get_SubscriptionStorage();
    public Guid get_DbId();
    public string get_DbBase64Id();
    [CompilerGeneratedAttribute]
public RavenConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public QueryRunner get_QueryRunner();
    public CancellationToken get_DatabaseShutdown();
    [CompilerGeneratedAttribute]
public AsyncManualResetEvent get_DatabaseShutdownCompleted();
    [CompilerGeneratedAttribute]
public DocumentsStorage get_DocumentsStorage();
    [CompilerGeneratedAttribute]
private void set_DocumentsStorage(DocumentsStorage value);
    [CompilerGeneratedAttribute]
public ExpiredDocumentsCleaner get_ExpiredDocumentsCleaner();
    [CompilerGeneratedAttribute]
private void set_ExpiredDocumentsCleaner(ExpiredDocumentsCleaner value);
    [CompilerGeneratedAttribute]
public DataArchivist get_DataArchivist();
    [CompilerGeneratedAttribute]
private void set_DataArchivist(DataArchivist value);
    [CompilerGeneratedAttribute]
public TimeSeriesPolicyRunner get_TimeSeriesPolicyRunner();
    [CompilerGeneratedAttribute]
private void set_TimeSeriesPolicyRunner(TimeSeriesPolicyRunner value);
    [CompilerGeneratedAttribute]
public PeriodicBackupRunner get_PeriodicBackupRunner();
    [CompilerGeneratedAttribute]
private void set_PeriodicBackupRunner(PeriodicBackupRunner value);
    [CompilerGeneratedAttribute]
public TombstoneCleaner get_TombstoneCleaner();
    [CompilerGeneratedAttribute]
private void set_TombstoneCleaner(TombstoneCleaner value);
    [CompilerGeneratedAttribute]
public DocumentsChanges get_Changes();
    [CompilerGeneratedAttribute]
public IoChangesNotifications get_IoChanges();
    [CompilerGeneratedAttribute]
public CatastrophicFailureNotification get_CatastrophicFailureNotification();
    [CompilerGeneratedAttribute]
public DatabaseNotificationCenter get_NotificationCenter();
    [CompilerGeneratedAttribute]
private void set_NotificationCenter(DatabaseNotificationCenter value);
    [CompilerGeneratedAttribute]
public DatabaseOperations get_Operations();
    [CompilerGeneratedAttribute]
private void set_Operations(DatabaseOperations value);
    [CompilerGeneratedAttribute]
public HugeDocuments get_HugeDocuments();
    [CompilerGeneratedAttribute]
public MetricCounters get_Metrics();
    [CompilerGeneratedAttribute]
public IndexStore get_IndexStore();
    [CompilerGeneratedAttribute]
private void set_IndexStore(IndexStore value);
    [CompilerGeneratedAttribute]
public ConfigurationStorage get_ConfigurationStorage();
    [CompilerGeneratedAttribute]
public ReplicationLoader get_ReplicationLoader();
    [CompilerGeneratedAttribute]
internal void set_ReplicationLoader(ReplicationLoader value);
    [CompilerGeneratedAttribute]
public EtlLoader get_EtlLoader();
    [CompilerGeneratedAttribute]
private void set_EtlLoader(EtlLoader value);
    [CompilerGeneratedAttribute]
public QueueSinkLoader get_QueueSinkLoader();
    [CompilerGeneratedAttribute]
private void set_QueueSinkLoader(QueueSinkLoader value);
    [CompilerGeneratedAttribute]
public Byte[] get_MasterKey();
    [CompilerGeneratedAttribute]
private void set_MasterKey(Byte[] value);
    public char get_IdentityPartsSeparator();
    [CompilerGeneratedAttribute]
public ClientConfiguration get_ClientConfiguration();
    [CompilerGeneratedAttribute]
private void set_ClientConfiguration(ClientConfiguration value);
    [CompilerGeneratedAttribute]
public StudioConfiguration get_StudioConfiguration();
    [CompilerGeneratedAttribute]
private void set_StudioConfiguration(StudioConfiguration value);
    [CompilerGeneratedAttribute]
public CompareExchangeStorage get_CompareExchangeStorage();
    [CompilerGeneratedAttribute]
private void set_CompareExchangeStorage(CompareExchangeStorage value);
    [CompilerGeneratedAttribute]
public OngoingTasks get_OngoingTasks();
    [CompilerGeneratedAttribute]
private void set_OngoingTasks(OngoingTasks value);
    [CompilerGeneratedAttribute]
public bool get_Is32Bits();
    public long get_LastValueChangeIndex();
    private void set_LastValueChangeIndex(long value);
    public bool get_CanUnload();
    public long get_LastTransactionId();
    [CompilerGeneratedAttribute]
public AbstractDatabaseSmugglerFactory get_Smuggler();
    [CompilerGeneratedAttribute]
protected void set_Smuggler(AbstractDatabaseSmugglerFactory value);
    protected virtual void InitializeCompareExchangeStorage();
    protected virtual void InitializeAndStartDocumentsMigration();
    protected virtual ReplicationLoader CreateReplicationLoader();
    public void Initialize(InitializeOptions options, Nullable`1<DateTime> wakeup);
    public IDisposable PreventFromUnloadingByIdleOperations();
    public DatabaseUsage DatabaseInUse(bool skipUsagesCount);
    [DoesNotReturnAttribute]
internal void ThrowDatabaseShutdown(Exception e);
    internal DatabaseDisabledException CreateDatabaseShutdownException(Exception e);
    public void NotifyOnPendingClusterTransaction();
    public long get_LastCompletedClusterTransaction();
    public bool get_IsEncrypted();
    private void ExecuteClusterTransaction();
    protected virtual ClusterTransactionBatchCollector CollectCommandsBatch(ClusterOperationContext context, long lastCompletedClusterTransactionIndex, int take);
    public ValueTuple`2<long, long> ExecuteClusterTransaction(ClusterOperationContext context, int batchSize);
    private bool ExecuteClusterTransactionOneByOne(ArraySegment`1<SingleClusterDatabaseCommand> batch);
    private void OnClusterTransactionCompletion(SingleClusterDatabaseCommand command, ClusterTransactionMergedCommand mergedCommands);
    private void OnClusterTransactionCompletion(SingleClusterDatabaseCommand command, Exception exception);
    public sealed virtual void Dispose();
    internal bool get_IsDisposed();
    private void DisposeInternal();
    private void DisposeBackgroundWorkers(ExceptionAggregator exceptionAggregator);
    public DynamicJsonValue GenerateOfflineDatabaseInfo();
    public DatabaseSummary GetDatabaseSummary();
    public long ReadLastEtag();
    public ValueTuple`2<long, string> ReadLastEtagAndChangeVector();
    public void SetChangeVector(string changeVector);
    public void RunIdleOperations(DatabaseCleanupMode mode);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentDatabase/<GetAllStoragesEnvironment>d__222")]
public IEnumerable`1<StorageEnvironmentWithType> GetAllStoragesEnvironment(List`1<StorageEnvironmentType> types);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentDatabase/<GetAllStoragesForBackup>d__223")]
private IEnumerable`1<StorageEnvironmentInformation> GetAllStoragesForBackup(bool excludeIndexes);
    public SmugglerResult FullBackupTo(Stream stream, SnapshotBackupCompressionAlgorithm compressionAlgorithm, CompressionLevel compressionLevel, bool excludeIndexes, Action`1<ValueTuple`2<string, int>> infoNotify, CancellationToken cancellationToken);
    public Stream GetOutputStream(Stream fileStream);
    [CompilerGeneratedAttribute]
public void add_DatabaseRecordChanged(Action`1<DatabaseRecord> value);
    [CompilerGeneratedAttribute]
public void remove_DatabaseRecordChanged(Action`1<DatabaseRecord> value);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DocumentDatabase/<ValueChangedAsync>d__229")]
public ValueTask ValueChangedAsync(long index, string type, object changeState);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DocumentDatabase/<StateChangedAsync>d__230")]
public ValueTask StateChangedAsync(long index, string type, ClusterDatabaseChangeType changeType);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DocumentDatabase/<UpdateOnStateChange>d__231")]
public Task UpdateOnStateChange(DatabaseRecord record, long index);
    private void SetUnusedDatabaseIds(DatabaseRecord record);
    private bool CanSkipValueChange(long index, string type);
    [AsyncStateMachineAttribute("Raven.Server.Documents.DocumentDatabase/<NotifyFeaturesAboutValueChangeAsync>d__234")]
private ValueTask NotifyFeaturesAboutValueChangeAsync(long index, string type, object changeState);
    public ValueTask RefreshFeaturesAsync();
    private void InitializeFromDatabaseRecord(DatabaseRecord record);
    public void InitializeCompressionFromDatabaseRecord(DatabaseRecord record);
    public TableSchema GetDocsSchemaForCollection(CollectionName collection, DocumentFlags flags);
    private void LoadTimeSeriesPolicyRunnerConfigurations();
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentDatabase/<GetAllPerformanceMetrics>d__240")]
public IEnumerable`1<DatabasePerformanceMetrics> GetAllPerformanceMetrics();
    protected virtual void OnDatabaseRecordChanged(DatabaseRecord record);
    public bool HasTopologyChanged(long index);
    public ValueTuple`2<Size, Size> GetSizeOnDisk();
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentDatabase/<GetMountPointsUsage>d__244")]
public IEnumerable`1<MountPointUsage> GetMountPointsUsage(bool includeTempBuffers);
    public DatabaseRecord ReadDatabaseRecord();
    private void OnCertificateChange(object sender, EventArgs e);
    public TableSchema GetDocsSchemaForCollection(CollectionName collection);
    private void UpdateCompressionConfigurationFromDatabaseRecord(DatabaseRecord record);
    private Lazy`1<RequestExecutor> CreateRequestExecutor();
    internal void HandleNonDurableFileSystemError(object sender, NonDurabilitySupportEventArgs e);
    internal void HandleOnDatabaseRecoveryError(object sender, RecoveryErrorEventArgs e);
    internal void HandleOnConfigurationRecoveryError(object sender, RecoveryErrorEventArgs e);
    internal void HandleOnIndexRecoveryError(string indexName, object sender, RecoveryErrorEventArgs e);
    private void HandleOnRecoveryError(StorageEnvironmentType type, string resourceName, object environment, RecoveryErrorEventArgs e);
    internal void HandleOnDatabaseIntegrityErrorOfAlreadySyncedData(object sender, DataIntegrityErrorEventArgs e);
    internal void HandleOnConfigurationIntegrityErrorOfAlreadySyncedData(object sender, DataIntegrityErrorEventArgs e);
    internal void HandleOnIndexIntegrityErrorOfAlreadySyncedData(string indexName, object sender, DataIntegrityErrorEventArgs e);
    private void HandleOnIntegrityErrorOfAlreadySyncedData(StorageEnvironmentType type, string resourceName, object environment, DataIntegrityErrorEventArgs e);
    internal void HandleRecoverableFailure(object sender, RecoverableFailureEventArgs e);
    public void CheckWriteRateAndNotifyIfNecessary(IoChange ioChange);
    public long GetEnvironmentsHash();
    public bool IsShutdownRequested();
    public void ThrowIfShutdownRequested();
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
private void <PreventFromUnloadingByIdleOperations>b__184_0();
    [CompilerGeneratedAttribute]
private void <DisposeBackgroundWorkers>b__215_0();
    [CompilerGeneratedAttribute]
private void <DisposeBackgroundWorkers>b__215_1();
    [CompilerGeneratedAttribute]
private void <DisposeBackgroundWorkers>b__215_2();
    [CompilerGeneratedAttribute]
private RequestExecutor <CreateRequestExecutor>b__249_0();
}
[FlagsAttribute]
public enum Raven.Server.Documents.DocumentFields : Enum {
    public int value__;
    public static DocumentFields Default;
    public static DocumentFields Id;
    public static DocumentFields LowerId;
    public static DocumentFields Data;
    public static DocumentFields ChangeVector;
    public static DocumentFields All;
}
[FlagsAttribute]
public enum Raven.Server.Documents.DocumentFlags : Enum {
    public int value__;
    public static DocumentFlags None;
    public static DocumentFlags Artificial;
    public static DocumentFlags HasRevisions;
    public static DocumentFlags DeleteRevision;
    public static DocumentFlags FromOldDocumentRevision;
    public static DocumentFlags FromIndex;
    public static DocumentFlags Revision;
    public static DocumentFlags FromReplication;
    public static DocumentFlags Reserved3;
    public static DocumentFlags HasAttachments;
    public static DocumentFlags Resolved;
    public static DocumentFlags Conflicted;
    public static DocumentFlags HasCounters;
    public static DocumentFlags FromClusterTransaction;
    public static DocumentFlags Reverted;
    public static DocumentFlags HasTimeSeries;
    public static DocumentFlags FromResharding;
    public static DocumentFlags ForceCreated;
    public static DocumentFlags Archived;
}
internal class Raven.Server.Documents.DocumentIdWorker : object {
    [ThreadStaticAttribute]
private static JsonParserState _jsonParserState;
    public static int MaxIdSize;
    private static UTF8Encoding Encoding;
    private static DocumentIdWorker();
    public static InternalScope<ByteStringMemoryCache> GetSliceFromId(ByteStringContext allocator, string id, Slice& idSlice, Nullable`1<byte> separator);
    public static InternalScope<ByteStringMemoryCache> GetSliceFromId(TransactionOperationContext`1<TTransaction> context, string id, Slice& idSlice, Nullable`1<byte> separator);
    public static InternalScope<ByteStringMemoryCache> GetSliceFromId(TransactionOperationContext`1<TTransaction> context, ReadOnlyMemory`1<char> id, Slice& idSlice, Nullable`1<byte> separator);
    public static InternalScope<ByteStringMemoryCache> GetSliceFromId(TransactionOperationContext`1<TTransaction> context, LazyStringValue id, Slice& idSlice, Nullable`1<byte> separator);
    private static InternalScope<ByteStringMemoryCache> GetSliceFromId(ByteStringContext allocator, ReadOnlySpan`1<char> id, Slice& idSlice, Nullable`1<byte> separator);
    private static int ReadFromUnicodeKey(ReadOnlySpan`1<char> key, ByteString buffer, int maxByteCount, Nullable`1<byte> separator);
    public static InternalScope<ByteStringMemoryCache> GetLower(ByteStringContext byteStringContext, LazyStringValue str, Slice& loweredKey);
    public static InternalScope<ByteStringMemoryCache> GetLower(ByteStringContext byteStringContext, string str, Slice& loweredKey);
    public static InternalScope<ByteStringMemoryCache> GetLower(ByteStringContext byteStringContext, Byte* str, int size, Slice& loweredKey);
    private static InternalScope<ByteStringMemoryCache> UnlikelyGetLowerUnicode(ByteStringContext byteStringContext, Byte* str, int size, Slice& loweredKey);
    private static InternalScope<ByteStringMemoryCache> UnlikelyGetLowerUnicode(ByteStringContext byteStringContext, string str, Slice& loweredKey);
    public static InternalScope<ByteStringMemoryCache> GetLowerIdSliceAndStorageKey(TransactionOperationContext`1<TTransaction> context, string str, Slice& lowerIdSlice, Slice& idSlice);
    public static InternalScope<ByteStringMemoryCache> GetLowerIdSliceAndStorageKey(ByteStringContext allocator, string str, Slice& lowerIdSlice, Slice& idSlice);
    private static InternalScope<ByteStringMemoryCache> UnicodeGetLowerIdAndStorageKey(ByteStringContext allocator, string str, Slice& lowerIdSlice, Slice& idSlice, int maxStrSize, int escapePositionsSize);
    [DoesNotReturnAttribute]
public static void ThrowDocumentIdTooBig(string str);
    public static InternalScope<ByteStringMemoryCache> GetStringPreserveCase(DocumentsOperationContext context, string str, Slice& strSlice);
}
public class Raven.Server.Documents.DocumentPutAction : object {
    private DocumentsStorage _documentsStorage;
    private DocumentDatabase _documentDatabase;
    private IRecreationType[] _recreationTypes;
    public DocumentPutAction(DocumentsStorage documentsStorage, DocumentDatabase documentDatabase);
    public void Recreate(DocumentsOperationContext context, string docId);
    public PutOperationResults PutDocument(DocumentsOperationContext context, string id, string expectedChangeVector, BlittableJsonReaderObject document, Nullable`1<long> lastModifiedTicks, ChangeVector changeVector, string oldChangeVectorForClusterTransactionIndexCheck, DocumentFlags newFlags, NonPersistentDocumentFlags nonPersistentFlags);
    [ConditionalAttribute("DEBUG")]
private static void ValidateDocument(string id, BlittableJsonReaderObject document, UInt64& documentDebugHash);
    [ConditionalAttribute("DEBUG")]
private static void ValidateDocumentHash(string id, BlittableJsonReaderObject document, ulong documentDebugHash);
    protected virtual void CalculateSuffixForIdentityPartsSeparator(string id, Char*& idSuffixPtr, Int32& idSuffixLength, Int32& idLength);
    protected virtual void WriteSuffixForIdentityPartsSeparator(Char*& valueWritePosition, Char* idSuffixPtr, int idSuffixLength);
    private string BuildDocumentId(string id, long newEtag, Boolean& knownNewId);
    [DoesNotReturnAttribute]
private static void ThrowInvalidDocumentId(string id);
    private void Recreate(DocumentsOperationContext context, string id, BlittableJsonReaderObject oldDoc, BlittableJsonReaderObject& document, DocumentFlags& flags, NonPersistentDocumentFlags nonPersistentFlags, UInt64& documentDebugHash);
    private bool RecreateIfNeeded(DocumentsOperationContext context, string docId, BlittableJsonReaderObject oldDoc, BlittableJsonReaderObject document, DocumentFlags& flags, NonPersistentDocumentFlags nonPersistentFlags, IRecreationType type);
    private static bool TryGetMetadata(BlittableJsonReaderObject document, IRecreationType type, BlittableJsonReaderObject& metadata, BlittableJsonReaderArray& current);
    [DoesNotReturnAttribute]
public static void ThrowRequiresTransaction(string caller);
    [DoesNotReturnAttribute]
private static void ThrowConcurrentExceptionOnMissingDoc(string id, string expectedChangeVector);
    [DoesNotReturnAttribute]
private static void ThrowInvalidCollectionNameChange(string id, CollectionName oldCollectionName, CollectionName collectionName);
    [DoesNotReturnAttribute]
private static void ThrowConcurrentException(string id, string expectedChangeVector, string oldChangeVector);
    private void DeleteTombstoneIfNeeded(DocumentsOperationContext context, CollectionName collectionName, Byte* lowerId, int lowerSize);
    public void DeleteTombstoneIfNeeded(DocumentsOperationContext context, CollectionName collectionName, Slice id);
    private static void DeleteTombstone(Table tombstoneTable, Slice id);
    [ConditionalAttribute("DEBUG")]
public static void AssertMetadataWasFiltered(BlittableJsonReaderObject data);
    [CompilerGeneratedAttribute]
internal static bool <RecreateIfNeeded>g__RecreatePreserveCasing|14_0(BlittableJsonReaderArray currentMetadata, DocumentFlags& documentFlags, <>c__DisplayClass14_0& );
}
public class Raven.Server.Documents.DocumentsStorage : object {
    public TableSchema DocsSchema;
    public TableSchema CompressedDocsSchema;
    public TableSchema TombstonesSchema;
    protected TableSchema AttachmentsSchema;
    protected TableSchema ConflictsSchema;
    public TableSchema CountersSchema;
    public TableSchema CounterTombstonesSchema;
    protected TableSchema TimeSeriesSchema;
    protected TableSchema TimeSeriesDeleteRangesSchema;
    public TableSchema RevisionsSchema;
    public TableSchema CompressedRevisionsSchema;
    public static TableSchema CollectionsSchema;
    public DocumentDatabase DocumentDatabase;
    public DocumentsContextPool ContextPool;
    public RevisionsStorage RevisionsStorage;
    public ExpirationStorage ExpirationStorage;
    public RefreshStorage RefreshStorage;
    public DataArchivalStorage DataArchivalStorage;
    public ConflictsStorage ConflictsStorage;
    public AttachmentsStorage AttachmentsStorage;
    public CountersStorage CountersStorage;
    public TimeSeriesStorage TimeSeriesStorage;
    public DocumentPutAction DocumentPut;
    [CompilerGeneratedAttribute]
private StorageEnvironment <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Transaction> <OnBeforeCommit>k__BackingField;
    protected Dictionary`2<string, CollectionName> _collectionsCache;
    private static Slice LastReplicatedEtagsSlice;
    private static Slice EtagsSlice;
    private static Slice LastEtagSlice;
    private static Slice LastCompletedClusterTransactionIndexSlice;
    private static Slice GlobalTreeSlice;
    private static Slice GlobalChangeVectorSlice;
    private static Slice GlobalFullChangeVectorSlice;
    private Action`2<LogMode, string> _addToInitLog;
    private Logger _logger;
    private string _name;
    private long _lastEtag;
    private DocumentTransactionCache _documentsMetadataCache;
    internal HashSet`1<string> UnusedDatabaseIds;
    internal TestingStuff _forTestingPurposes;
    private static int ConflictedTombstoneOverhead;
    public StorageEnvironment Environment { get; private set; }
    public Action`1<Transaction> OnBeforeCommit { get; protected set; }
    public Debugging ForDebug { get; }
    private static DocumentsStorage();
    public DocumentsStorage(DocumentDatabase documentDatabase, Action`2<LogMode, string> addToInitLog);
    [CompilerGeneratedAttribute]
public StorageEnvironment get_Environment();
    [CompilerGeneratedAttribute]
private void set_Environment(StorageEnvironment value);
    [CompilerGeneratedAttribute]
public Action`1<Transaction> get_OnBeforeCommit();
    [CompilerGeneratedAttribute]
protected void set_OnBeforeCommit(Action`1<Transaction> value);
    protected virtual void SetDocumentsStorageSchemas();
    public sealed virtual void Dispose();
    public void Initialize(bool generateNewDatabaseId);
    public static StorageEnvironmentOptions GetStorageEnvironmentOptionsFromConfiguration(RavenConfiguration config, IoChangesNotifications ioChanges, CatastrophicFailureNotification catastrophicFailureNotification);
    private void Initialize(StorageEnvironmentOptions options);
    protected virtual DocumentPutAction CreateDocumentPutAction();
    private void SetTransactionCache(LowLevelTransaction tx);
    private void ComputeTransactionCache_BeforeCommit(LowLevelTransaction llt);
    private void UpdateDocumentTransactionCache(LowLevelTransaction obj);
    public static ChangeVector GetDatabaseChangeVector(DocumentsOperationContext context);
    public static string GetDatabaseChangeVector(Transaction tx);
    public bool HasUnusedDatabaseIds();
    public ValueTuple`2<ChangeVector, long> GetNewChangeVector(DocumentsOperationContext context);
    public ChangeVector GetNewChangeVector(DocumentsOperationContext context, long newEtag);
    public void SetDatabaseChangeVector(DocumentsOperationContext context, ChangeVector changeVector);
    public static string GetFullDatabaseChangeVector(DocumentsOperationContext context);
    public void SetFullDatabaseChangeVector(DocumentsOperationContext context, string changeVector);
    [ConditionalAttribute("DEBUG")]
private static void ThrowOnNotUpdatedChangeVector(DocumentsOperationContext context, ChangeVector changeVector);
    public static long ReadLastDocumentEtag(Transaction tx);
    public static long ReadLastTombstoneEtag(Transaction tx);
    public static long ReadLastConflictsEtag(Transaction tx);
    public static long ReadLastRevisionsEtag(Transaction tx);
    public long ReadLastAttachmentsEtag(Transaction tx);
    public static long ReadLastCountersEtag(Transaction tx);
    public static long ReadLastTimeSeriesEtag(Transaction tx);
    private static long ReadLastEtagFrom(Transaction tx, Slice name);
    public long ReadLastEtag(Transaction tx);
    public static long ReadLastCompletedClusterTransactionIndex(Transaction tx);
    public void SetLastCompletedClusterTransactionIndex(DocumentsOperationContext context, long index);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocumentsStartingWith>d__76")]
public IEnumerable`1<Document> GetDocumentsStartingWith(DocumentsOperationContext context, string idPrefix, string startAfterId, long start, long take, string collection, Reference`1<long> skippedResults, DocumentFields fields, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocumentsStartingWith>d__77")]
public IEnumerable`1<Document> GetDocumentsStartingWith(DocumentsOperationContext context, string idPrefix, string matches, string exclude, string startAfterId, long start, long take, Reference`1<long> skip, DocumentFields fields, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocumentsInReverseEtagOrder>d__78")]
public IEnumerable`1<Document> GetDocumentsInReverseEtagOrder(DocumentsOperationContext context, long start, long take);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocumentsInReverseEtagOrderFrom>d__79")]
public IEnumerable`1<Document> GetDocumentsInReverseEtagOrderFrom(DocumentsOperationContext context, long etag, long take, long skip);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocumentsInReverseEtagOrder>d__80")]
public IEnumerable`1<Document> GetDocumentsInReverseEtagOrder(DocumentsOperationContext context, string collection, long start, long take);
    internal TestingStuff ForTestingPurposesOnly();
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocumentsFrom>d__84")]
public IEnumerable`1<Document> GetDocumentsFrom(DocumentsOperationContext context, long etag, long start, long take, DocumentFields fields, EventHandler`1<InvalidOperationException> onCorruptedDataHandler);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocumentsFrom>d__85")]
public IEnumerable`1<DocumentReplicationItem> GetDocumentsFrom(DocumentsOperationContext context, long etag, DocumentFields fields);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocuments>d__86")]
public IEnumerable`1<Document> GetDocuments(DocumentsOperationContext context, IEnumerable`1<Slice> ids, long start, long take);
    public IEnumerable`1<Document> GetDocuments(DocumentsOperationContext context, IEnumerable`1<string> ids, long start, long take);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocumentsForCollection>d__88")]
public IEnumerable`1<Document> GetDocumentsForCollection(DocumentsOperationContext context, IEnumerable`1<Slice> ids, string collection, long start, long take);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocumentsFrom>d__89")]
public IEnumerable`1<Document> GetDocumentsFrom(DocumentsOperationContext context, string collection, long etag, long start, long take, DocumentFields fields);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetDocumentsFrom>d__90")]
public IEnumerable`1<Document> GetDocumentsFrom(DocumentsOperationContext context, List`1<string> collections, long etag, long take);
    public DocumentOrTombstone GetDocumentOrTombstone(DocumentsOperationContext context, string id, DocumentFields fields, bool throwOnConflict);
    public DocumentOrTombstone GetDocumentOrTombstone(DocumentsOperationContext context, Slice lowerId, DocumentFields fields, bool throwOnConflict);
    public Document Get(DocumentsOperationContext context, ReadOnlyMemory`1<char> id, DocumentFields fields, bool throwOnConflict);
    public Document Get(DocumentsOperationContext context, string id, DocumentFields fields, bool throwOnConflict);
    public Document Get(DocumentsOperationContext context, Slice lowerId, DocumentFields fields, bool throwOnConflict, bool skipValidationInDebug);
    public Document GetByEtag(DocumentsOperationContext context, long etag);
    public Tombstone GetTombstoneByEtag(DocumentsOperationContext context, long etag);
    public long GetNumberOfTombstones(DocumentsOperationContext context);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetAllIds>d__100")]
public IEnumerable`1<string> GetAllIds(DocumentsOperationContext context);
    public Nullable`1<ValueTuple`3<int, int, bool>> GetDocumentMetrics(DocumentsOperationContext context, string id);
    public bool GetTableValueReaderForDocument(DocumentsOperationContext context, Slice lowerId, bool throwOnConflict, TableValueReader& tvr);
    public bool HasMoreOfTombstonesAfter(DocumentsOperationContext context, long etag, int maxAllowed);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetTombstonesFrom>d__104")]
public IEnumerable`1<Tombstone> GetTombstonesFrom(DocumentsOperationContext context, long etag, long start, long take);
    public GetTombstonesPreviewResult GetTombstonesPreviewResult(DocumentsOperationContext context, long etag, long start, long take);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetTombstonesInReverseEtagOrderFrom>d__106")]
public IEnumerable`1<Tombstone> GetTombstonesInReverseEtagOrderFrom(DocumentsOperationContext context, long etag, long start, long take);
    public Tombstone GetTombstoneAtOrBefore(DocumentsOperationContext context, long etag);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetTombstonesFrom>d__108")]
public IEnumerable`1<ReplicationBatchItem> GetTombstonesFrom(DocumentsOperationContext context, long etag, bool revisionTombstonesWithId);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetAttachmentTombstonesFrom>d__109")]
public IEnumerable`1<Tombstone> GetAttachmentTombstonesFrom(DocumentsOperationContext context, long etag, long start, long take);
    private Table GetTombstoneTableForCollection(DocumentsOperationContext context, string collection);
    public long TombstonesCountForCollection(DocumentsOperationContext context, string collection);
    public long TombstonesSizeForCollectionInBytes(DocumentsOperationContext context, string collection);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetTombstonesFrom>d__113")]
public IEnumerable`1<Tombstone> GetTombstonesFrom(DocumentsOperationContext context, string collection, long etag, long start, long take);
    public long GetLastDocumentEtag(Transaction tx, string collection);
    public string GetLastDocumentChangeVector(Transaction tx, JsonOperationContext ctx, string collection);
    private bool LastDocument(Transaction transaction, string collection, TableValueHolder& result);
    private bool ReadLastDocument(Transaction transaction, CollectionName collectionName, CollectionTableType collectionType, TableValueHolder& result);
    public long GetLastTombstoneEtag(Transaction tx, string collection);
    public bool HasTombstonesWithEtagGreaterThanStartAndLowerThanOrEqualToEnd(DocumentsOperationContext context, string collection, long start, long end);
    internal Document TableValueToDocument(DocumentsOperationContext context, TableValueReader& tvr, DocumentFields fields, bool skipValidationInDebug);
    [ConditionalAttribute("DEBUG")]
public void AssertMetadataKey(string id, BlittableJsonReaderObject document, DocumentFlags flags, DocumentFlags assertionFlag, string assertionKey);
    private static Document ParseDocument(JsonOperationContext context, TableValueReader& tvr, DocumentFields fields);
    private static Document ParseDocumentPartial(JsonOperationContext context, TableValueReader& tvr, DocumentFields fields);
    public static Document ParseRawDataSectionDocumentWithValidation(JsonOperationContext context, TableValueReader& tvr, int expectedSize);
    public static Tombstone TableValueToTombstone(JsonOperationContext context, TableValueReader& tvr);
    public Nullable`1<DeleteOperationResult> Delete(DocumentsOperationContext context, string id, DocumentFlags flags);
    public Nullable`1<DeleteOperationResult> Delete(DocumentsOperationContext context, string id, string expectedChangeVector, DocumentFlags newFlags);
    public Nullable`1<DeleteOperationResult> Delete(DocumentsOperationContext context, Slice lowerId, string id, LazyStringValue expectedChangeVector, Nullable`1<long> lastModifiedTicks, ChangeVector changeVector, CollectionName collectionName, NonPersistentDocumentFlags nonPersistentFlags, DocumentFlags newFlags);
    public virtual void ValidateId(DocumentsOperationContext context, Slice lowerId, DocumentChangeTypes type, DocumentFlags documentFlags);
    [DoesNotReturnAttribute]
private static void ThrowConcurrencyException(string id, string expected, string actual);
    public long GetOrCreateLastModifiedTicks(Nullable`1<long> lastModifiedTicks);
    public long GenerateNextEtagForReplicatedTombstoneMissingDocument(DocumentsOperationContext context);
    public List`1<DeleteOperationResult> DeleteDocumentsStartingWith(DocumentsOperationContext context, string prefix, long maxDocsToDelete, Action`1<Document> beforeDeleted, DocumentFlags flags);
    public long GenerateNextEtag();
    internal void InitializeLastEtag(Transaction tx);
    public void EnsureLastEtagIsPersisted(DocumentsOperationContext context, long docEtag);
    public ValueTuple`2<long, string> CreateTombstone(DocumentsOperationContext context, Slice lowerId, long documentEtag, CollectionName collectionName, string docChangeVector, long lastModifiedTicks, ChangeVector changeVector, DocumentFlags flags, NonPersistentDocumentFlags nonPersistentFlags);
    [ConditionalAttribute("DEBUG")]
public static void FlagsProperlySet(DocumentFlags flags, ChangeVector changeVector);
    [ConditionalAttribute("DEBUG")]
private static void CheckFlagsProperlySet(DocumentFlags flags, string changeVector);
    private IDisposable ModifyLowerIdIfNeeded(DocumentsOperationContext context, Table table, Slice lowerId, Slice& nonConflictedLowerId);
    private static LazyStringValue UnwrapLowerIdIfNeeded(JsonOperationContext context, LazyStringValue lowerId);
    protected static int GetSizeOfTombstoneId(Byte* lowerId, int size);
    private static bool NeedToUnwrapLowerId(Byte* lowerId, int size);
    public static bool IsTombstoneOfId(Slice tombstoneKey, Slice lowerId);
    [DoesNotReturnAttribute]
private void ThrowNotSupportedExceptionForCreatingTombstoneWhenItExistsForDifferentCollection(Slice lowerId, CollectionName collectionName, CollectionName tombstoneCollectionName, VoronConcurrencyErrorException e);
    public void DeleteWithoutCreatingTombstone(DocumentsOperationContext context, string collection, long storageId, bool isTombstone);
    public PutOperationResults Put(DocumentsOperationContext context, string id, string expectedChangeVector, BlittableJsonReaderObject document, Nullable`1<long> lastModifiedTicks, string changeVector, string oldChangeVectorForClusterTransactionIndexCheck, DocumentFlags flags, NonPersistentDocumentFlags nonPersistentFlags);
    public long GetNumberOfDocumentsToProcess(DocumentsOperationContext context, string collection, long afterEtag, Int64& totalCount, Stopwatch overallDuration);
    public long GetNumberOfTombstonesToProcess(DocumentsOperationContext context, string collection, long afterEtag, Int64& totalCount, Stopwatch overallDuration);
    private long GetNumberOfItemsToProcess(DocumentsOperationContext context, string collection, long afterEtag, bool tombstones, Int64& totalCount, Stopwatch overallDuration);
    public long GetNumberOfDocuments();
    public long GetNumberOfDocuments(DocumentsOperationContext context);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetCollections>d__157")]
public IEnumerable`1<CollectionStats> GetCollections(DocumentsOperationContext context);
    public CollectionDetails GetCollectionDetails(DocumentsOperationContext context, string collection);
    private TableReport GetReportForTable(DocumentsOperationContext context, TableSchema schema, string name, bool blnDetailed);
    public CollectionStats GetCollection(string collection, DocumentsOperationContext context);
    public long DeleteTombstonesBefore(DocumentsOperationContext context, string collection, long etag, long numberOfEntriesToDelete);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetTombstoneCollections>d__162")]
public IEnumerable`1<string> GetTombstoneCollections(Transaction transaction);
    public ConflictStatus GetConflictStatus(DocumentsOperationContext context, string remote, string local, ChangeVectorMode mode);
    public ConflictStatus GetConflictStatus(DocumentsOperationContext context, string remote, string local, ChangeVectorMode mode, Boolean& skipValidation);
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<GetAllReplicatedEtags>d__165")]
public static IEnumerable`1<KeyValuePair`2<string, long>> GetAllReplicatedEtags(DocumentsOperationContext context);
    public static long GetLastReplicatedEtagFrom(DocumentsOperationContext context, string dbId);
    public static void SetLastReplicatedEtagFrom(DocumentsOperationContext context, string dbId, long etag);
    public CollectionName GetCollection(string collection, bool throwIfDoesNotExist);
    public CollectionName ExtractCollectionName(DocumentsOperationContext context, BlittableJsonReaderObject document);
    public CollectionName ExtractCollectionName(DocumentsOperationContext context, string collectionName);
    public ValueTuple`2<ChangeVector, NonPersistentDocumentFlags> BuildChangeVectorAndResolveConflicts(DocumentsOperationContext context, Slice lowerId, long newEtag, BlittableJsonReaderObject document, ChangeVector changeVector, string expectedChangeVector, DocumentFlags flags, ChangeVector oldChangeVector);
    public static bool UpdateLastDatabaseChangeVector(DocumentsOperationContext context, ChangeVector changeVector, DocumentFlags flags, NonPersistentDocumentFlags nonPersistentFlags);
    private ChangeVector SetDocumentChangeVectorForLocalChange(DocumentsOperationContext context, Slice lowerId, ChangeVector oldChangeVector, long newEtag);
    public DocumentFlags GetFlagsFromOldDocument(DocumentFlags newFlags, DocumentFlags oldFlags, NonPersistentDocumentFlags nonPersistentFlags);
    public static InternalScope<ByteStringMemoryCache> GetEtagAsSlice(DocumentsOperationContext context, long etag, Slice& slice);
    [DoesNotReturnAttribute]
private static void ThrowNoActiveTransactionException();
    [IteratorStateMachineAttribute("Raven.Server.Documents.DocumentsStorage/<IterateCollectionNames>d__177")]
private IEnumerable`1<string> IterateCollectionNames(Transaction tx, JsonOperationContext context);
    private Dictionary`2<string, CollectionName> ReadCollections(Transaction tx);
    public static Dictionary`2<string, CollectionName> ReadCollections(Transaction tx, JsonOperationContext context);
    public static long TableValueToEtag(int index, TableValueReader& tvr);
    public static long TableValueToLong(int index, TableValueReader& tvr);
    public static DocumentFlags TableValueToFlags(int index, TableValueReader& tvr);
    public static short TableValueToShort(int index, string name, TableValueReader& tvr);
    [DoesNotReturnAttribute]
private static void ThrowInvalidTagLength();
    [DoesNotReturnAttribute]
private static void ThrowInvalidShortSize(string name, int size);
    public static DateTime TableValueToDateTime(int index, TableValueReader& tvr);
    public static LazyStringValue TableValueToString(JsonOperationContext context, int index, TableValueReader& tvr);
    public static string TableValueToChangeVector(JsonOperationContext context, int index, TableValueReader& tvr);
    public static ChangeVector TableValueToChangeVector(DocumentsOperationContext context, int index, TableValueReader& tvr);
    public static LazyStringValue TableValueToId(JsonOperationContext context, int index, TableValueReader& tvr);
    public static InternalScope<ByteStringMemoryCache> TableValueToSlice(DocumentsOperationContext context, int index, TableValueReader& tvr, Slice& slice);
    public Debugging get_ForDebug();
    [CompilerGeneratedAttribute]
private void <Dispose>b__47_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__47_1();
    [CompilerGeneratedAttribute]
internal static bool <GetDocumentsStartingWith>g__IsCollectionMatch|76_0(Document doc, <>c__DisplayClass76_0& , <>c__DisplayClass76_1& );
}
public class Raven.Server.Documents.DocumentsTransaction : RavenTransaction {
    private DocumentsOperationContext _context;
    private DocumentsChanges _changes;
    private List`1<DocumentChange> _documentNotifications;
    private List`1<CounterChange> _counterNotifications;
    private List`1<TimeSeriesChange> _timeSeriesNotifications;
    private List`1<Slice> _attachmentHashesToMaybeDelete;
    private bool _executeDocumentsMigrationAfterCommit;
    private bool _replaced;
    private Dictionary`2<string, CollectionName> _collectionCache;
    private bool _isDisposed;
    public DocumentsTransaction(DocumentsOperationContext context, Transaction transaction, DocumentsChanges changes);
    public virtual void BeforeCommit();
    protected virtual void AfterCommit();
    public DocumentsTransaction BeginAsyncCommitAndStartNewTransaction(DocumentsOperationContext context);
    public void AddAfterCommitNotification(DocumentChange change);
    public void AddAfterCommitNotification(CounterChange change);
    public void AddAfterCommitNotification(TimeSeriesChange change);
    public virtual void Dispose();
    protected virtual void RaiseNotifications();
    protected virtual bool ShouldRaiseNotifications();
    public bool TryGetFromCache(string collectionName, CollectionName& name);
    public void AddToCache(string collectionName, CollectionName name);
    public void ForgetAbout(Document doc);
    internal void CheckIfShouldDeleteAttachmentStream(Slice hash);
    internal void ExecuteDocumentsMigrationAfterCommit();
}
[ExtensionAttribute]
public static class Raven.Server.Documents.EnumExtensions : object {
    [ExtensionAttribute]
public static bool Contain(DocumentFields current, DocumentFields flag);
    [ExtensionAttribute]
public static bool Contain(DocumentFlags current, DocumentFlags flag);
    [ExtensionAttribute]
public static DocumentFlags Strip(DocumentFlags current, DocumentFlags flag);
    [ExtensionAttribute]
public static bool Contain(NonPersistentDocumentFlags current, NonPersistentDocumentFlags flag);
    [ExtensionAttribute]
public static bool Contain(DatabaseRecordItemType current, DatabaseRecordItemType flag);
}
public enum Raven.Server.Documents.ETL.EtlItemType : Enum {
    public int value__;
    public static EtlItemType None;
    public static EtlItemType Document;
    public static EtlItemType CounterGroup;
    public static EtlItemType TimeSeries;
}
public class Raven.Server.Documents.ETL.EtlLoader : object {
    private static string AlertTitle;
    private EtlProcess[] _processes;
    private HashSet`1<string> _uniqueConfigurationNames;
    private DatabaseRecord _databaseRecord;
    private object _loadProcessedLock;
    private DocumentDatabase _database;
    private ServerStore _serverStore;
    private bool _isSubscribedToDocumentChanges;
    private bool _isSubscribedToCounterChanges;
    private bool _isSubscribedToTimeSeriesChanges;
    private Logger Logger;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<ValueTuple`3<string, string, EtlProcessStatistics>> BatchCompleted;
    public List`1<RavenEtlConfiguration> RavenDestinations;
    public List`1<SqlEtlConfiguration> SqlDestinations;
    public List`1<OlapEtlConfiguration> OlapDestinations;
    public List`1<ElasticSearchEtlConfiguration> ElasticSearchDestinations;
    public List`1<QueueEtlConfiguration> QueueDestinations;
    [CompilerGeneratedAttribute]
private Action`1<EtlProcess> ProcessAdded;
    [CompilerGeneratedAttribute]
private Action`1<EtlProcess> ProcessRemoved;
    public EtlProcess[] Processes { get; }
    public string TombstoneCleanerIdentifier { get; }
    public EtlLoader(DocumentDatabase database, ServerStore serverStore);
    [CompilerGeneratedAttribute]
public void add_BatchCompleted(Action`1<ValueTuple`3<string, string, EtlProcessStatistics>> value);
    [CompilerGeneratedAttribute]
public void remove_BatchCompleted(Action`1<ValueTuple`3<string, string, EtlProcessStatistics>> value);
    public void OnBatchCompleted(string configurationName, string transformationName, EtlProcessStatistics statistics);
    public EtlProcess[] get_Processes();
    public long GetQueueDestinationCountByBroker(QueueBrokerType brokerType);
    public void Initialize(DatabaseRecord record);
    [CompilerGeneratedAttribute]
public void add_ProcessAdded(Action`1<EtlProcess> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessAdded(Action`1<EtlProcess> value);
    [CompilerGeneratedAttribute]
public void add_ProcessRemoved(Action`1<EtlProcess> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessRemoved(Action`1<EtlProcess> value);
    private void OnProcessAdded(EtlProcess process);
    private void OnProcessRemoved(EtlProcess process);
    private void LoadProcesses(DatabaseRecord record, List`1<RavenEtlConfiguration> newRavenDestinations, List`1<SqlEtlConfiguration> newSqlDestinations, List`1<OlapEtlConfiguration> newOlapDestinations, List`1<ElasticSearchEtlConfiguration> newElasticSearchDestinations, List`1<QueueEtlConfiguration> newQueueDestinations, List`1<EtlProcess> toRemove, Dictionary`2<string, string> responsibleNodes, List`1<string> explanations);
    private void HandleChangesSubscriptions();
    [IteratorStateMachineAttribute("Raven.Server.Documents.ETL.EtlLoader/<GetRelevantProcesses>d__35`2")]
private IEnumerable`1<EtlProcess> GetRelevantProcesses(List`1<T> configurations, HashSet`1<string> uniqueNames);
    public static EtlProcessState GetProcessState(List`1<Transformation> configTransforms, DocumentDatabase database, string configurationName);
    [DoesNotReturnAttribute]
public static void ThrownUnknownEtlConfiguration(Type type);
    private bool ValidateConfiguration(EtlConfiguration`1<T> config, HashSet`1<string> uniqueNames);
    private void LogConfigurationError(EtlConfiguration`1<T> config, List`1<string> errors);
    private void LogConfigurationWarning(EtlConfiguration`1<T> config, List`1<string> warnings);
    private void OnCounterChange(CounterChange change);
    private void OnDocumentChange(DocumentChange change);
    private void OnTimeSeriesChange(TimeSeriesChange change);
    private void NotifyAboutWork(DatabaseChange change);
    public sealed virtual void Dispose();
    private bool IsMyEtlTask(DatabaseRecord record, T etlTask, Dictionary`2& responsibleNodes, List`1& explanations);
    public void HandleDatabaseRecordChange(DatabaseRecord record);
    private void LogLongRunningDisposeIfNeeded(Stopwatch sp, string processName);
    private static string GetStopReason(EtlProcess process, List`1<RavenEtlConfiguration> myRavenEtl, List`1<SqlEtlConfiguration> mySqlEtl, List`1<OlapEtlConfiguration> myOlapEtl, List`1<ElasticSearchEtlConfiguration> myElasticSearchEtl, List`1<QueueEtlConfiguration> myQueueEtl, Dictionary`2<string, string> responsibleNodes, List`1<string> explanations);
    private string GetStartReason(Dictionary`2<string, string> responsibleNodes, List`1<string> explanations, EtlProcess process);
    public void HandleDatabaseValueChanged();
    public sealed virtual string get_TombstoneCleanerIdentifier();
    public sealed virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType tombstoneType);
    public sealed virtual Dictionary`2<TombstoneDeletionBlockageSource, HashSet`1<string>> GetDisabledSubscribersCollections(HashSet`1<string> tombstoneCollections);
    private void MarkDocumentTombstonesForDeletion(EtlConfiguration`1<T> config, Dictionary`2<string, long> lastProcessedTombstones);
    private void MarkTimeSeriesTombstonesForDeletion(EtlConfiguration`1<T> config, Dictionary`2<string, long> lastProcessedTombstones);
    private void MarkCounterTombstonesForDeletion(EtlConfiguration`1<T> config, Dictionary`2<string, long> lastProcessedTombstones);
    private void AddOrUpdate(Dictionary`2<string, long> dic, string key, long value);
}
public abstract class Raven.Server.Documents.ETL.EtlProcess : object {
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EtlSubType>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlProcessStatistics <Statistics>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlMetricsCountersManager <Metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransformationName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <FallbackTime>k__BackingField;
    public string Tag { get; protected set; }
    public EtlType EtlType { get; }
    public string EtlSubType { get; }
    public long TaskId { get; }
    public EtlProcessStatistics Statistics { get; protected set; }
    public EtlMetricsCountersManager Metrics { get; protected set; }
    public string Name { get; protected set; }
    public string ConfigurationName { get; protected set; }
    public string TransformationName { get; protected set; }
    public Nullable`1<TimeSpan> FallbackTime { get; protected set; }
    internal bool IsRunning { get; }
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
protected void set_Tag(string value);
    public abstract virtual EtlType get_EtlType();
    [CompilerGeneratedAttribute]
public virtual string get_EtlSubType();
    public abstract virtual long get_TaskId();
    [CompilerGeneratedAttribute]
public EtlProcessStatistics get_Statistics();
    [CompilerGeneratedAttribute]
protected void set_Statistics(EtlProcessStatistics value);
    [CompilerGeneratedAttribute]
public EtlMetricsCountersManager get_Metrics();
    [CompilerGeneratedAttribute]
protected void set_Metrics(EtlMetricsCountersManager value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
protected void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public string get_TransformationName();
    [CompilerGeneratedAttribute]
protected void set_TransformationName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_FallbackTime();
    [CompilerGeneratedAttribute]
protected void set_FallbackTime(Nullable`1<TimeSpan> value);
    public abstract virtual void Start(string reason);
    public abstract virtual void Stop(string reason);
    public abstract virtual void Dispose();
    public abstract virtual void Reset();
    public abstract virtual void NotifyAboutWork(DatabaseChange change);
    public abstract virtual bool ShouldTrackCounters();
    public abstract virtual bool ShouldTrackTimeSeries();
    public virtual bool ShouldTrackDocumentTombstones();
    public abstract virtual EtlPerformanceStats[] GetPerformanceStats();
    public abstract virtual IEtlStatsAggregator GetLatestPerformanceStats();
    public abstract virtual OngoingTaskConnectionStatus GetConnectionStatus();
    public abstract virtual EtlProcessProgress GetProgress(DocumentsOperationContext documentsContext);
    internal abstract virtual bool get_IsRunning();
    public static EtlProcessState GetProcessState(DocumentDatabase database, string configurationName, string transformationName);
}
public abstract class Raven.Server.Documents.ETL.EtlProcess`6 : EtlProcess {
    private static Size DefaultMaximumMemoryAllocation;
    internal static int MinBatchSize;
    protected ManualResetEventSlim _waitForChanges;
    private CancellationTokenSource _cts;
    private HashSet`1<string> _collections;
    private ConcurrentQueue`1<IEtlStatsAggregator> _lastEtlStats;
    private Size _currentMaximumAllowedMemory;
    private ThreadStats _threadAllocations;
    private LongRunningWork _longRunningWork;
    private MultipleUseFlag _lowMemoryFlag;
    private IEtlStatsAggregator _lastStats;
    private int _statsId;
    private TestMode<TExtracted, TTransformed, TConfiguration, TConnectionString, TStatsScope, TEtlPerformanceOperation> _testMode;
    protected Transformation Transformation;
    protected Logger Logger;
    protected DocumentDatabase Database;
    protected EtlProcessState LastProcessState;
    private ServerStore _serverStore;
    public TConfiguration Configuration;
    internal bool IsRunning { get; }
    protected CancellationToken CancellationToken { get; }
    public long TaskId { get; }
    protected EtlProcess`6(Transformation transformation, TConfiguration configuration, DocumentDatabase database, ServerStore serverStore, string tag);
    private static EtlProcess`6();
    internal virtual bool get_IsRunning();
    protected CancellationToken get_CancellationToken();
    protected abstract virtual IEnumerator`1<TExtracted> ConvertDocsEnumerator(DocumentsOperationContext context, IEnumerator`1<Document> docs, string collection);
    protected abstract virtual IEnumerator`1<TExtracted> ConvertTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, string collection, bool trackAttachments);
    protected abstract virtual IEnumerator`1<TExtracted> ConvertAttachmentTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, List`1<string> collections);
    protected abstract virtual IEnumerator`1<TExtracted> ConvertCountersEnumerator(DocumentsOperationContext context, IEnumerator`1<CounterGroupDetail> counters, string collection);
    protected abstract virtual IEnumerator`1<TExtracted> ConvertTimeSeriesEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesSegmentEntry> timeSeries, string collection);
    protected abstract virtual IEnumerator`1<TExtracted> ConvertTimeSeriesDeletedRangeEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesDeletedRangeItem> timeSeries, string collection);
    protected abstract virtual bool ShouldTrackAttachmentTombstones();
    public virtual long get_TaskId();
    private void Extract(DocumentsOperationContext context, ExtractedItemsEnumerator`3<TExtracted, TStatsScope, TEtlPerformanceOperation> merged, long fromEtag, EtlItemType type, AbstractEtlStatsScope`2<TStatsScope, TEtlPerformanceOperation> stats, DisposableScope scope);
    private void ExtractDocuments(DocumentsOperationContext context, ExtractedItemsEnumerator`3<TExtracted, TStatsScope, TEtlPerformanceOperation> merged, long fromEtag, AbstractEtlStatsScope`2<TStatsScope, TEtlPerformanceOperation> stats, DisposableScope scope);
    private void ExtractCounters(DocumentsOperationContext context, ExtractedItemsEnumerator`3<TExtracted, TStatsScope, TEtlPerformanceOperation> merged, long fromEtag, AbstractEtlStatsScope`2<TStatsScope, TEtlPerformanceOperation> stats, DisposableScope scope);
    private void ExtractTimeSeries(DocumentsOperationContext context, ExtractedItemsEnumerator`3<TExtracted, TStatsScope, TEtlPerformanceOperation> merged, long fromEtag, AbstractEtlStatsScope`2<TStatsScope, TEtlPerformanceOperation> stats, DisposableScope scope);
    protected abstract virtual EtlTransformer`4<TExtracted, TTransformed, TStatsScope, TEtlPerformanceOperation> GetTransformer(DocumentsOperationContext context);
    public IEnumerable`1<TTransformed> Transform(IEnumerable`1<TExtracted> items, DocumentsOperationContext context, TStatsScope stats, EtlProcessState state);
    private void HandleTransformationScriptParseException(TStatsScope stats, Exception e);
    public bool Load(IEnumerable`1<TTransformed> items, DocumentsOperationContext context, TStatsScope stats);
    private void EnterFallbackMode(Nullable`1<DateTime> lastErrorTime);
    protected abstract virtual int LoadInternal(IEnumerable`1<TTransformed> items, DocumentsOperationContext context, TStatsScope scope);
    private bool CanContinueBatch(TStatsScope stats, TExtracted currentItem, int batchSize, DocumentsOperationContext ctx);
    protected void UpdateMetrics(DateTime startTime, TStatsScope stats);
    public virtual void Reset();
    public virtual void NotifyAboutWork(DatabaseChange change);
    public virtual void Start(string reason);
    public virtual void Stop(string reason);
    protected virtual void OnProcessStopped();
    private void ReportStopReasonToStats(string msg);
    protected abstract virtual TStatsScope CreateScope(EtlRunStats stats);
    public void Run();
    private static void RecordSuccessfulBatch(TStatsScope stats);
    protected void UpdateEtlProcessState(EtlProcessState state, Nullable`1<DateTime> lastBatchTime);
    private void PauseIfCpuCreditsBalanceIsTooLow();
    protected abstract virtual bool ShouldFilterOutHiLoDocument();
    protected virtual void AfterAllBatchesCompleted(DateTime lastBatchTime);
    private static bool AlreadyLoadedByDifferentNode(ExtractedItem item, EtlProcessState state);
    protected void EnsureThreadAllocationStats();
    private void AddPerformanceStats(IEtlStatsAggregator stats);
    public virtual EtlPerformanceStats[] GetPerformanceStats();
    public virtual IEtlStatsAggregator GetLatestPerformanceStats();
    private void LogSuccessfulBatchInfo(AbstractEtlStatsScope`2<TStatsScope, TEtlPerformanceOperation> stats);
    public virtual OngoingTaskConnectionStatus GetConnectionStatus();
    public static TestEtlScriptResult TestScript(TestEtlScript`2<TC, TCS> testScript, DocumentDatabase database, ServerStore serverStore, DocumentsOperationContext context);
    private IDisposable EnterTestMode(List`1& debugOutput);
    public virtual EtlProcessProgress GetProgress(DocumentsOperationContext documentsContext);
    public virtual void Dispose();
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    [CompilerGeneratedAttribute]
private void <Dispose>b__68_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__68_1();
    [CompilerGeneratedAttribute]
private void <Dispose>b__68_2();
}
public class Raven.Server.Documents.ETL.EtlProcessStatistics : object {
    private string _processTag;
    private string _processName;
    private DatabaseNotificationCenter _notificationCenter;
    private EnsureAlerts _alertsGuard;
    private bool _preventFromAddingAlertsToNotificationCenter;
    [CompilerGeneratedAttribute]
private string <LastChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastProcessedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastTransformationErrorTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastLoadErrorTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransformationErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransformationSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoadErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoadSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoadSuccessesInCurrentBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private AlertRaised <LastAlert>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlErrorsDetails <TransformationErrorsInCurrentBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlErrorsDetails <LastLoadErrorsInCurrentBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private SlowSqlDetails <LastSlowSqlWarningsInCurrentBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasLatestLoadSuccessful>k__BackingField;
    public string LastChangeVector { get; public set; }
    public long LastProcessedEtag { get; public set; }
    public Nullable`1<DateTime> LastTransformationErrorTime { get; private set; }
    public Nullable`1<DateTime> LastLoadErrorTime { get; private set; }
    private int TransformationErrors { get; private set; }
    private int TransformationSuccesses { get; private set; }
    public int LoadErrors { get; public set; }
    public int LoadSuccesses { get; private set; }
    public int LoadSuccessesInCurrentBatch { get; private set; }
    public AlertRaised LastAlert { get; public set; }
    public EtlErrorsDetails TransformationErrorsInCurrentBatch { get; }
    public EtlErrorsDetails LastLoadErrorsInCurrentBatch { get; }
    public SlowSqlDetails LastSlowSqlWarningsInCurrentBatch { get; }
    public bool WasLatestLoadSuccessful { get; public set; }
    public EtlProcessStatistics(string processTag, string processName, DatabaseNotificationCenter notificationCenter);
    [CompilerGeneratedAttribute]
public string get_LastChangeVector();
    [CompilerGeneratedAttribute]
public void set_LastChangeVector(string value);
    [CompilerGeneratedAttribute]
public long get_LastProcessedEtag();
    [CompilerGeneratedAttribute]
public void set_LastProcessedEtag(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastTransformationErrorTime();
    [CompilerGeneratedAttribute]
private void set_LastTransformationErrorTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastLoadErrorTime();
    [CompilerGeneratedAttribute]
private void set_LastLoadErrorTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
private int get_TransformationErrors();
    [CompilerGeneratedAttribute]
private void set_TransformationErrors(int value);
    [CompilerGeneratedAttribute]
private int get_TransformationSuccesses();
    [CompilerGeneratedAttribute]
private void set_TransformationSuccesses(int value);
    [CompilerGeneratedAttribute]
public int get_LoadErrors();
    [CompilerGeneratedAttribute]
public void set_LoadErrors(int value);
    [CompilerGeneratedAttribute]
public int get_LoadSuccesses();
    [CompilerGeneratedAttribute]
private void set_LoadSuccesses(int value);
    [CompilerGeneratedAttribute]
public int get_LoadSuccessesInCurrentBatch();
    [CompilerGeneratedAttribute]
private void set_LoadSuccessesInCurrentBatch(int value);
    [CompilerGeneratedAttribute]
public AlertRaised get_LastAlert();
    [CompilerGeneratedAttribute]
public void set_LastAlert(AlertRaised value);
    [CompilerGeneratedAttribute]
public EtlErrorsDetails get_TransformationErrorsInCurrentBatch();
    [CompilerGeneratedAttribute]
public EtlErrorsDetails get_LastLoadErrorsInCurrentBatch();
    [CompilerGeneratedAttribute]
public SlowSqlDetails get_LastSlowSqlWarningsInCurrentBatch();
    [CompilerGeneratedAttribute]
public bool get_WasLatestLoadSuccessful();
    [CompilerGeneratedAttribute]
public void set_WasLatestLoadSuccessful(bool value);
    public void TransformationSuccess();
    public IDisposable NewBatch();
    public void RecordTransformationError(Exception e, string documentId);
    public void RecordPartialLoadError(string error, string documentId, int count);
    public void ThrowLoadError(string error, int count);
    public void RecordSlowSql(SlowSqlStatementInfo slowSql);
    public void LoadSuccess(int items);
    private void CreateAlertIfAnyTransformationErrors(string preMessage);
    private void CreateAlertIfAnyLoadErrors(string preMessage);
    private void CreateAlertIfAnySlowSqls();
    public sealed virtual DynamicJsonValue ToJson();
    public virtual string ToString();
    public void Reset();
    public IDisposable PreventFromAddingAlertsToNotificationCenter();
    [CompilerGeneratedAttribute]
private void <PreventFromAddingAlertsToNotificationCenter>b__73_0();
}
public abstract class Raven.Server.Documents.ETL.EtlTransformer`4 : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    protected DocumentsOperationContext Context;
    private PatchRequest _mainScript;
    private PatchRequest _behaviorFunctions;
    protected SingleRun DocumentScript;
    protected SingleRun BehaviorsScript;
    protected TExtracted Current;
    private ReturnRun _returnMainRun;
    private ReturnRun _behaviorFunctionsRun;
    public DocumentDatabase Database { get; }
    protected String[] LoadToDestinations { get; }
    protected EtlTransformer`4(DocumentDatabase database, DocumentsOperationContext context, PatchRequest mainScript, PatchRequest behaviorFunctions);
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    public virtual void Initialize(bool debugMode);
    private JsValue LoadToFunctionTranslator(JsValue self, JsValue[] args);
    private JsValue LoadToFunctionTranslator(string name, JsValue self, JsValue[] args);
    protected abstract virtual void AddLoadedAttachment(JsValue reference, string name, Attachment attachment);
    protected abstract virtual void AddLoadedCounter(JsValue reference, string name, long value);
    protected abstract virtual void AddLoadedTimeSeries(JsValue reference, string name, IEnumerable`1<SingleResult> entries);
    private JsValue LoadAttachment(JsValue self, JsValue[] args);
    private static JsValue CreateLoadAttachmentReference(string attachmentName);
    private JsValue LoadCounter(JsValue self, JsValue[] args);
    private static JsValue CreateLoadCounterReference(string counterName);
    private JsValue LoadTimeSeries(JsValue self, JsValue[] args);
    private static JsValue CreateLoadTimeSeriesReference(string timeSeriesName, DateTime from, DateTime to);
    private JsValue GetAttachments(JsValue self, JsValue[] args);
    private JsValue HasAttachment(JsValue self, JsValue[] args);
    private JsValue GetCounters(JsValue self, JsValue[] args);
    private JsValue HasCounter(JsValue self, JsValue[] args);
    private JsValue GetTimeSeries(JsValue self, JsValue[] args);
    private JsValue HasTimeSeries(JsValue self, JsValue[] args);
    private JsValue GetRevisionsCount(JsValue self, JsValue[] args);
    protected abstract virtual String[] get_LoadToDestinations();
    protected abstract virtual void LoadToFunction(string tableName, ScriptRunnerResult colsAsObject);
    public abstract virtual IEnumerable`1<TTransformed> GetTransformedResults();
    public abstract virtual void Transform(TExtracted item, TStatsScope stats, EtlProcessState state);
    [DoesNotReturnAttribute]
public static void ThrowLoadParameterIsMandatory(string parameterName);
    [DoesNotReturnAttribute]
protected static void ThrowInvalidScriptMethodCall(string message);
    public sealed virtual void Dispose();
    public List`1<string> GetDebugOutput();
}
public abstract class Raven.Server.Documents.ETL.ExtractedItem : object {
    public bool Filtered;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private LazyStringValue <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Etag>k__BackingField;
    public string ChangeVector;
    [CompilerGeneratedAttribute]
private bool <IsDelete>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private LazyStringValue <CollectionFromMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlItemType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <CounterGroupDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesSegmentEntry <TimeSeriesSegmentEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesDeletedRangeItem <TimeSeriesDeletedRangeItem>k__BackingField;
    [CompilerGeneratedAttribute]
private LazyStringValue <CounterTombstoneId>k__BackingField;
    public Document Document { get; public set; }
    public LazyStringValue DocumentId { get; protected set; }
    public long Etag { get; protected set; }
    public bool IsDelete { get; protected set; }
    public string Collection { get; public set; }
    public LazyStringValue CollectionFromMetadata { get; }
    public EtlItemType Type { get; protected set; }
    public BlittableJsonReaderObject CounterGroupDocument { get; protected set; }
    public TimeSeriesSegmentEntry TimeSeriesSegmentEntry { get; protected set; }
    public TimeSeriesDeletedRangeItem TimeSeriesDeletedRangeItem { get; protected set; }
    public LazyStringValue CounterTombstoneId { get; protected set; }
    protected ExtractedItem(Document document, string collection, EtlItemType type);
    protected ExtractedItem(Tombstone tombstone, string collection, EtlItemType type);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(Document value);
    [CompilerGeneratedAttribute]
public LazyStringValue get_DocumentId();
    [CompilerGeneratedAttribute]
protected void set_DocumentId(LazyStringValue value);
    [CompilerGeneratedAttribute]
public long get_Etag();
    [CompilerGeneratedAttribute]
protected void set_Etag(long value);
    [CompilerGeneratedAttribute]
public bool get_IsDelete();
    [CompilerGeneratedAttribute]
protected void set_IsDelete(bool value);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public LazyStringValue get_CollectionFromMetadata();
    [CompilerGeneratedAttribute]
public EtlItemType get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(EtlItemType value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_CounterGroupDocument();
    [CompilerGeneratedAttribute]
protected void set_CounterGroupDocument(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public TimeSeriesSegmentEntry get_TimeSeriesSegmentEntry();
    [CompilerGeneratedAttribute]
protected void set_TimeSeriesSegmentEntry(TimeSeriesSegmentEntry value);
    [CompilerGeneratedAttribute]
public TimeSeriesDeletedRangeItem get_TimeSeriesDeletedRangeItem();
    [CompilerGeneratedAttribute]
protected void set_TimeSeriesDeletedRangeItem(TimeSeriesDeletedRangeItem value);
    [CompilerGeneratedAttribute]
public LazyStringValue get_CounterTombstoneId();
    [CompilerGeneratedAttribute]
protected void set_CounterTombstoneId(LazyStringValue value);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.ETL.ExtractedItemsEnumerator`3 : object {
    private List`1<IEnumerator`1<T>> _workEnumerators;
    private T _item;
    private TStatsScope _extractionStats;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ExtractedItemsEnumerator`3(AbstractEtlStatsScope`2<TStatsScope, TEtlPerformanceOperation> stats);
    public void AddEnumerator(IEnumerator`1<T> enumerator);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [IteratorStateMachineAttribute("Raven.Server.Documents.ETL.ExtractedItemsEnumerator`3/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Raven.Server.Documents.ETL.Handlers.EtlHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Handlers.EtlHandler/<Stats>d__0")]
[RavenActionAttribute("/databases/*/etl/stats", "GET", "3", "1", "False", "False", "True", "0")]
public Task Stats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Handlers.EtlHandler/<DebugStats>d__1")]
[RavenActionAttribute("/databases/*/etl/debug/stats", "GET", "3", "1", "False", "False", "True", "0")]
public Task DebugStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Handlers.EtlHandler/<Performance>d__2")]
[RavenActionAttribute("/databases/*/etl/performance", "GET", "3", "1", "False", "False", "True", "0")]
public Task Performance();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Handlers.EtlHandler/<PerformanceLive>d__3")]
[RavenActionAttribute("/databases/*/etl/performance/live", "GET", "3", "1", "False", "False", "True", "0")]
public Task PerformanceLive();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Handlers.EtlHandler/<Progress>d__4")]
[RavenActionAttribute("/databases/*/etl/progress", "GET", "3", "1", "False", "False", "True", "0")]
public Task Progress();
}
internal abstract class Raven.Server.Documents.ETL.Handlers.Processors.AbstractEtlHandlerProcessorForDebugStats`2 : AbstractHandlerProxyReadProcessor`3<EtlTaskDebugStats[], TRequestHandler, TOperationContext> {
    protected AbstractEtlHandlerProcessorForDebugStats`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<EtlTaskDebugStats[]> CreateCommandForNode(string nodeTag);
    protected StringValues GetNames();
}
internal abstract class Raven.Server.Documents.ETL.Handlers.Processors.AbstractEtlHandlerProcessorForPerformance`2 : AbstractHandlerProxyReadProcessor`3<EtlTaskPerformanceStats[], TRequestHandler, TOperationContext> {
    protected AbstractEtlHandlerProcessorForPerformance`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<EtlTaskPerformanceStats[]> CreateCommandForNode(string nodeTag);
    protected StringValues GetNames();
}
internal abstract class Raven.Server.Documents.ETL.Handlers.Processors.AbstractEtlHandlerProcessorForPerformanceLive`2 : AbstractHandlerWebSocketProxyProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractEtlHandlerProcessorForPerformanceLive`2(TRequestHandler requestHandler);
    protected virtual string GetRemoteEndpointUrl(string databaseName);
}
internal abstract class Raven.Server.Documents.ETL.Handlers.Processors.AbstractEtlHandlerProcessorForProgress`2 : AbstractHandlerProxyReadProcessor`3<EtlTaskProgress[], TRequestHandler, TOperationContext> {
    protected AbstractEtlHandlerProcessorForProgress`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<EtlTaskProgress[]> CreateCommandForNode(string nodeTag);
    protected StringValues GetNames();
}
internal abstract class Raven.Server.Documents.ETL.Handlers.Processors.AbstractEtlHandlerProcessorForStats`2 : AbstractHandlerProxyReadProcessor`3<EtlTaskStats[], TRequestHandler, TOperationContext> {
    protected AbstractEtlHandlerProcessorForStats`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<EtlTaskStats[]> CreateCommandForNode(string nodeTag);
    protected StringValues GetNames();
}
internal class Raven.Server.Documents.ETL.Handlers.Processors.EtlHandlerProcessorForDebugStats : AbstractEtlHandlerProcessorForDebugStats`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public EtlHandlerProcessorForDebugStats(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Handlers.Processors.EtlHandlerProcessorForDebugStats/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<EtlTaskDebugStats[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.ETL.Handlers.Processors.EtlHandlerProcessorForPerformance : AbstractEtlHandlerProcessorForPerformance`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public EtlHandlerProcessorForPerformance(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Handlers.Processors.EtlHandlerProcessorForPerformance/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<EtlTaskPerformanceStats[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.ETL.Handlers.Processors.EtlHandlerProcessorForPerformanceLive : AbstractEtlHandlerProcessorForPerformanceLive`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public EtlHandlerProcessorForPerformanceLive(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Handlers.Processors.EtlHandlerProcessorForPerformanceLive/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal class Raven.Server.Documents.ETL.Handlers.Processors.EtlHandlerProcessorForProgress : AbstractEtlHandlerProcessorForProgress`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public EtlHandlerProcessorForProgress(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Handlers.Processors.EtlHandlerProcessorForProgress/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<EtlTaskProgress[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.ETL.Handlers.Processors.EtlHandlerProcessorForStats : AbstractEtlHandlerProcessorForStats`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public EtlHandlerProcessorForStats(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Handlers.Processors.EtlHandlerProcessorForStats/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<EtlTaskStats[]> command, OperationCancelToken token);
    public static Dictionary`2<string, List`1<EtlProcess>> GetProcessesToReportOn(DocumentDatabase database, StringValues names);
}
public class Raven.Server.Documents.ETL.LiveEtlPerformanceCollector : DatabaseAwareLivePerformanceCollector`1<EtlTaskPerformanceStats> {
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, EtlProcessAndPerformanceStatsList>> _perEtlProcessStats;
    public LiveEtlPerformanceCollector(DocumentDatabase database, Dictionary`2<string, List`1<EtlProcess>> etls);
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.LiveEtlPerformanceCollector/<StartCollectingStats>d__2")]
protected virtual Task StartCollectingStats();
    private void EtlProcessRemoved(EtlProcess etl);
    private void ProcessAdded(EtlProcess etl);
    private void BatchCompleted(ValueTuple`3<string, string, EtlProcessStatistics> change);
    protected virtual List`1<EtlTaskPerformanceStats> PreparePerformanceStats();
    protected virtual void WriteStats(List`1<EtlTaskPerformanceStats> stats, AsyncBlittableJsonTextWriter writer, JsonOperationContext context);
}
public class Raven.Server.Documents.ETL.Metrics.EtlMetricsCountersManager : object {
    private Double[] _processedPerSecondRate;
    private int _index;
    [CompilerGeneratedAttribute]
private MeterMetric <BatchSizeMeter>k__BackingField;
    public MeterMetric BatchSizeMeter { get; protected set; }
    [CompilerGeneratedAttribute]
public MeterMetric get_BatchSizeMeter();
    [CompilerGeneratedAttribute]
protected void set_BatchSizeMeter(MeterMetric value);
    public void UpdateProcessedPerSecondRate(long batchSize, TimeSpan duration);
    public Nullable`1<double> GetProcessedPerSecondRate();
    public virtual DynamicJsonValue ToJson();
}
internal class Raven.Server.Documents.ETL.Providers.ElasticSearch.BlittableJsonElasticSerializer : Serializer {
    private DocumentsOperationContext _context;
    public DisposableAction SetContext(DocumentsOperationContext context);
    public virtual void Serialize(T data, Stream stream, SerializationFormatting formatting);
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.ElasticSearch.BlittableJsonElasticSerializer/<SerializeAsync>d__3`1")]
public virtual Task SerializeAsync(T data, Stream stream, SerializationFormatting formatting, CancellationToken cancellationToken);
    public virtual object Deserialize(Type type, Stream stream);
    public virtual T Deserialize(Stream stream);
    public virtual ValueTask`1<object> DeserializeAsync(Type type, Stream stream, CancellationToken cancellationToken);
    public virtual ValueTask`1<T> DeserializeAsync(Stream stream, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <SetContext>b__1_0();
}
internal class Raven.Server.Documents.ETL.Providers.ElasticSearch.ElasticSearchDocumentTransformer : EtlTransformer`4<ElasticSearchItem, ElasticSearchIndexWithRecords, EtlStatsScope, EtlPerformanceOperation> {
    private ElasticSearchEtlConfiguration _config;
    private Dictionary`2<string, ElasticSearchIndexWithRecords> _indexes;
    private List`1<ElasticSearchIndex> _indexesForScript;
    [CompilerGeneratedAttribute]
private String[] <LoadToDestinations>k__BackingField;
    protected String[] LoadToDestinations { get; }
    public ElasticSearchDocumentTransformer(Transformation transformation, DocumentDatabase database, DocumentsOperationContext context, ElasticSearchEtlConfiguration config);
    public virtual void Initialize(bool debugMode);
    protected virtual void AddLoadedAttachment(JsValue reference, string name, Attachment attachment);
    protected virtual void AddLoadedCounter(JsValue reference, string name, long value);
    protected virtual void AddLoadedTimeSeries(JsValue reference, string name, IEnumerable`1<SingleResult> entries);
    [CompilerGeneratedAttribute]
protected virtual String[] get_LoadToDestinations();
    protected virtual void LoadToFunction(string indexName, ScriptRunnerResult document);
    [PreserveBaseOverridesAttribute]
public virtual override List`1<ElasticSearchIndexWithRecords> GetTransformedResults();
    public virtual void Transform(ElasticSearchItem item, EtlStatsScope stats, EtlProcessState state);
    private ElasticSearchIndexWithRecords GetOrAdd(string indexName);
    [DoesNotReturnAttribute]
private static void ThrowIndexNotDefinedInConfig(string indexName);
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.ElasticSearchEtl : EtlProcess`6<ElasticSearchItem, ElasticSearchIndexWithRecords, ElasticSearchEtlConfiguration, ElasticSearchConnectionString, EtlStatsScope, EtlPerformanceOperation> {
    internal static string IndexBulkAction;
    internal static Byte[] IndexBulkActionBytes;
    private HashSet`1<string> _existingIndexes;
    public ElasticSearchEtlMetricsCountersManager ElasticSearchMetrics;
    public static string ElasticSearchEtlTag;
    private ElasticsearchClient _client;
    public EtlType EtlType { get; }
    public ElasticSearchEtl(Transformation transformation, ElasticSearchEtlConfiguration configuration, DocumentDatabase database, ServerStore serverStore);
    private static ElasticSearchEtl();
    public virtual EtlType get_EtlType();
    public virtual bool ShouldTrackCounters();
    public virtual bool ShouldTrackTimeSeries();
    protected virtual bool ShouldTrackAttachmentTombstones();
    protected virtual EtlStatsScope CreateScope(EtlRunStats stats);
    protected virtual bool ShouldFilterOutHiLoDocument();
    protected virtual IEnumerator`1<ElasticSearchItem> ConvertDocsEnumerator(DocumentsOperationContext context, IEnumerator`1<Document> docs, string collection);
    protected virtual IEnumerator`1<ElasticSearchItem> ConvertTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, string collection, bool trackAttachments);
    protected virtual IEnumerator`1<ElasticSearchItem> ConvertAttachmentTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, List`1<string> collections);
    protected virtual IEnumerator`1<ElasticSearchItem> ConvertCountersEnumerator(DocumentsOperationContext context, IEnumerator`1<CounterGroupDetail> counters, string collection);
    protected virtual IEnumerator`1<ElasticSearchItem> ConvertTimeSeriesEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesSegmentEntry> timeSeries, string collection);
    protected virtual IEnumerator`1<ElasticSearchItem> ConvertTimeSeriesDeletedRangeEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesDeletedRangeItem> timeSeries, string collection);
    protected virtual EtlTransformer`4<ElasticSearchItem, ElasticSearchIndexWithRecords, EtlStatsScope, EtlPerformanceOperation> GetTransformer(DocumentsOperationContext context);
    protected virtual int LoadInternal(IEnumerable`1<ElasticSearchIndexWithRecords> records, DocumentsOperationContext context, EtlStatsScope scope);
    internal static BlittableJsonReaderObject EnsureLowerCasedIndexIdProperty(DocumentsOperationContext context, BlittableJsonReaderObject json, ElasticSearchIndexWithRecords index);
    private int DeleteByQueryOnIndexIdProperty(ElasticSearchIndexWithRecords index);
    private void EnsureIndexExistsAndValidateIfNeeded(string indexName, ElasticSearchIndexWithRecords index);
    private void CreateDefaultIndex(string indexName, ElasticSearchIndexWithRecords index);
    internal static string LowerCaseDocumentIdProperty(LazyStringValue id);
    [DoesNotReturnAttribute]
private void ThrowElasticSearchLoadException(string message, ElasticsearchServerError serverError, Exception originalException, string debugInformation);
    public ElasticSearchEtlTestScriptResult RunTest(IEnumerable`1<ElasticSearchIndexWithRecords> records, DocumentsOperationContext context);
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.ElasticSearchEtlMetricsCountersManager : EtlMetricsCountersManager {
}
public static class Raven.Server.Documents.ETL.Providers.ElasticSearch.ElasticSearchHelper : object {
    public static ElasticsearchClient CreateClient(ElasticSearchConnectionString connectionString, Nullable`1<TimeSpan> requestTimeout, Nullable`1<TimeSpan> pingTimeout, bool useCustomBlittableSerializer);
}
public static class Raven.Server.Documents.ETL.Providers.ElasticSearch.ElasticSearchIndexValidator : object {
    private static int MaxIndexNameBytesLength;
    private static List`1<string> NotAllowedIndexNameCharacters;
    private static List`1<string> NotAllowedIndexNameStartCharacters;
    private static ElasticSearchIndexValidator();
    public static bool IsValidIndexName(string name, String& errorMessage);
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.ElasticSearchIndexWithRecords : ElasticSearchIndex {
    public List`1<ElasticSearchItem> Deletes;
    public List`1<ElasticSearchItem> Inserts;
    public ElasticSearchIndexWithRecords(ElasticSearchIndex index);
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.ElasticSearchIndexWriterSimulator : object {
    public IEnumerable`1<string> SimulateExecuteCommandText(ElasticSearchIndexWithRecords records, DocumentsOperationContext context);
    private string GenerateDeleteItemsCommandText(string indexName, string idField, List`1<ElasticSearchItem> elasticSearchItems);
    private IEnumerable`1<string> GenerateInsertItemsCommandText(string indexName, ElasticSearchIndexWithRecords index, DocumentsOperationContext context);
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.ElasticSearchItem : ExtractedItem {
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <TransformationResult>k__BackingField;
    public BlittableJsonReaderObject TransformationResult { get; public set; }
    public ElasticSearchItem(ElasticSearchItem item);
    public ElasticSearchItem(Document document, string collection);
    public ElasticSearchItem(Tombstone tombstone, string collection);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_TransformationResult();
    [CompilerGeneratedAttribute]
public void set_TransformationResult(BlittableJsonReaderObject value);
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.Enumerators.DocumentsToElasticSearchItems : object {
    private string _collection;
    private IEnumerator`1<Document> _docs;
    [CompilerGeneratedAttribute]
private ElasticSearchItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public ElasticSearchItem Current { get; private set; }
    public DocumentsToElasticSearchItems(IEnumerator`1<Document> docs, string collection);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual ElasticSearchItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(ElasticSearchItem value);
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.Enumerators.TombstonesToElasticSearchItems : object {
    private string _collection;
    private IEnumerator`1<Tombstone> _tombstones;
    [CompilerGeneratedAttribute]
private ElasticSearchItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public ElasticSearchItem Current { get; private set; }
    public TombstonesToElasticSearchItems(IEnumerator`1<Tombstone> tombstones, string collection);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual ElasticSearchItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(ElasticSearchItem value);
    private bool Filter();
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.Handlers.ElasticSearchEtlConnectionHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.ElasticSearch.Handlers.ElasticSearchEtlConnectionHandler/<TestConnection>d__0")]
[RavenActionAttribute("/databases/*/admin/etl/elasticsearch/test-connection", "POST", "2", "False", "False", "True", "0")]
public Task TestConnection();
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.Handlers.ElasticSearchEtlHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.ElasticSearch.Handlers.ElasticSearchEtlHandler/<Test>d__0")]
[RavenActionAttribute("/databases/*/admin/etl/elasticsearch/test", "POST", "2", "False", "False", "True", "0")]
public Task Test();
}
internal class Raven.Server.Documents.ETL.Providers.ElasticSearch.Handlers.Processors.ElasticSearchEtlConnectionHandlerForTestConnection`1 : AbstractDatabaseHandlerProcessor`1<TOperationContext> {
    public ElasticSearchEtlConnectionHandlerForTestConnection`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.ElasticSearch.Handlers.Processors.ElasticSearchEtlConnectionHandlerForTestConnection`1/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.ETL.Providers.ElasticSearch.Handlers.Processors.ElasticSearchEtlHandlerProcessorForTest : AbstractDatabaseEtlHandlerProcessorForTest`3<TestElasticSearchEtlScript, ElasticSearchEtlConfiguration, ElasticSearchConnectionString> {
    public ElasticSearchEtlHandlerProcessorForTest(DatabaseRequestHandler requestHandler);
    protected virtual TestElasticSearchEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.Test.ElasticSearchEtlTestScriptResult : TestEtlScriptResult {
    [CompilerGeneratedAttribute]
private List`1<IndexSummary> <Summary>k__BackingField;
    public List`1<IndexSummary> Summary { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<IndexSummary> get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(List`1<IndexSummary> value);
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.Test.IndexSummary : object {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Commands>k__BackingField;
    public string IndexName { get; public set; }
    public String[] Commands { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public String[] get_Commands();
    [CompilerGeneratedAttribute]
public void set_Commands(String[] value);
}
public class Raven.Server.Documents.ETL.Providers.ElasticSearch.Test.TestElasticSearchEtlScript : TestEtlScript`2<ElasticSearchEtlConfiguration, ElasticSearchConnectionString> {
}
public class Raven.Server.Documents.ETL.Providers.OLAP.DocumentsToOlapItems : object {
    private IEnumerator`1<Document> _docs;
    private string _collection;
    [CompilerGeneratedAttribute]
private ToOlapItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public ToOlapItem Current { get; private set; }
    public DocumentsToOlapItems(IEnumerator`1<Document> docs, string collection);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual ToOlapItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(ToOlapItem value);
}
public class Raven.Server.Documents.ETL.Providers.OLAP.Handlers.OlapEtlHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.OLAP.Handlers.OlapEtlHandler/<PostScriptTest>d__0")]
[RavenActionAttribute("/databases/*/admin/etl/olap/test", "POST", "2", "False", "False", "True", "0")]
public Task PostScriptTest();
}
internal class Raven.Server.Documents.ETL.Providers.OLAP.Handlers.Processors.OlapEtlHandlerProcessorForTest : AbstractDatabaseEtlHandlerProcessorForTest`3<TestOlapEtlScript, OlapEtlConfiguration, OlapConnectionString> {
    public OlapEtlHandlerProcessorForTest(DatabaseRequestHandler requestHandler);
    protected virtual TestOlapEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
}
public class Raven.Server.Documents.ETL.Providers.OLAP.OlapColumn : object {
    public string Name;
    public object Value;
    public BlittableJsonToken Type;
}
internal class Raven.Server.Documents.ETL.Providers.OLAP.OlapDocumentTransformer : EtlTransformer`4<ToOlapItem, OlapTransformedItems, OlapEtlStatsScope, OlapEtlPerformanceOperation> {
    private static string DateFormat;
    private OlapEtlConfiguration _config;
    private Dictionary`2<string, OlapTransformedItems> _tables;
    private string _fileNameSuffix;
    private string _localFilePath;
    private OlapEtlStatsScope _stats;
    private ObjectInstance _noPartition;
    private static string PartitionKeys;
    private static string DefaultPartitionColumnName;
    private static string CustomPartition;
    [CompilerGeneratedAttribute]
private String[] <LoadToDestinations>k__BackingField;
    protected String[] LoadToDestinations { get; }
    public OlapDocumentTransformer(Transformation transformation, DocumentDatabase database, DocumentsOperationContext context, OlapEtlConfiguration config);
    public virtual void Initialize(bool debugMode);
    [CompilerGeneratedAttribute]
protected virtual String[] get_LoadToDestinations();
    protected virtual void LoadToFunction(string tableName, ScriptRunnerResult colsAsObject);
    private void LoadToFunction(string tableName, string key, ScriptRunnerResult runnerResult, List`1<string> partitions);
    protected virtual void AddLoadedAttachment(JsValue reference, string name, Attachment attachment);
    protected virtual void AddLoadedCounter(JsValue reference, string name, long value);
    protected virtual void AddLoadedTimeSeries(JsValue reference, string name, IEnumerable`1<SingleResult> entries);
    private OlapTransformedItems GetOrAdd(string tableName, string key, List`1<string> partitions);
    private JsValue LoadToFunctionTranslator(JsValue self, JsValue[] args);
    private JsValue LoadToFunctionTranslator(string name, JsValue[] args);
    private JsValue LoadToFunctionTranslatorInternal(string name, ObjectInstance key, ObjectInstance obj, string methodSignature);
    private JsValue PartitionBy(JsValue self, JsValue[] args);
    private JsValue NoPartition(JsValue self, JsValue[] args);
    public virtual IEnumerable`1<OlapTransformedItems> GetTransformedResults();
    public virtual void Transform(ToOlapItem item, OlapEtlStatsScope stats, EtlProcessState state);
}
public class Raven.Server.Documents.ETL.Providers.OLAP.OlapEtl : EtlProcess`6<ToOlapItem, OlapTransformedItems, OlapEtlConfiguration, OlapConnectionString, OlapEtlStatsScope, OlapEtlPerformanceOperation> {
    public static string OlaptEtlTag;
    public OlapEtlMetricsCountersManager OlapMetrics;
    private BackupTimer _timer;
    private OperationCancelToken _operationCancelToken;
    private static IEnumerator`1<ToOlapItem> EmptyEnumerator;
    private OlapEtlStatsScope _uploadScope;
    private UploaderSettings _uploaderSettings;
    public EtlType EtlType { get; }
    private bool AnyRemoteDestinations { get; }
    public OlapEtl(Transformation transformation, OlapEtlConfiguration configuration, DocumentDatabase database, ServerStore serverStore);
    private static OlapEtl();
    private UploaderSettings GenerateUploaderSetting(BackupConfiguration configuration);
    public virtual EtlType get_EtlType();
    public virtual bool ShouldTrackCounters();
    public virtual bool ShouldTrackTimeSeries();
    public virtual void NotifyAboutWork(DatabaseChange change);
    protected virtual OlapEtlStatsScope CreateScope(EtlRunStats stats);
    protected virtual bool ShouldTrackAttachmentTombstones();
    protected virtual bool ShouldFilterOutHiLoDocument();
    protected virtual IEnumerator`1<ToOlapItem> ConvertDocsEnumerator(DocumentsOperationContext context, IEnumerator`1<Document> docs, string collection);
    protected virtual IEnumerator`1<ToOlapItem> ConvertTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, string collection, bool trackAttachments);
    protected virtual IEnumerator`1<ToOlapItem> ConvertAttachmentTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, List`1<string> collections);
    protected virtual IEnumerator`1<ToOlapItem> ConvertCountersEnumerator(DocumentsOperationContext context, IEnumerator`1<CounterGroupDetail> counters, string collection);
    protected virtual IEnumerator`1<ToOlapItem> ConvertTimeSeriesEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesSegmentEntry> timeSeries, string collection);
    protected virtual IEnumerator`1<ToOlapItem> ConvertTimeSeriesDeletedRangeEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesDeletedRangeItem> timeSeries, string collection);
    protected virtual EtlTransformer`4<ToOlapItem, OlapTransformedItems, OlapEtlStatsScope, OlapEtlPerformanceOperation> GetTransformer(DocumentsOperationContext context);
    protected virtual int LoadInternal(IEnumerable`1<OlapTransformedItems> records, DocumentsOperationContext context, OlapEtlStatsScope scope);
    protected virtual void AfterAllBatchesCompleted(DateTime lastBatchTime);
    private void UpdateTimer(Nullable`1<DateTime> lastBatchTime);
    private void UpdateTimerInternal(NextBackup nextRun);
    private DateTime GetNextRunOccurrence(string runFrequency, Nullable`1<DateTime> lastBatchTime);
    private static BackupResult GenerateUploadResult();
    private void UploadToRemoteDestinations(string localPath, UploadInfo uploadInfo, OlapEtlStatsScope scope);
    private void TryDeleteFromRemoteDestinations(UploadInfo uploadInfo);
    private void ProgressNotification(IOperationProgress progress);
    private bool get_AnyRemoteDestinations();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <UpdateTimerInternal>b__27_0(object _);
    [CompilerGeneratedAttribute]
internal static UploadProgress <ProgressNotification>g__GetUploadProgress|32_0(CloudUploadStatus current);
}
public class Raven.Server.Documents.ETL.Providers.OLAP.OlapEtlMetricsCountersManager : EtlMetricsCountersManager {
}
public class Raven.Server.Documents.ETL.Providers.OLAP.OlapEtlPerformanceOperation : EtlPerformanceOperation {
    [CompilerGeneratedAttribute]
private UploadProgress <AzureUpload>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadProgress <FtpUpload>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadProgress <GlacierUpload>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadProgress <GoogleCloudUpload>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadProgress <S3Upload>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public UploadProgress AzureUpload { get; public set; }
    public UploadProgress FtpUpload { get; public set; }
    public UploadProgress GlacierUpload { get; public set; }
    public UploadProgress GoogleCloudUpload { get; public set; }
    public UploadProgress S3Upload { get; public set; }
    public int NumberOfFiles { get; public set; }
    public string FileName { get; public set; }
    public OlapEtlPerformanceOperation(TimeSpan duration);
    [CompilerGeneratedAttribute]
public UploadProgress get_AzureUpload();
    [CompilerGeneratedAttribute]
public void set_AzureUpload(UploadProgress value);
    [CompilerGeneratedAttribute]
public UploadProgress get_FtpUpload();
    [CompilerGeneratedAttribute]
public void set_FtpUpload(UploadProgress value);
    [CompilerGeneratedAttribute]
public UploadProgress get_GlacierUpload();
    [CompilerGeneratedAttribute]
public void set_GlacierUpload(UploadProgress value);
    [CompilerGeneratedAttribute]
public UploadProgress get_GoogleCloudUpload();
    [CompilerGeneratedAttribute]
public void set_GoogleCloudUpload(UploadProgress value);
    [CompilerGeneratedAttribute]
public UploadProgress get_S3Upload();
    [CompilerGeneratedAttribute]
public void set_S3Upload(UploadProgress value);
    [CompilerGeneratedAttribute]
public int get_NumberOfFiles();
    [CompilerGeneratedAttribute]
public void set_NumberOfFiles(int value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
}
public abstract class Raven.Server.Documents.ETL.Providers.OLAP.OlapTransformedItems : object {
    [CompilerGeneratedAttribute]
private OlapEtlFileFormat <Format>k__BackingField;
    public OlapEtlFileFormat Format { get; }
    public int Count { get; }
    protected OlapTransformedItems(OlapEtlFileFormat format);
    [CompilerGeneratedAttribute]
public OlapEtlFileFormat get_Format();
    public abstract virtual void AddItem(ToOlapItem item);
    public abstract virtual string GenerateFile(UploadInfo& uploadInfo);
    public abstract virtual int get_Count();
}
public class Raven.Server.Documents.ETL.Providers.OLAP.ParquetTransformedItems : OlapTransformedItems {
    public static string DefaultIdColumn;
    public static string LastModifiedColumn;
    private RowGroup _group;
    private Dictionary`2<string, Type> _dataTypes;
    private Dictionary`2<string, DataField> _fields;
    private string _tableName;
    private string _key;
    private string _tmpFilePath;
    private string _fileNameSuffix;
    private string _documentIdColumn;
    private string _remoteFolderName;
    private string _localFolderName;
    private int _count;
    private OlapEtlConfiguration _configuration;
    private Boolean[] _boolArr;
    private String[] _strArr;
    private Byte[] _byteArr;
    private SByte[] _sbyteArr;
    private Int16[] _shortArr;
    private Int32[] _intArr;
    private Int64[] _longArr;
    private UInt16[] _ushortArr;
    private UInt32[] _uintArr;
    private UInt64[] _ulongArr;
    private Single[] _floatArr;
    private Double[] _doubleArr;
    private Decimal[] _decimalArr;
    private DateTime[] _dtArr;
    private TimeSpan[] _tsArr;
    private static string DateTimeFormat;
    private static string Extension;
    private static HashSet`1<char> InvalidFileNameChars;
    private static long UnixEpochTicks;
    public int Count { get; }
    public Dictionary`2<string, DataField> Fields { get; }
    public RowGroup RowGroup { get; }
    public string Key { get; }
    public ParquetTransformedItems(string name, string key, string tmpPath, string fileNameSuffix, List`1<string> partitions, OlapEtlConfiguration configuration);
    private static ParquetTransformedItems();
    public virtual int get_Count();
    public Dictionary`2<string, DataField> get_Fields();
    public RowGroup get_RowGroup();
    public string get_Key();
    private void GetSafeFolderName(string name, List`1<string> partitions);
    private void SetIdColumn();
    public virtual string GenerateFile(UploadInfo& uploadInfo);
    private Dictionary`2<string, DataField> GenerateDataFields();
    private void WriteGroup(ParquetWriter parquetWriter);
    internal void AddMandatoryFields();
    public virtual void AddItem(ToOlapItem item);
    private void AddProperty(LazyStringValue docId, OlapColumn prop);
    private static Type GetPropertyDataType(LazyStringValue docId, OlapColumn prop, IList& data);
    private static Type GetTypeFromObject(LazyStringValue docId, OlapColumn prop, IList& data);
    private static bool TryChangeDataType(Type dataType, Type propType, IList data, IList& newData);
    private static bool TryChangeValueType(Type dataType, Type propType, object value, Object& newValue);
    private static void AddNewValue(IList data, Type dataType, object value);
    [DoesNotReturnAttribute]
private static void ThrowUnsupportedDataType(Type dataType);
    private void UpdateField(Type dataType, string propName, IList data, RowGroup group, bool addDefaultData);
    private static void AddDefaultData(IList data, Type type, long count);
    private static void AddDefaultData(IList data, long count);
    internal static bool TryParseDate(string str, DateTime& dt);
    private static bool TryParseTimeSpan(string str, TimeSpan& ts);
    internal static string GetSafeNameForFileSystem(string name);
    internal static string GetSafeNameForRemoteDestination(string str);
    internal static long UnixTimestampFromDateTime(DateTime date);
}
public class Raven.Server.Documents.ETL.Providers.OLAP.RowGroup : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IList> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Ids>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<long> <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public Dictionary`2<string, IList> Data { get; public set; }
    public List`1<string> Ids { get; }
    public List`1<long> LastModified { get; }
    public int Count { get; internal set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IList> get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Dictionary`2<string, IList> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Ids();
    [CompilerGeneratedAttribute]
public List`1<long> get_LastModified();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
internal void set_Count(int value);
    public void Clear();
}
public class Raven.Server.Documents.ETL.Providers.OLAP.Test.OlapEtlTestScriptResult : TestEtlScriptResult {
    [CompilerGeneratedAttribute]
private List`1<PartitionItems> <ItemsByPartition>k__BackingField;
    public List`1<PartitionItems> ItemsByPartition { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<PartitionItems> get_ItemsByPartition();
    [CompilerGeneratedAttribute]
public void set_ItemsByPartition(List`1<PartitionItems> value);
}
public class Raven.Server.Documents.ETL.Providers.OLAP.Test.TestOlapEtlScript : TestEtlScript`2<OlapEtlConfiguration, OlapConnectionString> {
}
public class Raven.Server.Documents.ETL.Providers.OLAP.ToOlapItem : ExtractedItem {
    [CompilerGeneratedAttribute]
private List`1<OlapColumn> <Properties>k__BackingField;
    public List`1<OlapColumn> Properties { get; public set; }
    public ToOlapItem(ToOlapItem item);
    public ToOlapItem(Document document, string collection);
    [CompilerGeneratedAttribute]
public List`1<OlapColumn> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(List`1<OlapColumn> value);
}
public class Raven.Server.Documents.ETL.Providers.OLAP.UploadInfo : object {
    public string FileName;
    public string FolderName;
}
public class Raven.Server.Documents.ETL.Providers.Queue.AzureQueueStorage.AzureQueueStorageDocumentTransformer`1 : QueueDocumentTransformer`2<T, AzureQueueStorageItem> {
    public AzureQueueStorageDocumentTransformer`1(Transformation transformation, DocumentDatabase database, DocumentsOperationContext context, QueueEtlConfiguration config);
    protected virtual void LoadToFunction(string queueName, ScriptRunnerResult document);
    protected virtual void LoadToFunction(string queueName, ScriptRunnerResult document, CloudEventAttributes attributes);
    public virtual void Initialize(bool debugMode);
}
public class Raven.Server.Documents.ETL.Providers.Queue.AzureQueueStorage.AzureQueueStorageEtl : QueueEtl`1<AzureQueueStorageItem> {
    private HashSet`1<string> _alreadyCreatedQueues;
    private Dictionary`2<string, QueueClient> _queueClients;
    public AzureQueueStorageEtl(Transformation transformation, QueueEtlConfiguration configuration, DocumentDatabase database, ServerStore serverStore);
    protected virtual EtlTransformer`4<QueueItem, QueueWithItems`1<AzureQueueStorageItem>, EtlStatsScope, EtlPerformanceOperation> GetTransformer(DocumentsOperationContext context);
    protected virtual int PublishMessages(List`1<QueueWithItems`1<AzureQueueStorageItem>> itemsPerQueue, BlittableJsonEventBinaryFormatter formatter, List`1& idsToDelete);
    private string CreateBase64CloudEvent(AzureQueueStorageItem queueItem);
    protected virtual void OnProcessStopped();
    private void CreateQueueIfNotExists(QueueClient queueClient);
}
public class Raven.Server.Documents.ETL.Providers.Queue.AzureQueueStorage.AzureQueueStorageItem : QueueItem {
    public AzureQueueStorageItem(QueueItem item);
}
public class Raven.Server.Documents.ETL.Providers.Queue.BlittableJsonEventBinaryFormatter : CloudEventFormatter {
    private JsonOperationContext _ctx;
    private List`1<MemoryStream> _streams;
    public BlittableJsonEventBinaryFormatter(JsonOperationContext ctx);
    public virtual ReadOnlyMemory`1<byte> EncodeBinaryModeEventData(CloudEvent cloudEvent);
    public virtual CloudEvent DecodeStructuredModeMessage(ReadOnlyMemory`1<byte> body, ContentType contentType, IEnumerable`1<CloudEventAttribute> extensionAttributes);
    public virtual ReadOnlyMemory`1<byte> EncodeStructuredModeMessage(CloudEvent cloudEvent, ContentType& contentType);
    public virtual void DecodeBinaryModeEventData(ReadOnlyMemory`1<byte> body, CloudEvent cloudEvent);
    public virtual IReadOnlyList`1<CloudEvent> DecodeBatchModeMessage(ReadOnlyMemory`1<byte> body, ContentType contentType, IEnumerable`1<CloudEventAttribute> extensionAttributes);
    public virtual ReadOnlyMemory`1<byte> EncodeBatchModeMessage(IEnumerable`1<CloudEvent> cloudEvents, ContentType& contentType);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.ETL.Providers.Queue.CloudEventAttributes : object {
    internal static string PartitionKeyLowercased;
    public static HashSet`1<string> ValidAttributeNames;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PartitionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <DataSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Time>k__BackingField;
    public string Id { get; public set; }
    public string Type { get; public set; }
    public Uri Source { get; public set; }
    public string PartitionKey { get; public set; }
    public Uri DataSchema { get; public set; }
    public string Subject { get; public set; }
    public Nullable`1<DateTimeOffset> Time { get; public set; }
    private static CloudEventAttributes();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public Uri get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(Uri value);
    [CompilerGeneratedAttribute]
public string get_PartitionKey();
    [CompilerGeneratedAttribute]
public void set_PartitionKey(string value);
    [CompilerGeneratedAttribute]
public Uri get_DataSchema();
    [CompilerGeneratedAttribute]
public void set_DataSchema(Uri value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(Nullable`1<DateTimeOffset> value);
}
public class Raven.Server.Documents.ETL.Providers.Queue.Enumerators.DocumentsToQueueItems : object {
    private string _collection;
    private IEnumerator`1<Document> _docs;
    [CompilerGeneratedAttribute]
private QueueItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public QueueItem Current { get; private set; }
    public DocumentsToQueueItems(IEnumerator`1<Document> docs, string collection);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual QueueItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(QueueItem value);
}
internal class Raven.Server.Documents.ETL.Providers.Queue.Handlers.Processors.QueueEtlHandlerProcessorForPostScriptTest : AbstractDatabaseEtlHandlerProcessorForTest`3<TestQueueEtlScript, QueueEtlConfiguration, QueueConnectionString> {
    public QueueEtlHandlerProcessorForPostScriptTest(DatabaseRequestHandler requestHandler);
    protected virtual TestQueueEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
}
internal class Raven.Server.Documents.ETL.Providers.Queue.Handlers.Processors.QueueEtlHandlerProcessorForTestAzureQueueStorageConnection`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public QueueEtlHandlerProcessorForTestAzureQueueStorageConnection`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Queue.Handlers.Processors.QueueEtlHandlerProcessorForTestAzureQueueStorageConnection`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.ETL.Providers.Queue.Handlers.Processors.QueueEtlHandlerProcessorForTestKafkaConnection`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public QueueEtlHandlerProcessorForTestKafkaConnection`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Queue.Handlers.Processors.QueueEtlHandlerProcessorForTestKafkaConnection`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.ETL.Providers.Queue.Handlers.Processors.QueueEtlHandlerProcessorForTestRabbitMqConnection`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public QueueEtlHandlerProcessorForTestRabbitMqConnection`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Queue.Handlers.Processors.QueueEtlHandlerProcessorForTestRabbitMqConnection`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
public class Raven.Server.Documents.ETL.Providers.Queue.Handlers.QueueEtlConnectionHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Queue.Handlers.QueueEtlConnectionHandler/<GetTestKafkaConnectionResult>d__0")]
[RavenActionAttribute("/databases/*/admin/etl/queue/kafka/test-connection", "POST", "2", "False", "False", "True", "0")]
public Task GetTestKafkaConnectionResult();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Queue.Handlers.QueueEtlConnectionHandler/<GetTestRabbitMqConnectionResult>d__1")]
[RavenActionAttribute("/databases/*/admin/etl/queue/rabbitmq/test-connection", "POST", "2", "False", "False", "True", "0")]
public Task GetTestRabbitMqConnectionResult();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Queue.Handlers.QueueEtlConnectionHandler/<GetTestAzureQueueStorageConnectionResult>d__2")]
[RavenActionAttribute("/databases/*/admin/etl/queue/azurequeuestorage/test-connection", "POST", "2", "False", "False", "True", "0")]
public Task GetTestAzureQueueStorageConnectionResult();
}
public class Raven.Server.Documents.ETL.Providers.Queue.Handlers.QueueEtlHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Queue.Handlers.QueueEtlHandler/<PostScriptTest>d__0")]
[RavenActionAttribute("/databases/*/admin/etl/queue/test", "POST", "2", "False", "False", "True", "0")]
public Task PostScriptTest();
}
public class Raven.Server.Documents.ETL.Providers.Queue.Kafka.KafkaDocumentTransformer`1 : QueueDocumentTransformer`2<T, KafkaItem> {
    public KafkaDocumentTransformer`1(Transformation transformation, DocumentDatabase database, DocumentsOperationContext context, QueueEtlConfiguration config);
    protected virtual void LoadToFunction(string topicName, ScriptRunnerResult document);
    protected virtual void LoadToFunction(string topicName, ScriptRunnerResult document, CloudEventAttributes attributes);
    public virtual void Initialize(bool debugMode);
}
public class Raven.Server.Documents.ETL.Providers.Queue.Kafka.KafkaEtl : QueueEtl`1<KafkaItem> {
    private IProducer`2<string, Byte[]> _producer;
    [CompilerGeneratedAttribute]
private string <TransactionalId>k__BackingField;
    internal string TransactionalId { get; }
    public KafkaEtl(Transformation transformation, QueueEtlConfiguration configuration, DocumentDatabase database, ServerStore serverStore);
    [CompilerGeneratedAttribute]
internal string get_TransactionalId();
    protected virtual EtlTransformer`4<QueueItem, QueueWithItems`1<KafkaItem>, EtlStatsScope, EtlPerformanceOperation> GetTransformer(DocumentsOperationContext context);
    private static string EnsureValidTransactionalId(string transactionalId);
    public virtual EtlProcessProgress GetProgress(DocumentsOperationContext documentsContext);
    protected virtual int PublishMessages(List`1<QueueWithItems`1<KafkaItem>> itemsPerTopic, BlittableJsonEventBinaryFormatter formatter, List`1& idsToDelete);
    private IAdminClient GetAdminClient();
    private static IEnumerable`1<AclBinding> GetMatchingAllowAclBindings(IAdminClient adminClient, AclOperation operation, ResourceType resourceType);
    private bool TryGetMissingAclsBindings(String& message, string topicName);
    private static bool AssertAclMatchingName(string expectedName, AclBinding aclBinding);
    private static bool IsMatchingLiterally(string pattern, string expected);
    private static bool IsPrefixMatching(string pattern, string expected);
    private bool TryAbortTransaction(Exception& abortException);
    protected virtual void OnProcessStopped();
}
public class Raven.Server.Documents.ETL.Providers.Queue.Kafka.KafkaItem : QueueItem {
    public KafkaItem(QueueItem item);
}
public static class Raven.Server.Documents.ETL.Providers.Queue.QueueBrokerConnectionHelper : object {
    public static IProducer`2<string, Byte[]> CreateKafkaProducer(KafkaConnectionSettings settings, string transactionalId, Logger logger, string etlProcessName, CertificateHolder certificateHolder);
    public static void SetupKafkaClientConfig(ClientConfig config, KafkaConnectionSettings settings, CertificateHolder certificateHolder);
    private static string ExportAsPem(object object);
    public static IConnection CreateRabbitMqConnection(RabbitMqConnectionSettings settings);
    public static QueueClient CreateAzureQueueStorageClient(AzureQueueStorageConnectionSettings azureQueueStorageConnectionSettings, string queueName);
    public static QueueServiceClient CreateAzureQueueStorageServiceClient(AzureQueueStorageConnectionSettings azureQueueStorageConnectionSettings);
}
public abstract class Raven.Server.Documents.ETL.Providers.Queue.QueueDocumentTransformer`2 : EtlTransformer`4<QueueItem, QueueWithItems`1<T>, EtlStatsScope, EtlPerformanceOperation> {
    private QueueEtlConfiguration _config;
    private Dictionary`2<string, QueueWithItems`1<TSelf>> _queues;
    [CompilerGeneratedAttribute]
private String[] <LoadToDestinations>k__BackingField;
    protected String[] LoadToDestinations { get; }
    protected QueueDocumentTransformer`2(Transformation transformation, DocumentDatabase database, DocumentsOperationContext context, QueueEtlConfiguration config);
    protected virtual void AddLoadedAttachment(JsValue reference, string name, Attachment attachment);
    protected virtual void AddLoadedCounter(JsValue reference, string name, long value);
    protected virtual void AddLoadedTimeSeries(JsValue reference, string name, IEnumerable`1<SingleResult> entries);
    [CompilerGeneratedAttribute]
protected virtual String[] get_LoadToDestinations();
    [IteratorStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Queue.QueueDocumentTransformer`2/<GetTransformedResults>d__9")]
public virtual IEnumerable`1<QueueWithItems`1<T>> GetTransformedResults();
    public virtual void Transform(QueueItem item, EtlStatsScope stats, EtlProcessState state);
    protected QueueWithItems`1<TSelf> GetOrAdd(string queueName);
    protected CloudEventAttributes GetCloudEventAttributes(ObjectInstance attributes);
    protected abstract virtual void LoadToFunction(string name, ScriptRunnerResult result, CloudEventAttributes cloudEventAttributes);
    protected JsValue LoadToFunctionTranslatorWithAttributesInternal(string name, ObjectInstance obj, ObjectInstance attributes);
    protected JsValue LoadToFunctionTranslatorWithAttributes(JsValue self, JsValue[] args);
    protected JsValue LoadToFunctionTranslatorWithAttributes(string name, JsValue[] args);
    [CompilerGeneratedAttribute]
internal static bool <GetCloudEventAttributes>g__TryGetStringAttributeValue|12_0(PropertyDescriptor attributeValue, String& value);
    [CompilerGeneratedAttribute]
internal static bool <GetCloudEventAttributes>g__TryGetDateAttributeValue|12_1(PropertyDescriptor attributeValue, DateTimeOffset& value);
}
public abstract class Raven.Server.Documents.ETL.Providers.Queue.QueueEtl`1 : EtlProcess`6<QueueItem, QueueWithItems`1<T>, QueueEtlConfiguration, QueueConnectionString, EtlStatsScope, EtlPerformanceOperation> {
    public static string QueueEtlTag;
    private static string DefaultCloudEventType;
    [CompilerGeneratedAttribute]
private Uri <DefaultCloudEventSource>k__BackingField;
    private Uri DefaultCloudEventSource { get; }
    public string EtlSubType { get; }
    public EtlType EtlType { get; }
    protected QueueEtl`1(Transformation transformation, QueueEtlConfiguration configuration, DocumentDatabase database, ServerStore serverStore);
    public static EtlProcess CreateInstance(Transformation transformation, QueueEtlConfiguration configuration, DocumentDatabase database, ServerStore serverStore);
    [CompilerGeneratedAttribute]
private Uri get_DefaultCloudEventSource();
    public virtual string get_EtlSubType();
    public virtual EtlType get_EtlType();
    public virtual bool ShouldTrackCounters();
    public virtual bool ShouldTrackTimeSeries();
    protected virtual bool ShouldTrackAttachmentTombstones();
    public virtual bool ShouldTrackDocumentTombstones();
    protected virtual bool ShouldFilterOutHiLoDocument();
    protected virtual IEnumerator`1<QueueItem> ConvertDocsEnumerator(DocumentsOperationContext context, IEnumerator`1<Document> docs, string collection);
    protected virtual IEnumerator`1<QueueItem> ConvertTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, string collection, bool trackAttachments);
    protected virtual IEnumerator`1<QueueItem> ConvertAttachmentTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, List`1<string> collections);
    protected virtual IEnumerator`1<QueueItem> ConvertCountersEnumerator(DocumentsOperationContext context, IEnumerator`1<CounterGroupDetail> counters, string collection);
    protected virtual IEnumerator`1<QueueItem> ConvertTimeSeriesEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesSegmentEntry> timeSeries, string collection);
    protected virtual IEnumerator`1<QueueItem> ConvertTimeSeriesDeletedRangeEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesDeletedRangeItem> timeSeries, string collection);
    protected virtual int LoadInternal(IEnumerable`1<QueueWithItems`1<T>> items, DocumentsOperationContext context, EtlStatsScope scope);
    protected abstract virtual int PublishMessages(List`1<QueueWithItems`1<T>> items, BlittableJsonEventBinaryFormatter formatter, List`1& idsToDelete);
    protected virtual EtlStatsScope CreateScope(EtlRunStats stats);
    protected CloudEvent CreateCloudEvent(QueueItem item);
    public QueueEtlTestScriptResult RunTest(IEnumerable`1<QueueWithItems`1<T>> records, DocumentsOperationContext context);
    public virtual void Dispose();
}
public class Raven.Server.Documents.ETL.Providers.Queue.QueueItem : ExtractedItem {
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <TransformationResult>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudEventAttributes <Attributes>k__BackingField;
    public BlittableJsonReaderObject TransformationResult { get; public set; }
    public CloudEventAttributes Attributes { get; public set; }
    public QueueItem(QueueItem item);
    public QueueItem(Document document, string collection);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_TransformationResult();
    [CompilerGeneratedAttribute]
public void set_TransformationResult(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public CloudEventAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(CloudEventAttributes value);
}
public class Raven.Server.Documents.ETL.Providers.Queue.QueueWithItems`1 : EtlQueue {
    public List`1<T> Items;
    public QueueWithItems`1(EtlQueue queue);
}
public class Raven.Server.Documents.ETL.Providers.Queue.QueueWriterSimulator : object {
    public List`1<MessageSummary> SimulateExecuteMessages(QueueWithItems`1<T> queueMessages, DocumentsOperationContext context);
}
public class Raven.Server.Documents.ETL.Providers.Queue.RabbitMq.RabbitMqDocumentTransformer`1 : QueueDocumentTransformer`2<T, RabbitMqItem> {
    public RabbitMqDocumentTransformer`1(Transformation transformation, DocumentDatabase database, DocumentsOperationContext context, QueueEtlConfiguration config);
    protected virtual void LoadToFunction(string exchangeName, ScriptRunnerResult document);
    private void LoadToFunction(string exchangeName, ScriptRunnerResult document, string routingKey, CloudEventAttributes attributes);
    public virtual void Initialize(bool debugMode);
    private JsValue LoadToFunctionTranslatorWithRoutingKeyAndAttributes(JsValue self, JsValue[] args);
    private JsValue LoadToFunctionTranslatorWithRoutingKeyAndAttributes(string name, JsValue[] args);
    private JsValue LoadToFunctionTranslatorWithAttributesInternal(string name, ObjectInstance obj, string routingKey, ObjectInstance attributes);
    protected virtual void LoadToFunction(string name, ScriptRunnerResult result, CloudEventAttributes cloudEventAttributes);
}
public class Raven.Server.Documents.ETL.Providers.Queue.RabbitMq.RabbitMqEtl : QueueEtl`1<RabbitMqItem> {
    public static string DefaultExchange;
    public static string DefaultRoutingKey;
    private HashSet`1<string> _alreadyCreatedExchanges;
    private HashSet`1<string> _alreadyCreatedQueues;
    private IConnection _connection;
    public RabbitMqEtl(Transformation transformation, QueueEtlConfiguration configuration, DocumentDatabase database, ServerStore serverStore);
    private static RabbitMqEtl();
    protected virtual EtlTransformer`4<QueueItem, QueueWithItems`1<RabbitMqItem>, EtlStatsScope, EtlPerformanceOperation> GetTransformer(DocumentsOperationContext context);
    protected virtual int PublishMessages(List`1<QueueWithItems`1<RabbitMqItem>> itemsPerExchange, BlittableJsonEventBinaryFormatter formatter, List`1& idsToDelete);
    protected virtual void OnProcessStopped();
    private void DeclareDefaultExchangesQueuesAndBindings(List`1<QueueWithItems`1<RabbitMqItem>> itemsPerExchange);
}
public class Raven.Server.Documents.ETL.Providers.Queue.RabbitMq.RabbitMqItem : QueueItem {
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public string RoutingKey { get; public set; }
    public RabbitMqItem(QueueItem item);
    [CompilerGeneratedAttribute]
public string get_RoutingKey();
    [CompilerGeneratedAttribute]
public void set_RoutingKey(string value);
}
public class Raven.Server.Documents.ETL.Providers.Queue.Test.MessageSummary : object {
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudEventAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RoutingKey>k__BackingField;
    public string Body { get; public set; }
    public CloudEventAttributes Attributes { get; public set; }
    public string RoutingKey { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(string value);
    [CompilerGeneratedAttribute]
public CloudEventAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(CloudEventAttributes value);
    [CompilerGeneratedAttribute]
public string get_RoutingKey();
    [CompilerGeneratedAttribute]
public void set_RoutingKey(string value);
}
public class Raven.Server.Documents.ETL.Providers.Queue.Test.QueueEtlTestScriptResult : TestEtlScriptResult {
    [CompilerGeneratedAttribute]
private List`1<QueueSummary> <Summary>k__BackingField;
    public List`1<QueueSummary> Summary { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<QueueSummary> get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(List`1<QueueSummary> value);
}
public class Raven.Server.Documents.ETL.Providers.Queue.Test.QueueSummary : object {
    [CompilerGeneratedAttribute]
private string <QueueName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MessageSummary> <Messages>k__BackingField;
    public string QueueName { get; public set; }
    public List`1<MessageSummary> Messages { get; public set; }
    [CompilerGeneratedAttribute]
public string get_QueueName();
    [CompilerGeneratedAttribute]
public void set_QueueName(string value);
    [CompilerGeneratedAttribute]
public List`1<MessageSummary> get_Messages();
    [CompilerGeneratedAttribute]
public void set_Messages(List`1<MessageSummary> value);
}
public class Raven.Server.Documents.ETL.Providers.Queue.Test.TestQueueEtlScript : TestEtlScript`2<QueueEtlConfiguration, QueueConnectionString> {
}
public class Raven.Server.Documents.ETL.Providers.Raven.Enumerators.AttachmentTombstonesToRavenEtlItems : object {
    private DocumentsOperationContext _context;
    private IEnumerator`1<Tombstone> _tombstones;
    private List`1<string> _collections;
    [CompilerGeneratedAttribute]
private RavenEtlItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public RavenEtlItem Current { get; private set; }
    public AttachmentTombstonesToRavenEtlItems(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, List`1<string> collections);
    private bool Filter(RavenEtlItem item);
    public static bool FilterAttachment(DocumentsOperationContext context, RavenEtlItem item);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual RavenEtlItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(RavenEtlItem value);
}
public class Raven.Server.Documents.ETL.Providers.Raven.Enumerators.CountersToRavenEtlItems : object {
    private DocumentsOperationContext _context;
    private IEnumerator`1<CounterGroupDetail> _counters;
    private string _collection;
    [CompilerGeneratedAttribute]
private RavenEtlItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public RavenEtlItem Current { get; private set; }
    public CountersToRavenEtlItems(DocumentsOperationContext context, IEnumerator`1<CounterGroupDetail> counters, string collection);
    private bool Filter(RavenEtlItem item);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual RavenEtlItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(RavenEtlItem value);
}
public class Raven.Server.Documents.ETL.Providers.Raven.Enumerators.DocumentsToRavenEtlItems : object {
    private IEnumerator`1<Document> _docs;
    private string _collection;
    [CompilerGeneratedAttribute]
private RavenEtlItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public RavenEtlItem Current { get; private set; }
    public DocumentsToRavenEtlItems(IEnumerator`1<Document> docs, string collection);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual RavenEtlItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(RavenEtlItem value);
}
public class Raven.Server.Documents.ETL.Providers.Raven.Enumerators.TimeSeriesDeletedRangeToRavenEtlItems : object {
    private IEnumerator`1<TimeSeriesDeletedRangeItem> _timeSeries;
    private string _collection;
    [CompilerGeneratedAttribute]
private RavenEtlItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public RavenEtlItem Current { get; private set; }
    public TimeSeriesDeletedRangeToRavenEtlItems(IEnumerator`1<TimeSeriesDeletedRangeItem> timeSeries, string collection);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual RavenEtlItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(RavenEtlItem value);
}
public class Raven.Server.Documents.ETL.Providers.Raven.Enumerators.TimeSeriesToRavenEtlItems : object {
    private IEnumerator`1<TimeSeriesSegmentEntry> _timeSeries;
    private string _collection;
    [CompilerGeneratedAttribute]
private RavenEtlItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public RavenEtlItem Current { get; private set; }
    public TimeSeriesToRavenEtlItems(IEnumerator`1<TimeSeriesSegmentEntry> timeSeries, string collection);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual RavenEtlItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(RavenEtlItem value);
}
public class Raven.Server.Documents.ETL.Providers.Raven.Enumerators.TombstonesToRavenEtlItems : object {
    private DocumentsOperationContext _context;
    private IEnumerator`1<Tombstone> _tombstones;
    private string _collection;
    private bool _trackAttachments;
    private bool _allDocs;
    [CompilerGeneratedAttribute]
private RavenEtlItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public RavenEtlItem Current { get; private set; }
    public TombstonesToRavenEtlItems(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, string collection, bool trackAttachments);
    private bool Filter(RavenEtlItem item);
    [DoesNotReturnAttribute]
public static void ThrowInvalidTombstoneType(TombstoneType expectedType, TombstoneType actualType);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual RavenEtlItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(RavenEtlItem value);
}
internal abstract class Raven.Server.Documents.ETL.Providers.Raven.Handlers.Processors.AbstractDatabaseEtlHandlerProcessorForTest`3 : AbstractEtlHandlerProcessorForTest`5<DatabaseRequestHandler, DocumentsOperationContext, TTestEtlScript, TConfiguration, TConnectionString> {
    protected bool SupportsCurrentNode { get; }
    protected AbstractDatabaseEtlHandlerProcessorForTest`3(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual TestEtlScriptResult TestScript(DocumentsOperationContext context, TTestEtlScript testScript);
    protected virtual ValueTask HandleRemoteNodeAsync(DocumentsOperationContext context, TTestEtlScript testScript, BlittableJsonReaderObject testScriptJson);
}
internal abstract class Raven.Server.Documents.ETL.Providers.Raven.Handlers.Processors.AbstractEtlHandlerProcessorForTest`5 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected bool SupportsCurrentNode { get; }
    protected AbstractEtlHandlerProcessorForTest`5(TRequestHandler requestHandler);
    protected abstract virtual bool get_SupportsCurrentNode();
    protected abstract virtual TTestEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
    protected abstract virtual TestEtlScriptResult TestScript(TOperationContext context, TTestEtlScript testScript);
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Raven.Handlers.Processors.AbstractEtlHandlerProcessorForTest`5/<HandleCurrentNodeAsync>d__5")]
private ValueTask HandleCurrentNodeAsync(TOperationContext context, TTestEtlScript testScript);
    protected abstract virtual ValueTask HandleRemoteNodeAsync(TOperationContext context, TTestEtlScript testScript, BlittableJsonReaderObject testScriptJson);
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Raven.Handlers.Processors.AbstractEtlHandlerProcessorForTest`5/<ExecuteAsync>d__7")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.ETL.Providers.Raven.Handlers.Processors.EtlHandlerProcessorForTest : AbstractDatabaseEtlHandlerProcessorForTest`3<TestRavenEtlScript, RavenEtlConfiguration, RavenConnectionString> {
    public EtlHandlerProcessorForTest(DatabaseRequestHandler requestHandler);
    protected virtual TestRavenEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
}
public class Raven.Server.Documents.ETL.Providers.Raven.Handlers.RavenEtlHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Raven.Handlers.RavenEtlHandler/<PostScriptTest>d__0")]
[RavenActionAttribute("/databases/*/admin/etl/raven/test", "POST", "2", "False", "False", "True", "0")]
public Task PostScriptTest();
}
public class Raven.Server.Documents.ETL.Providers.Raven.RavenEtl : EtlProcess`6<RavenEtlItem, ICommandData, RavenEtlConfiguration, RavenConnectionString, EtlStatsScope, EtlPerformanceOperation> {
    private RavenEtlConfiguration _configuration;
    private ServerStore _serverStore;
    public static string RavenEtlTag;
    private RequestExecutor _requestExecutor;
    private string _recentUrl;
    private ScriptInput _script;
    internal Action`1<RavenEtl> BeforeActualLoad;
    public string Url { get; }
    public EtlType EtlType { get; }
    public RavenEtl(Transformation transformation, RavenEtlConfiguration configuration, DocumentDatabase database, ServerStore serverStore);
    public string get_Url();
    public virtual EtlType get_EtlType();
    private void OnServerCertificateChanged(object sender, EventArgs e);
    private static RequestExecutor CreateNewRequestExecutor(RavenEtlConfiguration configuration, ServerStore serverStore);
    protected virtual IEnumerator`1<RavenEtlItem> ConvertDocsEnumerator(DocumentsOperationContext context, IEnumerator`1<Document> docs, string collection);
    protected virtual IEnumerator`1<RavenEtlItem> ConvertTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, string collection, bool trackAttachments);
    protected virtual IEnumerator`1<RavenEtlItem> ConvertAttachmentTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, List`1<string> collections);
    protected virtual IEnumerator`1<RavenEtlItem> ConvertCountersEnumerator(DocumentsOperationContext context, IEnumerator`1<CounterGroupDetail> counters, string collection);
    protected virtual IEnumerator`1<RavenEtlItem> ConvertTimeSeriesEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesSegmentEntry> timeSeries, string collection);
    protected virtual IEnumerator`1<RavenEtlItem> ConvertTimeSeriesDeletedRangeEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesDeletedRangeItem> timeSeries, string collection);
    protected virtual bool ShouldTrackAttachmentTombstones();
    public static bool ShouldTrackAttachmentTombstones(Transformation transformation);
    public virtual bool ShouldTrackCounters();
    public virtual bool ShouldTrackTimeSeries();
    protected virtual EtlTransformer`4<RavenEtlItem, ICommandData, EtlStatsScope, EtlPerformanceOperation> GetTransformer(DocumentsOperationContext context);
    protected virtual int LoadInternal(IEnumerable`1<ICommandData> items, DocumentsOperationContext context, EtlStatsScope scope);
    protected virtual EtlStatsScope CreateScope(EtlRunStats stats);
    protected virtual bool ShouldFilterOutHiLoDocument();
    [DoesNotReturnAttribute]
private static void ThrowTimeoutException(int numberOfCommands, TimeSpan duration, Exception e);
    public virtual void Dispose();
}
public class Raven.Server.Documents.ETL.Providers.Raven.RavenEtlDocumentTransformer : EtlTransformer`4<RavenEtlItem, ICommandData, EtlStatsScope, EtlPerformanceOperation> {
    private Transformation _transformation;
    private ScriptInput _script;
    private PropertyDescriptor _addAttachmentMethod;
    private PropertyDescriptor _addCounterMethod;
    private PropertyDescriptor _addTimeSeriesMethod;
    private RavenEtlScriptRun _currentRun;
    [CompilerGeneratedAttribute]
private String[] <LoadToDestinations>k__BackingField;
    protected String[] LoadToDestinations { get; }
    public RavenEtlDocumentTransformer(Transformation transformation, DocumentDatabase database, DocumentsOperationContext context, ScriptInput script);
    public virtual void Initialize(bool debugMode);
    [CompilerGeneratedAttribute]
protected virtual String[] get_LoadToDestinations();
    protected virtual void LoadToFunction(string collectionName, ScriptRunnerResult document);
    private JsValue AddAttachment(JsValue self, JsValue[] args);
    private JsValue AddCounter(JsValue self, JsValue[] args);
    private JsValue AddTimeSeries(JsValue self, JsValue[] args);
    private string GetPrefixedId(LazyStringValue documentId, string loadCollectionName);
    public virtual IEnumerable`1<ICommandData> GetTransformedResults();
    public virtual void Transform(RavenEtlItem item, EtlStatsScope stats, EtlProcessState state);
    private bool ShouldLoadTimeSeriesWithDoc(RavenEtlItem item, EtlProcessState state);
    private bool ShouldFilterOutDeletion(RavenEtlItem item);
    private void AddCounters(LazyStringValue docId, IEnumerable`1<CounterGroupDetail> counterGroups, string function);
    private void AddSingleCounterGroup(LazyStringValue docId, BlittableJsonReaderObject counterGroupDocument, string function);
    private void AddAndRemoveTimeSeries(LazyStringValue docId, Dictionary`2<string, TimeSeriesModifications> modificationsPerTimeSeries);
    private void HandleSingleTimeSeriesSegment(string loadBehaviorFunction, EtlStatsScope stats, EtlProcessState state);
    private void HandleSingleTimeSeriesDeletedRangeItem(TimeSeriesDeletedRangeItem item, string loadBehaviorFunction);
    private bool FilterSingleTimeSeriesSegmentByLoadBehaviorScript(IEnumerable`1& timeSeriesEntries, LazyStringValue docId, TimeSeriesSegmentEntry segmentEntry, string loadBehaviorFunction);
    [IteratorStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Raven.RavenEtlDocumentTransformer/<SkipUntilFrom>d__27")]
private static IEnumerable`1<SingleResult> SkipUntilFrom(IEnumerable`1<SingleResult> origin, DateTime from);
    [IteratorStateMachineAttribute("Raven.Server.Documents.ETL.Providers.Raven.RavenEtlDocumentTransformer/<BreakOnTo>d__28")]
private static IEnumerable`1<SingleResult> BreakOnTo(IEnumerable`1<SingleResult> origin, DateTime to);
    private bool ShouldFilterByScriptAndGetParams(string docId, string timeSeriesName, string function, Nullable`1& toLoad);
    private List`1<CounterOperation> GetCounterOperationsFor(RavenEtlItem item);
    private Dictionary`2<string, TimeSeriesModifications> GetTimeSeriesFor(RavenEtlItem item, string loadBehaviorFunction);
    private List`1<TimeSeriesOperation> GetTimeSeriesOperationsFor(RavenEtlItem item);
    private bool GetCounterValueAndCheckIfShouldSkip(LazyStringValue docId, string function, PropertyDetails prop, Int64& value, Boolean& delete);
    private IEnumerable`1<CounterGroupDetail> GetCounterGroupsFor(RavenEtlItem item);
    protected virtual void AddLoadedAttachment(JsValue reference, string name, Attachment attachment);
    protected virtual void AddLoadedCounter(JsValue reference, string name, long value);
    protected virtual void AddLoadedTimeSeries(JsValue reference, string name, IEnumerable`1<SingleResult> entries);
    private List`1<Attachment> GetAttachmentsFor(RavenEtlItem item);
    private void ApplyDeleteCommands(RavenEtlItem item, OperationType operation, Boolean& isLoadedToDefaultCollectionDeleted);
}
public class Raven.Server.Documents.ETL.Providers.Raven.RavenEtlItem : ExtractedItem {
    [CompilerGeneratedAttribute]
private LazyStringValue <AttachmentTombstoneId>k__BackingField;
    public LazyStringValue AttachmentTombstoneId { get; }
    public bool IsAttachmentTombstone { get; }
    public RavenEtlItem(Document document, string collection);
    public RavenEtlItem(Tombstone tombstone, string collection, EtlItemType type);
    public RavenEtlItem(CounterGroupDetail counter, string collection);
    public RavenEtlItem(TimeSeriesSegmentEntry timeSeriesSegmentEntry, string collection);
    public RavenEtlItem(TimeSeriesDeletedRangeItem deletedRange, string collection);
    [CompilerGeneratedAttribute]
public LazyStringValue get_AttachmentTombstoneId();
    public bool get_IsAttachmentTombstone();
}
public class Raven.Server.Documents.ETL.Providers.Raven.RavenEtlScriptRun : object {
    private EtlStatsScope _stats;
    private Transformation _transformation;
    private List`1<ICommandData> _deletes;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<JsValue, ValueTuple`2<string, BlittableJsonReaderObject>> _putsByJsReference;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<JsValue, List`1<ValueTuple`2<string, Attachment>>> _addAttachments;
    private Dictionary`2<JsValue, Attachment> _loadedAttachments;
    private Dictionary`2<JsValue, List`1<CounterOperation>> _countersByJsReference;
    private Dictionary`2<LazyStringValue, List`1<CounterOperation>> _countersByDocumentId;
    private Dictionary`2<JsValue, Dictionary`2<JsValue, TimeSeriesOperation>> _timeSeriesByJsReference;
    private Dictionary`2<LazyStringValue, Dictionary`2<string, TimeSeriesBatchCommandData>> _timeSeriesByDocumentId;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<JsValue, ValueTuple`2<string, long>> _loadedCountersByJsReference;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<JsValue, ValueTuple`2<string, IEnumerable`1<SingleResult>>> _loadedTimeSeriesByJsReference;
    private Dictionary`2<string, List`1<ICommandData>> _fullDocuments;
    public RavenEtlScriptRun(EtlStatsScope stats, Transformation transformation);
    public void Delete(string documentId);
    public void DeleteByPrefix(string documentIdPrefix);
    public void PutFullDocument(string id, BlittableJsonReaderObject doc, List`1<Attachment> attachments, List`1<CounterOperation> counterOperations, List`1<TimeSeriesOperation> timeSeriesOperations);
    public void Put(string id, JsValue instance, BlittableJsonReaderObject doc);
    public void LoadAttachment(JsValue attachmentReference, Attachment attachment);
    public void LoadCounter(JsValue counterReference, string name, long value);
    public void LoadTimeSeries(JsValue reference, string name, IEnumerable`1<SingleResult> value);
    public void AddAttachment(JsValue instance, string name, JsValue attachmentReference);
    public void DeleteAttachment(string documentId, string name);
    public void AddCounter(JsValue instance, JsValue counterReference);
    public void AddCounter(LazyStringValue documentId, string counterName, long value);
    public void DeleteCounter(LazyStringValue documentId, string counterName);
    public void AddTimeSeries(JsValue instance, JsValue timeSeriesReference);
    public void AddTimeSeries(LazyStringValue documentId, string timeSeriesName, SingleResult timeSeries);
    public void RemoveTimeSeries(LazyStringValue documentId, string timeSeriesName, DateTime from, DateTime to);
    private TimeSeriesBatchCommandData GetTimeSeriesOperationFor(LazyStringValue documentId, string timeSeriesName);
    public List`1<ICommandData> GetCommands();
    public bool IsDocumentLoadedToSameCollection(LazyStringValue documentId);
    private string GetRemoteDocumentId(string localDocId);
}
public class Raven.Server.Documents.ETL.Providers.Raven.Test.RavenEtlTestScriptResult : TestEtlScriptResult {
    [CompilerGeneratedAttribute]
private List`1<ICommandData> <Commands>k__BackingField;
    public List`1<ICommandData> Commands { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ICommandData> get_Commands();
    [CompilerGeneratedAttribute]
public void set_Commands(List`1<ICommandData> value);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.Documents.ETL.Providers.Raven.Test.TestRavenEtlScript : TestEtlScript`2<RavenEtlConfiguration, RavenConnectionString> {
}
public class Raven.Server.Documents.ETL.Providers.SQL.Enumerators.DocumentsToSqlItems : object {
    private IEnumerator`1<Document> _docs;
    private string _collection;
    [CompilerGeneratedAttribute]
private ToSqlItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public ToSqlItem Current { get; private set; }
    public DocumentsToSqlItems(IEnumerator`1<Document> docs, string collection);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual ToSqlItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(ToSqlItem value);
}
public class Raven.Server.Documents.ETL.Providers.SQL.Enumerators.TombstonesToSqlItems : object {
    private IEnumerator`1<Tombstone> _tombstones;
    private string _collection;
    [CompilerGeneratedAttribute]
private ToSqlItem <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    public ToSqlItem Current { get; private set; }
    public TombstonesToSqlItems(IEnumerator`1<Tombstone> tombstones, string collection);
    private bool Filter();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual ToSqlItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(ToSqlItem value);
}
internal class Raven.Server.Documents.ETL.Providers.SQL.Handlers.Processors.SqlEtlHandlerProcessorForTest : AbstractDatabaseEtlHandlerProcessorForTest`3<TestSqlEtlScript, SqlEtlConfiguration, SqlConnectionString> {
    public SqlEtlHandlerProcessorForTest(DatabaseRequestHandler requestHandler);
    protected virtual TestSqlEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
}
internal class Raven.Server.Documents.ETL.Providers.SQL.Handlers.Processors.SqlEtlHandlerProcessorForTestConnection`1 : AbstractDatabaseHandlerProcessor`1<TOperationContext> {
    public SqlEtlHandlerProcessorForTestConnection`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.SQL.Handlers.Processors.SqlEtlHandlerProcessorForTestConnection`1/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
public class Raven.Server.Documents.ETL.Providers.SQL.Handlers.SqlEtlHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.SQL.Handlers.SqlEtlHandler/<TestConnection>d__0")]
[RavenActionAttribute("/databases/*/admin/etl/sql/test-connection", "POST", "2", "False", "False", "True", "0")]
public Task TestConnection();
    [AsyncStateMachineAttribute("Raven.Server.Documents.ETL.Providers.SQL.Handlers.SqlEtlHandler/<Test>d__1")]
[RavenActionAttribute("/databases/*/admin/etl/sql/test", "POST", "2", "False", "False", "True", "0")]
public Task Test();
}
public class Raven.Server.Documents.ETL.Providers.SQL.Metrics.SqlEtlMetricsCountersManager : EtlMetricsCountersManager {
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, SqlEtlTableMetrics> <TablesMetrics>k__BackingField;
    public ConcurrentDictionary`2<string, SqlEtlTableMetrics> TablesMetrics { get; public set; }
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, SqlEtlTableMetrics> get_TablesMetrics();
    [CompilerGeneratedAttribute]
public void set_TablesMetrics(ConcurrentDictionary`2<string, SqlEtlTableMetrics> value);
    public SqlEtlTableMetrics GetTableMetrics(string tableName);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.ETL.Providers.SQL.Metrics.SqlEtlTableMetrics : object {
    public string TableName;
    public MeterMetric DeleteActionsMeter;
    public MeterMetric InsertActionsMeter;
    public SqlEtlTableMetrics(string tableName);
    public DynamicJsonValue ToSqlEtlTableMetricsDataDictionary();
}
public class Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.DbCommandBuilder : object {
    public string Start;
    public string End;
    public string QuoteIdentifier(string unquotedIdentifier);
}
public class Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.DbProviderFactories : object {
    public static DbProviderFactory GetFactory(string factoryName);
}
[ExtensionAttribute]
public static class Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.DbProviderFactoryExtensions : object {
    [ExtensionAttribute]
public static DbCommandBuilder InitializeCommandBuilder(DbProviderFactory factory);
}
public class Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.RelationalDatabaseWriter : RelationalDatabaseWriterBase {
    private Logger _logger;
    private SqlEtl _etl;
    private DocumentDatabase _database;
    private DbCommandBuilder _commandBuilder;
    private DbProviderFactory _providerFactory;
    private DbConnection _connection;
    private DbTransaction _tx;
    private List`1<Func`3<DbParameter, string, bool>> _stringParserList;
    private SqlProvider _providerType;
    private static int LongStatementWarnThresholdInMs;
    public RelationalDatabaseWriter(SqlEtl etl, DocumentDatabase database);
    private void OpenConnection(DocumentDatabase database, string etlConfigurationName, string connectionStringName);
    public static void TestConnection(string factoryName, string connectionString);
    private DbProviderFactory GetDbProviderFactory(SqlEtlConfiguration configuration);
    public sealed virtual void Dispose();
    public void Commit();
    public void Rollback();
    private int InsertItems(string tableName, string pkName, List`1<ToSqlItem> toInsert, Action`1<DbCommand> commandCallback, CancellationToken token);
    private DbCommand CreateCommand();
    public int DeleteItems(string tableName, string pkName, bool parameterize, List`1<ToSqlItem> toDelete, Action`1<DbCommand> commandCallback, CancellationToken token);
    private void HandleSlowSql(long elapsedMilliseconds, string stmt);
    private string GetTableNameString(string tableName);
    public static string SanitizeSqlValue(string sqlValue);
    private string GetParameterName(string paramName);
    public SqlWriteStats Write(SqlTableWithRecords table, List`1<DbCommand> commands, CancellationToken token);
    public static void SetParamValue(DbParameter colParam, SqlColumn column, List`1<Func`3<DbParameter, string, bool>> stringParsers, SqlProvider provider);
    private static T ParseProviderSpecificParameterType(string dbTypeString);
    private static void SetParamStringValue(DbParameter colParam, string value, List`1<Func`3<DbParameter, string, bool>> stringParsers);
    public List`1<Func`3<DbParameter, string, bool>> GenerateStringParsers();
    [CompilerGeneratedAttribute]
internal static void <SetParamValue>g__ThrowProviderNotSupported|25_0(<>c__DisplayClass25_0& );
    [CompilerGeneratedAttribute]
internal static Type <SetParamValue>g__TryDetectCollectionType|25_1(string dbTypeString, object value);
}
public class Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.RelationalDatabaseWriterBase : object {
    protected bool IsSqlServerFactoryType;
    private static String[] SqlServerFactoryNames;
    public RelationalDatabaseWriterBase(string factoryName);
    private static RelationalDatabaseWriterBase();
}
public class Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.RelationalDatabaseWriterSimulator : RelationalDatabaseWriterBase {
    private SqlEtlConfiguration _configuration;
    private DbProviderFactory _providerFactory;
    private DbCommandBuilder _commandBuilder;
    private SqlProvider _providerType;
    public RelationalDatabaseWriterSimulator(SqlEtlConfiguration configuration);
    [IteratorStateMachineAttribute("Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.RelationalDatabaseWriterSimulator/<SimulateExecuteCommandText>d__5")]
public IEnumerable`1<string> SimulateExecuteCommandText(SqlTableWithRecords records, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.RelationalDatabaseWriterSimulator/<GenerateInsertItemCommandText>d__6")]
private IEnumerable`1<string> GenerateInsertItemCommandText(string tableName, string pkName, List`1<ToSqlItem> dataForTable, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.RelationalDatabaseWriterSimulator/<GenerateDeleteItemsCommandText>d__7")]
private IEnumerable`1<string> GenerateDeleteItemsCommandText(string tableName, string pkName, bool parameterize, List`1<ToSqlItem> toSqlItems, CancellationToken token);
    private string GetTableNameString(string tableName);
    [CompilerGeneratedAttribute]
private string <GetTableNameString>b__8_0(string x);
}
public class Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.SqlWriteStats : object {
    public int InsertedRecordsCount;
    public int DeletedRecordsCount;
}
public class Raven.Server.Documents.ETL.Providers.SQL.RelationalWriters.TestSqlEtlScript : TestEtlScript`2<SqlEtlConfiguration, SqlConnectionString> {
    public bool PerformRolledBackTransaction;
    public SqlConnectionString Connection;
}
public class Raven.Server.Documents.ETL.Providers.SQL.SqlColumn : object {
    public string Id;
    public object Value;
    public BlittableJsonToken Type;
}
internal class Raven.Server.Documents.ETL.Providers.SQL.SqlDocumentTransformer : EtlTransformer`4<ToSqlItem, SqlTableWithRecords, EtlStatsScope, EtlPerformanceOperation> {
    private static JsValue DefaultVarCharSize;
    private Transformation _transformation;
    private SqlEtlConfiguration _config;
    private Dictionary`2<string, SqlTableWithRecords> _tables;
    private Dictionary`2<string, Queue`1<Attachment>> _loadedAttachments;
    private List`1<SqlEtlTable> _tablesForScript;
    private EtlStatsScope _stats;
    [CompilerGeneratedAttribute]
private String[] <LoadToDestinations>k__BackingField;
    protected String[] LoadToDestinations { get; }
    public SqlDocumentTransformer(Transformation transformation, DocumentDatabase database, DocumentsOperationContext context, SqlEtlConfiguration config);
    private static SqlDocumentTransformer();
    public virtual void Initialize(bool debugMode);
    [CompilerGeneratedAttribute]
protected virtual String[] get_LoadToDestinations();
    protected virtual void LoadToFunction(string tableName, ScriptRunnerResult cols);
    private static bool IsLoadAttachment(LazyStringValue value, String& attachmentName);
    protected virtual void AddLoadedAttachment(JsValue reference, string name, Attachment attachment);
    protected virtual void AddLoadedCounter(JsValue reference, string name, long value);
    protected virtual void AddLoadedTimeSeries(JsValue reference, string name, IEnumerable`1<SingleResult> entries);
    private SqlTableWithRecords GetOrAdd(string tableName);
    [DoesNotReturnAttribute]
private static void ThrowTableNotDefinedInConfig(string tableName);
    public virtual IEnumerable`1<SqlTableWithRecords> GetTransformedResults();
    public virtual void Transform(ToSqlItem item, EtlStatsScope stats, EtlProcessState state);
    private JsValue ToVarcharTranslator(JsValue type, JsValue[] args);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private JsValue <Initialize>b__8_0(JsValue value, JsValue[] values);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private JsValue <Initialize>b__8_1(JsValue value, JsValue[] values);
}
public class Raven.Server.Documents.ETL.Providers.SQL.SqlEtl : EtlProcess`6<ToSqlItem, SqlTableWithRecords, SqlEtlConfiguration, SqlConnectionString, EtlStatsScope, EtlPerformanceOperation> {
    public static string SqlEtlTag;
    public SqlEtlMetricsCountersManager SqlMetrics;
    public EtlType EtlType { get; }
    public SqlEtl(Transformation transformation, SqlEtlConfiguration configuration, DocumentDatabase database, ServerStore serverStore);
    public virtual EtlType get_EtlType();
    protected virtual IEnumerator`1<ToSqlItem> ConvertDocsEnumerator(DocumentsOperationContext context, IEnumerator`1<Document> docs, string collection);
    protected virtual IEnumerator`1<ToSqlItem> ConvertTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, string collection, bool trackAttachments);
    protected virtual IEnumerator`1<ToSqlItem> ConvertAttachmentTombstonesEnumerator(DocumentsOperationContext context, IEnumerator`1<Tombstone> tombstones, List`1<string> collections);
    protected virtual IEnumerator`1<ToSqlItem> ConvertCountersEnumerator(DocumentsOperationContext context, IEnumerator`1<CounterGroupDetail> counters, string collection);
    protected virtual IEnumerator`1<ToSqlItem> ConvertTimeSeriesEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesSegmentEntry> timeSeries, string collection);
    protected virtual IEnumerator`1<ToSqlItem> ConvertTimeSeriesDeletedRangeEnumerator(DocumentsOperationContext context, IEnumerator`1<TimeSeriesDeletedRangeItem> timeSeries, string collection);
    protected virtual bool ShouldTrackAttachmentTombstones();
    public virtual bool ShouldTrackCounters();
    public virtual bool ShouldTrackTimeSeries();
    protected virtual EtlTransformer`4<ToSqlItem, SqlTableWithRecords, EtlStatsScope, EtlPerformanceOperation> GetTransformer(DocumentsOperationContext context);
    protected virtual int LoadInternal(IEnumerable`1<SqlTableWithRecords> records, DocumentsOperationContext context, EtlStatsScope scope);
    private void LogStats(SqlWriteStats stats, SqlTableWithRecords table);
    protected virtual EtlStatsScope CreateScope(EtlRunStats stats);
    protected virtual bool ShouldFilterOutHiLoDocument();
    public SqlEtlTestScriptResult RunTest(DocumentsOperationContext context, IEnumerable`1<SqlTableWithRecords> toWrite, bool performRolledBackTransaction);
    [CompilerGeneratedAttribute]
private RelationalDatabaseWriter <LoadInternal>b__15_0();
}
public class Raven.Server.Documents.ETL.Providers.SQL.SqlEtlPerformanceStats : object {
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    public int BatchSize { get; public set; }
    public TimeSpan Duration { get; public set; }
    public DateTime Started { get; public set; }
    public double DurationInMs { get; }
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    public double get_DurationInMs();
    public virtual string ToString();
    private bool Equals(SqlEtlPerformanceStats other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Server.Documents.ETL.Providers.SQL.SqlTableWithRecords : SqlEtlTable {
    public List`1<ToSqlItem> Inserts;
    public List`1<ToSqlItem> Deletes;
    public SqlTableWithRecords(SqlEtlTable table);
}
public class Raven.Server.Documents.ETL.Providers.SQL.Test.SqlEtlTestScriptResult : TestEtlScriptResult {
    [CompilerGeneratedAttribute]
private List`1<TableQuerySummary> <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<EtlErrorInfo> <LoadErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SlowSqlStatementInfo> <SlowSqlWarnings>k__BackingField;
    public List`1<TableQuerySummary> Summary { get; public set; }
    public List`1<EtlErrorInfo> LoadErrors { get; public set; }
    public List`1<SlowSqlStatementInfo> SlowSqlWarnings { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TableQuerySummary> get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(List`1<TableQuerySummary> value);
    [CompilerGeneratedAttribute]
public List`1<EtlErrorInfo> get_LoadErrors();
    [CompilerGeneratedAttribute]
public void set_LoadErrors(List`1<EtlErrorInfo> value);
    [CompilerGeneratedAttribute]
public List`1<SlowSqlStatementInfo> get_SlowSqlWarnings();
    [CompilerGeneratedAttribute]
public void set_SlowSqlWarnings(List`1<SlowSqlStatementInfo> value);
}
public class Raven.Server.Documents.ETL.Providers.SQL.Test.TableQuerySummary : object {
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandData[] <Commands>k__BackingField;
    public string TableName { get; public set; }
    public CommandData[] Commands { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
public void set_TableName(string value);
    [CompilerGeneratedAttribute]
public CommandData[] get_Commands();
    [CompilerGeneratedAttribute]
public void set_Commands(CommandData[] value);
    public static TableQuerySummary GenerateSummaryFromCommands(string tableName, IEnumerable`1<DbCommand> commands);
    public static object GetParameterValue(DbParameter param);
}
public class Raven.Server.Documents.ETL.Providers.SQL.ToSqlItem : ExtractedItem {
    [CompilerGeneratedAttribute]
private List`1<SqlColumn> <Columns>k__BackingField;
    public List`1<SqlColumn> Columns { get; public set; }
    public ToSqlItem(ToSqlItem item);
    public ToSqlItem(Document document, string collection);
    public ToSqlItem(Tombstone tombstone, string collection);
    [CompilerGeneratedAttribute]
public List`1<SqlColumn> get_Columns();
    [CompilerGeneratedAttribute]
public void set_Columns(List`1<SqlColumn> value);
}
public abstract class Raven.Server.Documents.ETL.Stats.AbstractEtlStatsScope`2 : StatsScope`2<EtlRunStats, TStatsScope> {
    private EtlRunStats _stats;
    public Dictionary`2<EtlItemType, int> NumberOfExtractedItems { get; }
    public Dictionary`2<EtlItemType, int> NumberOfTransformedItems { get; }
    public Dictionary`2<EtlItemType, int> NumberOfTransformedTombstones { get; }
    public Dictionary`2<EtlItemType, long> LastTransformedEtags { get; }
    public Dictionary`2<EtlItemType, long> LastFilteredOutEtags { get; }
    public Dictionary`2<EtlItemType, long> LastExtractedEtags { get; }
    public long LastLoadedEtag { get; }
    public int NumberOfLoadedItems { get; }
    public int TransformationErrorCount { get; }
    public string ChangeVector { get; }
    public string BatchTransformationCompleteReason { get; }
    public string BatchStopReason { get; }
    public Size BatchSize { get; }
    protected AbstractEtlStatsScope`2(EtlRunStats stats, bool start);
    public Dictionary`2<EtlItemType, int> get_NumberOfExtractedItems();
    public Dictionary`2<EtlItemType, int> get_NumberOfTransformedItems();
    public Dictionary`2<EtlItemType, int> get_NumberOfTransformedTombstones();
    public Dictionary`2<EtlItemType, long> get_LastTransformedEtags();
    public Dictionary`2<EtlItemType, long> get_LastFilteredOutEtags();
    public Dictionary`2<EtlItemType, long> get_LastExtractedEtags();
    public long get_LastLoadedEtag();
    public int get_NumberOfLoadedItems();
    public int get_TransformationErrorCount();
    public string get_ChangeVector();
    public string get_BatchTransformationCompleteReason();
    public string get_BatchStopReason();
    public Size get_BatchSize();
    public void RecordExtractedItem(EtlItemType itemType);
    public void RecordTransformedItem(EtlItemType itemType, bool isTombstone);
    public void RecordLastExtractedEtag(long etag, EtlItemType type);
    public void RecordLastTransformedEtag(long etag, EtlItemType type);
    public void RecordChangeVector(IChangeVectorOperationContext context, ChangeVector changeVector);
    public void RecordLastLoadedEtag(long etag);
    public void RecordLastFilteredOutEtag(long etag, EtlItemType type);
    protected abstract virtual TEtlPerformanceOperation ToPerformanceOperation(string name, TStatsScope scope);
    public abstract virtual TEtlPerformanceOperation ToPerformanceOperation(string name);
    public void RecordBatchTransformationCompleteReason(string reason);
    public bool HasBatchTransformationCompleteReason();
    public void RecordBatchStopReason(string reason);
    public void RecordTransformationError();
    public void RecordLoadSuccess(int count);
    public void RecordLoadFailure();
    public void RecordCurrentlyAllocated(long allocatedInBytes);
    public void IncrementBatchSize(long sizeInBytes);
}
public class Raven.Server.Documents.ETL.Stats.EtlOperations : object {
    public static string Extract;
    public static string Transform;
    public static string Load;
    public static string LoadLocal;
    public static string LoadUpload;
}
public class Raven.Server.Documents.ETL.Stats.EtlPerformanceOperation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlPerformanceOperation[] <Operations>k__BackingField;
    public string Name { get; public set; }
    public double DurationInMs { get; }
    public EtlPerformanceOperation[] Operations { get; public set; }
    public EtlPerformanceOperation(TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public EtlPerformanceOperation[] get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(EtlPerformanceOperation[] value);
}
public class Raven.Server.Documents.ETL.Stats.EtlPerformanceStats : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlPerformanceOperation <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastLoadedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfLoadedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<EtlItemType, long> <LastExtractedEtags>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<EtlItemType, long> <LastTransformedEtags>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<EtlItemType, long> <LastFilteredOutEtags>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<EtlItemType, int> <NumberOfExtractedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<EtlItemType, int> <NumberOfTransformedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<EtlItemType, int> <NumberOfTransformedTombstones>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <CurrentlyAllocated>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BatchTransformationCompleteReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BatchStopReason>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransformationErrorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SuccessfullyLoaded>k__BackingField;
    public int Id { get; public set; }
    public DateTime Started { get; public set; }
    public Nullable`1<DateTime> Completed { get; public set; }
    public double DurationInMs { get; }
    public EtlPerformanceOperation Details { get; public set; }
    public long LastLoadedEtag { get; public set; }
    public int NumberOfLoadedItems { get; public set; }
    public Dictionary`2<EtlItemType, long> LastExtractedEtags { get; public set; }
    public Dictionary`2<EtlItemType, long> LastTransformedEtags { get; public set; }
    public Dictionary`2<EtlItemType, long> LastFilteredOutEtags { get; public set; }
    public Dictionary`2<EtlItemType, int> NumberOfExtractedItems { get; public set; }
    public Dictionary`2<EtlItemType, int> NumberOfTransformedItems { get; public set; }
    public Dictionary`2<EtlItemType, int> NumberOfTransformedTombstones { get; public set; }
    public Size CurrentlyAllocated { get; public set; }
    public Size BatchSize { get; public set; }
    public string BatchTransformationCompleteReason { get; public set; }
    public string BatchStopReason { get; public set; }
    public int TransformationErrorCount { get; public set; }
    public Nullable`1<bool> SuccessfullyLoaded { get; public set; }
    public EtlPerformanceStats(TimeSpan duration);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public EtlPerformanceOperation get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(EtlPerformanceOperation value);
    [CompilerGeneratedAttribute]
public long get_LastLoadedEtag();
    [CompilerGeneratedAttribute]
public void set_LastLoadedEtag(long value);
    [CompilerGeneratedAttribute]
public int get_NumberOfLoadedItems();
    [CompilerGeneratedAttribute]
public void set_NumberOfLoadedItems(int value);
    [CompilerGeneratedAttribute]
public Dictionary`2<EtlItemType, long> get_LastExtractedEtags();
    [CompilerGeneratedAttribute]
public void set_LastExtractedEtags(Dictionary`2<EtlItemType, long> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<EtlItemType, long> get_LastTransformedEtags();
    [CompilerGeneratedAttribute]
public void set_LastTransformedEtags(Dictionary`2<EtlItemType, long> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<EtlItemType, long> get_LastFilteredOutEtags();
    [CompilerGeneratedAttribute]
public void set_LastFilteredOutEtags(Dictionary`2<EtlItemType, long> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<EtlItemType, int> get_NumberOfExtractedItems();
    [CompilerGeneratedAttribute]
public void set_NumberOfExtractedItems(Dictionary`2<EtlItemType, int> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<EtlItemType, int> get_NumberOfTransformedItems();
    [CompilerGeneratedAttribute]
public void set_NumberOfTransformedItems(Dictionary`2<EtlItemType, int> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<EtlItemType, int> get_NumberOfTransformedTombstones();
    [CompilerGeneratedAttribute]
public void set_NumberOfTransformedTombstones(Dictionary`2<EtlItemType, int> value);
    [CompilerGeneratedAttribute]
public Size get_CurrentlyAllocated();
    [CompilerGeneratedAttribute]
public void set_CurrentlyAllocated(Size value);
    [CompilerGeneratedAttribute]
public Size get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(Size value);
    [CompilerGeneratedAttribute]
public string get_BatchTransformationCompleteReason();
    [CompilerGeneratedAttribute]
public void set_BatchTransformationCompleteReason(string value);
    [CompilerGeneratedAttribute]
public string get_BatchStopReason();
    [CompilerGeneratedAttribute]
public void set_BatchStopReason(string value);
    [CompilerGeneratedAttribute]
public int get_TransformationErrorCount();
    [CompilerGeneratedAttribute]
public void set_TransformationErrorCount(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SuccessfullyLoaded();
    [CompilerGeneratedAttribute]
public void set_SuccessfullyLoaded(Nullable`1<bool> value);
}
public class Raven.Server.Documents.ETL.Stats.EtlProcessPerformanceStats : object {
    [CompilerGeneratedAttribute]
private string <TransformationName>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlPerformanceStats[] <Performance>k__BackingField;
    public string TransformationName { get; public set; }
    public EtlPerformanceStats[] Performance { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TransformationName();
    [CompilerGeneratedAttribute]
public void set_TransformationName(string value);
    [CompilerGeneratedAttribute]
public EtlPerformanceStats[] get_Performance();
    [CompilerGeneratedAttribute]
public void set_Performance(EtlPerformanceStats[] value);
}
public class Raven.Server.Documents.ETL.Stats.EtlProcessProgress : object {
    [CompilerGeneratedAttribute]
private string <TransformationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransactionalId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AverageProcessedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfDocumentsToProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalNumberOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfDocumentTombstonesToProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalNumberOfDocumentTombstones>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfCounterGroupsToProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalNumberOfCounterGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfTimeSeriesSegmentsToProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalNumberOfTimeSeriesSegments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfTimeSeriesDeletedRangesToProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalNumberOfTimeSeriesDeletedRanges>k__BackingField;
    public string TransformationName { get; public set; }
    public string TransactionalId { get; public set; }
    public bool Completed { get; public set; }
    public bool Disabled { get; public set; }
    public double AverageProcessedPerSecond { get; public set; }
    public long NumberOfDocumentsToProcess { get; public set; }
    public long TotalNumberOfDocuments { get; public set; }
    public long NumberOfDocumentTombstonesToProcess { get; public set; }
    public long TotalNumberOfDocumentTombstones { get; public set; }
    public long NumberOfCounterGroupsToProcess { get; public set; }
    public long TotalNumberOfCounterGroups { get; public set; }
    public long NumberOfTimeSeriesSegmentsToProcess { get; public set; }
    public long TotalNumberOfTimeSeriesSegments { get; public set; }
    public long NumberOfTimeSeriesDeletedRangesToProcess { get; public set; }
    public long TotalNumberOfTimeSeriesDeletedRanges { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TransformationName();
    [CompilerGeneratedAttribute]
public void set_TransformationName(string value);
    [CompilerGeneratedAttribute]
public string get_TransactionalId();
    [CompilerGeneratedAttribute]
public void set_TransactionalId(string value);
    [CompilerGeneratedAttribute]
public bool get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(bool value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public double get_AverageProcessedPerSecond();
    [CompilerGeneratedAttribute]
public void set_AverageProcessedPerSecond(double value);
    [CompilerGeneratedAttribute]
public long get_NumberOfDocumentsToProcess();
    [CompilerGeneratedAttribute]
public void set_NumberOfDocumentsToProcess(long value);
    [CompilerGeneratedAttribute]
public long get_TotalNumberOfDocuments();
    [CompilerGeneratedAttribute]
public void set_TotalNumberOfDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfDocumentTombstonesToProcess();
    [CompilerGeneratedAttribute]
public void set_NumberOfDocumentTombstonesToProcess(long value);
    [CompilerGeneratedAttribute]
public long get_TotalNumberOfDocumentTombstones();
    [CompilerGeneratedAttribute]
public void set_TotalNumberOfDocumentTombstones(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfCounterGroupsToProcess();
    [CompilerGeneratedAttribute]
public void set_NumberOfCounterGroupsToProcess(long value);
    [CompilerGeneratedAttribute]
public long get_TotalNumberOfCounterGroups();
    [CompilerGeneratedAttribute]
public void set_TotalNumberOfCounterGroups(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfTimeSeriesSegmentsToProcess();
    [CompilerGeneratedAttribute]
public void set_NumberOfTimeSeriesSegmentsToProcess(long value);
    [CompilerGeneratedAttribute]
public long get_TotalNumberOfTimeSeriesSegments();
    [CompilerGeneratedAttribute]
public void set_TotalNumberOfTimeSeriesSegments(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfTimeSeriesDeletedRangesToProcess();
    [CompilerGeneratedAttribute]
public void set_NumberOfTimeSeriesDeletedRangesToProcess(long value);
    [CompilerGeneratedAttribute]
public long get_TotalNumberOfTimeSeriesDeletedRanges();
    [CompilerGeneratedAttribute]
public void set_TotalNumberOfTimeSeriesDeletedRanges(long value);
}
public class Raven.Server.Documents.ETL.Stats.EtlProcessTransformationDebugStats : EtlProcessTransformationStats {
    [CompilerGeneratedAttribute]
private EtlMetricsCountersManager <Metrics>k__BackingField;
    public EtlMetricsCountersManager Metrics { get; public set; }
    [CompilerGeneratedAttribute]
public EtlMetricsCountersManager get_Metrics();
    [CompilerGeneratedAttribute]
public void set_Metrics(EtlMetricsCountersManager value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.ETL.Stats.EtlProcessTransformationStats : object {
    [CompilerGeneratedAttribute]
private string <TransformationName>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlProcessStatistics <Statistics>k__BackingField;
    public string TransformationName { get; public set; }
    public EtlProcessStatistics Statistics { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TransformationName();
    [CompilerGeneratedAttribute]
public void set_TransformationName(string value);
    [CompilerGeneratedAttribute]
public EtlProcessStatistics get_Statistics();
    [CompilerGeneratedAttribute]
public void set_Statistics(EtlProcessStatistics value);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.ETL.Stats.EtlRunStats : object {
    public Dictionary`2<EtlItemType, int> NumberOfExtractedItems;
    public Dictionary`2<EtlItemType, int> NumberOfTransformedItems;
    public Dictionary`2<EtlItemType, int> NumberOfTransformedTombstones;
    public Dictionary`2<EtlItemType, long> LastExtractedEtags;
    public Dictionary`2<EtlItemType, long> LastTransformedEtags;
    public Dictionary`2<EtlItemType, long> LastFilteredOutEtags;
    public Size CurrentlyAllocated;
    public long LastLoadedEtag;
    public int NumberOfLoadedItems;
    public int TransformationErrorCount;
    public string BatchTransformationCompleteReason;
    public string BatchStopReason;
    public string ChangeVector;
    public Nullable`1<bool> SuccessfullyLoaded;
    public Size BatchSize;
}
public class Raven.Server.Documents.ETL.Stats.EtlStatsAggregator`2 : StatsAggregator`2<EtlRunStats, TStatsScope> {
    private Func`2<EtlRunStats, TStatsScope> _factory;
    private EtlPerformanceStats modreq(System.Runtime.CompilerServices.IsVolatile) _performanceStats;
    public IStatsScope EtlScope { get; }
    public EtlStatsAggregator`2(int id, Func`2<EtlRunStats, TStatsScope> factory, IEtlStatsAggregator lastStats);
    public virtual TStatsScope CreateScope();
    public sealed virtual EtlPerformanceStats ToPerformanceStats();
    private EtlPerformanceStats CreatePerformanceStats(bool completed);
    public sealed virtual EtlPerformanceStats ToPerformanceLiveStatsWithDetails();
    public sealed virtual EtlPerformanceStats ToPerformanceLiveStats();
    public IStatsScope get_EtlScope();
}
public class Raven.Server.Documents.ETL.Stats.EtlStatsScope : AbstractEtlStatsScope`2<EtlStatsScope, EtlPerformanceOperation> {
    public EtlStatsScope(EtlRunStats stats, bool start);
    protected virtual EtlStatsScope OpenNewScope(EtlRunStats stats, bool start);
    protected virtual EtlPerformanceOperation ToPerformanceOperation(string name, EtlStatsScope scope);
    public virtual EtlPerformanceOperation ToPerformanceOperation(string name);
    [CompilerGeneratedAttribute]
private EtlPerformanceOperation <ToPerformanceOperation>b__3_0(KeyValuePair`2<string, EtlStatsScope> x);
}
public class Raven.Server.Documents.ETL.Stats.EtlTaskDebugStats : object {
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlProcessTransformationDebugStats[] <Stats>k__BackingField;
    public string TaskName { get; public set; }
    public EtlProcessTransformationDebugStats[] Stats { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
public void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public EtlProcessTransformationDebugStats[] get_Stats();
    [CompilerGeneratedAttribute]
public void set_Stats(EtlProcessTransformationDebugStats[] value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.ETL.Stats.EtlTaskPerformanceStats : object {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlType <EtlType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EtlSubType>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlProcessPerformanceStats[] <Stats>k__BackingField;
    public long TaskId { get; public set; }
    public string TaskName { get; public set; }
    public EtlType EtlType { get; public set; }
    public string EtlSubType { get; public set; }
    public EtlProcessPerformanceStats[] Stats { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
public void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public EtlType get_EtlType();
    [CompilerGeneratedAttribute]
public void set_EtlType(EtlType value);
    [CompilerGeneratedAttribute]
public string get_EtlSubType();
    [CompilerGeneratedAttribute]
public void set_EtlSubType(string value);
    [CompilerGeneratedAttribute]
public EtlProcessPerformanceStats[] get_Stats();
    [CompilerGeneratedAttribute]
public void set_Stats(EtlProcessPerformanceStats[] value);
}
public class Raven.Server.Documents.ETL.Stats.EtlTaskProgress : object {
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlType <EtlType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<QueueBrokerType> <QueueBrokerType>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlProcessProgress[] <ProcessesProgress>k__BackingField;
    public string TaskName { get; public set; }
    public EtlType EtlType { get; public set; }
    public Nullable`1<QueueBrokerType> QueueBrokerType { get; public set; }
    public EtlProcessProgress[] ProcessesProgress { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
public void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public EtlType get_EtlType();
    [CompilerGeneratedAttribute]
public void set_EtlType(EtlType value);
    [CompilerGeneratedAttribute]
public Nullable`1<QueueBrokerType> get_QueueBrokerType();
    [CompilerGeneratedAttribute]
public void set_QueueBrokerType(Nullable`1<QueueBrokerType> value);
    [CompilerGeneratedAttribute]
public EtlProcessProgress[] get_ProcessesProgress();
    [CompilerGeneratedAttribute]
public void set_ProcessesProgress(EtlProcessProgress[] value);
}
public class Raven.Server.Documents.ETL.Stats.EtlTaskStats : object {
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlProcessTransformationStats[] <Stats>k__BackingField;
    public string TaskName { get; public set; }
    public EtlProcessTransformationStats[] Stats { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
public void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public EtlProcessTransformationStats[] get_Stats();
    [CompilerGeneratedAttribute]
public void set_Stats(EtlProcessTransformationStats[] value);
    public sealed virtual DynamicJsonValue ToJson();
}
public interface Raven.Server.Documents.ETL.Stats.IEtlStatsAggregator {
    public bool Completed { get; }
    public abstract virtual EtlPerformanceStats ToPerformanceStats();
    public abstract virtual EtlPerformanceStats ToPerformanceLiveStatsWithDetails();
    public abstract virtual EtlPerformanceStats ToPerformanceLiveStats();
    public abstract virtual bool get_Completed();
}
public class Raven.Server.Documents.ETL.Stats.OlapEtlStatsScope : AbstractEtlStatsScope`2<OlapEtlStatsScope, OlapEtlPerformanceOperation> {
    [CompilerGeneratedAttribute]
private UploadProgress <AzureUpload>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadProgress <FtpUpload>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadProgress <GlacierUpload>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadProgress <GoogleCloudUpload>k__BackingField;
    [CompilerGeneratedAttribute]
private UploadProgress <S3Upload>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public UploadProgress AzureUpload { get; public set; }
    public UploadProgress FtpUpload { get; public set; }
    public UploadProgress GlacierUpload { get; public set; }
    public UploadProgress GoogleCloudUpload { get; public set; }
    public UploadProgress S3Upload { get; public set; }
    public int NumberOfFiles { get; public set; }
    public string FileName { get; public set; }
    public OlapEtlStatsScope(EtlRunStats stats, bool start);
    [CompilerGeneratedAttribute]
public UploadProgress get_AzureUpload();
    [CompilerGeneratedAttribute]
public void set_AzureUpload(UploadProgress value);
    [CompilerGeneratedAttribute]
public UploadProgress get_FtpUpload();
    [CompilerGeneratedAttribute]
public void set_FtpUpload(UploadProgress value);
    [CompilerGeneratedAttribute]
public UploadProgress get_GlacierUpload();
    [CompilerGeneratedAttribute]
public void set_GlacierUpload(UploadProgress value);
    [CompilerGeneratedAttribute]
public UploadProgress get_GoogleCloudUpload();
    [CompilerGeneratedAttribute]
public void set_GoogleCloudUpload(UploadProgress value);
    [CompilerGeneratedAttribute]
public UploadProgress get_S3Upload();
    [CompilerGeneratedAttribute]
public void set_S3Upload(UploadProgress value);
    [CompilerGeneratedAttribute]
public int get_NumberOfFiles();
    [CompilerGeneratedAttribute]
public void set_NumberOfFiles(int value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    protected virtual OlapEtlStatsScope OpenNewScope(EtlRunStats stats, bool start);
    protected virtual OlapEtlPerformanceOperation ToPerformanceOperation(string name, OlapEtlStatsScope scope);
    public virtual OlapEtlPerformanceOperation ToPerformanceOperation(string name);
    [CompilerGeneratedAttribute]
private OlapEtlPerformanceOperation <ToPerformanceOperation>b__31_0(KeyValuePair`2<string, OlapEtlStatsScope> x);
}
public abstract class Raven.Server.Documents.ETL.Test.TestEtlScript`2 : object {
    public string DocumentId;
    public bool IsDelete;
    public TConfiguration Configuration;
}
public abstract class Raven.Server.Documents.ETL.Test.TestEtlScriptResult : object {
    [CompilerGeneratedAttribute]
private List`1<EtlErrorInfo> <TransformationErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <DebugOutput>k__BackingField;
    public List`1<EtlErrorInfo> TransformationErrors { get; public set; }
    public List`1<string> DebugOutput { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<EtlErrorInfo> get_TransformationErrors();
    [CompilerGeneratedAttribute]
public void set_TransformationErrors(List`1<EtlErrorInfo> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_DebugOutput();
    [CompilerGeneratedAttribute]
public void set_DebugOutput(List`1<string> value);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.Documents.ExecuteRateLimitedOperations`1 : MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> {
    private Queue`1<T> _documentIds;
    private Func`2<T, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> _commandToExecute;
    private RateGate _rateGate;
    private OperationCancelToken _token;
    private Nullable`1<int> _batchSize;
    private CancellationToken _cancellationToken;
    [CompilerGeneratedAttribute]
private bool <NeedWait>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Processed>k__BackingField;
    public bool NeedWait { get; private set; }
    public long Processed { get; private set; }
    internal ExecuteRateLimitedOperations`1(Queue`1<T> documentIds, Func`2<T, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> commandToExecute, RateGate rateGate, OperationCancelToken token, Nullable`1<int> batchSize);
    [CompilerGeneratedAttribute]
public bool get_NeedWait();
    [CompilerGeneratedAttribute]
private void set_NeedWait(bool value);
    [CompilerGeneratedAttribute]
public long get_Processed();
    [CompilerGeneratedAttribute]
private void set_Processed(long value);
    public virtual long Execute(DocumentsOperationContext context, RecordingState<DocumentsOperationContext, DocumentsTransaction> recording);
    public virtual IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> ToDto(DocumentsOperationContext context);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
}
internal class Raven.Server.Documents.Expiration.DeleteExpiredDocumentsCommandDto : object {
    [CompilerGeneratedAttribute]
private ValueTuple`3[] <Expired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForExpiration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CurrentTime>k__BackingField;
    public ValueTuple`3[] Expired { get; public set; }
    public bool ForExpiration { get; public set; }
    public DateTime CurrentTime { get; public set; }
    public sealed virtual DeleteExpiredDocumentsCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
    [CompilerGeneratedAttribute]
public ValueTuple`3[] get_Expired();
    [CompilerGeneratedAttribute]
public void set_Expired(ValueTuple`3[] value);
    [CompilerGeneratedAttribute]
public bool get_ForExpiration();
    [CompilerGeneratedAttribute]
public void set_ForExpiration(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_CurrentTime();
    [CompilerGeneratedAttribute]
public void set_CurrentTime(DateTime value);
}
public class Raven.Server.Documents.Expiration.ExpirationStorage : AbstractBackgroundWorkStorage {
    private static string DocumentsByExpiration;
    public ExpirationStorage(DocumentDatabase database, Transaction tx);
    protected virtual void ProcessDocument(DocumentsOperationContext context, Slice lowerId, string id, DateTime currentTime);
    protected virtual void HandleDocumentConflict(BackgroundWorkParameters options, Slice ticksAsSlice, Slice clonedId, Queue`1<DocumentExpirationInfo> expiredDocs, Int32& totalCount);
    private ValueTuple`2<bool, string> GetConflictedExpiration(DocumentsOperationContext context, DateTime currentTime, Slice clonedId);
}
public class Raven.Server.Documents.Expiration.ExpiredDocumentsCleaner : BackgroundWorkBase {
    public static int DefaultDeleteFrequencyInSec;
    public static int DefaultRefreshFrequencyInSec;
    internal static int BatchSize;
    internal static int DefaultMaxItemsToProcessInSingleRun;
    private DocumentDatabase _database;
    private TimeSpan _refreshPeriod;
    private TimeSpan _expirationPeriod;
    [CompilerGeneratedAttribute]
private ExpirationConfiguration <ExpirationConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private RefreshConfiguration <RefreshConfiguration>k__BackingField;
    public ExpirationConfiguration ExpirationConfiguration { get; }
    public RefreshConfiguration RefreshConfiguration { get; }
    private ExpiredDocumentsCleaner(DocumentDatabase database, ExpirationConfiguration expirationConfiguration, RefreshConfiguration refreshConfiguration);
    private static ExpiredDocumentsCleaner();
    [CompilerGeneratedAttribute]
public ExpirationConfiguration get_ExpirationConfiguration();
    [CompilerGeneratedAttribute]
public RefreshConfiguration get_RefreshConfiguration();
    public static ExpiredDocumentsCleaner LoadConfigurations(DocumentDatabase database, DatabaseRecord dbRecord, ExpiredDocumentsCleaner expiredDocumentsCleaner);
    protected virtual Task DoWork();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Expiration.ExpiredDocumentsCleaner/<DoRefreshWork>d__16")]
private Task DoRefreshWork();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Expiration.ExpiredDocumentsCleaner/<DoExpirationWork>d__17")]
private Task DoExpirationWork();
    internal Task CleanupExpiredDocs(Nullable`1<int> batchSize);
    internal Task RefreshDocs(Nullable`1<int> batchSize);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Expiration.ExpiredDocumentsCleaner/<CleanupDocs>d__20")]
private Task CleanupDocs(int batchSize, long maxItemsToProcess, bool forExpiration);
}
public abstract class Raven.Server.Documents.Handlers.AbstractStreamJsonFileBlittableQueryResultWriter`1 : object {
    protected AsyncBlittableJsonTextWriter Writer;
    protected String[] Properties;
    public bool SupportStatistics { get; }
    protected AbstractStreamJsonFileBlittableQueryResultWriter`1(HttpResponse response, Stream stream, JsonOperationContext context, String[] properties, string jsonFileNamePrefix);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void StartResponse();
    public sealed virtual void StartResults();
    public sealed virtual void EndResults();
    public abstract virtual ValueTask AddResultAsync(T res, CancellationToken token);
    public sealed virtual void EndResponse();
    public sealed virtual ValueTask WriteErrorAsync(Exception e);
    public sealed virtual ValueTask WriteErrorAsync(string error);
    public sealed virtual void WriteQueryStatistics(long resultEtag, bool isStale, string indexName, long totalResults, DateTime timestamp);
    public sealed virtual bool get_SupportStatistics();
}
public class Raven.Server.Documents.Handlers.Admin.AdminAnalyzersHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminAnalyzersHandler/<Put>d__0")]
[RavenActionAttribute("/databases/*/admin/analyzers", "PUT", "2", "False", "False", "True", "0")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminAnalyzersHandler/<Delete>d__1")]
[RavenActionAttribute("/databases/*/admin/analyzers", "DELETE", "2", "False", "False", "True", "0")]
public Task Delete();
}
public class Raven.Server.Documents.Handlers.Admin.AdminConfigurationHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminConfigurationHandler/<GetSettings>d__0")]
[RavenActionAttribute("/databases/*/admin/configuration/settings", "GET", "2", "False", "False", "True", "0")]
public Task GetSettings();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminConfigurationHandler/<GetDatabaseRecord>d__1")]
[RavenActionAttribute("/databases/*/admin/record", "GET", "2", "False", "False", "True", "0")]
public Task GetDatabaseRecord();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminConfigurationHandler/<PutSettings>d__2")]
[RavenActionAttribute("/databases/*/admin/configuration/settings", "PUT", "2", "False", "False", "True", "0")]
public Task PutSettings();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminConfigurationHandler/<PutStudioConfiguration>d__3")]
[RavenActionAttribute("/databases/*/admin/configuration/studio", "PUT", "2", "False", "False", "True", "0")]
public Task PutStudioConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminConfigurationHandler/<PutClientConfiguration>d__4")]
[RavenActionAttribute("/databases/*/admin/configuration/client", "PUT", "2", "False", "False", "True", "0")]
public Task PutClientConfiguration();
}
public class Raven.Server.Documents.Handlers.Admin.AdminIndexHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminIndexHandler/<Put>d__0")]
[RavenActionAttribute("/databases/*/admin/indexes", "PUT", "2", "False", "False", "True", "0")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminIndexHandler/<PutJavaScript>d__1")]
[RavenActionAttribute("/databases/*/indexes", "PUT", "3", "2", "False", "False", "True", "0")]
public Task PutJavaScript();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminIndexHandler/<TestIndex>d__2")]
[RavenActionAttribute("/databases/*/indexes/test", "POST", "3", "2", "False", "False", "True", "0")]
public Task TestIndex();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminIndexHandler/<Stop>d__3")]
[RavenActionAttribute("/databases/*/admin/indexes/stop", "POST", "2", "False", "False", "True", "0")]
public Task Stop();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminIndexHandler/<Start>d__4")]
[RavenActionAttribute("/databases/*/admin/indexes/start", "POST", "2", "False", "False", "True", "0")]
public Task Start();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminIndexHandler/<Enable>d__5")]
[RavenActionAttribute("/databases/*/admin/indexes/enable", "POST", "2", "False", "False", "True", "0")]
public Task Enable();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminIndexHandler/<Disable>d__6")]
[RavenActionAttribute("/databases/*/admin/indexes/disable", "POST", "2", "False", "False", "True", "0")]
public Task Disable();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminIndexHandler/<Dump>d__7")]
[RavenActionAttribute("/databases/*/admin/indexes/dump", "POST", "2", "False", "False", "True", "0")]
public Task Dump();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminIndexHandler/<OptimizeIndex>d__10")]
[RavenActionAttribute("/databases/*/admin/indexes/optimize", "POST", "2", "False", "False", "True", "0")]
public Task OptimizeIndex();
}
public class Raven.Server.Documents.Handlers.Admin.AdminLogsHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminLogsHandler/<GetConfiguration>d__0")]
[RavenActionAttribute("/admin/logs/configuration", "GET", "1", "False", "False", "True", "0")]
public Task GetConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminLogsHandler/<SetConfiguration>d__1")]
[RavenActionAttribute("/admin/logs/configuration", "POST", "1", "False", "False", "True", "0")]
public Task SetConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminLogsHandler/<RegisterForLogs>d__2")]
[RavenActionAttribute("/admin/logs/watch", "GET", "1", "False", "False", "True", "0")]
public Task RegisterForLogs();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminLogsHandler/<Download>d__3")]
[RavenActionAttribute("/admin/logs/download", "GET", "1", "False", "False", "True", "0")]
public Task Download();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminLogsHandler/<GetMicrosoftLoggers>d__4")]
[RavenActionAttribute("/admin/logs/microsoft/loggers", "GET", "1", "False", "False", "True", "0")]
public Task GetMicrosoftLoggers();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminLogsHandler/<GetMicrosoftConfiguration>d__5")]
[RavenActionAttribute("/admin/logs/microsoft/configuration", "GET", "1", "False", "False", "True", "0")]
public Task GetMicrosoftConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminLogsHandler/<GetMicrosoftLoggersState>d__6")]
[RavenActionAttribute("/admin/logs/microsoft/state", "GET", "1", "False", "False", "True", "0")]
public Task GetMicrosoftLoggersState();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminLogsHandler/<SetMicrosoftConfiguration>d__7")]
[RavenActionAttribute("/admin/logs/microsoft/configuration", "POST", "1", "False", "False", "True", "0")]
public Task SetMicrosoftConfiguration();
    [RavenActionAttribute("/admin/logs/microsoft/enable", "POST", "1", "False", "False", "True", "0")]
public Task EnableMicrosoftLog();
    [RavenActionAttribute("/admin/logs/microsoft/disable", "POST", "1", "False", "False", "True", "0")]
public Task DisableMicrosoftLog();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminLogsHandler/<GetEventListenerConfiguration>d__10")]
[RavenActionAttribute("/admin/event-listener/configuration", "GET", "1", "False", "False", "True", "0")]
public Task GetEventListenerConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminLogsHandler/<SetEventListenerConfiguration>d__11")]
[RavenActionAttribute("/admin/event-listener/configuration", "POST", "1", "False", "False", "True", "0")]
public Task SetEventListenerConfiguration();
}
public class Raven.Server.Documents.Handlers.Admin.AdminMemoryHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminMemoryHandler/<CollectGarbage>d__0")]
[RavenActionAttribute("/admin/memory/gc", "GET", "1", "False", "False", "True", "0")]
public Task CollectGarbage();
}
public class Raven.Server.Documents.Handlers.Admin.AdminRevisionsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminRevisionsHandler/<DeleteRevisionsFor>d__0")]
[RavenActionAttribute("/databases/*/admin/revisions", "DELETE", "2", "False", "False", "True", "0")]
public Task DeleteRevisionsFor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminRevisionsHandler/<ConfigConflictedRevisions>d__1")]
[RavenActionAttribute("/databases/*/admin/revisions/conflicts/config", "POST", "2", "False", "False", "True", "0")]
public Task ConfigConflictedRevisions();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminRevisionsHandler/<PostRevisionsConfiguration>d__2")]
[RavenActionAttribute("/databases/*/admin/revisions/config", "POST", "2", "False", "False", "True", "0")]
public Task PostRevisionsConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminRevisionsHandler/<EnforceConfigRevisions>d__3")]
[RavenActionAttribute("/databases/*/admin/revisions/config/enforce", "POST", "2", "False", "False", "True", "0")]
public Task EnforceConfigRevisions();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminRevisionsHandler/<AdoptOrphans>d__4")]
[RavenActionAttribute("/databases/*/admin/revisions/orphaned/adopt", "POST", "2", "False", "False", "True", "0")]
public Task AdoptOrphans();
}
public class Raven.Server.Documents.Handlers.Admin.AdminScriptRunnersDebugInfoHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminScriptRunnersDebugInfoHandler/<GetJSAdminDebugInfo>d__0")]
[RavenActionAttribute("/admin/debug/script-runners", "GET", "1", "False", "False", "True", "0")]
public Task GetJSAdminDebugInfo();
}
public class Raven.Server.Documents.Handlers.Admin.AdminShardingHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminShardingHandler/<ExecuteMoveDocuments>d__0")]
[RavenActionAttribute("/databases/*/admin/sharding/resharding/cleanup", "POST", "2", "False", "False", "True", "0")]
public Task ExecuteMoveDocuments();
    [RavenActionAttribute("/databases/*/admin/sharding/prefixed", "PUT", "2", "False", "False", "True", "0")]
public Task AddPrefixedShardingSetting();
    [RavenActionAttribute("/databases/*/admin/sharding/prefixed", "DELETE", "2", "False", "False", "True", "0")]
public Task DeletePrefixedShardingSetting();
    [RavenActionAttribute("/databases/*/admin/sharding/prefixed", "POST", "2", "False", "False", "True", "0")]
public Task UpdatePrefixedShardingSetting();
    private void ValidateShardDatabaseName();
}
public class Raven.Server.Documents.Handlers.Admin.AdminSortersHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminSortersHandler/<Put>d__0")]
[RavenActionAttribute("/databases/*/admin/sorters", "PUT", "2", "False", "False", "True", "0")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminSortersHandler/<Delete>d__1")]
[RavenActionAttribute("/databases/*/admin/sorters", "DELETE", "2", "False", "False", "True", "0")]
public Task Delete();
}
public class Raven.Server.Documents.Handlers.Admin.AdminTimeSeriesHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminTimeSeriesHandler/<AddTimeSeriesPolicy>d__0")]
[RavenActionAttribute("/databases/*/admin/timeseries/policy", "PUT", "2", "False", "False", "True", "0")]
public Task AddTimeSeriesPolicy();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminTimeSeriesHandler/<RemoveTimeSeriesPolicy>d__1")]
[RavenActionAttribute("/databases/*/admin/timeseries/policy", "DELETE", "2", "False", "False", "True", "0")]
public Task RemoveTimeSeriesPolicy();
}
public class Raven.Server.Documents.Handlers.Admin.AdminTombstoneHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminTombstoneHandler/<Cleanup>d__0")]
[RavenActionAttribute("/databases/*/admin/tombstones/cleanup", "POST", "2", "False", "False", "True", "0")]
public Task Cleanup();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.AdminTombstoneHandler/<State>d__1")]
[RavenActionAttribute("/databases/*/admin/tombstones/state", "GET", "2", "False", "False", "True", "0")]
public Task State();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractAdminConfigurationHandlerProcessor`1 : AbstractDatabaseHandlerProcessor`1<TOperationContext> {
    protected AbstractAdminConfigurationHandlerProcessor`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractAdminConfigurationHandlerProcessor`1/<UpdateDatabaseRecordAsync>d__1")]
protected ValueTask UpdateDatabaseRecordAsync(ClusterOperationContext context, Action`2<DatabaseRecord, long> action, string raftRequestId, string databaseName);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractAdminConfigurationHandlerProcessorForGetSettings`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminConfigurationHandlerProcessorForGetSettings`2(TRequestHandler requestHandler);
    protected abstract virtual RavenConfiguration GetDatabaseConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractAdminConfigurationHandlerProcessorForGetSettings`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractAdminConfigurationHandlerProcessorForPutClientConfiguration`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminConfigurationHandlerProcessorForPutClientConfiguration`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask WaitForIndexNotificationAsync(long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractAdminConfigurationHandlerProcessorForPutClientConfiguration`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractAdminConfigurationHandlerProcessorForPutSettings`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminConfigurationHandlerProcessorForPutSettings`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask WaitForIndexNotificationAsync(long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractAdminConfigurationHandlerProcessorForPutSettings`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    private static List`1<string> GetUpdatedSettingsKeys(Dictionary`2<string, string> currentSettings, Dictionary`2<string, string> settingsToUpdate);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractAdminConfigurationHandlerProcessorForPutStudioConfiguration`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminConfigurationHandlerProcessorForPutStudioConfiguration`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask WaitForIndexNotificationAsync(long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractAdminConfigurationHandlerProcessorForPutStudioConfiguration`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractHandlerDatabaseProcessorForGetDatabaseRecord`2 : AbstractHandlerProcessorForGetDatabaseRecord`1<TRequestHandler> {
    protected string DatabaseName { get; }
    protected AbstractHandlerDatabaseProcessorForGetDatabaseRecord`2(TRequestHandler requestHandler);
    protected virtual string get_DatabaseName();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractHandlerProcessorForGetDatabaseRecord`1 : AbstractHandlerProcessor`1<TRequestHandler> {
    protected string DatabaseName { get; }
    protected AbstractHandlerProcessorForGetDatabaseRecord`1(TRequestHandler requestHandler);
    protected abstract virtual string get_DatabaseName();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AbstractHandlerProcessorForGetDatabaseRecord`1/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AdminConfigurationHandlerForGetDatabaseRecord : AbstractHandlerDatabaseProcessorForGetDatabaseRecord`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminConfigurationHandlerForGetDatabaseRecord(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AdminConfigurationHandlerProcessorForGetSettings : AbstractAdminConfigurationHandlerProcessorForGetSettings`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminConfigurationHandlerProcessorForGetSettings(DatabaseRequestHandler requestHandler);
    protected virtual RavenConfiguration GetDatabaseConfiguration();
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AdminConfigurationHandlerProcessorForPutClientConfiguration : AbstractAdminConfigurationHandlerProcessorForPutClientConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminConfigurationHandlerProcessorForPutClientConfiguration(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AdminConfigurationHandlerProcessorForPutClientConfiguration/<WaitForIndexNotificationAsync>d__1")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AdminConfigurationHandlerProcessorForPutSettings : AbstractAdminConfigurationHandlerProcessorForPutSettings`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminConfigurationHandlerProcessorForPutSettings(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AdminConfigurationHandlerProcessorForPutSettings/<WaitForIndexNotificationAsync>d__1")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AdminConfigurationHandlerProcessorForPutStudioConfiguration : AbstractAdminConfigurationHandlerProcessorForPutStudioConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminConfigurationHandlerProcessorForPutStudioConfiguration(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Configuration.AdminConfigurationHandlerProcessorForPutStudioConfiguration/<WaitForIndexNotificationAsync>d__1")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForDump`2 : AbstractHandlerProxyReadProcessor`3<object, TRequestHandler, TOperationContext> {
    protected AbstractAdminIndexHandlerProcessorForDump`2(TRequestHandler requestHandler);
    [PreserveBaseOverridesAttribute]
protected virtual override RavenCommand CreateCommandForNode(string nodeTag);
    protected ValueTuple`2<string, string> GetParameters();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForJavaScriptPut`2 : AbstractAdminIndexHandlerProcessorForPut`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminIndexHandlerProcessorForJavaScriptPut`2(TRequestHandler requestHandler);
    protected abstract virtual RavenConfiguration GetDatabaseConfiguration();
    protected abstract virtual ValueTask HandleIndexesFromLegacyReplicationAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForJavaScriptPut`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForPut`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    private bool _validatedAsAdmin;
    protected AbstractAdminIndexHandlerProcessorForPut`2(TRequestHandler requestHandler, bool validatedAsAdmin);
    protected abstract virtual AbstractIndexCreateController GetIndexCreateProcessor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForPut`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForStart`2 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminIndexHandlerProcessorForStart`2(TRequestHandler requestHandler);
    [PreserveBaseOverridesAttribute]
protected virtual override RavenCommand CreateCommandForNode(string nodeTag);
    protected ValueTuple`2<string, string> GetParameters();
    private StringValues GetTypes();
    private StringValues GetNames();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForState`2 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    protected IndexState State;
    protected AbstractAdminIndexHandlerProcessorForState`2(IndexState state, TRequestHandler requestHandler);
    protected abstract virtual AbstractIndexStateController GetIndexStateProcessor();
    [PreserveBaseOverridesAttribute]
protected virtual override RavenCommand CreateCommandForNode(string nodeTag);
    protected string GetName();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForState`2/<ExecuteAsync>d__5")]
public virtual ValueTask ExecuteAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForStaticPut`2 : AbstractAdminIndexHandlerProcessorForPut`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminIndexHandlerProcessorForStaticPut`2(TRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForStop`2 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminIndexHandlerProcessorForStop`2(TRequestHandler requestHandler);
    [PreserveBaseOverridesAttribute]
protected virtual override RavenCommand CreateCommandForNode(string nodeTag);
    protected ValueTuple`2<string, string> GetParameters();
    private StringValues GetTypes();
    private StringValues GetNames();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForTestIndex`2 : AbstractHandlerProxyReadProcessor`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractAdminIndexHandlerProcessorForTestIndex`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AbstractAdminIndexHandlerProcessorForTestIndex`2/<GetTestIndexParametersAsync>d__1")]
protected Task`1<TestIndexParameters> GetTestIndexParametersAsync(JsonOperationContext context);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AdminIndexHandlerProcessorForDump : AbstractAdminIndexHandlerProcessorForDump`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public AdminIndexHandlerProcessorForDump(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AdminIndexHandlerProcessorForDump/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AdminIndexHandlerProcessorForJavaScriptPut : AbstractAdminIndexHandlerProcessorForJavaScriptPut`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminIndexHandlerProcessorForJavaScriptPut(DatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexCreateController GetIndexCreateProcessor();
    protected virtual RavenConfiguration GetDatabaseConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AdminIndexHandlerProcessorForJavaScriptPut/<HandleIndexesFromLegacyReplicationAsync>d__3")]
protected virtual ValueTask HandleIndexesFromLegacyReplicationAsync();
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AdminIndexHandlerProcessorForStart : AbstractAdminIndexHandlerProcessorForStart`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public AdminIndexHandlerProcessorForStart(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AdminIndexHandlerProcessorForState : AbstractAdminIndexHandlerProcessorForState`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public AdminIndexHandlerProcessorForState(IndexState state, DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
    protected virtual AbstractIndexStateController GetIndexStateProcessor();
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AdminIndexHandlerProcessorForStaticPut : AbstractAdminIndexHandlerProcessorForStaticPut`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminIndexHandlerProcessorForStaticPut(DatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexCreateController GetIndexCreateProcessor();
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AdminIndexHandlerProcessorForStop : AbstractAdminIndexHandlerProcessorForStop`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public AdminIndexHandlerProcessorForStop(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AdminIndexHandlerProcessorForTestIndex : AbstractAdminIndexHandlerProcessorForTestIndex`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public AdminIndexHandlerProcessorForTestIndex(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Indexes.AdminIndexHandlerProcessorForTestIndex/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<BlittableJsonReaderObject> command, OperationCancelToken token);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AbstractAdminRevisionsHandlerProcessorForDeleteRevisions`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminRevisionsHandlerProcessorForDeleteRevisions`2(TRequestHandler requestHandler);
    protected abstract virtual Task`1<long> DeleteRevisionsAsync(Parameters parameters, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AbstractAdminRevisionsHandlerProcessorForDeleteRevisions`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AbstractAdminRevisionsHandlerProcessorForPostRevisionsConflictsConfiguration`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractAdminRevisionsHandlerProcessorForPostRevisionsConflictsConfiguration`2(TRequestHandler requestHandler);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AbstractAdminRevisionsHandlerProcessorForRevisionsOperation`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected OperationType _operationType;
    public string Description { get; }
    protected AbstractAdminRevisionsHandlerProcessorForRevisionsOperation`3(TRequestHandler requestHandler, OperationType operationType);
    public abstract virtual string get_Description();
    protected abstract virtual long GetNextOperationId();
    protected abstract virtual void ScheduleEnforceConfigurationOperation(long operationId, TOperationParameters parameters, OperationCancelToken token);
    protected abstract virtual TOperationParameters GetOperationParameters(BlittableJsonReaderObject json);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AbstractAdminRevisionsHandlerProcessorForRevisionsOperation`3/<ExecuteAsync>d__7")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AdminRevisionsHandlerProcessorForAdoptOrphanedRevisions : AdminRevisionsHandlerProcessorForRevisionsOperation`1<Parameters> {
    public string Description { get; }
    public AdminRevisionsHandlerProcessorForAdoptOrphanedRevisions(DatabaseRequestHandler requestHandler);
    public virtual string get_Description();
    protected virtual Parameters GetOperationParameters(BlittableJsonReaderObject json);
    protected virtual Task`1<IOperationResult> ExecuteOperation(Action`1<IOperationProgress> onProgress, Parameters parameters, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AdminRevisionsHandlerProcessorForDeleteRevisions : AbstractAdminRevisionsHandlerProcessorForDeleteRevisions`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminRevisionsHandlerProcessorForDeleteRevisions(DatabaseRequestHandler requestHandler);
    protected virtual Task`1<long> DeleteRevisionsAsync(Parameters request, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AdminRevisionsHandlerProcessorForDeleteRevisions/<DeleteRevisionsByChangeVectorAsync>d__2")]
private Task`1<long> DeleteRevisionsByChangeVectorAsync(string id, List`1<string> cvs, bool includeForceCreated);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AdminRevisionsHandlerProcessorForDeleteRevisions/<DeleteRevisionsByDocumentIdAsync>d__3")]
private Task`1<long> DeleteRevisionsByDocumentIdAsync(List`1<string> ids, Nullable`1<DateTime> from, Nullable`1<DateTime> to, bool includeForceCreated, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AdminRevisionsHandlerProcessorForEnforceRevisionsConfiguration : AdminRevisionsHandlerProcessorForRevisionsOperation`1<Parameters> {
    public string Description { get; }
    public AdminRevisionsHandlerProcessorForEnforceRevisionsConfiguration(DatabaseRequestHandler requestHandler);
    public virtual string get_Description();
    protected virtual Parameters GetOperationParameters(BlittableJsonReaderObject json);
    protected virtual Task`1<IOperationResult> ExecuteOperation(Action`1<IOperationProgress> onProgress, Parameters parameters, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AdminRevisionsHandlerProcessorForPostRevisionsConflictsConfiguration : AbstractAdminRevisionsHandlerProcessorForPostRevisionsConflictsConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminRevisionsHandlerProcessorForPostRevisionsConflictsConfiguration(DatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Revisions.AdminRevisionsHandlerProcessorForRevisionsOperation`1 : AbstractAdminRevisionsHandlerProcessorForRevisionsOperation`3<DatabaseRequestHandler, DocumentsOperationContext, TOperationParameters> {
    public AdminRevisionsHandlerProcessorForRevisionsOperation`1(DatabaseRequestHandler requestHandler, OperationType operationType);
    protected virtual long GetNextOperationId();
    protected abstract virtual Task`1<IOperationResult> ExecuteOperation(Action`1<IOperationProgress> onProgress, TOperationParameters parameters, OperationCancelToken token);
    protected virtual void ScheduleEnforceConfigurationOperation(long operationId, TOperationParameters parameters, OperationCancelToken token);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Sorters.AbstractAdminSortersHandlerProcessorForDelete`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminSortersHandlerProcessorForDelete`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Sorters.AbstractAdminSortersHandlerProcessorForDelete`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Sorters.AbstractAdminSortersHandlerProcessorForPut`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminSortersHandlerProcessorForPut`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Sorters.AbstractAdminSortersHandlerProcessorForPut`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Sorters.AdminSortersHandlerProcessorForDelete : AbstractAdminSortersHandlerProcessorForDelete`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminSortersHandlerProcessorForDelete(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Sorters.AdminSortersHandlerProcessorForPut : AbstractAdminSortersHandlerProcessorForPut`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminSortersHandlerProcessorForPut(DatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.TimeSeries.AbstractAdminTimeSeriesHandlerProcessorForDeleteTimeSeriesPolicy`2 : AbstractTimeSeriesHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminTimeSeriesHandlerProcessorForDeleteTimeSeriesPolicy`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.TimeSeries.AbstractAdminTimeSeriesHandlerProcessorForDeleteTimeSeriesPolicy`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.TimeSeries.AbstractAdminTimeSeriesHandlerProcessorForPutTimeSeriesPolicy`2 : AbstractTimeSeriesHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminTimeSeriesHandlerProcessorForPutTimeSeriesPolicy`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.TimeSeries.AbstractAdminTimeSeriesHandlerProcessorForPutTimeSeriesPolicy`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.TimeSeries.AdminTimeSeriesHandlerProcessorForDeleteTimeSeriesPolicy : AbstractAdminTimeSeriesHandlerProcessorForDeleteTimeSeriesPolicy`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminTimeSeriesHandlerProcessorForDeleteTimeSeriesPolicy(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.TimeSeries.AdminTimeSeriesHandlerProcessorForPutTimeSeriesPolicy : AbstractAdminTimeSeriesHandlerProcessorForPutTimeSeriesPolicy`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminTimeSeriesHandlerProcessorForPutTimeSeriesPolicy(DatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Tombstones.AbstractAdminTombstoneHandlerProcessorForCleanup`2 : AbstractHandlerProxyReadProcessor`3<Response, TRequestHandler, TOperationContext> {
    protected AbstractAdminTombstoneHandlerProcessorForCleanup`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<Response> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Admin.Processors.Tombstones.AbstractAdminTombstoneHandlerProcessorForState`2 : AbstractHandlerProxyReadProcessor`3<Response, TRequestHandler, TOperationContext> {
    protected AbstractAdminTombstoneHandlerProcessorForState`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<Response> CreateCommandForNode(string nodeTag);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Tombstones.AdminTombstoneHandlerProcessorForCleanup : AbstractAdminTombstoneHandlerProcessorForCleanup`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public AdminTombstoneHandlerProcessorForCleanup(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Tombstones.AdminTombstoneHandlerProcessorForCleanup/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<Response> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Admin.Processors.Tombstones.AdminTombstoneHandlerProcessorForState : AbstractAdminTombstoneHandlerProcessorForState`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public AdminTombstoneHandlerProcessorForState(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.Processors.Tombstones.AdminTombstoneHandlerProcessorForState/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<Response> command, OperationCancelToken token);
}
public class Raven.Server.Documents.Handlers.Admin.RachisAdminHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<ApplyCommand>d__0")]
[RavenActionAttribute("/admin/rachis/send", "POST", "1", "False", "False", "True", "0")]
public Task ApplyCommand();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<WaitForIndex>d__1")]
[RavenActionAttribute("/rachis/waitfor", "Get", "3", "1", "False", "False", "True", "0")]
public Task WaitForIndex();
    [RavenActionAttribute("/admin/cluster/observer/suspend", "POST", "1", "False", "False", "True", "0")]
public Task SuspendObserver();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<GetObserverDecisions>d__3")]
[RavenActionAttribute("/admin/cluster/observer/decisions", "GET", "1", "False", "False", "True", "0")]
public Task GetObserverDecisions();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<GetLogs>d__4")]
[RavenActionAttribute("/admin/cluster/log", "GET", "1", "False", "False", "True", "0")]
public Task GetLogs();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<GetHistoryLogs>d__5")]
[RavenActionAttribute("/admin/debug/cluster/history-logs", "GET", "1", "False", "False", "True", "0")]
public Task GetHistoryLogs();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<GetNodeInfo>d__6")]
[RavenActionAttribute("/cluster/node-info", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetNodeInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<GetClusterTopology>d__7")]
[RavenActionAttribute("/cluster/topology", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetClusterTopology();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<ClusterMaintenanceStats>d__8")]
[RavenActionAttribute("/admin/cluster/maintenance-stats", "GET", "1", "False", "False", "True", "0")]
public Task ClusterMaintenanceStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<Bootstrap>d__9")]
[RavenActionAttribute("/admin/cluster/bootstrap", "POST", "0", "False", "False", "True", "0")]
public Task Bootstrap();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<AddNode>d__10")]
[RavenActionAttribute("/admin/cluster/node", "PUT", "0", "False", "False", "True", "0")]
public Task AddNode();
    private static void AssertCanAddNodeWithTopologyId(ClusterTopology clusterTopology, NodeInfo nodeInfo, string nodeUrl);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<DeleteNode>d__12")]
[RavenActionAttribute("/admin/cluster/node", "DELETE", "0", "False", "False", "True", "0")]
public Task DeleteNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<SetLicenseLimit>d__13")]
[RavenActionAttribute("/admin/license/set-limit", "POST", "0", "False", "False", "True", "0")]
public Task SetLicenseLimit();
    [RavenActionAttribute("/admin/cluster/timeout", "POST", "1", "False", "False", "True", "0")]
public Task TimeoutNow();
    [RavenActionAttribute("/admin/cluster/reelect", "POST", "1", "False", "False", "True", "0")]
public Task EnforceReelection();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<PromoteNode>d__16")]
[RavenActionAttribute("/admin/cluster/promote", "POST", "0", "False", "False", "True", "0")]
public Task PromoteNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<DemoteNode>d__17")]
[RavenActionAttribute("/admin/cluster/demote", "POST", "0", "False", "False", "True", "0")]
public Task DemoteNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandler/<RemoveEntryFromLog>d__18")]
[RavenActionAttribute("/admin/cluster/remove-entry-from-log", "POST", "0", "False", "False", "True", "0")]
public Task RemoveEntryFromLog();
}
internal class Raven.Server.Documents.Handlers.Admin.RachisAdminHandlerProcessorForGetClusterLogs : AbstractServerHandlerProxyReadProcessor`1<RaftDebugView> {
    private static string DetailedParameter;
    private bool _detailed;
    private int _take;
    private int _start;
    protected bool SupportsCurrentNode { get; }
    public RachisAdminHandlerProcessorForGetClusterLogs(RequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Admin.RachisAdminHandlerProcessorForGetClusterLogs/<HandleCurrentNodeAsync>d__7")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual ValueTask`1<RavenCommand`1<RaftDebugView>> CreateCommandForNodeAsync(string nodeTag, JsonOperationContext context);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<RaftDebugView> command, JsonOperationContext context, OperationCancelToken token);
}
public class Raven.Server.Documents.Handlers.AnalyzersHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.AnalyzersHandler/<Get>d__0")]
[RavenActionAttribute("/databases/*/analyzers", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
}
public class Raven.Server.Documents.Handlers.AttachmentHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.AttachmentHandler/<Head>d__0")]
[RavenActionAttribute("/databases/*/attachments", "HEAD", "3", "1", "False", "False", "True", "0")]
public Task Head();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.AttachmentHandler/<Get>d__1")]
[RavenActionAttribute("/databases/*/attachments", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.AttachmentHandler/<GetPost>d__2")]
[RavenActionAttribute("/databases/*/attachments", "POST", "3", "1", "False", "False", "True", "0")]
public Task GetPost();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.AttachmentHandler/<GetAttachments>d__3")]
[RavenActionAttribute("/databases/*/attachments/bulk", "POST", "3", "1", "False", "False", "True", "0")]
public Task GetAttachments();
    private static void WriteAttachmentDetails(AsyncBlittableJsonTextWriter writer, Attachment attachment, string documentId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.AttachmentHandler/<GetHashCount>d__5")]
[RavenActionAttribute("/databases/*/debug/attachments/hash", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetHashCount();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.AttachmentHandler/<GetAttachmentMetadataWithCounts>d__6")]
[RavenActionAttribute("/databases/*/debug/attachments/metadata", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetAttachmentMetadataWithCounts();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.AttachmentHandler/<Put>d__7")]
[RavenActionAttribute("/databases/*/attachments", "PUT", "3", "2", "False", "False", "True", "0")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.AttachmentHandler/<Delete>d__8")]
[RavenActionAttribute("/databases/*/attachments", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task Delete();
}
public abstract class Raven.Server.Documents.Handlers.Batches.AbstractBatchCommandParsingObserver : object {
    public abstract virtual void OnCommandStart(UnmanagedJsonParser parser);
    public abstract virtual void OnCommandEnd(UnmanagedJsonParser parser);
    public abstract virtual void OnParserBufferRefill(UnmanagedJsonParser parser);
    public abstract virtual void OnId(UnmanagedJsonParser parser, int idLength, bool isNull);
    public abstract virtual void OnIdsStart(UnmanagedJsonParser parser);
    public abstract virtual void OnIdsEnd(UnmanagedJsonParser parser);
    public abstract virtual void OnNullChangeVector(UnmanagedJsonParser parser);
}
public abstract class Raven.Server.Documents.Handlers.Batches.AbstractBatchCommandsReader`2 : object {
    private static CommandData[] Empty;
    private char _identityPartsSeparator;
    protected BatchRequestParser BatchRequestParser;
    protected RequestHandler Handler;
    private string _database;
    private int _index;
    private CommandData[] _commands;
    protected List`1<string> Identities;
    protected List`1<int> IdentityPositions;
    public bool IsClusterTransactionRequest;
    protected ServerStore ServerStore { get; }
    public ArraySegment`1<CommandData> Commands { get; }
    public bool HasIdentities { get; }
    protected AbstractBatchCommandsReader`2(RequestHandler handler, string database, char identityPartsSeparator, BatchRequestParser batchRequestParser);
    private static AbstractBatchCommandsReader`2();
    protected ServerStore get_ServerStore();
    public ArraySegment`1<CommandData> get_Commands();
    public bool get_HasIdentities();
    private void AddIdentity(JsonOperationContext ctx, CommandData& command, int index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.AbstractBatchCommandsReader`2/<ExecuteGetIdentitiesAsync>d__18")]
protected ValueTask ExecuteGetIdentitiesAsync();
    public abstract virtual ValueTask SaveStreamAsync(JsonOperationContext context, Stream input, CancellationToken token);
    public virtual Task`1<CommandData> ReadCommandAsync(JsonOperationContext ctx, Stream stream, JsonParserState state, UnmanagedJsonParser parser, MemoryBuffer buffer, BlittableMetadataModifier modifier, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.AbstractBatchCommandsReader`2/<BuildCommandsAsync>d__21")]
public Task BuildCommandsAsync(JsonOperationContext context, Stream stream, char separator, CancellationToken token);
    public static bool IsIdentityCommand(CommandData& commandData);
    public static bool IsServerSideIdentityCommand(CommandData& commandData, char identityPartsSeparator);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.AbstractBatchCommandsReader`2/<ParseMultipart>d__24")]
public Task ParseMultipart(JsonOperationContext context, Stream stream, string contentType, char separator, CancellationToken token);
    public abstract virtual ValueTask`1<TBatchCommand> GetCommandAsync(TOperationContext context);
    [DoesNotReturnAttribute]
private static void ThrowInvalidUsageOfChangeVectorWithIdentities(CommandData commandData);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Handlers.Batches.BatchHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.BatchHandler/<BulkDocs>d__0")]
[RavenActionAttribute("/databases/*/bulk_docs", "POST", "3", "2", "False", "False", "True", "0")]
public Task BulkDocs();
}
public class Raven.Server.Documents.Handlers.Batches.BatchRequestParser : object {
    internal static BatchRequestParser Instance;
    private static int MaxSizeOfCommandsInBatchToCache;
    [ThreadStaticAttribute]
private static Stack`1<CommandData[]> _cache;
    [CompilerGeneratedAttribute]
private AbstractBatchCommandParsingObserver <CommandParsingObserver>k__BackingField;
    public AbstractBatchCommandParsingObserver CommandParsingObserver { get; public set; }
    private static BatchRequestParser();
    public static void ReturnBuffer(ArraySegment`1<CommandData> cmds);
    private static void ReturnBuffer(CommandData[] cmds);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.BatchRequestParser/<IsClusterTransaction>d__7")]
public Task`1<bool> IsClusterTransaction(Stream stream, UnmanagedJsonParser parser, MemoryBuffer buffer, JsonParserState state);
    private static bool ReadClusterTransactionProperty(JsonParserState state);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.BatchRequestParser/<ReadSingleCommand>d__9")]
public Task`1<CommandData> ReadSingleCommand(JsonOperationContext ctx, Stream stream, JsonParserState state, UnmanagedJsonParser parser, MemoryBuffer buffer, BlittableMetadataModifier modifier, CancellationToken token);
    public static CommandData[] IncreaseSizeOfCommandsBuffer(int index, CommandData[] cmds);
    [DoesNotReturnAttribute]
private static void ThrowInvalidType();
    [DoesNotReturnAttribute]
private static void ThrowMissingDocumentProperty();
    [DoesNotReturnAttribute]
private static void ThrowMissingPatchProperty();
    [DoesNotReturnAttribute]
private static void ThrowMissingNameProperty();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.BatchRequestParser/<ReadJsonArray>d__15")]
private Task`1<BlittableJsonReaderArray> ReadJsonArray(JsonOperationContext ctx, Stream stream, UnmanagedJsonParser parser, JsonParserState state, MemoryBuffer buffer, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.BatchRequestParser/<ReadJsonObject>d__16")]
private Task`1<BlittableJsonReaderObject> ReadJsonObject(JsonOperationContext ctx, Stream stream, string id, UnmanagedJsonParser parser, JsonParserState state, MemoryBuffer buffer, IBlittableDocumentModifier modifier, CancellationToken token);
    private static string GetStringPropertyValue(JsonParserState state);
    private static LazyStringValue GetLazyStringValue(JsonOperationContext ctx, JsonParserState state);
    private static CommandPropertyName GetPropertyType(JsonParserState state);
    private static ForceRevisionStrategy GetEnumValue(JsonParserState state, JsonOperationContext ctx);
    private static AttachmentType GetAttachmentType(JsonParserState state, JsonOperationContext ctx);
    private static CommandType GetCommandType(JsonParserState state, JsonOperationContext ctx);
    [DoesNotReturnAttribute]
private static void ThrowInvalidProperty(JsonParserState state, JsonOperationContext ctx);
    [DoesNotReturnAttribute]
private static void ThrowInvalidCommandType(JsonParserState state, JsonOperationContext ctx);
    [DoesNotReturnAttribute]
public static void ThrowUnexpectedToken(JsonParserToken jsonParserToken, JsonParserState state);
    [CompilerGeneratedAttribute]
public AbstractBatchCommandParsingObserver get_CommandParsingObserver();
    [CompilerGeneratedAttribute]
public void set_CommandParsingObserver(AbstractBatchCommandParsingObserver value);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.BatchRequestParser/<RefillParserBuffer>d__31")]
public Task RefillParserBuffer(Stream stream, MemoryBuffer buffer, UnmanagedJsonParser parser, CancellationToken token);
    [DoesNotReturnAttribute]
private static void ThrowUnexpectedEndOfStream();
}
public class Raven.Server.Documents.Handlers.Batches.Commands.ClusterTransactionMergedCommand : TransactionMergedCommand {
    private ArraySegment`1<SingleClusterDatabaseCommand> _batch;
    public Dictionary`2<long, DynamicJsonArray> Replies;
    public Dictionary`2<long, ClusterTransactionOptions> Options;
    public ClusterTransactionMergedCommand(DocumentDatabase database, ArraySegment`1<SingleClusterDatabaseCommand> batch);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    [PreserveBaseOverridesAttribute]
public virtual override IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, DocumentMergedTransactionCommand> ToDto(DocumentsOperationContext context);
    private CollectionName GetCollection(DocumentsOperationContext context, DocumentOrTombstone item);
    private CollectionName GetFirstConflictCollection(DocumentsOperationContext context, ClusterTransactionDataCommand cmd);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Handlers.Batches.Commands.ClusterTransactionMergedCommandDto : object {
    [CompilerGeneratedAttribute]
private List`1<SingleClusterDatabaseCommand> <Batch>k__BackingField;
    public List`1<SingleClusterDatabaseCommand> Batch { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<SingleClusterDatabaseCommand> get_Batch();
    [CompilerGeneratedAttribute]
public void set_Batch(List`1<SingleClusterDatabaseCommand> value);
    public sealed virtual ClusterTransactionMergedCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public interface Raven.Server.Documents.Handlers.Batches.Commands.IBatchCommand {
    public bool IncludeReply { get; public set; }
    public HashSet`1<string> ModifiedCollections { get; public set; }
    public string LastChangeVector { get; public set; }
    public long LastTombstoneEtag { get; public set; }
    public bool IsClusterTransaction { get; public set; }
    public abstract virtual bool get_IncludeReply();
    public abstract virtual void set_IncludeReply(bool value);
    public abstract virtual HashSet`1<string> get_ModifiedCollections();
    public abstract virtual void set_ModifiedCollections(HashSet`1<string> value);
    public abstract virtual string get_LastChangeVector();
    public abstract virtual void set_LastChangeVector(string value);
    public abstract virtual long get_LastTombstoneEtag();
    public abstract virtual void set_LastTombstoneEtag(long value);
    public abstract virtual bool get_IsClusterTransaction();
    public abstract virtual void set_IsClusterTransaction(bool value);
}
public class Raven.Server.Documents.Handlers.Batches.Commands.MergedBatchCommand : TransactionMergedCommand {
    public ArraySegment`1<CommandData> ParsedCommands;
    public List`1<AttachmentStream> AttachmentStreams;
    public StreamsTempFile AttachmentStreamsTempFile;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, List`1<ValueTuple`2<DynamicJsonValue, string>>> _documentsToUpdateAfterAttachmentChange;
    private List`1<IDisposable> _toDispose;
    private static AppendOptions AppendOptionsForTimeSeriesCopy;
    public MergedBatchCommand(DocumentDatabase database);
    private static MergedBatchCommand();
    public virtual string ToString();
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    [PreserveBaseOverridesAttribute]
public virtual override IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, DocumentMergedTransactionCommand> ToDto(DocumentsOperationContext context);
    private string EtlGetDocIdFromPrefixIfNeeded(string docId, CommandData cmd, Nullable`1<PutOperationResults> lastPutResult);
    public virtual void Dispose();
    [DoesNotReturnAttribute]
private void ThrowUnexpectedOrderOfRavenEtlCommands(string source);
}
public class Raven.Server.Documents.Handlers.Batches.Commands.MergedBatchCommandDto : object {
    [CompilerGeneratedAttribute]
private CommandData[] <ParsedCommands>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AttachmentStream> <AttachmentStreams>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeReply>k__BackingField;
    public CommandData[] ParsedCommands { get; public set; }
    public List`1<AttachmentStream> AttachmentStreams { get; public set; }
    public bool IncludeReply { get; public set; }
    [CompilerGeneratedAttribute]
public CommandData[] get_ParsedCommands();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParsedCommands(CommandData[] value);
    [CompilerGeneratedAttribute]
public List`1<AttachmentStream> get_AttachmentStreams();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AttachmentStreams(List`1<AttachmentStream> value);
    [CompilerGeneratedAttribute]
public bool get_IncludeReply();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeReply(bool value);
    public sealed virtual MergedBatchCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public abstract class Raven.Server.Documents.Handlers.Batches.Commands.TransactionMergedCommand : DocumentMergedTransactionCommand {
    protected DocumentDatabase Database;
    public DynamicJsonArray Reply;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ModifiedCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastTombstoneEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastDocumentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClusterTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeReply>k__BackingField;
    public HashSet`1<string> ModifiedCollections { get; public set; }
    public string LastChangeVector { get; public set; }
    public long LastTombstoneEtag { get; public set; }
    public long LastDocumentEtag { get; public set; }
    public bool IsClusterTransaction { get; public set; }
    public bool IncludeReply { get; public set; }
    protected TransactionMergedCommand(DocumentDatabase database);
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<string> get_ModifiedCollections();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ModifiedCollections(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LastChangeVector();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastChangeVector(string value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_LastTombstoneEtag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastTombstoneEtag(long value);
    [CompilerGeneratedAttribute]
public long get_LastDocumentEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocumentEtag(long value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsClusterTransaction();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsClusterTransaction(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeReply();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeReply(bool value);
    protected void AddPutResult(PutOperationResults putResult);
    protected void AddDeleteResult(Nullable`1<DeleteOperationResult> deleted, string id);
    protected void DeleteWithPrefix(DocumentsOperationContext context, string id);
    public abstract virtual void Dispose();
}
public class Raven.Server.Documents.Handlers.Batches.DatabaseBatchCommandsReader : AbstractBatchCommandsReader`2<MergedBatchCommand, DocumentsOperationContext> {
    private DocumentDatabase _database;
    public List`1<AttachmentStream> AttachmentStreams;
    public StreamsTempFile AttachmentStreamsTempFile;
    public DatabaseBatchCommandsReader(RequestHandler handler, DocumentDatabase database);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.DatabaseBatchCommandsReader/<SaveStreamAsync>d__4")]
public virtual ValueTask SaveStreamAsync(JsonOperationContext context, Stream input, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Batches.DatabaseBatchCommandsReader/<GetCommandAsync>d__5")]
public virtual ValueTask`1<MergedBatchCommand> GetCommandAsync(DocumentsOperationContext context);
}
public interface Raven.Server.Documents.Handlers.Batches.IBatchCommandData {
    public CommandType Type { get; }
    public string Id { get; }
    public AttachmentStream AttachmentStream { get; public set; }
    public long ContentLength { get; }
    public abstract virtual CommandType get_Type();
    public abstract virtual string get_Id();
    public abstract virtual AttachmentStream get_AttachmentStream();
    public abstract virtual void set_AttachmentStream(AttachmentStream value);
    public abstract virtual long get_ContentLength();
}
public abstract class Raven.Server.Documents.Handlers.BulkInsert.AbstractBulkInsertBatchCommandsReader`1 : object {
    private Stream _stream;
    private UnmanagedJsonParser _parser;
    private MemoryBuffer _buffer;
    protected BatchRequestParser BatchRequestParser;
    private JsonParserState _state;
    private CancellationToken _token;
    protected AbstractBulkInsertBatchCommandsReader`1(JsonOperationContext ctx, Stream stream, MemoryBuffer buffer, BatchRequestParser batchRequestParser, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.BulkInsert.AbstractBulkInsertBatchCommandsReader`1/<InitAsync>d__7")]
public Task InitAsync();
    public abstract virtual Task`1<TCommandData> GetCommandAsync(JsonOperationContext ctx, BlittableMetadataModifier modifier);
    protected Task`1<CommandData> MoveNextAsync(JsonOperationContext ctx, BlittableMetadataModifier modifier);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.BulkInsert.AbstractBulkInsertBatchCommandsReader`1/<MoveNextUnlikely>d__10")]
private Task`1<CommandData> MoveNextUnlikely(JsonOperationContext ctx, BlittableMetadataModifier modifier);
    public Stream GetBlob(long blobSize);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Handlers.BulkInsert.BulkInsertBatchCommandsReader : AbstractBulkInsertBatchCommandsReader`1<CommandData> {
    public BulkInsertBatchCommandsReader(JsonOperationContext ctx, Stream stream, MemoryBuffer buffer, CancellationToken token);
    public virtual Task`1<CommandData> GetCommandAsync(JsonOperationContext ctx, BlittableMetadataModifier modifier);
}
public class Raven.Server.Documents.Handlers.BulkInsert.BulkInsertHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.BulkInsert.BulkInsertHandler/<BulkInsert>d__0")]
[RavenActionAttribute("/databases/*/bulk_insert", "POST", "3", "2", "False", "False", "True", "0")]
public Task BulkInsert();
}
public class Raven.Server.Documents.Handlers.ChangesHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ChangesHandler/<GetChanges>d__0")]
[RavenActionAttribute("/databases/*/changes", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetChanges();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ChangesHandler/<GetConnectionsDebugInfo>d__1")]
[RavenActionAttribute("/databases/*/changes/debug", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetConnectionsDebugInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ChangesHandler/<DeleteConnections>d__2")]
[RavenActionAttribute("/databases/*/changes", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task DeleteConnections();
}
public class Raven.Server.Documents.Handlers.CollectionsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.CollectionsHandler/<GetCollectionStats>d__0")]
[RavenActionAttribute("/databases/*/collections/stats", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetCollectionStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.CollectionsHandler/<GetDetailedCollectionStats>d__1")]
[RavenActionAttribute("/databases/*/collections/stats/detailed", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetDetailedCollectionStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.CollectionsHandler/<GetCollectionDocuments>d__2")]
[RavenActionAttribute("/databases/*/collections/docs", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetCollectionDocuments();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.CollectionsHandler/<GetLastDocumentChangeVectorForCollection>d__3")]
[RavenActionAttribute("/databases/*/collections/last-change-vector", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetLastDocumentChangeVectorForCollection();
}
public class Raven.Server.Documents.Handlers.ConfigurationHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ConfigurationHandler/<GetStudioConfiguration>d__0")]
[RavenActionAttribute("/databases/*/configuration/studio", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetStudioConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ConfigurationHandler/<GetClientConfiguration>d__1")]
[RavenActionAttribute("/databases/*/configuration/client", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetClientConfiguration();
}
public class Raven.Server.Documents.Handlers.CountersHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.CountersHandler/<Get>d__2")]
[RavenActionAttribute("/databases/*/counters", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.CountersHandler/<Batch>d__3")]
[RavenActionAttribute("/databases/*/counters", "POST", "3", "2", "False", "False", "True", "0")]
public Task Batch();
    [DoesNotReturnAttribute]
private static void ThrowMissingDocument(string docId);
}
public class Raven.Server.Documents.Handlers.DataArchivalHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DataArchivalHandler/<GetArchivalConfig>d__0")]
[RavenActionAttribute("/databases/*/data-archival/config", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetArchivalConfig();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DataArchivalHandler/<ConfigArchival>d__1")]
[RavenActionAttribute("/databases/*/admin/data-archival/config", "POST", "2", "False", "False", "True", "0")]
public Task ConfigArchival();
}
public class Raven.Server.Documents.Handlers.Debugging.AllDocumentIdsDebugHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.AllDocumentIdsDebugHandler/<ExportAllDocIds>d__0")]
[RavenActionAttribute("/databases/*/debug/documents/export-all-ids", "GET", "3", "1", "False", "False", "True", "0")]
public Task ExportAllDocIds();
}
public class Raven.Server.Documents.Handlers.Debugging.DatabaseDebugInfoPackageHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.DatabaseDebugInfoPackageHandler/<GetInfoPackage>d__0")]
[RavenActionAttribute("/databases/*/debug/info-package", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetInfoPackage();
}
public class Raven.Server.Documents.Handlers.Debugging.DocumentDebugHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.DocumentDebugHandler/<HugeDocuments>d__0")]
[RavenActionAttribute("/databases/*/debug/documents/huge", "GET", "3", "1", "False", "False", "True", "0")]
public Task HugeDocuments();
}
public class Raven.Server.Documents.Handlers.Debugging.IdentityDebugHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.IdentityDebugHandler/<GetIdentities>d__0")]
[RavenActionAttribute("/databases/*/debug/identities", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetIdentities();
}
public class Raven.Server.Documents.Handlers.Debugging.MemoryDebugHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.MemoryDebugHandler/<GcInfo>d__0")]
[RavenActionAttribute("/admin/debug/memory/gc", "GET", "1", "False", "False", "True", "0")]
public Task GcInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.MemoryDebugHandler/<LowMemLog>d__1")]
[RavenActionAttribute("/admin/debug/memory/low-mem-log", "GET", "1", "False", "False", "True", "0")]
public Task LowMemLog();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.MemoryDebugHandler/<PosixMemStatus>d__2")]
[RavenActionAttribute("/admin/debug/proc/status", "GET", "1", "False", "False", "True", "0")]
public Task PosixMemStatus();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.MemoryDebugHandler/<PosixMemInfo>d__3")]
[RavenActionAttribute("/admin/debug/proc/meminfo", "GET", "1", "False", "False", "True", "0")]
public Task PosixMemInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.MemoryDebugHandler/<WriteFile>d__4")]
private Task WriteFile(string file);
    public static DynamicJsonValue LowMemLogInternal();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.MemoryDebugHandler/<MemorySmaps>d__6")]
[RavenActionAttribute("/admin/debug/memory/smaps", "GET", "1", "False", "False", "True", "0")]
public Task MemorySmaps();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.MemoryDebugHandler/<MemoryStats>d__7")]
[RavenActionAttribute("/admin/debug/memory/stats", "GET", "1", "False", "False", "True", "0")]
public Task MemoryStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.MemoryDebugHandler/<EncryptionBufferPoolStats>d__8")]
[RavenActionAttribute("/admin/debug/memory/encryption-buffer-pool", "GET", "1", "False", "False", "True", "0")]
public Task EncryptionBufferPoolStats();
    private static void WriteMemoryStats(TWriter writer, JsonOperationContext context, bool includeThreads, bool includeMappings);
    private static void WriteThreads(bool includeThreads, TWriter writer, JsonOperationContext context);
    private static void WriteMappings(bool includeMappings, TWriter writer, JsonOperationContext context, Dictionary`2<string, long> fileMappingSizesByDir, Dictionary`2<string, Dictionary`2<string, ConcurrentDictionary`2<IntPtr, long>>> fileMappingByDir);
    private static long GetFileSize(string file);
    public static int LongestCommonPrefixLength(List`1<string> strings);
    [CompilerGeneratedAttribute]
internal static DynamicJsonValue <GcInfo>g__ToJson|0_0(GCMemoryInfo info);
}
public class Raven.Server.Documents.Handlers.Debugging.NodeDebugHandler : ServerRequestHandler {
    [RavenActionAttribute("/admin/debug/node/clear-http-clients-pool", "GET", "0", "False", "False", "True", "0")]
public Task ClearHttpClientsPool();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.NodeDebugHandler/<ListRemoteConnections>d__1")]
[RavenActionAttribute("/admin/debug/node/remote-connections", "GET", "1", "False", "False", "True", "0")]
public Task ListRemoteConnections();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.NodeDebugHandler/<ListRecentEngineLogs>d__2")]
[RavenActionAttribute("/admin/debug/node/engine-logs", "GET", "1", "False", "False", "True", "0")]
public Task ListRecentEngineLogs();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.NodeDebugHandler/<GetStateChangeHistory>d__3")]
[RavenActionAttribute("/admin/debug/node/state-change-history", "GET", "1", "False", "False", "True", "0")]
public Task GetStateChangeHistory();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.NodeDebugHandler/<PingTest>d__4")]
[RavenActionAttribute("/admin/debug/node/ping", "GET", "1", "False", "False", "True", "0")]
public Task PingTest();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.NodeDebugHandler/<PingOnce>d__9")]
private Task`1<PingResult> PingOnce(string url);
}
internal abstract class Raven.Server.Documents.Handlers.Debugging.Processors.AbstractQueriesDebugHandlerProcessorForKillQuery`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractQueriesDebugHandlerProcessorForKillQuery`2(TRequestHandler requestHandler);
    protected abstract virtual AbstractQueryRunner GetQueryRunner();
    public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Debugging.Processors.AbstractQueriesDebugHandlerProcessorForQueriesCacheList`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractQueriesDebugHandlerProcessorForQueriesCacheList`2(TRequestHandler requestHandler);
    protected abstract virtual QueryMetadataCache GetQueryMetadataCache();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.Processors.AbstractQueriesDebugHandlerProcessorForQueriesCacheList`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Debugging.Processors.AbstractQueriesDebugHandlerProcessorForRunningQueries`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractQueriesDebugHandlerProcessorForRunningQueries`2(TRequestHandler requestHandler);
    protected abstract virtual AbstractQueryRunner GetQueryRunner();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.Processors.AbstractQueriesDebugHandlerProcessorForRunningQueries`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Debugging.Processors.AbstractTransactionDebugHandlerProcessorForGetClusterInfo`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractTransactionDebugHandlerProcessorForGetClusterInfo`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.Processors.AbstractTransactionDebugHandlerProcessorForGetClusterInfo`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Debugging.Processors.QueriesDebugHandlerProcessorForKillQuery : AbstractQueriesDebugHandlerProcessorForKillQuery`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public QueriesDebugHandlerProcessorForKillQuery(DatabaseRequestHandler requestHandler);
    protected virtual AbstractQueryRunner GetQueryRunner();
}
internal class Raven.Server.Documents.Handlers.Debugging.Processors.QueriesDebugHandlerProcessorForQueriesCacheList : AbstractQueriesDebugHandlerProcessorForQueriesCacheList`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public QueriesDebugHandlerProcessorForQueriesCacheList(DatabaseRequestHandler requestHandler);
    protected virtual QueryMetadataCache GetQueryMetadataCache();
}
internal class Raven.Server.Documents.Handlers.Debugging.Processors.QueriesDebugHandlerProcessorForRunningQueries : AbstractQueriesDebugHandlerProcessorForRunningQueries`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public QueriesDebugHandlerProcessorForRunningQueries(DatabaseRequestHandler requestHandler);
    protected virtual AbstractQueryRunner GetQueryRunner();
}
internal class Raven.Server.Documents.Handlers.Debugging.Processors.TransactionDebugHandlerProcessorForGetClusterInfo : AbstractTransactionDebugHandlerProcessorForGetClusterInfo`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public TransactionDebugHandlerProcessorForGetClusterInfo(DatabaseRequestHandler requestHandler);
}
public class Raven.Server.Documents.Handlers.Debugging.ProcStatsHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ProcStatsHandler/<CpuStats>d__0")]
[RavenActionAttribute("/admin/debug/cpu/stats", "GET", "1", "False", "False", "True", "0")]
public Task CpuStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ProcStatsHandler/<ProcStats>d__1")]
[RavenActionAttribute("/admin/debug/proc/stats", "GET", "1", "False", "False", "True", "0")]
public Task ProcStats();
    private DynamicJsonValue CpuStatsInternal();
    private DynamicJsonValue ProcStatsInternal();
    private DynamicJsonArray GetProcessThreadCollection(Process proc);
    private DynamicJsonArray GetProcessModuleCollection(Process proc);
    private static void AddValue(DynamicJsonValue djv, string key, Func`1<T> func);
}
public class Raven.Server.Documents.Handlers.Debugging.QueriesDebugHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.QueriesDebugHandler/<KillQuery>d__0")]
[RavenActionAttribute("/databases/*/debug/queries/kill", "POST", "3", "2", "False", "False", "True", "0")]
public Task KillQuery();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.QueriesDebugHandler/<RunningQueries>d__1")]
[RavenActionAttribute("/databases/*/debug/queries/running", "GET", "3", "1", "False", "False", "True", "0")]
public Task RunningQueries();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.QueriesDebugHandler/<QueriesCacheList>d__2")]
[RavenActionAttribute("/databases/*/debug/queries/cache/list", "GET", "3", "1", "False", "False", "True", "0")]
public Task QueriesCacheList();
}
public class Raven.Server.Documents.Handlers.Debugging.RevisionsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.RevisionsHandler/<GetRevisions>d__0")]
[RavenActionAttribute("/databases/*/debug/documents/get-revisions", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetRevisions();
}
public class Raven.Server.Documents.Handlers.Debugging.ScriptRunnersDebugInfoHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ScriptRunnersDebugInfoHandler/<GetJSDebugInfo>d__0")]
[RavenActionAttribute("/databases/*/debug/script-runners", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetJSDebugInfo();
}
public class Raven.Server.Documents.Handlers.Debugging.ServerInfoHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerInfoHandler/<ServerId>d__0")]
[RavenActionAttribute("/debug/server-id", "GET", "3", "1", "False", "False", "True", "0")]
public Task ServerId();
}
public class Raven.Server.Documents.Handlers.Debugging.ServerTransactionDebugHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerTransactionDebugHandler/<TxInfo>d__0")]
[RavenActionAttribute("/admin/debug/txinfo", "GET", "1", "False", "False", "True", "0")]
public Task TxInfo();
}
public class Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler : ServerRequestHandler {
    internal static string _serverWidePrefix;
    internal static String[] FieldsThatShouldBeExposedForDebug;
    private Logger _logger;
    private static ServerWideDebugInfoPackageHandler();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<GetClusterWideInfoPackageForRemote>d__3")]
[RavenActionAttribute("/admin/debug/remote-cluster-info-package", "GET", "1", "False", "False", "True", "0")]
public Task GetClusterWideInfoPackageForRemote();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<GetClusterWideInfoPackage>d__4")]
[RavenActionAttribute("/admin/debug/cluster-info-package", "GET", "1", "False", "False", "True", "0")]
public Task GetClusterWideInfoPackage();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<WriteDebugInfoPackageForNodeAsync>d__5")]
private Task WriteDebugInfoPackageForNodeAsync(JsonOperationContext context, ZipArchive archive, string tag, string url, OperationCancelToken clusterOperationToken, int timeoutInSecPerNode, StringValues databases, DebugInfoPackageContentType contentType);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<GetInfoPackage>d__6")]
[RavenActionAttribute("/admin/debug/info-package", "GET", "1", "False", "False", "True", "0")]
public Task GetInfoPackage();
    private DebugInfoPackageContentType GetDebugInfoPackageContentType();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<WriteLogFile>d__8")]
private static Task WriteLogFile(ZipArchive archive, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<GetDebugInfoFromNodeAsync>d__9")]
private Task`1<Stream> GetDebugInfoFromNodeAsync(JsonOperationContext context, RequestExecutor requestExecutor, long operationId, OperationCancelToken token, int timeoutInSec, StringValues databases, DebugInfoPackageContentType contentType);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<WriteForAllLocalDatabases>d__10")]
private Task WriteForAllLocalDatabases(ZipArchive archive, JsonOperationContext jsonOperationContext, LocalEndpointClient localEndpointClient, StringValues databases, CancellationToken token);
    private static bool IsDatabaseBeingDeleted(string tag, RawDatabaseRecord databaseRecord);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<WriteDatabaseInfo>d__12")]
private Task WriteDatabaseInfo(ZipArchive archive, JsonOperationContext jsonOperationContext, LocalEndpointClient localEndpointClient, string databaseName, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<WriteServerInfo>d__13")]
private Task WriteServerInfo(ZipArchive archive, JsonOperationContext jsonOperationContext, LocalEndpointClient localEndpointClient, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<WriteForServerOrDatabase>d__14")]
private Task WriteForServerOrDatabase(ZipArchive archive, JsonOperationContext context, LocalEndpointClient localEndpointClient, RouteType routeType, string path, string databaseName, Dictionary`2<string, StringValues> endpointParameters, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<InvokeAndWriteToArchive>d__15")]
internal static Task InvokeAndWriteToArchive(ZipArchive archive, JsonOperationContext jsonOperationContext, LocalEndpointClient localEndpointClient, RouteInformation route, string path, Dictionary`2<string, StringValues> endpointParameters, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideDebugInfoPackageHandler/<WriteDatabaseRecord>d__16")]
private Task WriteDatabaseRecord(ZipArchive archive, string databaseName, JsonOperationContext jsonOperationContext, TransactionOperationContext transactionCtx);
    public BlittableJsonReaderObject GetDatabaseRecordForDebugPackage(TransactionOperationContext context, string databaseName);
    [CompilerGeneratedAttribute]
private HashSet`1<string> <WriteForAllLocalDatabases>g__GetDatabases|10_0(<>c__DisplayClass10_0& , <>c__DisplayClass10_1& );
}
public class Raven.Server.Documents.Handlers.Debugging.ServerWideQueriesDebugHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ServerWideQueriesDebugHandler/<RunningQueriesLive>d__0")]
[RavenActionAttribute("/debug/queries/running/live", "GET", "3", "1", "False", "False", "True", "0")]
public Task RunningQueriesLive();
}
public class Raven.Server.Documents.Handlers.Debugging.StorageHandler : DatabaseRequestHandler {
    [RavenActionAttribute("/databases/*/admin/storage/manual-flush", "POST", "2", "False", "False", "True", "0")]
public Task ManualFlush();
    [RavenActionAttribute("/databases/*/admin/storage/manual-sync", "POST", "2", "False", "False", "True", "0")]
public Task ManualSync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.StorageHandler/<Pages>d__2")]
[RavenActionAttribute("/databases/*/debug/storage/environment/debug-only/pages", "GET", "3", "1", "False", "False", "True", "0")]
public Task Pages();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.StorageHandler/<Trees>d__3")]
[RavenActionAttribute("/databases/*/debug/storage/trees", "GET", "3", "1", "False", "False", "True", "0")]
public Task Trees();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.StorageHandler/<BTreeStructure>d__4")]
[RavenActionAttribute("/databases/*/debug/storage/btree-structure", "GET", "3", "1", "False", "False", "True", "0")]
public Task BTreeStructure();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.StorageHandler/<FixedSizeTreeStructure>d__5")]
[RavenActionAttribute("/databases/*/debug/storage/fst-structure", "GET", "3", "1", "False", "False", "True", "0")]
public Task FixedSizeTreeStructure();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.StorageHandler/<GetTreeNames>d__6")]
private static IEnumerable`1<string> GetTreeNames(Transaction tx, RootObjectType type);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.StorageHandler/<Report>d__7")]
[RavenActionAttribute("/databases/*/debug/storage/report", "GET", "3", "1", "False", "False", "True", "0")]
public Task Report();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.StorageHandler/<AllEnvironmentsReport>d__8")]
[RavenActionAttribute("/databases/*/debug/storage/all-environments/report", "GET", "3", "1", "False", "False", "True", "0")]
public Task AllEnvironmentsReport();
    private void WriteAllEnvs(TWriter writer, DocumentsOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.StorageHandler/<GetEnvironmentReport>d__10")]
[RavenActionAttribute("/databases/*/debug/storage/environment/report", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetEnvironmentReport();
    private DetailedStorageReport GetDetailedReport(StorageEnvironmentWithType environment, bool details);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.StorageHandler/<CompressionDictionary>d__12")]
[RavenActionAttribute("/databases/*/debug/storage/compression-dictionaries", "GET", "3", "1", "False", "False", "True", "0")]
public Task CompressionDictionary();
    private static void WriteCompressionDictionaries(AsyncBlittableJsonTextWriterForDebug writer, CompressionDictionary[] dictionaries, string sourceName);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.StorageHandler/<ScratchBufferPoolInfoReport>d__14")]
[RavenActionAttribute("/databases/*/debug/storage/environment/scratch-buffer-info", "GET", "3", "1", "False", "False", "True", "0")]
public Task ScratchBufferPoolInfoReport();
}
public class Raven.Server.Documents.Handlers.Debugging.ThreadsHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ThreadsHandler/<StackTrace>d__0")]
[RavenActionAttribute("/admin/debug/threads/stack-trace", "GET", "1", "False", "False", "True", "0")]
public Task StackTrace();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ThreadsHandler/<RunawayThreads>d__1")]
[RavenActionAttribute("/admin/debug/threads/runaway", "GET", "1", "False", "False", "True", "0")]
public Task RunawayThreads();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.ThreadsHandler/<Contention>d__2")]
[RavenActionAttribute("/admin/debug/threads/contention", "GET", "1", "False", "False", "True", "0")]
public Task Contention();
    public static void OutputResultToStream(TextWriter sw, HashSet`1<string> threadIds, bool includeStackObjects);
}
public class Raven.Server.Documents.Handlers.Debugging.TransactionDebugHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.TransactionDebugHandler/<TxInfo>d__1")]
[RavenActionAttribute("/databases/*/admin/debug/txinfo", "GET", "2", "False", "False", "True", "0")]
public Task TxInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Debugging.TransactionDebugHandler/<ClusterTxInfo>d__2")]
[RavenActionAttribute("/databases/*/admin/debug/cluster/txinfo", "GET", "2", "False", "False", "True", "0")]
public Task ClusterTxInfo();
    internal static DynamicJsonArray ToJson(List`1<TransactionInfo> txInfos);
    private static DynamicJsonValue ToJson(TransactionInfo txinfo);
    private static DynamicJsonValue ToJson(LowLevelTransaction lowLevelTransaction);
}
internal class Raven.Server.Documents.Handlers.Debugging.TxInfoResult : object {
    public int TransactionId;
    public int ThreadId;
    public string ThreadName;
    public int StartTime;
    public int TotalTime;
    public bool FlushInProgressLockTaken;
    public TransactionFlags Flags;
    public bool IsCloned;
    public long NumberOfModifiedPages;
    public bool Committed;
    public string TotalEncryptionBufferSize;
}
public class Raven.Server.Documents.Handlers.DocumentHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DocumentHandler/<Head>d__0")]
[RavenActionAttribute("/databases/*/docs", "HEAD", "3", "1", "False", "False", "True", "0")]
public Task Head();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DocumentHandler/<GetDocSize>d__1")]
[RavenActionAttribute("/databases/*/docs/size", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetDocSize();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DocumentHandler/<Get>d__2")]
[RavenActionAttribute("/databases/*/docs", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DocumentHandler/<PostGet>d__3")]
[RavenActionAttribute("/databases/*/docs", "POST", "3", "1", "False", "False", "True", "0")]
public Task PostGet();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DocumentHandler/<Delete>d__4")]
[RavenActionAttribute("/databases/*/docs", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task Delete();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DocumentHandler/<Put>d__5")]
[RavenActionAttribute("/databases/*/docs", "PUT", "3", "2", "False", "False", "True", "0")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DocumentHandler/<Patch>d__6")]
[RavenActionAttribute("/databases/*/docs", "PATCH", "3", "2", "False", "False", "True", "0")]
public Task Patch();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DocumentHandler/<GenerateClassFromDocument>d__7")]
[RavenActionAttribute("/databases/*/docs/class", "GET", "3", "1", "False", "False", "True", "0")]
public Task GenerateClassFromDocument();
}
public class Raven.Server.Documents.Handlers.DocumentsCompressionHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DocumentsCompressionHandler/<GetDocumentsCompressionConfig>d__0")]
[RavenActionAttribute("/databases/*/documents-compression/config", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetDocumentsCompressionConfig();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.DocumentsCompressionHandler/<ConfigDocumentsCompression>d__1")]
[RavenActionAttribute("/databases/*/admin/documents-compression/config", "POST", "2", "False", "False", "True", "0")]
public Task ConfigDocumentsCompression();
}
public class Raven.Server.Documents.Handlers.DocumentWithException : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DocumentData>k__BackingField;
    public string Id { get; public set; }
    public string ChangeVector { get; public set; }
    public string Exception { get; public set; }
    public object DocumentData { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    [CompilerGeneratedAttribute]
public object get_DocumentData();
    [CompilerGeneratedAttribute]
public void set_DocumentData(object value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.Handlers.ExecuteCounterBatchCommandDto : object {
    public bool ReplyWithAllNodesValues;
    public bool FromEtl;
    public List`1<CounterOperation> List;
    public sealed virtual ExecuteCounterBatchCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public class Raven.Server.Documents.Handlers.ExpirationHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ExpirationHandler/<GetExpirationConfig>d__0")]
[RavenActionAttribute("/databases/*/expiration/config", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetExpirationConfig();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ExpirationHandler/<ConfigExpiration>d__1")]
[RavenActionAttribute("/databases/*/admin/expiration/config", "POST", "2", "False", "False", "True", "0")]
public Task ConfigExpiration();
}
public class Raven.Server.Documents.Handlers.HiLoHandler : DatabaseRequestHandler {
    public static string RavenHiloIdPrefix;
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.HiLoHandler/<GetNextHiLo>d__1")]
[RavenActionAttribute("/databases/*/hilo/next", "GET", "3", "2", "False", "False", "True", "0")]
public Task GetNextHiLo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.HiLoHandler/<ReturnHiLo>d__2")]
[RavenActionAttribute("/databases/*/hilo/return", "PUT", "3", "2", "False", "False", "True", "0")]
public Task ReturnHiLo();
}
public class Raven.Server.Documents.Handlers.IdentityHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IdentityHandler/<NextIdentityFor>d__0")]
[RavenActionAttribute("/databases/*/identity/next", "POST", "3", "2", "False", "False", "True", "0")]
public Task NextIdentityFor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IdentityHandler/<SeedIdentityFor>d__1")]
[RavenActionAttribute("/databases/*/identity/seed", "POST", "3", "2", "False", "False", "True", "0")]
public Task SeedIdentityFor();
}
public class Raven.Server.Documents.Handlers.IndexHandler : DatabaseRequestHandler {
    private static int DefaultInputSizeForTestingJavaScriptIndex;
    private static IndexHandler();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Replace>d__0")]
[RavenActionAttribute("/databases/*/indexes/replace", "POST", "3", "2", "False", "False", "True", "0")]
public Task Replace();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<FinishRolling>d__1")]
[RavenActionAttribute("/databases/*/indexes/finish-rolling", "POST", "3", "2", "False", "False", "True", "0")]
public Task FinishRolling();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Source>d__2")]
[RavenActionAttribute("/databases/*/indexes/source", "GET", "3", "1", "False", "False", "True", "0")]
public Task Source();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<GetIndexHistory>d__4")]
[RavenActionAttribute("/databases/*/indexes/history", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetIndexHistory();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<HasChanged>d__5")]
[RavenActionAttribute("/databases/*/indexes/has-changed", "POST", "3", "1", "False", "False", "True", "0")]
public Task HasChanged();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Debug>d__6")]
[RavenActionAttribute("/databases/*/indexes/debug", "GET", "3", "1", "False", "False", "True", "0")]
public Task Debug();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<GetAll>d__7")]
[RavenActionAttribute("/databases/*/indexes", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetAll();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Stats>d__8")]
[RavenActionAttribute("/databases/*/indexes/stats", "GET", "3", "1", "False", "False", "True", "0")]
public Task Stats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Stale>d__9")]
[RavenActionAttribute("/databases/*/indexes/staleness", "GET", "3", "1", "False", "False", "True", "0")]
public Task Stale();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Progress>d__10")]
[RavenActionAttribute("/databases/*/indexes/progress", "GET", "3", "1", "False", "False", "True", "0")]
public Task Progress();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Reset>d__11")]
[RavenActionAttribute("/databases/*/indexes", "RESET", "3", "2", "False", "False", "True", "0")]
public Task Reset();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<OpenFaultyIndex>d__12")]
[RavenActionAttribute("/databases/*/index/open-faulty-index", "POST", "3", "2", "False", "False", "True", "0")]
public Task OpenFaultyIndex();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Delete>d__13")]
[RavenActionAttribute("/databases/*/indexes", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task Delete();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<GenerateCSharpIndexDefinition>d__14")]
[RavenActionAttribute("/databases/*/indexes/c-sharp-index-definition", "GET", "3", "1", "False", "False", "True", "0")]
public Task GenerateCSharpIndexDefinition();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Status>d__15")]
[RavenActionAttribute("/databases/*/indexes/status", "GET", "3", "1", "False", "False", "True", "0")]
public Task Status();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<SetLockMode>d__16")]
[RavenActionAttribute("/databases/*/indexes/set-lock", "POST", "3", "2", "False", "False", "True", "0")]
public Task SetLockMode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<SetPriority>d__17")]
[RavenActionAttribute("/databases/*/indexes/set-priority", "POST", "3", "2", "False", "False", "True", "0")]
public Task SetPriority();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<ClearErrors>d__18")]
[RavenActionAttribute("/databases/*/indexes/errors", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task ClearErrors();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<GetErrors>d__19")]
[RavenActionAttribute("/databases/*/indexes/errors", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetErrors();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Terms>d__20")]
[RavenActionAttribute("/databases/*/indexes/terms", "GET", "3", "1", "False", "False", "True", "0")]
public Task Terms();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<TotalTime>d__21")]
[RavenActionAttribute("/databases/*/indexes/total-time", "GET", "3", "1", "False", "False", "True", "0")]
public Task TotalTime();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Performance>d__22")]
[RavenActionAttribute("/databases/*/indexes/performance", "GET", "3", "1", "False", "False", "True", "0")]
public Task Performance();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<PerformanceLive>d__23")]
[RavenActionAttribute("/databases/*/indexes/performance/live", "GET", "3", "1", "False", "False", "True", "0")]
public Task PerformanceLive();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<SuggestIndexMerge>d__24")]
[RavenActionAttribute("/databases/*/indexes/suggest-index-merge", "GET", "3", "1", "False", "False", "True", "0")]
public Task SuggestIndexMerge();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<TestJavaScriptIndex>d__25")]
[RavenActionAttribute("/databases/*/indexes/try", "POST", "3", "2", "False", "False", "True", "0")]
public Task TestJavaScriptIndex();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<Metadata>d__27")]
[RavenActionAttribute("/databases/*/indexes/debug/metadata", "GET", "3", "1", "False", "False", "True", "0")]
public Task Metadata();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IndexHandler/<ConvertAutoIndex>d__28")]
[RavenActionAttribute("/databases/*/indexes/auto/convert", "GET", "3", "1", "False", "False", "True", "0")]
public Task ConvertAutoIndex();
    private IEnumerable`1<Index> GetIndexesToReportOn();
}
public class Raven.Server.Documents.Handlers.IoMetricsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IoMetricsHandler/<Get>d__0")]
[RavenActionAttribute("/databases/*/debug/io-metrics", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.IoMetricsHandler/<Live>d__1")]
[RavenActionAttribute("/databases/*/debug/io-metrics/live", "GET", "3", "1", "False", "False", "True", "0")]
public Task Live();
}
public class Raven.Server.Documents.Handlers.JsonPatchHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.JsonPatchHandler/<DocOperations>d__0")]
[RavenActionAttribute("/databases/*/json-patch", "PATCH", "3", "2", "False", "False", "True", "0")]
public Task DocOperations();
}
public class Raven.Server.Documents.Handlers.LegacyReplicationHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.LegacyReplicationHandler/<LastEtag>d__0")]
[RavenActionAttribute("/databases/*/replication/lastEtag", "GET", "3", "2", "False", "False", "True", "0")]
public Task LastEtag();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.LegacyReplicationHandler/<Documents>d__1")]
[RavenActionAttribute("/databases/*/replication/replicateDocs", "POST", "3", "2", "False", "False", "True", "0")]
public Task Documents();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.LegacyReplicationHandler/<Attachments>d__2")]
[RavenActionAttribute("/databases/*/replication/replicateAttachments", "POST", "3", "2", "False", "False", "True", "0")]
public Task Attachments();
    [RavenActionAttribute("/databases/*/replication/heartbeat", "POST", "3", "2", "False", "False", "True", "0")]
public Task Heartbeat();
    [RavenActionAttribute("/databases/*/indexes/last-queried", "POST", "3", "2", "False", "False", "True", "0")]
public Task LastQueried();
    [RavenActionAttribute("/databases/*/side-by-side-indexes", "PUT", "3", "2", "False", "False", "True", "0")]
public Task SideBySideIndexes();
    [RavenActionAttribute("/databases/*/transformers/$", "PUT", "3", "2", "False", "False", "True", "0")]
public Task PutTransformer();
    [RavenActionAttribute("/databases/*/transformers/$", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task DeleteTransformer();
    private Guid GetRemoteServerInstanceId();
    private string GetFromServer();
    private LegacySourceReplicationInformation GetSourceReplicationInformation(DocumentsOperationContext context, Guid remoteServerInstanceId, String& documentId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.LegacyReplicationHandler/<SaveSourceReplicationInformation>d__11")]
private Task SaveSourceReplicationInformation(LegacySourceReplicationInformation replicationSource, DocumentsOperationContext context, string documentId);
}
public class Raven.Server.Documents.Handlers.LegacySourceReplicationInformation : object {
    [CompilerGeneratedAttribute]
private string <LastDocumentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastAttachmentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ServerInstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastBatchSize>k__BackingField;
    public string LastDocumentEtag { get; public set; }
    public string LastAttachmentEtag { get; public set; }
    public Guid ServerInstanceId { get; public set; }
    public string Source { get; public set; }
    public Nullable`1<DateTime> LastModified { get; public set; }
    public long LastBatchSize { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LastDocumentEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocumentEtag(string value);
    [CompilerGeneratedAttribute]
public string get_LastAttachmentEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentEtag(string value);
    [CompilerGeneratedAttribute]
public Guid get_ServerInstanceId();
    [CompilerGeneratedAttribute]
public void set_ServerInstanceId(Guid value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public long get_LastBatchSize();
    [CompilerGeneratedAttribute]
public void set_LastBatchSize(long value);
}
internal class Raven.Server.Documents.Handlers.MergedDeleteAttachmentCommandDto : object {
    public string DocumentId;
    public string Name;
    public LazyStringValue ExpectedChangeVector;
    public sealed virtual MergedDeleteAttachmentCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public class Raven.Server.Documents.Handlers.MergedPutAttachmentCommandDto : object {
    public string DocumentId;
    public string Name;
    public LazyStringValue ExpectedChangeVector;
    public string ContentType;
    public Stream Stream;
    public string Hash;
    public sealed virtual MergedPutAttachmentCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public class Raven.Server.Documents.Handlers.MergedPutCommand : MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> {
    private string _id;
    private LazyStringValue _expectedChangeVector;
    private BlittableJsonReaderObject _document;
    private DocumentDatabase _database;
    private bool _shouldValidateAttachments;
    public PutOperationResults PutResult;
    public MergedPutCommand(BlittableJsonReaderObject doc, string id, LazyStringValue changeVector, DocumentDatabase database, bool shouldValidateAttachments);
    public static string GenerateNonConflictingId(DocumentDatabase database, string prefix);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    private void ValidateAttachments(BlittableJsonReaderArray attachments, DocumentsOperationContext context, string id);
    public sealed virtual void Dispose();
    public virtual IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> ToDto(DocumentsOperationContext context);
}
public class Raven.Server.Documents.Handlers.MultiGetHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.MultiGetHandler/<Post>d__0")]
[RavenActionAttribute("/databases/*/multi_get", "POST", "3", "1", "False", "False", "True", "0")]
public Task Post();
}
public class Raven.Server.Documents.Handlers.PerformanceMetricsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.PerformanceMetricsHandler/<IoMetrics>d__1")]
[RavenActionAttribute("/databases/*/debug/perf-metrics", "GET", "3", "1", "False", "False", "True", "0")]
public Task IoMetrics();
    public static PerformanceMetricsResponse GetPerformanceMetricsResponse(DocumentDatabase documentDatabase);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.AbstractDatabaseHandlerProcessor`1 : AbstractDatabaseHandlerProcessor`2<AbstractDatabaseRequestHandler`1<TOperationContext>, TOperationContext> {
    protected AbstractDatabaseHandlerProcessor`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.AbstractDatabaseHandlerProcessor`2 : AbstractHandlerProcessor`1<TRequestHandler> {
    protected JsonContextPoolBase`1<TOperationContext> ContextPool;
    protected Logger Logger;
    protected AbstractDatabaseHandlerProcessor`2(TRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.AbstractHandlerProcessor`1 : object {
    protected ClusterContextPool ClusterContextPool;
    protected TRequestHandler RequestHandler;
    protected HttpContext HttpContext;
    protected ServerStore ServerStore { get; }
    protected AbstractHandlerProcessor`1(TRequestHandler requestHandler);
    protected ServerStore get_ServerStore();
    public abstract virtual ValueTask ExecuteAsync();
    public virtual void Dispose();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.AbstractHandlerProxyNoContentProcessor`2 : AbstractHandlerProxyReadProcessor`3<object, TRequestHandler, TOperationContext> {
    private HttpStatusCode _statusCode;
    protected AbstractHandlerProxyNoContentProcessor`2(TRequestHandler requestHandler, HttpStatusCode statusCode);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.AbstractHandlerProxyNoContentProcessor`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.AbstractHandlerProxyProcessor`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    [CompilerGeneratedAttribute]
private bool <SupportsOptionalShardNumber>k__BackingField;
    protected bool SupportsCurrentNode { get; }
    protected bool SupportsOptionalShardNumber { get; }
    protected AbstractHandlerProxyProcessor`2(TRequestHandler requestHandler);
    protected abstract virtual bool get_SupportsCurrentNode();
    [CompilerGeneratedAttribute]
protected virtual bool get_SupportsOptionalShardNumber();
    protected int GetShardNumber();
    protected bool TryGetShardNumber(Int32& shardNumber);
    protected bool IsCurrentNode(String& nodeTag);
    protected string GetNodeTag(bool required);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.AbstractHandlerProxyReadProcessor`3 : AbstractHandlerProxyProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractHandlerProxyReadProcessor`3(TRequestHandler requestHandler);
    protected abstract virtual ValueTask HandleCurrentNodeAsync();
    protected abstract virtual Task HandleRemoteNodeAsync(ProxyCommand`1<TResult> command, OperationCancelToken token);
    protected virtual RavenCommand`1<TResult> CreateCommandForNode(string nodeTag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.AbstractHandlerProxyReadProcessor`3/<ExecuteAsync>d__4")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.AbstractHandlerWebSocketProxyProcessor`2 : AbstractHandlerProxyProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractHandlerWebSocketProxyProcessor`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
    protected virtual string GetDatabaseName();
    protected virtual string GetRemoteEndpointUrl(string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.AbstractHandlerWebSocketProxyProcessor`2/<ExecuteAsync>d__4")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.AbstractHandlerWebSocketProxyProcessor`2/<HandleRemoteNodeAsync>d__5")]
private ValueTask HandleRemoteNodeAsync(WebSocket webSocket, string remoteNodeUrl, string remoteEndpointUrl, OperationCancelToken token);
    private string GetRemoteNodeUrl(string nodeTag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.AbstractHandlerWebSocketProxyProcessor`2/<HandleExceptionAsync>d__7")]
private ValueTask HandleExceptionAsync(Exception ex, WebSocket webSocket);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.AbstractServerHandlerProxyProcessor : AbstractHandlerProcessor`1<RequestHandler> {
    protected bool SupportsCurrentNode { get; }
    protected AbstractServerHandlerProxyProcessor(RequestHandler requestHandler);
    protected abstract virtual bool get_SupportsCurrentNode();
    protected int GetShardNumber();
    protected bool TryGetShardNumber(Int32& shardNumber);
    protected bool IsCurrentNode(String& nodeTag);
    protected string GetNodeTag(bool required);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.AbstractServerHandlerProxyReadProcessor`1 : AbstractServerHandlerProxyProcessor {
    protected AbstractServerHandlerProxyReadProcessor`1(RequestHandler requestHandler);
    protected abstract virtual ValueTask HandleCurrentNodeAsync();
    protected abstract virtual Task HandleRemoteNodeAsync(ProxyCommand`1<TResult> command, JsonOperationContext context, OperationCancelToken token);
    protected virtual ValueTask`1<RavenCommand`1<TResult>> CreateCommandForNodeAsync(string nodeTag, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.AbstractServerHandlerProxyReadProcessor`1/<ExecuteAsync>d__4")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Analyzers.AbstractAdminAnalyzersHandlerProcessorForDelete`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminAnalyzersHandlerProcessorForDelete`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Analyzers.AbstractAdminAnalyzersHandlerProcessorForDelete`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Analyzers.AbstractAdminAnalyzersHandlerProcessorForPut`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAdminAnalyzersHandlerProcessorForPut`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Analyzers.AbstractAdminAnalyzersHandlerProcessorForPut`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Analyzers.AdminAnalyzersHandlerProcessorForDelete : AbstractAdminAnalyzersHandlerProcessorForDelete`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminAnalyzersHandlerProcessorForDelete(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.Analyzers.AdminAnalyzersHandlerProcessorForPut : AbstractAdminAnalyzersHandlerProcessorForPut`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AdminAnalyzersHandlerProcessorForPut(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.Analyzers.AnalyzersHandlerProcessorForGet`1 : AbstractDatabaseHandlerProcessor`1<TOperationContext> {
    public AnalyzersHandlerProcessorForGet`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Analyzers.AnalyzersHandlerProcessorForGet`1/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForDeleteAttachment`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAttachmentHandlerProcessorForDeleteAttachment`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask DeleteAttachmentAsync(TOperationContext context, string docId, string name, LazyStringValue changeVector);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForDeleteAttachment`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForGetAttachment`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    private bool _isDocument;
    protected AbstractAttachmentHandlerProcessorForGetAttachment`2(TRequestHandler requestHandler, bool isDocument);
    protected abstract virtual ValueTask GetAttachmentAsync(TOperationContext context, string documentId, string name, AttachmentType type, string changeVector, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForGetAttachment`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForGetAttachmentMetadataWithCounts`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAttachmentHandlerProcessorForGetAttachmentMetadataWithCounts`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask HandleAttachmentMetadataWithCountsAsync(string documentId);
    public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForGetHashCount`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAttachmentHandlerProcessorForGetHashCount`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<Response> GetResponseAsync(TOperationContext context, string hash);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForGetHashCount`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForGetHashCount`2/<WriteResponseAsync>d__3")]
private ValueTask WriteResponseAsync(TOperationContext context, Response response);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForHeadAttachment`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAttachmentHandlerProcessorForHeadAttachment`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask HandleHeadAttachmentAsync(string documentId, string name, string changeVector);
    public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForPutAttachment`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractAttachmentHandlerProcessorForPutAttachment`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask PutAttachmentsAsync(TOperationContext context, string id, string name, Stream requestBodyStream, string contentType, string changeVector, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Attachments.AbstractAttachmentHandlerProcessorForPutAttachment`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Attachments.AttachmentHandlerProcessorForDeleteAttachment : AbstractAttachmentHandlerProcessorForDeleteAttachment`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AttachmentHandlerProcessorForDeleteAttachment(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Attachments.AttachmentHandlerProcessorForDeleteAttachment/<DeleteAttachmentAsync>d__1")]
protected virtual ValueTask DeleteAttachmentAsync(DocumentsOperationContext _, string docId, string name, LazyStringValue changeVector);
}
internal class Raven.Server.Documents.Handlers.Processors.Attachments.AttachmentHandlerProcessorForGetAttachment : AbstractAttachmentHandlerProcessorForGetAttachment`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AttachmentHandlerProcessorForGetAttachment(DatabaseRequestHandler requestHandler, bool isDocument);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Attachments.AttachmentHandlerProcessorForGetAttachment/<GetAttachmentAsync>d__1")]
protected virtual ValueTask GetAttachmentAsync(DocumentsOperationContext context, string documentId, string name, AttachmentType type, string changeVector, CancellationToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Attachments.AttachmentHandlerProcessorForGetAttachmentMetadataWithCounts : AbstractAttachmentHandlerProcessorForGetAttachmentMetadataWithCounts`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AttachmentHandlerProcessorForGetAttachmentMetadataWithCounts(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Attachments.AttachmentHandlerProcessorForGetAttachmentMetadataWithCounts/<HandleAttachmentMetadataWithCountsAsync>d__1")]
protected virtual ValueTask HandleAttachmentMetadataWithCountsAsync(string documentId);
}
internal class Raven.Server.Documents.Handlers.Processors.Attachments.AttachmentHandlerProcessorForGetHashCount : AbstractAttachmentHandlerProcessorForGetHashCount`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AttachmentHandlerProcessorForGetHashCount(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<Response> GetResponseAsync(DocumentsOperationContext context, string hash);
}
internal class Raven.Server.Documents.Handlers.Processors.Attachments.AttachmentHandlerProcessorForHeadAttachment : AbstractAttachmentHandlerProcessorForHeadAttachment`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AttachmentHandlerProcessorForHeadAttachment(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask HandleHeadAttachmentAsync(string documentId, string name, string changeVector);
}
internal class Raven.Server.Documents.Handlers.Processors.Attachments.AttachmentHandlerProcessorForPutAttachment : AbstractAttachmentHandlerProcessorForPutAttachment`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public AttachmentHandlerProcessorForPutAttachment(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Attachments.AttachmentHandlerProcessorForPutAttachment/<PutAttachmentsAsync>d__1")]
protected virtual ValueTask PutAttachmentsAsync(DocumentsOperationContext context, string id, string name, Stream requestBodyStream, string contentType, string changeVector, CancellationToken token);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Batches.AbstractBatchHandlerProcessorForBulkDocs`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractBatchHandlerProcessorForBulkDocs`3(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<DynamicJsonArray> HandleTransactionAsync(JsonOperationContext context, TBatchCommand command, IndexBatchOptions indexBatchOptions, ReplicationBatchOptions replicationBatchOptions);
    protected abstract virtual ValueTask WaitForIndexesAsync(IndexBatchOptions options, string lastChangeVector, long lastTombstoneEtag, HashSet`1<string> modifiedCollections, CancellationToken token);
    protected abstract virtual ValueTask WaitForReplicationAsync(TOperationContext context, ReplicationBatchOptions options, string lastChangeVector);
    protected abstract virtual char GetIdentityPartsSeparator();
    protected abstract virtual AbstractBatchCommandsReader`2<TBatchCommand, TOperationContext> GetCommandsReader();
    protected abstract virtual AbstractClusterTransactionRequestProcessor`2<TRequestHandler, TBatchCommand> GetClusterTransactionRequestProcessor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Batches.AbstractBatchHandlerProcessorForBulkDocs`3/<ExecuteAsync>d__7")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Batches.AbstractBatchHandlerProcessorForBulkDocs`3/<ExecuteInternalAsync>d__8")]
public ValueTask ExecuteInternalAsync();
    private static IndexBatchOptions GetIndexBatchOptions(QueryStringParameters<TBatchCommand, TRequestHandler, TOperationContext> parameters);
    private static ReplicationBatchOptions GetReplicationBatchOptions(QueryStringParameters<TBatchCommand, TRequestHandler, TOperationContext> parameters);
    private static string BatchTrafficWatch(ArraySegment`1<CommandData> parsedCommands);
    [DoesNotReturnAttribute]
private static void ThrowNotSupportedType(string contentType);
}
public abstract class Raven.Server.Documents.Handlers.Processors.Batches.AbstractClusterTransactionRequestProcessor`2 : object {
    protected TRequestHandler RequestHandler;
    protected AbstractClusterTransactionRequestProcessor`2(TRequestHandler requestHandler);
    protected abstract virtual ArraySegment`1<CommandData> GetParsedCommands(TBatchCommand command);
    protected abstract virtual ClusterConfiguration GetClusterConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Batches.AbstractClusterTransactionRequestProcessor`2/<ProcessAsync>d__4")]
public ValueTask`1<ValueTuple`2<long, DynamicJsonArray>> ProcessAsync(JsonOperationContext context, TBatchCommand command, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Batches.AbstractClusterTransactionRequestProcessor`2/<GetClusterTransactionDatabaseCommandsResults>d__5")]
private Task`1<DynamicJsonArray> GetClusterTransactionDatabaseCommandsResults(object result, long databaseCommandsCount, long index, ClusterTransactionOptions options, Task`1<HashSet`1<string>> onDatabaseCompletionTask, CancellationToken token);
    public abstract virtual Task WaitForDatabaseCompletion(Task`1<HashSet`1<string>> onDatabaseCompletionTask, long index, ClusterTransactionOptions options, CancellationToken token);
    private void ThrowClusterTransactionConcurrencyException(List`1<ClusterTransactionErrorInfo> errors);
    protected abstract virtual ClusterTransactionCommand CreateClusterTransactionCommand(ArraySegment`1<CommandData> parsedCommands, ClusterTransactionOptions options, string raftRequestId);
    private void CheckBackwardCompatibility(Boolean& disableAtomicDocumentWrites);
}
internal class Raven.Server.Documents.Handlers.Processors.Batches.BatchHandlerProcessorForBulkDocs : AbstractBatchHandlerProcessorForBulkDocs`3<MergedBatchCommand, DatabaseRequestHandler, DocumentsOperationContext> {
    public BatchHandlerProcessorForBulkDocs(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Batches.BatchHandlerProcessorForBulkDocs/<HandleTransactionAsync>d__1")]
protected virtual ValueTask`1<DynamicJsonArray> HandleTransactionAsync(JsonOperationContext context, MergedBatchCommand command, IndexBatchOptions indexBatchOptions, ReplicationBatchOptions replicationBatchOptions);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Batches.BatchHandlerProcessorForBulkDocs/<WaitForIndexesAsync>d__2")]
protected virtual ValueTask WaitForIndexesAsync(IndexBatchOptions options, string lastChangeVector, long lastTombstoneEtag, HashSet`1<string> modifiedCollections, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Batches.BatchHandlerProcessorForBulkDocs/<WaitForIndexesAsync>d__3")]
public static Task WaitForIndexesAsync(DocumentDatabase database, TimeSpan timeout, String[] specifiedIndexesQueryString, bool throwOnTimeout, long lastDocumentEtag, long lastTombstoneEtag, HashSet`1<string> modifiedCollections, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Batches.BatchHandlerProcessorForBulkDocs/<WaitForReplicationAsync>d__4")]
protected virtual ValueTask WaitForReplicationAsync(DocumentsOperationContext context, ReplicationBatchOptions options, string lastChangeVector);
    protected virtual char GetIdentityPartsSeparator();
    protected virtual AbstractBatchCommandsReader`2<MergedBatchCommand, DocumentsOperationContext> GetCommandsReader();
    protected virtual AbstractClusterTransactionRequestProcessor`2<DatabaseRequestHandler, MergedBatchCommand> GetClusterTransactionRequestProcessor();
    [DoesNotReturnAttribute]
private static void ThrowTimeoutException(List`1<WaitForIndexItem> indexesToWait, int i, Stopwatch sp, QueryOperationContext context, long cutoffEtag);
    private static List`1<Index> GetImpactedIndexesToWaitForToBecomeNonStale(DocumentDatabase database, String[] specifiedIndexesQueryString, HashSet`1<string> modifiedCollections);
}
public class Raven.Server.Documents.Handlers.Processors.Batches.ClusterTransactionRequestProcessor : AbstractClusterTransactionRequestProcessor`2<DatabaseRequestHandler, MergedBatchCommand> {
    private DatabaseTopology _topology;
    public ClusterTransactionRequestProcessor(DatabaseRequestHandler requestHandler, DatabaseTopology topology);
    protected virtual ArraySegment`1<CommandData> GetParsedCommands(MergedBatchCommand command);
    protected virtual ClusterConfiguration GetClusterConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Batches.ClusterTransactionRequestProcessor/<WaitForDatabaseCompletion>d__4")]
public virtual Task WaitForDatabaseCompletion(Task`1<HashSet`1<string>> onDatabaseCompletionTask, long index, ClusterTransactionOptions options, CancellationToken token);
    protected virtual ClusterTransactionCommand CreateClusterTransactionCommand(ArraySegment`1<CommandData> parsedCommands, ClusterTransactionOptions options, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.BulkInsert.AbstractBulkInsertHandlerProcessor`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    private CancellationTokenSource _cts;
    private BulkInsertProgress _progress;
    private Action`1<IOperationProgress> _onProgress;
    protected bool SkipOverwriteIfUnchanged;
    protected List`1<StreamsTempFile> AttachmentStreamsTempFiles;
    [CompilerGeneratedAttribute]
private BulkOperationResult <OperationResult>k__BackingField;
    internal TestingStuff<TCommandData, TRequestHandler, TOperationContext> ForTestingPurposes;
    public BulkOperationResult OperationResult { get; private set; }
    protected AbstractBulkInsertHandlerProcessor`3(TRequestHandler requestHandler, Action`1<IOperationProgress> onProgress, bool skipOverwriteIfUnchanged, CancellationToken token);
    protected abstract virtual AbstractBulkInsertBatchCommandsReader`1<TCommandData> GetCommandsReader(JsonOperationContext context, Stream requestBodyStream, MemoryBuffer buffer, CancellationToken token);
    protected abstract virtual ValueTask ExecuteCommands(Task currentTask, int numberOfCommands, TCommandData[] array, long totalSize);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.BulkInsert.AbstractBulkInsertHandlerProcessor`3/<WriteAttachmentStream>d__8")]
protected ValueTask`1<AttachmentStream> WriteAttachmentStream(long size, Stream stream);
    protected abstract virtual StreamsTempFile GetTempFile();
    protected abstract virtual ValueTask`1<string> CopyAttachmentStream(Stream sourceStream, Stream attachmentStream);
    protected abstract virtual ValueTuple`2<long, int> GetSizeAndOperationsCount(TCommandData commandData);
    [CompilerGeneratedAttribute]
public BulkOperationResult get_OperationResult();
    [CompilerGeneratedAttribute]
private void set_OperationResult(BulkOperationResult value);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.BulkInsert.AbstractBulkInsertHandlerProcessor`3/<ExecuteAsync>d__16")]
public virtual ValueTask ExecuteAsync();
    protected virtual Task OnErrorAsync(Exception exception);
    private void ClearAttachmentStreamsTempFiles();
    protected static ValueTuple`2<long, int> GetSizeAndOperationsCount(CommandData commandData, long estimatedChangeVectorSize);
    public virtual void Dispose();
    internal TestingStuff<TCommandData, TRequestHandler, TOperationContext> ForTestingPurposesOnly();
}
internal class Raven.Server.Documents.Handlers.Processors.BulkInsert.BulkInsertHandlerProcessor : AbstractBulkInsertHandlerProcessor`3<CommandData, BulkInsertHandler, DocumentsOperationContext> {
    private DocumentDatabase _database;
    private Logger _logger;
    private int _databaseChangeVectorSize;
    public BulkInsertHandlerProcessor(BulkInsertHandler requestHandler, DocumentDatabase database, Action`1<IOperationProgress> onProgress, bool skipOverwriteIfUnchanged, CancellationToken token);
    protected virtual AbstractBulkInsertBatchCommandsReader`1<CommandData> GetCommandsReader(JsonOperationContext context, Stream requestBodyStream, MemoryBuffer buffer, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.BulkInsert.BulkInsertHandlerProcessor/<ExecuteCommands>d__5")]
protected virtual ValueTask ExecuteCommands(Task currentTask, int numberOfCommands, CommandData[] array, long totalSize);
    protected virtual StreamsTempFile GetTempFile();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.BulkInsert.BulkInsertHandlerProcessor/<CopyAttachmentStream>d__7")]
protected virtual ValueTask`1<string> CopyAttachmentStream(Stream sourceStream, Stream attachmentStream);
    protected virtual ValueTuple`2<long, int> GetSizeAndOperationsCount(CommandData commandData);
    private int GetDatabaseChangeVectorSize();
    private IDisposable ReplaceContextIfCurrentlyInUse(Task task, int numberOfCommands, CommandData[] array);
}
public class Raven.Server.Documents.Handlers.Processors.BulkInsert.MergedInsertBulkCommand : DocumentMergedTransactionCommand {
    public Logger Logger;
    public DocumentDatabase Database;
    public CommandData[] Commands;
    public int NumberOfCommands;
    public long TotalSize;
    public bool SkipOverwriteIfUnchanged;
    private Dictionary`2<string, DocumentUpdates> _documentsToUpdate;
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    [PreserveBaseOverridesAttribute]
public virtual override IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, DocumentMergedTransactionCommand> ToDto(DocumentsOperationContext context);
    private DocumentUpdates GetDocumentUpdates(string documentId);
}
public class Raven.Server.Documents.Handlers.Processors.BulkInsert.MergedInsertBulkCommandDto : object {
    [CompilerGeneratedAttribute]
private CommandData[] <Commands>k__BackingField;
    public CommandData[] Commands { get; public set; }
    [CompilerGeneratedAttribute]
public CommandData[] get_Commands();
    [CompilerGeneratedAttribute]
public void set_Commands(CommandData[] value);
    public sealed virtual MergedInsertBulkCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Changes.AbstractChangesHandlerProcessorForDeleteConnections`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractChangesHandlerProcessorForDeleteConnections`2(TRequestHandler requestHandler);
    protected abstract virtual void Disconnect(long connectionId);
    public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Changes.AbstractChangesHandlerProcessorForGetChanges`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractChangesHandlerProcessorForGetChanges`3(TRequestHandler requestHandler);
    protected abstract virtual TChangesClientConnection CreateChangesClientConnection(WebSocket webSocket, bool throttleConnection, bool fromStudio);
    protected abstract virtual void Connect(TChangesClientConnection connection);
    protected abstract virtual void Disconnect(TChangesClientConnection connection);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Changes.AbstractChangesHandlerProcessorForGetChanges`3/<ExecuteAsync>d__4")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Changes.AbstractChangesHandlerProcessorForGetChanges`3/<HandleConnectionAsync>d__5")]
private Task HandleConnectionAsync(WebSocket webSocket, TChangesClientConnection connection, JsonOperationContext context, OperationCancelToken token);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Changes.AbstractChangesHandlerProcessorForGetConnectionsDebugInfo`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractChangesHandlerProcessorForGetConnectionsDebugInfo`3(TRequestHandler requestHandler);
    protected abstract virtual ConcurrentDictionary`2<long, TChangesClientConnection> GetConnections();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Changes.AbstractChangesHandlerProcessorForGetConnectionsDebugInfo`3/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Changes.ChangesHandlerProcessorForDeleteConnections : AbstractChangesHandlerProcessorForDeleteConnections`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public ChangesHandlerProcessorForDeleteConnections(DatabaseRequestHandler requestHandler);
    protected virtual void Disconnect(long connectionId);
}
internal class Raven.Server.Documents.Handlers.Processors.Changes.ChangesHandlerProcessorForGetChanges : AbstractChangesHandlerProcessorForGetChanges`3<DatabaseRequestHandler, DocumentsOperationContext, ChangesClientConnection> {
    public ChangesHandlerProcessorForGetChanges(DatabaseRequestHandler requestHandler);
    protected virtual ChangesClientConnection CreateChangesClientConnection(WebSocket webSocket, bool throttleConnection, bool fromStudio);
    protected virtual void Connect(ChangesClientConnection connection);
    protected virtual void Disconnect(ChangesClientConnection connection);
}
internal class Raven.Server.Documents.Handlers.Processors.Changes.ChangesHandlerProcessorForGetConnectionsDebugInfo : AbstractChangesHandlerProcessorForGetConnectionsDebugInfo`3<DatabaseRequestHandler, DocumentsOperationContext, ChangesClientConnection> {
    public ChangesHandlerProcessorForGetConnectionsDebugInfo(DatabaseRequestHandler requestHandler);
    protected virtual ConcurrentDictionary`2<long, ChangesClientConnection> GetConnections();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Collections.AbstractCollectionsHandlerProcessorForGetCollectionDocuments`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public AbstractCollectionsHandlerProcessorForGetCollectionDocuments`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<ValueTuple`2<long, long>> GetCollectionDocumentsAndWriteAsync(TOperationContext context, string name, int start, int pageSize, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Collections.AbstractCollectionsHandlerProcessorForGetCollectionDocuments`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Collections.AbstractCollectionsHandlerProcessorForGetCollectionStats`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    private bool _detailed;
    public AbstractCollectionsHandlerProcessorForGetCollectionStats`2(TRequestHandler requestHandler, bool detailed);
    protected abstract virtual ValueTask`1<DynamicJsonValue> GetStatsAsync(TOperationContext context, bool detailed);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Collections.AbstractCollectionsHandlerProcessorForGetCollectionStats`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Collections.AbstractCollectionsHandlerProcessorForGetLastChangeVector`2 : AbstractHandlerProxyReadProcessor`3<LastChangeVectorForCollectionResult, TRequestHandler, TOperationContext> {
    protected bool SupportsCurrentNode { get; }
    protected AbstractCollectionsHandlerProcessorForGetLastChangeVector`2(TRequestHandler requestHandler);
    protected string GetCollectionName();
    protected virtual bool get_SupportsCurrentNode();
    protected virtual RavenCommand`1<LastChangeVectorForCollectionResult> CreateCommandForNode(string nodeTag);
}
internal class Raven.Server.Documents.Handlers.Processors.Collections.CollectionsHandlerProcessorForGetCollectionDocuments : AbstractCollectionsHandlerProcessorForGetCollectionDocuments`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public CollectionsHandlerProcessorForGetCollectionDocuments(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Collections.CollectionsHandlerProcessorForGetCollectionDocuments/<GetCollectionDocumentsAndWriteAsync>d__1")]
protected virtual ValueTask`1<ValueTuple`2<long, long>> GetCollectionDocumentsAndWriteAsync(DocumentsOperationContext context, string name, int start, int pageSize, CancellationToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Collections.CollectionsHandlerProcessorForGetCollectionStats : AbstractCollectionsHandlerProcessorForGetCollectionStats`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public CollectionsHandlerProcessorForGetCollectionStats(DatabaseRequestHandler requestHandler, bool detailed);
    protected virtual ValueTask`1<DynamicJsonValue> GetStatsAsync(DocumentsOperationContext context, bool detailed);
    private DynamicJsonValue GetCollectionStats(DocumentsOperationContext context, bool detailed);
}
internal class Raven.Server.Documents.Handlers.Processors.Collections.CollectionsHandlerProcessorForGetLastChangeVector : AbstractCollectionsHandlerProcessorForGetLastChangeVector`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public CollectionsHandlerProcessorForGetLastChangeVector(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Collections.CollectionsHandlerProcessorForGetLastChangeVector/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<LastChangeVectorForCollectionResult> command, OperationCancelToken token);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Configuration.AbstractConfigurationHandlerProcessorForGetClientConfiguration`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractConfigurationHandlerProcessorForGetClientConfiguration`2(TRequestHandler requestHandler);
    protected abstract virtual ClientConfiguration GetDatabaseClientConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Configuration.AbstractConfigurationHandlerProcessorForGetClientConfiguration`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    private ClientConfiguration GetServerClientConfiguration();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Configuration.AbstractConfigurationHandlerProcessorForGetStudioConfiguration`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractConfigurationHandlerProcessorForGetStudioConfiguration`2(TRequestHandler requestHandler);
    protected abstract virtual StudioConfiguration GetStudioConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Configuration.AbstractConfigurationHandlerProcessorForGetStudioConfiguration`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Configuration.AbstractConfigurationHandlerProcessorForGetTimeSeriesConfiguration`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractConfigurationHandlerProcessorForGetTimeSeriesConfiguration`2(TRequestHandler requestHandler);
    protected abstract virtual TimeSeriesConfiguration GetTimeSeriesConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Configuration.AbstractConfigurationHandlerProcessorForGetTimeSeriesConfiguration`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Configuration.AbstractConfigurationHandlerProcessorForPostTimeSeriesConfiguration`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractConfigurationHandlerProcessorForPostTimeSeriesConfiguration`2(TRequestHandler requestHandler);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual void OnBeforeUpdateConfiguration(BlittableJsonReaderObject& configuration, JsonOperationContext context);
    protected abstract virtual ValueTask WaitForIndexNotificationAsync(TransactionOperationContext context, long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Configuration.AbstractConfigurationHandlerProcessorForPostTimeSeriesConfiguration`2/<ModifyTimeSeriesConfiguration>d__4")]
private Task`1<ValueTuple`2<long, object>> ModifyTimeSeriesConfiguration(TransactionOperationContext context, string name, BlittableJsonReaderObject configurationJson, string raftRequestId);
}
internal class Raven.Server.Documents.Handlers.Processors.Configuration.ConfigurationHandlerProcessorForGetClientConfiguration : AbstractConfigurationHandlerProcessorForGetClientConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public ConfigurationHandlerProcessorForGetClientConfiguration(DatabaseRequestHandler requestHandler);
    protected virtual ClientConfiguration GetDatabaseClientConfiguration();
}
internal class Raven.Server.Documents.Handlers.Processors.Configuration.ConfigurationHandlerProcessorForGetStudioConfiguration : AbstractConfigurationHandlerProcessorForGetStudioConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public ConfigurationHandlerProcessorForGetStudioConfiguration(DatabaseRequestHandler requestHandler);
    protected virtual StudioConfiguration GetStudioConfiguration();
}
internal class Raven.Server.Documents.Handlers.Processors.Configuration.ConfigurationHandlerProcessorForGetTimeSeriesConfiguration : AbstractConfigurationHandlerProcessorForGetTimeSeriesConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public ConfigurationHandlerProcessorForGetTimeSeriesConfiguration(DatabaseRequestHandler requestHandler);
    protected virtual TimeSeriesConfiguration GetTimeSeriesConfiguration();
}
internal class Raven.Server.Documents.Handlers.Processors.Configuration.ConfigurationHandlerProcessorForPostTimeSeriesConfiguration : AbstractConfigurationHandlerProcessorForPostTimeSeriesConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public ConfigurationHandlerProcessorForPostTimeSeriesConfiguration(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Configuration.ConfigurationHandlerProcessorForPostTimeSeriesConfiguration/<WaitForIndexNotificationAsync>d__1")]
protected virtual ValueTask WaitForIndexNotificationAsync(TransactionOperationContext context, long index);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Counters.AbstractCountersHandlerProcessorForGetCounters`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractCountersHandlerProcessorForGetCounters`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<CountersDetail> GetCountersAsync(TOperationContext context, string docId, StringValues counters, bool full);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Counters.AbstractCountersHandlerProcessorForGetCounters`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Counters.AbstractCountersHandlerProcessorForPostCounters`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public AbstractCountersHandlerProcessorForPostCounters`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<CountersDetail> ApplyCountersOperationsAsync(TOperationContext context, CounterBatch counterBatch);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Counters.AbstractCountersHandlerProcessorForPostCounters`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Counters.CountersHandlerProcessorForGetCounters : AbstractCountersHandlerProcessorForGetCounters`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public CountersHandlerProcessorForGetCounters(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<CountersDetail> GetCountersAsync(DocumentsOperationContext context, string docId, StringValues counters, bool full);
    internal static CountersDetail GetInternal(DocumentDatabase database, DocumentsOperationContext context, StringValues counters, string docId, bool full);
    internal static void GetCounterValue(DocumentsOperationContext context, DocumentDatabase database, string docId, string counterName, bool addFullValues, CountersDetail result, bool capValueOnOverflow);
}
internal class Raven.Server.Documents.Handlers.Processors.Counters.CountersHandlerProcessorForPostCounters : AbstractCountersHandlerProcessorForPostCounters`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public CountersHandlerProcessorForPostCounters(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Counters.CountersHandlerProcessorForPostCounters/<ApplyCountersOperationsAsync>d__1")]
protected virtual ValueTask`1<CountersDetail> ApplyCountersOperationsAsync(DocumentsOperationContext context, CounterBatch counterBatch);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.DataArchival.AbstractDataArchivalHandlerProcessorForGet`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDataArchivalHandlerProcessorForGet`2(TRequestHandler requestHandler);
    protected abstract virtual DataArchivalConfiguration GetDataArchivalConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.DataArchival.AbstractDataArchivalHandlerProcessorForGet`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.DataArchival.AbstractDataArchivalHandlerProcessorForPost`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractDataArchivalHandlerProcessorForPost`2(TRequestHandler requestHandler);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal class Raven.Server.Documents.Handlers.Processors.DataArchival.DataArchivalHandlerProcessorForGet : AbstractDataArchivalHandlerProcessorForGet`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public DataArchivalHandlerProcessorForGet(DatabaseRequestHandler requestHandler);
    protected virtual DataArchivalConfiguration GetDataArchivalConfiguration();
}
internal class Raven.Server.Documents.Handlers.Processors.DataArchival.DataArchivalHandlerProcessorForPost : AbstractDataArchivalHandlerProcessorForPost`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public DataArchivalHandlerProcessorForPost(DatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Databases.AbstractHandlerProcessorForUpdateDatabaseConfiguration`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    private bool _isBlittable;
    protected long Index;
    protected bool RequireAdmin { get; }
    protected AbstractHandlerProcessorForUpdateDatabaseConfiguration`3(TRequestHandler requestHandler);
    protected virtual bool get_RequireAdmin();
    protected virtual HttpStatusCode GetResponseStatusCode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Databases.AbstractHandlerProcessorForUpdateDatabaseConfiguration`3/<GetConfigurationAsync>d__6")]
protected virtual ValueTask`1<T> GetConfigurationAsync(TransactionOperationContext context, AsyncBlittableJsonTextWriter writer);
    protected virtual void OnBeforeUpdateConfiguration(T& configuration, JsonOperationContext context);
    protected abstract virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, T configuration, string raftRequestId);
    protected virtual void OnBeforeResponseWrite(TransactionOperationContext context, DynamicJsonValue responseJson, T configuration, long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Databases.AbstractHandlerProcessorForUpdateDatabaseConfiguration`3/<AssertCanExecuteAsync>d__10")]
protected virtual ValueTask AssertCanExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Databases.AbstractHandlerProcessorForUpdateDatabaseConfiguration`3/<OnAfterUpdateConfiguration>d__11")]
protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext context, T configuration, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Databases.AbstractHandlerProcessorForUpdateDatabaseConfiguration`3/<ExecuteAsync>d__12")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Databases.AbstractHandlerProcessorForUpdateDatabaseConfiguration`3/<UpdateConfigurationAsync>d__13")]
protected ValueTask UpdateConfigurationAsync(TransactionOperationContext context, AsyncBlittableJsonTextWriter writer, T configuration);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Databases.AbstractHandlerProcessorForUpdateDatabaseTask`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<object, TRequestHandler, TOperationContext> {
    protected AbstractHandlerProcessorForUpdateDatabaseTask`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Databases.AbstractHandlerProcessorForUpdateDatabaseTask`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Debugging.AbstractStorageHandlerProcessorForGetEnvironmentReport`2 : AbstractHandlerProxyReadProcessor`3<object, TRequestHandler, TOperationContext> {
    protected AbstractStorageHandlerProcessorForGetEnvironmentReport`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<object> CreateCommandForNode(string nodeTag);
    protected string GetName();
    protected StorageEnvironmentType GetEnvironmentType();
    protected bool GetDetails();
    protected virtual DynamicJsonValue GetJsonReport(StorageEnvironmentWithType env, LowLevelTransaction lowTx, bool de);
    public void WriteEnvironmentsReport(AsyncBlittableJsonTextWriter writer, string name, IEnumerable`1<StorageEnvironmentWithType> envs, DocumentsOperationContext context, bool detailed);
    public void WriteReport(AsyncBlittableJsonTextWriter writer, StorageEnvironmentWithType env, DocumentsOperationContext context, bool detailed);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Debugging.AbstractStorageHandlerProcessorForGetReport`2 : AbstractHandlerProxyReadProcessor`3<object, TRequestHandler, TOperationContext> {
    protected AbstractStorageHandlerProcessorForGetReport`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<object> CreateCommandForNode(string nodeTag);
}
internal class Raven.Server.Documents.Handlers.Processors.Debugging.StorageHandlerProcessorForGetEnvironmentPages : AbstractStorageHandlerProcessorForGetEnvironmentReport`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public StorageHandlerProcessorForGetEnvironmentPages(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Debugging.StorageHandlerProcessorForGetEnvironmentPages/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Debugging.StorageHandlerProcessorForGetEnvironmentReport : AbstractStorageHandlerProcessorForGetEnvironmentReport`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public StorageHandlerProcessorForGetEnvironmentReport(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Debugging.StorageHandlerProcessorForGetEnvironmentReport/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
    private DetailedStorageReport GetDetailedReport(StorageEnvironmentWithType environment, bool details);
    protected virtual DynamicJsonValue GetJsonReport(StorageEnvironmentWithType env, LowLevelTransaction lowTx, bool de);
}
internal class Raven.Server.Documents.Handlers.Processors.Debugging.StorageHandlerProcessorForGetReport : AbstractStorageHandlerProcessorForGetReport`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public StorageHandlerProcessorForGetReport(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Debugging.StorageHandlerProcessorForGetReport/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
    private static StorageReport GetReport(StorageEnvironmentWithType environment);
}
internal class Raven.Server.Documents.Handlers.Processors.Debugging.StorageHandlerProcessorForGetScratchBufferReport : AbstractStorageHandlerProcessorForGetEnvironmentReport`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public StorageHandlerProcessorForGetScratchBufferReport(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Debugging.StorageHandlerProcessorForGetScratchBufferReport/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
    protected virtual DynamicJsonValue GetJsonReport(StorageEnvironmentWithType env, LowLevelTransaction lowTx, bool de);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForDelete`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDocumentHandlerProcessorForDelete`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask HandleDeleteDocumentAsync(string docId, string changeVector);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForDelete`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGenerateClassFromDocument`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDocumentHandlerProcessorForGenerateClassFromDocument`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGenerateClassFromDocument`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    protected abstract virtual ValueTask HandleClassGenerationAsync(string id, string lang);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGet`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    private static ValueTuple`2<long, long> NoResults;
    private HttpMethod _method;
    protected List`1<IDisposable> Disposables;
    protected bool SupportsShowingRequestInTrafficWatch { get; }
    protected CancellationToken CancellationToken { get; }
    protected AbstractDocumentHandlerProcessorForGet`3(HttpMethod method, TRequestHandler requestHandler);
    private static AbstractDocumentHandlerProcessorForGet`3();
    protected abstract virtual bool get_SupportsShowingRequestInTrafficWatch();
    protected abstract virtual CancellationToken get_CancellationToken();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGet`3/<ExecuteAsync>d__8")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGet`3/<ExecuteInternalAsync>d__9")]
protected virtual ValueTask ExecuteInternalAsync(TOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGet`3/<GetDocumentsByIdAsync>d__10")]
protected ValueTask`1<ValueTuple`2<long, long>> GetDocumentsByIdAsync(TOperationContext context, QueryStringParameters<TRequestHandler, TOperationContext, TDocumentType> parameters, RevisionIncludeField revisions, HashSet`1<AbstractTimeSeriesRange> timeSeries, string etag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGet`3/<WriteDocumentsByIdResultAsync>d__11")]
private ValueTask`1<ValueTuple`2<long, long>> WriteDocumentsByIdResultAsync(TOperationContext context, bool metadataOnly, bool clusterWideTx, DocumentsByIdResult`1<TRequestHandler, TOperationContext, TDocumentType, TDocumentType> result);
    protected abstract virtual ValueTask`1<ValueTuple`2<long, long>> WriteDocumentsAsync(AsyncBlittableJsonTextWriter writer, TOperationContext context, IEnumerable`1<TDocumentType> documentsToWrite, bool metadataOnly, CancellationToken token);
    protected abstract virtual ValueTask`1<ValueTuple`2<long, long>> WriteDocumentsAsync(AsyncBlittableJsonTextWriter writer, TOperationContext context, IAsyncEnumerable`1<TDocumentType> documentsToWrite, bool metadataOnly, CancellationToken token);
    protected abstract virtual ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, TOperationContext context, string propertyName, List`1<TDocumentType> includes, CancellationToken token);
    protected abstract virtual ValueTask`1<DocumentsByIdResult`1<TRequestHandler, TOperationContext, TDocumentType, TDocumentType>> GetDocumentsByIdImplAsync(TOperationContext context, List`1<ReadOnlyMemory`1<char>> ids, StringValues includePaths, RevisionIncludeField revisions, StringValues counters, HashSet`1<AbstractTimeSeriesRange> timeSeries, StringValues compareExchangeValues, bool metadataOnly, bool clusterWideTx, string etag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGet`3/<GetDocumentsAsync>d__16")]
protected ValueTask`1<ValueTuple`2<long, long>> GetDocumentsAsync(TOperationContext context, Nullable`1<long> etag, StartsWithParams<TRequestHandler, TOperationContext, TDocumentType> startsWith, bool metadataOnly, string changeVector);
    protected abstract virtual ValueTask`1<DocumentsResult<TRequestHandler, TOperationContext, TDocumentType>> GetDocumentsImplAsync(TOperationContext context, Nullable`1<long> etag, StartsWithParams<TRequestHandler, TOperationContext, TDocumentType> startsWith, string changeVector);
    private static RevisionIncludeField GetRevisionsToInclude(QueryStringParameters<TRequestHandler, TOperationContext, TDocumentType> parameters);
    private HashSet`1<AbstractTimeSeriesRange> GetTimeSeriesToInclude(QueryStringParameters<TRequestHandler, TOperationContext, TDocumentType> parameters);
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGet`3/<GetIdsFromRequestBodyAsync>d__21")]
private static ValueTask`1<List`1<ReadOnlyMemory`1<char>>> GetIdsFromRequestBodyAsync(TOperationContext context, TRequestHandler requestHandler);
    [CompilerGeneratedAttribute]
internal static string <ExecuteInternalAsync>g__CreatePerformanceHintDetails|9_0(<>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static string <ExecuteInternalAsync>g__IdsToString|9_1(List`1<ReadOnlyMemory`1<char>> ids);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGetDocSize`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDocumentHandlerProcessorForGetDocSize`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask HandleDocSizeAsync(string docId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForGetDocSize`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForHead`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDocumentHandlerProcessorForHead`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask HandleHeadRequestAsync(string docId, string changeVector);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForHead`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForPatch`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDocumentHandlerProcessorForPatch`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForPatch`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    protected abstract virtual ValueTask HandleDocumentPatchAsync(string id, string changeVector, BlittableJsonReaderObject patchRequest, bool skipPatchIfChangeVectorMismatch, bool debugMode, bool isTest, TOperationContext context);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForPut`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDocumentHandlerProcessorForPut`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.AbstractDocumentHandlerProcessorForPut`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    protected abstract virtual ValueTask HandleDocumentPutAsync(string id, string changeVector, BlittableJsonReaderObject doc, TOperationContext context);
}
internal class Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForDelete : AbstractDocumentHandlerProcessorForDelete`2<DocumentHandler, DocumentsOperationContext> {
    public DocumentHandlerProcessorForDelete(DocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForDelete/<HandleDeleteDocumentAsync>d__1")]
protected virtual ValueTask HandleDeleteDocumentAsync(string docId, string changeVector);
}
internal class Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForGenerateClassFromDocument : AbstractDocumentHandlerProcessorForGenerateClassFromDocument`2<DocumentHandler, DocumentsOperationContext> {
    public DocumentHandlerProcessorForGenerateClassFromDocument(DocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForGenerateClassFromDocument/<HandleClassGenerationAsync>d__1")]
protected virtual ValueTask HandleClassGenerationAsync(string id, string lang);
}
internal class Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForGet : AbstractDocumentHandlerProcessorForGet`3<DocumentHandler, DocumentsOperationContext, Document> {
    protected bool SupportsShowingRequestInTrafficWatch { get; }
    protected CancellationToken CancellationToken { get; }
    public DocumentHandlerProcessorForGet(HttpMethod method, DocumentHandler requestHandler);
    protected virtual bool get_SupportsShowingRequestInTrafficWatch();
    protected virtual CancellationToken get_CancellationToken();
    protected virtual ValueTask`1<DocumentsByIdResult`1<DocumentHandler, DocumentsOperationContext, Document, Document>> GetDocumentsByIdImplAsync(DocumentsOperationContext context, List`1<ReadOnlyMemory`1<char>> ids, StringValues includePaths, RevisionIncludeField revisions, StringValues counters, HashSet`1<AbstractTimeSeriesRange> timeSeries, StringValues compareExchangeValues, bool metadataOnly, bool clusterWideTx, string etag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForGet/<WriteDocumentsAsync>d__6")]
protected virtual ValueTask`1<ValueTuple`2<long, long>> WriteDocumentsAsync(AsyncBlittableJsonTextWriter writer, DocumentsOperationContext context, IEnumerable`1<Document> documentsToWrite, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForGet/<WriteDocumentsAsync>d__7")]
protected virtual ValueTask`1<ValueTuple`2<long, long>> WriteDocumentsAsync(AsyncBlittableJsonTextWriter writer, DocumentsOperationContext context, IAsyncEnumerable`1<Document> documentsToWrite, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForGet/<WriteIncludesAsync>d__8")]
protected virtual ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, DocumentsOperationContext context, string propertyName, List`1<Document> includes, CancellationToken token);
    protected virtual ValueTask`1<DocumentsResult<DocumentHandler, DocumentsOperationContext, Document>> GetDocumentsImplAsync(DocumentsOperationContext context, Nullable`1<long> etag, StartsWithParams<DocumentHandler, DocumentsOperationContext, Document> startsWith, string changeVector);
}
internal class Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForGetDocSize : AbstractDocumentHandlerProcessorForGetDocSize`2<DocumentHandler, DocumentsOperationContext> {
    public DocumentHandlerProcessorForGetDocSize(DocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForGetDocSize/<HandleDocSizeAsync>d__1")]
protected virtual ValueTask HandleDocSizeAsync(string docId);
}
internal class Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForHead : AbstractDocumentHandlerProcessorForHead`2<DocumentHandler, DocumentsOperationContext> {
    public DocumentHandlerProcessorForHead(DocumentHandler requestHandler);
    protected virtual ValueTask HandleHeadRequestAsync(string docId, string changeVector);
}
internal class Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForPatch : AbstractDocumentHandlerProcessorForPatch`2<DocumentHandler, DocumentsOperationContext> {
    public DocumentHandlerProcessorForPatch(DocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForPatch/<HandleDocumentPatchAsync>d__1")]
protected virtual ValueTask HandleDocumentPatchAsync(string id, string cv, BlittableJsonReaderObject patchRequest, bool skipPatchIfChangeVectorMismatch, bool debugMode, bool isTest, DocumentsOperationContext context);
}
internal class Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForPut : AbstractDocumentHandlerProcessorForPut`2<DocumentHandler, DocumentsOperationContext> {
    public DocumentHandlerProcessorForPut(DocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Documents.DocumentHandlerProcessorForPut/<HandleDocumentPutAsync>d__1")]
protected virtual ValueTask HandleDocumentPutAsync(string id, string changeVector, BlittableJsonReaderObject doc, DocumentsOperationContext context);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.DocumentsCompression.AbstractDocumentsCompressionHandlerProcessorForGet`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDocumentsCompressionHandlerProcessorForGet`2(TRequestHandler requestHandler);
    protected abstract virtual DocumentsCompressionConfiguration GetDocumentsCompressionConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.DocumentsCompression.AbstractDocumentsCompressionHandlerProcessorForGet`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.DocumentsCompression.AbstractDocumentsCompressionHandlerProcessorForPost`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractDocumentsCompressionHandlerProcessorForPost`2(TRequestHandler requestHandler);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal class Raven.Server.Documents.Handlers.Processors.DocumentsCompression.DocumentsCompressionHandlerProcessorForGet : AbstractDocumentsCompressionHandlerProcessorForGet`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public DocumentsCompressionHandlerProcessorForGet(DatabaseRequestHandler requestHandler);
    protected virtual DocumentsCompressionConfiguration GetDocumentsCompressionConfiguration();
}
internal class Raven.Server.Documents.Handlers.Processors.DocumentsCompression.DocumentsCompressionHandlerProcessorForPost : AbstractDocumentsCompressionHandlerProcessorForPost`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public DocumentsCompressionHandlerProcessorForPost(DatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Expiration.AbstractExpirationHandlerProcessorForGet`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractExpirationHandlerProcessorForGet`2(TRequestHandler requestHandler);
    protected abstract virtual ExpirationConfiguration GetExpirationConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Expiration.AbstractExpirationHandlerProcessorForGet`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Expiration.AbstractExpirationHandlerProcessorForPost`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractExpirationHandlerProcessorForPost`2(TRequestHandler requestHandler);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal class Raven.Server.Documents.Handlers.Processors.Expiration.ExpirationHandlerProcessorForGet : AbstractExpirationHandlerProcessorForGet`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public ExpirationHandlerProcessorForGet(DatabaseRequestHandler requestHandler);
    protected virtual ExpirationConfiguration GetExpirationConfiguration();
}
internal class Raven.Server.Documents.Handlers.Processors.Expiration.ExpirationHandlerProcessorForPost : AbstractExpirationHandlerProcessorForPost`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public ExpirationHandlerProcessorForPost(DatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.HiLo.AbstractHiLoHandlerProcessorForGetNextHiLo`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractHiLoHandlerProcessorForGetNextHiLo`2(TRequestHandler requestHandler);
    protected string GetTag();
    protected long GetLastBatchSize();
    protected Nullable`1<DateTime> GetLastRangeAt();
    protected char GetIdentityPartsSeparator();
    protected long GetLastMax();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.HiLo.AbstractHiLoHandlerProcessorForReturnHiLo`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractHiLoHandlerProcessorForReturnHiLo`2(TRequestHandler requestHandler);
    protected string GetTag();
    protected long GetEnd();
    protected long GetLast();
}
internal class Raven.Server.Documents.Handlers.Processors.HiLo.HiLoHandlerProcessorForGetNextHiLo : AbstractHiLoHandlerProcessorForGetNextHiLo`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public HiLoHandlerProcessorForGetNextHiLo(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.HiLo.HiLoHandlerProcessorForGetNextHiLo/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    private static long CalculateCapacity(long lastSize, Nullable`1<DateTime> lastRangeAt);
}
internal class Raven.Server.Documents.Handlers.Processors.HiLo.HiLoHandlerProcessorForReturnHiLo : AbstractHiLoHandlerProcessorForReturnHiLo`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public HiLoHandlerProcessorForReturnHiLo(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.HiLo.HiLoHandlerProcessorForReturnHiLo/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Identities.AbstractIdentityDebugHandlerProcessorForGetIdentities`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIdentityDebugHandlerProcessorForGetIdentities`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Identities.AbstractIdentityDebugHandlerProcessorForGetIdentities`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Identities.AbstractIdentityHandlerProcessorForNextIdentityFor`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIdentityHandlerProcessorForNextIdentityFor`2(TRequestHandler requestHandler);
    protected abstract virtual char GetDatabaseIdentityPartsSeparator();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Identities.AbstractIdentityHandlerProcessorForNextIdentityFor`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Identities.AbstractIdentityHandlerProcessorForPostIdentity`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIdentityHandlerProcessorForPostIdentity`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Identities.AbstractIdentityHandlerProcessorForPostIdentity`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Identities.IdentityDebugHandlerProcessorForGetIdentities : AbstractIdentityDebugHandlerProcessorForGetIdentities`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IdentityDebugHandlerProcessorForGetIdentities(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.Identities.IdentityHandlerProcessorForNextIdentityFor : AbstractIdentityHandlerProcessorForNextIdentityFor`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IdentityHandlerProcessorForNextIdentityFor(DatabaseRequestHandler requestHandler);
    protected virtual char GetDatabaseIdentityPartsSeparator();
}
internal class Raven.Server.Documents.Handlers.Processors.Identities.IdentityHandlerProcessorForPostIdentity : AbstractIdentityHandlerProcessorForPostIdentity`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IdentityHandlerProcessorForPostIdentity(DatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForClearErrors`2 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForClearErrors`2(TRequestHandler requestHandler);
    [PreserveBaseOverridesAttribute]
protected virtual override RavenCommand CreateCommandForNode(string nodeTag);
    protected StringValues GetNames();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForDebug`2 : AbstractHandlerProxyReadProcessor`3<object, TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForDebug`2(TRequestHandler requestHandler);
    protected string GetIndexName();
    protected string GetOperation();
    protected StringValues GetDocIds();
    protected string GetStartsWith();
    protected virtual RavenCommand`1<object> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForDelete`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForDelete`2(TRequestHandler requestHandler);
    protected abstract virtual AbstractIndexDeleteController GetIndexDeleteProcessor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForDelete`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    private string GetName();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForGetAll`2 : AbstractHandlerProxyReadProcessor`3<IndexDefinition[], TRequestHandler, TOperationContext> {
    protected bool SupportsCurrentNode { get; }
    protected AbstractIndexHandlerProcessorForGetAll`2(TRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected string GetName();
    protected abstract virtual IndexDefinition[] GetIndexDefinitions(string indexName, int start, int pageSize);
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual RavenCommand`1<IndexDefinition[]> CreateCommandForNode(string nodeTag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForGetAll`2/<WriteResultAsync>d__7")]
private ValueTask WriteResultAsync(IndexDefinition[] result);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForGetAllNames`2 : AbstractHandlerProxyReadProcessor`3<String[], TRequestHandler, TOperationContext> {
    protected bool SupportsCurrentNode { get; }
    protected AbstractIndexHandlerProcessorForGetAllNames`2(TRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected string GetName();
    protected abstract virtual String[] GetIndexNames(string name);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForGetAllNames`2/<HandleCurrentNodeAsync>d__5")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual RavenCommand`1<String[]> CreateCommandForNode(string nodeTag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForGetAllNames`2/<WriteResultAsync>d__7")]
private ValueTask WriteResultAsync(String[] result);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForGetDatabaseIndexStatistics`2 : AbstractHandlerProxyReadProcessor`3<IndexStats[], TRequestHandler, TOperationContext> {
    protected bool ShouldCalculateStats { get; }
    protected AbstractIndexHandlerProcessorForGetDatabaseIndexStatistics`2(TRequestHandler requestHandler);
    protected bool get_ShouldCalculateStats();
    protected virtual RavenCommand`1<IndexStats[]> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForGetErrors`2 : AbstractHandlerProxyReadProcessor`3<IndexErrors[], TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForGetErrors`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<IndexErrors[]> CreateCommandForNode(string nodeTag);
    protected String[] GetIndexNames();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForGetIndexesStatus`2 : AbstractHandlerProxyReadProcessor`3<IndexingStatus, TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForGetIndexesStatus`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<IndexingStatus> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForHasChanged`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForHasChanged`2(TRequestHandler requestHandler);
    protected abstract virtual AbstractIndexHasChangedController GetHasChangedController();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForHasChanged`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForOpenFaultyIndex`2 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForOpenFaultyIndex`2(TRequestHandler requestHandler);
    [PreserveBaseOverridesAttribute]
protected virtual override RavenCommand CreateCommandForNode(string nodeTag);
    protected string GetName();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForPerformance`2 : AbstractHandlerProxyReadProcessor`3<IndexPerformanceStats[], TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForPerformance`2(TRequestHandler requestHandler);
    protected StringValues GetNames();
    protected virtual RavenCommand`1<IndexPerformanceStats[]> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForPerformanceLive`2 : AbstractHandlerWebSocketProxyProcessor`2<TRequestHandler, TOperationContext> {
    private static string IncludeSideBySideQueryString;
    private static string NameQueryString;
    protected bool IncludeSideBySide { get; }
    protected AbstractIndexHandlerProcessorForPerformanceLive`2(TRequestHandler requestHandler);
    protected virtual string GetRemoteEndpointUrl(string databaseName);
    protected bool get_IncludeSideBySide();
    protected StringValues GetNames();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForProgress`2 : AbstractHandlerProxyReadProcessor`3<IndexProgress[], TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForProgress`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<IndexProgress[]> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForReplace`2 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForReplace`2(TRequestHandler requestHandler);
    protected string GetIndexName();
    protected virtual RavenCommand`1<object> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForReset`2 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    private static string IndexResetModeQueryStringParamName;
    protected AbstractIndexHandlerProcessorForReset`2(TRequestHandler requestHandler);
    [PreserveBaseOverridesAttribute]
protected virtual override RavenCommand CreateCommandForNode(string nodeTag);
    protected string GetName();
    private Nullable`1<IndexResetMode> GetIndexResetMode();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForSetLockMode`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForSetLockMode`2(TRequestHandler requestHandler);
    protected abstract virtual AbstractIndexLockModeController GetIndexLockModeProcessor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForSetLockMode`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForSetPriority`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForSetPriority`2(TRequestHandler requestHandler);
    protected abstract virtual AbstractIndexPriorityController GetIndexPriorityProcessor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForSetPriority`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForSource`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForSource`2(TRequestHandler requestHandler);
    protected abstract virtual IndexInformationHolder GetIndex(string name);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForSource`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    private string GetName();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForStale`2 : AbstractHandlerProxyReadProcessor`3<IndexStaleness, TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForStale`2(TRequestHandler requestHandler);
    protected string GetName();
    protected virtual RavenCommand`1<IndexStaleness> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForSuggestIndexMerge`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForSuggestIndexMerge`2(TRequestHandler requestHandler);
    protected abstract virtual Dictionary`2<string, IndexDefinition> GetIndexes();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForSuggestIndexMerge`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForTerms`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForTerms`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<TermsQueryResultServerSide> GetTermsAsync(string indexName, string field, string fromValue, int pageSize, Nullable`1<long> resultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForTerms`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexHandlerProcessorForTotalTime`2 : AbstractHandlerProxyReadProcessor`3<IndexTotalTime[], TRequestHandler, TOperationContext> {
    protected AbstractIndexHandlerProcessorForTotalTime`2(TRequestHandler requestHandler);
    protected StringValues GetNames();
    protected virtual RavenCommand`1<IndexTotalTime[]> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Indexes.AbstractIndexProcessorForGenerateCSharpIndexDefinition`2 : AbstractHandlerProxyReadProcessor`3<string, TRequestHandler, TOperationContext> {
    protected AbstractIndexProcessorForGenerateCSharpIndexDefinition`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<string> CreateCommandForNode(string nodeTag);
    protected string GetName();
}
public class Raven.Server.Documents.Handlers.Processors.Indexes.AutoToStaticIndexConverter : object {
    public static AutoToStaticIndexConverter Instance;
    private static AutoToStaticIndexConverter();
    public IndexDefinition ConvertToIndexDefinition(AutoIndexDefinition autoIndex);
    public string ConvertToAbstractIndexCreationTask(AutoIndexDefinition autoIndex);
    public static string GetSanitizedIndexName(AutoIndexDefinition autoIndex);
    private static void HandleMapFields(StringBuilder sb, AutoIndexDefinition autoIndex, AutoIndexConversionContext context);
    private static void ConstructReduceInternal(StringBuilder sb, AutoIndexDefinition autoIndex);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.AutoToStaticIndexConverter/<GenerateFieldName>d__7")]
private static IEnumerable`1<ValueTuple`3<string, AutoFieldIndexing, bool>> GenerateFieldName(string name, Nullable`1<AutoFieldIndexing> indexing);
    [CompilerGeneratedAttribute]
internal static string <ConvertToIndexDefinition>g__GenerateName|2_0(string name);
    [CompilerGeneratedAttribute]
internal static HashSet`1<string> <ConvertToIndexDefinition>g__ConstructMaps|2_1(AutoIndexDefinition autoIndex, AutoIndexConversionContext context);
    [CompilerGeneratedAttribute]
internal static string <ConvertToIndexDefinition>g__ConstructReduce|2_2(AutoIndexDefinition autoIndex);
    [CompilerGeneratedAttribute]
internal static Dictionary`2<string, IndexFieldOptions> <ConvertToIndexDefinition>g__ConstructFields|2_3(AutoIndexDefinition autoIndex, AutoIndexConversionContext context);
    [CompilerGeneratedAttribute]
internal static IndexFieldOptions <ConvertToIndexDefinition>g__GetFieldOptions|2_4(string fieldName, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static void <ConvertToIndexDefinition>g__HandleFieldIndexing|2_5(string fieldName, Nullable`1<AutoFieldIndexing> fieldIndexing, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static void <ConvertToIndexDefinition>g__HandleStorage|2_6(string fieldName, Nullable`1<FieldStorage> fieldStorage, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static void <ConvertToIndexDefinition>g__HandleSuggestions|2_7(string fieldName, Nullable`1<bool> suggestions, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static void <ConvertToIndexDefinition>g__HandleSpatial|2_8(string fieldName, AutoSpatialOptions spatialOptions, AutoIndexConversionContext context, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static void <ConvertToAbstractIndexCreationTask>g__ConstructMap|3_0(AutoIndexDefinition autoIndex, StringBuilder sb, AutoIndexConversionContext context);
    [CompilerGeneratedAttribute]
internal static void <ConvertToAbstractIndexCreationTask>g__ConstructReduce|3_1(AutoIndexDefinition autoIndex, StringBuilder sb);
    [CompilerGeneratedAttribute]
internal static void <ConvertToAbstractIndexCreationTask>g__ConstructFieldOptions|3_2(AutoIndexDefinition autoIndex, StringBuilder sb, AutoIndexConversionContext context);
    [CompilerGeneratedAttribute]
internal static void <ConvertToAbstractIndexCreationTask>g__HandleFieldIndexing|3_3(string fieldName, Nullable`1<AutoFieldIndexing> indexing, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <ConvertToAbstractIndexCreationTask>g__HandleStorage|3_4(string fieldName, Nullable`1<FieldStorage> fieldStorage, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <ConvertToAbstractIndexCreationTask>g__HandleSuggestions|3_5(string fieldName, Nullable`1<bool> suggestions, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <ConvertToAbstractIndexCreationTask>g__HandleSpatial|3_6(string fieldName, AutoSpatialOptions spatial, AutoIndexConversionContext context, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static string <ConstructReduceInternal>g__GenerateGroupBy|6_0(AutoIndexDefinition autoIndex);
}
public enum Raven.Server.Documents.Handlers.Processors.Indexes.ConversionOutputType : Enum {
    public int value__;
    public static ConversionOutputType CsharpClass;
    public static ConversionOutputType Json;
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForClearErrors : AbstractIndexHandlerProcessorForClearErrors`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForClearErrors(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForConvertAutoIndex`2 : AbstractHandlerProcessor`1<TRequestHandler> {
    public IndexHandlerProcessorForConvertAutoIndex`2(TRequestHandler requestHandler);
    private string GetName();
    private ConversionOutputType GetConvertType();
    private bool HasDownload();
    private void SetFileToDownload(string fileName);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForConvertAutoIndex`2/<ExecuteAsync>d__5")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForDebug : AbstractIndexHandlerProcessorForDebug`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForDebug(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForDebug/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForDelete : AbstractIndexHandlerProcessorForDelete`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IndexHandlerProcessorForDelete(DatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexDeleteController GetIndexDeleteProcessor();
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForGetAll : AbstractIndexHandlerProcessorForGetAll`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IndexHandlerProcessorForGetAll(DatabaseRequestHandler requestHandler);
    protected virtual IndexDefinition[] GetIndexDefinitions(string indexName, int start, int pageSize);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexDefinition[]> command, OperationCancelToken token);
    internal static IndexDefinition[] GetIndexDefinitions(DatabaseRequestHandler requestHandler, string indexName, int start, int pageSize);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForGetAllNames : AbstractIndexHandlerProcessorForGetAllNames`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IndexHandlerProcessorForGetAllNames(DatabaseRequestHandler requestHandler);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<String[]> command, OperationCancelToken token);
    protected virtual String[] GetIndexNames(string name);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForGetDatabaseIndexStatistics : AbstractIndexHandlerProcessorForGetDatabaseIndexStatistics`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForGetDatabaseIndexStatistics(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexStats[]> command, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForGetDatabaseIndexStatistics/<WriteResultAsync>d__5")]
private ValueTask WriteResultAsync(IndexStats[] result);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForGetErrors : AbstractIndexHandlerProcessorForGetErrors`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForGetErrors(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexErrors[]> command, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForGetErrors/<WriteResultAsync>d__5")]
private ValueTask WriteResultAsync(IndexErrors[] result);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForGetIndexesStatus : AbstractIndexHandlerProcessorForGetIndexesStatus`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForGetIndexesStatus(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexingStatus> command, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForGetIndexesStatus/<WriteResultAsync>d__5")]
private ValueTask WriteResultAsync(IndexingStatus result);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForGetIndexHistory`1 : AbstractDatabaseHandlerProcessor`1<TOperationContext> {
    public IndexHandlerProcessorForGetIndexHistory`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForGetIndexHistory`1/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    private string GetName();
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForHasChanged : AbstractIndexHandlerProcessorForHasChanged`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IndexHandlerProcessorForHasChanged(DatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexHasChangedController GetHasChangedController();
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForOpenFaultyIndex : AbstractIndexHandlerProcessorForOpenFaultyIndex`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForOpenFaultyIndex(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForPerformance : AbstractIndexHandlerProcessorForPerformance`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForPerformance(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexPerformanceStats[]> command, OperationCancelToken token);
    private IEnumerable`1<Index> GetIndexesToReportOn();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForPerformance/<WriteResultAsync>d__6")]
private ValueTask WriteResultAsync(IndexPerformanceStats[] result);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForPerformanceLive : AbstractIndexHandlerProcessorForPerformanceLive`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForPerformanceLive(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForPerformanceLive/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
    private IEnumerable`1<Index> GetIndexesToReportOn();
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForProgress : AbstractIndexHandlerProcessorForProgress`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForProgress(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexProgress[]> command, OperationCancelToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForProgress/<GetIndexesProgress>d__5")]
private IEnumerable`1<IndexProgress> GetIndexesProgress();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForProgress/<WriteResultAsync>d__6")]
private ValueTask WriteResultAsync(IndexProgress[] result);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForReplace : AbstractIndexHandlerProcessorForReplace`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForReplace(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForReset : AbstractIndexHandlerProcessorForReset`2<DatabaseRequestHandler, DocumentsOperationContext> {
    private static string IndexResetModeQueryStringParamName;
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForReset(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForSetLockMode : AbstractIndexHandlerProcessorForSetLockMode`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IndexHandlerProcessorForSetLockMode(DatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexLockModeController GetIndexLockModeProcessor();
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForSetPriority : AbstractIndexHandlerProcessorForSetPriority`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IndexHandlerProcessorForSetPriority(DatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexPriorityController GetIndexPriorityProcessor();
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForSource : AbstractIndexHandlerProcessorForSource`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IndexHandlerProcessorForSource(DatabaseRequestHandler requestHandler);
    protected virtual IndexInformationHolder GetIndex(string name);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForStale : AbstractIndexHandlerProcessorForStale`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForStale(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexStaleness> command, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForStale/<WriteResultAsync>d__5")]
private ValueTask WriteResultAsync(IndexStaleness result);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForSuggestIndexMerge : AbstractIndexHandlerProcessorForSuggestIndexMerge`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IndexHandlerProcessorForSuggestIndexMerge(DatabaseRequestHandler requestHandler);
    protected virtual Dictionary`2<string, IndexDefinition> GetIndexes();
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForTerms : AbstractIndexHandlerProcessorForTerms`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public IndexHandlerProcessorForTerms(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<TermsQueryResultServerSide> GetTermsAsync(string indexName, string field, string fromValue, int pageSize, Nullable`1<long> resultEtag, OperationCancelToken token);
    private string GetIndexNameFromCollectionAndField(string field);
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForTotalTime : AbstractIndexHandlerProcessorForTotalTime`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexHandlerProcessorForTotalTime(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexHandlerProcessorForTotalTime/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexTotalTime[]> command, OperationCancelToken token);
    private IEnumerable`1<Index> GetIndexesToReportOn();
}
internal class Raven.Server.Documents.Handlers.Processors.Indexes.IndexProcessorForGenerateCSharpIndexDefinition : AbstractIndexProcessorForGenerateCSharpIndexDefinition`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IndexProcessorForGenerateCSharpIndexDefinition(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<string> command, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Indexes.IndexProcessorForGenerateCSharpIndexDefinition/<WriteResultAsync>d__5")]
private ValueTask WriteResultAsync(string result);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.IoMetrics.AbstractIoMetricsHandlerProcessorForLive`2 : AbstractHandlerWebSocketProxyProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractIoMetricsHandlerProcessorForLive`2(TRequestHandler requestHandler);
    protected virtual string GetRemoteEndpointUrl(string databaseName);
}
internal class Raven.Server.Documents.Handlers.Processors.IoMetrics.IoMetricsHandlerProcessorForLive : AbstractIoMetricsHandlerProcessorForLive`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public IoMetricsHandlerProcessorForLive(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.IoMetrics.IoMetricsHandlerProcessorForLive/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.MultiGet.AbstractMultiGetHandlerProcessorForPost`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractMultiGetHandlerProcessorForPost`2(TRequestHandler requestHandler);
    protected abstract virtual HandleRequest GetRequestHandler(RouteInformation routeInformation);
    protected abstract virtual void FillRequestHandlerContext(RequestHandlerContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.MultiGet.AbstractMultiGetHandlerProcessorForPost`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
    private static MemoryStream GetRequestBody(string content);
    private static void HandleException(JsonOperationContext context, AsyncBlittableJsonTextWriter writer, Exception e, string url, string query);
    private static void HandleNoRoute(JsonOperationContext context, AsyncBlittableJsonTextWriter writer, string method, string url, string query, LazyStringValue statusProperty, LazyStringValue resultProperty);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.MultiGet.AbstractMultiGetHandlerProcessorForPost`2/<HandleRequestAsync>d__7")]
private ValueTask HandleRequestAsync(BlittableJsonReaderObject request, JsonOperationContext context, MemoryStream responseStream, AsyncBlittableJsonTextWriter writer, HttpContext httpContext, StringValues httpEncodings, HostString host, string scheme, LazyStringValue resultProperty, LazyStringValue statusProperty, LazyStringValue headersProperty, StringBuilder trafficWatchStringBuilder);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.MultiGet.AbstractMultiGetHandlerProcessorForPost`2/<PrepareHttpContextAsync>d__8")]
private ValueTask`1<object> PrepareHttpContextAsync(BlittableJsonReaderObject request, JsonOperationContext context, HttpContext httpContext, StringValues httpEncodings, string method, string query, HostString host, string scheme, StringBuilder trafficWatchStringBuilder);
    private void WriteHeaders(AsyncBlittableJsonTextWriter writer, HttpContext httpContext, LazyStringValue headersProperty);
}
internal class Raven.Server.Documents.Handlers.Processors.MultiGet.MultiGetHandlerProcessorForPost : AbstractMultiGetHandlerProcessorForPost`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public MultiGetHandlerProcessorForPost(DatabaseRequestHandler requestHandler);
    protected virtual HandleRequest GetRequestHandler(RouteInformation routeInformation);
    protected virtual void FillRequestHandlerContext(RequestHandlerContext context);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForAddEtl`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    private long _taskId;
    protected AbstractOngoingTasksHandlerProcessorForAddEtl`2(TRequestHandler requestHandler);
    protected virtual void OnBeforeResponseWrite(TransactionOperationContext _, DynamicJsonValue responseJson, BlittableJsonReaderObject configuration, long index);
    protected virtual void OnBeforeUpdateConfiguration(BlittableJsonReaderObject& configuration, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForAddEtl`2/<OnAfterUpdateConfiguration>d__4")]
protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext _, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual void AssertCanAddOrUpdateEtl(BlittableJsonReaderObject& etlConfiguration);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForAddQueueSink`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    private long _taskId;
    protected AbstractOngoingTasksHandlerProcessorForAddQueueSink`2(TRequestHandler requestHandler);
    protected virtual void OnBeforeResponseWrite(TransactionOperationContext _, DynamicJsonValue responseJson, BlittableJsonReaderObject configuration, long index);
    protected virtual void OnBeforeUpdateConfiguration(BlittableJsonReaderObject& configuration, JsonOperationContext context);
    protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext _, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual void AssertCanAddOrUpdateQueueSink(BlittableJsonReaderObject& queueSinkConfiguration);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForBackupDatabaseNow`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractOngoingTasksHandlerProcessorForBackupDatabaseNow`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<bool> ScheduleBackupOperationAsync(long taskId, bool isFullBackup, long operationId, Nullable`1<DateTime> startTime);
    protected abstract virtual long GetNextOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForBackupDatabaseNow`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForBackupDatabaseOnce`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    private static int _oneTimeBackupCounter;
    protected AbstractOngoingTasksHandlerProcessorForBackupDatabaseOnce`2(TRequestHandler requestHandler);
    protected abstract virtual void ScheduleBackup(BackupConfiguration backupConfiguration, long operationId, string backupName, Stopwatch sw, DateTime startTime, OperationCancelToken token);
    protected abstract virtual long GetNextOperationId();
    protected abstract virtual AbstractNotificationCenter GetNotificationCenter();
    protected virtual void AssertBackup(BackupConfiguration configuration);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForBackupDatabaseOnce`2/<ExecuteAsync>d__6")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForDeleteOngoingTask`2 : AbstractHandlerProcessorForUpdateDatabaseTask`2<TRequestHandler, TOperationContext> {
    protected string TaskName;
    private OngoingTaskType _type;
    private long _taskId;
    private DeleteOngoingTaskAction<TRequestHandler, TOperationContext> _action;
    protected AbstractOngoingTasksHandlerProcessorForDeleteOngoingTask`2(TRequestHandler requestHandler);
    protected virtual void OnBeforeResponseWrite(TransactionOperationContext context, DynamicJsonValue responseJson, object _, long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForDeleteOngoingTask`2/<OnAfterUpdateConfiguration>d__6")]
protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext context, object _, string raftRequestId);
    protected abstract virtual ValueTask RaiseNotificationForSubscriptionTaskRemoval();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForDeleteOngoingTask`2/<OnUpdateConfiguration>d__8")]
protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, object _, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForDeleteSubscriptionTasks`2 : AbstractOngoingTasksHandlerProcessorForDeleteOngoingTask`2<TRequestHandler, TOperationContext> {
    protected AbstractOngoingTasksHandlerProcessorForDeleteSubscriptionTasks`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForDeleteSubscriptionTasks`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForGetPullReplicationHubTasksInfo`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractOngoingTasksHandlerProcessorForGetPullReplicationHubTasksInfo`2(TRequestHandler requestHandler);
    protected abstract virtual IEnumerable`1<OngoingTaskPullReplicationAsHub> GetOngoingTasks(TransactionOperationContext context, DatabaseRecord databaseRecord, ClusterTopology clusterTopology, long key);
    protected virtual void AssertCanExecute();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForGetPullReplicationHubTasksInfo`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForGetPullReplicationHubTasksInfo`2/<WriteResultAsync>d__4")]
internal Task WriteResultAsync(JsonOperationContext context, DynamicJsonValue dynamicJsonValue);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForPostSubscriptionTasksState`2 : AbstractOngoingTasksHandlerProcessorForToggleTaskState`2<TRequestHandler, TOperationContext> {
    [CompilerGeneratedAttribute]
private bool <RequireAdmin>k__BackingField;
    protected bool RequireAdmin { get; }
    public AbstractOngoingTasksHandlerProcessorForPostSubscriptionTasksState`2(TRequestHandler requestHandler);
    [CompilerGeneratedAttribute]
protected virtual bool get_RequireAdmin();
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, object _, string raftRequestId);
    public static void ValidateSubscriptionTaskType(string typeStr);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForPutConnectionString`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    private long _index;
    protected AbstractOngoingTasksHandlerProcessorForPutConnectionString`2(TRequestHandler requestHandler);
    protected virtual void OnBeforeUpdateConfiguration(BlittableJsonReaderObject& configuration, JsonOperationContext context);
    private static ConnectionString GetConnectionString(BlittableJsonReaderObject readerObject, ConnectionStringType connectionStringType);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForPutConnectionString`2/<OnUpdateConfiguration>d__4")]
protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForRemoveConnectionString`2 : AbstractHandlerProcessorForUpdateDatabaseTask`2<TRequestHandler, TOperationContext> {
    protected AbstractOngoingTasksHandlerProcessorForRemoveConnectionString`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForRemoveConnectionString`2/<OnUpdateConfiguration>d__1")]
protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, object _, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForResetEtl`2 : AbstractHandlerProcessorForUpdateDatabaseTask`2<TRequestHandler, TOperationContext> {
    protected AbstractOngoingTasksHandlerProcessorForResetEtl`2(TRequestHandler requestHandler);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, object _, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForToggleTaskState`2 : AbstractHandlerProcessorForUpdateDatabaseTask`2<TRequestHandler, TOperationContext> {
    private long _key;
    private string _desc;
    protected AbstractOngoingTasksHandlerProcessorForToggleTaskState`2(TRequestHandler requestHandler);
    protected virtual void OnBeforeResponseWrite(TransactionOperationContext context, DynamicJsonValue responseJson, object _, long index);
    protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext context, object configuration, string raftRequestId);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, object _, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForToggleTaskState`2/<ToggleTaskState>d__6")]
private Task`1<ValueTuple`2<long, object>> ToggleTaskState(long taskId, string taskName, OngoingTaskType type, bool disable, string dbName, string raftRequestId);
    protected abstract virtual AbstractSubscriptionStorage GetSubscriptionStorage();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForUpdateExternalReplication`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    private ExternalReplication _watcher;
    private long _taskId;
    protected AbstractOngoingTasksHandlerProcessorForUpdateExternalReplication`2(TRequestHandler requestHandler);
    protected abstract virtual void FillResponsibleNode(TransactionOperationContext context, DynamicJsonValue responseJson, ExternalReplication watcher);
    protected virtual void OnBeforeResponseWrite(TransactionOperationContext context, DynamicJsonValue responseJson, BlittableJsonReaderObject configuration, long index);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForUpdatePeriodicBackup`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<PeriodicBackupConfiguration, TRequestHandler, TOperationContext> {
    private long _taskId;
    protected AbstractOngoingTasksHandlerProcessorForUpdatePeriodicBackup`2(TRequestHandler requestHandler);
    protected abstract virtual BackupConfiguration GetBackupConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForUpdatePeriodicBackup`2/<GetConfigurationAsync>d__3")]
protected virtual ValueTask`1<PeriodicBackupConfiguration> GetConfigurationAsync(TransactionOperationContext context, AsyncBlittableJsonTextWriter writer);
    protected virtual void OnBeforeUpdateConfiguration(PeriodicBackupConfiguration& configuration, JsonOperationContext context);
    protected virtual void OnBeforeResponseWrite(TransactionOperationContext _, DynamicJsonValue responseJson, PeriodicBackupConfiguration configuration, long index);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, PeriodicBackupConfiguration configuration, string raftRequestId);
    protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext context, PeriodicBackupConfiguration configuration, string raftRequestId);
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForAddEtl : AbstractOngoingTasksHandlerProcessorForAddEtl`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForAddEtl(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForAddQueueSink : AbstractOngoingTasksHandlerProcessorForAddQueueSink`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForAddQueueSink(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForBackupDatabaseNow : AbstractOngoingTasksHandlerProcessorForBackupDatabaseNow`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForBackupDatabaseNow(DatabaseRequestHandler requestHandler);
    protected virtual long GetNextOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForBackupDatabaseNow/<ScheduleBackupOperationAsync>d__2")]
protected virtual ValueTask`1<bool> ScheduleBackupOperationAsync(long taskId, bool isFullBackup, long operationId, Nullable`1<DateTime> startTime);
    private void RedirectToRelevantNode(string nodeTag);
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForBackupDatabaseOnce : AbstractOngoingTasksHandlerProcessorForBackupDatabaseOnce`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForBackupDatabaseOnce(DatabaseRequestHandler requestHandler);
    protected virtual void ScheduleBackup(BackupConfiguration backupConfiguration, long operationId, string backupName, Stopwatch sw, DateTime startTime, OperationCancelToken token);
    protected virtual long GetNextOperationId();
    protected virtual AbstractNotificationCenter GetNotificationCenter();
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForDeleteOngoingTask : AbstractOngoingTasksHandlerProcessorForDeleteOngoingTask`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForDeleteOngoingTask(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask RaiseNotificationForSubscriptionTaskRemoval();
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForDeleteSubscriptionTasks : AbstractOngoingTasksHandlerProcessorForDeleteSubscriptionTasks`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForDeleteSubscriptionTasks(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask RaiseNotificationForSubscriptionTaskRemoval();
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetConnectionString`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public OngoingTasksHandlerProcessorForGetConnectionString`2(TRequestHandler requestHandler);
    private static ValueTuple`5<Dictionary`2<string, RavenConnectionString>, Dictionary`2<string, SqlConnectionString>, Dictionary`2<string, OlapConnectionString>, Dictionary`2<string, ElasticSearchConnectionString>, Dictionary`2<string, QueueConnectionString>> GetConnectionString(RawDatabaseRecord rawRecord, string connectionStringName, ConnectionStringType connectionStringType);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetConnectionString`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetFullBackupDataDirectory`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public OngoingTasksHandlerProcessorForGetFullBackupDataDirectory`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetFullBackupDataDirectory`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetPeriodicBackupConfiguration`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public OngoingTasksHandlerProcessorForGetPeriodicBackupConfiguration`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetPeriodicBackupConfiguration`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetPullReplicationHubTasksInfo : AbstractOngoingTasksHandlerProcessorForGetPullReplicationHubTasksInfo`2<DatabaseRequestHandler, DocumentsOperationContext> {
    private OngoingTasksHandler _ongoingTasksHandler;
    public OngoingTasksHandlerProcessorForGetPullReplicationHubTasksInfo(OngoingTasksHandler requestHandler);
    protected virtual IEnumerable`1<OngoingTaskPullReplicationAsHub> GetOngoingTasks(TransactionOperationContext context, DatabaseRecord databaseRecord, ClusterTopology clusterTopology, long key);
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForPostSubscriptionTasksState : AbstractOngoingTasksHandlerProcessorForPostSubscriptionTasksState`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForPostSubscriptionTasksState(DatabaseRequestHandler requestHandler);
    protected virtual AbstractSubscriptionStorage GetSubscriptionStorage();
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForPutConnectionString : AbstractOngoingTasksHandlerProcessorForPutConnectionString`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForPutConnectionString(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForRemoveConnectionString : AbstractOngoingTasksHandlerProcessorForRemoveConnectionString`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForRemoveConnectionString(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForResetEtl : AbstractOngoingTasksHandlerProcessorForResetEtl`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForResetEtl(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForToggleTaskState : AbstractOngoingTasksHandlerProcessorForToggleTaskState`2<DatabaseRequestHandler, DocumentsOperationContext> {
    [CompilerGeneratedAttribute]
private bool <RequireAdmin>k__BackingField;
    protected bool RequireAdmin { get; }
    public OngoingTasksHandlerProcessorForToggleTaskState(DatabaseRequestHandler requestHandler, bool requireAdmin);
    [CompilerGeneratedAttribute]
protected virtual bool get_RequireAdmin();
    protected virtual AbstractSubscriptionStorage GetSubscriptionStorage();
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForUpdateExternalReplication : AbstractOngoingTasksHandlerProcessorForUpdateExternalReplication`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForUpdateExternalReplication(DatabaseRequestHandler requestHandler);
    protected virtual void FillResponsibleNode(TransactionOperationContext context, DynamicJsonValue responseJson, ExternalReplication watcher);
}
internal class Raven.Server.Documents.Handlers.Processors.OngoingTasks.OngoingTasksHandlerProcessorForUpdatePeriodicBackup : AbstractOngoingTasksHandlerProcessorForUpdatePeriodicBackup`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OngoingTasksHandlerProcessorForUpdatePeriodicBackup(DatabaseRequestHandler requestHandler);
    protected virtual BackupConfiguration GetBackupConfiguration();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Queries.AbstractDatabaseOperationQueriesHandlerProcessor : AbstractOperationQueriesHandlerProcessor`2<QueriesHandler, DocumentsOperationContext> {
    protected QueryOperationContext QueryOperationContext;
    protected AbstractDatabaseNotificationCenter NotificationCenter { get; }
    protected RavenConfiguration Configuration { get; }
    protected AbstractDatabaseOperationQueriesHandlerProcessor(QueriesHandler requestHandler);
    protected virtual AbstractDatabaseNotificationCenter get_NotificationCenter();
    protected virtual RavenConfiguration get_Configuration();
    protected virtual long GetNextOperationId();
    protected virtual IDisposable AllocateContextForAsyncOperation(DocumentsOperationContext& asyncOperationContext);
    protected abstract virtual ValueTuple`2<QueryOperationFunction, OperationType> GetOperation(IndexQueryServerSide query);
    protected virtual void ScheduleOperation(DocumentsOperationContext asyncOperationContext, IDisposable returnAsyncOperationContext, IndexQueryServerSide query, long operationId, QueryOperationOptions options);
    private void ExecuteQueryOperation(IndexQueryServerSide query, long operationId, QueryOperationOptions options, QueryOperationFunction operation, IDisposable returnContextToPool, OperationType operationType);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Queries.AbstractOperationQueriesHandlerProcessor`2 : AbstractQueriesHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractOperationQueriesHandlerProcessor`2(TRequestHandler requestHandler, QueryMetadataCache queryMetadataCache);
    protected abstract virtual long GetNextOperationId();
    protected abstract virtual IDisposable AllocateContextForAsyncOperation(TOperationContext& asyncOperationContext);
    protected abstract virtual void ScheduleOperation(TOperationContext asyncOperationContext, IDisposable returnAsyncOperationContext, IndexQueryServerSide query, long operationId, QueryOperationOptions options);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.AbstractOperationQueriesHandlerProcessor`2/<ExecuteAsync>d__4")]
public virtual ValueTask ExecuteAsync();
    protected QueryOperationOptions GetQueryOperationOptions();
    protected static string GetOperationDescription(IndexQueryServerSide query);
    protected static OperationDetails GetDetailedDescription(IndexQueryServerSide query);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessor`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected QueryMetadataCache QueryMetadataCache;
    private int _start;
    private int _pageSize;
    private HttpContext _httpContext;
    private Stream _stream;
    protected HttpMethod QueryMethod { get; }
    protected AbstractDatabaseNotificationCenter NotificationCenter { get; }
    protected RavenConfiguration Configuration { get; }
    protected AbstractQueriesHandlerProcessor`2(TRequestHandler requestHandler, QueryMetadataCache queryMetadataCache);
    protected abstract virtual HttpMethod get_QueryMethod();
    protected abstract virtual AbstractDatabaseNotificationCenter get_NotificationCenter();
    protected abstract virtual RavenConfiguration get_Configuration();
    protected RequestTimeTracker CreateRequestTimeTracker();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessor`2/<GetIndexQueryAsync>d__13")]
public ValueTask`1<IndexQueryServerSide> GetIndexQueryAsync(JsonOperationContext context, HttpMethod method, RequestTimeTracker tracker, bool addSpatialProperties);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessor`2/<ReadIndexQueryAsync>d__14")]
private ValueTask`1<IndexQueryServerSide> ReadIndexQueryAsync(JsonOperationContext context, RequestTimeTracker tracker, bool addSpatialProperties);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessorForGet`4 : AbstractQueriesHandlerProcessor`2<TRequestHandler, TOperationContext> {
    [CompilerGeneratedAttribute]
private HttpMethod <QueryMethod>k__BackingField;
    protected HttpMethod QueryMethod { get; }
    protected AbstractQueriesHandlerProcessorForGet`4(TRequestHandler requestHandler, QueryMetadataCache queryMetadataCache, HttpMethod method);
    protected abstract virtual IDisposable AllocateContextForQueryOperation(TQueryContext& queryContext, TOperationContext& context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessorForGet`4/<HandleDebugAsync>d__2")]
private ValueTask HandleDebugAsync(IndexQueryServerSide query, TQueryContext queryContext, TOperationContext context, QueryStringParameters<TRequestHandler, TOperationContext, TQueryContext, TQueryResult> parameters, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    protected abstract virtual ValueTask`1<IndexEntriesQueryResult> GetIndexEntriesAsync(TQueryContext queryContext, TOperationContext context, IndexQueryServerSide query, Nullable`1<long> existingResultEtag, bool ignoreLimit, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessorForGet`4/<IndexEntriesAsync>d__4")]
private ValueTask IndexEntriesAsync(TQueryContext queryContext, TOperationContext context, IndexQueryServerSide query, Nullable`1<long> existingResultEtag, bool ignoreLimit, OperationCancelToken token);
    protected abstract virtual ValueTask ExplainAsync(TQueryContext queryContext, IndexQueryServerSide query, OperationCancelToken token);
    protected abstract virtual ValueTask`1<FacetedQueryResult> GetFacetedQueryResultAsync(IndexQueryServerSide query, TQueryContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    protected abstract virtual ValueTask`1<SuggestionQueryResult> GetSuggestionQueryResultAsync(IndexQueryServerSide query, TQueryContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    protected abstract virtual ValueTask`1<QueryResultServerSide`1<TQueryResult>> GetQueryResultsAsync(IndexQueryServerSide query, TQueryContext queryContext, Nullable`1<long> existingResultEtag, bool metadataOnly, OperationCancelToken token);
    [CompilerGeneratedAttribute]
protected virtual HttpMethod get_QueryMethod();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessorForGet`4/<ExecuteAsync>d__12")]
public virtual ValueTask ExecuteAsync();
    protected virtual void AssertIndexQuery(IndexQueryServerSide indexQuery);
    protected virtual void EnsureQueryContextInitialized(TQueryContext queryContext, IndexQueryServerSide indexQuery);
    private static Action`1<AbstractBlittableJsonTextWriter> WriteAdditionalData(IndexQueryServerSide indexQuery, bool shouldReturnServerSideQuery);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessorForGet`4/<ServerSideQueryAsync>d__16")]
private ValueTask ServerSideQueryAsync(TOperationContext context, IndexQueryServerSide indexQuery);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessorForGet`4/<HandleSuggestQueryAsync>d__17")]
private ValueTask HandleSuggestQueryAsync(IndexQueryServerSide query, TQueryContext queryContext, TOperationContext operationContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessorForGet`4/<HandleFacetedQueryAsync>d__18")]
private ValueTask HandleFacetedQueryAsync(IndexQueryServerSide query, TQueryContext queryContext, TOperationContext operationContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    private void AddQueryTimingsToTrafficWatch(IndexQueryServerSide indexQuery);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessorForPatchTest`2 : AbstractQueriesHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected HttpMethod QueryMethod { get; }
    protected AbstractQueriesHandlerProcessorForPatchTest`2(TRequestHandler requestHandler, QueryMetadataCache queryMetadataCache);
    protected virtual HttpMethod get_QueryMethod();
    protected abstract virtual ValueTask HandleDocumentPatchTestAsync(IndexQueryServerSide query, string docId, TOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.AbstractQueriesHandlerProcessorForPatchTest`2/<ExecuteAsync>d__4")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForDelete : AbstractDatabaseOperationQueriesHandlerProcessor {
    protected HttpMethod QueryMethod { get; }
    public DatabaseQueriesHandlerProcessorForDelete(QueriesHandler requestHandler);
    protected virtual HttpMethod get_QueryMethod();
    protected virtual ValueTuple`2<QueryOperationFunction, OperationType> GetOperation(IndexQueryServerSide query);
}
internal class Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForGet : AbstractQueriesHandlerProcessorForGet`4<QueriesHandler, DocumentsOperationContext, QueryOperationContext, Document> {
    protected AbstractDatabaseNotificationCenter NotificationCenter { get; }
    protected RavenConfiguration Configuration { get; }
    public DatabaseQueriesHandlerProcessorForGet(QueriesHandler requestHandler, HttpMethod method);
    protected virtual IDisposable AllocateContextForQueryOperation(QueryOperationContext& queryContext, DocumentsOperationContext& context);
    protected virtual AbstractDatabaseNotificationCenter get_NotificationCenter();
    protected virtual RavenConfiguration get_Configuration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForGet/<GetFacetedQueryResultAsync>d__6")]
protected virtual ValueTask`1<FacetedQueryResult> GetFacetedQueryResultAsync(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForGet/<GetSuggestionQueryResultAsync>d__7")]
protected virtual ValueTask`1<SuggestionQueryResult> GetSuggestionQueryResultAsync(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForGet/<GetQueryResultsAsync>d__8")]
protected virtual ValueTask`1<QueryResultServerSide`1<Document>> GetQueryResultsAsync(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, bool metadataOnly, OperationCancelToken token);
    protected virtual void EnsureQueryContextInitialized(QueryOperationContext queryContext, IndexQueryServerSide indexQuery);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForGet/<GetIndexEntriesAsync>d__10")]
protected virtual ValueTask`1<IndexEntriesQueryResult> GetIndexEntriesAsync(QueryOperationContext queryContext, DocumentsOperationContext context, IndexQueryServerSide query, Nullable`1<long> existingResultEtag, bool ignoreLimit, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForGet/<ExplainAsync>d__11")]
protected virtual ValueTask ExplainAsync(QueryOperationContext queryContext, IndexQueryServerSide query, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForPatch : AbstractDatabaseOperationQueriesHandlerProcessor {
    protected HttpMethod QueryMethod { get; }
    public DatabaseQueriesHandlerProcessorForPatch(QueriesHandler requestHandler);
    protected virtual HttpMethod get_QueryMethod();
    protected virtual ValueTuple`2<QueryOperationFunction, OperationType> GetOperation(IndexQueryServerSide query);
}
internal class Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForPatchTest : AbstractQueriesHandlerProcessorForPatchTest`2<QueriesHandler, DocumentsOperationContext> {
    protected AbstractDatabaseNotificationCenter NotificationCenter { get; }
    protected RavenConfiguration Configuration { get; }
    public DatabaseQueriesHandlerProcessorForPatchTest(QueriesHandler requestHandler);
    protected virtual AbstractDatabaseNotificationCenter get_NotificationCenter();
    protected virtual RavenConfiguration get_Configuration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForPatchTest/<HandleDocumentPatchTestAsync>d__5")]
protected virtual ValueTask HandleDocumentPatchTestAsync(IndexQueryServerSide query, string docId, DocumentsOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Queries.DatabaseQueriesHandlerProcessorForPatchTest/<WritePatchResultToResponseAsync>d__6")]
private ValueTask WritePatchResultToResponseAsync(DocumentsOperationContext context, PatchDocumentCommand command);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Rachis.AbstractRachisHandlerProcessorForWaitForIndexNotifications`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractRachisHandlerProcessorForWaitForIndexNotifications`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask WaitForCommandsAsync(TransactionOperationContext context, WaitForIndexNotificationRequest commands);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Rachis.AbstractRachisHandlerProcessorForWaitForIndexNotifications`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Rachis.RachisHandlerProcessorForWaitForIndexNotifications : AbstractRachisHandlerProcessorForWaitForIndexNotifications`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public RachisHandlerProcessorForWaitForIndexNotifications(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Rachis.RachisHandlerProcessorForWaitForIndexNotifications/<WaitForCommandsAsync>d__1")]
protected virtual ValueTask WaitForCommandsAsync(TransactionOperationContext _, WaitForIndexNotificationRequest commands);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Refresh.AbstractRefreshHandlerProcessorForGetRefreshConfiguration`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractRefreshHandlerProcessorForGetRefreshConfiguration`2(TRequestHandler requestHandler);
    protected abstract virtual RefreshConfiguration GetRefreshConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Refresh.AbstractRefreshHandlerProcessorForGetRefreshConfiguration`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Refresh.AbstractRefreshHandlerProcessorForPostRefreshConfiguration`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractRefreshHandlerProcessorForPostRefreshConfiguration`2(TRequestHandler requestHandler);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal class Raven.Server.Documents.Handlers.Processors.Refresh.RefreshHandlerProcessorForGetRefreshConfiguration : AbstractRefreshHandlerProcessorForGetRefreshConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public RefreshHandlerProcessorForGetRefreshConfiguration(DatabaseRequestHandler requestHandler);
    protected virtual RefreshConfiguration GetRefreshConfiguration();
}
internal class Raven.Server.Documents.Handlers.Processors.Refresh.RefreshHandlerProcessorForPostRefreshConfiguration : AbstractRefreshHandlerProcessorForPostRefreshConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public RefreshHandlerProcessorForPostRefreshConfiguration(DatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForDefineHub`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    private PullReplicationDefinition _pullReplication;
    private long _taskId;
    protected AbstractPullReplicationHandlerProcessorForDefineHub`2(TRequestHandler requestHandler);
    protected virtual void OnBeforeResponseWrite(TransactionOperationContext context, DynamicJsonValue responseJson, BlittableJsonReaderObject configuration, long index);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForGenerateCertificate`1 : AbstractHandlerProcessor`1<TRequestHandler> {
    protected AbstractPullReplicationHandlerProcessorForGenerateCertificate`1(TRequestHandler requestHandler);
    protected abstract virtual void AssertCanExecute();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForGenerateCertificate`1/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForGetListHubAccess`2 : AbstractHandlerProcessor`1<TRequestHandler> {
    protected AbstractPullReplicationHandlerProcessorForGetListHubAccess`2(TRequestHandler requestHandler, JsonContextPoolBase`1<TOperationContext> contextPool);
    protected abstract virtual void AssertCanExecute();
    protected abstract virtual string GetDatabaseName();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForGetListHubAccess`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForRegisterHubAccess`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    private string _hubTaskName;
    private PullReplicationDefinition _hubDefinition;
    protected AbstractPullReplicationHandlerProcessorForRegisterHubAccess`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForRegisterHubAccess`2/<GetConfigurationAsync>d__3")]
protected virtual ValueTask`1<BlittableJsonReaderObject> GetConfigurationAsync(TransactionOperationContext context, AsyncBlittableJsonTextWriter writer);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForRegisterHubAccess`2/<OnUpdateConfiguration>d__4")]
protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForUnregisterHubAccess`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractPullReplicationHandlerProcessorForUnregisterHubAccess`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForUnregisterHubAccess`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForUnregisterHubAccess`2/<OnUpdateConfiguration>d__2")]
protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractPullReplicationHandlerProcessorForUpdatePullReplicationOnSinkNode`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    private PullReplicationAsSink _pullReplication;
    private long _taskId;
    protected AbstractPullReplicationHandlerProcessorForUpdatePullReplicationOnSinkNode`2(TRequestHandler requestHandler);
    protected abstract virtual void FillResponsibleNode(TransactionOperationContext context, DynamicJsonValue responseJson, PullReplicationAsSink pullReplication);
    protected virtual void OnBeforeResponseWrite(TransactionOperationContext context, DynamicJsonValue responseJson, BlittableJsonReaderObject configuration, long index);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetActiveConnections`2 : AbstractHandlerProxyReadProcessor`3<ReplicationActiveConnectionsPreview, TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetActiveConnections`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<ReplicationActiveConnectionsPreview> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetConflicts`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetConflicts`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<GetConflictsPreviewResult> GetConflictsPreviewAsync(TOperationContext context, long start, int pageSize);
    protected abstract virtual Task GetConflictsForDocumentAsync(TOperationContext context, string documentId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetConflicts`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetConflicts`2/<WriteResultsAsync>d__4")]
protected ValueTask WriteResultsAsync(JsonOperationContext context, GetConflictsPreviewResult previewResult);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetConflictSolver`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetConflictSolver`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetConflictSolver`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetIncomingActivityTimes`2 : AbstractHandlerProxyReadProcessor`3<ReplicationIncomingLastActivityTimePreview, TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetIncomingActivityTimes`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<ReplicationIncomingLastActivityTimePreview> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetIncomingRejectionInfo`2 : AbstractHandlerProxyReadProcessor`3<ReplicationIncomingRejectionInfoPreview, TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetIncomingRejectionInfo`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<ReplicationIncomingRejectionInfoPreview> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetOutgoingFailureStats`2 : AbstractHandlerProxyReadProcessor`3<ReplicationOutgoingsFailurePreview, TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetOutgoingFailureStats`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<ReplicationOutgoingsFailurePreview> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetOutgoingReconnectionQueue`2 : AbstractHandlerProxyReadProcessor`3<ReplicationOutgoingReconnectionQueuePreview, TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetOutgoingReconnectionQueue`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<ReplicationOutgoingReconnectionQueuePreview> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetPerformance`2 : AbstractHandlerProxyReadProcessor`3<ReplicationPerformance, TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetPerformance`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<ReplicationPerformance> CreateCommandForNode(string nodeTag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetPerformance`2/<WriteResultsAsync>d__2")]
protected ValueTask WriteResultsAsync(JsonOperationContext context, IEnumerable`1<IAbstractIncomingReplicationHandler> incomingHandlers, IEnumerable`1<IReportOutgoingReplicationPerformance> outgoingReplicationReports);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetPerformanceLive`2 : AbstractHandlerWebSocketProxyProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetPerformanceLive`2(TRequestHandler requestHandler);
    protected virtual string GetRemoteEndpointUrl(string databaseName);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetPulsesLive`2 : AbstractHandlerWebSocketProxyProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetPulsesLive`2(TRequestHandler requestHandler);
    protected virtual string GetRemoteEndpointUrl(string databaseName);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetTombstones`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractReplicationHandlerProcessorForGetTombstones`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<GetTombstonesPreviewResult> GetTombstonesAsync(TOperationContext context, int start, int pageSize);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetTombstones`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.AbstractReplicationHandlerProcessorForGetTombstones`2/<WriteResultsAsync>d__3")]
protected ValueTask WriteResultsAsync(JsonOperationContext context, GetTombstonesPreviewResult previewResult, int pageSize);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ConflictsPreviewComparer : Comparer`1<ConflictPreview> {
    public static ConflictsPreviewComparer Instance;
    private static ConflictsPreviewComparer();
    public virtual int Compare(ConflictPreview x, ConflictPreview y);
}
public class Raven.Server.Documents.Handlers.Processors.Replication.GetTombstonesPreviewResult : object {
    [CompilerGeneratedAttribute]
private List`1<Tombstone> <Tombstones>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContinuationToken>k__BackingField;
    public List`1<Tombstone> Tombstones { get; public set; }
    public string ContinuationToken { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Tombstone> get_Tombstones();
    [CompilerGeneratedAttribute]
public void set_Tombstones(List`1<Tombstone> value);
    [CompilerGeneratedAttribute]
public string get_ContinuationToken();
    [CompilerGeneratedAttribute]
public void set_ContinuationToken(string value);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.PullReplicationHandlerProcessorForDefineHub : AbstractPullReplicationHandlerProcessorForDefineHub`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public PullReplicationHandlerProcessorForDefineHub(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask AssertCanExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.PullReplicationHandlerProcessorForGenerateCertificate : AbstractPullReplicationHandlerProcessorForGenerateCertificate`1<DatabaseRequestHandler> {
    public PullReplicationHandlerProcessorForGenerateCertificate(DatabaseRequestHandler requestHandler);
    protected virtual void AssertCanExecute();
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.PullReplicationHandlerProcessorForGetListHubAccess : AbstractPullReplicationHandlerProcessorForGetListHubAccess`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public PullReplicationHandlerProcessorForGetListHubAccess(DatabaseRequestHandler requestHandler);
    protected virtual void AssertCanExecute();
    protected virtual string GetDatabaseName();
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.PullReplicationHandlerProcessorForRegisterHubAccess : AbstractPullReplicationHandlerProcessorForRegisterHubAccess`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public PullReplicationHandlerProcessorForRegisterHubAccess(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask AssertCanExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.PullReplicationHandlerProcessorForUnregisterHubAccess : AbstractPullReplicationHandlerProcessorForUnregisterHubAccess`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public PullReplicationHandlerProcessorForUnregisterHubAccess(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask AssertCanExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.PullReplicationHandlerProcessorForUpdatePullReplicationOnSinkNode : AbstractPullReplicationHandlerProcessorForUpdatePullReplicationOnSinkNode`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public PullReplicationHandlerProcessorForUpdatePullReplicationOnSinkNode(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask AssertCanExecuteAsync();
    protected virtual void FillResponsibleNode(TransactionOperationContext context, DynamicJsonValue responseJson, PullReplicationAsSink pullReplication);
}
public class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationActiveConnectionsPreview : object {
    public List`1<IncomingConnectionInfo> IncomingConnections;
    public List`1<ReplicationNode> OutgoingConnections;
    public DynamicJsonValue ToJson();
    public sealed virtual void FillFromBlittableJson(BlittableJsonReaderObject json);
    private void FillIncomingConnections(BlittableJsonReaderObject json);
    private void FillOutgoingConnections(BlittableJsonReaderObject json);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetActiveConnections : AbstractReplicationHandlerProcessorForGetActiveConnections`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ReplicationHandlerProcessorForGetActiveConnections(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetActiveConnections/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationActiveConnectionsPreview> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetConflicts : AbstractReplicationHandlerProcessorForGetConflicts`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public ReplicationHandlerProcessorForGetConflicts(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<GetConflictsPreviewResult> GetConflictsPreviewAsync(DocumentsOperationContext context, long start, int pageSize);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetConflicts/<GetConflictsForDocumentAsync>d__2")]
protected virtual Task GetConflictsForDocumentAsync(DocumentsOperationContext context, string documentId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetConflicts/<WriteDocumentConflicts>d__3")]
private Task WriteDocumentConflicts(JsonOperationContext context, string documentId, IEnumerable`1<DocumentConflict> conflicts);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetConflictSolver : AbstractReplicationHandlerProcessorForGetConflictSolver`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public ReplicationHandlerProcessorForGetConflictSolver(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetIncomingActivityTimes : AbstractReplicationHandlerProcessorForGetIncomingActivityTimes`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ReplicationHandlerProcessorForGetIncomingActivityTimes(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetIncomingActivityTimes/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationIncomingLastActivityTimePreview> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetIncomingRejectionInfo : AbstractReplicationHandlerProcessorForGetIncomingRejectionInfo`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ReplicationHandlerProcessorForGetIncomingRejectionInfo(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetIncomingRejectionInfo/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationIncomingRejectionInfoPreview> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetOutgoingFailureStats : AbstractReplicationHandlerProcessorForGetOutgoingFailureStats`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ReplicationHandlerProcessorForGetOutgoingFailureStats(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetOutgoingFailureStats/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationOutgoingsFailurePreview> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetOutgoingReconnectionQueue : AbstractReplicationHandlerProcessorForGetOutgoingReconnectionQueue`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ReplicationHandlerProcessorForGetOutgoingReconnectionQueue(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetOutgoingReconnectionQueue/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationOutgoingReconnectionQueuePreview> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetPerformance : AbstractReplicationHandlerProcessorForGetPerformance`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ReplicationHandlerProcessorForGetPerformance(DatabaseRequestHandler requestHandler);
    private IEnumerable`1<IAbstractIncomingReplicationHandler> GetIncomingHandlers(DocumentsOperationContext context);
    private IEnumerable`1<IReportOutgoingReplicationPerformance> GetOutgoingReplicationReportsPerformance(DocumentsOperationContext context);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetPerformance/<HandleCurrentNodeAsync>d__5")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationPerformance> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetPerformanceLive : AbstractReplicationHandlerProcessorForGetPerformanceLive`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ReplicationHandlerProcessorForGetPerformanceLive(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetPerformanceLive/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetPulsesLive : AbstractReplicationHandlerProcessorForGetPulsesLive`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ReplicationHandlerProcessorForGetPulsesLive(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetPulsesLive/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetPulsesLive/<SendPulsesOrHeartbeatToWebSocket>d__4")]
private Task`1<bool> SendPulsesOrHeartbeatToWebSocket(Task`1<WebSocketReceiveResult> receive, WebSocket webSocket, LiveReplicationPulsesCollector collector, MemoryStream ms, int timeToWait);
}
internal class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationHandlerProcessorForGetTombstones : AbstractReplicationHandlerProcessorForGetTombstones`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public ReplicationHandlerProcessorForGetTombstones(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<GetTombstonesPreviewResult> GetTombstonesAsync(DocumentsOperationContext context, int start, int pageSize);
}
public class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationIncomingLastActivityTimePreview : object {
    public IDictionary`2<IncomingConnectionInfo, DateTime> Stats;
    public DynamicJsonValue ToJson();
    private DynamicJsonValue IncomingActivityTimeToJson(KeyValuePair`2<IncomingConnectionInfo, DateTime> kvp);
}
public class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationIncomingRejectionInfoPreview : object {
    public IDictionary`2<IncomingConnectionInfo, ConcurrentQueue`1<IncomingConnectionRejectionInfo>> Stats;
    public DynamicJsonValue ToJson();
    private DynamicJsonValue IncomingRejectionInfoToJson(KeyValuePair`2<IncomingConnectionInfo, ConcurrentQueue`1<IncomingConnectionRejectionInfo>> kvp);
}
public class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationOutgoingReconnectionQueuePreview : object {
    public List`1<ReplicationNode> QueueInfo;
    public DynamicJsonValue ToJson();
    public sealed virtual void FillFromBlittableJson(BlittableJsonReaderObject json);
}
public class Raven.Server.Documents.Handlers.Processors.Replication.ReplicationOutgoingsFailurePreview : object {
    public IDictionary`2<ReplicationNode, ConnectionShutdownInfo> Stats;
    public DynamicJsonValue ToJson();
    private DynamicJsonValue OutgoingFailureInfoToJson(KeyValuePair`2<ReplicationNode, ConnectionShutdownInfo> kvp);
    public sealed virtual void FillFromBlittableJson(BlittableJsonReaderObject json);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetResolvedRevisions`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractRevisionsHandlerProcessorForGetResolvedRevisions`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask GetResolvedRevisionsAndWriteAsync(TOperationContext context, DateTime since, int take, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetResolvedRevisions`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisions`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractRevisionsHandlerProcessorForGetRevisions`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask GetRevisionByChangeVectorAsync(TOperationContext context, StringValues changeVectors, bool metadataOnly, CancellationToken token);
    protected abstract virtual ValueTask GetRevisionsAsync(TOperationContext context, string id, Nullable`1<DateTime> before, int start, int pageSize, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisions`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
    protected bool NotModified(string actualEtag);
    protected void WriteRevisionsBlittable(JsonOperationContext context, IEnumerable`1<BlittableJsonReaderObject> documentsToWrite, Int64& numberOfResults, Int64& totalDocumentsSizeInBytes);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisionsBin`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractRevisionsHandlerProcessorForGetRevisionsBin`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask GetAndWriteRevisionsBinAsync(TOperationContext context, int start, int pageSize);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisionsBin`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisionsConfiguration`1 : AbstractHandlerProcessor`1<TRequestHandler> {
    protected AbstractRevisionsHandlerProcessorForGetRevisionsConfiguration`1(TRequestHandler requestHandler);
    protected abstract virtual RevisionsConfiguration GetRevisionsConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisionsConfiguration`1/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisionsConflictsConfiguration`1 : AbstractHandlerProcessor`1<TRequestHandler> {
    protected AbstractRevisionsHandlerProcessorForGetRevisionsConflictsConfiguration`1(TRequestHandler requestHandler);
    protected abstract virtual RevisionsCollectionConfiguration GetRevisionsConflicts();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisionsConflictsConfiguration`1/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisionsCount`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public AbstractRevisionsHandlerProcessorForGetRevisionsCount`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<DocumentRevisionsCount> GetRevisionsCountAsync(string docId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisionsCount`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForGetRevisionsDebug`2 : AbstractHandlerProxyReadProcessor`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractRevisionsHandlerProcessorForGetRevisionsDebug`2(TRequestHandler requestHandler);
    protected ValueTuple`2<long, int> GetParameters();
    protected virtual RavenCommand`1<BlittableJsonReaderObject> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForPostRevisionsConfiguration`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractRevisionsHandlerProcessorForPostRevisionsConfiguration`2(TRequestHandler requestHandler);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
    protected virtual void OnBeforeUpdateConfiguration(BlittableJsonReaderObject& configuration, JsonOperationContext context);
    protected virtual ValueTask OnAfterUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForRevertRevisions`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractRevisionsHandlerProcessorForRevertRevisions`2(TRequestHandler requestHandler);
    protected abstract virtual void ScheduleRevertRevisions(long operationId, RevertRevisionsRequest configuration, OperationCancelToken token);
    protected abstract virtual long GetNextOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForRevertRevisions`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForRevertRevisionsForDocument`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractRevisionsHandlerProcessorForRevertRevisionsForDocument`2(TRequestHandler requestHandler);
    protected abstract virtual Task RevertDocumentsAsync(Dictionary`2<string, string> idToChangeVector, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.AbstractRevisionsHandlerProcessorForRevertRevisionsForDocument`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetResolvedRevisions : AbstractRevisionsHandlerProcessorForGetResolvedRevisions`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public RevisionsHandlerProcessorForGetResolvedRevisions(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetResolvedRevisions/<GetResolvedRevisionsAndWriteAsync>d__1")]
protected virtual ValueTask GetResolvedRevisionsAndWriteAsync(DocumentsOperationContext context, DateTime since, int take, CancellationToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisions : AbstractRevisionsHandlerProcessorForGetRevisions`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public RevisionsHandlerProcessorForGetRevisions(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisions/<GetRevisionByChangeVectorAsync>d__1")]
protected virtual ValueTask GetRevisionByChangeVectorAsync(DocumentsOperationContext context, StringValues changeVectors, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisions/<GetRevisionsAsync>d__2")]
protected virtual ValueTask GetRevisionsAsync(DocumentsOperationContext context, string id, Nullable`1<DateTime> before, int start, int pageSize, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisions/<WriteRevisionsJsonAsync>d__3")]
private ValueTask`1<ValueTuple`2<long, long>> WriteRevisionsJsonAsync(JsonOperationContext context, bool metadataOnly, IEnumerable`1<Document> revisionsResult, CancellationToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisionsBin : AbstractRevisionsHandlerProcessorForGetRevisionsBin`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public RevisionsHandlerProcessorForGetRevisionsBin(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisionsBin/<GetAndWriteRevisionsBinAsync>d__1")]
protected virtual ValueTask GetAndWriteRevisionsBinAsync(DocumentsOperationContext context, int start, int pageSize);
}
internal class Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisionsConfiguration : AbstractRevisionsHandlerProcessorForGetRevisionsConfiguration`1<DatabaseRequestHandler> {
    public RevisionsHandlerProcessorForGetRevisionsConfiguration(DatabaseRequestHandler requestHandler);
    protected virtual RevisionsConfiguration GetRevisionsConfiguration();
}
internal class Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisionsConflictsConfiguration : AbstractRevisionsHandlerProcessorForGetRevisionsConflictsConfiguration`1<DatabaseRequestHandler> {
    public RevisionsHandlerProcessorForGetRevisionsConflictsConfiguration(DatabaseRequestHandler requestHandler);
    protected virtual RevisionsCollectionConfiguration GetRevisionsConflicts();
}
internal class Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisionsCount : AbstractRevisionsHandlerProcessorForGetRevisionsCount`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public RevisionsHandlerProcessorForGetRevisionsCount(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<DocumentRevisionsCount> GetRevisionsCountAsync(string docId);
}
internal class Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisionsDebug : AbstractRevisionsHandlerProcessorForGetRevisionsDebug`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public RevisionsHandlerProcessorForGetRevisionsDebug(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisionsDebug/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForGetRevisionsDebug/<HandleRemoteNodeAsync>d__4")]
protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<BlittableJsonReaderObject> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForPostRevisionsConfiguration : AbstractRevisionsHandlerProcessorForPostRevisionsConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public RevisionsHandlerProcessorForPostRevisionsConfiguration(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForRevertRevisions : AbstractRevisionsHandlerProcessorForRevertRevisions`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public RevisionsHandlerProcessorForRevertRevisions(DatabaseRequestHandler requestHandler);
    protected virtual void ScheduleRevertRevisions(long operationId, RevertRevisionsRequest configuration, OperationCancelToken token);
    protected virtual long GetNextOperationId();
}
internal class Raven.Server.Documents.Handlers.Processors.Revisions.RevisionsHandlerProcessorForRevertRevisionsForDocument : AbstractRevisionsHandlerProcessorForRevertRevisionsForDocument`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public RevisionsHandlerProcessorForRevertRevisionsForDocument(DatabaseRequestHandler requestHandler);
    protected virtual Task RevertDocumentsAsync(Dictionary`2<string, string> idToChangeVector, OperationCancelToken token);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.SampleData.AbstractSampleDataHandlerProcessorForGetSampleDataClasses`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSampleDataHandlerProcessorForGetSampleDataClasses`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.SampleData.AbstractSampleDataHandlerProcessorForGetSampleDataClasses`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.SampleData.AbstractSampleDataHandlerProcessorForPostSampleData`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSampleDataHandlerProcessorForPostSampleData`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask ExecuteSmugglerAsync(JsonOperationContext context, Stream sampleDataStream, DatabaseItemType operateOnTypes);
    protected abstract virtual ValueTask`1<bool> IsDatabaseEmptyAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.SampleData.AbstractSampleDataHandlerProcessorForPostSampleData`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
    [CompilerGeneratedAttribute]
internal static DatabaseItemType <ExecuteAsync>g__GetOperateOnTypes|3_0(StringValues operateOnTypesAsString);
}
internal class Raven.Server.Documents.Handlers.Processors.SampleData.SampleDataHandlerProcessorForGetSampleDataClasses : AbstractSampleDataHandlerProcessorForGetSampleDataClasses`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public SampleDataHandlerProcessorForGetSampleDataClasses(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.SampleData.SampleDataHandlerProcessorForPostSampleData : AbstractSampleDataHandlerProcessorForPostSampleData`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public SampleDataHandlerProcessorForPostSampleData(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.SampleData.SampleDataHandlerProcessorForPostSampleData/<ExecuteSmugglerAsync>d__1")]
protected virtual ValueTask ExecuteSmugglerAsync(JsonOperationContext context, Stream sampleDataStream, DatabaseItemType operateOnTypes);
    protected virtual ValueTask`1<bool> IsDatabaseEmptyAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessor`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSmugglerHandlerProcessor`2(TRequestHandler requestHandler);
    internal void ApplyBackwardCompatibility(DatabaseSmugglerOptionsServerSide options);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessor`2/<GetInputStreamAsync>d__2")]
internal static Task`1<Stream> GetInputStreamAsync(Stream fileStream, DatabaseSmugglerOptionsServerSide options);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessor`2/<GetOutputStreamAsync>d__3")]
internal static Task`1<Stream> GetOutputStreamAsync(Stream fileStream, DatabaseSmugglerOptionsServerSide options);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessor`2/<WriteSmugglerResultAsync>d__4")]
internal static ValueTask WriteSmugglerResultAsync(JsonOperationContext context, SmugglerResult result, Stream stream);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForExport`2 : AbstractSmugglerHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSmugglerHandlerProcessorForExport`2(TRequestHandler requestHandler);
    protected abstract virtual long GetNextOperationId();
    protected abstract virtual ValueTask`1<IOperationResult> ExportAsync(JsonOperationContext context, IDisposable returnToContextPool, long operationId, DatabaseSmugglerOptionsServerSide options, long startDocumentEtag, long startRaftIndex, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForExport`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForImport`2 : AbstractSmugglerHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSmugglerHandlerProcessorForImport`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask ImportAsync(JsonOperationContext context, Nullable`1<long> operationId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForImport`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForImport`2/<Import>d__3`1")]
internal Task Import(JsonOperationContext context, string databaseName, ImportDelegate onImport, AbstractOperations`1<TOperation> operations, long operationId);
    private void IgnoreDatabaseItemTypesIfCurrentVersionIsOlderThenClientVersion(JsonOperationContext context, BlittableJsonReaderObject& blittableJson);
    private void CheckClientVersion(string value, string propertyName);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForImportDir`2 : AbstractSmugglerHandlerProcessorForImport`2<TRequestHandler, TOperationContext> {
    protected ImportDelegate DoImport { get; }
    protected AbstractSmugglerHandlerProcessorForImportDir`2(TRequestHandler requestHandler);
    protected abstract virtual ImportDelegate get_DoImport();
    protected abstract virtual long GetOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForImportDir`2/<ImportAsync>d__4")]
protected virtual ValueTask ImportAsync(JsonOperationContext context, Nullable`1<long> operationId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForImportDir`2/<BulkImport>d__5")]
private Task BulkImport(BlockingCollection`1<Func`1<Task`1<Stream>>> files, string directory, long operationId);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForImportGet`2 : AbstractSmugglerHandlerProcessorForImport`2<TRequestHandler, TOperationContext> {
    protected ImportDelegate DoImport { get; }
    protected AbstractSmugglerHandlerProcessorForImportGet`2(TRequestHandler requestHandler);
    protected abstract virtual ImportDelegate get_DoImport();
    protected abstract virtual long GetOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForImportGet`2/<ImportAsync>d__4")]
protected virtual ValueTask ImportAsync(JsonOperationContext context, Nullable`1<long> operationId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.AbstractSmugglerHandlerProcessorForImportGet`2/<GetImportStream>d__5")]
private Task`1<Stream> GetImportStream();
}
public class Raven.Server.Documents.Handlers.Processors.Smuggler.ImportDelegate : MulticastDelegate {
    public ImportDelegate(object object, IntPtr method);
    public virtual Task`1<SmugglerResult> Invoke(JsonOperationContext context, Stream stream, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, long operationId, OperationCancelToken token);
    public virtual IAsyncResult BeginInvoke(JsonOperationContext context, Stream stream, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, long operationId, OperationCancelToken token, AsyncCallback callback, object object);
    public virtual Task`1<SmugglerResult> EndInvoke(IAsyncResult result);
}
internal class Raven.Server.Documents.Handlers.Processors.Smuggler.ShardedSmugglerHandlerProcessorForImportDir : AbstractSmugglerHandlerProcessorForImportDir`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected ImportDelegate DoImport { get; }
    public ShardedSmugglerHandlerProcessorForImportDir(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ImportDelegate get_DoImport();
    protected virtual long GetOperationId();
}
internal class Raven.Server.Documents.Handlers.Processors.Smuggler.ShardedSmugglerHandlerProcessorForImportGet : AbstractSmugglerHandlerProcessorForImportGet`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected ImportDelegate DoImport { get; }
    public ShardedSmugglerHandlerProcessorForImportGet(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ImportDelegate get_DoImport();
    protected virtual long GetOperationId();
}
internal class Raven.Server.Documents.Handlers.Processors.Smuggler.SmugglerHandlerProcessorForExport : AbstractSmugglerHandlerProcessorForExport`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public SmugglerHandlerProcessorForExport(DatabaseRequestHandler requestHandler);
    protected virtual long GetNextOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.SmugglerHandlerProcessorForExport/<ExportAsync>d__2")]
protected virtual ValueTask`1<IOperationResult> ExportAsync(JsonOperationContext context, IDisposable returnToContextPool, long operationId, DatabaseSmugglerOptionsServerSide options, long startDocumentEtag, long startRaftIndex, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.SmugglerHandlerProcessorForExport/<ExportDatabaseInternalAsync>d__3")]
private Task`1<IOperationResult> ExportDatabaseInternalAsync(DatabaseSmugglerOptionsServerSide options, long startDocumentEtag, long startRaftIndex, Action`1<IOperationProgress> onProgress, JsonOperationContext jsonOperationContext, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Smuggler.SmugglerHandlerProcessorForImport : AbstractSmugglerHandlerProcessorForImport`2<SmugglerHandler, DocumentsOperationContext> {
    public SmugglerHandlerProcessorForImport(SmugglerHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.SmugglerHandlerProcessorForImport/<ImportAsync>d__1")]
protected virtual ValueTask ImportAsync(JsonOperationContext context, Nullable`1<long> operationId);
}
internal class Raven.Server.Documents.Handlers.Processors.Smuggler.SmugglerHandlerProcessorForImportDir : AbstractSmugglerHandlerProcessorForImportDir`2<SmugglerHandler, DocumentsOperationContext> {
    protected ImportDelegate DoImport { get; }
    public SmugglerHandlerProcessorForImportDir(SmugglerHandler requestHandler);
    protected virtual ImportDelegate get_DoImport();
    protected virtual long GetOperationId();
}
internal class Raven.Server.Documents.Handlers.Processors.Smuggler.SmugglerHandlerProcessorForImportGet : AbstractSmugglerHandlerProcessorForImportGet`2<SmugglerHandler, DocumentsOperationContext> {
    protected ImportDelegate DoImport { get; }
    public SmugglerHandlerProcessorForImportGet(SmugglerHandler requestHandler);
    protected virtual ImportDelegate get_DoImport();
    protected virtual long GetOperationId();
}
internal class Raven.Server.Documents.Handlers.Processors.Smuggler.SmugglerHandlerProcessorForValidateOptions`1 : AbstractDatabaseHandlerProcessor`1<TOperationContext> {
    internal SmugglerHandlerProcessorForValidateOptions`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Smuggler.SmugglerHandlerProcessorForValidateOptions`1/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Sorters.AbstractSortersHandlerProcessorForGet`1 : AbstractDatabaseHandlerProcessor`1<TOperationContext> {
    protected AbstractSortersHandlerProcessorForGet`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Sorters.AbstractSortersHandlerProcessorForGet`1/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Sorters.SortersHandlerProcessorForGet : AbstractSortersHandlerProcessorForGet`1<DocumentsOperationContext> {
    public SortersHandlerProcessorForGet(DatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForDatabaseHealthCheck`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractStatsHandlerProcessorForDatabaseHealthCheck`2(TRequestHandler requestHandler);
    protected abstract virtual Task GetNoContentStatusAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForDatabaseHealthCheck`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForEssentialStats`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractStatsHandlerProcessorForEssentialStats`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<EssentialDatabaseStatistics> GetEssentialDatabaseStatisticsAsync(TOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForEssentialStats`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForGetDatabaseStatistics`2 : AbstractHandlerProxyReadProcessor`3<DatabaseStatistics, TRequestHandler, TOperationContext> {
    protected AbstractStatsHandlerProcessorForGetDatabaseStatistics`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<DatabaseStatistics> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForGetDetailedDatabaseStatistics`2 : AbstractHandlerProxyReadProcessor`3<DetailedDatabaseStatistics, TRequestHandler, TOperationContext> {
    protected AbstractStatsHandlerProcessorForGetDetailedDatabaseStatistics`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<DetailedDatabaseStatistics> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForGetMetrics`2 : AbstractHandlerProxyReadProcessor`3<object, TRequestHandler, TOperationContext> {
    protected AbstractStatsHandlerProcessorForGetMetrics`2(TRequestHandler requestHandler);
    [PreserveBaseOverridesAttribute]
protected virtual override RavenCommand CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForGetMetricsBytes`2 : AbstractHandlerProxyReadProcessor`3<object, TRequestHandler, TOperationContext> {
    protected AbstractStatsHandlerProcessorForGetMetricsBytes`2(TRequestHandler requestHandler);
    [PreserveBaseOverridesAttribute]
protected virtual override RavenCommand CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForGetMetricsPuts`2 : AbstractHandlerProxyReadProcessor`3<object, TRequestHandler, TOperationContext> {
    protected AbstractStatsHandlerProcessorForGetMetricsPuts`2(TRequestHandler requestHandler);
    [PreserveBaseOverridesAttribute]
protected virtual override RavenCommand CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForPostValidateUnusedIds`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractStatsHandlerProcessorForPostValidateUnusedIds`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Stats.AbstractStatsHandlerProcessorForPostValidateUnusedIds`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    protected abstract virtual Task ValidateUnusedIdsOnAllNodesAsync(HashSet`1<string> unusedIds, string databaseName, CancellationToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForDatabaseHealthCheck : AbstractStatsHandlerProcessorForDatabaseHealthCheck`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StatsHandlerProcessorForDatabaseHealthCheck(DatabaseRequestHandler requestHandler);
    protected virtual Task GetNoContentStatusAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForEssentialStats : AbstractStatsHandlerProcessorForEssentialStats`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StatsHandlerProcessorForEssentialStats(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<EssentialDatabaseStatistics> GetEssentialDatabaseStatisticsAsync(DocumentsOperationContext context);
    internal static void FillBasicDatabaseStatistics(EssentialDatabaseStatistics stats, DocumentsOperationContext context, DocumentDatabase database);
}
internal class Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForGetDatabaseStatistics : AbstractStatsHandlerProcessorForGetDatabaseStatistics`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public StatsHandlerProcessorForGetDatabaseStatistics(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<DatabaseStatistics> command, OperationCancelToken token);
    internal static void FillDatabaseStatistics(DatabaseStatistics stats, QueryOperationContext context, DocumentDatabase database);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForGetDatabaseStatistics/<WriteResultAsync>d__6")]
private ValueTask WriteResultAsync(DatabaseStatistics result);
}
internal class Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForGetDetailedDatabaseStatistics : AbstractStatsHandlerProcessorForGetDetailedDatabaseStatistics`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public StatsHandlerProcessorForGetDetailedDatabaseStatistics(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<DetailedDatabaseStatistics> command, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForGetDetailedDatabaseStatistics/<WriteResultAsync>d__5")]
private ValueTask WriteResultAsync(DetailedDatabaseStatistics result);
}
internal class Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForGetMetrics : AbstractStatsHandlerProcessorForGetMetrics`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public StatsHandlerProcessorForGetMetrics(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForGetMetrics/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForGetMetricsBytes : AbstractStatsHandlerProcessorForGetMetricsBytes`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public StatsHandlerProcessorForGetMetricsBytes(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForGetMetricsBytes/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForGetMetricsPuts : AbstractStatsHandlerProcessorForGetMetricsPuts`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public StatsHandlerProcessorForGetMetricsPuts(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForGetMetricsPuts/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForPostValidateUnusedIds : AbstractStatsHandlerProcessorForPostValidateUnusedIds`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StatsHandlerProcessorForPostValidateUnusedIds(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Stats.StatsHandlerProcessorForPostValidateUnusedIds/<ValidateUnusedIdsOnAllNodesAsync>d__1")]
protected virtual Task ValidateUnusedIdsOnAllNodesAsync(HashSet`1<string> unusedIds, string databaseName, CancellationToken token);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Streaming.AbstractStreamingHandlerProcessorForGetDocs`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractStreamingHandlerProcessorForGetDocs`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask GetDocumentsAndWriteAsync(TOperationContext context, int start, int pageSize, string startsWith, string excludes, string matches, string startAfter, string format, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Streaming.AbstractStreamingHandlerProcessorForGetDocs`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Streaming.AbstractStreamingHandlerProcessorForGetStreamQuery`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected HttpMethod _method;
    protected AbstractStreamingHandlerProcessorForGetStreamQuery`2(TRequestHandler requestHandler, HttpMethod method);
    protected abstract virtual RequestTimeTracker GetTimeTracker();
    protected abstract virtual ValueTask`1<BlittableJsonReaderObject> GetDocumentDataAsync(TOperationContext context, string fromDocument);
    protected abstract virtual IDisposable AllocateContext(TOperationContext& context);
    protected abstract virtual QueryMetadataCache GetQueryMetadataCache();
    protected abstract virtual IStreamQueryResultWriter`1<BlittableJsonReaderObject> GetBlittableQueryResultWriter(string format, bool isDebug, JsonOperationContext context, HttpResponse response, Stream responseBodyStream, bool fromSharded, String[] propertiesArray, string fileNamePrefix);
    protected abstract virtual ValueTask ExecuteAndWriteQueryStreamAsync(TOperationContext context, IndexQueryServerSide query, string format, String[] propertiesArray, string fileNamePrefix, bool ignoreLimit, bool fromSharded, OperationCancelToken token);
    protected abstract virtual ValueTask ExecuteAndWriteIndexQueryStreamEntriesAsync(TOperationContext context, IndexQueryServerSide query, string format, string debug, String[] propertiesArray, string fileNamePrefix, bool ignoreLimit, bool fromSharded, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Streaming.AbstractStreamingHandlerProcessorForGetStreamQuery`2/<ExecuteAsync>d__9")]
public virtual ValueTask ExecuteAsync();
    protected static QueryResultFormat<TRequestHandler, TOperationContext> GetQueryResultFormat(string format);
    [DoesNotReturnAttribute]
protected void ThrowUnsupportedException(string message);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Streaming.AbstractStreamingHandlerProcessorForGetTimeSeries`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractStreamingHandlerProcessorForGetTimeSeries`2(TRequestHandler requestHandler);
    protected abstract virtual IDisposable OpenReadTransaction(TOperationContext context);
    protected abstract virtual ValueTask GetAndWriteTimeSeriesAsync(TOperationContext context, string docId, string name, DateTime from, DateTime to, Nullable`1<TimeSpan> offset, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Streaming.AbstractStreamingHandlerProcessorForGetTimeSeries`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Streaming.StreamingHandlerProcessorForGetDocs : AbstractStreamingHandlerProcessorForGetDocs`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StreamingHandlerProcessorForGetDocs(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Streaming.StreamingHandlerProcessorForGetDocs/<GetDocumentsAndWriteAsync>d__1")]
protected virtual ValueTask GetDocumentsAndWriteAsync(DocumentsOperationContext context, int start, int pageSize, string startsWith, string excludes, string matches, string startAfter, string format, OperationCancelToken token);
    private IStreamResultsWriter`1<Document> GetLoadDocumentsResultsWriter(string format, JsonOperationContext context, Stream responseBodyStream, CancellationToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Streaming.StreamingHandlerProcessorForGetStreamQuery : AbstractStreamingHandlerProcessorForGetStreamQuery`2<DatabaseRequestHandler, DocumentsOperationContext> {
    private QueryOperationContext _queryContext;
    public StreamingHandlerProcessorForGetStreamQuery(DatabaseRequestHandler requestHandler, HttpMethod method);
    protected virtual RequestTimeTracker GetTimeTracker();
    protected virtual ValueTask`1<BlittableJsonReaderObject> GetDocumentDataAsync(DocumentsOperationContext context, string fromDocument);
    protected virtual IDisposable AllocateContext(DocumentsOperationContext& context);
    protected virtual QueryMetadataCache GetQueryMetadataCache();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Streaming.StreamingHandlerProcessorForGetStreamQuery/<ExecuteAndWriteIndexQueryStreamEntriesAsync>d__6")]
protected virtual ValueTask ExecuteAndWriteIndexQueryStreamEntriesAsync(DocumentsOperationContext context, IndexQueryServerSide query, string format, string _, String[] propertiesArray, string fileNamePrefix, bool ignoreLimit, bool fromSharded, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Streaming.StreamingHandlerProcessorForGetStreamQuery/<ExecuteAndWriteQueryStreamAsync>d__7")]
protected virtual ValueTask ExecuteAndWriteQueryStreamAsync(DocumentsOperationContext context, IndexQueryServerSide query, string format, String[] propertiesArray, string fileNamePrefix, bool _, bool fromSharded, OperationCancelToken token);
    private IStreamQueryResultWriter`1<Document> GetDocumentQueryResultWriter(string format, HttpResponse response, JsonOperationContext context, Stream responseBodyStream, String[] propertiesArray, string fileNamePrefix);
    protected virtual IStreamQueryResultWriter`1<BlittableJsonReaderObject> GetBlittableQueryResultWriter(string format, bool isDebug, JsonOperationContext context, HttpResponse response, Stream responseBodyStream, bool fromSharded, String[] propertiesArray, string fileNamePrefix);
}
internal class Raven.Server.Documents.Handlers.Processors.Streaming.StreamingHandlerProcessorForGetTimeSeries : AbstractStreamingHandlerProcessorForGetTimeSeries`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StreamingHandlerProcessorForGetTimeSeries(DatabaseRequestHandler requestHandler);
    protected virtual IDisposable OpenReadTransaction(DocumentsOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Streaming.StreamingHandlerProcessorForGetTimeSeries/<GetAndWriteTimeSeriesAsync>d__2")]
protected virtual ValueTask GetAndWriteTimeSeriesAsync(DocumentsOperationContext context, string docId, string name, DateTime from, DateTime to, Nullable`1<TimeSpan> offset, CancellationToken token);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Studio.AbstractStudioCollectionFieldsHandlerProcessorForGetCollectionFields`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected static int MaxArrayItemsToFetch;
    protected AbstractStudioCollectionFieldsHandlerProcessorForGetCollectionFields`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<Dictionary`2<LazyStringValue, FieldType>> GetFieldsAsync(TOperationContext context, string collection, string prefix);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Studio.AbstractStudioCollectionFieldsHandlerProcessorForGetCollectionFields`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
    protected abstract virtual DocumentsTransaction OpenReadTransaction(TOperationContext context);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Studio.AbstractStudioCollectionHandlerProcessorForDeleteCollection`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractStudioCollectionHandlerProcessorForDeleteCollection`2(TRequestHandler requestHandler);
    protected abstract virtual void ScheduleDeleteCollection(TOperationContext context, IDisposable returnToContextPool, string collectionName, HashSet`1<string> excludeIds, long operationId);
    protected abstract virtual long GetNextOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Studio.AbstractStudioCollectionHandlerProcessorForDeleteCollection`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Studio.AbstractStudioStatsHandlerProcessorForGetFooterStats`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractStudioStatsHandlerProcessorForGetFooterStats`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<FooterStatistics> GetFooterStatisticsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Studio.AbstractStudioStatsHandlerProcessorForGetFooterStats`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
[FlagsAttribute]
public enum Raven.Server.Documents.Handlers.Processors.Studio.FieldType : Enum {
    public int value__;
    public static FieldType None;
    public static FieldType Object;
    public static FieldType Array;
    public static FieldType String;
    public static FieldType Number;
    public static FieldType Boolean;
    public static FieldType Null;
    public static FieldType ArrayObject;
    public static FieldType ArrayArray;
    public static FieldType ArrayString;
    public static FieldType ArrayNumber;
    public static FieldType ArrayBoolean;
}
internal class Raven.Server.Documents.Handlers.Processors.Studio.StudioCollectionFieldsHandlerProcessorForGetCollectionFields : AbstractStudioCollectionFieldsHandlerProcessorForGetCollectionFields`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StudioCollectionFieldsHandlerProcessorForGetCollectionFields(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<Dictionary`2<LazyStringValue, FieldType>> GetFieldsAsync(DocumentsOperationContext context, string collection, string prefix);
    protected virtual DocumentsTransaction OpenReadTransaction(DocumentsOperationContext context);
    private void FetchFieldsForCollection(DocumentsOperationContext context, string collection, string prefix, Dictionary`2<LazyStringValue, FieldType> fields);
    private void FetchFields(BlittableJsonReaderObject data, Dictionary`2<LazyStringValue, FieldType> fields);
    private FieldType GetFieldType(BlittableJsonToken token, object value);
}
internal class Raven.Server.Documents.Handlers.Processors.Studio.StudioCollectionHandlerProcessorForDeleteCollection : AbstractStudioCollectionHandlerProcessorForDeleteCollection`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StudioCollectionHandlerProcessorForDeleteCollection(DatabaseRequestHandler requestHandler);
    protected virtual void ScheduleDeleteCollection(DocumentsOperationContext context, IDisposable returnToContextPool, string collectionName, HashSet`1<string> excludeIds, long operationId);
    protected virtual long GetNextOperationId();
    private void ExecuteCollectionOperation(Func`6<CollectionRunner, string, CollectionOperationOptions, Action`1<IOperationProgress>, OperationCancelToken, Task`1<IOperationResult>> operation, DocumentsOperationContext docsContext, IDisposable returnToContextPool, OperationType operationType, string collectionName, long operationId, HashSet`1<string> excludeIds);
}
internal class Raven.Server.Documents.Handlers.Processors.Studio.StudioIndexHandlerProcessorForGetIndexErrorsCount : AbstractStudioIndexHandlerProcessorForGetIndexErrorsCount`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public StudioIndexHandlerProcessorForGetIndexErrorsCount(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexErrorsCount[]> command, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Studio.StudioIndexHandlerProcessorForGetIndexErrorsCount/<WriteResultAsync>d__5")]
private ValueTask WriteResultAsync(IndexErrorsCount[] result);
}
internal class Raven.Server.Documents.Handlers.Processors.Studio.StudioStatsHandlerProcessorForGetFooterStats : AbstractStudioStatsHandlerProcessorForGetFooterStats`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StudioStatsHandlerProcessorForGetFooterStats(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<FooterStatistics> GetFooterStatisticsAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Studio.StudioStatsHandlerProcessorForGetLicenseLimitsUsage`1 : AbstractDatabaseHandlerProcessor`2<AbstractDatabaseRequestHandler`1<TOperationContext>, TOperationContext> {
    public StudioStatsHandlerProcessorForGetLicenseLimitsUsage`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Studio.StudioStatsHandlerProcessorForGetLicenseLimitsUsage`1/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionHandlerProcessorForDeleteSubscription`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public AbstractSubscriptionHandlerProcessorForDeleteSubscription`2(TRequestHandler requestHandler);
    public abstract virtual void RaiseNotificationForTaskRemoved(string subscriptionName);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionHandlerProcessorForDeleteSubscription`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForDropSubscriptionConnection`3 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSubscriptionStorage`1<TSubscriptionState> SubscriptionStorage;
    protected bool SupportsCurrentNode { get; }
    private Nullable`1<long> SubscriptionId { get; }
    private string SubscriptionName { get; }
    private string WorkerId { get; }
    protected AbstractSubscriptionsHandlerProcessorForDropSubscriptionConnection`3(TRequestHandler requestHandler, AbstractSubscriptionStorage`1<TSubscriptionState> subscriptionStorage);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForDropSubscriptionConnection`3/<DropSubscriptionAsync>d__2")]
private ValueTask DropSubscriptionAsync(Nullable`1<long> subscriptionId, string subscriptionName, string workerId);
    private bool DropSingleSubscriptionConnection(SubscriptionState subscription, string workerId);
    protected virtual RavenCommand`1<object> CreateCommandForNode(string nodeTag);
    protected virtual bool get_SupportsCurrentNode();
    private Nullable`1<long> get_SubscriptionId();
    private string get_SubscriptionName();
    private string get_WorkerId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForDropSubscriptionConnection`3/<HandleCurrentNodeAsync>d__13")]
protected virtual ValueTask HandleCurrentNodeAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForGetConnectionDetails`2 : AbstractHandlerProxyReadProcessor`3<SubscriptionConnectionsDetails, TRequestHandler, TOperationContext> {
    protected bool SupportsCurrentNode { get; }
    protected AbstractSubscriptionsHandlerProcessorForGetConnectionDetails`2(TRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected abstract virtual SubscriptionConnectionsDetails GetConnectionDetails(ClusterOperationContext context, string subscriptionName);
    protected string GetName();
    protected virtual RavenCommand`1<SubscriptionConnectionsDetails> CreateCommandForNode(string nodeTag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForGetConnectionDetails`2/<HandleCurrentNodeAsync>d__6")]
protected virtual ValueTask HandleCurrentNodeAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForGetResend`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSubscriptionStorage`1<TSubscriptionState> SubscriptionStorage;
    protected AbstractSubscriptionsHandlerProcessorForGetResend`3(TRequestHandler requestHandler, AbstractSubscriptionStorage`1<TSubscriptionState> subscriptionStorage);
    protected abstract virtual HashSet`1<long> GetActiveBatches(ClusterOperationContext context, SubscriptionState subscriptionState);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForGetResend`3/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForGetResend`3/<WriteSubscriptionBatchesStateAsync>d__4")]
protected Task WriteSubscriptionBatchesStateAsync(JsonOperationContext context, IEnumerable`1<ResendItem> resendItems, HashSet`1<long> activeBatches);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForGetSubscription`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSubscriptionsHandlerProcessorForGetSubscription`3(TRequestHandler requestHandler);
    protected abstract virtual IEnumerable`1<TState> GetAllSubscriptions(ClusterOperationContext context, int start, int pageSize, bool history, bool running);
    protected abstract virtual TState GetSubscriptionByName(ClusterOperationContext context, bool history, bool running, string name);
    protected abstract virtual TState GetSubscriptionById(ClusterOperationContext context, bool history, bool running, long id);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForGetSubscription`3/<ExecuteAsync>d__4")]
public virtual ValueTask ExecuteAsync();
    private IEnumerable`1<TState> GetSubscriptions(ClusterOperationContext context, int start, int pageSize, bool history, bool running, Nullable`1<long> id, string name);
    internal void WriteGetAllResult(AsyncBlittableJsonTextWriterForDebug writer, IEnumerable`1<TState> subscriptions, ClusterOperationContext context);
    protected virtual DynamicJsonValue SubscriptionStateAsJson(TState state);
    protected static DynamicJsonValue GetSubscriptionConnectionJson(SubscriptionConnectionBase`1<T> x);
    private static DynamicJsonValue GetConnectionStatsJson(SubscriptionStatsCollector x);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForGetSubscriptionState`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSubscriptionStorage`1<TSubscriptionState> SubscriptionStorage;
    protected AbstractSubscriptionsHandlerProcessorForGetSubscriptionState`3(TRequestHandler requestHandler, AbstractSubscriptionStorage`1<TSubscriptionState> subscriptionStorage);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForGetSubscriptionState`3/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForPerformanceLive`2 : AbstractHandlerWebSocketProxyProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSubscriptionsHandlerProcessorForPerformanceLive`2(TRequestHandler requestHandler);
    protected virtual string GetRemoteEndpointUrl(string databaseName);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForPostSubscription`3 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSubscriptionStorage`1<TSubscriptionState> SubscriptionStorage;
    protected AbstractSubscriptionsHandlerProcessorForPostSubscription`3(TRequestHandler requestHandler, AbstractSubscriptionStorage`1<TSubscriptionState> subscriptionStorage);
    public virtual ParsedSubscription ParseSubscriptionQuery(string query);
    protected abstract virtual ValueTask CreateSubscriptionInternalAsync(BlittableJsonReaderObject bjro, Nullable`1<long> id, Nullable`1<bool> disabled, SubscriptionCreationOptions options, ClusterOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForPostSubscription`3/<ExecuteAsync>d__4")]
public virtual ValueTask ExecuteAsync();
    protected abstract virtual void SetSubscriptionChangeVectorOnUpdate(SubscriptionUpdateOptions options, SubscriptionState state);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForPutSubscription`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public AbstractSubscriptionsHandlerProcessorForPutSubscription`2(TRequestHandler requestHandler);
    public virtual ParsedSubscription ParseSubscriptionQuery(string query);
    protected abstract virtual ValueTask CreateInternalAsync(BlittableJsonReaderObject bjro, SubscriptionCreationOptions options, TOperationContext context, Nullable`1<long> id, Nullable`1<bool> disabled);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForPutSubscription`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForTrySubscription`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractSubscriptionsHandlerProcessorForTrySubscription`2(TRequestHandler requestHandler);
    public virtual ParsedSubscription ParseSubscriptionQuery(string query);
    protected abstract virtual ValueTask TryoutSubscriptionAsync(TOperationContext context, ParsedSubscription subscription, SubscriptionTryout tryout, int pageSize);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.AbstractSubscriptionsHandlerProcessorForTrySubscription`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
public class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionBatchesState : object {
    public HashSet`1<long> Active;
    public List`1<ResendItem> Results;
}
internal class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionHandlerProcessorForDeleteSubscription : AbstractSubscriptionHandlerProcessorForDeleteSubscription`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public SubscriptionHandlerProcessorForDeleteSubscription(DatabaseRequestHandler requestHandler);
    public virtual void RaiseNotificationForTaskRemoved(string subscriptionName);
}
internal class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForDropSubscriptionConnection : AbstractSubscriptionsHandlerProcessorForDropSubscriptionConnection`3<DatabaseRequestHandler, DocumentsOperationContext, SubscriptionConnectionsState> {
    public SubscriptionsHandlerProcessorForDropSubscriptionConnection(DatabaseRequestHandler requestHandler);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForGetConnectionDetails : AbstractSubscriptionsHandlerProcessorForGetConnectionDetails`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public SubscriptionsHandlerProcessorForGetConnectionDetails(DatabaseRequestHandler requestHandler);
    protected virtual SubscriptionConnectionsDetails GetConnectionDetails(ClusterOperationContext context, string subscriptionName);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<SubscriptionConnectionsDetails> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForGetResend : AbstractSubscriptionsHandlerProcessorForGetResend`3<DatabaseRequestHandler, DocumentsOperationContext, SubscriptionConnectionsState> {
    public SubscriptionsHandlerProcessorForGetResend(DatabaseRequestHandler requestHandler);
    protected virtual HashSet`1<long> GetActiveBatches(ClusterOperationContext context, SubscriptionState subscriptionState);
}
internal class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForGetSubscription : AbstractSubscriptionsHandlerProcessorForGetSubscription`3<DatabaseRequestHandler, DocumentsOperationContext, SubscriptionGeneralDataAndStats> {
    public SubscriptionsHandlerProcessorForGetSubscription(DatabaseRequestHandler requestHandler);
    protected virtual IEnumerable`1<SubscriptionGeneralDataAndStats> GetAllSubscriptions(ClusterOperationContext context, int start, int pageSize, bool history, bool running);
    protected virtual SubscriptionGeneralDataAndStats GetSubscriptionByName(ClusterOperationContext context, bool history, bool running, string name);
    protected virtual SubscriptionGeneralDataAndStats GetSubscriptionById(ClusterOperationContext context, bool history, bool running, long id);
    protected virtual DynamicJsonValue SubscriptionStateAsJson(SubscriptionGeneralDataAndStats state);
    private static DynamicJsonArray GetSubscriptionConnectionsJson(List`1<SubscriptionConnection> subscriptionList);
}
internal class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForGetSubscriptionState : AbstractSubscriptionsHandlerProcessorForGetSubscriptionState`3<DatabaseRequestHandler, DocumentsOperationContext, SubscriptionConnectionsState> {
    public SubscriptionsHandlerProcessorForGetSubscriptionState(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForPerformanceLive : AbstractSubscriptionsHandlerProcessorForPerformanceLive`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public SubscriptionsHandlerProcessorForPerformanceLive(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForPerformanceLive/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForPostSubscription : AbstractSubscriptionsHandlerProcessorForPostSubscription`3<SubscriptionsHandler, DocumentsOperationContext, SubscriptionConnectionsState> {
    public SubscriptionsHandlerProcessorForPostSubscription(SubscriptionsHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForPostSubscription/<CreateSubscriptionInternalAsync>d__1")]
protected virtual ValueTask CreateSubscriptionInternalAsync(BlittableJsonReaderObject bjro, Nullable`1<long> id, Nullable`1<bool> disabled, SubscriptionCreationOptions options, ClusterOperationContext _);
    protected virtual void SetSubscriptionChangeVectorOnUpdate(SubscriptionUpdateOptions options, SubscriptionState state);
}
internal class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForPutSubscription : AbstractSubscriptionsHandlerProcessorForPutSubscription`2<SubscriptionsHandler, DocumentsOperationContext> {
    public SubscriptionsHandlerProcessorForPutSubscription(SubscriptionsHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForPutSubscription/<CreateInternalAsync>d__1")]
protected virtual ValueTask CreateInternalAsync(BlittableJsonReaderObject bjro, SubscriptionCreationOptions options, DocumentsOperationContext context, Nullable`1<long> id, Nullable`1<bool> disabled);
}
internal class Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForTrySubscription : AbstractSubscriptionsHandlerProcessorForTrySubscription`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public SubscriptionsHandlerProcessorForTrySubscription(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Subscriptions.SubscriptionsHandlerProcessorForTrySubscription/<TryoutSubscriptionAsync>d__1")]
protected virtual ValueTask TryoutSubscriptionAsync(DocumentsOperationContext context, ParsedSubscription subscription, SubscriptionTryout tryout, int pageSize);
    [CompilerGeneratedAttribute]
private bool <TryoutSubscriptionAsync>b__1_0(ChangeVectorEntry x);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Tcp.AbstractTcpManagementHandlerProcessorForDelete`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractTcpManagementHandlerProcessorForDelete`2(TRequestHandler requestHandler);
    protected abstract virtual ConcurrentSet`1<TcpConnectionOptions> GetRunningTcpConnections();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Tcp.AbstractTcpManagementHandlerProcessorForDelete`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.Tcp.AbstractTcpManagementHandlerProcessorForGetAll`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractTcpManagementHandlerProcessorForGetAll`2(TRequestHandler requestHandler);
    protected abstract virtual ConcurrentSet`1<TcpConnectionOptions> GetRunningTcpConnections();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.Tcp.AbstractTcpManagementHandlerProcessorForGetAll`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.Tcp.TcpManagementHandlerProcessorForDelete : AbstractTcpManagementHandlerProcessorForDelete`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public TcpManagementHandlerProcessorForDelete(DatabaseRequestHandler requestHandler);
    protected virtual ConcurrentSet`1<TcpConnectionOptions> GetRunningTcpConnections();
}
internal class Raven.Server.Documents.Handlers.Processors.Tcp.TcpManagementHandlerProcessorForGetAll : AbstractTcpManagementHandlerProcessorForGetAll`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public TcpManagementHandlerProcessorForGetAll(DatabaseRequestHandler requestHandler);
    protected virtual ConcurrentSet`1<TcpConnectionOptions> GetRunningTcpConnections();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessor`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractTimeSeriesHandlerProcessor`2(TRequestHandler requestHandler);
    protected static void AddInternalFieldsToResultForSharded(TimeSeriesRangeResult rangeResult, BlittableJsonReaderObject responseRange);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessor`2/<SendConfigurationResponseAsync>d__2")]
protected Task SendConfigurationResponseAsync(TransactionOperationContext context, long index);
    public static DateTime ParseDate(string dateStr, string name);
    public static bool CheckIfIncrementalTs(string tsName);
    internal static TimeSeriesRangeResult GetTimeSeriesRange(DocumentsOperationContext context, string docId, string name, DateTime from, DateTime to, Int32& start, Int32& pageSize, IncludeDocumentsDuringTimeSeriesLoadingCommand includesCommand);
    internal static TimeSeriesRangeResult GetIncrementalTimeSeriesRange(DocumentsOperationContext context, string docId, string name, DateTime from, DateTime to, Int32& start, Int32& pageSize, IncludeDocumentsDuringTimeSeriesLoadingCommand includesCommand, bool returnFullResults);
    internal static int WriteRange(AsyncBlittableJsonTextWriter writer, TimeSeriesRangeResult rangeResult, Nullable`1<long> totalCount);
    private static int WriteEntries(AsyncBlittableJsonTextWriter writer, TimeSeriesEntry[] entries);
    private static void WriteNodeValues(AsyncBlittableJsonTextWriter writer, Dictionary`2<string, Double[]> nodeValues);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForGetDebugSegmentsSummary`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public AbstractTimeSeriesHandlerProcessorForGetDebugSegmentsSummary`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask GetSegmentsSummaryAndWriteAsync(TOperationContext context, string docId, string name, DateTime from, DateTime to);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForGetDebugSegmentsSummary`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForGetTimeSeries`2 : AbstractTimeSeriesHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractTimeSeriesHandlerProcessorForGetTimeSeries`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask`1<TimeSeriesRangeResult> GetTimeSeriesAndWriteAsync(TOperationContext context, string docId, string name, DateTime from, DateTime to, int start, int pageSize, bool includeDoc, bool includeTags, bool fullResults);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForGetTimeSeries`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForGetTimeSeriesRanges`2 : AbstractTimeSeriesHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public AbstractTimeSeriesHandlerProcessorForGetTimeSeriesRanges`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask GetTimeSeriesRangesAndWriteAsync(TOperationContext context, string documentId, StringValues names, StringValues fromList, StringValues toList, int start, int pageSize, bool includeDoc, bool includeTags, bool returnFullResults, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForGetTimeSeriesRanges`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForGetTimeSeriesRanges`2/<WriteTimeSeriesDetails>d__3")]
protected Task WriteTimeSeriesDetails(JsonOperationContext writeContext, DocumentsOperationContext docsContext, string documentId, TimeSeriesDetails ranges, bool calcTotalCount, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForGetTimeSeriesRanges`2/<WriteTimeSeriesRangeResultsAsync>d__4")]
internal static ValueTask`1<int> WriteTimeSeriesRangeResultsAsync(DocumentsOperationContext context, AsyncBlittableJsonTextWriter writer, string documentId, Dictionary`2<string, List`1<TimeSeriesRangeResult>> dictionary, bool calcTotalCount, CancellationToken token);
    protected static List`1<TimeSeriesRange> ConvertAndValidateMultipleTimeSeriesParameters(string documentId, StringValues names, StringValues fromList, StringValues toList);
}
internal abstract class Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForGetTimeSeriesStats`2 : AbstractTimeSeriesHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractTimeSeriesHandlerProcessorForGetTimeSeriesStats`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask GetTimeSeriesStatsAndWriteAsync(TOperationContext context, string docId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForGetTimeSeriesStats`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForPostTimeSeries`2 : AbstractTimeSeriesHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractTimeSeriesHandlerProcessorForPostTimeSeries`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask ApplyTimeSeriesOperationAsync(string docId, TimeSeriesOperation operation, TOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForPostTimeSeries`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForPostTimeSeriesNamesConfiguration`2 : AbstractTimeSeriesHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public AbstractTimeSeriesHandlerProcessorForPostTimeSeriesNamesConfiguration`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.AbstractTimeSeriesHandlerProcessorForPostTimeSeriesNamesConfiguration`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Handlers.Processors.TimeSeries.TimeSeriesHandlerProcessorForGetDebugSegmentsSummary : AbstractTimeSeriesHandlerProcessorForGetDebugSegmentsSummary`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public TimeSeriesHandlerProcessorForGetDebugSegmentsSummary(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.TimeSeriesHandlerProcessorForGetDebugSegmentsSummary/<GetSegmentsSummaryAndWriteAsync>d__1")]
protected virtual ValueTask GetSegmentsSummaryAndWriteAsync(DocumentsOperationContext context, string docId, string name, DateTime from, DateTime to);
}
internal class Raven.Server.Documents.Handlers.Processors.TimeSeries.TimeSeriesHandlerProcessorForGetTimeSeries : AbstractTimeSeriesHandlerProcessorForGetTimeSeries`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public TimeSeriesHandlerProcessorForGetTimeSeries(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<TimeSeriesRangeResult> GetTimeSeriesAndWriteAsync(DocumentsOperationContext context, string docId, string name, DateTime from, DateTime to, int start, int pageSize, bool includeDoc, bool includeTags, bool fullResults);
}
internal class Raven.Server.Documents.Handlers.Processors.TimeSeries.TimeSeriesHandlerProcessorForGetTimeSeriesRanges : AbstractTimeSeriesHandlerProcessorForGetTimeSeriesRanges`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public TimeSeriesHandlerProcessorForGetTimeSeriesRanges(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.TimeSeriesHandlerProcessorForGetTimeSeriesRanges/<GetTimeSeriesRangesAndWriteAsync>d__1")]
protected virtual ValueTask GetTimeSeriesRangesAndWriteAsync(DocumentsOperationContext context, string documentId, StringValues names, StringValues fromList, StringValues toList, int start, int pageSize, bool includeDoc, bool includeTags, bool returnFullResults, CancellationToken token);
    private static Dictionary`2<string, List`1<TimeSeriesRangeResult>> GetTimeSeriesRangeResults(DocumentsOperationContext context, string documentId, StringValues names, StringValues fromList, StringValues toList, int start, int pageSize, IncludeDocumentsDuringTimeSeriesLoadingCommand includes, bool returnFullResult);
    internal static Dictionary`2<string, List`1<TimeSeriesRangeResult>> GetTimeSeriesRangeResults(DocumentsOperationContext context, string documentId, List`1<TimeSeriesRange> ranges, int start, int pageSize, IncludeDocumentsDuringTimeSeriesLoadingCommand includes, bool returnFullResult);
    private static string CombineHashesFromMultipleRanges(Dictionary`2<string, List`1<TimeSeriesRangeResult>> ranges);
}
internal class Raven.Server.Documents.Handlers.Processors.TimeSeries.TimeSeriesHandlerProcessorForGetTimeSeriesStats : AbstractTimeSeriesHandlerProcessorForGetTimeSeriesStats`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public TimeSeriesHandlerProcessorForGetTimeSeriesStats(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.TimeSeriesHandlerProcessorForGetTimeSeriesStats/<GetTimeSeriesStatsAndWriteAsync>d__1")]
protected virtual ValueTask GetTimeSeriesStatsAndWriteAsync(DocumentsOperationContext context, string docId);
    public static List`1<string> GetTimesSeriesNames(Document document);
}
internal class Raven.Server.Documents.Handlers.Processors.TimeSeries.TimeSeriesHandlerProcessorForPostTimeSeries : AbstractTimeSeriesHandlerProcessorForPostTimeSeries`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public TimeSeriesHandlerProcessorForPostTimeSeries(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Processors.TimeSeries.TimeSeriesHandlerProcessorForPostTimeSeries/<ApplyTimeSeriesOperationAsync>d__1")]
protected virtual ValueTask ApplyTimeSeriesOperationAsync(string docId, TimeSeriesOperation operation, DocumentsOperationContext _);
}
internal class Raven.Server.Documents.Handlers.Processors.TimeSeries.TimeSeriesHandlerProcessorForPostTimeSeriesNamesConfiguration : AbstractTimeSeriesHandlerProcessorForPostTimeSeriesNamesConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public TimeSeriesHandlerProcessorForPostTimeSeriesNamesConfiguration(DatabaseRequestHandler requestHandler);
}
public class Raven.Server.Documents.Handlers.PullReplicationHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.PullReplicationHandler/<DefineHub>d__0")]
[RavenActionAttribute("/databases/*/admin/tasks/pull-replication/hub", "PUT", "2", "False", "False", "True", "0")]
public Task DefineHub();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.PullReplicationHandler/<RegisterHubAccess>d__1")]
[RavenActionAttribute("/databases/*/admin/tasks/pull-replication/hub/access", "PUT", "2", "False", "False", "True", "0")]
public Task RegisterHubAccess();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.PullReplicationHandler/<UnregisterHubAccess>d__2")]
[RavenActionAttribute("/databases/*/admin/tasks/pull-replication/hub/access", "DELETE", "2", "False", "False", "True", "0")]
public Task UnregisterHubAccess();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.PullReplicationHandler/<ListHubAccess>d__3")]
[RavenActionAttribute("/databases/*/admin/tasks/pull-replication/hub/access", "GET", "2", "False", "False", "True", "0")]
public Task ListHubAccess();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.PullReplicationHandler/<UpdatePullReplicationOnSinkNode>d__4")]
[RavenActionAttribute("/databases/*/admin/tasks/sink-pull-replication", "POST", "2", "False", "False", "True", "0")]
public Task UpdatePullReplicationOnSinkNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.PullReplicationHandler/<GeneratePullReplicationCertificate>d__5")]
[RavenActionAttribute("/databases/*/admin/pull-replication/generate-certificate", "POST", "2", "False", "False", "True", "0")]
public Task GeneratePullReplicationCertificate();
}
public class Raven.Server.Documents.Handlers.QueriesHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.QueriesHandler/<Post>d__0")]
[RavenActionAttribute("/databases/*/queries", "POST", "3", "1", "False", "False", "True", "0")]
public Task Post();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.QueriesHandler/<Get>d__1")]
[RavenActionAttribute("/databases/*/queries", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.QueriesHandler/<Patch>d__2")]
[RavenActionAttribute("/databases/*/queries", "PATCH", "3", "2", "False", "False", "True", "0")]
public Task Patch();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.QueriesHandler/<PatchTest>d__3")]
[RavenActionAttribute("/databases/*/queries/test", "PATCH", "3", "2", "False", "False", "True", "0")]
public Task PatchTest();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.QueriesHandler/<Delete>d__4")]
[RavenActionAttribute("/databases/*/queries", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task Delete();
}
public class Raven.Server.Documents.Handlers.RachisDatabaseHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RachisDatabaseHandler/<WaitForIndexNotifications>d__0")]
[RavenActionAttribute("/databases/*/admin/rachis/wait-for-index-notifications", "POST", "2", "False", "False", "True", "0")]
public Task WaitForIndexNotifications();
}
public class Raven.Server.Documents.Handlers.RefreshHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RefreshHandler/<GetRefreshConfiguration>d__0")]
[RavenActionAttribute("/databases/*/refresh/config", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetRefreshConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RefreshHandler/<PostRefreshConfiguration>d__1")]
[RavenActionAttribute("/databases/*/admin/refresh/config", "POST", "2", "False", "False", "True", "0")]
public Task PostRefreshConfiguration();
}
public class Raven.Server.Documents.Handlers.ReplicationHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<GetAllTombstones>d__0")]
[RavenActionAttribute("/databases/*/replication/tombstones", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetAllTombstones();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<GetReplicationConflicts>d__1")]
[RavenActionAttribute("/databases/*/replication/conflicts", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetReplicationConflicts();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<Performance>d__2")]
[RavenActionAttribute("/databases/*/replication/performance", "GET", "3", "1", "False", "False", "True", "0")]
public Task Performance();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<PerformanceLive>d__3")]
[RavenActionAttribute("/databases/*/replication/performance/live", "GET", "3", "1", "False", "False", "True", "0")]
public Task PerformanceLive();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<PulsesLive>d__4")]
[RavenActionAttribute("/databases/*/replication/pulses/live", "GET", "3", "1", "False", "False", "True", "0")]
public Task PulsesLive();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<GetReplicationActiveConnections>d__5")]
[RavenActionAttribute("/databases/*/replication/active-connections", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetReplicationActiveConnections();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<GetReplicationOutgoingFailureStats>d__6")]
[RavenActionAttribute("/databases/*/replication/debug/outgoing-failures", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetReplicationOutgoingFailureStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<GetReplicationIncomingActivityTimes>d__7")]
[RavenActionAttribute("/databases/*/replication/debug/incoming-last-activity-time", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetReplicationIncomingActivityTimes();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<GetReplicationIncomingRejectionInfo>d__8")]
[RavenActionAttribute("/databases/*/replication/debug/incoming-rejection-info", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetReplicationIncomingRejectionInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<GetReplicationReconnectionQueue>d__9")]
[RavenActionAttribute("/databases/*/replication/debug/outgoing-reconnect-queue", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetReplicationReconnectionQueue();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<GetConflictSolver>d__10")]
[RavenActionAttribute("/databases/*/replication/conflicts/solver", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetConflictSolver();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.ReplicationHandler/<GetAllItems>d__11")]
[RavenActionAttribute("/databases/*/debug/replication/all-items", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetAllItems();
}
public class Raven.Server.Documents.Handlers.RevisionsHandler : DatabaseRequestHandler {
    public static string ReadRevisionsConfigTag;
    public static string ConflictedRevisionsConfigTag;
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RevisionsHandler/<GetRevisionsConfiguration>d__2")]
[RavenActionAttribute("/databases/*/revisions/config", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetRevisionsConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RevisionsHandler/<GetConflictRevisionsConfig>d__3")]
[RavenActionAttribute("/databases/*/revisions/conflicts/config", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetConflictRevisionsConfig();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RevisionsHandler/<GetRevisionsCountFor>d__4")]
[RavenActionAttribute("/databases/*/revisions/count", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetRevisionsCountFor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RevisionsHandler/<GetRevisionsFor>d__5")]
[RavenActionAttribute("/databases/*/revisions", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetRevisionsFor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RevisionsHandler/<Revert>d__6")]
[RavenActionAttribute("/databases/*/revisions/revert", "POST", "3", "2", "False", "False", "True", "0")]
public Task Revert();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RevisionsHandler/<RevertDocument>d__7")]
[RavenActionAttribute("/databases/*/revisions/revert/docs", "POST", "3", "2", "False", "False", "True", "0")]
public Task RevertDocument();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RevisionsHandler/<GetResolvedConflictsSince>d__8")]
[RavenActionAttribute("/databases/*/revisions/resolved", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetResolvedConflictsSince();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.RevisionsHandler/<GetRevisionsBin>d__9")]
[RavenActionAttribute("/databases/*/revisions/bin", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetRevisionsBin();
}
public class Raven.Server.Documents.Handlers.SecretKeyHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SecretKeyHandler/<GetKeys>d__0")]
[RavenActionAttribute("/admin/secrets", "GET", "1", "False", "False", "True", "0")]
public Task GetKeys();
    [RavenActionAttribute("/admin/secrets/generate", "GET", "1", "False", "False", "True", "0")]
public Task LegacyGenerate();
    [RavenActionAttribute("/secrets/generate", "GET", "3", "1", "False", "False", "True", "0")]
public Task Generate();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SecretKeyHandler/<WriteAsync>d__3")]
private static Task WriteAsync(Stream responseBodyStream, string base64);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SecretKeyHandler/<PutKey>d__4")]
[RavenActionAttribute("/admin/secrets", "POST", "1", "False", "False", "True", "0")]
public Task PutKey();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SecretKeyHandler/<DistributeKeyInCluster>d__5")]
[RavenActionAttribute("/admin/secrets/distribute", "POST", "1", "False", "False", "True", "0")]
public Task DistributeKeyInCluster();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SecretKeyHandler/<SendKeyToNodeAsync>d__6")]
private static Task SendKeyToNodeAsync(string name, string base64, JsonOperationContext ctx, ServerStore server, string node, string url);
    private void StoreKeyLocally(string name, Byte[] key, TransactionOperationContext ctx);
}
public class Raven.Server.Documents.Handlers.SmugglerCounterBatchCommandDto : object {
    public List`1<CounterGroupDetail> CounterGroups;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, Dictionary`2<string, List`1<ValueTuple`2<string, long>>>> LegacyDictionary;
    public sealed virtual SmugglerCounterBatchCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public class Raven.Server.Documents.Handlers.SortersHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SortersHandler/<Get>d__0")]
[RavenActionAttribute("/databases/*/sorters", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
}
public class Raven.Server.Documents.Handlers.StartTransactionsRecordingCommand`2 : MergedTransactionCommand`2<TOperationContext, TTransaction> {
    private AbstractTransactionOperationsMerger`2<TOperationContext, TTransaction> _txMerger;
    private string _filePath;
    private Action _onStop;
    public StartTransactionsRecordingCommand`2(AbstractTransactionOperationsMerger`2<TOperationContext, TTransaction> txMerger, string filePath, Action onStop);
    public virtual long Execute(TOperationContext context, RecordingState<TOperationContext, TTransaction> recordingState);
    public virtual IReplayableCommandDto`3<TOperationContext, TTransaction, MergedTransactionCommand`2<TOperationContext, TTransaction>> ToDto(TOperationContext context);
    protected virtual long ExecuteCmd(TOperationContext context);
}
public class Raven.Server.Documents.Handlers.StatsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StatsHandler/<EssentialStats>d__0")]
[RavenActionAttribute("/databases/*/stats/essential", "GET", "3", "1", "False", "False", "True", "0")]
public Task EssentialStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StatsHandler/<DetailedStats>d__1")]
[RavenActionAttribute("/databases/*/stats/detailed", "GET", "3", "1", "False", "False", "True", "0")]
public Task DetailedStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StatsHandler/<Stats>d__2")]
[RavenActionAttribute("/databases/*/stats", "GET", "3", "1", "False", "False", "True", "0")]
public Task Stats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StatsHandler/<DatabaseHealthCheck>d__3")]
[RavenActionAttribute("/databases/*/healthcheck", "GET", "3", "1", "False", "False", "True", "0")]
public Task DatabaseHealthCheck();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StatsHandler/<Metrics>d__4")]
[RavenActionAttribute("/databases/*/metrics", "GET", "3", "1", "False", "False", "True", "0")]
public Task Metrics();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StatsHandler/<PutsMetrics>d__5")]
[RavenActionAttribute("/databases/*/metrics/puts", "GET", "3", "1", "False", "False", "True", "0")]
public Task PutsMetrics();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StatsHandler/<BytesMetrics>d__6")]
[RavenActionAttribute("/databases/*/metrics/bytes", "GET", "3", "1", "False", "False", "True", "0")]
public Task BytesMetrics();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StatsHandler/<ValidateUnusedIds>d__7")]
[RavenActionAttribute("/databases/*/admin/validate-unused-ids", "POST", "2", "False", "False", "True", "0")]
public Task ValidateUnusedIds();
}
public class Raven.Server.Documents.Handlers.StopTransactionsRecordingCommand`2 : MergedTransactionCommand`2<TOperationContext, TTransaction> {
    private AbstractTransactionOperationsMerger`2<TOperationContext, TTransaction> _txMerger;
    public StopTransactionsRecordingCommand`2(AbstractTransactionOperationsMerger`2<TOperationContext, TTransaction> _txMerger);
    public virtual long Execute(TOperationContext context, RecordingState<TOperationContext, TTransaction> recordingState);
    public virtual IReplayableCommandDto`3<TOperationContext, TTransaction, MergedTransactionCommand`2<TOperationContext, TTransaction>> ToDto(TOperationContext context);
    protected virtual long ExecuteCmd(TOperationContext context);
}
public class Raven.Server.Documents.Handlers.StreamCsvBlittableQueryResultWriter : StreamCsvResultWriter`1<BlittableJsonReaderObject> {
    public StreamCsvBlittableQueryResultWriter(HttpResponse response, Stream stream, String[] properties, string csvFileName);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StreamCsvBlittableQueryResultWriter/<AddResultAsync>d__0")]
public virtual ValueTask AddResultAsync(BlittableJsonReaderObject res, CancellationToken token);
}
public class Raven.Server.Documents.Handlers.StreamCsvDocumentQueryResultWriter : StreamCsvResultWriter`1<Document> {
    public StreamCsvDocumentQueryResultWriter(HttpResponse response, Stream stream, String[] properties, string csvFileName);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StreamCsvDocumentQueryResultWriter/<AddResultAsync>d__0")]
public virtual ValueTask AddResultAsync(Document res, CancellationToken token);
}
public abstract class Raven.Server.Documents.Handlers.StreamCsvResultWriter`1 : object {
    private StreamWriter _writer;
    private CsvWriter _csvWriter;
    private ValueTuple`2[] _properties;
    private bool _writeHeader;
    private HashSet`1<string> _metadataPropertiesToSkip;
    private Char[] _splitter;
    public bool SupportError { get; }
    public bool SupportStatistics { get; }
    protected StreamCsvResultWriter`1(HttpResponse response, Stream stream, String[] properties, string csvFileNamePrefix);
    protected void WriteCsvHeaderIfNeeded(BlittableJsonReaderObject blittable, bool writeIds);
    private string Escape(string s);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StreamCsvResultWriter`1/<DisposeAsync>d__9")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void StartResponse();
    public sealed virtual void StartResults();
    public sealed virtual void EndResults();
    public abstract virtual ValueTask AddResultAsync(T res, CancellationToken token);
    public CsvWriter GetCsvWriter();
    public ValueTuple`2[] GetProperties();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Handlers.StreamCsvResultWriter`1/<GetPropertiesRecursive>d__16")]
private IEnumerable`1<ValueTuple`2<string, string>> GetPropertiesRecursive(ValueTuple`2<string, string> propertyTuple, BlittableJsonReaderObject obj, bool addId);
    public sealed virtual void EndResponse();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StreamCsvResultWriter`1/<WriteErrorAsync>d__18")]
public sealed virtual ValueTask WriteErrorAsync(Exception e);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.StreamCsvResultWriter`1/<WriteErrorAsync>d__19")]
public sealed virtual ValueTask WriteErrorAsync(string error);
    public sealed virtual void WriteQueryStatistics(long resultEtag, bool isStale, string indexName, long totalResults, DateTime timestamp);
    public bool get_SupportError();
    public sealed virtual bool get_SupportStatistics();
    [CompilerGeneratedAttribute]
private ValueTuple`2<string, string> <.ctor>b__5_0(string p);
}
public class Raven.Server.Documents.Handlers.Streaming.DocsStreamingIterationState : PulsedEnumerationState`1<Document> {
    public string StartsWith;
    public string Excludes;
    public string Matches;
    public string StartAfter;
    public int Start;
    public int Take;
    public Nullable`1<long> LastIteratedEtag;
    public Reference`1<long> Skip;
    public DocsStreamingIterationState(DocumentsOperationContext context, Size pulseLimit);
    public virtual void OnMoveNext(Document current);
}
public interface Raven.Server.Documents.Handlers.Streaming.IStreamResultsWriter`1 {
    public abstract virtual void StartResponse();
    public abstract virtual void StartResults();
    public abstract virtual void EndResults();
    public abstract virtual ValueTask AddResultAsync(T res, CancellationToken token);
    public abstract virtual void EndResponse();
}
public class Raven.Server.Documents.Handlers.Streaming.StreamingHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Streaming.StreamingHandler/<StreamDocsGet>d__0")]
[RavenActionAttribute("/databases/*/streams/docs", "GET", "3", "1", "False", "False", "True", "0")]
public Task StreamDocsGet();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Streaming.StreamingHandler/<Stream>d__1")]
[RavenActionAttribute("/databases/*/streams/timeseries", "GET", "3", "1", "False", "False", "True", "0")]
public Task Stream();
    [RavenActionAttribute("/databases/*/streams/queries", "HEAD", "3", "1", "False", "False", "True", "0")]
public Task SteamQueryHead();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Streaming.StreamingHandler/<StreamQueryGet>d__3")]
[RavenActionAttribute("/databases/*/streams/queries", "GET", "3", "1", "False", "False", "True", "0")]
public Task StreamQueryGet();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Streaming.StreamingHandler/<StreamQueryPost>d__4")]
[RavenActionAttribute("/databases/*/streams/queries", "POST", "3", "1", "False", "False", "True", "0")]
public Task StreamQueryPost();
}
public class Raven.Server.Documents.Handlers.Streaming.StreamJsonlResultsWriter : object {
    private AsyncBlittableJsonTextWriter _writer;
    private JsonOperationContext _context;
    public StreamJsonlResultsWriter(Stream stream, JsonOperationContext context, CancellationToken token);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void StartResponse();
    public sealed virtual void StartResults();
    public sealed virtual void EndResults();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Streaming.StreamJsonlResultsWriter/<AddResultAsync>d__7")]
public sealed virtual ValueTask AddResultAsync(Document res, CancellationToken token);
    public sealed virtual void EndResponse();
}
public class Raven.Server.Documents.Handlers.Streaming.StreamResultsWriter : object {
    private AsyncBlittableJsonTextWriter _writer;
    private JsonOperationContext _context;
    private bool _first;
    public StreamResultsWriter(Stream stream, JsonOperationContext context, CancellationToken token);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void StartResponse();
    public sealed virtual void StartResults();
    public sealed virtual void EndResults();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.Streaming.StreamResultsWriter/<AddResultAsync>d__8")]
public sealed virtual ValueTask AddResultAsync(Document res, CancellationToken token);
    public sealed virtual void EndResponse();
}
public class Raven.Server.Documents.Handlers.StreamJsonFileBlittableQueryResultWriter : AbstractStreamJsonFileBlittableQueryResultWriter`1<BlittableJsonReaderObject> {
    private bool _first;
    public StreamJsonFileBlittableQueryResultWriter(HttpResponse response, Stream stream, JsonOperationContext context, String[] properties, string jsonFileNamePrefix);
    public virtual ValueTask AddResultAsync(BlittableJsonReaderObject res, CancellationToken token);
}
public class Raven.Server.Documents.Handlers.StreamJsonFileDocumentQueryResultWriter : AbstractStreamJsonFileBlittableQueryResultWriter`1<Document> {
    private bool _first;
    public StreamJsonFileDocumentQueryResultWriter(HttpResponse response, Stream stream, JsonOperationContext context, String[] properties, string jsonFileNamePrefix);
    public virtual ValueTask AddResultAsync(Document res, CancellationToken token);
}
public class Raven.Server.Documents.Handlers.SubscriptionsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<Try>d__0")]
[RavenActionAttribute("/databases/*/subscriptions/try", "POST", "3", "2", "False", "False", "True", "0")]
public Task Try();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<Create>d__1")]
[RavenActionAttribute("/databases/*/subscriptions", "PUT", "3", "2", "False", "False", "True", "0")]
public Task Create();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<Delete>d__2")]
[RavenActionAttribute("/databases/*/subscriptions", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task Delete();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<GetSubscriptionState>d__3")]
[RavenActionAttribute("/databases/*/subscriptions/state", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetSubscriptionState();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<GetSubscriptionResend>d__4")]
[RavenActionAttribute("/databases/*/debug/subscriptions/resend", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetSubscriptionResend();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<GetSubscriptionConnectionDetails>d__5")]
[RavenActionAttribute("/databases/*/subscriptions/connection-details", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetSubscriptionConnectionDetails();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<GetAll>d__6")]
[RavenActionAttribute("/databases/*/subscriptions", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetAll();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<PerformanceLive>d__7")]
[RavenActionAttribute("/databases/*/subscriptions/performance/live", "GET", "3", "1", "False", "False", "True", "0")]
public Task PerformanceLive();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<DropSubscriptionConnection>d__8")]
[RavenActionAttribute("/databases/*/subscriptions/drop", "POST", "3", "2", "False", "False", "True", "0")]
public Task DropSubscriptionConnection();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<Update>d__9")]
[RavenActionAttribute("/databases/*/subscriptions/update", "POST", "3", "2", "False", "False", "True", "0")]
public Task Update();
    public static bool SubscriptionHasChanges(SubscriptionCreationOptions options, SubscriptionState state);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.SubscriptionsHandler/<CreateInternalAsync>d__11")]
public Task CreateInternalAsync(BlittableJsonReaderObject bjro, SubscriptionCreationOptions options, DocumentsOperationContext context, Nullable`1<long> id, Nullable`1<bool> disabled, ParsedSubscription sub);
}
public class Raven.Server.Documents.Handlers.TcpManagementHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TcpManagementHandler/<GetAll>d__0")]
[RavenActionAttribute("/databases/*/tcp", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetAll();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TcpManagementHandler/<Delete>d__1")]
[RavenActionAttribute("/databases/*/tcp", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task Delete();
}
public class Raven.Server.Documents.Handlers.TimeSeriesHandler : DatabaseRequestHandler {
    private static AppendOptions AppendOptionsForSmuggler;
    private static TimeSeriesHandler();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TimeSeriesHandler/<Stats>d__0")]
[RavenActionAttribute("/databases/*/timeseries/stats", "GET", "3", "1", "False", "False", "True", "0")]
public Task Stats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TimeSeriesHandler/<ReadRanges>d__1")]
[RavenActionAttribute("/databases/*/timeseries/ranges", "GET", "3", "1", "False", "False", "True", "0")]
public Task ReadRanges();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TimeSeriesHandler/<ReadRangesPost>d__2")]
[RavenActionAttribute("/databases/*/timeseries/ranges", "POST", "3", "1", "False", "False", "True", "0")]
public Task ReadRangesPost();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TimeSeriesHandler/<Read>d__3")]
[RavenActionAttribute("/databases/*/timeseries", "GET", "3", "1", "False", "False", "True", "0")]
public Task Read();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TimeSeriesHandler/<Batch>d__4")]
[RavenActionAttribute("/databases/*/timeseries", "POST", "3", "2", "False", "False", "True", "0")]
public Task Batch();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TimeSeriesHandler/<GetTimeSeriesConfiguration>d__5")]
[RavenActionAttribute("/databases/*/timeseries/config", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetTimeSeriesConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TimeSeriesHandler/<PostTimeSeriesConfiguration>d__6")]
[RavenActionAttribute("/databases/*/admin/timeseries/config", "POST", "2", "False", "False", "True", "0")]
public Task PostTimeSeriesConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TimeSeriesHandler/<ConfigTimeSeriesNames>d__7")]
[RavenActionAttribute("/databases/*/timeseries/names/config", "POST", "3", "2", "False", "False", "True", "0")]
public Task ConfigTimeSeriesNames();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TimeSeriesHandler/<GetSegmentSummary>d__11")]
[RavenActionAttribute("/databases/*/timeseries/debug/segments-summary", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetSegmentSummary();
}
public class Raven.Server.Documents.Handlers.TransactionsRecordingHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TransactionsRecordingHandler/<ReplayRecording>d__0")]
[RavenActionAttribute("/databases/*/transactions/replay", "POST", "3", "2", "False", "False", "True", "0")]
public Task ReplayRecording();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TransactionsRecordingHandler/<DoReplayAsync>d__1")]
private Task`1<IOperationResult> DoReplayAsync(Action`1<IOperationProgress> onProgress, Stream replayStream, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TransactionsRecordingHandler/<StartRecording>d__2")]
[RavenActionAttribute("/databases/*/admin/transactions/start-recording", "POST", "2", "False", "False", "True", "0")]
public Task StartRecording();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Handlers.TransactionsRecordingHandler/<StopRecording>d__3")]
[RavenActionAttribute("/databases/*/admin/transactions/stop-recording", "POST", "2", "False", "False", "True", "0")]
public Task StopRecording();
}
public class Raven.Server.Documents.HugeDocuments : object {
    private static string PerformanceHintSource;
    internal static string HugeDocumentsId;
    private object _addHintSyncObj;
    private SizeLimitedConcurrentDictionary`2<Tuple`2<string, DateTime>, long> _hugeDocs;
    private Logger _logger;
    private long _maxWarnSize;
    private DatabaseNotificationCenter _notificationCenter;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _needsSync;
    private PerformanceHint _performanceHint;
    private HugeDocumentsDetails _details;
    private Timer _timer;
    public HugeDocuments(DatabaseNotificationCenter notificationCenter, int maxCollectionSize, long maxWarnSize);
    private static HugeDocuments();
    public void AddIfDocIsHuge(Document doc);
    public void AddIfDocIsHuge(string id, int size);
    private void AddHint(string id, int size);
    internal void UpdateHugeDocuments(object state);
    public SizeLimitedConcurrentDictionary`2<Tuple`2<string, DateTime>, long> GetHugeDocuments();
    private PerformanceHint GetOrCreatePerformanceHint(HugeDocumentsDetails& details);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.IdleDatabaseActivity : object {
    [CompilerGeneratedAttribute]
private long <LastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private IdleDatabaseActivityType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <DateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    public long LastEtag { get; }
    public IdleDatabaseActivityType Type { get; }
    public Nullable`1<DateTime> DateTime { get; internal set; }
    public long TaskId { get; }
    public int DueTime { get; }
    public IdleDatabaseActivity(IdleDatabaseActivityType type);
    public IdleDatabaseActivity(IdleDatabaseActivityType type, DateTime timeOfActivity, long taskId, long lastEtag);
    [CompilerGeneratedAttribute]
public long get_LastEtag();
    [CompilerGeneratedAttribute]
public IdleDatabaseActivityType get_Type();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_DateTime();
    [CompilerGeneratedAttribute]
internal void set_DateTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    public int get_DueTime();
}
public enum Raven.Server.Documents.IdleDatabaseActivityType : Enum {
    public int value__;
    public static IdleDatabaseActivityType WakeUpDatabase;
    public static IdleDatabaseActivityType UpdateBackupStatusOnly;
}
public abstract class Raven.Server.Documents.Includes.AbstractIncludeCountersCommand : object {
    public Dictionary`2<string, String[]> IncludedCounterNames { get; }
    public int Count { get; }
    public abstract virtual ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public abstract virtual Dictionary`2<string, String[]> get_IncludedCounterNames();
    public abstract virtual int get_Count();
    public abstract virtual long GetCountersSize();
    public abstract virtual long GetCountersCount();
}
public abstract class Raven.Server.Documents.Includes.AbstractIncludeDocumentsCommand : object {
    public int Count { get; }
    public abstract virtual int get_Count();
}
public abstract class Raven.Server.Documents.Includes.AbstractIncludesCommand : object {
    public static StringSegment IncludesSegment;
    public static StringSegment CounterIncludesSegment;
    public static StringSegment IncludedCounterNamesSegment;
    public static StringSegment TimeSeriesIncludesSegment;
    private AbstractIncludeDocumentsCommand _includeDocumentsCommand;
    private AbstractIncludeTimeSeriesCommand _includeTimeSeriesCommand;
    private AbstractIncludeCountersCommand _includeCountersCommand;
    protected AbstractIncludesCommand(AbstractIncludeDocumentsCommand includeDocumentsCommand, AbstractIncludeTimeSeriesCommand includeTimeSeriesCommand, AbstractIncludeCountersCommand includeCountersCommand);
    private static AbstractIncludesCommand();
    public abstract virtual ValueTask`1<ValueTuple`2<long, long>> WriteIncludedDocumentsInternalAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Includes.AbstractIncludesCommand/<WriteIncludesAsync>d__9")]
public ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, SubscriptionBatchStatsScope batchScope, CancellationToken token);
}
public abstract class Raven.Server.Documents.Includes.AbstractIncludeTimeSeriesCommand : object {
    public int Count { get; }
    public abstract virtual ValueTask`1<int> WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public abstract virtual int get_Count();
    public abstract virtual long GetEntriesCountForStats();
}
public class Raven.Server.Documents.Includes.DatabaseIncludesCommandImpl : AbstractIncludesCommand {
    public IncludeDocumentsCommand IncludeDocumentsCommand;
    public IncludeTimeSeriesCommand IncludeTimeSeriesCommand;
    public IncludeCountersCommand IncludeCountersCommand;
    public DatabaseIncludesCommandImpl(IncludeDocumentsCommand includeDocumentsCommand, IncludeTimeSeriesCommand includeTimeSeriesCommand, IncludeCountersCommand includeCountersCommand);
    public virtual ValueTask`1<ValueTuple`2<long, long>> WriteIncludedDocumentsInternalAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public void GatherIncludesForDocument(Document document);
}
public interface Raven.Server.Documents.Includes.ICompareExchangeValueIncludes {
    public Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> Results { get; }
    public abstract virtual Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> get_Results();
}
public interface Raven.Server.Documents.Includes.ICounterIncludes {
    public Dictionary`2<string, String[]> IncludedCounterNames { get; }
    public int Count { get; }
    public abstract virtual ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public abstract virtual Dictionary`2<string, String[]> get_IncludedCounterNames();
    public abstract virtual int get_Count();
    public abstract virtual long GetCountersSize();
    public abstract virtual long GetCountersCount();
}
public class Raven.Server.Documents.Includes.IncludeCompareExchangeValuesCommand : object {
    private ServerStore _serverStore;
    private AbstractCompareExchangeStorage _compareExchangeStorage;
    private char _identityPartsSeparator;
    private String[] _includes;
    private HashSet`1<string> _includedKeys;
    private IDisposable _releaseContext;
    private ClusterOperationContext _serverContext;
    private bool _throwWhenServerContextIsAllocated;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> <Results>k__BackingField;
    public Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> Results { get; public set; }
    private IncludeCompareExchangeValuesCommand(DocumentDatabase database, ClusterOperationContext serverContext, bool throwWhenServerContextIsAllocated, String[] compareExchangeValues);
    private IncludeCompareExchangeValuesCommand(ServerStore serverStore, AbstractCompareExchangeStorage compareExchangeStorage, char identityPartsSeparator, ClusterOperationContext serverContext, bool throwWhenServerContextIsAllocated, String[] compareExchangeValues);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> value);
    public static IncludeCompareExchangeValuesCommand ExternalScope(QueryOperationContext context, String[] compareExchangeValues);
    public static IncludeCompareExchangeValuesCommand InternalScope(DocumentDatabase database, String[] compareExchangeValues);
    internal void AddRange(HashSet`1<string> keys);
    internal void Gather(Document document);
    public void AddDocument(string id);
    public bool TryGetCompareExchange(string key, Nullable`1<long> maxAtomicGuardIndex, Int64& index, BlittableJsonReaderObject& value);
    internal void Materialize(Nullable`1<long> maxAllowedAtomicGuardIndex);
    private void CreateServerContext();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Includes.IncludeCountersCommand : AbstractIncludeCountersCommand {
    private DocumentDatabase _database;
    private DocumentsOperationContext _context;
    private Dictionary`2<string, String[]> _countersBySourcePath;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <IncludedCounterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<CounterDetail>> <Results>k__BackingField;
    public Dictionary`2<string, String[]> IncludedCounterNames { get; }
    public Dictionary`2<string, List`1<CounterDetail>> Results { get; }
    public int Count { get; }
    private IncludeCountersCommand(DocumentDatabase database, DocumentsOperationContext context);
    public IncludeCountersCommand(DocumentDatabase database, DocumentsOperationContext context, String[] counters);
    public IncludeCountersCommand(DocumentDatabase database, DocumentsOperationContext context, Dictionary`2<string, HashSet`1<string>> countersBySourcePath);
    [CompilerGeneratedAttribute]
public virtual Dictionary`2<string, String[]> get_IncludedCounterNames();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<CounterDetail>> get_Results();
    public void Fill(Document document);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Includes.IncludeCountersCommand/<WriteIncludesAsync>d__13")]
public virtual ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public virtual int get_Count();
    public virtual long GetCountersSize();
    public virtual long GetCountersCount();
}
public class Raven.Server.Documents.Includes.IncludeDocumentsCommand : AbstractIncludeDocumentsCommand {
    private DocumentsStorage _storage;
    private DocumentsOperationContext _context;
    private String[] _includes;
    private bool _isProjection;
    private HashSet`1<string> _includedIds;
    private HashSet`1<string> _idsToIgnore;
    public DocumentsOperationContext Context { get; }
    public int Count { get; }
    public IncludeDocumentsCommand(DocumentsStorage storage, DocumentsOperationContext context, String[] includes, bool isProjection);
    public DocumentsOperationContext get_Context();
    public virtual int get_Count();
    public void AddRange(HashSet`1<string> ids, string documentId);
    public void Gather(Document document);
    public void Gather(List`1<FacetResult> results);
    public void Fill(List`1<Document> result, bool includeMissingAsNull);
    private static Document CreateConflictDocument(DocumentConflictException exception);
    private void AddToIgnore(string documentId);
}
public class Raven.Server.Documents.Includes.IncludeDocumentsDuringTimeSeriesLoadingCommand : object {
    private DocumentsOperationContext _context;
    private string _docId;
    private bool _includeDoc;
    private bool _includeTags;
    private Byte* _state;
    private Dictionary`2<string, BlittableJsonReaderObject> _includesDictionary;
    private DynamicJsonValue _includes;
    private HashSet`1<string> _missingIncludes;
    public IncludeDocumentsDuringTimeSeriesLoadingCommand(DocumentsOperationContext context, string docId, bool includeDocument, bool includeTags, bool missingIncludes);
    public void InitializeNewRangeResult(Byte* state);
    public void Fill(string tag);
    public void AddIncludesToResult(TimeSeriesRangeResult rangeResult);
    private void IncludeDocument(string id);
}
public class Raven.Server.Documents.Includes.IncludeRevisionsCommand : object {
    private DocumentDatabase _database;
    private DocumentsOperationContext _context;
    private Nullable`1<DateTime> _revisionsBeforeDateTime;
    private HashSet`1<string> _pathsForRevisionsChangeVectors;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Document> <RevisionsChangeVectorResults>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Dictionary`2<DateTime, Document>> <IdByRevisionsByDateTimeResults>k__BackingField;
    public Dictionary`2<string, Document> RevisionsChangeVectorResults { get; private set; }
    public Dictionary`2<string, Dictionary`2<DateTime, Document>> IdByRevisionsByDateTimeResults { get; private set; }
    public int Count { get; }
    private IncludeRevisionsCommand(DocumentDatabase database, DocumentsOperationContext context);
    public IncludeRevisionsCommand(DocumentDatabase database, DocumentsOperationContext context, RevisionIncludeField revisionIncludeField);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Document> get_RevisionsChangeVectorResults();
    [CompilerGeneratedAttribute]
private void set_RevisionsChangeVectorResults(Dictionary`2<string, Document> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Dictionary`2<DateTime, Document>> get_IdByRevisionsByDateTimeResults();
    [CompilerGeneratedAttribute]
private void set_IdByRevisionsByDateTimeResults(Dictionary`2<string, Dictionary`2<DateTime, Document>> value);
    public void Fill(Document document);
    public void AddRange(HashSet`1<string> changeVectorPaths);
    public void AddRevisionByDateTimeBefore(Nullable`1<DateTime> dateTime, string documentId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Includes.IncludeRevisionsCommand/<WriteIncludesAsync>d__17")]
public sealed virtual ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public sealed virtual int get_Count();
}
public class Raven.Server.Documents.Includes.IncludeTimeSeriesCommand : AbstractIncludeTimeSeriesCommand {
    private DocumentsOperationContext _context;
    private Dictionary`2<string, HashSet`1<AbstractTimeSeriesRange>> _timeSeriesRangesBySourcePath;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, Dictionary`2<string, ValueTuple`3<long, DateTime, DateTime>>> _timeSeriesStatsPerDocumentId;
    public Dictionary`2<string, Dictionary`2<string, List`1<TimeSeriesRangeResult>>> Results;
    public int Count { get; }
    public IncludeTimeSeriesCommand(DocumentsOperationContext context, Dictionary`2<string, HashSet`1<AbstractTimeSeriesRange>> timeSeriesRangesBySourcePath);
    public virtual int get_Count();
    public void Fill(Document document);
    private Dictionary`2<string, List`1<TimeSeriesRangeResult>> GetTimeSeriesForDocument(string docId, HashSet`1<AbstractTimeSeriesRange> timeSeriesToGet);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Includes.IncludeTimeSeriesCommand/<WriteIncludesAsync>d__9")]
public virtual ValueTask`1<int> WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public virtual long GetEntriesCountForStats();
    [CompilerGeneratedAttribute]
private ValueTuple`3<long, DateTime, DateTime> <GetTimeSeriesForDocument>g__GetTimeSeriesStats|8_0(string documentId, string timeSeries);
}
public interface Raven.Server.Documents.Includes.IRevisionIncludes {
    public int Count { get; }
    public abstract virtual ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public abstract virtual int get_Count();
}
public interface Raven.Server.Documents.Includes.ITimeSeriesIncludes {
    public int Count { get; }
    public abstract virtual ValueTask`1<int> WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public abstract virtual int get_Count();
    public abstract virtual long GetEntriesCountForStats();
}
public class Raven.Server.Documents.Includes.Sharding.IncludeDocumentsOrchestratedSubscriptionCommand : AbstractIncludeDocumentsCommand {
    private JsonOperationContext _clusterContext;
    private CancellationToken _token;
    [CompilerGeneratedAttribute]
private List`1<BlittableJsonReaderObject> <Includes>k__BackingField;
    public List`1<BlittableJsonReaderObject> Includes { get; }
    public int Count { get; }
    public IncludeDocumentsOrchestratedSubscriptionCommand(JsonOperationContext clusterContext, CancellationToken token);
    [CompilerGeneratedAttribute]
public List`1<BlittableJsonReaderObject> get_Includes();
    public virtual int get_Count();
    public void Gather(List`1<BlittableJsonReaderObject> includes);
}
public class Raven.Server.Documents.Includes.Sharding.OrchestratorIncludesCommandImpl : AbstractIncludesCommand {
    public IncludeDocumentsOrchestratedSubscriptionCommand IncludeDocumentsCommand;
    public ShardedTimeSeriesIncludes IncludeTimeSeriesCommand;
    public ShardedCounterIncludes IncludeCountersCommand;
    public OrchestratorIncludesCommandImpl(IncludeDocumentsOrchestratedSubscriptionCommand includeDocumentsCommand, ShardedTimeSeriesIncludes includeTimeSeriesCommand, ShardedCounterIncludes includeCountersCommand);
    public virtual ValueTask`1<ValueTuple`2<long, long>> WriteIncludedDocumentsInternalAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
}
public class Raven.Server.Documents.Includes.Sharding.ShardedCompareExchangeValueInclude : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> <Results>k__BackingField;
    public Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> Results { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> value);
    public void AddResults(BlittableJsonReaderObject results, JsonOperationContext contextToClone);
}
public class Raven.Server.Documents.Includes.Sharding.ShardedCounterIncludes : AbstractIncludeCountersCommand {
    private CancellationToken _token;
    private Dictionary`2<string, List`1<BlittableJsonReaderObject>> _countersByDocumentId;
    private Dictionary`2<string, HashSet`1<string>> _includedCounterNames;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <MissingCounterIncludes>k__BackingField;
    public HashSet`1<string> MissingCounterIncludes { get; public set; }
    public Dictionary`2<string, String[]> IncludedCounterNames { get; }
    public int Count { get; }
    public ShardedCounterIncludes(CancellationToken token);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_MissingCounterIncludes();
    [CompilerGeneratedAttribute]
public void set_MissingCounterIncludes(HashSet`1<string> value);
    public virtual Dictionary`2<string, String[]> get_IncludedCounterNames();
    public virtual int get_Count();
    public void AddResults(BlittableJsonReaderObject results, Dictionary`2<string, String[]> includedCounterNames, JsonOperationContext contextToClone);
    public void AddMissingCounter(string docId, BlittableJsonReaderObject counter);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Includes.Sharding.ShardedCounterIncludes/<WriteIncludesAsync>d__14")]
public virtual ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public void Gather(List`1<ValueTuple`2<BlittableJsonReaderObject, Dictionary`2<string, String[]>>> list, ClusterOperationContext clusterOperationContext);
    public virtual long GetCountersSize();
    public virtual long GetCountersCount();
}
public class Raven.Server.Documents.Includes.Sharding.ShardedRevisionIncludes : object {
    private Dictionary`2<string, List`1<BlittableJsonReaderObject>> _revisionsByDocumentId;
    public int Count { get; }
    public sealed virtual int get_Count();
    public void AddResults(BlittableJsonReaderArray results, JsonOperationContext contextToClone);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Includes.Sharding.ShardedRevisionIncludes/<WriteIncludesAsync>d__4")]
public sealed virtual ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
}
public class Raven.Server.Documents.Includes.Sharding.ShardedTimeSeriesIncludes : AbstractIncludeTimeSeriesCommand {
    private bool _supportsMissingIncludes;
    private CancellationToken _token;
    private Dictionary`2<string, BlittableJsonReaderObject> _resultsByDocumentId;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<TimeSeriesRange>> <MissingTimeSeriesIncludes>k__BackingField;
    public int Count { get; }
    public Dictionary`2<string, List`1<TimeSeriesRange>> MissingTimeSeriesIncludes { get; public set; }
    public ShardedTimeSeriesIncludes(bool supportsMissingIncludes, CancellationToken token);
    public virtual int get_Count();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<TimeSeriesRange>> get_MissingTimeSeriesIncludes();
    [CompilerGeneratedAttribute]
public void set_MissingTimeSeriesIncludes(Dictionary`2<string, List`1<TimeSeriesRange>> value);
    public void AddResults(BlittableJsonReaderObject results, JsonOperationContext contextToClone);
    private bool HasMissingEntries(BlittableJsonReaderObject json, List`1& missingRanges);
    public void AddMissingTimeSeries(string docId, BlittableJsonReaderObject timeSeries);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Includes.Sharding.ShardedTimeSeriesIncludes/<WriteIncludesAsync>d__13")]
public virtual ValueTask`1<int> WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
    public virtual long GetEntriesCountForStats();
    public void Gather(List`1<BlittableJsonReaderObject> list, ClusterOperationContext clusterOperationContext);
}
public class Raven.Server.Documents.Includes.Sharding.ShardIncludesCommandImpl : DatabaseIncludesCommandImpl {
    public ShardIncludesCommandImpl(IncludeDocumentsCommand includeDocumentsCommand, IncludeTimeSeriesCommand includeTimeSeriesCommand, IncludeCountersCommand includeCountersCommand);
    public virtual ValueTask`1<ValueTuple`2<long, long>> WriteIncludedDocumentsInternalAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, CancellationToken token);
}
public abstract class Raven.Server.Documents.Indexes.AbstractCompilationCache`1 : object {
    private ConcurrentDictionary`2<CacheKey<TType>, Lazy`1<TType>> _compilationCache;
    internal ConcurrentDictionary`2<CacheKey<TType>, Lazy`1<TType>> ServerWideCache;
    internal ConcurrentDictionary`2<CacheKey<TType>, Lazy`1<TType>> PerDatabaseCache;
    public TType GetItemType(string name, string databaseName);
    private static bool TryGetItemType(ConcurrentDictionary`2<CacheKey<TType>, Lazy`1<TType>> cache, CacheKey<TType> key, TType& type);
    public void AddServerWideItem(string name, string code);
    public void RemoveServerWideItem(string name);
    protected abstract virtual bool DatabaseRecordContainsItem(RawDatabaseRecord databaseRecord, string name);
    protected abstract virtual IEnumerable`1<ValueTuple`2<string, string>> GetItemsFromDatabaseRecord(RawDatabaseRecord databaseRecord);
    protected abstract virtual IEnumerable`1<ValueTuple`2<string, string>> GetItemsFromCluster(ServerStore serverStore, TransactionOperationContext context);
    public void AddItems(RawDatabaseRecord databaseRecord);
    public void AddServerWideItems(ServerStore serverStore);
    public void Clear(string resourceName);
    private void AddItemInternal(ConcurrentDictionary`2<CacheKey<TType>, Lazy`1<TType>> cache, CacheKey<TType> key, string name, string code);
    protected abstract virtual TType CompileItem(string name, string code);
    private TType CompileAnalyzer(string name, string code);
}
public abstract class Raven.Server.Documents.Indexes.AbstractIndexCreateController : object {
    protected ServerStore ServerStore;
    protected AbstractIndexCreateController(ServerStore serverStore);
    protected abstract virtual string GetDatabaseName();
    protected abstract virtual SystemTime GetDatabaseTime();
    public abstract virtual RavenConfiguration GetDatabaseConfiguration();
    protected abstract virtual IndexInformationHolder GetIndex(string name);
    protected abstract virtual IEnumerable`1<string> GetIndexNames();
    protected abstract virtual ValueTask`1<long> GetCollectionCountAsync(string collection);
    protected abstract virtual IEnumerable`1<IndexInformationHolder> GetIndexes();
    protected abstract virtual ValueTask WaitForIndexNotificationAsync(long index, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.AbstractIndexCreateController/<ValidateStaticIndexAsync>d__10")]
protected virtual ValueTask ValidateStaticIndexAsync(IndexDefinition definition);
    protected virtual void ValidateAutoIndex(IndexDefinitionBaseServerSide definition);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.AbstractIndexCreateController/<CreateIndexAsync>d__12")]
public ValueTask`1<long> CreateIndexAsync(IndexDefinition definition, string raftRequestId, string source);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.AbstractIndexCreateController/<CreateIndexAsync>d__13")]
public ValueTask`1<Nullable`1<long>> CreateIndexAsync(IndexDefinitionBaseServerSide definition, string raftRequestId);
    public bool CanUseIndexBatch();
    public IndexBatchScope CreateIndexBatch();
    private void ValidateAnalyzers(IndexDefinition definition);
    private static void ValidateConfiguration(IndexDefinition definition);
    private bool NeedToCheckIfCollectionEmpty(IndexDefinition definition, RavenConfiguration databaseConfiguration);
    private static bool IsCreateOrUpdate(IndexCreationOptions creationOptions);
}
public abstract class Raven.Server.Documents.Indexes.AbstractIndexDeleteController : object {
    protected ServerStore ServerStore;
    protected AbstractIndexDeleteController(ServerStore serverStore);
    protected abstract virtual string GetDatabaseName();
    protected abstract virtual IndexDefinitionBaseServerSide GetIndexDefinition(string name);
    protected abstract virtual ValueTask CreateIndexAsync(IndexDefinition definition, string raftRequestId);
    protected abstract virtual ValueTask WaitForIndexNotificationAsync(long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.AbstractIndexDeleteController/<TryDeleteIndexIfExistsAsync>d__6")]
public ValueTask`1<bool> TryDeleteIndexIfExistsAsync(string name, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.AbstractIndexDeleteController/<DeleteIndexAsync>d__7")]
public ValueTask DeleteIndexAsync(string name, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.AbstractIndexDeleteController/<HandleSideBySideIndexDeleteAsync>d__8")]
private ValueTask HandleSideBySideIndexDeleteAsync(string name, string raftRequestId);
}
public abstract class Raven.Server.Documents.Indexes.AbstractIndexHasChangedController : object {
    protected abstract virtual IndexInformationHolder GetIndex(string name);
    protected abstract virtual RavenConfiguration GetDatabaseConfiguration();
    public bool HasChanged(IndexDefinition definition);
}
public abstract class Raven.Server.Documents.Indexes.AbstractIndexLockModeController : object {
    protected ServerStore ServerStore;
    protected AbstractIndexLockModeController(ServerStore serverStore);
    protected abstract virtual string GetDatabaseName();
    protected abstract virtual void ValidateIndex(string name, IndexLockMode mode);
    protected abstract virtual ValueTask WaitForIndexNotificationAsync(long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.AbstractIndexLockModeController/<SetLockAsync>d__5")]
public Task SetLockAsync(string name, IndexLockMode mode, string raftRequestId);
}
public abstract class Raven.Server.Documents.Indexes.AbstractIndexPriorityController : object {
    protected ServerStore ServerStore;
    protected AbstractIndexPriorityController(ServerStore serverStore);
    protected abstract virtual string GetDatabaseName();
    protected abstract virtual void ValidateIndex(string name, IndexPriority priority);
    protected abstract virtual ValueTask WaitForIndexNotificationAsync(long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.AbstractIndexPriorityController/<SetPriorityAsync>d__5")]
public Task SetPriorityAsync(string name, IndexPriority priority, string raftRequestId);
}
public abstract class Raven.Server.Documents.Indexes.AbstractIndexStateController : object {
    protected ServerStore ServerStore;
    protected AbstractIndexStateController(ServerStore serverStore);
    protected abstract virtual string GetDatabaseName();
    protected abstract virtual void ValidateIndex(string name, IndexState state);
    protected abstract virtual ValueTask WaitForIndexNotificationAsync(long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.AbstractIndexStateController/<SetStateAsync>d__5")]
public Task SetStateAsync(string name, IndexState state, string raftRequestId);
}
public class Raven.Server.Documents.Indexes.Analysis.AnalyzerCompilationCache : AbstractCompilationCache`1<AnalyzerFactory> {
    public static AnalyzerCompilationCache Instance;
    private static AnalyzerCompilationCache();
    protected virtual bool DatabaseRecordContainsItem(RawDatabaseRecord databaseRecord, string name);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Analysis.AnalyzerCompilationCache/<GetItemsFromDatabaseRecord>d__3")]
protected virtual IEnumerable`1<ValueTuple`2<string, string>> GetItemsFromDatabaseRecord(RawDatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Analysis.AnalyzerCompilationCache/<GetItemsFromCluster>d__4")]
protected virtual IEnumerable`1<ValueTuple`2<string, string>> GetItemsFromCluster(ServerStore serverStore, TransactionOperationContext context);
    protected virtual AnalyzerFactory CompileItem(string name, string code);
}
public static class Raven.Server.Documents.Indexes.Analysis.AnalyzerCompiler : object {
    public static AnalyzerFactory Compile(string name, string analyzerCode);
    private static string GetCSharpSafeName(string name);
}
public class Raven.Server.Documents.Indexes.Analysis.AnalyzerFactory : object {
    public Type Type;
    public AnalyzerFactory(Type analyzerType);
    public virtual Analyzer CreateInstance(string fieldName);
}
public class Raven.Server.Documents.Indexes.Analysis.FaultyAnalyzerFactory : AnalyzerFactory {
    private string _name;
    private Exception _e;
    public FaultyAnalyzerFactory(string name, Exception e);
    public virtual Analyzer CreateInstance(string fieldName);
}
public class Raven.Server.Documents.Indexes.AsyncWaitForIndexing : object {
    private Stopwatch _queryDuration;
    private TimeSpan _waitTimeout;
    private Index _index;
    private bool _isMaxTimeout;
    public bool TimeoutExceeded;
    public AsyncWaitForIndexing(Stopwatch queryDuration, TimeSpan waitTimeout, Index index);
    public Task WaitForIndexingAsync(FrozenAwaiter indexingBatchCompleted);
}
internal abstract class Raven.Server.Documents.Indexes.Auto.AutoIndexDefinitionBaseServerSide : IndexDefinitionBaseServerSide`1<AutoIndexField> {
    internal AutoIndexDefinitionBaseServerSide(string indexName, string collection, AutoIndexField[] fields, Nullable`1<IndexDeploymentMode> deploymentMode, IndexDefinitionClusterState clusterState, Nullable`1<long> indexVersion);
    protected abstract virtual void PersistFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected virtual void PersistMapFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected internal abstract virtual IndexDefinition GetOrCreateIndexDefinitionInternal();
    public abstract virtual IndexDefinitionCompareDifferences Compare(IndexDefinitionBaseServerSide indexDefinition);
    public abstract virtual IndexDefinitionCompareDifferences Compare(IndexDefinition indexDefinition);
    protected abstract virtual int ComputeRestOfHash(int hashCode);
}
public class Raven.Server.Documents.Indexes.Auto.AutoIndexDocsEnumerator : object {
    private IndexingStatsScope _documentReadStats;
    private IEnumerator`1<IndexItem> _itemsEnumerator;
    private Document[] _results;
    public IndexItem Current { get; }
    public AutoIndexDocsEnumerator(IEnumerable`1<IndexItem> items, IndexingStatsScope stats);
    public sealed virtual bool MoveNext(DocumentsOperationContext ctx, IEnumerable& resultsOfCurrentDocument, Nullable`1& etag);
    public sealed virtual void OnError();
    public sealed virtual IndexItem get_Current();
    public sealed virtual void Dispose();
}
internal class Raven.Server.Documents.Indexes.Auto.AutoMapIndex : MapIndexBase`2<AutoMapIndexDefinition, AutoIndexField> {
    private AutoMapIndex(AutoMapIndexDefinition definition);
    public static AutoMapIndex CreateNew(AutoMapIndexDefinition definition, DocumentDatabase documentDatabase);
    public static AutoMapIndex Open(StorageEnvironment environment, DocumentDatabase documentDatabase);
    public virtual IIndexedItemEnumerator GetMapEnumerator(IEnumerable`1<IndexItem> items, string collection, TransactionOperationContext indexContext, IndexingStatsScope stats, IndexType type);
    public virtual void Update(IndexDefinitionBaseServerSide definition, IndexingConfiguration configuration);
    public virtual void SetState(IndexState state, bool inMemoryOnly, bool ignoreWriteError);
    public virtual ValueTuple`2<ICollection`1<string>, ICollection`1<string>> GetEntriesFields();
    protected virtual void LoadValues();
}
internal class Raven.Server.Documents.Indexes.Auto.AutoMapIndexDefinition : AutoIndexDefinitionBaseServerSide {
    internal AutoMapIndexDefinition(string indexName, string collection, AutoIndexField[] fields, Nullable`1<IndexDeploymentMode> deploymentMode, IndexDefinitionClusterState clusterState, Nullable`1<long> indexVersion);
    public AutoMapIndexDefinition(string collection, AutoIndexField[] fields, Nullable`1<long> indexVersion);
    protected virtual void PersistFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected internal virtual IndexDefinition GetOrCreateIndexDefinitionInternal();
    public virtual IndexDefinitionCompareDifferences Compare(IndexDefinitionBaseServerSide other);
    public virtual IndexDefinitionCompareDifferences Compare(IndexDefinition indexDefinition);
    protected virtual int ComputeRestOfHash(int hashCode);
    public static AutoMapIndexDefinition Load(StorageEnvironment environment);
    public static AutoMapIndexDefinition LoadFromJson(BlittableJsonReaderObject reader);
    [CompilerGeneratedAttribute]
private void <GetOrCreateIndexDefinitionInternal>g__AddFields|3_0(IEnumerable`1<string> mapFields, IEnumerable`1<ValueTuple`2<string, IndexFieldOptions>> indexFields, <>c__DisplayClass3_0& );
}
public class Raven.Server.Documents.Indexes.AutoIndexField : IndexFieldBase {
    [CompilerGeneratedAttribute]
private AggregationOperation <Aggregation>k__BackingField;
    [CompilerGeneratedAttribute]
private GroupByArrayBehavior <GroupByArrayBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasQuotedName>k__BackingField;
    [CompilerGeneratedAttribute]
private AutoFieldIndexing <Indexing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private AutoSpatialOptions <Spatial>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SamePathToArrayAsGroupByField>k__BackingField;
    public AggregationOperation Aggregation { get; public set; }
    public GroupByArrayBehavior GroupByArrayBehavior { get; public set; }
    public bool HasQuotedName { get; public set; }
    public AutoFieldIndexing Indexing { get; public set; }
    public int Id { get; public set; }
    public AutoSpatialOptions Spatial { get; public set; }
    public bool SamePathToArrayAsGroupByField { get; public set; }
    [CompilerGeneratedAttribute]
public AggregationOperation get_Aggregation();
    [CompilerGeneratedAttribute]
public void set_Aggregation(AggregationOperation value);
    [CompilerGeneratedAttribute]
public GroupByArrayBehavior get_GroupByArrayBehavior();
    [CompilerGeneratedAttribute]
public void set_GroupByArrayBehavior(GroupByArrayBehavior value);
    [CompilerGeneratedAttribute]
public bool get_HasQuotedName();
    [CompilerGeneratedAttribute]
public void set_HasQuotedName(bool value);
    [CompilerGeneratedAttribute]
public AutoFieldIndexing get_Indexing();
    [CompilerGeneratedAttribute]
public void set_Indexing(AutoFieldIndexing value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public AutoSpatialOptions get_Spatial();
    [CompilerGeneratedAttribute]
public void set_Spatial(AutoSpatialOptions value);
    [CompilerGeneratedAttribute]
public bool get_SamePathToArrayAsGroupByField();
    [CompilerGeneratedAttribute]
public void set_SamePathToArrayAsGroupByField(bool value);
    public static AutoIndexField Create(string name, AutoIndexFieldOptions options);
    public List`1<IndexField> ToIndexFields(Reference`1<int> lastUsedId);
    private bool Equals(AutoIndexField other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static string GetSearchAutoIndexFieldName(string name);
    public static string GetExactAutoIndexFieldName(string name);
    public static string GetHighlightingAutoIndexFieldName(string name);
    public static string GetGroupByArrayContentAutoIndexFieldName(string name);
    public static string GetSuggestionsAutoIndexFieldName(string name);
}
public class Raven.Server.Documents.Indexes.AutoIndexNameFinder : object {
    public static string AutoIndexPrefix;
    public static string FindMapIndexName(string collection, IReadOnlyCollection`1<AutoIndexField> fields);
    public static string FindMapReduceIndexName(string collection, IReadOnlyCollection`1<AutoIndexField> fields, IReadOnlyCollection`1<AutoIndexField> groupBy);
    private static string FindName(string collection, IReadOnlyCollection`1<AutoIndexField> fields, bool isMapReduce);
    private static string GetName(AutoIndexField x);
}
public static class Raven.Server.Documents.Indexes.BloomFilterVersion : object {
    public static long BaseVersion;
    public static long PartitionFix;
    public static long CurrentVersion;
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Documents.Indexes.CollectionOfBloomFilters : object {
    private static string BloomFiltersTreeName;
    private static Slice Count64Slice;
    private static Slice Count32Slice;
    internal static Slice VersionSlice;
    private TransactionOperationContext _context;
    private BloomFilter[] _filters;
    private BloomFilter _currentFilter;
    private Mode _mode;
    public long Version;
    private Tree _tree;
    public bool Consumed;
    private static long _consumed;
    public long CurrentFilterCount { get; }
    public int Count { get; }
    public BloomFilter Item { get; }
    private static CollectionOfBloomFilters();
    private CollectionOfBloomFilters(Mode mode, long version, Tree tree, TransactionOperationContext context);
    public long get_CurrentFilterCount();
    public int get_Count();
    public BloomFilter get_Item(int index);
    public static CollectionOfBloomFilters Load(Mode mode, TransactionOperationContext indexContext);
    internal static long GetVersion(Tree tree, bool isNew);
    private static long GetCount(Tree tree, Mode& mode);
    private void Initialize();
    internal BloomFilter CreateNewFilter(int number, Mode mode);
    internal void AddFilter(BloomFilter filter);
    public bool Add(LazyStringValue key);
    public void DirectAdd(LazyStringValue key);
    public bool Contains(LazyStringValue key);
    private void ExpandFiltersIfNecessary();
    public void Flush();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.CollectionOfIndexes : object {
    private ConcurrentDictionary`2<string, Index> _indexesByName;
    private ConcurrentDictionary`2<string, ConcurrentSet`1<Index>> _indexesByCollection;
    public int Count { get; }
    public void Add(Index index);
    public void ReplaceIndex(string name, Index oldIndex, Index newIndex);
    public bool TryRemoveByName(string name, Index existingInstance);
    public bool TryGetByName(string name, Index& index);
    public IEnumerable`1<Index> GetForCollection(string collection);
    public sealed virtual IEnumerator`1<Index> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int get_Count();
}
public abstract class Raven.Server.Documents.Indexes.CompiledIndexField : object {
    public string Name;
    protected CompiledIndexField(string name);
    protected virtual bool Equals(CompiledIndexField other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IsMatch(string name);
    public abstract virtual void WriteTo(StringBuilder sb);
    public abstract virtual object GetValue(object value, object blittableValue);
}
public class Raven.Server.Documents.Indexes.ConcurrentLruRegexCache : object {
    public static int DefaultCapacity;
    private ConcurrentDictionary`2<string, ConcurrentLruRegexCacheNode> _regexCache;
    private int _capacity;
    private TimeSpan _regexTimeout;
    private long _count;
    private bool _neverCompile;
    private DateTime _lastClearTime;
    private int _halfCapacity;
    public ConcurrentLruRegexCache(int capacity, TimeSpan regexTimeout);
    public Regex Get(string pattern);
    private static void UpdateTimestamp(ConcurrentLruRegexCacheNode result);
    private Regex GetUnlikely(string pattern);
    private void ClearOldItems();
}
internal class Raven.Server.Documents.Indexes.ConcurrentLruRegexCacheNode : object {
    public long Timestamp;
    [CompilerGeneratedAttribute]
private Lazy`1<Regex> <RegexLazy>k__BackingField;
    public Lazy`1<Regex> RegexLazy { get; }
    public ConcurrentLruRegexCacheNode(string pattern, TimeSpan regexTimeout, RegexOptions options);
    [CompilerGeneratedAttribute]
public Lazy`1<Regex> get_RegexLazy();
}
public class Raven.Server.Documents.Indexes.Configuration.FaultyInMemoryIndexConfiguration : IndexingConfiguration {
    private PathSetting _storagePath;
    public bool RunInMemory { get; }
    public PathSetting StoragePath { get; }
    public FaultyInMemoryIndexConfiguration(PathSetting storagePath, RavenConfiguration databaseConfiguration);
    public virtual bool get_RunInMemory();
    public virtual PathSetting get_StoragePath();
}
public enum Raven.Server.Documents.Indexes.Configuration.IndexUpdateType : Enum {
    public int value__;
    public static IndexUpdateType None;
    public static IndexUpdateType Refresh;
    public static IndexUpdateType Reset;
}
[AttributeUsageAttribute("128")]
public class Raven.Server.Documents.Indexes.Configuration.IndexUpdateTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IndexUpdateType <UpdateType>k__BackingField;
    public IndexUpdateType UpdateType { get; }
    public IndexUpdateTypeAttribute(IndexUpdateType updateType);
    [CompilerGeneratedAttribute]
public IndexUpdateType get_UpdateType();
}
public class Raven.Server.Documents.Indexes.Configuration.SingleIndexConfiguration : IndexingConfiguration {
    private RavenConfiguration _databaseConfiguration;
    public bool Disabled { get; }
    public bool RunInMemory { get; }
    public PathSetting TempPath { get; }
    public SingleIndexConfiguration(IndexConfiguration clientConfiguration, RavenConfiguration databaseConfiguration);
    public virtual bool get_Disabled();
    public virtual bool get_RunInMemory();
    public virtual PathSetting get_TempPath();
    public IndexUpdateType CalculateUpdateType(SingleIndexConfiguration newConfiguration);
}
public class Raven.Server.Documents.Indexes.CounterIndexItem : IndexItem {
    public CounterIndexItem(LazyStringValue id, LazyStringValue sourceDocumentId, long etag, LazyStringValue counterName, int size, object item);
    protected virtual string ToStringInternal();
}
public class Raven.Server.Documents.Indexes.DatabaseIndexCreateController : AbstractIndexCreateController {
    private DocumentDatabase _database;
    public DatabaseIndexCreateController(DocumentDatabase database);
    protected virtual string GetDatabaseName();
    protected virtual SystemTime GetDatabaseTime();
    public virtual RavenConfiguration GetDatabaseConfiguration();
    protected virtual IndexInformationHolder GetIndex(string name);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.DatabaseIndexCreateController/<GetIndexNames>d__6")]
protected virtual IEnumerable`1<string> GetIndexNames();
    protected virtual ValueTask`1<long> GetCollectionCountAsync(string collection);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.DatabaseIndexCreateController/<GetIndexes>d__8")]
protected virtual IEnumerable`1<IndexInformationHolder> GetIndexes();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.DatabaseIndexCreateController/<WaitForIndexNotificationAsync>d__9")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index, Nullable`1<TimeSpan> timeout);
}
public class Raven.Server.Documents.Indexes.DatabaseIndexDeleteController : AbstractIndexDeleteController {
    private DocumentDatabase _database;
    public DatabaseIndexDeleteController(DocumentDatabase database);
    protected virtual string GetDatabaseName();
    protected virtual IndexDefinitionBaseServerSide GetIndexDefinition(string name);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.DatabaseIndexDeleteController/<CreateIndexAsync>d__4")]
protected virtual ValueTask CreateIndexAsync(IndexDefinition definition, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.DatabaseIndexDeleteController/<WaitForIndexNotificationAsync>d__5")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
public class Raven.Server.Documents.Indexes.DatabaseIndexHasChangedController : AbstractIndexHasChangedController {
    private DocumentDatabase _database;
    public DatabaseIndexHasChangedController(DocumentDatabase database);
    protected virtual IndexInformationHolder GetIndex(string name);
    protected virtual RavenConfiguration GetDatabaseConfiguration();
}
public class Raven.Server.Documents.Indexes.DatabaseIndexLockModeController : AbstractIndexLockModeController {
    private DocumentDatabase _database;
    public DatabaseIndexLockModeController(DocumentDatabase database);
    protected virtual string GetDatabaseName();
    protected virtual void ValidateIndex(string name, IndexLockMode mode);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.DatabaseIndexLockModeController/<WaitForIndexNotificationAsync>d__4")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
public class Raven.Server.Documents.Indexes.DatabaseIndexPriorityController : AbstractIndexPriorityController {
    private DocumentDatabase _database;
    public DatabaseIndexPriorityController(DocumentDatabase database);
    protected virtual string GetDatabaseName();
    protected virtual void ValidateIndex(string name, IndexPriority priority);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.DatabaseIndexPriorityController/<WaitForIndexNotificationAsync>d__4")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
public class Raven.Server.Documents.Indexes.DatabaseIndexStateController : AbstractIndexStateController {
    private DocumentDatabase _database;
    public DatabaseIndexStateController(DocumentDatabase database);
    protected virtual string GetDatabaseName();
    protected virtual void ValidateIndex(string name, IndexState state);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.DatabaseIndexStateController/<WaitForIndexNotificationAsync>d__4")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
[ExtensionAttribute]
public static class Raven.Server.Documents.Indexes.Debugging.IndexDebugExtensions : object {
    [ExtensionAttribute]
public static IDisposable GetIdentifiersOfMappedDocuments(Index self, string startsWith, long start, long take, IEnumerable`1& docIds);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Debugging.IndexDebugExtensions/<IterateKeys>d__1")]
private static IEnumerable`1<string> IterateKeys(IIterator it, string prefix, long start, long take, TransactionOperationContext context);
    private static bool SetupPrefix(IIterator it, string prefix, TransactionOperationContext context, Nullable`1& scope);
    [ExtensionAttribute]
public static IDisposable GetReduceTree(Index self, String[] docIds, IEnumerable`1& trees);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Debugging.IndexDebugExtensions/<IterateTrees>d__4")]
private static IEnumerable`1<ReduceTree> IterateTrees(Index self, List`1<FixedSizeTree> mapEntries, Tree reducePhaseTree, FixedSizeTree typePerHash, TransactionOperationContext indexContext, DisposableScope scope);
    private static ReduceTree RenderTree(Tree tree, ulong reduceKeyHash, Dictionary`2<long, string> idToDocIdHash, Index index, TransactionOperationContext context);
    private static string GetTreeName(BlittableJsonReaderObject reduceEntry, IndexDefinitionBaseServerSide indexDefinition, JsonOperationContext context);
    private static BlittableJsonReaderObject GetAggregationResult(long pageNumber, Table table, TransactionOperationContext context);
    private static ReduceTree RenderNestedSection(NestedMapResultsSection section, ulong reduceKeyHash, Dictionary`2<long, string> idToDocIdHash, Index index, TransactionOperationContext context);
    private static BlittableJsonReaderObject GetReduceResult(ulong reduceKeyHash, Index index, TransactionOperationContext context);
}
public class Raven.Server.Documents.Indexes.Debugging.MapResultInLeaf : object {
    public BlittableJsonReaderObject Data;
    public string Source;
}
public class Raven.Server.Documents.Indexes.Debugging.ReduceTree : object {
    public ReduceTreePage Root;
    public string Name;
    public string DisplayName;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfEntries>k__BackingField;
    public int Depth { get; public set; }
    public long PageCount { get; public set; }
    public long NumberOfEntries { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(int value);
    [CompilerGeneratedAttribute]
public long get_PageCount();
    [CompilerGeneratedAttribute]
public void set_PageCount(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfEntries();
    [CompilerGeneratedAttribute]
public void set_NumberOfEntries(long value);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Debugging.ReduceTreePage : object {
    private bool _disposed;
    private bool _isLeaf;
    [CompilerGeneratedAttribute]
private TreePage <Page>k__BackingField;
    public List`1<ReduceTreePage> Children;
    public List`1<MapResultInLeaf> Entries;
    public BlittableJsonReaderObject AggregationResult;
    public DecompressedLeafPage DecompressedLeaf;
    public TreePage Page { get; }
    public long PageNumber { get; }
    public ReduceTreePage(TreePage p);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public TreePage get_Page();
    public long get_PageNumber();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.DocumentIndexItem : IndexItem {
    public DocumentIndexItem(LazyStringValue id, LazyStringValue lowerId, long etag, DateTime lastModified, int size, object item, DocumentFlags flags);
    protected virtual string ToStringInternal();
}
internal class Raven.Server.Documents.Indexes.Errors.FaultyAutoIndexDefinition : IndexDefinitionBaseServerSide`1<IndexField> {
    public AutoIndexDefinitionBaseServerSide Definition;
    public FaultyAutoIndexDefinition(string name, HashSet`1<string> collections, IndexLockMode lockMode, IndexPriority priority, IndexState state, IndexField[] mapFields, AutoIndexDefinitionBaseServerSide definition);
    protected virtual void PersistMapFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected virtual void PersistFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected internal virtual IndexDefinition GetOrCreateIndexDefinitionInternal();
    protected virtual int ComputeRestOfHash(int hashCode);
    public virtual IndexDefinitionCompareDifferences Compare(IndexDefinitionBaseServerSide indexDefinition);
    public virtual IndexDefinitionCompareDifferences Compare(IndexDefinition indexDefinition);
    internal virtual void Reset();
}
public class Raven.Server.Documents.Indexes.Errors.FaultyIndexDefinition : IndexDefinitionBaseServerSide`1<IndexField> {
    private IndexDefinition _definition;
    public FaultyIndexDefinition(string name, IEnumerable`1<string> collections, IndexLockMode lockMode, IndexPriority priority, IndexState state, IndexField[] mapFields, IndexDefinition definition);
    protected virtual void PersistMapFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected virtual void PersistFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected internal virtual IndexDefinition GetOrCreateIndexDefinitionInternal();
    protected virtual int ComputeRestOfHash(int hashCode);
    public virtual IndexDefinitionCompareDifferences Compare(IndexDefinitionBaseServerSide indexDefinition);
    public virtual IndexDefinitionCompareDifferences Compare(IndexDefinition indexDefinition);
    internal virtual void Reset();
}
internal class Raven.Server.Documents.Indexes.Errors.FaultyInMemoryIndex : Index {
    private Exception _e;
    private DateTime _createdAt;
    public IndexRunningStatus Status { get; }
    public FaultyInMemoryIndex(Exception e, string name, IndexingConfiguration configuration, AutoIndexDefinitionBaseServerSide definition, SearchEngineType searchEngineType);
    public FaultyInMemoryIndex(Exception e, string name, IndexingConfiguration configuration, IndexDefinition definition, SearchEngineType searchEngineType);
    private FaultyInMemoryIndex(Exception e, IndexingConfiguration configuration, IndexDefinitionBaseServerSide definition, SearchEngineType searchEngineType);
    protected virtual IIndexingWork[] CreateIndexWorkExecutors();
    public virtual IIndexedItemEnumerator GetMapEnumerator(IEnumerable`1<IndexItem> items, string collection, TransactionOperationContext indexContext, IndexingStatsScope stats, IndexType type);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual int HandleMap(IndexItem indexItem, IEnumerable mapResults, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual IQueryResultRetriever GetQueryResultRetriever(IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsOperationContext documentsContext, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
    public virtual void Update(IndexDefinitionBaseServerSide definition, IndexingConfiguration configuration);
    public virtual void SaveLastState();
    public virtual void DeleteErrors();
    public virtual List`1<IndexingError> GetErrors();
    internal virtual IndexProgress GetProgress(QueryOperationContext queryContext, Stopwatch overallDuration, Nullable`1<bool> isStale);
    public virtual IndexStats GetStats(bool calculateLag, bool calculateStaleness, bool calculateMemoryStats, bool calculateLastBatchStats, QueryOperationContext queryContext);
    public virtual IndexRunningStatus get_Status();
    public virtual void Start();
    public virtual void Stop(bool disableIndex);
    public virtual void SetPriority(IndexPriority priority);
    public virtual void SetState(IndexState state, bool inMemoryOnly, bool ignoreWriteError);
    public virtual void Enable();
    public virtual void Disable();
    public virtual void SetLock(IndexLockMode mode);
    public virtual Task StreamQuery(HttpResponse response, IStreamQueryResultWriter`1<Document> writer, IndexQueryServerSide query, QueryOperationContext queryContext, OperationCancelToken token);
    public virtual Task`1<DocumentQueryResult> Query(IndexQueryServerSide query, QueryOperationContext queryContext, OperationCancelToken token);
    public virtual Task`1<FacetedQueryResult> FacetedQuery(FacetQuery query, QueryOperationContext queryContext, OperationCancelToken token);
    public virtual TermsQueryResultServerSide GetTerms(string field, string fromValue, long pageSize, QueryOperationContext queryContext, OperationCancelToken token);
    public virtual ValueTuple`2<ICollection`1<string>, ICollection`1<string>> GetEntriesFields();
}
public class Raven.Server.Documents.Indexes.GlobalIndexingScratchSpaceMonitor : object {
    public long LimitInBytes;
    public long ScratchSpaceInBytes;
    public Size LimitAsSize { get; }
    public Size ScratchSpaceAsSize { get; }
    public bool IsLimitExceeded { get; }
    public GlobalIndexingScratchSpaceMonitor(Size indexingGlobalScratchSpaceLimit);
    public Size get_LimitAsSize();
    public Size get_ScratchSpaceAsSize();
    public bool get_IsLimitExceeded();
    public sealed virtual void Increase(long allocatedScratchSpaceInBytes);
    public sealed virtual void Decrease(long releasedScratchSpaceInBytes);
}
public interface Raven.Server.Documents.Indexes.IIndexedItemEnumerator {
    public IndexItem Current { get; }
    public abstract virtual bool MoveNext(DocumentsOperationContext ctx, IEnumerable& resultsOfCurrentDocument, Nullable`1& etag);
    public abstract virtual void OnError();
    public abstract virtual IndexItem get_Current();
}
public abstract class Raven.Server.Documents.Indexes.Index : object {
    private int _writeErrors;
    private int _unexpectedErrors;
    private int _analyzerErrors;
    private int _diskFullErrors;
    private static int WriteErrorsLimit;
    private static int UnexpectedErrorsLimit;
    private static int AnalyzerErrorLimit;
    private static int DiskFullErrorLimit;
    internal static int LowMemoryPressure;
    private static int AllocationCleanupRequestsLimit;
    private Size MappedSizeLimitOn32Bits;
    protected Logger _logger;
    internal IndexPersistenceBase IndexPersistence;
    internal IndexFieldsPersistence IndexFieldsPersistence;
    private AsyncManualResetEvent _indexingBatchCompleted;
    private SemaphoreSlim _doingIndexingWork;
    private SemaphoreSlim _executingIndexing;
    private long _allocatedAfterPreviousCleanup;
    private CancellationTokenSource _indexingProcessCancellationTokenSource;
    private bool _indexDisabled;
    private ConcurrentDictionary`2<string, CollectionStats> _inMemoryIndexProgress;
    private ConcurrentDictionary`2<string, CollectionStats> _inMemoryReferencesIndexProgress;
    private ShardedDocumentDatabase _shardedDocumentDatabase;
    internal DocumentDatabase DocumentDatabase;
    internal LongRunningWork _indexingThread;
    private bool _initialized;
    internal UnmanagedBuffersPoolWithLowMemoryHandling _unmanagedBuffersPool;
    internal StorageEnvironment _environment;
    internal TransactionContextPool _contextPool;
    private ByteStringContext _indexAllocator;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Slice, Slice>> _compoundFields;
    internal ThrottledManualResetEventSlim _mre;
    private object _disablingIndexLock;
    private ManualResetEventSlim _logsAppliedEvent;
    private Nullable`1<DateTime> _lastQueryingTime;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastIndexingTime>k__BackingField;
    public Stopwatch TimeSpentIndexing;
    public HashSet`1<string> Collections;
    internal IndexStorage _indexStorage;
    private IIndexingWork[] _indexWorkers;
    private IndexingStatsAggregator _lastStats;
    private ConcurrentQueue`1<IndexingStatsAggregator> _lastIndexingStats;
    private bool _didWork;
    private bool _isReplacing;
    private string _lastPendingStatus;
    public MultipleUseFlag ForceReplace;
    protected bool HandleAllDocs;
    protected internal MeterMetric MapsPerSec;
    protected internal MeterMetric ReducesPerSec;
    protected internal IndexingConfiguration Configuration;
    protected PerformanceHintsConfiguration PerformanceHintsConfig;
    private int _allocationCleanupNeeded;
    private MultipleUseFlag _lowMemoryFlag;
    private long _lowMemoryPressure;
    private bool _batchStopped;
    private Size _currentMaximumAllowedMemory;
    internal ThreadStats _threadAllocations;
    private string _errorStateReason;
    private bool _isCompactionInProgress;
    public bool _firstQuery;
    internal Nullable`1<TimeSpan> _firstBatchTimeout;
    private Lazy`1<Nullable`1<Size>> _transactionSizeLimit;
    private bool _scratchSpaceLimitExceeded;
    private AsyncReaderWriterLock _currentlyRunningQueriesLock;
    private AsyncLocal`1<bool> _isRunningQueriesWriteLockTaken;
    private MultipleUseFlag _priorityChanged;
    private MultipleUseFlag _hadRealIndexingWorkToDo;
    private MultipleUseFlag _definitionChanged;
    private Size _initialManagedAllocations;
    private ConcurrentDictionary`2<string, SpatialField> _spatialFields;
    internal QueryBuilderFactories _queryBuilderFactories;
    private WarningDetails _indexOutputsPerDocumentWarning;
    private WarningDetails _referenceLoadWarning;
    private bool _updateReferenceLoadWarning;
    private static Size DefaultMaximumMemoryAllocation;
    private double _txAllocationsRatio;
    private string _itemType;
    internal bool SourceDocumentIncludedInOutput;
    private bool _alreadyNotifiedAboutIncludingDocumentInOutput;
    public TestIndexRun TestRun;
    private HashSet`1<string> _fieldsReportedAsComplex;
    private bool _newComplexFieldsToReport;
    [CompilerGeneratedAttribute]
private HashSet`1<IndexField> <ComplexFieldsNotIndexedByCorax>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexType <Type>k__BackingField;
    public SearchEngineType SearchEngineType;
    [CompilerGeneratedAttribute]
private IndexSourceType <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexDefinitionBaseServerSide <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfOutputsPerDocument>k__BackingField;
    private ManualResetEventSlim _rollingEvent;
    private int _numberOfDeployedNodes;
    private Task _rollingCompletionTask;
    private DisposeOnce`1<SingleAttempt> _disposeOnce;
    private ThreadStats _indexingThreadStats;
    internal static TimeSpan DefaultWaitForNonStaleResultsTimeout;
    private ConcurrentLruRegexCache _regexCache;
    private Nullable`1<int> _minBatchSize;
    private static int MinMapBatchSize;
    internal static int MinMapReduceBatchSize;
    [CompilerGeneratedAttribute]
private CoraxComplexFieldIndexingBehavior <CoraxComplexFieldIndexingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchivedDataProcessingBehavior <ArchivedDataProcessingBehavior>k__BackingField;
    private DateTime _lastCheckedFlushLock;
    internal TestingStuff _forTestingPurposes;
    internal CancellationToken IndexingProcessCancellationToken { get; }
    private bool CalledUnderIndexingThread { get; }
    public Nullable`1<DateTime> LastIndexingTime { get; private set; }
    public bool IsRolling { get; }
    public bool DeployedOnAllNodes { get; }
    public string NormalizedName { get; }
    internal bool HadRealIndexingWork { get; }
    private string IndexingThreadName { get; }
    public Nullable`1<long> LastTransactionId { get; }
    internal bool IsLowMemory { get; }
    public bool IsTestRun { get; }
    public HashSet`1<IndexField> ComplexFieldsNotIndexedByCorax { get; private set; }
    public IndexType Type { get; }
    public IndexSourceType SourceType { get; }
    public IndexState State { get; protected set; }
    public IndexDefinitionBaseServerSide Definition { get; private set; }
    public string Name { get; }
    public int MaxNumberOfOutputsPerDocument { get; private set; }
    public IndexRunningStatus Status { get; }
    public bool HasBoostedFields { get; }
    public bool IsMultiMap { get; }
    public bool IsPending { get; }
    public bool IsDisposed { get; }
    public string TombstoneCleanerIdentifier { get; }
    private int MinBatchSize { get; }
    private Nullable`1<Size> TransactionSizeLimit { get; }
    public CoraxComplexFieldIndexingBehavior CoraxComplexFieldIndexingBehavior { get; private set; }
    public ArchivedDataProcessingBehavior ArchivedDataProcessingBehavior { get; private set; }
    protected Index(IndexType type, IndexSourceType sourceType, IndexDefinitionBaseServerSide definition);
    private static Index();
    internal CancellationToken get_IndexingProcessCancellationToken();
    private bool get_CalledUnderIndexingThread();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastIndexingTime();
    [CompilerGeneratedAttribute]
private void set_LastIndexingTime(Nullable`1<DateTime> value);
    public bool get_IsRolling();
    public bool get_DeployedOnAllNodes();
    public string get_NormalizedName();
    internal bool get_HadRealIndexingWork();
    private string get_IndexingThreadName();
    public Nullable`1<long> get_LastTransactionId();
    internal bool get_IsLowMemory();
    public bool get_IsTestRun();
    [CompilerGeneratedAttribute]
public HashSet`1<IndexField> get_ComplexFieldsNotIndexedByCorax();
    [CompilerGeneratedAttribute]
private void set_ComplexFieldsNotIndexedByCorax(HashSet`1<IndexField> value);
    public void ScheduleIndexingRun();
    protected virtual void DisposeIndex();
    public static Index Open(string path, DocumentDatabase documentDatabase, bool generateNewDatabaseId, SearchEngineType& searchEngineType);
    [CompilerGeneratedAttribute]
public IndexType get_Type();
    [CompilerGeneratedAttribute]
public IndexSourceType get_SourceType();
    [CompilerGeneratedAttribute]
public IndexState get_State();
    [CompilerGeneratedAttribute]
protected void set_State(IndexState value);
    [CompilerGeneratedAttribute]
public IndexDefinitionBaseServerSide get_Definition();
    [CompilerGeneratedAttribute]
private void set_Definition(IndexDefinitionBaseServerSide value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfOutputsPerDocument();
    [CompilerGeneratedAttribute]
private void set_MaxNumberOfOutputsPerDocument(int value);
    public bool IsInvalidIndex();
    public virtual IndexRunningStatus get_Status();
    public virtual bool get_HasBoostedFields();
    public virtual bool get_IsMultiMap();
    public virtual void ResetIsSideBySideAfterReplacement();
    public FrozenAwaiter GetIndexingBatchAwaiter();
    [DoesNotReturnAttribute]
internal static void ThrowObjectDisposed();
    protected void Initialize(DocumentDatabase documentDatabase, IndexingConfiguration configuration, PerformanceHintsConfiguration performanceHints);
    private void InitializeMetrics(IndexingConfiguration configuration);
    public CurrentIndexingScope CreateIndexingScope(TransactionOperationContext indexContext, QueryOperationContext queryContext);
    private StorageEnvironmentOptions CreateStorageEnvironmentOptions(DocumentDatabase documentDatabase, IndexingConfiguration configuration);
    private static void InitializeOptions(StorageEnvironmentOptions options, DocumentDatabase documentDatabase, string name, bool schemaUpgrader, SearchEngineType searchEngineType);
    internal IDisposable DrainRunningQueries();
    protected void Initialize(StorageEnvironment environment, DocumentDatabase documentDatabase, IndexingConfiguration configuration, PerformanceHintsConfiguration performanceHints);
    private void InitializeInternal(StorageEnvironment environment, DocumentDatabase documentDatabase, IndexingConfiguration configuration, PerformanceHintsConfiguration performanceHints);
    public bool HasCompoundField(Slice first, Slice second, Int32& bindingId);
    private void InitializeCompoundFields();
    private bool IsStaleInternal(List`1<string> stalenessReasons);
    private void InitializeComponentsUsingEnvironment(DocumentDatabase documentDatabase, StorageEnvironment environment);
    protected virtual void OnInitialization();
    protected virtual void LoadValues();
    public virtual void Start();
    private void StartIndexingThread();
    public void RollIfNeeded();
    private void CompleteIfRollingSideBySideRemoved();
    private int GetNumberOfDeployedNodes();
    private void RaiseNotificationIfNeeded();
    public bool get_IsPending();
    private void GetPendingAndReplaceStatus(Boolean& pending, Boolean& replace);
    private void MaybeFinishRollingDeployment();
    private void ReportUnexpectedIndexingError(Exception e);
    public virtual void Stop(bool disableIndex);
    private LongRunningWork GetWaitForIndexingThreadToExit(bool disableIndex);
    public virtual void Update(IndexDefinitionBaseServerSide definition, IndexingConfiguration configuration);
    internal bool UpdateIndexState(IndexDefinitionBaseServerSide definition, bool autoIndex);
    public bool get_IsDisposed();
    public sealed virtual void Dispose();
    public bool IsStale(QueryOperationContext queryContext, Nullable`1<long> cutoff, List`1<string> stalenessReasons);
    public IndexingState GetIndexingState(QueryOperationContext queryContext);
    protected virtual IndexingState GetIndexingStateInternal(QueryOperationContext queryContext, TransactionOperationContext indexContext);
    protected virtual IndexItem GetItemByEtag(QueryOperationContext queryContext, long etag);
    protected virtual IndexItem GetTombstoneByEtag(QueryOperationContext queryContext, long etag);
    protected virtual bool HasTombstonesWithEtagGreaterThanStartAndLowerThanOrEqualToEnd(QueryOperationContext context, string collection, long start, long end);
    internal virtual bool IsStale(QueryOperationContext queryContext, TransactionOperationContext indexContext, Nullable`1<long> cutoff, Nullable`1<long> referenceCutoff, Nullable`1<long> compareExchangeReferenceCutoff, List`1<string> stalenessReasons);
    public long GetLastMappedEtagFor(string collection);
    public Dictionary`2<string, long> GetLastMappedEtagsForDebug();
    protected void ExecuteIndexing();
    public ReplaceStatus ReplaceIfNeeded(bool batchCompleted, bool didWork);
    private void PauseIfCpuCreditsBalanceIsTooLow();
    private void NotifyAboutCompletedBatch(bool didWork);
    public void Cleanup(IndexCleanup mode);
    protected virtual bool ShouldReplace();
    private void ChangeIndexThreadPriority();
    private void PersistIndexDefinition();
    private void HandleLogsApplied();
    private void ReduceMemoryUsage(StorageEnvironment environment, IndexCleanup mode);
    internal void ResetErrors();
    internal void HandleAnalyzerErrors(IndexingStatsScope stats, IndexAnalyzerException iae);
    internal void HandleUnexpectedErrors(IndexingStatsScope stats, Exception e);
    internal void HandleCriticalErrors(IndexingStatsScope stats, CriticalIndexingException e);
    internal void HandleWriteErrors(IndexingStatsScope stats, IndexWriteException iwe);
    internal void HandleExcessiveNumberOfReduceErrors(IndexingStatsScope stats, ExcessiveNumberOfReduceErrorsException e);
    internal void HandleDiskFullErrors(IndexingStatsScope stats, StorageEnvironment storageEnvironment, DiskFullException dfe);
    private void FlushAndSync(StorageEnvironment storageEnvironment, int timeToWaitInMilliseconds, bool tryCleanupRecycledJournals);
    private void SetErrorState(string reason);
    private void HandleOutOfMemoryException(IndexingStatsScope scope, StorageEnvironment storageEnvironment, Exception exception);
    private void HandleIndexCorruption(IndexingStatsScope stats, Exception e);
    private void HandleIndexFailureInformation(IndexFailureInformation failureInformation);
    public void ErrorIndexIfCriticalException(Exception e);
    protected abstract virtual IIndexingWork[] CreateIndexWorkExecutors();
    public virtual IDisposable InitializeIndexingWork(TransactionOperationContext indexContext);
    public virtual InMemoryReferencesInfo GetInMemoryReferencesState(string collection, bool isCompareExchange);
    public void InitializeTestRun(DocumentsOperationContext context, int docsToProcessPerCollection, int numberOfCollections);
    public bool DoIndexingWork(IndexingStatsScope stats, CancellationToken cancellationToken);
    private void HandleReferences(RavenTransaction tx);
    internal void SetFieldIsIndexedAsJsonViaCoraxAutoIndex(IndexField field);
    public void SetComplexFieldNotIndexedByCoraxStaticIndex(IndexField field);
    private void HandleComplexFieldsAlert();
    private void HandleMismatchedReferences();
    private void DisposeIndexWriterOnError(Lazy`1<IndexWriteOperationBase> writeOperation);
    public abstract virtual IIndexedItemEnumerator GetMapEnumerator(IEnumerable`1<IndexItem> items, string collection, TransactionOperationContext indexContext, IndexingStatsScope stats, IndexType type);
    public abstract virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public abstract virtual int HandleMap(IndexItem indexItem, IEnumerable mapResults, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual bool MustDeleteArchivedDocument(IndexItem indexItem);
    public virtual void DeleteArchived(IndexItem indexItem, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats, LazyStringValue lowerId);
    private void HandleIndexChange(IndexChange change);
    protected virtual void SubscribeToChanges(DocumentDatabase documentDatabase);
    protected virtual void UnsubscribeFromChanges(DocumentDatabase documentDatabase);
    protected virtual void HandleDocumentChange(DocumentChange change);
    protected virtual void HandleCompareExchangeChange(CompareExchangeChange change);
    public virtual void DeleteErrors();
    public virtual List`1<IndexingError> GetErrors();
    public long GetErrorCount();
    public Nullable`1<DateTime> GetLastIndexingErrorTime();
    public virtual void SetPriority(IndexPriority priority);
    public virtual void SetState(IndexState state, bool inMemoryOnly, bool ignoreWriteError);
    private static IndexChangeTypes GetIndexChangeType(IndexState state, IndexState oldState);
    public virtual void SetLock(IndexLockMode mode);
    public virtual void Enable();
    public virtual void Disable();
    public void Rename(string name);
    internal virtual IndexProgress GetProgress(QueryOperationContext queryContext, Stopwatch overallDuration, Nullable`1<bool> isStale);
    private void UpdateIndexProgress(QueryOperationContext queryContext, IndexProgress progress, IndexStats stats, Stopwatch overallDuration);
    internal virtual void UpdateProgressStats(QueryOperationContext queryContext, CollectionStats progressStats, string collectionName, Stopwatch overallDuration);
    private IEnumerable`1<string> GetCollections(QueryOperationContext queryContext, Boolean& isAllDocs);
    internal CollectionStats GetStats(string collection);
    internal CollectionStats GetReferencesStats(string collection);
    private static ValueTuple`2<long, long> GetLastEtags(ConcurrentDictionary`2<string, CollectionStats> indexProgressStats, string collection, long lastProcessedDocumentEtag, long lastProcessedTombstoneEtag);
    public virtual IndexStats GetStats(bool calculateLag, bool calculateStaleness, bool calculateMemoryStats, bool calculateLastBatchStats, QueryOperationContext queryContext);
    internal HashSet`1<string> GetReferencedCollectionNames();
    private MemoryStats GetMemoryStats();
    public Nullable`1<DateTime> GetLastQueryingTime();
    public bool NoQueryRecently();
    private void MarkQueried(DateTime time);
    public IndexDefinition GetIndexDefinition();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Index/<StreamQuery>d__261")]
public virtual Task StreamQuery(HttpResponse response, IStreamQueryResultWriter`1<Document> writer, IndexQueryServerSide query, QueryOperationContext queryContext, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Index/<StreamIndexEntriesQuery>d__262")]
public virtual Task StreamIndexEntriesQuery(HttpResponse response, IStreamQueryResultWriter`1<BlittableJsonReaderObject> writer, IndexQueryServerSide query, QueryOperationContext queryContext, bool ignoreLimit, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Index/<IdQuery>d__263")]
public virtual Task`1<DocumentIdQueryResult> IdQuery(IndexQueryServerSide query, QueryOperationContext queryContext, DeterminateProgress progress, Action`1<DeterminateProgress> onProgress, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Index/<Query>d__264")]
public virtual Task`1<DocumentQueryResult> Query(IndexQueryServerSide query, QueryOperationContext queryContext, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Index/<QueryInternal>d__265`1")]
private Task QueryInternal(TQueryResult resultToFill, IndexQueryServerSide query, QueryOperationContext queryContext, bool pulseDocsReadingTransaction, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Index/<IndexEntriesQueryInternal>d__266`1")]
private Task IndexEntriesQueryInternal(TQueryResult resultToFill, IndexQueryServerSide query, QueryOperationContext queryContext, bool ignoreLimit, OperationCancelToken token);
    private void QueryInternalPreparation(IndexQueryServerSide query);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Index/<FacetedQuery>d__268")]
public virtual Task`1<FacetedQueryResult> FacetedQuery(FacetQuery facetQuery, QueryOperationContext queryContext, OperationCancelToken token);
    public virtual TermsQueryResultServerSide GetTerms(string field, string fromValue, long pageSize, QueryOperationContext queryContext, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Index/<SuggestionQuery>d__270")]
public virtual Task`1<SuggestionQueryResult> SuggestionQuery(IndexQueryServerSide query, QueryOperationContext queryContext, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Index/<IndexEntries>d__271")]
public virtual Task`1<IndexEntriesQueryResult> IndexEntries(IndexQueryServerSide query, QueryOperationContext queryContext, bool ignoreLimit, OperationCancelToken token);
    public abstract virtual ValueTuple`2<ICollection`1<string>, ICollection`1<string>> GetEntriesFields();
    protected List`1<string> GetDynamicEntriesFields(HashSet`1<string> staticFields);
    private void AssertIndexState(bool assertState);
    private ValueTuple`3<long, Nullable`1<long>, Nullable`1<long>> GetCutoffEtag(QueryOperationContext queryContext);
    [DoesNotReturnAttribute]
private void ThrowErrored();
    [DoesNotReturnAttribute]
private void ThrowMarkedAsError(string errorStateReason);
    [DoesNotReturnAttribute]
private void ThrowWasDisposed();
    [DoesNotReturnAttribute]
private void ThrowNotInitialized();
    [DoesNotReturnAttribute]
private void ThrowCompactionInProgress();
    private void AssertQueryDoesNotContainFieldsThatAreNotIndexed(QueryMetadata metadata);
    private void AssertKnownField(string f, QueryMetadata queryMetadata);
    private static void ThrowInvalidField(string f, QueryMetadata queryMetadata);
    private void FillFacetedQueryResult(FacetedQueryResult result, bool isStale, long facetSetupEtag, QueryMetadata q, QueryOperationContext queryContext, TransactionOperationContext indexContext);
    private void FillSuggestionQueryResult(SuggestionQueryResult result, bool isStale, QueryMetadata q, QueryOperationContext queryContext, TransactionOperationContext indexContext);
    private void FillQueryResult(QueryResultBase`2<TResult, TInclude> result, bool isStale, QueryMetadata q, QueryOperationContext queryContext, TransactionOperationContext indexContext);
    private IndexQueryDoneRunning MarkQueryAsRunning(IIndexQuery query);
    protected IndexQueryDoneRunning CurrentlyInUse(Boolean& available);
    protected IndexQueryDoneRunning CurrentlyInUse();
    private IDisposable EnsureSingleIndexingThread();
    internal static bool WillResultBeAcceptable(bool isStale, IndexQueryBase`1<BlittableJsonReaderObject> query, AsyncWaitForIndexing wait);
    protected virtual long CalculateIndexEtag(QueryOperationContext queryContext, TransactionOperationContext indexContext, QueryMetadata q, bool isStale);
    public long CalculateIndexEtagWithReferences(HandleReferences handleReferences, HandleReferences handleCompareExchangeReferences, QueryOperationContext queryContext, TransactionOperationContext indexContext, QueryMetadata query, bool isStale, HashSet`1<string> referencedCollections, AbstractStaticIndexBase compiled);
    private static void UseAllDocumentsCounterCmpXchgAndTimeSeriesEtags(QueryOperationContext queryContext, QueryMetadata q, int length, Byte* indexEtagBytes);
    private int MinimumSizeForCalculateIndexEtagLength(QueryMetadata q);
    private void CalculateIndexEtagInternal(Byte* indexEtagBytes, bool isStale, IndexState indexState, QueryOperationContext queryContext, TransactionOperationContext indexContext);
    public long GetIndexEtag(QueryOperationContext context, QueryMetadata q);
    public sealed virtual string get_TombstoneCleanerIdentifier();
    public virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType tombstoneType);
    public sealed virtual Dictionary`2<TombstoneDeletionBlockageSource, HashSet`1<string>> GetDisabledSubscribersCollections(HashSet`1<string> tombstoneCollections);
    internal Dictionary`2<string, long> GetLastProcessedDocumentTombstonesPerCollection(RavenTransaction tx);
    private void AddIndexingPerformance(IndexingStatsAggregator stats);
    public IndexingPerformanceStats[] GetIndexingPerformance();
    public IndexingStatsAggregator GetLatestIndexingStat();
    public abstract virtual IQueryResultRetriever GetQueryResultRetriever(IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsOperationContext documentsContext, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
    public abstract virtual void SaveLastState();
    protected void HandleSourceDocumentIncludedInMapOutput();
    protected void HandleIndexOutputsPerDocument(LazyStringValue documentId, int numberOfOutputs, IndexingStatsScope stats);
    public void CheckReferenceLoadsPerformanceHintLimit(Reference reference, int numberOfLoads);
    public virtual Dictionary`2<string, HashSet`1<CollectionName>> GetReferencedCollections();
    public virtual bool WorksOnAnyCollection(HashSet`1<string> collections);
    private int get_MinBatchSize();
    private Nullable`1<Size> get_TransactionSizeLimit();
    [CompilerGeneratedAttribute]
public CoraxComplexFieldIndexingBehavior get_CoraxComplexFieldIndexingBehavior();
    [CompilerGeneratedAttribute]
private void set_CoraxComplexFieldIndexingBehavior(CoraxComplexFieldIndexingBehavior value);
    [CompilerGeneratedAttribute]
public ArchivedDataProcessingBehavior get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
private void set_ArchivedDataProcessingBehavior(ArchivedDataProcessingBehavior value);
    internal ArchivedDataProcessingBehavior GetDefaultArchivedDataProcessingBehavior();
    private bool ShouldReleaseTransactionBecauseFlushIsWaiting(IndexingStatsScope stats, IndexingWorkType type);
    public CanContinueBatchResult CanContinueBatch(CanContinueBatchParameters& parameters, TimeSpan& maxTimeForDocumentTransactionToRemainOpen);
    public long UpdateThreadAllocations(TransactionOperationContext indexingContext, Lazy`1<IndexWriteOperationBase> indexWriteOperation, IndexingStatsScope stats, IndexingWorkType workType);
    private void HandleStoppedBatchesConcurrently(IndexingStatsScope stats, long count, Func`1<bool> canContinue, string reason, IndexingWorkType type);
    public void Compact(Action`1<IOperationProgress> onProgress, CompactionResult result, bool shouldSkipOptimization, CancellationToken token);
    public void Optimize(IndexOptimizeResult result, CancellationToken token);
    private void OptimizeInternal(CancellationToken token);
    private void AssertCompactionOrOptimizationIsNotInProgress(string name, string operation);
    public IDisposable RestartEnvironment(Action onBeforeEnvironmentDispose);
    public Size CalculateIndexStorageSize();
    public long GetLastEtagInCollection(QueryOperationContext queryContext, string collection);
    public virtual long GetLastItemEtagInCollection(QueryOperationContext queryContext, string collection);
    public virtual long GetLastTombstoneEtagInCollection(QueryOperationContext queryContext, string collection);
    public virtual DetailedStorageReport GenerateStorageReport(bool calculateExactSizes);
    public virtual string ToString();
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    internal void SimulateLowMemory();
    private Regex GetOrAddRegex(string arg);
    private SpatialField GetOrAddSpatialField(string name);
    private static bool TryFindIndexDefinition(string directoryName, RawDatabaseRecord record, IndexDefinition& staticDef, AutoIndexDefinition& autoDef);
    public void AssertNotDisposed();
    public int Dump(string path, Action`1<IOperationProgress> onProgress);
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
private void <.ctor>b__109_0();
    [CompilerGeneratedAttribute]
private void <DisposeIndex>b__111_0();
    [CompilerGeneratedAttribute]
private void <DisposeIndex>b__111_1();
    [CompilerGeneratedAttribute]
private void <DisposeIndex>b__111_2();
    [CompilerGeneratedAttribute]
private void <DisposeIndex>b__111_3();
    [CompilerGeneratedAttribute]
private void <DisposeIndex>b__111_4();
    [CompilerGeneratedAttribute]
private void <DisposeIndex>b__111_5();
    [CompilerGeneratedAttribute]
private void <DisposeIndex>b__111_6();
    [CompilerGeneratedAttribute]
private void <DisposeIndex>b__111_7();
    [CompilerGeneratedAttribute]
private void <StartIndexingThread>b__160_0(object x);
    [CompilerGeneratedAttribute]
internal static void <QueryInternal>g__UpdateQueryStatistics|265_1(<>c__DisplayClass265_0`1& , <>c__DisplayClass265_1`1& );
    [CompilerGeneratedAttribute]
internal static long <GetCutoffEtag>g__GetLastCompareExchangeEtag|275_0(<>c__DisplayClass275_0& );
    [CompilerGeneratedAttribute]
private void <EnsureSingleIndexingThread>b__290_0();
    [CompilerGeneratedAttribute]
internal static IDisposable <GetIndexEtag>g__OpenReadTransaction|299_0(QueryOperationContext context);
}
public abstract class Raven.Server.Documents.Indexes.Index`2 : Index {
    public TIndexDefinition Definition { get; }
    protected Index`2(IndexType type, IndexSourceType sourceType, TIndexDefinition definition);
    public TIndexDefinition get_Definition();
}
[FlagsAttribute]
public enum Raven.Server.Documents.Indexes.IndexCleanup : Enum {
    public int value__;
    public static IndexCleanup None;
    public static IndexCleanup Basic;
    public static IndexCleanup Readers;
    public static IndexCleanup Writers;
    public static IndexCleanup All;
}
public enum Raven.Server.Documents.Indexes.IndexCreationOptions : Enum {
    public int value__;
    public static IndexCreationOptions Noop;
    public static IndexCreationOptions Update;
    public static IndexCreationOptions UpdateWithoutUpdatingCompiledIndex;
    public static IndexCreationOptions Create;
}
public abstract class Raven.Server.Documents.Indexes.IndexDefinitionBaseServerSide : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexLockMode <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    internal IndexDefinitionClusterState ClusterState;
    [CompilerGeneratedAttribute]
private IndexDeploymentMode <DeploymentMode>k__BackingField;
    public static Byte[] EncryptionContext;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IndexFieldBase> <MapFields>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IndexField> <IndexFields>k__BackingField;
    public string Name { get; protected set; }
    public long Version { get; }
    public HashSet`1<string> Collections { get; protected set; }
    public IndexLockMode LockMode { get; public set; }
    public IndexPriority Priority { get; public set; }
    public IndexState State { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    public IndexDeploymentMode DeploymentMode { get; public set; }
    public bool HasDynamicFields { get; }
    public bool HasCompareExchange { get; }
    public Dictionary`2<string, IndexFieldBase> MapFields { get; protected set; }
    public Dictionary`2<string, IndexField> IndexFields { get; public set; }
    private static IndexDefinitionBaseServerSide();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    public abstract virtual long get_Version();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Collections();
    [CompilerGeneratedAttribute]
protected void set_Collections(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public IndexLockMode get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(IndexLockMode value);
    [CompilerGeneratedAttribute]
public IndexPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(IndexPriority value);
    [CompilerGeneratedAttribute]
public IndexState get_State();
    [CompilerGeneratedAttribute]
public void set_State(IndexState value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
    [CompilerGeneratedAttribute]
public IndexDeploymentMode get_DeploymentMode();
    [CompilerGeneratedAttribute]
public void set_DeploymentMode(IndexDeploymentMode value);
    public virtual bool get_HasDynamicFields();
    public virtual bool get_HasCompareExchange();
    public void Rename(string name, TransactionOperationContext context, StorageEnvironmentOptions options);
    public abstract virtual void Persist(TransactionOperationContext context, StorageEnvironmentOptions options);
    protected abstract virtual void PersistMapFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    public static string GetIndexNameSafeForFileSystem(string name);
    public void Persist(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    public bool ContainsField(string name);
    internal abstract virtual void Reset();
    protected abstract virtual void PersistFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected internal abstract virtual IndexDefinition GetOrCreateIndexDefinitionInternal();
    public abstract virtual IndexDefinitionCompareDifferences Compare(IndexDefinitionBaseServerSide indexDefinition);
    public abstract virtual IndexDefinitionCompareDifferences Compare(IndexDefinition indexDefinition);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IndexFieldBase> get_MapFields();
    [CompilerGeneratedAttribute]
protected void set_MapFields(Dictionary`2<string, IndexFieldBase> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IndexField> get_IndexFields();
    [CompilerGeneratedAttribute]
public void set_IndexFields(Dictionary`2<string, IndexField> value);
}
public abstract class Raven.Server.Documents.Indexes.IndexDefinitionBaseServerSide`1 : IndexDefinitionBaseServerSide {
    protected static string MetadataFileName;
    protected static Slice DefinitionSlice;
    private long _indexVersion;
    private Nullable`1<int> _cachedHashCode;
    public long Version { get; }
    internal IndexDefinitionBaseServerSide`1(string name, IEnumerable`1<string> collections, IndexLockMode lockMode, IndexPriority priority, IndexState state, T[] mapFields, long indexVersion, Nullable`1<IndexDeploymentMode> deploymentMode, IndexDefinitionClusterState clusterState, Nullable`1<ArchivedDataProcessingBehavior> archivedDataProcessingBehavior);
    private static IndexDefinitionBaseServerSide`1();
    public virtual long get_Version();
    internal virtual void Reset();
    public virtual void Persist(TransactionOperationContext context, StorageEnvironmentOptions options);
    private static void EncryptStream(StorageEnvironmentOptions options, MemoryStream stream);
    protected static Stream GetIndexDefinitionStream(StorageEnvironment environment, Transaction tx);
    private static void DecryptStream(StorageEnvironmentOptions options, MemoryStream stream);
    public virtual bool TryGetField(string field, T& value);
    public virtual T GetField(string field);
    public virtual int GetHashCode();
    protected abstract virtual int ComputeRestOfHash(int hashCode);
    protected static string ReadName(BlittableJsonReaderObject reader);
    protected static String[] ReadCollections(BlittableJsonReaderObject reader);
    protected static IndexLockMode ReadLockMode(BlittableJsonReaderObject reader);
    protected static IndexPriority ReadPriority(BlittableJsonReaderObject reader);
    protected static IndexState ReadState(BlittableJsonReaderObject reader);
    protected static Nullable`1<ArchivedDataProcessingBehavior> ReadArchivedDataProcessingBehavior(BlittableJsonReaderObject reader);
    protected static long ReadVersion(BlittableJsonReaderObject reader);
}
public class Raven.Server.Documents.Indexes.IndexDefinitionCodeGenerator : object {
    private IndexDefinition _indexDefinition;
    private static string IndexName;
    private static string CreateIndexDefinition;
    private static UsingDirectiveSyntax[] Usings;
    public IndexDefinitionCodeGenerator(IndexDefinition indexDefinition);
    private static IndexDefinitionCodeGenerator();
    public string Generate();
    private static string GetText(string indexName, IndexDefinition indexDefinition);
    private static IEnumerable`1<SyntaxNodeOrToken> ParsingIndexDefinitionFields(IndexDefinition indexDefinition);
    private static AssignmentExpressionSyntax GetLiteral(string fieldName, string field);
    private static IEnumerable`1<SyntaxNodeOrToken> ParsingIndexDefinitionFieldsToRoslyn(Dictionary`2<string, IndexFieldOptions> fields);
    private static IEnumerable`1<SyntaxNodeOrToken> InnerParsingIndexDefinitionFieldsToRoslyn(IndexFieldOptions options);
    private static void AddCommaTokenIfNecessary(ICollection`1<SyntaxNodeOrToken> syntaxNodeOrToken);
    private static AssignmentExpressionSyntax ParseEnum(T option, string fieldName);
    private static AssignmentExpressionSyntax ParseBool(bool option, string fieldName);
    private static IEnumerable`1<SyntaxNodeOrToken> ParsingIndexDefinitionMapsToRoslyn(ICollection`1<string> maps);
    private static string GetCSharpSafeName(string name);
}
public class Raven.Server.Documents.Indexes.IndexField : IndexFieldBase {
    [CompilerGeneratedAttribute]
private string <OriginalName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Analyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldIndexing <Indexing>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldTermVector <TermVector>k__BackingField;
    [CompilerGeneratedAttribute]
private SpatialOptions <Spatial>k__BackingField;
    private IndexFieldOptions _indexFieldOptions;
    internal string OriginalName { get; internal set; }
    public int Id { get; public set; }
    public string Analyzer { get; public set; }
    public FieldIndexing Indexing { get; public set; }
    public FieldTermVector TermVector { get; public set; }
    public SpatialOptions Spatial { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_OriginalName();
    [CompilerGeneratedAttribute]
internal void set_OriginalName(string value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_Analyzer();
    [CompilerGeneratedAttribute]
public void set_Analyzer(string value);
    [CompilerGeneratedAttribute]
public FieldIndexing get_Indexing();
    [CompilerGeneratedAttribute]
public void set_Indexing(FieldIndexing value);
    [CompilerGeneratedAttribute]
public FieldTermVector get_TermVector();
    [CompilerGeneratedAttribute]
public void set_TermVector(FieldTermVector value);
    [CompilerGeneratedAttribute]
public SpatialOptions get_Spatial();
    [CompilerGeneratedAttribute]
public void set_Spatial(SpatialOptions value);
    public static IndexField Create(string name, IndexFieldOptions options, IndexFieldOptions allFields, int id);
    private bool Equals(IndexField other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public IndexFieldOptions ToIndexFieldOptions();
}
public abstract class Raven.Server.Documents.Indexes.IndexFieldBase : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSuggestions>k__BackingField;
    public string Name { get; public set; }
    public FieldStorage Storage { get; public set; }
    public bool HasSuggestions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public FieldStorage get_Storage();
    [CompilerGeneratedAttribute]
public void set_Storage(FieldStorage value);
    [CompilerGeneratedAttribute]
public bool get_HasSuggestions();
    [CompilerGeneratedAttribute]
public void set_HasSuggestions(bool value);
    public T As();
}
[ExtensionAttribute]
public static class Raven.Server.Documents.Indexes.IndexFieldExtensions : object {
    [ExtensionAttribute]
public static TermVector GetLuceneValue(FieldTermVector value);
    [ExtensionAttribute]
public static Index GetLuceneValue(FieldIndexing value, string analyzer, Index default);
    [ExtensionAttribute]
public static Store GetLuceneValue(FieldStorage value);
}
public class Raven.Server.Documents.Indexes.IndexFieldsPersistence : object {
    private bool _initialized;
    private Index _index;
    private bool _supportsTimeFields;
    private HashSet`1<string> _timeFields;
    private HashSet`1<string> _timeFieldsToWrite;
    public IndexFieldsPersistence(Index index);
    internal void Initialize();
    internal void MarkHasTimeValue(string fieldName);
    internal bool HasTimeValues(string fieldName);
    internal void Persist(TransactionOperationContext indexContext);
    [CompilerGeneratedAttribute]
private void <Persist>b__9_0(IPagerLevelTransactionState _);
}
public class Raven.Server.Documents.Indexes.IndexIdentities : object {
    private int _indexingStatsId;
    public int GetNextIndexingStatsId();
}
public class Raven.Server.Documents.Indexes.IndexInformationHolder : object {
    public string Name;
    public IndexDefinitionBaseServerSide Definition;
    public IndexingConfiguration Configuration;
    public IndexType Type;
    public IndexSourceType SourceType;
    protected IndexInformationHolder(IndexDefinitionBaseServerSide definition, IndexingConfiguration configuration);
    protected IndexInformationHolder(Index index);
    public static IndexInformationHolder CreateFor(IndexDefinitionBaseServerSide definition, IndexingConfiguration configuration, AbstractStaticIndexBase staticIndex);
    public static IndexInformationHolder CreateFor(Index index);
    private static void DetectIndexType(IndexDefinitionBaseServerSide definition, IndexType& type, IndexSourceType& sourceType);
}
[ExtensionAttribute]
public static class Raven.Server.Documents.Indexes.IndexInformationHolderExtensions : object {
    [ExtensionAttribute]
public static IndexInformationHolder ToIndexInformationHolder(Index index);
    [ExtensionAttribute]
public static EssentialIndexInformation ToEssentialIndexInformation(IndexInformationHolder holder);
}
public class Raven.Server.Documents.Indexes.IndexingRunStats : object {
    public long MapAttempts;
    public long MapReferenceAttempts;
    public long MapSuccesses;
    public long MapReferenceSuccesses;
    public long TombstoneDeleteSuccesses;
    public long MapErrors;
    public long MapReferenceErrors;
    public long ReduceAttempts;
    public long ReduceSuccesses;
    public long ReduceErrors;
    public long IndexingOutputs;
    public Size AllocatedManagedBytes;
    public Size AllocatedUnmanagedBytes;
    public long DocumentsSize;
    public Nullable`1<long> EntriesCount;
    public ReduceRunDetails ReduceDetails;
    public MapRunDetails MapDetails;
    public ReferenceRunDetails ReferenceDetails;
    public CleanupRunDetails CleanupDetails;
    public StorageCommitDetails CommitDetails;
    public List`1<IndexingError> Errors;
    public int MaxNumberOfOutputsPerDocument;
    public int NumberOfKeptReduceErrors;
    public LuceneMergeDetails LuceneMergeDetails;
    public virtual string ToString();
    public void AddMapError(string key, string message);
    public void AddMapReferenceError(string key, string message);
    public void AddReduceError(string message, string reduceKey);
    public void AddCorruptionError(Exception exception);
    public void AddWriteError(IndexWriteException exception);
    public void AddAnalyzerError(IndexAnalyzerException exception);
    public void AddUnexpectedError(Exception exception);
    public void AddCriticalError(Exception exception);
    public void AddMemoryError(Exception oome);
    public void AddExcessiveNumberOfReduceErrors(ExcessiveNumberOfReduceErrorsException e);
    public void AddDiskFullError(DiskFullException e);
    private void AddError(string key, string message, string action);
}
public class Raven.Server.Documents.Indexes.IndexingState : object {
    public bool IsStale;
    public long LastProcessedEtag;
    public Nullable`1<long> LastProcessedCompareExchangeReferenceEtag;
    public Nullable`1<long> LastProcessedCompareExchangeReferenceTombstoneEtag;
    public IndexingState(bool isStale, long lastProcessedEtag, Nullable`1<long> lastProcessedCompareExchangeReferenceEtag, Nullable`1<long> lastProcessedCompareExchangeReferenceTombstoneEtag);
}
public class Raven.Server.Documents.Indexes.IndexingStatsAggregator : StatsAggregator`2<IndexingRunStats, IndexingStatsScope> {
    private IndexingPerformanceStats modreq(System.Runtime.CompilerServices.IsVolatile) _performanceStats;
    public IndexingStatsAggregator(int id, IndexingStatsAggregator lastStats);
    public virtual IndexingStatsScope CreateScope();
    public IndexingPerformanceBasicStats ToIndexingPerformanceLiveStats();
    public IndexingPerformanceStats ToIndexingPerformanceLiveStatsWithDetails();
    public IndexingPerformanceStats ToIndexingPerformanceStats();
    private IndexingPerformanceStats CreateIndexingPerformanceStats(bool completed);
}
public class Raven.Server.Documents.Indexes.IndexingStatsScope : StatsScope`2<IndexingRunStats, IndexingStatsScope> {
    private IndexingRunStats _stats;
    public long MapAttempts { get; }
    public long MapReferenceAttempts { get; }
    public long MapErrors { get; }
    public long ReduceAttempts { get; }
    public long ReduceErrors { get; }
    public int ErrorsCount { get; }
    public int NumberOfKeptReduceErrors { get; }
    public long TombstoneDeleteSuccesses { get; }
    public IndexingStatsScope(IndexingRunStats stats, bool start);
    protected virtual IndexingStatsScope OpenNewScope(IndexingRunStats stats, bool start);
    public long get_MapAttempts();
    public long get_MapReferenceAttempts();
    public long get_MapErrors();
    public long get_ReduceAttempts();
    public long get_ReduceErrors();
    public int get_ErrorsCount();
    public int get_NumberOfKeptReduceErrors();
    public long get_TombstoneDeleteSuccesses();
    public void SetAllocatedManagedBytes(long sizeInBytes);
    public void SetAllocatedUnmanagedBytes(long sizeInBytes);
    public void AddCorruptionError(Exception e);
    public void AddWriteError(IndexWriteException iwe);
    public void AddUnexpectedError(Exception e);
    public void AddCriticalError(Exception e);
    public void AddMemoryError(Exception oome);
    public void AddAnalyzerError(IndexAnalyzerException iae);
    public void AddExcessiveNumberOfReduceErrors(ExcessiveNumberOfReduceErrorsException e);
    public void AddDiskFullError(DiskFullException e);
    public void AddMapError(string key, string message);
    public void AddMapReferenceError(string key, string message);
    public void AddReduceError(string message, string reduceKey);
    public void RecordMapAttempt();
    public void RecordMapReferenceAttempt();
    public void RecordMapSuccess();
    public void RecordMapReferenceSuccess();
    public void RecordTombstoneDeleteSuccess();
    public void RecordMapError();
    public void RecordMapReferenceError();
    public void RecordIndexingOutput();
    public void RecordBatchCompletedReason(IndexingWorkType type, string reason);
    private void RecordMapCompletedReason(string reason);
    private void RecordReferenceCompletedReason(string reason);
    private void RecordCleanupCompletedReason(string reason);
    public void RecordReduceTreePageModified(bool isLeaf);
    public void RecordCompressedLeafPage();
    public void RecordReduceAttempts(int numberOfEntries);
    public void RecordReduceSuccesses(int numberOfEntries);
    public void RecordReduceErrors(int numberOfEntries);
    public IndexingPerformanceOperation ToIndexingPerformanceOperation(string name);
    public void RecordMapMemoryStats(long currentProcessWorkingSet, long currentProcessPrivateMemorySize, long currentBudget);
    public void RecordMapAllocations(long allocations);
    public void RecordReduceMemoryStats(long currentProcessWorkingSet, long currentProcessPrivateMemorySize);
    public void RecordReduceAllocations(long allocations);
    public void RecordCommitStats(int numberOfModifiedPages, int numberOf4KbsWrittenToDisk);
    public void RecordNumberOfProducedOutputs(int numberOfOutputs);
    public void RecordDocumentSize(int size);
    public void RecordEntriesCountAfterTxCommit(long entriesCount);
    public void RecordPendingMergesCount(int pendingMergesCount);
    public void RecordMergeStats(OneMergeStats mergeStats);
    public void RecordReferenceAllocations(long allocated);
    public void RecordReferenceMemoryStats(long currentProcessWorkingSet, long currentProcessPrivateMemorySize, long currentBudget);
}
public abstract class Raven.Server.Documents.Indexes.IndexItem : object {
    public LazyStringValue Id;
    public LazyStringValue LowerId;
    public LazyStringValue SourceDocumentId;
    public LazyStringValue LowerSourceDocumentId;
    public long Etag;
    public DateTime LastModified;
    public Nullable`1<DocumentFlags> DocumentFlags;
    public int Size;
    public object Item;
    public string IndexingKey;
    public bool Empty;
    public IndexItemType ItemType;
    public bool KnownToBeNew;
    protected IndexItem(LazyStringValue id, LazyStringValue lowerId, LazyStringValue sourceDocumentId, LazyStringValue lowerSourceDocumentId, long etag, DateTime lastModified, string indexingKey, int size, object item, bool empty, IndexItemType itemType, Nullable`1<DocumentFlags> flags);
    protected abstract virtual string ToStringInternal();
    private bool IsArchived();
    public bool ShouldBeProcessedAsArchived(ArchivedDataProcessingBehavior behavior);
    public sealed virtual void Dispose();
    public virtual string ToString();
}
public enum Raven.Server.Documents.Indexes.IndexItemType : Enum {
    public int value__;
    public static IndexItemType None;
    public static IndexItemType Document;
    public static IndexItemType TimeSeries;
    public static IndexItemType Counters;
}
internal class Raven.Server.Documents.Indexes.IndexMerging.CaptureSelectExpressionsAndNewFieldNamesVisitor : CaptureSelectNewFieldNamesVisitor {
    private bool _outerMostRequired;
    private HashSet`1<string> _fieldNames;
    private Dictionary`2<string, ExpressionSyntax> _selectExpressions;
    private bool _queryProcessed;
    public CaptureSelectExpressionsAndNewFieldNamesVisitor(bool outerMostRequired, HashSet`1<string> fieldNames, Dictionary`2<string, ExpressionSyntax> selectExpressions);
    public virtual SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    private void CollectFieldNamesAndSelectsFromMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax expression);
}
internal class Raven.Server.Documents.Indexes.IndexMerging.IndexData : object {
    private IndexDefinition _index;
    public Dictionary`2<string, ExpressionSyntax> SelectExpressions;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <FromExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfFromClauses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfSelectClauses>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <OriginalMaps>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasWhere>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAlreadyMerged>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFanout>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <InvocationExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMapReduceOrMultiMap>k__BackingField;
    public ExpressionSyntax FromExpression { get; public set; }
    public string FromIdentifier { get; public set; }
    public int NumberOfFromClauses { get; public set; }
    public int NumberOfSelectClauses { get; public set; }
    public HashSet`1<string> OriginalMaps { get; public set; }
    public bool HasWhere { get; public set; }
    public bool HasLet { get; public set; }
    public bool HasGroup { get; public set; }
    public bool HasOrder { get; public set; }
    public string IndexName { get; public set; }
    public bool IsAlreadyMerged { get; public set; }
    public string Comment { get; public set; }
    public bool IsFanout { get; public set; }
    public String[] Collections { get; public set; }
    public InvocationExpressionSyntax InvocationExpression { get; public set; }
    public IndexDefinition Index { get; }
    public bool IsMapReduceOrMultiMap { get; public set; }
    public IndexData(IndexDefinition index);
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_FromExpression();
    [CompilerGeneratedAttribute]
public void set_FromExpression(ExpressionSyntax value);
    [CompilerGeneratedAttribute]
public string get_FromIdentifier();
    [CompilerGeneratedAttribute]
public void set_FromIdentifier(string value);
    [CompilerGeneratedAttribute]
public int get_NumberOfFromClauses();
    [CompilerGeneratedAttribute]
public void set_NumberOfFromClauses(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfSelectClauses();
    [CompilerGeneratedAttribute]
public void set_NumberOfSelectClauses(int value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_OriginalMaps();
    [CompilerGeneratedAttribute]
public void set_OriginalMaps(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_HasWhere();
    [CompilerGeneratedAttribute]
public void set_HasWhere(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasLet();
    [CompilerGeneratedAttribute]
public void set_HasLet(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasGroup();
    [CompilerGeneratedAttribute]
public void set_HasGroup(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasOrder();
    [CompilerGeneratedAttribute]
public void set_HasOrder(bool value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAlreadyMerged();
    [CompilerGeneratedAttribute]
public void set_IsAlreadyMerged(bool value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFanout();
    [CompilerGeneratedAttribute]
public void set_IsFanout(bool value);
    [CompilerGeneratedAttribute]
public String[] get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(String[] value);
    [CompilerGeneratedAttribute]
public InvocationExpressionSyntax get_InvocationExpression();
    [CompilerGeneratedAttribute]
public void set_InvocationExpression(InvocationExpressionSyntax value);
    public IndexDefinition get_Index();
    [CompilerGeneratedAttribute]
public bool get_IsMapReduceOrMultiMap();
    [CompilerGeneratedAttribute]
public void set_IsMapReduceOrMultiMap(bool value);
    public string BuildExpression(Dictionary`2<string, ExpressionSyntax> selectExpressions);
    public virtual string ToString();
}
public class Raven.Server.Documents.Indexes.IndexMerging.IndexMerger : object {
    private Dictionary`2<string, IndexDefinition> _indexDefinitions;
    private static IdentifierNameSyntax DefaultDocumentIdentifier;
    private TestingStuff _forTestingPurposes;
    public IndexMerger(Dictionary`2<string, IndexDefinition> indexDefinitions);
    private static IndexMerger();
    internal TestingStuff ForTestingPurposesOnly();
    private List`1<MergeProposal> MergeIndexes(List`1<IndexData> indexes);
    private static List`1<string> CheckForUnsuitableIndexForMerging(IndexData indexData);
    private List`1<IndexData> ParseIndexesAndGetReadyToMerge();
    private bool CanMergeIndexes(IndexData other, IndexData current);
    private bool CompareIndexFieldOptions(IndexData index1Data, IndexData index2Data);
    private static bool DataDictionaryCompare(IDictionary`2<string, T> dataDict1, IDictionary`2<string, T> dataDict2, IEnumerable`1<string> names);
    private static void DataDictionaryMerge(IDictionary`2<TKey, TVal> dest, IDictionary`2<TKey, TVal> src);
    private static bool AreSelectClausesCompatible(IndexData x, IndexData y);
    private static bool AreSelectClausesTheSame(IndexData index, Dictionary`2<string, ExpressionSyntax> selectExpressionDict);
    private IndexMergeResults CreateMergeIndexDefinition(List`1<MergeProposal> indexDataForMerge);
    private static void SuggestIndexesToDelete(MergeProposal mergeProposal, Dictionary`2<string, ExpressionSyntax> selectExpressionDict, MergeSuggestions mergeSuggestion, IndexMergeResults indexMergeResults);
    private static void AddMergeErrors(IndexMergeResults indexMergeResults, List`1<MergeError> errors);
    private static void TrySetCollectionName(IndexData indexData, MergeSuggestions mergeSuggestion);
    private bool TryMergeSelectExpressionsAndFields(MergeProposal mergeProposal, Dictionary`2<string, ExpressionSyntax> selectExpressionDict, MergeSuggestions mergeSuggestion, List`1& mergeErrors);
    private static InvocationExpressionSyntax RecursivelyTransformInvocationExpressionSyntax(IndexData curProposedData, InvocationExpressionSyntax ies, String& message);
    private static ExpressionSyntax RewriteExpressionSyntax(IndexData indexData, ExpressionSyntax originalExpression, String& message);
    private static ExpressionSyntax RewriteElementAccessExpressionSyntax(IndexData indexData, ElementAccessExpressionSyntax eaes, String& message);
    private static ExpressionSyntax RewriteCastExpressionSyntax(IndexData indexData, CastExpressionSyntax ces, String& message);
    private static ExpressionSyntax RewriteParenthesizedExpressionSyntax(IndexData indexData, ParenthesizedExpressionSyntax pes, String& message);
    private static ConditionalExpressionSyntax RewriteConditionalExpressionSyntax(IndexData indexData, ConditionalExpressionSyntax ces, String& message);
    private static BinaryExpressionSyntax RewriteBinaryExpression(IndexData indexData, BinaryExpressionSyntax original, String& message);
    private static MemberAccessExpressionSyntax ChangeParentInMemberSyntaxToDoc(IndexData data, MemberAccessExpressionSyntax memberAccessExpression);
    private static IndexMergeResults ExcludePartialResults(IndexMergeResults originalIndexes);
    private static ValueTuple`2<string, string> ExtractValueFromExpression(ExpressionSyntax expression);
    private static string ExtractIdentifierFromExpression(MemberAccessExpressionSyntax expression);
    public IndexMergeResults ProposeIndexMergeSuggestions();
    [CompilerGeneratedAttribute]
internal static string <AreSelectClausesCompatible>g__TransformAndExtractValueFromExpression|13_0(IndexData index, ExpressionSyntax expr);
    [CompilerGeneratedAttribute]
internal static string <AreSelectClausesTheSame>g__TransformAndExtractValueFromExpression|14_0(ExpressionSyntax expr, <>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static IdentifierNameSyntax <RewriteExpressionSyntax>g__ChangeIdentifierToIndexMergerDefaultWhenNeeded|21_0(IdentifierNameSyntax original, <>c__DisplayClass21_0& );
}
public class Raven.Server.Documents.Indexes.IndexMerging.IndexMergeResults : object {
    public Dictionary`2<string, string> Unmergables;
    public List`1<MergeSuggestions> Suggestions;
    public List`1<MergeError> Errors;
    public DynamicJsonValue ToJson();
}
internal class Raven.Server.Documents.Indexes.IndexMerging.IndexVisitor : CSharpSyntaxRewriter {
    private IndexData _indexData;
    public IndexVisitor(IndexData indexData);
    public virtual SyntaxNode VisitQueryExpression(QueryExpressionSyntax node);
    public virtual SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax invocationExpression);
    public virtual SyntaxNode VisitQueryBody(QueryBodySyntax node);
    public virtual SyntaxNode VisitWhereClause(WhereClauseSyntax queryWhereClause);
    public virtual SyntaxNode VisitOrderByClause(OrderByClauseSyntax queryOrderClause);
    public virtual SyntaxNode VisitOrdering(OrderingSyntax queryOrdering);
    public virtual SyntaxNode VisitGroupClause(GroupClauseSyntax queryGroupClause);
    public virtual SyntaxNode VisitLetClause(LetClauseSyntax queryLetClause);
    private void AssertSufficientStack();
}
public class Raven.Server.Documents.Indexes.IndexMerging.MergeError : object {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StackTrace>k__BackingField;
    public string IndexName { get; public set; }
    public string Message { get; public set; }
    public string StackTrace { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_StackTrace();
    [CompilerGeneratedAttribute]
public void set_StackTrace(string value);
    public DynamicJsonValue ToJson();
}
internal class Raven.Server.Documents.Indexes.IndexMerging.MergeProposal : object {
    public List`1<IndexData> ProposedForMerge;
    [CompilerGeneratedAttribute]
private IndexData <MergedData>k__BackingField;
    public IndexData MergedData { get; public set; }
    [CompilerGeneratedAttribute]
public IndexData get_MergedData();
    [CompilerGeneratedAttribute]
public void set_MergedData(IndexData value);
}
public class Raven.Server.Documents.Indexes.IndexMerging.MergeSuggestions : object {
    public IndexDefinition MergedIndex;
    public List`1<string> CanMerge;
    public string Collection;
    public List`1<string> CanDelete;
    public string SurpassingIndex;
    public DynamicJsonValue ToJson();
}
internal static class Raven.Server.Documents.Indexes.IndexMerging.SourceCodeBeautifier : object {
    public static FormattedExpression FormatIndex(string sourceCode);
}
public class Raven.Server.Documents.Indexes.IndexStorage : object {
    private Logger _logger;
    private Index _index;
    internal TransactionContextPool _contextPool;
    [CompilerGeneratedAttribute]
private DocumentDatabase <DocumentDatabase>k__BackingField;
    private TableSchema _errorsSchema;
    private Dictionary`2<string, CollectionName> _referencedCollections;
    private StorageEnvironment _environment;
    private long _lastDatabaseEtagOnIndexCreation;
    public static int MaxNumberOfKeptErrors;
    internal bool SimulateCorruption;
    internal Exception SimulateIndexWriteException;
    public DocumentReferences ReferencesForDocuments;
    public CompareExchangeReferences ReferencesForCompareExchange;
    public long CreatedTimestampAsBinary;
    public DocumentDatabase DocumentDatabase { get; }
    public IndexStorage(Index index, TransactionContextPool contextPool, DocumentDatabase database);
    [CompilerGeneratedAttribute]
public DocumentDatabase get_DocumentDatabase();
    public void Initialize(DocumentDatabase documentDatabase, StorageEnvironment environment);
    private void CreateSchema(DocumentDatabase documentDatabase);
    private long InitializeLastDatabaseEtagOnIndexCreation(TransactionOperationContext indexContext);
    public bool LowerThanLastDatabaseEtagOnIndexCreation(long currentEtag);
    public void WriteDefinition(IndexDefinitionBaseServerSide indexDefinition, Nullable`1<TimeSpan> timeout);
    public void WriteState(IndexState state);
    public IndexState ReadState(RavenTransaction tx);
    public void DeleteErrors();
    public List`1<IndexingError> ReadErrors();
    public long ReadErrorsCount();
    public Nullable`1<DateTime> ReadLastIndexingErrorTime();
    public Nullable`1<DateTime> ReadLastIndexingTime(RavenTransaction tx);
    public bool IsIndexInvalid(RavenTransaction tx);
    public IndexStats ReadStats(RavenTransaction tx);
    public int ReadMaxNumberOfOutputsPerDocument(RavenTransaction tx);
    public ArchivedDataProcessingBehavior ReadArchivedDataProcessingBehavior(RavenTransaction tx);
    public CoraxComplexFieldIndexingBehavior ReadCoraxComplexFieldIndexingBehavior(RavenTransaction tx);
    public long ReadLastProcessedTombstoneEtag(RavenTransaction tx, string collection);
    public long ReadLastIndexedEtag(RavenTransaction tx, string collection);
    public void WriteLastTombstoneEtag(RavenTransaction tx, string collection, long etag);
    public void WriteLastIndexedEtag(RavenTransaction tx, string collection, long etag);
    private void WriteLastEtag(RavenTransaction tx, string tree, Slice collection, long etag);
    private void SimulateCorruptionError();
    private void SimulateIndexWriteError(Exception inner);
    internal static long ReadLastEtag(Transaction tx, string tree, Slice collection);
    public IndexFailureInformation UpdateStats(DateTime indexingTime, IndexingRunStats stats);
    private void CleanupErrors(Table table);
    public static IndexType ReadIndexType(string name, StorageEnvironment environment);
    public static string ReadDatabaseId(string name, StorageEnvironment environment);
    public static SearchEngineType ReadSearchEngineType(string name, StorageEnvironment environment);
    public static IndexSourceType ReadIndexSourceType(string name, StorageEnvironment environment);
    public void WriteReferences(CurrentIndexingScope indexingScope, RavenTransaction tx);
    public void Rename(string name);
    internal HashSet`1<string> ReadIndexTimeFields();
    internal void WriteIndexTimeFields(RavenTransaction tx, HashSet`1<string> timeFieldsToAdd);
    public StorageEnvironment Environment();
    [CompilerGeneratedAttribute]
private void <CreateSchema>g__PersistConfiguration|19_0(<>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
private void <CreateSchema>g__AssertAndPersistAnalyzer|19_1(Tree configurationTree, string configurationKey, string expectedAnalyzer, string defaultAnalyzer);
    [CompilerGeneratedAttribute]
private void <CreateSchema>g__PersistSearchEngine|19_2(Tree configurationTree);
    [CompilerGeneratedAttribute]
private void <CreateSchema>g__PersistArchivedDataProcessingBehavior|19_3(Tree configurationTree, ArchivedDataProcessingBehavior defaultBehavior);
    [CompilerGeneratedAttribute]
private void <CreateSchema>g__PersistCoraxComplexFieldIndexingBehavior|19_4(Tree configurationTree);
    [CompilerGeneratedAttribute]
internal static HashSet`1<string> <ReadIndexTimeFields>g__ReadLuceneTimeFields|55_0(Transaction tx);
}
public class Raven.Server.Documents.Indexes.IndexStore : object {
    private DocumentDatabase _documentDatabase;
    private ServerStore _serverStore;
    private CollectionOfIndexes _indexes;
    private ConcurrentDictionary`2<string, SemaphoreSlim> _indexLocks;
    private bool _initialized;
    private bool _run;
    private long _lastSurpassedAutoIndexesDatabaseRecordEtag;
    public IndexIdentities Identities;
    public Logger Logger;
    [CompilerGeneratedAttribute]
private SemaphoreSlim <StoppedConcurrentIndexBatches>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Action`1<ValueTuple`2<string, bool>> IndexBatchCompleted;
    private static int PathLengthLimit;
    internal static int MaxIndexNameLength;
    public DatabaseIndexLockModeController LockMode;
    public DatabaseIndexPriorityController Priority;
    public DatabaseIndexStateController State;
    public DatabaseIndexDeleteController Delete;
    public DatabaseIndexCreateController Create;
    public IIndexReadOperationFactory IndexReadOperationFactory;
    public DatabaseIndexHasChangedController HasChanged;
    public SharedMultipleUseFlag IsDisposed;
    internal TestingStuff ForTestingPurposes;
    public SemaphoreSlim StoppedConcurrentIndexBatches { get; }
    public IndexRunningStatus Status { get; }
    public long Count { get; }
    public IndexStore(DocumentDatabase documentDatabase, ServerStore serverStore);
    protected IndexStore(DocumentDatabase documentDatabase, ServerStore serverStore, DatabaseIndexLockModeController lockMode, DatabaseIndexPriorityController priority, DatabaseIndexStateController state, DatabaseIndexCreateController create, DatabaseIndexDeleteController delete, DatabaseIndexHasChangedController hasChanged, IIndexReadOperationFactory indexReadOperationFactory);
    private static IndexStore();
    [CompilerGeneratedAttribute]
public SemaphoreSlim get_StoppedConcurrentIndexBatches();
    public int HandleDatabaseRecordChange(DatabaseRecord record, long raftIndex, bool startIndexes);
    private void ExecuteForIndexes(IEnumerable`1<Index> indexes, Action`1<Index> action);
    private void HandleSorters(DatabaseRecord record, long index);
    private void HandleAnalyzers(DatabaseRecord record, long index);
    private void HandleChangesForAutoIndexes(DatabaseRecord record, long index, List`1<Index> indexesToStart);
    private Index HandleAutoIndexChange(string name, AutoIndexDefinitionBaseServerSide definition);
    internal static AutoIndexDefinitionBaseServerSide CreateAutoDefinition(AutoIndexDefinition definition, IndexDeploymentMode indexDeployment);
    private void RollIndexesIfNeeded();
    private void HandleChangesForStaticIndexes(DatabaseRecord record, long index, List`1<Index> indexesToStart);
    public bool ShouldSkipThisNodeWhenRolling(Index index, String& reason, Boolean& replace);
    private bool ShouldSkipThisNode(RawDatabaseRecord record, Index index, String& reason, Boolean& replace);
    private bool DidWork(string name);
    private Index HandleStaticIndexChange(string name, IndexDefinition definition, bool forceUpdate);
    public Index CreateTestIndexFromDefinition(IndexDefinition indexDefinition, DocumentDatabase documentDatabase, DocumentsOperationContext context, int maxDocumentsPerIndex);
    private static Index CreateIndexFromDefinition(IndexDefinition indexDefinition, DocumentDatabase documentDatabase, SingleIndexConfiguration optionalIndexConfiguration);
    private static void CollectPrefixesOfDocumentsToDelete(MapReduceIndex mapReduceIndex, Dictionary`2& prefixesOfDocumentsToDelete);
    private void HandleDeletes(DatabaseRecord record, long raftLogIndex);
    public Task InitializeAsync(DatabaseRecord record, long raftIndex, Action`2<LogMode, string> addToInitLog);
    public Index GetIndex(string name);
    public bool HasReplacement(string name);
    public bool MaybeFinishRollingDeployment(string index, Nullable`1<long> lastRollingDeploymentIndex);
    public RollingIndex GetRollingProgress(string name);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.IndexStore/<CreateIndex>d__46")]
public Task`1<ValueTuple`2<long, Index>> CreateIndex(IndexDefinition definition, string raftRequestId, string source);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.IndexStore/<CreateIndex>d__47")]
public Task`1<ValueTuple`2<Nullable`1<long>, Index>> CreateIndex(IndexDefinitionBaseServerSide definition, string raftRequestId);
    private void StartIndex(Index index);
    private void UpdateIndex(IndexDefinition definition, Index existingIndex, IndexDefinitionCompareDifferences indexDifferences);
    private static void UpdateIndexDefinition(IndexDefinitionBase definition, Index existingIndex, IndexDefinitionCompareDifferences indexDifferences);
    internal static IndexCreationOptions GetIndexCreationOptions(object indexDefinition, IndexInformationHolder existingIndex, RavenConfiguration databaseConfiguration, IndexDefinitionCompareDifferences& differences);
    public static bool IsValidIndexName(string name, bool isStatic, String& errorMessage);
    public Index ResetIndex(string name, IndexResetMode indexResetMode);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.IndexStore/<DeleteIndex>d__54")]
public Task DeleteIndex(string name, string raftRequestId);
    internal void DeleteIndexInternal(Index index, bool raiseNotification);
    public IndexRunningStatus get_Status();
    public long get_Count();
    public void StartIndexing();
    public void StartMapIndexes();
    public void StartMapReduceIndexes();
    private void StartIndexing(IEnumerable`1<Index> indexes);
    public void StartIndex(string name);
    public void StopIndex(string name);
    private IDisposable IndexLock(string indexName);
    public void StopIndexing();
    public void StopMapIndexes();
    public void StopMapReduceIndexes();
    private void StopIndexing(IEnumerable`1<Index> indexes);
    public sealed virtual void Dispose();
    private Index ResetIndexInternal(Index index, bool start);
    private Index ResetIndexSideBySideInternal(Index index);
    private void OpenIndexesFromRecord(DatabaseRecord record, long raftIndex, Action`2<LogMode, string> addToInitLog);
    public void OpenFaultyIndex(Index index);
    private void OpenIndex(PathSetting path, string indexPath, List`1<Exception> exceptions, string name, bool startIndex, IndexDefinitionBase indexDefinition);
    public IEnumerable`1<Index> GetIndexesForCollection(string collection);
    public IEnumerable`1<Index> GetIndexes();
    public void RunIdleOperations(DatabaseCleanupMode mode);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.IndexStore/<RunIdleOperationsAsync>d__81")]
private Task RunIdleOperationsAsync(long databaseRecordEtag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.IndexStore/<DeleteOrMergeSurpassedAutoIndexes>d__82")]
private Task DeleteOrMergeSurpassedAutoIndexes(long databaseRecordEtag, string raftRequestId);
    private void InitializePath(PathSetting path);
    public void ReplaceIndexes(string oldIndexName, string replacementIndexName, CancellationToken token);
    private SemaphoreSlim GetIndexLock(string name);
    private void ExecuteIndexAction(Action action);
    [DoesNotReturnAttribute]
public static void ThrowIndexCreationExceptionDueToLicenseLimitations(string indexType, string indexName, LicenseLimitException exception);
    [DoesNotReturnAttribute]
public static void ThrowIndexCreationException(string indexType, string indexName, Exception exception, string reason, ServerStore serverStore);
    [DoesNotReturnAttribute]
public static void ThrowIndexDeletionException(string indexName, Exception exception);
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
private void <StartIndexing>b__63_0(Index index);
    [CompilerGeneratedAttribute]
private void <StopIndexing>b__70_0(Index index);
}
public class Raven.Server.Documents.Indexes.JsNestedField : NestedField {
    public string PropertyName;
    public JsNestedField(string propertyName, string name, String[] path);
    protected virtual bool Equals(CompiledIndexField other);
    public virtual void WriteTo(StringBuilder sb);
    public virtual object GetValue(object value, object blittableValue);
}
public class Raven.Server.Documents.Indexes.LiveIndexingPerformanceCollector : DatabaseAwareLivePerformanceCollector`1<IndexPerformanceStats> {
    private ConcurrentDictionary`2<string, IndexAndPerformanceStatsList> _perIndexStats;
    public LiveIndexingPerformanceCollector(DocumentDatabase documentDatabase, IEnumerable`1<string> indexNames);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.LiveIndexingPerformanceCollector/<StartCollectingStats>d__2")]
protected virtual Task StartCollectingStats();
    protected virtual List`1<IndexPerformanceStats> PreparePerformanceStats();
    protected virtual void WriteStats(List`1<IndexPerformanceStats> stats, AsyncBlittableJsonTextWriter writer, JsonOperationContext context);
    private void OnIndexChange(IndexChange change);
}
public abstract class Raven.Server.Documents.Indexes.MapIndexBase`2 : Index`2<T, TField> {
    private CollectionOfBloomFilters _filters;
    private IndexingStatsScope _statsInstance;
    private MapStats<T, TField> _stats;
    protected MapIndexBase`2(IndexType type, IndexSourceType sourceType, T definition);
    protected virtual IIndexingWork[] CreateIndexWorkExecutors();
    public virtual IDisposable InitializeIndexingWork(TransactionOperationContext indexContext);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual int HandleMap(IndexItem indexItem, IEnumerable mapResults, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual bool MustDeleteArchivedDocument(IndexItem indexItem);
    private int UpdateIndexEntriesCorax(IndexItem indexItem, IEnumerable mapResults, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    private int UpdateIndexEntriesLucene(IndexItem indexItem, IEnumerable mapResults, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual IQueryResultRetriever GetQueryResultRetriever(IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsOperationContext documentsContext, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
    public virtual void SaveLastState();
    private void EnsureValidStats(IndexingStatsScope stats);
}
public abstract class Raven.Server.Documents.Indexes.MapReduce.AggregationResult : object {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<object> GetOutputs();
    public abstract virtual IEnumerable`1<BlittableJsonReaderObject> GetOutputsToStore();
    public abstract virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.MapReduce.Auto.AggregatedDocuments : AggregationResult {
    private List`1<Document> _outputs;
    public int Count { get; }
    public AggregatedDocuments(List`1<Document> results);
    public virtual int get_Count();
    public virtual IEnumerable`1<object> GetOutputs();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.MapReduce.Auto.AggregatedDocuments/<GetOutputsToStore>d__5")]
public virtual IEnumerable`1<BlittableJsonReaderObject> GetOutputsToStore();
    public virtual void Dispose();
}
internal class Raven.Server.Documents.Indexes.MapReduce.Auto.AutoMapReduceIndex : MapReduceIndexBase`2<AutoMapReduceIndexDefinition, AutoIndexField> {
    private ReduceKeyProcessor _reduceKeyProcessor;
    private BlittableJsonTraverser _blittableJsonTraverser;
    private IndexingStatsScope _statsInstance;
    private MapPhaseStats _stats;
    private bool _isFanout;
    private List`1<MapResult> _results;
    private MapOutput _output;
    private AutoMapReduceIndex(AutoMapReduceIndexDefinition definition);
    public static AutoMapReduceIndex CreateNew(AutoMapReduceIndexDefinition definition, DocumentDatabase documentDatabase);
    public static AutoMapReduceIndex Open(StorageEnvironment environment, DocumentDatabase documentDatabase);
    protected virtual void OnInitialization();
    protected virtual IIndexingWork[] CreateIndexWorkExecutors();
    public virtual IIndexedItemEnumerator GetMapEnumerator(IEnumerable`1<IndexItem> items, string collection, TransactionOperationContext indexContext, IndexingStatsScope stats, IndexType type);
    public virtual void Update(IndexDefinitionBaseServerSide definition, IndexingConfiguration configuration);
    public virtual void SetState(IndexState state, bool inMemoryOnly, bool ignoreWriteError);
    public virtual ValueTuple`2<ICollection`1<string>, ICollection`1<string>> GetEntriesFields();
    protected virtual void LoadValues();
    public virtual int HandleMap(IndexItem indexItem, IEnumerable mapResults, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    private void UpdateMapFields();
    private object GetFieldValue(AutoIndexField autoIndexField, Document document);
    protected virtual void DisposeIndex();
    private void EnsureValidStats(IndexingStatsScope stats);
}
internal class Raven.Server.Documents.Indexes.MapReduce.Auto.AutoMapReduceIndexDefinition : AutoIndexDefinitionBaseServerSide {
    public Dictionary`2<string, AutoIndexField> GroupByFields;
    public Dictionary`2<string, AutoIndexField> MapAndGroupByFields;
    public AutoIndexField[] OrderedGroupByFields;
    [CompilerGeneratedAttribute]
private List`1<string> <GroupByFieldNames>k__BackingField;
    public List`1<string> GroupByFieldNames { get; }
    internal AutoMapReduceIndexDefinition(string indexName, string collection, AutoIndexField[] mapFields, AutoIndexField[] groupByFields, List`1<string> groupByFieldNames, Nullable`1<IndexDeploymentMode> deploymentMode, IndexDefinitionClusterState clusterState, Nullable`1<long> indexVersion);
    public AutoMapReduceIndexDefinition(string collection, AutoIndexField[] mapFields, AutoIndexField[] groupByFields, Nullable`1<long> indexVersion);
    [CompilerGeneratedAttribute]
public List`1<string> get_GroupByFieldNames();
    public virtual bool TryGetField(string field, AutoIndexField& value);
    protected virtual void PersistFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected internal virtual IndexDefinition GetOrCreateIndexDefinitionInternal();
    private void PersistGroupByFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected virtual int ComputeRestOfHash(int hashCode);
    public virtual IndexDefinitionCompareDifferences Compare(IndexDefinitionBaseServerSide other);
    public virtual IndexDefinitionCompareDifferences Compare(IndexDefinition indexDefinition);
    public static AutoMapReduceIndexDefinition Load(StorageEnvironment environment);
    public static AutoMapReduceIndexDefinition LoadFromJson(BlittableJsonReaderObject reader);
}
public class Raven.Server.Documents.Indexes.MapReduce.Auto.AutoMapReduceIndexResultsAggregator : object {
    protected Action`1<DynamicJsonValue> ModifyOutputToStore;
    internal AggregationResult AggregateOn(List`1<BlittableJsonReaderObject> aggregationBatch, AutoMapReduceIndexDefinition indexDefinition, TransactionOperationContext indexContext, IndexingStatsScope stats, BlittableJsonReaderObject& currentlyProcessedResult, CancellationToken token);
    internal virtual DynamicJsonValue BuildResult(KeyValuePair`2<BlittableJsonReaderObject, Dictionary`2<string, PropertyResult>> aggregationResult);
    internal virtual void HandleProperty(AutoMapReduceIndexDefinition indexDefinition, string propertyName, BlittableJsonReaderObject json, Dictionary`2<string, PropertyResult> aggregatedResult);
    internal virtual PropertyResult HandleSumAndCount(object value);
}
internal class Raven.Server.Documents.Indexes.MapReduce.Auto.ReduceMapResultsOfAutoIndex : ReduceMapResultsBase`1<AutoMapReduceIndexDefinition> {
    public static AutoMapReduceIndexResultsAggregator Aggregator;
    private BlittableJsonReaderObject _currentlyProcessedResult;
    protected BlittableJsonReaderObject CurrentlyProcessedResult { get; }
    public ReduceMapResultsOfAutoIndex(Index index, AutoMapReduceIndexDefinition indexDefinition, IndexStorage indexStorage, MetricCounters metrics, MapReduceIndexingContext mapReduceContext);
    private static ReduceMapResultsOfAutoIndex();
    protected virtual BlittableJsonReaderObject get_CurrentlyProcessedResult();
    protected virtual AggregationResult AggregateOnImpl(List`1<BlittableJsonReaderObject> aggregationBatch, TransactionOperationContext indexContext, IndexingStatsScope stats, CancellationToken token);
}
public class Raven.Server.Documents.Indexes.MapReduce.Exceptions.AggregationResultNotFoundException : Exception {
    public AggregationResultNotFoundException(string message);
    public AggregationResultNotFoundException(string message, Exception inner);
}
public class Raven.Server.Documents.Indexes.MapReduce.Exceptions.ExcessiveNumberOfReduceErrorsException : Exception {
    public ExcessiveNumberOfReduceErrorsException(string message);
    public ExcessiveNumberOfReduceErrorsException(string message, Exception inner);
}
public class Raven.Server.Documents.Indexes.MapReduce.Exceptions.UnexpectedReduceTreePageException : Exception {
    public UnexpectedReduceTreePageException(string message);
    public UnexpectedReduceTreePageException(string message, Exception inner);
}
public class Raven.Server.Documents.Indexes.MapReduce.MapEntry : object {
    public ulong ReduceKeyHash;
    public long Id;
}
public abstract class Raven.Server.Documents.Indexes.MapReduce.MapReduceIndexBase`2 : Index`2<T, TField> {
    internal static string MapPhaseTreeName;
    internal static string ReducePhaseTreeName;
    internal static string ResultsStoreTypesTreeName;
    internal MapReduceIndexingContext MapReduceWorkContext;
    private IndexingStatsScope _statsInstance;
    private MapPhaseStats<T, TField> _stats;
    protected MapReduceIndexBase`2(IndexType type, IndexSourceType sourceType, T definition);
    public virtual IDisposable InitializeIndexingWork(TransactionOperationContext indexContext);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual IQueryResultRetriever GetQueryResultRetriever(IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsOperationContext documentsContext, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
    private static Tree GetMapPhaseTree(Transaction tx);
    private static Tree GetReducePhaseTree(Transaction tx);
    protected int PutMapResults(LazyStringValue lowerId, LazyStringValue sourceDocumentId, IEnumerable`1<MapResult> mappedResults, TransactionOperationContext indexContext, IndexingStatsScope stats);
    private static bool ResultsBinaryEqual(BlittableJsonReaderObject newResult, PtrSize existingData);
    internal static Queue`1<MapEntry> GetMapEntries(FixedSizeTree documentMapEntries);
    [DoesNotReturnAttribute]
private static void ThrowCouldNotSeekToFirstElement(Slice treeName);
    public MapReduceResultsStore GetResultsStore(ulong reduceKeyHash, TransactionOperationContext indexContext, bool create);
    internal MapReduceResultsStore CreateResultsStore(FixedSizeTree typePerHash, ulong reduceKeyHash, TransactionOperationContext indexContext, bool create);
    protected virtual void LoadValues();
    public virtual DetailedStorageReport GenerateStorageReport(bool calculateExactSizes);
    public virtual void SaveLastState();
    private void EnsureValidStats(IndexingStatsScope stats);
}
public class Raven.Server.Documents.Indexes.MapReduce.MapReduceIndexingContext : object {
    private static Logger Logger;
    internal static Slice LastMapResultIdKey;
    public FixedSizeTree DocumentMapEntries;
    public Tree MapPhaseTree;
    public Tree ReducePhaseTree;
    public FixedSizeTree ResultsStoreTypes;
    public Dictionary`2<ulong, MapReduceResultsStore> StoreByReduceKeyHash;
    public Dictionary`2<string, long> ProcessedDocEtags;
    public Dictionary`2<string, long> ProcessedTombstoneEtags;
    public HashSet`1<long> FreedPages;
    public long NextMapResultId;
    private static MapReduceIndexingContext();
    public sealed virtual void Dispose();
    public void StoreNextMapResultId();
    public void Initialize(Tree mapEntriesTree);
}
public class Raven.Server.Documents.Indexes.MapReduce.MapReduceResultsStore : object {
    public static string ReduceTreePrefix;
    public static string NestedValuesPrefix;
    private ulong _reduceKeyHash;
    private TransactionOperationContext _indexContext;
    private MapReduceIndexingContext _mapReduceContext;
    private Slice _nestedValueKey;
    private InternalScope<ByteStringMemoryCache> _nestedValueKeyScope;
    private Transaction _tx;
    private NestedMapResultsSection _nestedSection;
    [CompilerGeneratedAttribute]
private MapResultsStorageType <Type>k__BackingField;
    public Tree Tree;
    public HashSet`1<long> ModifiedPages;
    private HashSet`1<string> _alreadyInitializedTrees;
    public MapResultsStorageType Type { get; private set; }
    public MapReduceResultsStore(ulong reduceKeyHash, MapResultsStorageType type, TransactionOperationContext indexContext, MapReduceIndexingContext mapReduceContext, bool create);
    [CompilerGeneratedAttribute]
public MapResultsStorageType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(MapResultsStorageType value);
    private void InitializeTree(bool create);
    public void Delete(long id);
    public void Add(long id, BlittableJsonReaderObject result);
    public ReadMapEntryScope Get(long id);
    private void MoveExistingResultsToTree(NestedMapResultsSection section);
    public NestedMapResultsSection GetNestedResultsSection(Tree tree);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <InitializeTree>b__17_0(long page, PageFlags flags);
    [CompilerGeneratedAttribute]
private void <InitializeTree>b__17_1(long page, PageFlags flags);
}
public class Raven.Server.Documents.Indexes.MapReduce.MapResult : object {
    public BlittableJsonReaderObject Data;
    public ulong ReduceKeyHash;
    public long Id;
}
public enum Raven.Server.Documents.Indexes.MapReduce.MapResultsStorageType : Enum {
    public byte value__;
    public static MapResultsStorageType None;
    public static MapResultsStorageType Nested;
    public static MapResultsStorageType Tree;
}
public class Raven.Server.Documents.Indexes.MapReduce.NestedMapResultsSection : object {
    private StorageEnvironment _env;
    private Tree _parent;
    private Slice _nestedValueKey;
    private int _dataSize;
    [CompilerGeneratedAttribute]
private bool <IsNew>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsModified>k__BackingField;
    public bool IsNew { get; }
    public int Size { get; }
    public bool IsModified { get; private set; }
    public Slice Name { get; }
    public TreePage RelevantPage { get; }
    public NestedMapResultsSection(StorageEnvironment env, Tree parent, Slice nestedValueKey);
    [CompilerGeneratedAttribute]
public bool get_IsNew();
    public int get_Size();
    [CompilerGeneratedAttribute]
public bool get_IsModified();
    [CompilerGeneratedAttribute]
private void set_IsModified(bool value);
    public Slice get_Name();
    public TreePage get_RelevantPage();
    public void Add(long id, BlittableJsonReaderObject result);
    public PtrSize Get(long id);
    public void MoveTo(Tree newHome);
    public int GetResults(JsonOperationContext context, List`1<BlittableJsonReaderObject> results);
    public int GetResultsForDebug(JsonOperationContext context, Dictionary`2<long, BlittableJsonReaderObject> results);
    public void Delete(long id);
    public int SizeAfterAdding(BlittableJsonReaderObject item);
}
public class Raven.Server.Documents.Indexes.MapReduce.OutputToCollection.DeleteReduceOutputDocumentsCommand : OutputReduceAbstractCommand {
    private string _documentsPrefix;
    private int _batchSize;
    private string _originalPattern;
    private OutputReferencesPattern _originalPatternForReduceOutputReferences;
    [CompilerGeneratedAttribute]
private long <DeleteCount>k__BackingField;
    public long DeleteCount { get; public set; }
    public DeleteReduceOutputDocumentsCommand(DocumentDatabase database, string documentsPrefix, string originalPattern, int batchSize);
    [CompilerGeneratedAttribute]
public long get_DeleteCount();
    [CompilerGeneratedAttribute]
public void set_DeleteCount(long value);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    private void RetrieveReferenceDocumentsToCleanup(Document doc, Dictionary`2<string, HashSet`1<string>> idsToDeleteByReferenceDocumentId);
    private void CleanupReferenceDocuments(DocumentsOperationContext context, Dictionary`2<string, HashSet`1<string>> idsToDeleteByReferenceDocumentId);
    public virtual IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> ToDto(DocumentsOperationContext context);
    [DoesNotReturnAttribute]
private static void ThrowIdsPropertyNotFound(string id);
}
public class Raven.Server.Documents.Indexes.MapReduce.OutputToCollection.DeleteReduceOutputDocumentsCommandDto : object {
    public string DocumentsPrefix;
    public string OriginalPattern;
    public int BatchSize;
    public sealed virtual DeleteReduceOutputDocumentsCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public abstract class Raven.Server.Documents.Indexes.MapReduce.OutputToCollection.OutputReduceAbstractCommand : MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> {
    protected DocumentDatabase _database;
    protected OutputReduceAbstractCommand(DocumentDatabase database);
    public void ArtificialDelete(DocumentsOperationContext context, string key);
    public void ArtificialPut(DocumentsOperationContext context, string key, BlittableJsonReaderObject document);
}
public class Raven.Server.Documents.Indexes.MapReduce.OutputToCollection.OutputReduceLuceneIndexWriteOperation : LuceneIndexWriteOperation {
    private OutputReduceIndexWriteOperationScope`1<OutputReduceLuceneIndexWriteOperation> _outputScope;
    public OutputReduceLuceneIndexWriteOperation(MapReduceIndex index, LuceneVoronDirectory directory, LuceneDocumentConverterBase converter, Transaction writeTransaction, LuceneIndexPersistence persistence, JsonOperationContext indexContext);
    public virtual void Commit(IndexingStatsScope stats);
    public virtual void IndexDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public virtual void Delete(LazyStringValue key, IndexingStatsScope stats);
    public virtual void DeleteReduceResult(LazyStringValue reduceKeyHash, IndexingStatsScope stats);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.MapReduce.OutputToCollection.OutputReduceToCollectionActions : object {
    private MapReduceIndex _index;
    private static string PrefixesOfReduceOutputDocumentsToDeleteTree;
    internal static Slice ReduceOutputsIdsToPatternReferenceIdsTree;
    private ConcurrentDictionary`2<string, string> _prefixesOfReduceOutputDocumentsToDelete;
    private string _collectionOfReduceOutputs;
    private Nullable`1<long> _reduceOutputVersion;
    private OutputReferencesPattern _patternForOutputReduceToCollectionReferences;
    private string _referenceDocumentsCollectionName;
    private static OutputReduceToCollectionActions();
    public OutputReduceToCollectionActions(MapReduceIndex index);
    public string GetCollectionOfReduceOutput();
    public string GetPattern();
    public string GetReferenceDocumentsCollectionName();
    public void Initialize(RavenTransaction tx);
    public void AddPatternGeneratedIdForReduceOutput(Transaction tx, string reduceResultId, string referenceDocumentId);
    public string GetPatternGeneratedIdForReduceOutput(Transaction tx, string reduceResultId);
    public void DeletePatternGeneratedIdForReduceOutput(Transaction tx, string reduceResultId);
    public OutputReduceToCollectionCommandBatcher CreateCommandBatcher(JsonOperationContext indexContext, TransactionHolder writeTxHolder);
    public void AddPrefixesOfDocumentsToDelete(Dictionary`2<string, string> prefixes);
    public ConcurrentDictionary`2<string, string> GetPrefixesOfDocumentsToDelete();
    public bool HasDocumentsToDelete(TransactionOperationContext indexContext);
    public bool DeleteDocuments(IndexingStatsScope stats, TransactionOperationContext indexContext);
    private void DeletePrefixOfReduceOutputDocumentsToDelete(string prefix, TransactionOperationContext indexContext);
    private static ValueTuple`2<string, string> GetPrefixToDeleteAndOriginalPatternFromCurrent(TreeIterator it);
}
public class Raven.Server.Documents.Indexes.MapReduce.OutputToCollection.OutputReduceToCollectionCommand : OutputReduceAbstractCommand {
    private static string MultipleOutputsForSameReduceKeyHashSeparator;
    private string _outputReduceToCollection;
    private Nullable`1<long> _reduceOutputIndex;
    private OutputReferencesPattern _patternForReduceOutputReferences;
    private HashSet`1<string> _reduceKeyHashesToDelete;
    private OutputReduceToCollectionReferencesCommand _outputToCollectionReferences;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, List`1<ValueTuple`2<BlittableJsonReaderObject, string>>> _reduceDocuments;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, List`1<ValueTuple`2<BlittableJsonReaderObject, string>>> _reduceDocumentsForReplayTransaction;
    private TransactionHolder _indexWriteTxHolder;
    public OutputReduceToCollectionCommand(DocumentDatabase database, string outputReduceToCollection, Nullable`1<long> reduceOutputIndex, OutputReferencesPattern patternForReduceOutputReferences, MapReduceIndex index, TransactionHolder indexWriteTxHolder);
    internal OutputReduceToCollectionCommand(DocumentDatabase database, string outputReduceToCollection, Nullable`1<long> reduceOutputIndex, Dictionary`2<string, List`1<ValueTuple`2<BlittableJsonReaderObject, string>>> reduceDocuments);
    private OutputReduceToCollectionCommand(DocumentDatabase database, string outputReduceToCollection, Nullable`1<long> reduceOutputIndex);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    private static bool DocumentsBinaryEqual(BlittableJsonReaderObject oldDocument, BlittableJsonReaderObject newDocument);
    private void ProcessReduceDocumentsForReplayTransaction(DocumentsOperationContext context);
    public virtual IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> ToDto(DocumentsOperationContext context);
    public void AddReduce(string reduceKeyHash, ValueTuple`2<BlittableJsonReaderObject, string> output);
    public bool DeleteReduce(string reduceKeyHash);
    public static bool IsOutputDocumentPrefix(string prefix);
    public static string GetOutputDocumentPrefix(string collectionName, long reduceOutputIndex);
    private string GetOutputDocumentKey(string reduceKeyHash);
    private string GetOutputDocumentKeyForSameReduceKeyHash(string reduceKeyHash, int outputNumber);
    private string GetOutputDocumentKeyForSameReduceKeyHashPrefix(string reduceKeyHash);
}
public class Raven.Server.Documents.Indexes.MapReduce.OutputToCollection.OutputReduceToCollectionCommandBatcher : object {
    private static int BatchSize;
    private DocumentDatabase _database;
    private string _outputReduceToCollection;
    private Nullable`1<long> _reduceOutputIndex;
    private OutputReferencesPattern _patternForReduceOutputReferences;
    private JsonOperationContext _indexContext;
    private TransactionHolder _indexWriteTxHolder;
    private MapReduceIndex _index;
    private List`1<string> _reduceKeyHashesToDelete;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, List`1<ValueTuple`2<BlittableJsonReaderObject, string>>> _reduceDocuments;
    public OutputReduceToCollectionCommandBatcher(DocumentDatabase database, string outputReduceToCollection, Nullable`1<long> reduceOutputIndex, OutputReferencesPattern patternForReduceOutputReferences, MapReduceIndex index, JsonOperationContext indexContext, TransactionHolder indexWriteTxHolder);
    private static OutputReduceToCollectionCommandBatcher();
    public void AddReduce(string reduceKeyHash, object reduceObject, IndexingStatsScope stats);
    public void DeleteReduce(string reduceKeyHash);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.MapReduce.OutputToCollection.OutputReduceToCollectionCommandBatcher/<CreateCommands>d__13")]
public IEnumerable`1<OutputReduceToCollectionCommand> CreateCommands();
    private BlittableJsonReaderObject GenerateReduceOutput(object reduceObject, IndexingStatsScope stats, String& referenceDocumentId);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private OutputReduceToCollectionCommand <CreateCommands>g__CreateCommand|13_0();
}
public class Raven.Server.Documents.Indexes.MapReduce.OutputToCollection.OutputReduceToCollectionCommandDto : object {
    public string OutputReduceToCollection;
    public Nullable`1<long> ReduceOutputIndex;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, List`1<ValueTuple`2<BlittableJsonReaderObject, string>>> ReduceDocuments;
    public sealed virtual OutputReduceToCollectionCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public class Raven.Server.Documents.Indexes.MapReduce.OutputToCollection.OutputReferencesPattern : object {
    [CompilerGeneratedAttribute]
private string <ReferencesCollectionName>k__BackingField;
    private static Regex FieldsRegex;
    private DocumentIdBuilder _builder;
    public string ReferencesCollectionName { get; }
    public string Pattern { get; }
    public OutputReferencesPattern(DocumentDatabase database, string pattern, string referencesCollectionName);
    private static OutputReferencesPattern();
    [CompilerGeneratedAttribute]
public string get_ReferencesCollectionName();
    public string get_Pattern();
    public static Dictionary`2<string, int> ValidatePattern(string pattern, String& formattedPattern);
    public IDisposable BuildReferenceDocumentId(DocumentIdBuilder& builder);
}
public class Raven.Server.Documents.Indexes.MapReduce.ReadMapEntryScope : ValueType {
    public PtrSize Data;
    private DecompressedReadResult _read;
    public ReadMapEntryScope(DecompressedReadResult read);
    public ReadMapEntryScope(PtrSize data);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.MapReduce.ReduceKeyProcessor : object {
    private UnmanagedBuffersPoolWithLowMemoryHandling _buffersPool;
    private long _indexVersion;
    private Mode _mode;
    private AllocatedMemoryData _buffer;
    private int _bufferPos;
    private ulong _singleValueHash;
    private int _numberOfReduceFields;
    private int _processedFields;
    private bool _hadAnyNotNullValue;
    public int ProcessedFields { get; }
    public ulong Hash { get; }
    public bool AllProcessedValuesWereNull { get; }
    public ReduceKeyProcessor(int numberOfReduceFields, UnmanagedBuffersPoolWithLowMemoryHandling buffersPool, long indexVersion);
    public void SetMode(Mode mode);
    public int get_ProcessedFields();
    public void Reset();
    public ulong get_Hash();
    [DoesNotReturnAttribute]
private void ThrowUnknownReduceValueMode();
    [DoesNotReturnAttribute]
private void ThrowInvalidNumberOfFields();
    public void Process(ByteStringContext context, object value, bool internalCall);
    private void CopyToBuffer(Byte* value, int size);
    public Buffer GetBuffer();
    public bool get_AllProcessedValuesWereNull();
    public void ReleaseBuffer();
}
public abstract class Raven.Server.Documents.Indexes.MapReduce.ReduceMapResultsBase`1 : object {
    private static TimeSpan MinReduceDurationToCalculateProcessMemoryUsage;
    internal static Slice PageNumberSlice;
    internal static string PageNumberToReduceResultTableName;
    private Logger _logger;
    private AggregationBatch<T> _aggregationBatch;
    private Index _index;
    protected T _indexDefinition;
    private IndexStorage _indexStorage;
    private MetricCounters _metrics;
    private MapReduceIndexingContext _mapReduceContext;
    internal static TableSchema ReduceResultsSchema;
    private IndexingStatsScope _treeReductionStatsInstance;
    private IndexingStatsScope _nestedValuesReductionStatsInstance;
    private TreeReductionStats<T> _treeReductionStats;
    private NestedValuesReductionStats<T> _nestedValuesReductionStats;
    internal static int NumberOfResultsPosition;
    internal static int StartOutputResultsPosition;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <OnErrorResult>k__BackingField;
    public string Name { get; }
    protected BlittableJsonReaderObject CurrentlyProcessedResult { get; }
    protected BlittableJsonReaderObject OnErrorResult { get; private set; }
    protected ReduceMapResultsBase`1(Index index, T indexDefinition, IndexStorage indexStorage, MetricCounters metrics, MapReduceIndexingContext mapReduceContext);
    private static ReduceMapResultsBase`1();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    protected abstract virtual BlittableJsonReaderObject get_CurrentlyProcessedResult();
    [CompilerGeneratedAttribute]
protected BlittableJsonReaderObject get_OnErrorResult();
    [CompilerGeneratedAttribute]
private void set_OnErrorResult(BlittableJsonReaderObject value);
    public sealed virtual ValueTuple`2<bool, CanContinueBatchResult> Execute(QueryOperationContext queryContext, TransactionOperationContext indexContext, Lazy`1<IndexWriteOperationBase> writeOperation, IndexingStatsScope stats, CancellationToken token);
    private void WriteLastEtags(TransactionOperationContext indexContext);
    private void HandleNestedValuesReduction(TransactionOperationContext indexContext, IndexingStatsScope stats, MapReduceResultsStore modifiedStore, Lazy`1<IndexWriteOperationBase> writer, LazyStringValue reduceKeyHash, CancellationToken token);
    private void IndexReducedResult(TransactionOperationContext indexContext, IndexingStatsScope stats, Lazy`1<IndexWriteOperationBase> writer, LazyStringValue reduceKeyHash, IEnumerable`1<object> results, bool isNewSection);
    private static void OutputReduceResultsLucene(TransactionOperationContext indexContext, IndexingStatsScope stats, Lazy`1<IndexWriteOperationBase> writer, LazyStringValue reduceKeyHash, IEnumerable`1<object> results, bool isNewSection);
    private static void OutputReduceResultsCorax(TransactionOperationContext indexContext, IndexingStatsScope stats, Lazy`1<IndexWriteOperationBase> writer, LazyStringValue reduceKeyHash, IEnumerable`1<object> results, bool isNewSection);
    private void HandleTreeReduction(TransactionOperationContext indexContext, IndexingStatsScope stats, MapReduceResultsStore modifiedStore, LowLevelTransaction lowLevelTransaction, Lazy`1<IndexWriteOperationBase> writer, LazyStringValue reduceKeyHash, Table table, CancellationToken token);
    private AggregationResult AggregateLeafPage(TreePage page, LowLevelTransaction lowLevelTransaction, TransactionOperationContext indexContext, CancellationToken token);
    private AggregationResult AggregateBranchPage(TreePage page, Table table, TransactionOperationContext indexContext, HashSet`1<long> remainingBranchesToAggregate, HashSet`1<long> compressedEmptyLeafs, Dictionary`2<long, Exception> failedAggregatedLeafs, Tree tree, CancellationToken token);
    private AggregationResult AggregateBatchResults(List`1<BlittableJsonReaderObject> aggregationBatch, TransactionOperationContext indexContext, IndexingStatsScope stats, CancellationToken token);
    private void StoreAggregationResult(TreePage page, Table table, AggregationResult result);
    private bool TryAggregateChildPageOrThrow(long pageNumber, Table table, TransactionOperationContext indexContext, HashSet`1<long> remainingBranchesToAggregate, HashSet`1<long> compressedEmptyLeafs, Dictionary`2<long, Exception> failedAggregatedLeafs, Tree tree, CancellationToken token);
    private AggregationResult AggregateOn(List`1<BlittableJsonReaderObject> aggregationBatch, TransactionOperationContext indexContext, IndexingStatsScope stats, CancellationToken token);
    protected abstract virtual AggregationResult AggregateOnImpl(List`1<BlittableJsonReaderObject> aggregationBatch, TransactionOperationContext indexContext, IndexingStatsScope stats, CancellationToken token);
    private void EnsureValidTreeReductionStats(IndexingStatsScope stats);
    private void EnsureValidNestedValuesReductionStats(IndexingStatsScope stats);
    private void HandleReductionError(Exception error, LazyStringValue reduceKeyHash, Lazy`1<IndexWriteOperationBase> writer, IndexingStatsScope stats, bool updateStats, TreePage page, int numberOfNestedValues);
    [CompilerGeneratedAttribute]
private string <HandleReductionError>g__GetReduceKey|44_0(<>c__DisplayClass44_0& );
}
public class Raven.Server.Documents.Indexes.MapReduce.Static.AggregatedAnonymousObjects : AggregationResult {
    private List`1<object> _outputs;
    private List`1<BlittableJsonReaderObject> _jsons;
    private IPropertyAccessor _propertyAccessor;
    private JsonOperationContext _indexContext;
    protected Action`1<DynamicJsonValue> ModifyOutputToStore;
    protected bool SkipImplicitNullInOutput;
    public int Count { get; }
    public AggregatedAnonymousObjects(List`1<object> results, IPropertyAccessor propertyAccessor, JsonOperationContext indexContext);
    public virtual int get_Count();
    public virtual IEnumerable`1<object> GetOutputs();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.MapReduce.Static.AggregatedAnonymousObjects/<GetOutputsToStore>d__10")]
public virtual IEnumerable`1<BlittableJsonReaderObject> GetOutputsToStore();
    public virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.MapReduce.Static.MapReduceIndex : MapReduceIndexBase`2<MapReduceIndexDefinition, IndexField> {
    private HashSet`1<string> _referencedCollections;
    protected internal AbstractStaticIndexBase _compiled;
    private Nullable`1<bool> _isSideBySide;
    protected HandleReferences _handleReferences;
    protected HandleCompareExchangeReferences _handleCompareExchangeReferences;
    protected Dictionary`2<string, AnonymousObjectToBlittableMapResultsEnumerableWrapper> _enumerationWrappers;
    public IPropertyAccessor OutputReduceToCollectionPropertyAccessor;
    [CompilerGeneratedAttribute]
private OutputReduceToCollectionActions <OutputReduceToCollection>k__BackingField;
    public bool HasBoostedFields { get; }
    public bool IsMultiMap { get; }
    public OutputReduceToCollectionActions OutputReduceToCollection { get; private set; }
    protected MapReduceIndex(MapReduceIndexDefinition definition, AbstractStaticIndexBase compiled);
    public virtual bool get_HasBoostedFields();
    public virtual bool get_IsMultiMap();
    public virtual void ResetIsSideBySideAfterReplacement();
    [CompilerGeneratedAttribute]
public OutputReduceToCollectionActions get_OutputReduceToCollection();
    [CompilerGeneratedAttribute]
private void set_OutputReduceToCollection(OutputReduceToCollectionActions value);
    protected virtual void HandleDocumentChange(DocumentChange change);
    protected virtual void OnInitialization();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.MapReduce.Static.MapReduceIndex/<ValidateReduceResultsCollectionNameAsync>d__19")]
public static ValueTask ValidateReduceResultsCollectionNameAsync(IndexDefinition definition, AbstractStaticIndexBase index, Func`1<IEnumerable`1<IndexInformationHolder>> getIndexes, Func`2<string, ValueTask`1<long>> getCollectionCountAsync, bool checkIfCollectionEmpty);
    private static bool CheckIfThereIsAnIndexWhichWillOutputReduceDocumentsWhichWillBeUsedAsMapOnTheSpecifiedIndex(StaticIndexInformationHolder indexToCheck, HashSet`1<string> indexCollections, List`1<StaticIndexInformationHolder> indexes, String& description);
    public static Index Open(StorageEnvironment environment, DocumentDatabase documentDatabase);
    public static MapReduceIndex CreateNew(IndexDefinition definition, DocumentDatabase documentDatabase, bool isIndexReset, SingleIndexConfiguration forcedConfiguration);
    public static void Update(Index index, IndexDefinition definition, DocumentDatabase documentDatabase);
    private static TStaticIndex CreateIndexInstance(IndexDefinition definition, RavenConfiguration configuration, long indexVersion, Func`3<MapReduceIndexDefinition, AbstractStaticIndexBase, TStaticIndex> factory);
    private static MapReduceIndexDefinition CreateIndexDefinition(IndexDefinition definition, RavenConfiguration configuration, long indexVersion, AbstractStaticIndexBase& staticIndex);
    public static IndexInformationHolder CreateIndexInformationHolder(IndexDefinition definition, RavenConfiguration configuration, long indexVersion, AbstractStaticIndexBase& staticIndex);
    protected virtual IIndexingWork[] CreateIndexWorkExecutors();
    public virtual InMemoryReferencesInfo GetInMemoryReferencesState(string collection, bool isCompareExchange);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual IIndexedItemEnumerator GetMapEnumerator(IEnumerable`1<IndexItem> items, string collection, TransactionOperationContext indexContext, IndexingStatsScope stats, IndexType type);
    public virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType tombstoneType);
    public virtual int HandleMap(IndexItem indexItem, IEnumerable mapResults, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    internal virtual bool IsStale(QueryOperationContext queryContext, TransactionOperationContext indexContext, Nullable`1<long> cutoff, Nullable`1<long> referenceCutoff, Nullable`1<long> compareExchangeReferenceCutoff, List`1<string> stalenessReasons);
    public virtual ValueTuple`2<ICollection`1<string>, ICollection`1<string>> GetEntriesFields();
    protected virtual long CalculateIndexEtag(QueryOperationContext queryContext, TransactionOperationContext indexContext, QueryMetadata query, bool isStale);
    protected virtual IndexingState GetIndexingStateInternal(QueryOperationContext queryContext, TransactionOperationContext indexContext);
    public bool IsSideBySide();
    protected virtual bool ShouldReplace();
    public virtual Dictionary`2<string, HashSet`1<CollectionName>> GetReferencedCollections();
    public virtual bool WorksOnAnyCollection(HashSet`1<string> collections);
}
public class Raven.Server.Documents.Indexes.MapReduce.Static.MapReduceIndexDefinition : MapIndexDefinition {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CompiledIndexField> <GroupByFields>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputReduceToCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ReduceOutputIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternForOutputReduceToCollectionReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PatternReferencesCollectionName>k__BackingField;
    public Dictionary`2<string, CompiledIndexField> GroupByFields { get; }
    public string OutputReduceToCollection { get; }
    public Nullable`1<long> ReduceOutputIndex { get; public set; }
    public string PatternForOutputReduceToCollectionReferences { get; }
    public string PatternReferencesCollectionName { get; }
    public MapReduceIndexDefinition(IndexDefinition definition, IEnumerable`1<string> collections, String[] outputFields, CompiledIndexField[] groupByFields, bool hasDynamicFields, bool hasCompareExchange, long indexVersion);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, CompiledIndexField> get_GroupByFields();
    [CompilerGeneratedAttribute]
public string get_OutputReduceToCollection();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ReduceOutputIndex();
    [CompilerGeneratedAttribute]
public void set_ReduceOutputIndex(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_PatternForOutputReduceToCollectionReferences();
    [CompilerGeneratedAttribute]
public string get_PatternReferencesCollectionName();
}
public class Raven.Server.Documents.Indexes.MapReduce.Static.ReduceMapResultsOfStaticIndex : ReduceMapResultsBase`1<MapReduceIndexDefinition> {
    private DynamicIterationOfAggregationBatchWrapper _blittableToDynamicWrapper;
    private IndexingFunc _reducingFunc;
    private IndexType _indexType;
    private IPropertyAccessor _propertyAccessor;
    protected BlittableJsonReaderObject CurrentlyProcessedResult { get; }
    public ReduceMapResultsOfStaticIndex(Index index, IndexingFunc reducingFunc, MapReduceIndexDefinition indexDefinition, IndexStorage indexStorage, MetricCounters metrics, MapReduceIndexingContext mapReduceContext);
    protected virtual BlittableJsonReaderObject get_CurrentlyProcessedResult();
    protected virtual AggregationResult AggregateOnImpl(List`1<BlittableJsonReaderObject> aggregationBatch, TransactionOperationContext indexContext, IndexingStatsScope stats, CancellationToken token);
}
public class Raven.Server.Documents.Indexes.MapReduce.Static.Sharding.ShardedAggregatedAnonymousObjects : AggregatedAnonymousObjects {
    private static DynamicJsonValue DummyDynamicJsonValue;
    public ShardedAggregatedAnonymousObjects(List`1<object> results, IPropertyAccessor propertyAccessor, JsonOperationContext indexContext, bool skipImplicitNullInOutput);
    private static ShardedAggregatedAnonymousObjects();
}
public class Raven.Server.Documents.Indexes.MapReduce.Static.Sharding.ShardedAggregatedAnonymousObjectsForIndexEntries : AggregatedAnonymousObjects {
    public ShardedAggregatedAnonymousObjectsForIndexEntries(List`1<object> results, IPropertyAccessor propertyAccessor, string reduceKeyHash, JsonOperationContext indexContext);
}
public class Raven.Server.Documents.Indexes.MapReduce.Workers.CleanupDocumentsForMapReduce : CleanupDocuments {
    private MapReduceIndex _mapReduceIndex;
    public CleanupDocumentsForMapReduce(MapReduceIndex mapReduceIndex, DocumentsStorage documentsStorage, IndexStorage indexStorage, IndexingConfiguration configuration, MapReduceIndexingContext mapReduceContext);
    public virtual ValueTuple`2<bool, CanContinueBatchResult> Execute(QueryOperationContext queryContext, TransactionOperationContext indexContext, Lazy`1<IndexWriteOperationBase> writeOperation, IndexingStatsScope stats, CancellationToken token);
}
public class Raven.Server.Documents.Indexes.NestedField : CompiledIndexField {
    private Type _accessorType;
    private IPropertyAccessor _accessor;
    private String[] _path;
    protected CompiledIndexField _field;
    public NestedField(string name, String[] path);
    protected virtual bool Equals(CompiledIndexField other);
    public virtual void WriteTo(StringBuilder sb);
    public virtual object GetValue(object value, object blittableValue);
}
public class Raven.Server.Documents.Indexes.NotForQueryingAttribute : Attribute {
}
public abstract class Raven.Server.Documents.Indexes.Persistence.AbstractQueryFilter : object {
    private ReturnRun _filterSingleRun;
    protected IndexQueryServerSide Query;
    protected QueryTimingsScope QueryTimings;
    protected JsonOperationContext Context;
    protected SingleRun FilterScriptRun;
    protected Nullable`1<long> ScannedDocuments { get; }
    protected AbstractQueryFilter(IndexQueryServerSide query, QueryTimingsScope queryTimings, ScriptRunnerCache scriptRunnerCache, JsonOperationContext context);
    protected abstract virtual Nullable`1<long> get_ScannedDocuments();
    protected abstract virtual ScriptRunnerResult GetScriptRunnerResult(object translatedDoc);
    protected abstract virtual void IncrementSkippedResults();
    protected abstract virtual void IncrementScannedDocuments();
    protected FilterResult Apply(object doc);
    public sealed virtual void Dispose();
}
public abstract class Raven.Server.Documents.Indexes.Persistence.ConverterBase : object {
    public static BlittableJsonTraverser FlatMapReduceResultsWithTimeOnlyDateOnlySupport;
    public static BlittableJsonTraverser DefaultWithTimeOnlyDateOnlySupport;
    protected BlittableJsonTraverser _blittableTraverser;
    protected Index _index;
    protected Dictionary`2<string, IndexField> _fields;
    protected bool _indexImplicitNull;
    internal bool _indexEmptyEntries;
    protected string _keyFieldName;
    protected bool _storeValue;
    protected string _storeValueFieldName;
    protected int _numberOfBaseFields;
    private static TypeCache`1<ValueType> _valueTypeCache;
    protected ConverterBase(Index index, bool storeValue, bool indexImplicitNull, bool indexEmptyEntries, int numberOfBaseFields, string keyFieldName, string storeValueFieldName, ICollection`1<IndexField> fields);
    private static ConverterBase();
    protected static bool IsArrayOfTypeValueObject(BlittableJsonReaderObject val);
    protected ValueType GetValueType(object value);
    protected static Byte[] ToArray(ConversionScope scope, Stream stream, Int32& length);
    protected static bool IsNumber(object value);
    internal static bool TryToTrimTrailingZeros(LazyNumberValue ldv, JsonOperationContext context, LazyStringValue& dblAsString);
    public abstract virtual void Dispose();
    [CompilerGeneratedAttribute]
private ValueType <GetValueType>g__GetValueTypeUnlikely|14_0(Type type, <>c__DisplayClass14_0& );
}
internal class Raven.Server.Documents.Indexes.Persistence.Corax.AnalyzersScope : object {
    private IndexFieldsMapping _knownFields;
    private bool _hasDynamics;
    private IndexSearcher _indexSearcher;
    private Dictionary`2<Slice, Analyzer> _analyzersCache;
    private InternalScope<ByteStringMemoryCache> _tempBufferScope;
    private int _tempOutputBufferSize;
    private Byte* _tempOutputBuffer;
    private int _tempOutputTokenSize;
    private Token* _tempTokenBuffer;
    public AnalyzersScope(IndexSearcher indexSearcher, IndexFieldsMapping fieldsMapping, bool hasDynamics);
    private void InitializeTemporaryBuffers(ByteStringContext allocator);
    private void UnlikelyGrowBuffers(int outputSize, int tokenSize);
    public InternalScope<ByteStringMemoryCache> Execute(Slice fieldName, ReadOnlySpan`1<byte> source, ReadOnlySpan`1& buffer, ReadOnlySpan`1& tokens);
    public InternalScope<ByteStringMemoryCache> Execute(FieldMetadata field, ReadOnlySpan`1<byte> source, ReadOnlySpan`1& buffer, ReadOnlySpan`1& tokens, bool exact);
    public InternalScope<ByteStringMemoryCache> Execute(Analyzer analyzer, ReadOnlySpan`1<byte> source, ReadOnlySpan`1& buffer, ReadOnlySpan`1& tokens);
    private Analyzer GetAnalyzer(Slice fieldName, FieldMetadata field);
    [DoesNotReturnAttribute]
private static Analyzer ThrowWhenAnalyzerModeNotFound(FieldIndexingMode mode);
    [DoesNotReturnAttribute]
private static void ThrowWhenDynamicFieldNotFound(Slice fieldName);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.AnonymousCoraxDocumentConverter : AnonymousCoraxDocumentConverterBase {
    public AnonymousCoraxDocumentConverter(Index index, bool storeValue);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.Corax.AnonymousCoraxDocumentConverterBase : CoraxDocumentConverterBase {
    private bool _isMultiMap;
    private IPropertyAccessor _propertyAccessor;
    public AnonymousCoraxDocumentConverterBase(Index index, int numberOfBaseFields, string keyFieldName, bool storeValue, bool canContainSourceDocumentId);
    protected virtual bool SetDocumentFields(LazyStringValue key, LazyStringValue sourceDocumentId, object doc, JsonOperationContext indexContext, TBuilder builder, object sourceDocument);
    [CompilerGeneratedAttribute]
private void <SetDocumentFields>g__HandleCompoundFields|3_0(<>c__DisplayClass3_0`1& );
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxDocumentConverter : CoraxDocumentConverterBase {
    public CoraxDocumentConverter(Index index, bool indexImplicitNull, bool indexEmptyEntries, string keyFieldName, bool storeValue, string storeValueFieldName);
    protected virtual bool SetDocumentFields(LazyStringValue key, LazyStringValue sourceDocumentId, object doc, JsonOperationContext indexContext, TBuilder builder, object sourceDocument);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxDocumentConverterBase : ConverterBase {
    protected Byte[] _compoundFieldsBuffer;
    private bool _canContainSourceDocumentId;
    private bool _legacyHandlingOfComplexFields;
    private static StandardFormat StandardFormat;
    private static StandardFormat TimeSpanFormat;
    private ConversionScope Scope;
    private Lazy`1<IndexFieldsMapping> _knownFieldsForReaders;
    protected IndexFieldsMapping KnownFieldsForWriter;
    protected ByteStringContext Allocator;
    public List`1<ByteString> StringsListForEnumerableScope;
    public List`1<long> LongsListForEnumerableScope;
    public List`1<double> DoublesListForEnumerableScope;
    public List`1<BlittableJsonReaderObject> BlittableJsonReaderObjectsListForEnumerableScope;
    public bool IgnoreComplexObjectsDuringIndex;
    public List`1<String[]> CompoundFields;
    protected HashSet`1<string> _nonExistingFieldsOfDocument;
    private static ReadOnlySpan`1<byte> TrueLiteral { get; }
    private static ReadOnlySpan`1<byte> FalseLiteral { get; }
    protected CoraxDocumentConverterBase(Index index, bool storeValue, bool indexImplicitNull, bool indexEmptyEntries, int numberOfBaseFields, string keyFieldName, string storeValueFieldName, bool canContainSourceDocumentId, ICollection`1<IndexField> fields);
    private static CoraxDocumentConverterBase();
    private static ReadOnlySpan`1<byte> get_TrueLiteral();
    private static ReadOnlySpan`1<byte> get_FalseLiteral();
    protected abstract virtual bool SetDocumentFields(LazyStringValue key, LazyStringValue sourceDocumentId, object doc, JsonOperationContext indexContext, TBuilder builder, object sourceDocument);
    [SkipLocalsInitAttribute]
public bool SetDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object doc, JsonOperationContext indexContext, TBuilder builder);
    public IndexFieldsMapping GetKnownFieldsForQuerying();
    private IndexFieldsMapping CreateKnownFieldsForWriter();
    public IndexFieldsMapping GetKnownFieldsForWriter();
    [SkipLocalsInitAttribute]
protected void InsertRegularField(IndexField field, object value, JsonOperationContext indexContext, TBuilder builder, object sourceDocument, Boolean& shouldSkip);
    protected void RegisterMissingFieldFor(IndexField field);
    protected void WriteNonExistingMarkerForMissingFields(TBuilder builder);
    [DoesNotReturnAttribute]
private static void ThrowFieldIsNoIndexedAndStored(IndexField field);
    private void AssertIndexingBehaviorForComplexObjectInStaticIndex(IndexField field);
    private void ComplexObjectInStaticIndexLegacyHandling(IndexField field);
    private void HandleObject(BlittableJsonReaderObject val, IndexField field, JsonOperationContext indexContext, TBuilder builder, object sourceDocument, Boolean& shouldSkip);
    private void DisableIndexingForComplexObjectLegacyHandling(IndexField field);
    [DoesNotReturnAttribute]
internal static void ThrowIndexingComplexObjectNotSupportedInStaticIndex(IndexField field, long indexVersion);
    protected int AppendFieldValue(string field, object v, int index, TBuilder builder);
    [DoesNotReturnAttribute]
protected void ThrowFieldInCompoundFieldNotFound(string field);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private Span`1<byte> <AppendFieldValue>g__EnsureHasSpace|35_0(int additionalSize, <>c__DisplayClass35_0`1& );
    [CompilerGeneratedAttribute]
private int <AppendFieldValue>g__AppendAnalyzedTerm|35_1(Span`1<byte> term, <>c__DisplayClass35_0`1& );
    [CompilerGeneratedAttribute]
private void <AppendFieldValue>g__AppendLong|35_2(long l, <>c__DisplayClass35_0`1& );
}
internal class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxDocumentTrainEnumerator : object {
    private DocumentsStorage _documentStorage;
    private DocumentsOperationContext _docsContext;
    private TransactionOperationContext _indexContext;
    private Index _index;
    private IndexType _indexType;
    private CoraxDocumentConverterBase _converter;
    private HashSet`1<string> _collections;
    private int _take;
    private IEnumerator`1<ArraySegment`1<byte>> _itemsEnumerable;
    private CancellationToken _token;
    private Size _maxAllocatedMemory;
    private IndexingStatsScope _indexingStatsScope;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public CoraxDocumentTrainEnumerator(TransactionOperationContext indexContext, CoraxDocumentConverterBase converter, Index index, IndexType indexType, DocumentsStorage storage, DocumentsOperationContext docsContext, HashSet`1<string> collections, CancellationToken token, IndexingStatsScope indexingStatsScope, int take);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Corax.CoraxDocumentTrainEnumerator/<GetItems>d__18")]
private IEnumerable`1<ArraySegment`1<byte>> GetItems();
    private IEnumerator`1<Document> GetDocumentsEnumerator(DocumentsOperationContext docsContext, string collection, long take, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Corax.CoraxDocumentTrainEnumerator/<GetItemsEnumerator>d__20")]
private IEnumerable`1<IndexItem> GetItemsEnumerator(DocumentsOperationContext docsContext, string collection, long take, CancellationToken token);
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext(ReadOnlySpan`1& output);
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxDocumentTrainSourceEnumerator : object {
    private DocumentsStorage _documentsStorage;
    public CoraxDocumentTrainSourceEnumerator(DocumentsStorage documentsStorage);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Corax.CoraxDocumentTrainSourceEnumerator/<GetDocumentsForDictionaryTraining>d__2")]
public IEnumerable`1<Document> GetDocumentsForDictionaryTraining(DocumentsOperationContext context, string collection, CoraxDocumentTrainSourceState state, DocumentFields fields);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Corax.CoraxDocumentTrainSourceEnumerator/<GetDocumentsForDictionaryTraining>d__3")]
public IEnumerable`1<Document> GetDocumentsForDictionaryTraining(DocumentsOperationContext context, CoraxDocumentTrainSourceState state, DocumentFields fields);
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxDocumentTrainSourceState : PulsedEnumerationState`1<Document> {
    private long _takeLimit;
    public long Take;
    private bool _initialized;
    public long CurrentKey;
    public CancellationToken Token;
    public long DocumentSkip;
    public CoraxDocumentTrainSourceState(DocumentsOperationContext context, Size pulseLimit, long takeLimit, CancellationToken token, int numberOfEnumeratedDocumentsToCheckIfPulseLimitExceeded);
    public void InitializeState(Table documentsTable);
    public virtual void OnMoveNext(Document current);
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxDynamicItem : object {
    public string FieldName;
    public IndexField Field;
    public object Value;
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxHighlightingTermIndex : object {
    public static String[] DefaultPreTags;
    public static String[] DefaultPostTags;
    public string FieldName;
    public string DynamicFieldName;
    public string GroupKey;
    public object Values;
    public String[] PreTags;
    public String[] PostTags;
    private static CoraxHighlightingTermIndex();
    public string GetPreTagByIndex(int i);
    public string GetPostTagByIndex(int i);
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexedEntriesReader : object {
    private JsonOperationContext _ctx;
    private IndexSearcher _indexSearcher;
    public CoraxIndexedEntriesReader(JsonOperationContext ctx, IndexSearcher indexSearcher);
    public DynamicJsonValue GetDocument(EntryTermsReader& entryReader);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static DynamicJsonValue <GetDocument>g__ToJson|3_0(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <GetDocument>g__ForceList|3_1(string name, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <GetDocument>g__SetValue|3_2(string name, object value, <>c__DisplayClass3_0& );
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexFacetedReadOperation : IndexFacetReadOperationBase {
    private IndexFieldsMapping _fieldMappings;
    private Dictionary`2<string, long> _fieldNameToRootPage;
    private IndexSearcher _indexSearcher;
    private ByteStringContext _allocator;
    private Dictionary`2<string, Slice> _fieldNameCache;
    public CoraxIndexFacetedReadOperation(Index index, Logger logger, Transaction readTransaction, QueryBuilderFactories queryBuilderFactories, IndexFieldsMapping fieldsMapping);
    public virtual List`1<FacetResult> FacetedQuery(FacetQuery facetQuery, QueryTimingsScope queryTimings, DocumentsOperationContext context, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    private List`1<FacetResult> IndexedFacetedQuery(Dictionary`2<string, FacetResult> results, FacetQuery facetQuery, QueryTimingsScope queryTimings, DocumentsOperationContext context, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    private List`1<FacetResult> ScanningFacetedQuery(Dictionary`2<string, FacetResult> results, FacetQuery facetQuery, QueryTimingsScope queryTimings, DocumentsOperationContext context, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    private void UpdateRangeResults(Dictionary`2<string, FacetResult> results, Dictionary`2<string, Dictionary`2<string, FacetValues>> facetsByRange);
    private void CreateMappingForRanges(Dictionary`2<string, FacetResult> results, Dictionary`2<string, Dictionary`2<string, FacetValues>> facetsByRange, FacetQuery facetQuery);
    private void HandleRangeFacetsPerDocument(EntryTermsReader& reader, string name, FacetResult result, bool legacy, QueryTimingsScope queryTimings, Dictionary`2<string, FacetValues> facetValues, CancellationToken token);
    private void HandleFacetsPerDocument(EntryTermsReader& reader, KeyValuePair`2<string, FacetResult> result, Dictionary`2<string, Dictionary`2<string, FacetValues>> facetsByName, bool legacy, QueryTimingsScope queryTimings, CancellationToken token);
    private void InsertTerm(ReadOnlySpan`1<byte> term, EntryTermsReader& reader, Dictionary`2<string, FacetValues> facetValues, KeyValuePair`2<string, FacetResult> result, bool legacy, bool needToApplyAggregation, CancellationToken token);
    private long GetFieldRootPage(string fieldName);
    private void ApplyAggregation(Dictionary`2<FacetAggregationField, Aggregation> aggregations, FacetValues values, EntryTermsReader& reader);
    [CompilerGeneratedAttribute]
private FieldMetadata <IndexedFacetedQuery>g__GetFieldMetadata|7_1(string name);
    [CompilerGeneratedAttribute]
private List`1<string> <IndexedFacetedQuery>b__7_2();
}
public static class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexingHelpers : object {
    private static ConcurrentDictionary`2<Type, bool> NotForQuerying;
    private static CoraxIndexingHelpers();
    private static Analyzer GetCoraxAnalyzer(string fieldName, string analyzer, Dictionary`2<Type, Analyzer> analyzers, bool forQuerying, string databaseName);
    public static IndexFieldsMapping CreateMappingWithAnalyzers(Index index, IndexDefinitionBaseServerSide indexDefinition, string keyFieldName, bool storedValue, string storedValueFieldName, bool forQuerying, bool canContainSourceDocumentId);
    [CompilerGeneratedAttribute]
internal static Analyzer <CreateMappingWithAnalyzers>g__CreateKeywordAnalyzer|2_4(ByteStringContext context, string fieldName, Type analyzerType, bool isForQuerying);
    [CompilerGeneratedAttribute]
internal static Analyzer <CreateMappingWithAnalyzers>g__CreateStandardAnalyzer|2_5(ByteStringContext context, string fieldName, Type analyzerType, bool forQuerying);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexingStats : ValueType {
    private IndexingStatsScope _stats;
    public CoraxIndexingStats(IndexingStatsScope indexingStatsScope);
    public sealed virtual ICoraxStatsScope For(string name, bool start);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexPersistence : IndexPersistenceBase {
    private static bool DisableDictionaryTraining;
    private Logger _logger;
    private CoraxDocumentConverterBase _converter;
    [CompilerGeneratedAttribute]
private bool <HasWriter>k__BackingField;
    public bool HasWriter { get; }
    public CoraxIndexPersistence(Index index, IIndexReadOperationFactory indexReadOperationFactory);
    private CoraxDocumentConverterBase CreateConverter(Index index);
    public virtual IndexReadOperationBase OpenIndexReader(Transaction readTransaction, IndexQueryServerSide query);
    public virtual bool ContainsField(string field);
    public virtual IndexFacetReadOperationBase OpenFacetedIndexReader(Transaction readTransaction);
    public virtual SuggestionIndexReaderBase OpenSuggestionIndexReader(Transaction readTransaction, string field);
    public virtual void Dispose();
    public virtual bool RequireOnBeforeExecuteIndexing();
    public virtual void OnBeforeExecuteIndexing(IndexingStatsAggregator indexingStatsAggregator, CancellationToken token);
    private void CreatePersistentDictionary(IndexingStatsAggregator indexingStatsAggregator, CancellationToken token);
    [CompilerGeneratedAttribute]
public virtual bool get_HasWriter();
    public virtual void CleanWritersIfNeeded();
    public virtual void Clean(IndexCleanup mode);
    public virtual void Initialize(StorageEnvironment environment);
    public virtual void PublishIndexCacheToNewTransactions(IndexTransactionCache transactionCache);
    internal virtual IndexTransactionCache BuildStreamCacheAfterTx(Transaction tx);
    internal virtual void RecreateSearcher(Transaction asOfTx);
    internal virtual void RecreateSuggestionsSearchers(Transaction asOfTx);
    public virtual void DisposeWriters();
    public virtual IndexWriteOperationBase OpenIndexWriter(Transaction writeTransaction, JsonOperationContext indexContext);
    public virtual void AssertCanOptimize();
    public virtual void AssertCanDump();
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexReadOperation : IndexReadOperationBase {
    [ThreadStaticAttribute]
private static ArrayPool`1<long> _queryPool;
    [ThreadStaticAttribute]
private static ArrayPool`1<float> _queryScorePool;
    [ThreadStaticAttribute]
private static ArrayPool`1<SpatialResult> _queryDistancePool;
    protected IndexSearcher IndexSearcher;
    private IndexFieldsMapping _fieldMappings;
    private ByteStringContext _allocator;
    private int _maxNumberOfOutputsPerDocument;
    private TermsReader _documentIdReader;
    public static ArrayPool`1<long> QueryPool { get; }
    private static ArrayPool`1<float> ScorePool { get; }
    private static ArrayPool`1<SpatialResult> DistancePool { get; }
    public CoraxIndexReadOperation(Index index, Logger logger, Transaction readTransaction, QueryBuilderFactories queryBuilderFactories, IndexFieldsMapping fieldsMapping, IndexQueryServerSide query);
    public static ArrayPool`1<long> get_QueryPool();
    private static ArrayPool`1<float> get_ScorePool();
    private static ArrayPool`1<SpatialResult> get_DistancePool();
    public virtual long EntriesCount();
    private static bool WillAlwaysIncludeInResults(IndexType indexType, FieldsToFetch fieldsToFetch, IndexQueryServerSide query);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexReadOperation/<QueryInternal>d__30`4")]
private IEnumerable`1<QueryResult> QueryInternal(IndexQueryServerSide query, QueryTimingsScope queryTimings, FieldsToFetch fieldsToFetch, Reference`1<long> totalResults, Reference`1<long> skippedResults, Reference`1<long> scannedDocuments, IQueryResultRetriever retriever, DocumentsOperationContext documentsContext, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    protected virtual QueryResult CreateQueryResult(IdentityTracker`1& tracker, Document document, IndexQueryServerSide query, DocumentsOperationContext documentsContext, EntryTermsReader& entryReader, FieldsToFetch highlightingFields, OrderMetadata[] orderByFields, THighlighting& highlightings, Reference`1<long> skippedResults, THasProjection& hasProjections, Boolean& markedAsSkipped);
    public virtual IEnumerable`1<QueryResult> Query(IndexQueryServerSide query, QueryTimingsScope queryTimings, FieldsToFetch fieldsToFetch, Reference`1<long> totalResults, Reference`1<long> skippedResults, Reference`1<long> scannedDocuments, IQueryResultRetriever retriever, DocumentsOperationContext documentsContext, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    private static int ProcessHighlightings(HighlightingField current, CoraxHighlightingTermIndex highlightingTerm, ReadOnlySpan`1<char> fieldFragment, List`1<string> fragments, int maxFragmentCount);
    public virtual IEnumerable`1<QueryResult> IntersectQuery(IndexQueryServerSide query, FieldsToFetch fieldsToFetch, Reference`1<long> totalResults, Reference`1<long> skippedResults, Reference`1<long> scannedDocuments, IQueryResultRetriever retriever, DocumentsOperationContext documentsContext, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    public virtual SortedSet`1<string> Terms(string field, string fromValue, long pageSize, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexReadOperation/<MoreLikeThis>d__36")]
public virtual IEnumerable`1<QueryResult> MoreLikeThis(IndexQueryServerSide query, IQueryResultRetriever retriever, DocumentsOperationContext context, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexReadOperation/<IndexEntries>d__37")]
public virtual IEnumerable`1<BlittableJsonReaderObject> IndexEntries(IndexQueryServerSide query, Reference`1<long> totalResults, DocumentsOperationContext documentsContext, Func`2<string, SpatialField> getSpatialField, bool ignoreLimit, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexReadOperation/<DynamicEntriesFields>d__38")]
public virtual IEnumerable`1<string> DynamicEntriesFields(HashSet`1<string> staticFields);
    public virtual void Dispose();
    [DoesNotReturnAttribute]
private static void ThrowDistinctOnBiggerCollectionThanInt32();
    [DoesNotReturnAttribute]
private static void ThrowExplanationsIsNotImplementedInCorax();
    [CompilerGeneratedAttribute]
private TQueryFilter <QueryInternal>g__GetQueryFilter|30_0(<>c__DisplayClass30_0`4& );
    [CompilerGeneratedAttribute]
internal static long <IndexEntries>g__Skip|37_0(<>c__DisplayClass37_0& );
    [CompilerGeneratedAttribute]
private void <Dispose>b__39_0();
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxIndexWriteOperation : IndexWriteOperationBase {
    public static int MaximumPersistedCapacityOfCoraxWriter;
    private IndexWriter _indexWriter;
    private CoraxDocumentConverterBase _converter;
    private IndexFieldsMappingBuilder _dynamicFieldsBuilder;
    private IndexFieldsMapping _dynamicFields;
    private CurrentIndexingScope _indexingScope;
    private ByteStringContext _allocator;
    public CoraxIndexWriteOperation(Index index, Transaction writeTransaction, CoraxDocumentConverterBase converter, Logger logger);
    public virtual void Commit(IndexingStatsScope stats);
    public virtual void UpdateDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public virtual void IndexDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public void UpdateDynamicFieldsBindings();
    public virtual long EntriesCount();
    public virtual ValueTuple`2<long, long> GetAllocations();
    public virtual void Optimize(CancellationToken token);
    public virtual void Delete(LazyStringValue key, IndexingStatsScope stats);
    private void DeleteByField(string fieldName, LazyStringValue key, IndexingStatsScope stats);
    public virtual void DeleteBySourceDocument(LazyStringValue sourceDocumentId, IndexingStatsScope stats);
    public virtual void DeleteReduceResult(LazyStringValue reduceKeyHash, IndexingStatsScope stats);
    private void EnsureValidStats(IndexingStatsScope stats);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static FieldIndexingMode <UpdateDynamicFieldsBindings>g__FieldIndexingIntoFieldIndexingMode|11_0(FieldIndexing option);
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxJintDocumentConverter : CoraxJintDocumentConverterBase {
    public CoraxJintDocumentConverter(MapIndex index, bool storeValue);
    public CoraxJintDocumentConverter(MapReduceIndex index, bool storeValue);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxJintDocumentConverterBase : CoraxDocumentConverterBase {
    private IndexFieldOptions _allFields;
    private bool _ticksSupport;
    private bool _dynamicFieldsProperlyHandleDynamicConfiguration;
    protected CoraxJintDocumentConverterBase(Index index, IndexDefinition definition, bool storeValue, int numberOfBaseFields, string keyFieldName, string storeValueFieldName, ICollection`1<IndexField> fields, bool canContainSourceDocumentId);
    protected virtual bool SetDocumentFields(LazyStringValue key, LazyStringValue sourceDocumentId, object doc, JsonOperationContext indexContext, TBuilder builder, object sourceDocument);
    private IndexField GetFieldObjectForProcessing(String& propertyAsString, CurrentIndexingScope indexingScope);
    private bool IsDynamicFieldEnumerable(JsValue propertyDescriptorValue, string propertyAsString, IndexField& field, CurrentIndexingScope indexingScope, IEnumerator`1& iterator);
    private JsValue TryDetectDynamicFieldCreation(string property, ObjectInstance valueAsObject, IndexField& field, CurrentIndexingScope scope);
    [DoesNotReturnAttribute]
private static void ThrowWhenBoostingIsInDocument();
    [CompilerGeneratedAttribute]
private void <SetDocumentFields>g__ProcessAsJson|4_0(JsValue actualValue, IndexField field, ObjectInstance documentToProcess, Boolean& shouldSkip, <>c__DisplayClass4_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <SetDocumentFields>g__TryGetBoostedValue|4_1(ObjectInstance valueToCheck, JsValue& value, TBuilder builder);
    [CompilerGeneratedAttribute]
internal static bool <SetDocumentFields>g__IsObject|4_2(JsValue value);
    [CompilerGeneratedAttribute]
private void <SetDocumentFields>g__ProcessObject|4_3(JsValue valueToInsert, String& propertyAsString, IndexField& field, Boolean& shouldProcessAsBlittable, Object& value, JsValue& actualValue, Boolean& shouldSkip, <>c__DisplayClass4_0`1& );
    [CompilerGeneratedAttribute]
private void <SetDocumentFields>g__HandleCompoundFields|4_4(<>c__DisplayClass4_0`1& );
    [CompilerGeneratedAttribute]
internal static TEnum <TryDetectDynamicFieldCreation>g__GetEnum|7_0(JsValue optionValue, string propertyName);
}
public static class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxQueryBuilder : object {
    internal static int TakeAll;
    private static IQueryMatch MaterializeWhenNeeded(Parameters builderParameters, IQueryMatch source, StreamingOptimization& streamingConfiguration);
    internal static IQueryMatch BuildQuery(Parameters builderParameters, OrderMetadata[]& sortMetadata);
    private static IQueryMatch ToCoraxQuery(Parameters builderParameters, QueryExpression expression, StreamingOptimization& leftOnlyOptimization, bool exact, Nullable`1<int> proximity);
    private static IQueryMatch HandleIn(Parameters builderParameters, InExpression ie, bool exact);
    private static bool TryUseNegatedQuery(Parameters builderParameters, NegatedExpression ne1, IQueryMatch& match, bool exact);
    public static MoreLikeThisQuery BuildMoreLikeThisQuery(Parameters builderParameters, QueryExpression whereExpression);
    private static IQueryMatch ToMoreLikeThisQuery(Parameters builderParameters, QueryExpression whereExpression, String& baseDocument, BlittableJsonReaderObject& options);
    private static bool TryMergeTwoNodesForAnd(IndexSearcher indexSearcher, Parameters parameters, IQueryMatch& lhs, IQueryMatch& rhs, CoraxBooleanQueryBase& merged, StreamingOptimization& streamingOptimization, bool requiredMaterialization);
    private static IQueryMatch HandleExact(Parameters builderParameters, MethodExpression expression, StreamingOptimization& streamingConfiguration, Nullable`1<int> proximity);
    private static IQueryMatch TranslateBetweenQuery(Parameters builderParameters, BetweenExpression be, bool exact);
    private static IQueryMatch HandleExists(Parameters builderParameters, MethodExpression expression, StreamingOptimization& streamingOptimization);
    private static IQueryMatch HandleStartsWith(Parameters builderParameters, MethodExpression expression, bool exact, StreamingOptimization& streamingOptimization, bool negated);
    private static MultiTermMatch HandleEndsWith(Parameters builderParameters, MethodExpression expression, bool exact, StreamingOptimization& streamingOptimization, bool negated);
    private static IQueryMatch HandleBoost(Parameters builderParameters, MethodExpression expression, bool exact);
    private static IQueryMatch HandleSearch(Parameters builderParameters, MethodExpression expression, Nullable`1<int> proximity);
    private static IQueryMatch HandleSpatial(Parameters builderParameters, MethodExpression expression, MethodType spatialMethod);
    private static IQueryMatch HandleRegex(Parameters builderParameters, MethodExpression expression, StreamingOptimization& streamingOptimization);
    public static OrderMetadata[] GetSortMetadata(Parameters builderParameters);
    private static IQueryMatch OrderBy(Parameters builderParameters, IQueryMatch match, OrderMetadata[]& orderMetadata);
    [CompilerGeneratedAttribute]
internal static IQueryMatch <ToCoraxQuery>g__HandleStringUnaryMatch|5_0(Parameters queryEnvironment, <>c__DisplayClass5_0& , <>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static IQueryMatch <TranslateBetweenQuery>g__HandleStringBetween|12_0(<>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static void <HandleSearch>g__AddEscapePosition|17_3(int i, <>c__DisplayClass17_1& );
    [CompilerGeneratedAttribute]
internal static string <HandleSearch>g__YieldValue|17_1(string input, int startIndex, int length, List`1<int> escapePositions);
    [CompilerGeneratedAttribute]
internal static bool <HandleSearch>g__IsEscaped|17_2(string input, int index);
    [CompilerGeneratedAttribute]
internal static bool <HandleRegex>g__IsStringFamily|19_0(object value);
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CoraxSuggestionReader : SuggestionIndexReaderBase {
    private IndexFieldsMapping _fieldMappings;
    private IndexSearcher _indexSearcher;
    private IndexFieldBinding _binding;
    private static int MaxTermSize;
    public CoraxSuggestionReader(Index index, Logger logger, IndexFieldBinding binding, Transaction readTransaction, IndexFieldsMapping fieldsMapping);
    public virtual SuggestionResult Suggestions(IndexQueryServerSide query, SuggestionField field, JsonOperationContext documentsContext, CancellationToken token);
    private SuggestWord[] QueryOverMultipleWords(SuggestionField field, List`1<string> words, SuggestionOptions options);
    private SuggestWord[] QueryOverSingleWord(SuggestionField field, string word, SuggestionOptions options);
    internal virtual void AddPopularity(SuggestWord suggestion, SuggestionResult& result);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CountersAndTimeSeriesAnonymousCoraxDocumentConverter : AnonymousCoraxDocumentConverterBase {
    public CountersAndTimeSeriesAnonymousCoraxDocumentConverter(Index index);
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.CountersAndTimeSeriesJintCoraxDocumentConverter : CoraxJintDocumentConverterBase {
    public CountersAndTimeSeriesJintCoraxDocumentConverter(MapTimeSeriesIndex index);
    public CountersAndTimeSeriesJintCoraxDocumentConverter(MapCountersIndex index);
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.OutputReduceCoraxIndexWriteOperation : CoraxIndexWriteOperation {
    private OutputReduceIndexWriteOperationScope`1<OutputReduceCoraxIndexWriteOperation> _outputScope;
    public OutputReduceCoraxIndexWriteOperation(MapReduceIndex index, Transaction writeTransaction, CoraxDocumentConverterBase converter, Logger logger, JsonOperationContext indexContext);
    public virtual void Commit(IndexingStatsScope stats);
    public virtual void IndexDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public virtual void Delete(LazyStringValue key, IndexingStatsScope stats);
    public virtual void UpdateDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public virtual void DeleteReduceResult(LazyStringValue reduceKeyHash, IndexingStatsScope stats);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.QueryOptimizer.CoraxAndQueries : CoraxBooleanQueryBase {
    private List`1<CoraxBooleanItem> _queryStack;
    public bool IsBoosting { get; }
    public CoraxAndQueries(IndexSearcher indexSearcher, Parameters parameters, CoraxBooleanItem left, CoraxBooleanItem right);
    public bool TryMerge(CoraxAndQueries other);
    public bool TryAnd(IQueryMatch item);
    public virtual IQueryMatch Materialize();
    private static int PrioritizeSort(CoraxBooleanItem firstUnaryItem, CoraxBooleanItem secondUnaryItem);
    public bool get_IsBoosting();
    [CompilerGeneratedAttribute]
private bool <Materialize>g__ShouldPerformScan|4_0(Span`1<CoraxBooleanItem> queries, Int32& pos);
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.QueryOptimizer.CoraxBooleanItem : ValueType {
    public FieldMetadata Field;
    public object Term;
    public object Term2;
    public string TermAsString;
    public UnaryMatchOperation Operation;
    public UnaryMatchOperation BetweenLeft;
    public UnaryMatchOperation BetweenRight;
    private IndexSearcher _indexSearcher;
    private bool _isTime;
    public Nullable`1<float> Boosting;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    private static string IQueryMatchUsageException;
    public bool IsBoosting { get; }
    public long Count { get; }
    public QueryCountConfidence Confidence { get; }
    private CoraxBooleanItem(IndexSearcher searcher, Index index, FieldMetadata field, object term, UnaryMatchOperation operation);
    private CoraxBooleanItem(IndexSearcher searcher, Index index, FieldMetadata field, object term1, object term2, UnaryMatchOperation operation, UnaryMatchOperation left, UnaryMatchOperation right);
    public sealed virtual bool get_IsBoosting();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual long get_Count();
    public static IQueryMatch Build(IndexSearcher searcher, Index index, FieldMetadata field, object term, UnaryMatchOperation operation, StreamingOptimization& streamingOptimization);
    public static IQueryMatch Build(IndexSearcher searcher, Index index, FieldMetadata field, object term1, object term2, UnaryMatchOperation operation, UnaryMatchOperation left, UnaryMatchOperation right, StreamingOptimization& streamingOptimization);
    public IQueryMatch OptimizeCompoundField(StreamingOptimization& streamingOptimization);
    private Slice GetStartWithTerm();
    public IQueryMatch Materialize(StreamingOptimization& streamingOptimization);
    public sealed virtual SkipSortingResult AttemptToSkipSorting();
    public sealed virtual QueryCountConfidence get_Confidence();
    public sealed virtual int Fill(Span`1<long> matches);
    public sealed virtual int AndWith(Span`1<long> buffer, int matches);
    public sealed virtual void Score(Span`1<long> matches, Span`1<float> scores, float boostFactor);
    public sealed virtual QueryInspectionNode Inspect();
    public virtual string ToString();
    public static bool CanBeMergedForAnd(CoraxBooleanItem lhsBq, CoraxBooleanItem rhsBq);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.Corax.QueryOptimizer.CoraxBooleanQueryBase : object {
    public Nullable`1<float> Boosting;
    protected IndexSearcher IndexSearcher;
    protected Parameters _parameters;
    protected bool _hasBinary;
    protected static string QueryMatchUsageException;
    public bool HasBinary { get; }
    public bool IsBoosting { get; }
    public long Count { get; }
    public QueryCountConfidence Confidence { get; }
    protected CoraxBooleanQueryBase(IndexSearcher indexSearcher, Parameters parameters);
    public abstract virtual IQueryMatch Materialize();
    public bool get_HasBinary();
    protected IQueryMatch TransformCoraxBooleanItemIntoQueryMatch(CoraxBooleanItem leftmostClause);
    public sealed virtual bool get_IsBoosting();
    public sealed virtual SkipSortingResult AttemptToSkipSorting();
    public sealed virtual long get_Count();
    public sealed virtual QueryCountConfidence get_Confidence();
    public sealed virtual int Fill(Span`1<long> matches);
    public sealed virtual int AndWith(Span`1<long> buffer, int matches);
    public sealed virtual void Score(Span`1<long> matches, Span`1<float> scores, float boostFactor);
    public sealed virtual QueryInspectionNode Inspect();
    protected bool EqualsScoreFunctions(CoraxBooleanQueryBase other);
    protected bool EqualsScoreFunctions(CoraxBooleanItem other);
}
public class Raven.Server.Documents.Indexes.Persistence.Corax.QueryOptimizer.CoraxOrQueries : CoraxBooleanQueryBase {
    private List`1<CoraxBooleanItem> _unaryMatchesList;
    private Dictionary`2<FieldMetadata, List`1<string>> _termMatchesList;
    private List`1<IQueryMatch> _complexMatches;
    public CoraxOrQueries(IndexSearcher indexSearcher, Parameters parameters);
    private bool TryMerge(CoraxOrQueries other);
    public bool TryAddItem(IQueryMatch itemToAdd);
    private bool TryAddItem(CoraxBooleanItem itemToAdd);
    public virtual IQueryMatch Materialize();
    [CompilerGeneratedAttribute]
private void <Materialize>g__AddToQueryTree|7_0(IQueryMatch query, <>c__DisplayClass7_0& );
}
public class Raven.Server.Documents.Indexes.Persistence.DatabaseIndexReadOperationFactory : object {
    public sealed virtual LuceneIndexReadOperation CreateLuceneIndexReadOperation(Index index, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, QueryBuilderFactories queryBuilderFactories, Transaction readTransaction, IndexQueryServerSide query);
    public sealed virtual CoraxIndexReadOperation CreateCoraxIndexReadOperation(Index index, Logger logger, Transaction readTransaction, QueryBuilderFactories queryBuilderFactories, IndexFieldsMapping fieldsMapping, IndexQueryServerSide query);
    public sealed virtual LuceneSuggestionIndexReader CreateLuceneSuggestionIndexReader(Index index, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, Transaction readTransaction);
}
public enum Raven.Server.Documents.Indexes.Persistence.FilterResult : Enum {
    public int value__;
    public static FilterResult Accepted;
    public static FilterResult Skipped;
    public static FilterResult LimitReached;
}
public interface Raven.Server.Documents.Indexes.Persistence.IIndexReadOperationFactory {
    public abstract virtual LuceneIndexReadOperation CreateLuceneIndexReadOperation(Index index, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, QueryBuilderFactories queryBuilderFactories, Transaction readTransaction, IndexQueryServerSide query);
    public abstract virtual CoraxIndexReadOperation CreateCoraxIndexReadOperation(Index index, Logger logger, Transaction readTransaction, QueryBuilderFactories queryBuilderFactories, IndexFieldsMapping fieldsMapping, IndexQueryServerSide query);
    public abstract virtual LuceneSuggestionIndexReader CreateLuceneSuggestionIndexReader(Index index, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, Transaction readTransaction);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.IndexFacetReadOperationBase : IndexOperationBase {
    protected QueryBuilderFactories _queryBuilderFactories;
    public IndexFacetReadOperationBase(Index index, QueryBuilderFactories queryBuilderFactories, Logger logger);
    public abstract virtual List`1<FacetResult> FacetedQuery(FacetQuery facetQuery, QueryTimingsScope queryTimings, DocumentsOperationContext context, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    protected static void CompleteFacetCalculationsStage(Dictionary`2<string, FacetResult> results, IndexQueryServerSide query);
    internal static void UpdateFacetResults(Dictionary`2<string, FacetResult> results, IndexQueryServerSide query, Dictionary`2<string, Dictionary`2<string, FacetValues>> facetsByName);
    internal static ValueTuple`4<List`1<FacetValue>, int, int, int> GetSortedAndPagedFacetValues(List`1<string> allTerms, int start, int pageSize, Dictionary`2<string, FacetValues> groups, Action`1<FacetValue> onFacetValueAdd);
    internal static List`1<string> GetAllTermsSorted(FacetTermSortMode sortMode, List`1<string> valueSortedIds, Dictionary`2<string, FacetValues> values);
    public virtual void Dispose();
}
public abstract class Raven.Server.Documents.Indexes.Persistence.IndexOperationBase : object {
    protected string _indexName;
    private static int DefaultBufferSizeForCorax;
    private static int MaxBufferSizeForCorax;
    protected Logger _logger;
    internal Index _index;
    protected IndexOperationBase(Index index, Logger logger);
    public abstract virtual void Dispose();
    protected Query GetLuceneQuery(DocumentsOperationContext context, QueryMetadata metadata, BlittableJsonReaderObject parameters, Analyzer analyzer, QueryBuilderFactories factories);
    protected Query GetLuceneQuery(DocumentsOperationContext context, QueryMetadata metadata, QueryExpression whereExpression, BlittableJsonReaderObject parameters, Analyzer analyzer, QueryBuilderFactories factories);
    protected static int LuceneGetPageSize(IndexSearcher searcher, long pageSize);
    protected static int CoraxBufferSize(IndexSearcher searcher, long pageSize, IndexQueryServerSide query);
    protected QueryFilter GetQueryFilter(Index index, IndexQueryServerSide query, DocumentsOperationContext documentsContext, Reference`1<long> skippedResults, Reference`1<long> scannedDocuments, IQueryResultRetriever retriever, QueryTimingsScope queryTimings);
    internal static BlittableJsonReaderObject ParseJsonStringIntoBlittable(string json, JsonOperationContext context);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.IndexPersistenceBase : object {
    protected Index _index;
    [CompilerGeneratedAttribute]
private IIndexReadOperationFactory <IndexReadOperationFactory>k__BackingField;
    protected IIndexReadOperationFactory IndexReadOperationFactory { get; }
    public bool HasWriter { get; }
    protected IndexPersistenceBase(Index index, IIndexReadOperationFactory indexReadOperationFactory);
    [CompilerGeneratedAttribute]
protected IIndexReadOperationFactory get_IndexReadOperationFactory();
    public abstract virtual bool get_HasWriter();
    public abstract virtual void CleanWritersIfNeeded();
    public abstract virtual void Clean(IndexCleanup mode);
    public abstract virtual void Initialize(StorageEnvironment environment);
    public abstract virtual bool RequireOnBeforeExecuteIndexing();
    public abstract virtual void OnBeforeExecuteIndexing(IndexingStatsAggregator indexingStatsAggregator, CancellationToken token);
    public abstract virtual void PublishIndexCacheToNewTransactions(IndexTransactionCache transactionCache);
    internal abstract virtual IndexTransactionCache BuildStreamCacheAfterTx(Transaction tx);
    public abstract virtual IndexWriteOperationBase OpenIndexWriter(Transaction writeTransaction, JsonOperationContext indexContext);
    public abstract virtual IndexReadOperationBase OpenIndexReader(Transaction readTransaction, IndexQueryServerSide query);
    public abstract virtual bool ContainsField(string field);
    public abstract virtual IndexFacetReadOperationBase OpenFacetedIndexReader(Transaction readTransaction);
    public abstract virtual SuggestionIndexReaderBase OpenSuggestionIndexReader(Transaction readTransaction, string field);
    public abstract virtual void AssertCanOptimize();
    public abstract virtual void AssertCanDump();
    internal abstract virtual void RecreateSearcher(Transaction asOfTx);
    internal abstract virtual void RecreateSuggestionsSearchers(Transaction asOfTx);
    public abstract virtual void DisposeWriters();
    public abstract virtual void Dispose();
}
public abstract class Raven.Server.Documents.Indexes.Persistence.IndexQueryingScopeBase`1 : object {
    protected IndexType _indexType;
    protected IndexQueryServerSide _query;
    protected FieldsToFetch _fieldsToFetch;
    protected IQueryResultRetriever _retriever;
    protected bool _isSortingQuery;
    protected HashSet`1<ulong> _alreadySeenProjections;
    protected HashSet`1<TKey> _alreadySeenDocumentKeysInPreviousPage;
    protected int _alreadyScannedForDuplicates;
    public IndexQueryingScopeBase`1(IndexType indexType, IndexQueryServerSide query, FieldsToFetch fieldsToFetch, IQueryResultRetriever retriever, HashSet`1<TKey> alreadySeenDocumentKeysInPreviousPage);
    public bool WillProbablyIncludeInResults(TKey key);
    public bool TryIncludeInResults(Document document);
    public sealed virtual void Dispose();
}
public abstract class Raven.Server.Documents.Indexes.Persistence.IndexReadOperationBase : IndexOperationBase {
    protected QueryBuilderFactories QueryBuilderFactories;
    private MemoryInfo _memoryInfo;
    private static long ThresholdForMemoryUsageLoggingInBytes;
    protected IndexReadOperationBase(Index index, Logger logger, QueryBuilderFactories queryBuilderFactories, IndexQueryServerSide query);
    private static IndexReadOperationBase();
    public abstract virtual long EntriesCount();
    internal virtual void AssertCanOrderByScoreAutomaticallyWhenBoostingIsInvolved();
    public abstract virtual IEnumerable`1<QueryResult> Query(IndexQueryServerSide query, QueryTimingsScope queryTimings, FieldsToFetch fieldsToFetch, Reference`1<long> totalResults, Reference`1<long> skippedResults, Reference`1<long> scannedDocuments, IQueryResultRetriever retriever, DocumentsOperationContext documentsContext, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    public abstract virtual IEnumerable`1<QueryResult> IntersectQuery(IndexQueryServerSide query, FieldsToFetch fieldsToFetch, Reference`1<long> totalResults, Reference`1<long> skippedResults, Reference`1<long> scannedDocuments, IQueryResultRetriever retriever, DocumentsOperationContext documentsContext, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    public abstract virtual SortedSet`1<string> Terms(string field, string fromValue, long pageSize, CancellationToken token);
    public abstract virtual IEnumerable`1<QueryResult> MoreLikeThis(IndexQueryServerSide query, IQueryResultRetriever retriever, DocumentsOperationContext context, CancellationToken token);
    public abstract virtual IEnumerable`1<BlittableJsonReaderObject> IndexEntries(IndexQueryServerSide query, Reference`1<long> totalResults, DocumentsOperationContext documentsContext, Func`2<string, SpatialField> getSpatialField, bool ignoreLimit, CancellationToken token);
    public abstract virtual IEnumerable`1<string> DynamicEntriesFields(HashSet`1<string> staticFields);
    public virtual void Dispose();
}
public abstract class Raven.Server.Documents.Indexes.Persistence.IndexWriteOperationBase : IndexOperationBase {
    protected IndexingStatsScope _statsInstance;
    protected IndexWriteOperationStats Stats;
    protected IndexWriteOperationBase(Index index, Logger logger);
    public abstract virtual void Commit(IndexingStatsScope stats);
    public abstract virtual void Optimize(CancellationToken token);
    public abstract virtual void UpdateDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public abstract virtual void IndexDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public abstract virtual long EntriesCount();
    public abstract virtual ValueTuple`2<long, long> GetAllocations();
    public abstract virtual void Delete(LazyStringValue key, IndexingStatsScope stats);
    public abstract virtual void DeleteBySourceDocument(LazyStringValue sourceDocumentId, IndexingStatsScope stats);
    public abstract virtual void DeleteReduceResult(LazyStringValue reduceKeyHash, IndexingStatsScope stats);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.AbstractCultureCollationAnalyzer : CollationAnalyzer {
    private static ConcurrentDictionary`2<Type, CultureInfo> CultureCache;
    private static AbstractCultureCollationAnalyzer();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.CollationAnalyzer : Analyzer {
    private CultureInfo _cultureInfo;
    public CollationAnalyzer(CultureInfo cultureInfo);
    protected void Init(CultureInfo ci);
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.CollationKeyFilter : TokenFilter {
    private TermAttribute _termAtt;
    private CultureInfo _cultureInfo;
    public CollationKeyFilter(TokenStream input, CultureInfo cultureInfo);
    public virtual bool IncrementToken();
    private Byte[] GetCollationKey(string text);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.AfCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.AmCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.ArCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.ArnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.AsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.AzCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.BaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.BeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.BgCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.BnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.BoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.BrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.BsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.CaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.CoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.CsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.CyCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.DaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.DeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.DsbCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.DvCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.ElCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.EnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.EsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.EtCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.EuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.FaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.FiCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.FilCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.FoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.FrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.FyCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.GaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.GdCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.GlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.GswCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.GuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.HaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.HeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.HiCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.HrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.HsbCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.HuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.HyCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.IdCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.IgCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.IiCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.IsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.ItCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.IuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.IvCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.JaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.KaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.KkCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.KlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.KmCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.KnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.KoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.KokCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.KyCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.LbCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.LoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.LtCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.LvCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.MiCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.MkCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.MlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.MnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.MohCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.MrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.MsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.MtCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.NbCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.NeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.NlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.NnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.NsoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.OcCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.OrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.PaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.PlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.PrsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.PsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.PtCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.QutCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.QuzCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.RmCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.RoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.RuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.RwCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SahCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SiCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SkCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SmaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SmjCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SmnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SmsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SqCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SvCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SwCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.SyrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.TaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.TeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.TgCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.ThCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.TkCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.TnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.TrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.TtCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.TzmCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.UgCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.UkCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.UrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.UzCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.ViCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.WoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.XhCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.YoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.ZhCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.Cultures.ZuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.Collation.IndexableBinaryStringTools_UsingArrays : object {
    private static CodingCase[] CODING_CASES;
    private static IndexableBinaryStringTools_UsingArrays();
    public static int GetEncodedLength(IList`1<byte> original);
    public static int GetDecodedLength(IList`1<char> encoded);
    public static void Encode(Byte[] input, Char[] output);
    private static void Decode(Char[] input, Byte[] output);
    public static Byte[] Decode(Char[] input);
    public static Char[] Encode(Byte[] input);
}
public interface Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.ILowerCaseTokenizerHelper {
    public abstract virtual bool IsTokenChar(char c);
    public abstract virtual char Normalize(char c);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.LowerCaseKeywordAnalyzer : Analyzer {
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.LowerCaseKeywordTokenizer : LowerCaseTokenizerBase`1<LowerCaseKeywordTokenizerHelper> {
    public LowerCaseKeywordTokenizer(TextReader input);
    public LowerCaseKeywordTokenizer(AttributeSource source, TextReader input);
    public LowerCaseKeywordTokenizer(AttributeFactory factory, TextReader input);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.LowerCaseKeywordTokenizerHelper : ValueType {
    private static TextInfo _invariantTextInfo;
    private static LowerCaseKeywordTokenizerHelper();
    public sealed virtual bool IsTokenChar(char c);
    public sealed virtual char Normalize(char c);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.LowerCaseTokenizerBase`1 : Tokenizer {
    private static T Helper;
    private int _offset;
    private int _bufferIndex;
    private int _dataLen;
    private static int IO_BUFFER_SIZE;
    private Char[] _ioBuffer;
    private ITermAttribute _termAtt;
    private IOffsetAttribute _offsetAtt;
    public LowerCaseTokenizerBase`1(TextReader input);
    protected LowerCaseTokenizerBase`1(AttributeSource source, TextReader input);
    protected LowerCaseTokenizerBase`1(AttributeFactory factory, TextReader input);
    public virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset(TextReader tr);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.LowerCaseWhitespaceAnalyzer : LowerCaseKeywordAnalyzer {
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.LowerCaseWhitespaceTokenizer : LowerCaseTokenizerBase`1<LowerCaseWhitespaceTokenizerHelper> {
    public LowerCaseWhitespaceTokenizer(TextReader input);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.LowerCaseWhitespaceTokenizerHelper : ValueType {
    private static TextInfo _invariantTextInfo;
    private static LowerCaseWhitespaceTokenizerHelper();
    public sealed virtual bool IsTokenChar(char c);
    public sealed virtual char Normalize(char c);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.LuceneRavenPerFieldAnalyzerWrapper : Analyzer {
    private Analyzer _defaultAnalyzer;
    private Analyzer _defaultExactAnalyzer;
    private Analyzer _defaultSearchAnalyzer;
    private Func`2<string, Analyzer> _defaultSearchAnalyzerFactory;
    private Func`2<string, Analyzer> _defaultExactAnalyzerFactory;
    private Dictionary`2<string, Analyzer> _analyzerMap;
    private bool _hasDynamicFields;
    public LuceneRavenPerFieldAnalyzerWrapper(Analyzer defaultAnalyzer);
    public LuceneRavenPerFieldAnalyzerWrapper(Analyzer defaultAnalyzer, Func`2<string, Analyzer> defaultSearchAnalyzerFactory, Func`2<string, Analyzer> defaultExactAnalyzerFactory);
    public void AddAnalyzer(string fieldName, Analyzer analyzer);
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    internal Analyzer GetAnalyzer(string fieldName);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
    public virtual int GetPositionIncrementGap(string fieldName);
    public virtual int GetOffsetGap(IFieldable field);
    public virtual string ToString();
    public virtual void Dispose();
}
[NotForQueryingAttribute]
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.NGramAnalyzer : Analyzer {
    private int _minGram;
    private int _maxGram;
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.NGramTokenFilter : TokenFilter {
    public static int DEFAULT_MIN_NGRAM_SIZE;
    public static int DEFAULT_MAX_NGRAM_SIZE;
    private int _minGram;
    private int _maxGram;
    private Char[] _curTermBuffer;
    private int _curTermLength;
    private int _curGramSize;
    private int _curPos;
    private int _tokStart;
    private TermAttribute _termAtt;
    private OffsetAttribute _offsetAtt;
    public NGramTokenFilter(TokenStream input, int minGram, int maxGram);
    public NGramTokenFilter(TokenStream input);
    private static NGramTokenFilter();
    public virtual bool IncrementToken();
    public virtual void Reset();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.RavenStandardAnalyzer : StandardAnalyzer {
    private Version _matchVersion;
    public RavenStandardAnalyzer(Version matchVersion);
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Analyzers.RavenStandardFilter : TokenFilter {
    private TokenStream _innerInputStream;
    private static string APOSTROPHE_TYPE;
    private static string ACRONYM_TYPE;
    private ITypeAttribute _typeAtt;
    private ITermAttribute _termAtt;
    private static bool IsAsciiCasingSameAsInvariant;
    private static TextInfo InvariantTextInfo;
    private CharArraySet _stopWords;
    public RavenStandardFilter(TokenStream input);
    private static RavenStandardFilter();
    public virtual bool IncrementToken();
    private char ToLower(char c);
    public bool Reset(TextReader reader);
}
internal static class Raven.Server.Documents.Indexes.Persistence.Lucene.Collectors.CollectorsPool : object {
    public static ObjectPool`1<List`1<ScoreDoc>> Instance;
    private static CollectorsPool();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Collectors.GatherAllCollector : Collector {
    private int _docBase;
    private List`1<ScoreDoc> _docs;
    private Scorer _scorer;
    private float _maxScore;
    public bool AcceptsDocsOutOfOrder { get; }
    public GatherAllCollector(int numberOfDocsToCollect);
    public virtual void SetScorer(Scorer scorer);
    public virtual void Collect(int doc, IState state);
    public virtual void SetNextReader(IndexReader reader, int docBase, IState state);
    public virtual bool get_AcceptsDocsOutOfOrder();
    public TopDocs ToTopDocs();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Collectors.IntersectionCollector : Collector {
    private Dictionary`2<string, SubQueryResult> _results;
    private IndexReader _currentReader;
    private Scorer _currentScorer;
    public bool AcceptsDocsOutOfOrder { get; }
    public IntersectionCollector(Searchable indexSearcher, IEnumerable`1<ScoreDoc> scoreDocs, IState state);
    public virtual void SetScorer(Scorer scorer);
    public virtual void Collect(int doc, IState state);
    public virtual void SetNextReader(IndexReader reader, int docBase, IState state);
    public virtual bool get_AcceptsDocsOutOfOrder();
    public IEnumerable`1<SubQueryResult> DocumentsIdsForCount(int expectedCount);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Collectors.NonSortingCollector : Collector {
    private int _numberOfDocsToCollect;
    private List`1<ScoreDoc> _docs;
    private int _totalHits;
    private int _docBase;
    private Scorer _scorer;
    private float _maxScore;
    public bool AcceptsDocsOutOfOrder { get; }
    public NonSortingCollector(int numberOfDocsToCollect);
    public virtual void SetScorer(Scorer scorer);
    public virtual void Collect(int doc, IState state);
    public virtual void SetNextReader(IndexReader reader, int docBase, IState state);
    public virtual bool get_AcceptsDocsOutOfOrder();
    public TopDocs ToTopDocs();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.AnonymousLuceneDocumentConverter : AnonymousLuceneDocumentConverterBase {
    public AnonymousLuceneDocumentConverter(Index index, bool storeValue);
    [ObsoleteAttribute("Used for testing purposes only")]
public AnonymousLuceneDocumentConverter(Index index, ICollection`1<IndexField> fields, bool isMultiMap, bool indexImplicitNull, bool indexEmptyEntries, bool storeValue);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.AnonymousLuceneDocumentConverterBase : LuceneDocumentConverterBase {
    private bool _isMultiMap;
    private IPropertyAccessor _propertyAccessor;
    protected AnonymousLuceneDocumentConverterBase(Index index, int numberOfBaseFields, string keyFieldName, bool storeValue, string storeValueFieldName);
    [ObsoleteAttribute("Used for testing purposes only")]
protected AnonymousLuceneDocumentConverterBase(Index index, ICollection`1<IndexField> fields, bool isMultiMap, bool indexImplicitNull, bool indexEmptyEntries, int numberOfBaseFields, string keyFieldName, bool storeValue, string storeValueFieldName);
    protected virtual int GetFields(T instance, LazyStringValue key, LazyStringValue sourceDocumentId, object document, JsonOperationContext indexContext, IWriteOperationBuffer writeBuffer, object sourceDocument);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.DictionaryAccessor : object {
    private Dictionary`2<string, DictionaryValueAccessor> _properties;
    private List`1<KeyValuePair`2<string, DictionaryValueAccessor>> _propertiesInOrder;
    private DictionaryAccessor(Dictionary`2<string, object> instance, Dictionary`2<string, CompiledIndexField> groupByFields);
    internal static DictionaryAccessor Create(Dictionary`2<string, object> instance, Dictionary`2<string, CompiledIndexField> groupByFields);
    public sealed virtual IEnumerator`1<PropertyItem> GetProperties(object target);
    public sealed virtual object GetValue(string name, object target);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.DynamicGetter : MulticastDelegate {
    public DynamicGetter(object object, IntPtr method);
    public virtual object Invoke(object target);
    public virtual IAsyncResult BeginInvoke(object target, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.Fields.BlittableObjectReader : object {
    private NonDisposableStreamReader _reader;
    private MemoryStream _ms;
    private StringBuilder _sb;
    private Char[] _readBuffer;
    public int Capacity { get; }
    public int get_Capacity();
    public TextReader GetTextReaderFor(BlittableJsonReaderObject value);
    public string GetStringFor(BlittableJsonReaderObject value);
    public void ResetCapacity();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.Fields.BlittableObjectReaderPool : object {
    public static BlittableObjectReaderPool Instance;
    private static int PoolSize;
    private static Size LowMemoryCapacityThreshold;
    private bool _isLowMemory;
    private ObjectPool`1<BlittableObjectReader> _pool;
    private static BlittableObjectReaderPool();
    public BlittableObjectReader Allocate();
    public void Free(BlittableObjectReader reader);
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.Fields.CachedFieldItem`1 : object {
    public FieldCacheKey Key;
    public T Field;
    [CompilerGeneratedAttribute]
private LazyStringReader <LazyStringReader>k__BackingField;
    public LazyStringReader LazyStringReader { get; public set; }
    [CompilerGeneratedAttribute]
public LazyStringReader get_LazyStringReader();
    [CompilerGeneratedAttribute]
public void set_LazyStringReader(LazyStringReader value);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.Fields.FieldCacheKey : object {
    internal string _name;
    internal Nullable`1<Index> _index;
    internal Store _store;
    internal TermVector _termVector;
    internal Int32[] _multipleItemsSameField;
    private int _hashKey;
    internal int HashKey { get; }
    public FieldCacheKey(string name, Nullable`1<Index> index, Store store, TermVector termVector, Int32[] multipleItemsSameField);
    internal int get_HashKey();
    public bool IsSame(string name, Nullable`1<Index> index, Store store, TermVector termVector, Int32[] multipleItemsSameField);
    public bool IsSame(string name, Nullable`1<Index> index, Store store, TermVector termVector, List`1<int> multipleItemsSameField);
    public static int CalculateHashCode(string name, Nullable`1<Index> index, Store store, TermVector termVector, Int32[] multipleItemsSameField);
    public static int CalculateHashCode(string name, Nullable`1<Index> index, Store store, TermVector termVector, List`1<int> multipleItemsSameField);
    public virtual int GetHashCode();
}
public interface Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.ILuceneDocumentWrapper {
    public abstract virtual void Add(AbstractField field);
    public abstract virtual IList`1<IFieldable> GetFields();
}
public interface Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.IPropertyAccessor {
    public abstract virtual IEnumerator`1<PropertyItem> GetProperties(object target);
    public abstract virtual object GetValue(string name, object target);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.JintLuceneDocumentConverter : JintLuceneDocumentConverterBase {
    public JintLuceneDocumentConverter(MapIndex index, bool storeValue);
    public JintLuceneDocumentConverter(MapReduceIndex index, bool storeValue);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.JintLuceneDocumentConverterBase : LuceneDocumentConverterBase {
    private IndexFieldOptions _allFields;
    private bool _ticksSupport;
    private bool _dynamicFieldsDynamicAnalyzer;
    protected JintLuceneDocumentConverterBase(Index index, IndexDefinition indexDefinition, int numberOfBaseFields, string keyFieldName, bool storeValue, string storeValueFieldName);
    protected virtual int GetFields(T instance, LazyStringValue key, LazyStringValue sourceDocumentId, object document, JsonOperationContext indexContext, IWriteOperationBuffer writeBuffer, object sourceDocument);
    private static bool TryGetBoostedValue(ObjectInstance valueToCheck, JsValue& value, Nullable`1& boost);
    private JsValue TryDetectDynamicFieldCreation(string property, ObjectInstance valueAsObject, IndexField& field);
    private static IEnumerable`1<AbstractField> LuceneCreateField(CurrentIndexingScope scope, IndexField field, object value);
    [CompilerGeneratedAttribute]
private void <GetFields>g__ProcessObject|4_0(JsValue valueToInsert, String& propertyAsString, IndexField& field, bool isDynamicFieldsEnumeratorScope, Boolean& shouldProcessAsBlittable, Object& value, Nullable`1& propertyBoost, Int32& numberOfCreatedFields, JsValue& actualValue, <>c__DisplayClass4_0`1& );
    [CompilerGeneratedAttribute]
private int <GetFields>g__ProcessAsJson|4_1(JsValue actualValue, IndexField field, Nullable`1<float> propertyBoost, <>c__DisplayClass4_0`1& );
    [CompilerGeneratedAttribute]
private bool <GetFields>g__IsDynamicFieldEnumerable|4_2(JsValue propertyDescriptorValue, string propertyAsString, IndexField& field, IEnumerator`1& iterator, <>c__DisplayClass4_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <GetFields>g__IsObject|4_3(JsValue value);
    [CompilerGeneratedAttribute]
internal static object <GetFields>g__CreateValueForIndexing|4_4(object value, Nullable`1<float> boost);
    [CompilerGeneratedAttribute]
internal static void <GetFields>g__BoostDocument|4_5(T instance, int numberOfCreatedFields, Nullable`1<float> boost);
    [CompilerGeneratedAttribute]
internal static TEnum <TryDetectDynamicFieldCreation>g__GetEnum|6_0(JsValue optionValue, string propertyName);
}
internal class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.JintPropertyAccessor : object {
    private Dictionary`2<string, CompiledIndexField> _groupByFields;
    public JintPropertyAccessor(Dictionary`2<string, CompiledIndexField> groupByFields);
    public sealed virtual IEnumerator`1<PropertyItem> GetProperties(object target);
    public sealed virtual object GetValue(string name, object target);
    private static object GetValue(JsValue jsValue);
    [DoesNotReturnAttribute]
private static void ThrowInvalidObject(JsValue jsValue);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.LuceneDocumentConverter : LuceneDocumentConverterBase {
    public LuceneDocumentConverter(Index index, bool indexEmptyEntries, string keyFieldName, bool storeValue, string storeValueFieldName);
    public LuceneDocumentConverter(Index index, ICollection`1<IndexField> fields, bool indexImplicitNull, bool indexEmptyEntries, string keyFieldName, bool storeValue, string storeValueFieldName);
    protected virtual int GetFields(T instance, LazyStringValue key, LazyStringValue sourceDocumentId, object doc, JsonOperationContext indexContext, IWriteOperationBuffer writeBuffer, object sourceDocument);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.LuceneDocumentConverterBase : ConverterBase {
    protected static float LuceneDefaultBoost;
    internal static string IsArrayFieldSuffix;
    internal static string ConvertToJsonSuffix;
    internal static string TrueString;
    internal static string FalseString;
    private Field _storeValueField;
    protected ConversionScope Scope;
    internal static int MaximumNumberOfItemsInFieldsCacheForMultipleItemsSameField;
    private int _numberOfItemsInFieldsCacheForMultipleItemsSameField;
    private int _numberOfItemsInNumericFieldsCacheForMultipleItemsSameField;
    private Dictionary`2<int, CachedFieldItem`1<Field>> _fieldsCache;
    private Dictionary`2<int, CachedFieldItem`1<NumericField>> _numericFieldsCache;
    public Document Document;
    private List`1<int> _multipleItemsSameFieldCount;
    protected LuceneDocumentConverterBase(Index index, bool indexEmptyEntries, int numberOfBaseFields, string keyFieldName, bool storeValue, string storeValueFieldName);
    protected LuceneDocumentConverterBase(Index index, ICollection`1<IndexField> fields, bool indexImplicitNull, bool indexEmptyEntries, int numberOfBaseFields, string keyFieldName, bool storeValue, string storeValueFieldName);
    private static LuceneDocumentConverterBase();
    public void Clean();
    public IDisposable SetDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, JsonOperationContext indexContext, IWriteOperationBuffer writeBuffer, Boolean& shouldSkip);
    protected abstract virtual int GetFields(T instance, LazyStringValue key, LazyStringValue sourceDocumentId, object document, JsonOperationContext indexContext, IWriteOperationBuffer writeBuffer, object sourceDocument);
    public int GetRegularFields(T instance, IndexField field, object value, JsonOperationContext indexContext, object sourceDocument, Boolean& shouldSkip, bool nestedArray);
    public ReduceMultipleValuesScope NestedField(int v);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.LuceneDocumentConverterBase/<GetComplexObjectFields>d__23")]
private IEnumerable`1<AbstractField> GetComplexObjectFields(string path, BlittableJsonReaderObject val, Store storage, Index indexing, TermVector termVector);
    protected Field GetOrCreateKeyField(LazyStringValue key);
    protected Field GetOrCreateSourceDocumentIdField(LazyStringValue key);
    protected Field GetOrCreateField(string name, string value, LazyStringValue lazyValue, Stream streamValue, BlittableJsonReaderObject blittableValue, Store store, Index index, TermVector termVector);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.LuceneDocumentConverterBase/<GetOrCreateNumericField>d__27")]
private IEnumerable`1<AbstractField> GetOrCreateNumericField(IndexField field, object value, Store storage, TermVector termVector);
    private NumericField GerOrCreateNumericLongField(string name, long value, Store storage, TermVector termVector);
    private NumericField GetNumericFieldFromCache(string name, Nullable`1<Index> index, Store store, TermVector termVector);
    private static bool CanCreateFieldsForNestedArray(object value, FieldIndexing fieldIndexing);
    protected AbstractField GetStoredValueField(BlittableJsonReaderObject value, IWriteOperationBuffer writeBuffer);
    private Byte[] GetStoredValue(BlittableJsonReaderObject value, IWriteOperationBuffer writeBuffer);
    public virtual void Dispose();
    private static void ClearFieldCache(Dictionary`2<int, CachedFieldItem`1<T>> fieldCache);
    private void AddToFieldsCache(int cacheKey, bool isMultipleItemsSameField, CachedFieldItem`1<Field> oldItem, CachedFieldItem`1<Field> newItem);
    private void AddToNumericFieldsCache(int cacheKey, bool isMultipleItemsSameField, CachedFieldItem`1<NumericField> oldItem, CachedFieldItem`1<NumericField> newItem);
    [CompilerGeneratedAttribute]
private int <GetRegularFields>g__HandleArray|20_0(IEnumerable itemsToIndex, <>c__DisplayClass20_0`1& );
    [CompilerGeneratedAttribute]
private int <GetRegularFields>g__HandleObject|20_1(BlittableJsonReaderObject val, <>c__DisplayClass20_0`1& );
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.PropertyAccessor : object {
    private Dictionary`2<string, Accessor> Properties;
    private List`1<KeyValuePair`2<string, Accessor>> _propertiesInOrder;
    private PropertyAccessor(Type type, Dictionary`2<string, CompiledIndexField> groupByFields);
    public sealed virtual IEnumerator`1<PropertyItem> GetProperties(object target);
    public static IPropertyAccessor Create(Type type, object instance);
    public sealed virtual object GetValue(string name, object target);
    private static ValueTypeAccessor CreateGetMethodForValueType(PropertyInfo prop, Type type);
    private static ClassAccessor CreateGetMethodForClass(PropertyInfo propertyInfo, Type type);
    internal static IPropertyAccessor CreateMapReduceOutputAccessor(Type type, object instance, Dictionary`2<string, CompiledIndexField> groupByFields, bool isObjectInstance);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.PropertyItem : ValueType {
    public string Key;
    public object Value;
    public CompiledIndexField GroupByField;
    public bool IsGroupByField;
    public PropertyItem(string key, object value, CompiledIndexField groupByField, bool isGroupByField);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.TimeSeries.CountersAndTimeSeriesAnonymousLuceneDocumentConverter : AnonymousLuceneDocumentConverterBase {
    public CountersAndTimeSeriesAnonymousLuceneDocumentConverter(Index index);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Documents.TimeSeries.CountersAndTimeSeriesJintLuceneDocumentConverter : JintLuceneDocumentConverterBase {
    public CountersAndTimeSeriesJintLuceneDocumentConverter(MapTimeSeriesIndex index);
    public CountersAndTimeSeriesJintLuceneDocumentConverter(MapCountersIndex index);
    public CountersAndTimeSeriesJintLuceneDocumentConverter(MapReduceTimeSeriesIndex index);
    public CountersAndTimeSeriesJintLuceneDocumentConverter(MapReduceCountersIndex index);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.Highlightings.PerFieldFragmentsBuilder : BaseFragmentsBuilder {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ValueTuple`2<String[], String[]>> _tagsPerField;
    private string _lastFieldName;
    public PerFieldFragmentsBuilder(IndexQueryServerSide query, JsonOperationContext context);
    private static Dictionary`2<string, ValueTuple`2<String[], String[]>> CreateTags(IndexQueryServerSide query, JsonOperationContext context);
    public virtual List`1<WeightedFragInfo> GetWeightedFragInfoList(List`1<WeightedFragInfo> src);
    public virtual String[] CreateFragments(IndexReader reader, int docId, string fieldName, FieldFragList fieldFragList, int maxNumFragments, int fragCharSize, IState state);
    protected virtual string GetPreTag(int num);
    protected virtual string GetPostTag(int num);
}
internal static class Raven.Server.Documents.Indexes.Persistence.Lucene.IndexedTerms : object {
    private static WeakCache CacheInstance;
    private static IndexedTerms();
    public static Dictionary`2<string, Int32[]> GetTermsAndDocumentsFor(IndexReader reader, int docBase, string field, string indexName, IState state);
    public static BlittableJsonReaderObject[] ReadAllEntriesFromIndex(IndexReader reader, JsonOperationContext context, bool ignoreLimit, IState state);
    private static Dictionary`2<string, Int32[]> FillCache(IndexReader reader, int docBase, string field, IState state);
    private static bool LowPrecisionNumber(string field, string val);
}
public interface Raven.Server.Documents.Indexes.Persistence.Lucene.IWriteOperationBuffer {
    public abstract virtual Byte[] GetBuffer(int necessarySize);
}
public abstract class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneAnalyzerAdapter : Analyzer {
    private static ITransformer[] NoTransformers;
    protected Analyzer Analyzer;
    protected LuceneAnalyzerAdapter(Analyzer analyzer, method functionUtf8, method functionUtf16);
    private static LuceneAnalyzerAdapter();
    internal static void Run(Analyzer adapter, ReadOnlySpan`1<char> source, Span`1& output, Span`1& tokens);
    public static LuceneAnalyzerAdapter Create(Analyzer analyzer, bool forQuerying);
}
internal class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneAnalyzerAdapterForQuerying : LuceneAnalyzerAdapter {
    [ThreadStaticAttribute]
private static LazyStringReader LazyStringReader;
    [ThreadStaticAttribute]
private static TokenStream Stream;
    [ThreadStaticAttribute]
private static IOffsetAttribute Offset;
    [ThreadStaticAttribute]
private static ITermAttribute Term;
    private LuceneAnalyzerAdapterForQuerying(Analyzer analyzer, method functionUtf8, method functionUtf16);
    private static void Run(Analyzer adapter, ReadOnlySpan`1<byte> source, Span`1& output, Span`1& tokens, Byte[]& buffer);
    internal static LuceneAnalyzerAdapterForQuerying Create(Analyzer analyzer);
}
internal class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneAnalyzerAdapterForWriter : LuceneAnalyzerAdapter {
    private LazyStringReader _lazyStringReader;
    private TokenStream _stream;
    private IOffsetAttribute _offset;
    private ITermAttribute _term;
    private LuceneAnalyzerAdapterForWriter(Analyzer analyzer, method functionUtf8, method functionUtf16);
    private static void Run(Analyzer adapter, ReadOnlySpan`1<byte> source, Span`1& output, Span`1& tokens, Byte[]& buffer);
    internal static LuceneAnalyzerAdapterForWriter Create(Analyzer analyzer);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexFacetedReadOperation : IndexFacetReadOperationBase {
    private IndexSearcher _searcher;
    private IDisposable _releaseReadTransaction;
    private LuceneRavenPerFieldAnalyzerWrapper _analyzer;
    private IDisposable _releaseSearcher;
    private IState _state;
    public LuceneIndexFacetedReadOperation(Index index, IndexDefinitionBaseServerSide indexDefinition, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, QueryBuilderFactories queryBuilderFactories, Transaction readTransaction, DocumentDatabase documentDatabase);
    public virtual List`1<FacetResult> FacetedQuery(FacetQuery facetQuery, QueryTimingsScope queryTimings, DocumentsOperationContext context, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    private void HandleRangeFacets(List`1<ReaderFacetInfo> returnedReaders, KeyValuePair`2<string, FacetResult> result, bool legacy, QueryTimingsScope queryTimings, CancellationToken token);
    private void HandleFacets(List`1<ReaderFacetInfo> returnedReaders, KeyValuePair`2<string, FacetResult> result, Dictionary`2<string, Dictionary`2<string, FacetValues>> facetsByName, bool legacy, QueryTimingsScope queryTimings, CancellationToken token);
    private static void ApplyAggregation(Dictionary`2<FacetAggregationField, Aggregation> aggregations, FacetValues values, ArraySegment`1<int> docsInQuery, IndexReader indexReader, int docBase, IState state);
    private static List`1<ReaderFacetInfo> GetQueryMatchingDocuments(IndexSearcher currentIndexSearcher, Query baseQuery, IState state);
    private IntersectDocs GetIntersectedDocuments(ArraySegment`1<int> a, ArraySegment`1<int> b, bool needToApplyAggregation);
    public virtual void Dispose();
}
public static class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexingExtensions : object {
    private static Assembly LuceneAssembly;
    private static Type[] ConstructorParameterTypes;
    private static Object[] ConstructorParameterValues;
    private static LuceneIndexingExtensions();
    public static Analyzer CreateAnalyzerInstance(string name, Type analyzerType);
    public static AnalyzerFactory GetAnalyzerType(string name, string analyzerTypeAsString, string databaseName);
}
public static class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexingHelpers : object {
    private static ConcurrentDictionary`2<Type, bool> NotForQuerying;
    private static LuceneIndexingHelpers();
    public static LuceneRavenPerFieldAnalyzerWrapper CreateLuceneAnalyzer(Index index, IndexDefinitionBaseServerSide indexDefinition, bool forQuerying);
    private static Analyzer GetLuceneAnalyzer(string fieldName, string analyzer, Dictionary`2<Type, Analyzer> analyzers, bool forQuerying, string databaseName);
    [CompilerGeneratedAttribute]
internal static Analyzer <CreateLuceneAnalyzer>g__CreateDefaultAnalyzer|1_4(string fieldName, Type analyzerType);
    [CompilerGeneratedAttribute]
internal static Analyzer <CreateLuceneAnalyzer>g__CreateKeywordAnalyzer|1_5(string fieldName, Type analyzerType);
    [CompilerGeneratedAttribute]
internal static Analyzer <CreateLuceneAnalyzer>g__CreateStandardAnalyzer|1_6(string fieldName, Type analyzerType);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexPersistence : IndexPersistenceBase {
    private Analyzer _dummyAnalyzer;
    internal IndexReader _lastReader;
    private LuceneDocumentConverterBase _converter;
    private IndexTransactionCache _streamsCache;
    private static StopAnalyzer StopAnalyzer;
    private LuceneIndexWriter _indexWriter;
    private Dictionary`2<string, LuceneSuggestionIndexWriter> _suggestionsIndexWriters;
    private SnapshotDeletionPolicy _snapshotter;
    internal TempFileCache TempFileCache;
    private LuceneVoronDirectory _directory;
    private Dictionary`2<string, LuceneVoronDirectory> _suggestionsDirectories;
    private Dictionary`2<string, LuceneIndexSearcherHolder> _suggestionsIndexSearcherHolders;
    private LuceneIndexSearcherHolder _luceneIndexSearcherHolder;
    private DisposeOnce`1<SingleAttempt> _disposeOnce;
    private bool _initialized;
    private Dictionary`2<string, IndexField> _fields;
    private Logger _logger;
    private object _readersLock;
    private bool _indexWriterCleanupNeeded;
    public bool HasWriter { get; }
    public LuceneVoronDirectory LuceneDirectory { get; }
    public LuceneIndexPersistence(Index index, IIndexReadOperationFactory indexReadOperationFactory);
    private static LuceneIndexPersistence();
    public virtual bool get_HasWriter();
    public LuceneVoronDirectory get_LuceneDirectory();
    public virtual void CleanWritersIfNeeded();
    public virtual void Clean(IndexCleanup mode);
    public virtual void Initialize(StorageEnvironment environment);
    public virtual bool RequireOnBeforeExecuteIndexing();
    public virtual void OnBeforeExecuteIndexing(IndexingStatsAggregator indexingStatsAggregator, CancellationToken token);
    public virtual void PublishIndexCacheToNewTransactions(IndexTransactionCache transactionCache);
    internal virtual IndexTransactionCache BuildStreamCacheAfterTx(Transaction tx);
    private void SetStreamCacheInTx(LowLevelTransaction tx);
    private void FillCollectionEtags(Transaction tx, Dictionary`2<string, CollectionEtags> map);
    private void FillLuceneFilesChunks(Transaction tx, Dictionary`2<string, ChunkDetails[]> cache, string name);
    private void InitializeSuggestionsIndexStorage(Transaction tx, StorageEnvironment environment);
    private void InitializeMainIndexStorage(Transaction tx, StorageEnvironment environment);
    private void CreateIndexStructure(LuceneVoronDirectory directory, IState state);
    public virtual IndexWriteOperationBase OpenIndexWriter(Transaction writeTransaction, JsonOperationContext indexContext);
    public virtual IndexReadOperationBase OpenIndexReader(Transaction readTransaction, IndexQueryServerSide query);
    public virtual IndexFacetReadOperationBase OpenFacetedIndexReader(Transaction readTransaction);
    public virtual SuggestionIndexReaderBase OpenSuggestionIndexReader(Transaction readTransaction, string field);
    internal virtual void RecreateSearcher(Transaction asOfTx);
    internal virtual void RecreateSuggestionsSearchers(Transaction asOfTx);
    internal LuceneIndexWriter EnsureIndexWriter(IState state);
    internal Dictionary`2<string, LuceneSuggestionIndexWriter> EnsureSuggestionIndexWriter(IState state);
    public virtual bool ContainsField(string field);
    public virtual void DisposeWriters();
    public virtual void Dispose();
    private void CheckDisposed();
    private void CheckInitialized();
    public virtual void AssertCanOptimize();
    public virtual void AssertCanDump();
    [CompilerGeneratedAttribute]
private void <.ctor>b__22_0();
    [CompilerGeneratedAttribute]
private IndexSearcher <.ctor>g__CreateIndexSearcher|22_3(IState state);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexQueryingScope : IndexQueryingScopeBase`1<string> {
    private IndexSearcher _searcher;
    private IState _state;
    public LuceneIndexQueryingScope(IndexType indexType, IndexQueryServerSide query, FieldsToFetch fieldsToFetch, IndexSearcher searcher, IQueryResultRetriever retriever, IState state);
    public void RecordAlreadyPagedItemsInPreviousPage(TopDocs search, CancellationToken token);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexReadOperation : IndexReadOperationBase {
    private static Sort SortByFieldScore;
    private IndexType _indexType;
    private bool _indexHasBoostedFields;
    private LuceneRavenPerFieldAnalyzerWrapper _analyzer;
    private IDisposable _releaseSearcher;
    private IDisposable _releaseReadTransaction;
    private int _maxNumberOfOutputsPerDocument;
    protected IState _state;
    private IDisposable _readLock;
    private FastVectorHighlighter _highlighter;
    private FieldQuery _highlighterQuery;
    protected IndexSearcher _searcher;
    private static LuceneCleaner _luceneCleaner;
    private static LuceneIndexReadOperation();
    public LuceneIndexReadOperation(Index index, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, QueryBuilderFactories queryBuilderFactories, Transaction readTransaction, IndexQueryServerSide query);
    public virtual long EntriesCount();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexReadOperation/<Query>d__16")]
public virtual IEnumerable`1<QueryResult> Query(IndexQueryServerSide query, QueryTimingsScope queryTimings, FieldsToFetch fieldsToFetch, Reference`1<long> totalResults, Reference`1<long> skippedResults, Reference`1<long> scannedDocuments, IQueryResultRetriever retriever, DocumentsOperationContext documentsContext, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    [DoesNotReturnAttribute]
private static void ThrowQueryWantToExceedsInt32();
    protected virtual QueryResult CreateQueryResult(Document doc, CreateQueryResultParameters parameters, Boolean& markedAsSkipped, Reference`1<long> skippedResults, Int32& returnedResults);
    private ExplanationResult GetQueryExplanations(ExplanationOptions options, Query luceneQuery, IndexSearcher searcher, ScoreDoc scoreDoc, Document document, Document luceneDocument);
    private Dictionary`2<string, Dictionary`2<string, String[]>> GetHighlighterResults(IndexQueryServerSide query, IndexSearcher searcher, ScoreDoc scoreDoc, Document document, Document luceneDocument, JsonOperationContext context);
    private void SetupHighlighter(IndexQueryServerSide query, Query luceneQuery, JsonOperationContext context);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexReadOperation/<IntersectQuery>d__22")]
public virtual IEnumerable`1<QueryResult> IntersectQuery(IndexQueryServerSide query, FieldsToFetch fieldsToFetch, Reference`1<long> totalResults, Reference`1<long> skippedResults, Reference`1<long> scannedDocuments, IQueryResultRetriever retriever, DocumentsOperationContext documentsContext, Func`2<string, SpatialField> getSpatialField, CancellationToken token);
    private TopDocs ExecuteQuery(Query documentQuery, int start, int pageSize, Sort sort);
    private static bool IsBoostedQuery(Query query);
    private IDisposable GetSort(IndexQueryServerSide query, Index index, Func`2<string, SpatialField> getSpatialField, DocumentsOperationContext documentsContext, Sort& sort);
    public virtual SortedSet`1<string> Terms(string field, string fromValue, long pageSize, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexReadOperation/<MoreLikeThis>d__28")]
public virtual IEnumerable`1<QueryResult> MoreLikeThis(IndexQueryServerSide query, IQueryResultRetriever retriever, DocumentsOperationContext context, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexReadOperation/<IndexEntries>d__29")]
public virtual IEnumerable`1<BlittableJsonReaderObject> IndexEntries(IndexQueryServerSide query, Reference`1<long> totalResults, DocumentsOperationContext documentsContext, Func`2<string, SpatialField> getSpatialField, bool ignoreLimit, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexReadOperation/<DynamicEntriesFields>d__30")]
public virtual IEnumerable`1<string> DynamicEntriesFields(HashSet`1<string> staticFields);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static QueryResult <IntersectQuery>g__CreateQueryResult|22_0(Document d, <>c__DisplayClass22_0& , <>c__DisplayClass22_1& , <>c__DisplayClass22_2& );
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexSearcherHolder : object {
    private Func`2<IState, IndexSearcher> _recreateSearcher;
    private DocumentDatabase _documentDatabase;
    private Logger _logger;
    private ImmutableList`1<IndexSearcherHoldingState> _states;
    public LuceneIndexSearcherHolder(Func`2<IState, IndexSearcher> recreateSearcher, DocumentDatabase documentDatabase);
    public void SetIndexSearcher(Transaction asOfTx);
    public IDisposable GetSearcher(Transaction tx, IState state, IndexSearcher& searcher);
    private IndexSearcherHoldingState GetStateHolder(Transaction tx);
    public void Cleanup(long oldestTx, IndexCleanup mode);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexWriteOperation : IndexWriteOperationBase {
    private Term _documentId;
    private Term _reduceKeyHash;
    private Term _sourceDocumentIdHash;
    protected Byte[] _buffer;
    protected LuceneRavenPerFieldAnalyzerWrapper _analyzer;
    protected LuceneIndexWriter _writer;
    protected Dictionary`2<string, LuceneSuggestionIndexWriter> _suggestionsWriters;
    private bool _hasSuggestions;
    private LuceneDocumentConverterBase _converter;
    private Lock _locker;
    private IDisposable _releaseWriteTransaction;
    private IState _state;
    private LuceneVoronDirectory _directory;
    public LuceneIndexWriteOperation(Index index, LuceneVoronDirectory directory, LuceneDocumentConverterBase converter, Transaction writeTransaction, LuceneIndexPersistence persistence);
    public virtual void Dispose();
    public virtual void Commit(IndexingStatsScope stats);
    public virtual void Optimize(CancellationToken token);
    public virtual void UpdateDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public virtual void IndexDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public virtual long EntriesCount();
    public virtual ValueTuple`2<long, long> GetAllocations();
    public virtual void Delete(LazyStringValue key, IndexingStatsScope stats);
    public virtual void DeleteBySourceDocument(LazyStringValue sourceDocumentId, IndexingStatsScope stats);
    public virtual void DeleteReduceResult(LazyStringValue reduceKeyHash, IndexingStatsScope stats);
    private void EnsureValidStats(IndexingStatsScope stats);
    public sealed virtual Byte[] GetBuffer(int necessarySize);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneIndexWriter : object {
    private Logger _logger;
    private TimeTrackingIndexWriter _indexWriter;
    private LuceneVoronDirectory _directory;
    private Analyzer _analyzer;
    private IndexDeletionPolicy _indexDeletionPolicy;
    private MaxFieldLength _maxFieldLength;
    private IndexReaderWarmer _indexReaderWarmer;
    private Index _index;
    public Analyzer Analyzer { get; }
    public LuceneIndexWriter(LuceneVoronDirectory d, Analyzer a, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl, IndexReaderWarmer indexReaderWarmer, Index index, IState state);
    public Analyzer get_Analyzer();
    public void AddDocument(Document doc, Analyzer a, IState state);
    public void DeleteDocuments(Term term, IState state);
    public int EntriesCount(IState state);
    public void Commit(IState state, IndexingStatsScope commitStats);
    public static void TryThrowingBetterException(SystemException e, LuceneVoronDirectory directory);
    public long RamSizeInBytes();
    public void Optimize(IState state, CancellationToken token);
    public void RecreateIndexWriter(IState state);
    private void CreateIndexWriter(IState state);
    private void DisposeIndexWriter();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneSuggestionIndexReader : SuggestionIndexReaderBase {
    private IndexSearcher _searcher;
    private IDisposable _releaseSearcher;
    private IDisposable _releaseReadTransaction;
    private IState _state;
    private static SuggestWord[] EmptyArray;
    private static string FWord;
    private static float BoostStart;
    private static float BoostEnd;
    private static GramKeys[] GramsTable;
    public LuceneSuggestionIndexReader(Index index, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, Transaction readTransaction);
    private static LuceneSuggestionIndexReader();
    public virtual SuggestionResult Suggestions(IndexQueryServerSide query, SuggestionField field, JsonOperationContext documentsContext, CancellationToken token);
    private SuggestWord[] QueryOverSingleWord(SuggestionField field, string word, SuggestionOptions options);
    private SuggestWord[] QueryOverSingleWord(SuggestionField suggestionField, string word, SuggestionOptions options, TDistance sd);
    private static void Add(BooleanQuery q, string k, string v, float boost);
    private static void Add(BooleanQuery q, string k, string v);
    private static String[] FormGrams(string text, int ng);
    private static int GetMin(int l);
    private SuggestWord[] QueryOverMultipleWords(SuggestionField field, List`1<string> words, SuggestionOptions options);
    internal virtual void AddPopularity(SuggestWord suggestion, SuggestionResult& result);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.LuceneSuggestionIndexWriter : object {
    private static string FWord;
    private Term _fWordTerm;
    private string _field;
    private LuceneVoronDirectory _directory;
    private SnapshotDeletionPolicy _indexDeletionPolicy;
    private MaxFieldLength _maxFieldLength;
    private Index _index;
    private HashSet`1<string> _alreadySeen;
    private IndexWriter _indexWriter;
    private IndexSearcher _indexSearcher;
    private Logger _logger;
    private static GramKeys[] GramsTable;
    public Analyzer Analyzer { get; }
    public LuceneSuggestionIndexWriter(string field, LuceneVoronDirectory directory, SnapshotDeletionPolicy snapshotter, MaxFieldLength maxFieldLength, Index index, IState state);
    private static LuceneSuggestionIndexWriter();
    public Analyzer get_Analyzer();
    private static int GetMin(int l);
    private static void AddGram(string text, Document doc, int ng1, int ng2);
    private static Document CreateDocument(string text, int ng1, int ng2);
    public void AddDocument(Document doc, Analyzer analyzer, IState state);
    public void DeleteDocuments(Term term, IState state);
    public void Commit(IState state);
    public void Optimize(IState state, CancellationToken token);
    public long RamSizeInBytes();
    public long FilesAllocationsInBytes();
    public void ResetAllocations();
    private void RecreateIndexWriter(IState state);
    private void CreateIndexWriter(IState state);
    private void DisposeIndexWriter(bool waitForMerges);
    public sealed virtual void Dispose();
}
internal interface Raven.Server.Documents.Indexes.Persistence.Lucene.Suggestions.IStringDistance {
    public abstract virtual float GetDistance(string s1, string s2);
}
internal class Raven.Server.Documents.Indexes.Persistence.Lucene.Suggestions.JaroWinklerDistance : object {
    [CompilerGeneratedAttribute]
private float <Threshold>k__BackingField;
    public float Threshold { get; public set; }
    private static Int32[] Matches(string s1, string s2);
    public sealed virtual float GetDistance(string s1, string s2);
    [CompilerGeneratedAttribute]
public float get_Threshold();
    [CompilerGeneratedAttribute]
public void set_Threshold(float value);
}
internal class Raven.Server.Documents.Indexes.Persistence.Lucene.Suggestions.LevenshteinDistance : object {
    public sealed virtual float GetDistance(string target, string other);
}
internal class Raven.Server.Documents.Indexes.Persistence.Lucene.Suggestions.NGramDistance : object {
    private int _n;
    public NGramDistance(int size);
    public sealed virtual float GetDistance(string source, string target);
}
internal class Raven.Server.Documents.Indexes.Persistence.Lucene.Suggestions.SuggestWordQueue : PriorityQueue`1<SuggestWord> {
    internal SuggestWordQueue(int size);
    public virtual bool LessThan(SuggestWord a, SuggestWord b);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.TimeTrackingIndexWriter : IndexWriter {
    private TimeTrackingSerialMergeScheduler _mergeScheduler;
    private IndexingStatsScope _commitStats;
    public TimeTrackingIndexWriter(Directory d, Analyzer a, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl, IState state);
    public void InitializeMergeScheduler(TimeTrackingSerialMergeScheduler scheduler, IState state);
    public void SetCommitStats(IndexingStatsScope commitStats);
    protected virtual bool ApplyDeletes(IState state);
}
public class Raven.Server.Documents.Indexes.Persistence.Lucene.TimeTrackingSerialMergeScheduler : MergeScheduler {
    private Index _index;
    private TimeSpan _maxMergeTime;
    private IndexingStatsScope _commitStats;
    public TimeTrackingSerialMergeScheduler(Index index);
    public void SetCommitStats(IndexingStatsScope commitStats);
    public virtual void Merge(IndexWriter writer, IState state);
    protected virtual void Dispose(bool disposing);
}
internal class Raven.Server.Documents.Indexes.Persistence.OutputReduceIndexWriteOperationScope`1 : object {
    private TWriter _writer;
    private OutputReduceToCollectionCommandBatcher _outputReduceToCollectionCommandBatcher;
    private TransactionHolder _txHolder;
    private DocumentDatabase _documentDatabase;
    public bool IsActive;
    public OutputReduceIndexWriteOperationScope`1(MapReduceIndex index, Transaction writeTransaction, JsonOperationContext indexContext, TWriter writer);
    public void Commit(IndexingStatsScope stats);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Persistence.OutputReduceIndexWriteOperationScope`1/<CommitOutputReduceToCollection>d__7")]
private Task CommitOutputReduceToCollection();
    public void IndexDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public void Delete(LazyStringValue key, IndexingStatsScope stats);
    public void DeleteReduceResult(LazyStringValue reduceKeyHash, IndexingStatsScope stats);
    public void UpdateDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public void Dispose();
}
public class Raven.Server.Documents.Indexes.Persistence.QueryFilter : AbstractQueryFilter {
    private Reference`1<long> _skippedResults;
    private Reference`1<long> _scannedDocuments;
    private IQueryResultRetriever _retriever;
    private DocumentsOperationContext _documentsContext;
    protected Nullable`1<long> ScannedDocuments { get; }
    public QueryFilter(Index index, IndexQueryServerSide query, DocumentsOperationContext documentsContext, Reference`1<long> skippedResults, Reference`1<long> scannedDocuments, IQueryResultRetriever retriever, QueryTimingsScope queryTimings);
    protected virtual Nullable`1<long> get_ScannedDocuments();
    public FilterResult Apply(RetrieverInput& input, string key);
    protected virtual ScriptRunnerResult GetScriptRunnerResult(object translatedDoc);
    protected virtual void IncrementSkippedResults();
    protected virtual void IncrementScannedDocuments();
}
public abstract class Raven.Server.Documents.Indexes.Persistence.SuggestionIndexReaderBase : IndexOperationBase {
    protected SuggestionIndexReaderBase(Index index, Logger logger);
    public abstract virtual SuggestionResult Suggestions(IndexQueryServerSide query, SuggestionField field, JsonOperationContext documentsContext, CancellationToken token);
}
internal class Raven.Server.Documents.Indexes.Persistence.SuggestWord : object {
    public float Score;
    public int Freq;
    public string Term;
    public int CompareTo(SuggestWord a);
    public sealed virtual int CompareTo(object obj);
}
public class Raven.Server.Documents.Indexes.QueryOperationContext : object {
    private DocumentDatabase _database;
    public DocumentsOperationContext Documents;
    public ClusterOperationContext Server;
    private IDisposable _releaseDocuments;
    private IDisposable _releaseServer;
    private QueryOperationContext(DocumentDatabase database, DocumentsOperationContext documentsContext, bool releaseDocumentsContext, bool needsServerContext);
    private QueryOperationContext(DocumentDatabase database, bool needsServerContext);
    internal void WithIndex(Index index);
    internal void WithQuery(QueryMetadata metadata);
    public IDisposable OpenReadTransaction();
    public void CloseTransaction();
    public bool AreTransactionsOpened();
    public void SetLongLivedTransactions(bool value);
    [ConditionalAttribute("DEBUG")]
public void AssertOpenedTransactions();
    public sealed virtual void Dispose();
    public static QueryOperationContext Allocate(DocumentDatabase database, bool needsServerContext);
    public static QueryOperationContext Allocate(DocumentDatabase database, Index index);
    public static QueryOperationContext ShortTermSingleUse(DocumentDatabase database);
    [DoesNotReturnAttribute]
private static void ThrowTransactionsNotInTheSameStateException(bool opened, bool serverOpened);
}
public class Raven.Server.Documents.Indexes.QueryResultsIterationState : PulsedEnumerationState`1<QueryResult> {
    public QueryResultsIterationState(DocumentsOperationContext context, Size pulseLimit);
    public virtual void OnMoveNext(QueryResult current);
}
public class Raven.Server.Documents.Indexes.Sharding.Persistence.Corax.ShardedCoraxIndexReadOperation : CoraxIndexReadOperation {
    public ShardedCoraxIndexReadOperation(Index index, Logger logger, Transaction readTransaction, QueryBuilderFactories queryBuilderFactories, IndexFieldsMapping fieldsMapping, IndexQueryServerSide query);
    protected virtual QueryResult CreateQueryResult(IdentityTracker`1& tracker, Document document, IndexQueryServerSide query, DocumentsOperationContext documentsContext, EntryTermsReader& entryReader, FieldsToFetch highlightingFields, OrderMetadata[] orderByFields, THighlighting& highlightings, Reference`1<long> skippedResults, THasProjection& hasProjections, Boolean& markedAsSkipped);
    private ShardedQueryResultDocument AddOrderByFields(Document queryResult, IndexQueryServerSide query, EntryTermsReader& reader, OrderMetadata[] orderByFields);
    private static bool IsSameOrderType(MatchCompareFieldType coraxOrderField, OrderByFieldType queryOrderField);
    internal virtual void AssertCanOrderByScoreAutomaticallyWhenBoostingIsInvolved();
}
public class Raven.Server.Documents.Indexes.Sharding.Persistence.Lucene.ShardedLuceneIndexReadOperation : LuceneIndexReadOperation {
    public ShardedLuceneIndexReadOperation(Index index, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, QueryBuilderFactories queryBuilderFactories, Transaction readTransaction, IndexQueryServerSide query);
    protected virtual QueryResult CreateQueryResult(Document doc, CreateQueryResultParameters parameters, Boolean& markedAsSkipped, Reference`1<long> skippedResults, Int32& returnedResults);
    private ShardedQueryResultDocument AddOrderByFields(Document queryResult, IndexQueryServerSide query, int doc);
    internal virtual void AssertCanOrderByScoreAutomaticallyWhenBoostingIsInvolved();
}
public class Raven.Server.Documents.Indexes.Sharding.Persistence.Lucene.ShardedLuceneSuggestionIndexReader : LuceneSuggestionIndexReader {
    public ShardedLuceneSuggestionIndexReader(Index index, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, Transaction readTransaction);
    internal virtual void AddPopularity(SuggestWord suggestion, SuggestionResult& result);
}
public class Raven.Server.Documents.Indexes.Sharding.Persistence.ShardedIndexReadOperationFactory : object {
    public sealed virtual LuceneIndexReadOperation CreateLuceneIndexReadOperation(Index index, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, QueryBuilderFactories queryBuilderFactories, Transaction readTransaction, IndexQueryServerSide query);
    public sealed virtual CoraxIndexReadOperation CreateCoraxIndexReadOperation(Index index, Logger logger, Transaction readTransaction, QueryBuilderFactories queryBuilderFactories, IndexFieldsMapping fieldsMapping, IndexQueryServerSide query);
    public sealed virtual LuceneSuggestionIndexReader CreateLuceneSuggestionIndexReader(Index index, LuceneVoronDirectory directory, LuceneIndexSearcherHolder searcherHolder, Transaction readTransaction);
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedDatabaseIndexCreateController : DatabaseIndexCreateController {
    private ShardedDocumentDatabase _database;
    public ShardedDatabaseIndexCreateController(ShardedDocumentDatabase database);
    protected virtual string GetDatabaseName();
    protected virtual void ValidateAutoIndex(IndexDefinitionBaseServerSide definition);
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedDatabaseIndexDeleteController : DatabaseIndexDeleteController {
    private ShardedDocumentDatabase _database;
    public ShardedDatabaseIndexDeleteController(ShardedDocumentDatabase database);
    protected virtual string GetDatabaseName();
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedDatabaseIndexLockModeController : DatabaseIndexLockModeController {
    private ShardedDocumentDatabase _database;
    public ShardedDatabaseIndexLockModeController(ShardedDocumentDatabase database);
    protected virtual string GetDatabaseName();
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedDatabaseIndexPriorityController : DatabaseIndexPriorityController {
    private ShardedDocumentDatabase _database;
    public ShardedDatabaseIndexPriorityController(ShardedDocumentDatabase database);
    protected virtual string GetDatabaseName();
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedDatabaseIndexStateController : DatabaseIndexStateController {
    private ShardedDocumentDatabase _database;
    public ShardedDatabaseIndexStateController(ShardedDocumentDatabase database);
    protected virtual string GetDatabaseName();
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedIndexCreateController : AbstractIndexCreateController {
    private ShardedDatabaseContext _context;
    public ShardedIndexCreateController(ShardedDatabaseContext context, ServerStore serverStore);
    protected virtual string GetDatabaseName();
    protected virtual SystemTime GetDatabaseTime();
    public virtual RavenConfiguration GetDatabaseConfiguration();
    protected virtual IndexInformationHolder GetIndex(string name);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Sharding.ShardedIndexCreateController/<GetIndexNames>d__6")]
protected virtual IEnumerable`1<string> GetIndexNames();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Sharding.ShardedIndexCreateController/<GetCollectionCountAsync>d__7")]
protected virtual ValueTask`1<long> GetCollectionCountAsync(string collection);
    protected virtual IEnumerable`1<IndexInformationHolder> GetIndexes();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Sharding.ShardedIndexCreateController/<WaitForIndexNotificationAsync>d__9")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Sharding.ShardedIndexCreateController/<ValidateStaticIndexAsync>d__10")]
protected virtual ValueTask ValidateStaticIndexAsync(IndexDefinition definition);
    protected virtual void ValidateAutoIndex(IndexDefinitionBaseServerSide definition);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0(IndexDefinition definition);
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedIndexDeleteController : AbstractIndexDeleteController {
    private ShardedDatabaseContext _context;
    public ShardedIndexDeleteController(ShardedDatabaseContext context, ServerStore serverStore);
    protected virtual string GetDatabaseName();
    protected virtual IndexDefinitionBaseServerSide GetIndexDefinition(string name);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Sharding.ShardedIndexDeleteController/<CreateIndexAsync>d__4")]
protected virtual ValueTask CreateIndexAsync(IndexDefinition definition, string raftRequestId);
    protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedIndexHasChangedController : AbstractIndexHasChangedController {
    private ShardedDatabaseContext _context;
    public ShardedIndexHasChangedController(ShardedDatabaseContext context);
    protected virtual IndexInformationHolder GetIndex(string name);
    protected virtual RavenConfiguration GetDatabaseConfiguration();
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedIndexLockModeController : AbstractIndexLockModeController {
    private ShardedDatabaseContext _context;
    public ShardedIndexLockModeController(ShardedDatabaseContext context, ServerStore serverStore);
    protected virtual string GetDatabaseName();
    protected virtual void ValidateIndex(string name, IndexLockMode mode);
    protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedIndexPriorityController : AbstractIndexPriorityController {
    private ShardedDatabaseContext _context;
    public ShardedIndexPriorityController(ShardedDatabaseContext context, ServerStore serverStore);
    protected virtual string GetDatabaseName();
    protected virtual void ValidateIndex(string name, IndexPriority priority);
    protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedIndexStateController : AbstractIndexStateController {
    private ShardedDatabaseContext _context;
    public ShardedIndexStateController(ShardedDatabaseContext context, ServerStore serverStore);
    protected virtual string GetDatabaseName();
    protected virtual void ValidateIndex(string name, IndexState state);
    protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
public class Raven.Server.Documents.Indexes.Sharding.ShardedIndexStore : IndexStore {
    public ShardedIndexStore(ShardedDocumentDatabase database, ServerStore serverStore);
}
public class Raven.Server.Documents.Indexes.SimpleField : CompiledIndexField {
    public SimpleField(string name);
    public virtual void WriteTo(StringBuilder sb);
    public virtual object GetValue(object value, object blittableValue);
}
public class Raven.Server.Documents.Indexes.Sorting.FaultySorterFactory : SorterFactory {
    private string _name;
    private Exception _e;
    public FaultySorterFactory(string name, Exception e);
    public virtual FieldComparator CreateInstance(string fieldName, int numHits, int sortPos, bool reversed, List`1<string> diagnostics);
}
public class Raven.Server.Documents.Indexes.Sorting.SorterCompilationCache : AbstractCompilationCache`1<SorterFactory> {
    public static SorterCompilationCache Instance;
    private static SorterCompilationCache();
    protected virtual bool DatabaseRecordContainsItem(RawDatabaseRecord databaseRecord, string name);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Sorting.SorterCompilationCache/<GetItemsFromDatabaseRecord>d__3")]
protected virtual IEnumerable`1<ValueTuple`2<string, string>> GetItemsFromDatabaseRecord(RawDatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Sorting.SorterCompilationCache/<GetItemsFromCluster>d__4")]
protected virtual IEnumerable`1<ValueTuple`2<string, string>> GetItemsFromCluster(ServerStore serverStore, TransactionOperationContext context);
    protected virtual SorterFactory CompileItem(string name, string code);
}
public static class Raven.Server.Documents.Indexes.Sorting.SorterCompiler : object {
    public static SorterFactory Compile(string name, string sorterCode);
    private static string GetCSharpSafeName(string name);
}
public class Raven.Server.Documents.Indexes.Sorting.SorterFactory : object {
    public Type Type;
    public SorterFactory(Type sorterType);
    public virtual FieldComparator CreateInstance(string fieldName, int numHits, int sortPos, bool reversed, List`1<string> diagnostics);
}
public class Raven.Server.Documents.Indexes.Spatial.Circle : SpatialShapeBase {
    public Coordinates Center;
    public double Radius;
    public SpatialUnits Units;
    public Circle(ICircle circle, SpatialUnits units, SpatialOptions options);
}
public class Raven.Server.Documents.Indexes.Spatial.Coordinates : object {
    public double Latitude;
    public double Longitude;
    public Coordinates(IPoint point);
    public Coordinates(double latitude, double longitude);
}
public class Raven.Server.Documents.Indexes.Spatial.Polygon : SpatialShapeBase {
    public List`1<Coordinates> Vertices;
    public Polygon(IRectangle rectangle);
    public Polygon(Polygon polygon);
}
public class Raven.Server.Documents.Indexes.Spatial.SpatialProperty : object {
    public string LatitudeProperty;
    public string LongitudeProperty;
    public SpatialProperty(string latitudePropertyPath, string longitudePropertyPath);
}
public abstract class Raven.Server.Documents.Indexes.Spatial.SpatialShapeBase : object {
    public SpatialShapeType Type;
    protected SpatialShapeBase(SpatialShapeType type);
}
public enum Raven.Server.Documents.Indexes.Spatial.SpatialShapeType : Enum {
    public int value__;
    public static SpatialShapeType Polygon;
    public static SpatialShapeType Circle;
}
public abstract class Raven.Server.Documents.Indexes.Static.AbstractCountersAndTimeSeriesJavaScriptIndex : AbstractJavaScriptIndex {
    private static string NameProperty;
    protected AbstractCountersAndTimeSeriesJavaScriptIndex(IndexDefinition definition, RavenConfiguration configuration, string mapPrefix, string allItems, long indexVersion);
    private static string GetMapCode(string allItems);
    private static void ModifyMappingFunctions(List`1<string> mappingFunctions, string mapPrefix);
    protected virtual void OnInitializeEngine(Engine engine);
    protected virtual void ProcessMaps(ObjectInstance definitions, JintPreventResolvingTasksReferenceResolver resolver, List`1<string> mapList, List`1<MapMetadata> mapReferencedCollections, Dictionary`2& collectionFunctions);
}
public abstract class Raven.Server.Documents.Indexes.Static.AbstractDynamicObject : DynamicObject {
    public abstract virtual bool Set(object item);
    public abstract virtual object GetId();
    protected abstract virtual bool TryGetByName(string name, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
}
public abstract class Raven.Server.Documents.Indexes.Static.AbstractJavaScriptIndex : AbstractStaticIndexBase {
    protected static string GlobalDefinitions;
    protected static string CollectionProperty;
    protected static string MethodProperty;
    protected static string MoreArgsProperty;
    protected static string MapsProperty;
    private static string ReduceProperty;
    private static string AggregateByProperty;
    private static string KeyProperty;
    private static ParserOptions DefaultParserOptions;
    private static string Code;
    protected IndexDefinition Definition;
    internal Engine _engine;
    protected JavaScriptUtils _javaScriptUtils;
    [CompilerGeneratedAttribute]
private JavaScriptReduceOperation <ReduceOperation>k__BackingField;
    public JavaScriptReduceOperation ReduceOperation { get; private set; }
    protected AbstractJavaScriptIndex(IndexDefinition definition, RavenConfiguration configuration, Action`1<List`1<string>> modifyMappingFunctions, string mapCode, long indexVersion);
    private static AbstractJavaScriptIndex();
    private List`1<string> GetMappingFunctions(Action`1<List`1<string>> modifyMappingFunctions);
    internal static AbstractJavaScriptIndex Create(IndexDefinition definition, RavenConfiguration configuration, long indexVersion);
    private void ProcessFields(IndexDefinition definition, Dictionary`2<string, Dictionary`2<string, List`1<JavaScriptMapOperation>>> collectionFunctions);
    private void ProcessReduce(IndexDefinition definition, ObjectInstance definitions, JintPreventResolvingTasksReferenceResolver resolver, long indexVersion);
    protected abstract virtual void ProcessMaps(ObjectInstance definitions, JintPreventResolvingTasksReferenceResolver resolver, List`1<string> mapList, List`1<MapMetadata> mapReferencedCollections, Dictionary`2& collectionFunctions);
    private ObjectInstance GetDefinitions();
    private MapMetadata ExecuteCodeAndCollectReferencedCollections(string code, string additionalSources);
    protected abstract virtual void OnInitializeEngine(Engine engine);
    private List`1<MapMetadata> InitializeEngine(IndexDefinition definition, List`1<string> maps, string mapCode);
    [DoesNotReturnAttribute]
protected void ThrowIndexCreationException(string message);
    private JsValue Recurse(JsValue self, JsValue[] args);
    private JsValue TryConvertToNumber(JsValue self, JsValue[] args);
    private JsValue LoadDocument(JsValue self, JsValue[] args);
    private JsValue LoadCompareExchangeValue(JsValue self, JsValue[] args);
    [CompilerGeneratedAttribute]
public JavaScriptReduceOperation get_ReduceOperation();
    [CompilerGeneratedAttribute]
private void set_ReduceOperation(JavaScriptReduceOperation value);
    public void SetBufferPoolForTestingPurposes(UnmanagedBuffersPoolWithLowMemoryHandling bufferPool);
    public void SetAllocatorForTestingPurposes(ByteStringContext byteStringContext);
    [CompilerGeneratedAttribute]
private JsValue <LoadCompareExchangeValue>g__ConvertToJsValue|23_0(object value);
    [CompilerGeneratedAttribute]
internal static void <LoadCompareExchangeValue>g__ThrowInvalidType|23_1(JsValue value, Types expectedType);
}
public abstract class Raven.Server.Documents.Indexes.Static.AbstractStaticIndexBase : object {
    protected Dictionary`2<string, CollectionName> _collectionsCache;
    public Dictionary`2<string, Dictionary`2<string, List`1<IndexingFunc>>> Maps;
    public Dictionary`2<string, HashSet`1<CollectionName>> ReferencedCollections;
    public HashSet`1<string> CollectionsWithCompareExchangeReferences;
    protected static Logger Log;
    [CompilerGeneratedAttribute]
private int <StackSizeInSelectClause>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDynamicFields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasBoostedFields>k__BackingField;
    public string Source;
    public IndexingFunc Reduce;
    public String[] OutputFields;
    public CompiledIndexField[] GroupByFields;
    private List`1<string> _groupByFieldNames;
    public int StackSizeInSelectClause { get; public set; }
    public bool HasDynamicFields { get; public set; }
    public bool HasBoostedFields { get; public set; }
    public List`1<string> GroupByFieldNames { get; }
    private static AbstractStaticIndexBase();
    [CompilerGeneratedAttribute]
public int get_StackSizeInSelectClause();
    [CompilerGeneratedAttribute]
public void set_StackSizeInSelectClause(int value);
    [CompilerGeneratedAttribute]
public bool get_HasDynamicFields();
    [CompilerGeneratedAttribute]
public void set_HasDynamicFields(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasBoostedFields();
    [CompilerGeneratedAttribute]
public void set_HasBoostedFields(bool value);
    public List`1<string> get_GroupByFieldNames();
    public void AddCompareExchangeReferenceToCollection(string collection);
    public void AddReferencedCollection(string collection, string referencedCollection);
    protected void AddMapInternal(string collection, string subCollecction, IndexingFunc map);
    internal void CheckDepthOfStackInOutputMap(IndexDefinition indexMetadata, DocumentDatabase documentDatabase);
    protected object TryConvert(object value);
    public object LoadDocument(object keyOrEnumerable, string collectionName);
    public object LoadDocument(object keyOrEnumerable, string collectionName);
    public object LoadCompareExchangeValue(object keyOrEnumerable);
    public object LoadCompareExchangeValue(object keyOrEnumerable);
    public IEnumerable`1<object> Recurse(object item, Func`2<object, object> func);
    protected IEnumerable`1<object> CreateField(string name, object value, CreateFieldOptions options);
    protected IEnumerable`1<CoraxDynamicItem> CoraxCreateField(CurrentIndexingScope scope, string name, object value, CreateFieldOptions options);
    private IEnumerable`1<AbstractField> LuceneCreateField(CurrentIndexingScope scope, string name, object value, CreateFieldOptions options);
    protected IEnumerable`1<object> CreateField(string name, object value, bool stored, Nullable`1<bool> analyzed);
    public object AsDateOnly(object field);
    public object AsTimeOnly(object field);
    public IEnumerable`1<object> CreateSpatialField(string name, object lat, object lng);
    public IEnumerable`1<object> CreateSpatialField(string name, Nullable`1<double> lat, Nullable`1<double> lng);
    public IEnumerable`1<object> CreateSpatialField(string name, object shapeWkt);
    internal static IEnumerable`1<object> CreateSpatialField(SpatialField spatialField, object lat, object lng);
    internal static IEnumerable`1<object> CreateSpatialField(SpatialField spatialField, Nullable`1<double> lat, Nullable`1<double> lng);
    internal static IEnumerable`1<object> CreateSpatialField(SpatialField spatialField, object shapeWkt);
    internal static SpatialField GetOrCreateSpatialField(string name);
    private static Nullable`1<double> ConvertToDouble(object value);
    [CompilerGeneratedAttribute]
internal static Nullable`1<double> <TryConvert>g__TryConvertToDouble|28_0(object v);
    [CompilerGeneratedAttribute]
internal static Nullable`1<long> <TryConvert>g__TryConvertToLong|28_1(object v);
}
public class Raven.Server.Documents.Indexes.Static.Counters.CounterEntryObjectInstance : ObjectInstance {
    private DynamicCounterEntry _entry;
    private Dictionary`2<string, PropertyDescriptor> _properties;
    public CounterEntryObjectInstance(Engine engine, DynamicCounterEntry entry);
    public virtual bool Delete(JsValue property);
    public virtual PropertyDescriptor GetOwnProperty(JsValue property);
    private PropertyDescriptor GetPropertyValue(string property);
    public virtual bool Set(JsValue property, JsValue value, JsValue receiver);
    public virtual IEnumerable`1<KeyValuePair`2<JsValue, PropertyDescriptor>> GetOwnProperties();
    public virtual List`1<JsValue> GetOwnPropertyKeys(Types types);
}
public class Raven.Server.Documents.Indexes.Static.Counters.CounterItemFilterBehavior : object {
    private static int MaxCapacity;
    private HashSet`1<string> _seenIds;
    private static CounterItemFilterBehavior();
    public sealed virtual bool ShouldFilter(IndexItem item);
}
public class Raven.Server.Documents.Indexes.Static.Counters.CountersJavaScriptIndex : AbstractCountersAndTimeSeriesJavaScriptIndex {
    private static string MapPrefix;
    public CountersJavaScriptIndex(IndexDefinition definition, RavenConfiguration configuration, long indexVersion);
}
public class Raven.Server.Documents.Indexes.Static.Counters.DynamicCounterEntry : AbstractDynamicObject {
    internal CounterGroupItemMetadata _counterItemMetadata;
    internal long _value;
    [DynamicAttribute]
public object DocumentId { get; }
    public LazyStringValue Name { get; }
    [DynamicAttribute]
public object Value { get; }
    public virtual object GetId();
    public virtual bool Set(object item);
    public object get_DocumentId();
    public LazyStringValue get_Name();
    public object get_Value();
    protected virtual bool TryGetByName(string name, Object& result);
}
public class Raven.Server.Documents.Indexes.Static.Counters.MapCountersIndex : MapIndexBase`2<MapIndexDefinition, IndexField> {
    private HashSet`1<string> _referencedCollections;
    internal AbstractStaticIndexBase _compiled;
    private Nullable`1<bool> _isSideBySide;
    private HandleCountersReferences _handleReferences;
    private HandleCompareExchangeCountersReferences _handleCompareExchangeReferences;
    public bool HasBoostedFields { get; }
    public bool IsMultiMap { get; }
    private MapCountersIndex(MapIndexDefinition definition, AbstractStaticIndexBase compiled);
    public virtual bool get_HasBoostedFields();
    public virtual bool get_IsMultiMap();
    public virtual IQueryResultRetriever GetQueryResultRetriever(IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsOperationContext documentsContext, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
    protected virtual void SubscribeToChanges(DocumentDatabase documentDatabase);
    protected virtual void UnsubscribeFromChanges(DocumentDatabase documentDatabase);
    protected virtual void HandleDocumentChange(DocumentChange change);
    protected virtual IIndexingWork[] CreateIndexWorkExecutors();
    public virtual InMemoryReferencesInfo GetInMemoryReferencesState(string collection, bool isCompareExchange);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    protected virtual IndexItem GetItemByEtag(QueryOperationContext queryContext, long etag);
    protected virtual bool ShouldReplace();
    public virtual void ResetIsSideBySideAfterReplacement();
    internal virtual bool IsStale(QueryOperationContext queryContext, TransactionOperationContext indexContext, Nullable`1<long> cutoff, Nullable`1<long> referenceCutoff, Nullable`1<long> compareExchangeReferenceCutoff, List`1<string> stalenessReasons);
    public virtual Dictionary`2<string, HashSet`1<CollectionName>> GetReferencedCollections();
    public virtual bool WorksOnAnyCollection(HashSet`1<string> collections);
    protected virtual long CalculateIndexEtag(QueryOperationContext queryContext, TransactionOperationContext indexContext, QueryMetadata query, bool isStale);
    protected virtual IndexingState GetIndexingStateInternal(QueryOperationContext queryContext, TransactionOperationContext indexContext);
    public virtual long GetLastItemEtagInCollection(QueryOperationContext queryContext, string collection);
    public virtual ValueTuple`2<ICollection`1<string>, ICollection`1<string>> GetEntriesFields();
    public virtual IIndexedItemEnumerator GetMapEnumerator(IEnumerable`1<IndexItem> items, string collection, TransactionOperationContext indexContext, IndexingStatsScope stats, IndexType type);
    public static Index CreateNew(IndexDefinition definition, DocumentDatabase documentDatabase, SingleIndexConfiguration forcedConfiguration);
    public static Index Open(StorageEnvironment environment, DocumentDatabase documentDatabase);
    private static MapCountersIndex CreateIndexInstance(IndexDefinition definition, RavenConfiguration configuration, long indexVersion);
    public static void Update(Index index, IndexDefinition definition, DocumentDatabase documentDatabase);
    private void HandleCounterChange(CounterChange change);
    internal virtual void UpdateProgressStats(QueryOperationContext queryContext, CollectionStats progressStats, string collectionName, Stopwatch overallDuration);
    public virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType tombstoneType);
}
public class Raven.Server.Documents.Indexes.Static.Counters.MapReduceCountersIndex : MapReduceIndex {
    private HashSet`1<string> _referencedCollections;
    internal AbstractStaticIndexBase _compiled;
    public MapReduceCountersIndex(MapReduceIndexDefinition definition, AbstractStaticIndexBase compiled);
    protected virtual IIndexingWork[] CreateIndexWorkExecutors();
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual IIndexedItemEnumerator GetMapEnumerator(IEnumerable`1<IndexItem> items, string collection, TransactionOperationContext indexContext, IndexingStatsScope stats, IndexType type);
    public virtual int HandleMap(IndexItem indexItem, IEnumerable mapResults, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual long GetLastItemEtagInCollection(QueryOperationContext queryContext, string collection);
    protected virtual IndexItem GetItemByEtag(QueryOperationContext queryContext, long etag);
    protected virtual void SubscribeToChanges(DocumentDatabase documentDatabase);
    protected virtual void UnsubscribeFromChanges(DocumentDatabase documentDatabase);
    protected virtual void HandleDocumentChange(DocumentChange change);
    private void HandleCounterChange(CounterChange change);
    internal virtual void UpdateProgressStats(QueryOperationContext queryContext, CollectionStats progressStats, string collectionName, Stopwatch overallDuration);
    public virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType tombstoneType);
}
public class Raven.Server.Documents.Indexes.Static.CurrentIndexingScope : object {
    private IndexingStatsScope _stats;
    private IndexingStatsScope _loadDocumentStats;
    private IndexingStatsScope _loadAttachmentStats;
    private IndexingStatsScope _loadCompareExchangeValueStats;
    private JavaScriptUtils _javaScriptUtils;
    private DocumentsStorage _documentsStorage;
    public QueryOperationContext QueryContext;
    public UnmanagedBuffersPoolWithLowMemoryHandling UnmanagedBuffersPool;
    public Dictionary`2<string, IndexField> DynamicFields;
    private Func`2<string, SpatialField> _getSpatialField;
    public Dictionary`2<string, Dictionary`2<Slice, HashSet`1<Slice>>> ReferencesByCollection;
    public Dictionary`2<string, Dictionary`2<Slice, HashSet`1<Slice>>> ReferencesByCollectionForCompareExchange;
    public MismatchedReferencesWarningHandler MismatchedReferencesWarningHandler;
    [ThreadStaticAttribute]
public static CurrentIndexingScope Current;
    [CompilerGeneratedAttribute]
private Action OnNewDynamicField;
    private int _createdFieldsCount;
    public Index Index;
    public AbstractDynamicObject Source;
    public string SourceCollection;
    public TransactionOperationContext IndexContext;
    public IndexDefinitionBaseServerSide IndexDefinition;
    public LuceneDocumentConverter CreateFieldConverter;
    private MetadataFieldCache _metadataFields;
    public int CreatedFieldsCount { get; }
    public bool SupportsDynamicFieldsCreation { get; }
    public bool SupportsSpatialFieldsCreation { get; }
    public MetadataFieldCache MetadataFields { get; }
    private static CurrentIndexingScope();
    public CurrentIndexingScope(Index index, DocumentsStorage documentsStorage, QueryOperationContext queryContext, IndexDefinitionBaseServerSide indexDefinition, TransactionOperationContext indexContext, Func`2<string, SpatialField> getSpatialField, UnmanagedBuffersPoolWithLowMemoryHandling _unmanagedBuffersPool);
    [CompilerGeneratedAttribute]
public void add_OnNewDynamicField(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnNewDynamicField(Action value);
    public void IncrementDynamicFields();
    public int get_CreatedFieldsCount();
    public virtual bool get_SupportsDynamicFieldsCreation();
    public virtual bool get_SupportsSpatialFieldsCreation();
    public void SetSourceCollection(string collection, IndexingStatsScope stats);
    public List`1<DynamicAttachment> LoadAttachments(string documentId, IEnumerable`1<string> attachmentNames);
    public MetadataFieldCache get_MetadataFields();
    public object LoadAttachments(DynamicBlittableJson document);
    public object LoadAttachment(string documentId, string attachmentName);
    public object LoadAttachment(DynamicBlittableJson document, string attachmentName);
    public object LoadDocument(LazyStringValue keyLazy, string keyString, string collectionName);
    public object LoadCompareExchangeValue(LazyStringValue keyLazy, string keyString);
    private LazyStringValue GetSourceId(AbstractDynamicObject source);
    private bool TryGetKeySlice(LazyStringValue keyLazy, string keyString, Slice& keySlice);
    private bool TryGetCompareExchangeKeySlice(LazyStringValue keyLazy, string keyString, Slice& keySlice);
    public SpatialField GetOrCreateSpatialField(string name);
    public void RegisterJavaScriptUtils(JavaScriptUtils javaScriptUtils);
    public sealed virtual void Dispose();
    private HashSet`1<Slice> GetReferencesForItem(Slice key);
    private HashSet`1<Slice> GetCompareExchangeReferencesForItem(Slice key);
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Documents.Indexes.Static.DynamicArray : DynamicObject {
    private IEnumerable`1<object> _inner;
    [DynamicAttribute]
public object Item { get; }
    public DynamicArray(IEnumerable inner);
    public DynamicArray(IEnumerable`1<object> inner);
    public object Get(Int32[] indexes);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public object get_Item(int i);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int Count();
    public int Count(Func`2<object, bool> predicate);
    public object Any();
    public object Any(Func`2<object, bool> predicate);
    public object All(Func`2<object, bool> predicate);
    public int FindIndex(Predicate`1<object> match);
    public int FindIndex(int startIndex, Predicate`1<object> match);
    public int FindIndex(int startIndex, int count, Predicate`1<object> match);
    public int FindLastIndex(Predicate`1<object> match);
    public int FindLastIndex(int startIndex, Predicate`1<object> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<object> match);
    public object First();
    public object First(Func`2<object, bool> predicate);
    public object FirstOrDefault();
    public object FirstOrDefault(Func`2<object, bool> predicate);
    public object Single();
    public object Single(Func`2<object, bool> predicate);
    public object SingleOrDefault();
    public object SingleOrDefault(Func`2<object, bool> predicate);
    public bool Contains(object item);
    public int Sum(Func`2<object, int> selector);
    public Nullable`1<int> Sum(Func`2<object, Nullable`1<int>> selector);
    public long Sum(Func`2<object, long> selector);
    public Nullable`1<long> Sum(Func`2<object, Nullable`1<long>> selector);
    public float Sum(Func`2<object, float> selector);
    public Nullable`1<float> Sum(Func`2<object, Nullable`1<float>> selector);
    public double Sum(Func`2<object, double> selector);
    public Nullable`1<double> Sum(Func`2<object, Nullable`1<double>> selector);
    public decimal Sum(Func`2<object, decimal> selector);
    public Nullable`1<decimal> Sum(Func`2<object, Nullable`1<decimal>> selector);
    public object Min();
    public object Min(Func`2<object, TResult> selector);
    public object Max();
    public object Max(Func`2<object, TResult> selector);
    public double Average(Func`2<object, int> selector);
    public Nullable`1<double> Average(Func`2<object, Nullable`1<int>> selector);
    public double Average(Func`2<object, long> selector);
    public Nullable`1<double> Average(Func`2<object, Nullable`1<long>> selector);
    public float Average(Func`2<object, float> selector);
    public Nullable`1<float> Average(Func`2<object, Nullable`1<float>> selector);
    public double Average(Func`2<object, double> selector);
    public Nullable`1<double> Average(Func`2<object, Nullable`1<double>> selector);
    public decimal Average(Func`2<object, decimal> selector);
    public Nullable`1<decimal> Average(Func`2<object, Nullable`1<decimal>> selector);
    public IEnumerable`1<object> OrderBy(Func`2<object, object> comparable);
    public IEnumerable`1<object> OrderBy(Func`2<IGrouping`2<object, object>, object> comparable);
    public IEnumerable`1<object> OrderByDescending(Func`2<object, object> comparable);
    public IEnumerable`1<object> OrderByDescending(Func`2<IGrouping`2<object, object>, object> comparable);
    private IOrderedEnumerable`1<object> CreateOrderedEnumerable(Func`2<object, TKey> keySelector, IComparer`1<TKey> comparer, bool descending, int depth);
    public sealed virtual IOrderedEnumerable`1<object> CreateOrderedEnumerable(Func`2<object, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
    public IEnumerable`1<object> ThenBy(Func`2<object, object> comparable);
    public IEnumerable`1<object> ThenBy(Func`2<object, object> comparable, IComparer`1<object> comparer);
    public IEnumerable`1<object> ThenByDescending(Func`2<object, object> keySelector);
    public IEnumerable`1<object> ThenByDescending(Func`2<object, object> keySelector, IComparer`1<object> comparer);
    public object GroupBy(Func`2<object, object> keySelector);
    public object GroupBy(Func`2<object, object> keySelector, Func`2<object, object> selector);
    public object Last();
    public object LastOrDefault();
    public object Last(Func`2<object, bool> predicate);
    public object LastOrDefault(Func`2<object, bool> predicate);
    public object IndexOf(object item);
    public object IndexOf(object item, int index);
    public object IndexOf(object item, int index, int count);
    private static object IndexOfInternal(object item, List`1<object> items, int index, int count);
    public object LastIndexOf(object item);
    public object LastIndexOf(object item, int index);
    public object LastIndexOf(object item, int index, int count);
    private static object LastIndexOfInternal(object item, List`1<object> items, int index, int count);
    private static object InternalConvert(object item);
    public IEnumerable`1<object> Take(int count);
    public IEnumerable`1<object> Skip(int count);
    public IEnumerable`1<object> Select(Func`2<object, object> func);
    public IEnumerable`1<object> Select(Func`2<IGrouping`2<object, object>, object> func);
    public IEnumerable`1<object> Select(Func`3<object, int, object> func);
    public IEnumerable`1<object> SelectMany(Func`2<object, IEnumerable`1<object>> func);
    public IEnumerable`1<object> SelectMany(Func`2<object, IEnumerable`1<object>> func, Func`3<object, object, object> selector);
    public IEnumerable`1<object> SelectMany(Func`3<object, int, IEnumerable`1<object>> func);
    public IEnumerable`1<object> Where(Func`2<object, bool> func);
    public IEnumerable`1<object> Where(Func`3<object, int, bool> func);
    public IEnumerable`1<object> Distinct();
    public object DefaultIfEmpty(object defaultValue);
    public IEnumerable`1<object> Except(IEnumerable`1<object> except);
    public IEnumerable`1<object> Reverse();
    public bool SequenceEqual(IEnumerable`1<object> second);
    public IEnumerable`1<object> AsEnumerable();
    public Object[] ToArray();
    public List`1<object> ToList();
    public IDictionary`2<object, object> ToDictionary(Func`2<IGrouping`2<object, object>, object> keySelector);
    public IDictionary`2<object, object> ToDictionary(Func`2<IGrouping`2<object, object>, object> keySelector, IEqualityComparer`1<object> comparer);
    public IDictionary`2<object, object> ToDictionary(Func`2<IGrouping`2<object, object>, object> keySelector, Func`2<IGrouping`2<object, object>, object> elementSelector);
    public IDictionary`2<object, object> ToDictionary(Func`2<IGrouping`2<object, object>, object> keySelector, Func`2<IGrouping`2<object, object>, object> elementSelector, IEqualityComparer`1<object> comparer);
    public IDictionary`2<object, object> ToDictionary(Func`2<object, object> keySelector);
    public IDictionary`2<object, object> ToDictionary(Func`2<object, object> keySelector, IEqualityComparer`1<object> comparer);
    public IDictionary`2<object, object> ToDictionary(Func`2<object, object> keySelector, Func`2<object, object> elementSelector);
    public IDictionary`2<object, object> ToDictionary(Func`2<object, object> keySelector, Func`2<object, object> elementSelector, IEqualityComparer`1<object> comparer);
    public ILookup`2<TKey, object> ToLookup(Func`2<object, TKey> keySelector, Func`2<object, object> elementSelector);
    public IEnumerable`1<object> OfType();
    public IEnumerable`1<object> Cast();
    public object ElementAt(int index);
    public object ElementAtOrDefault(int index);
    public long LongCount();
    public long LongCount(Func`2<object, bool> predicate);
    public object Aggregate(Func`3<object, object, object> func);
    public object Aggregate(object seed, Func`3<object, object, object> func);
    public object Aggregate(object seed, Func`3<object, object, object> func, Func`2<object, object> resultSelector);
    public IEnumerable`1<object> TakeWhile(Func`2<object, bool> predicate);
    public IEnumerable`1<object> TakeWhile(Func`3<object, int, bool> predicate);
    public IEnumerable`1<object> SkipWhile(Func`2<object, bool> predicate);
    public IEnumerable`1<object> SkipWhile(Func`3<object, int, bool> predicate);
    public IEnumerable`1<object> Join(IEnumerable`1<object> items, Func`2<object, object> outerKeySelector, Func`2<object, object> innerKeySelector, Func`3<object, object, object> resultSelector);
    public IEnumerable`1<object> GroupJoin(IEnumerable`1<object> items, Func`2<object, object> outerKeySelector, Func`2<object, object> innerKeySelector, Func`3<object, object, object> resultSelector);
    public IEnumerable`1<object> Concat(IEnumerable second);
    public IEnumerable`1<object> Zip(IEnumerable second, Func`3<object, object, object> resultSelector);
    public IEnumerable`1<object> Union(IEnumerable second);
    public IEnumerable`1<object> Intersect(IEnumerable second);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Server.Documents.Indexes.Static.DynamicAttachment : AbstractDynamicObject {
    private Attachment _attachment;
    private string _hash;
    private string _contentAsString;
    public string Name { get; }
    public string ContentType { get; }
    public string Hash { get; }
    public long Size { get; }
    public DynamicAttachment(Attachment attachment);
    public virtual object GetId();
    public virtual bool Set(object item);
    public sealed virtual string get_Name();
    public sealed virtual string get_ContentType();
    public sealed virtual string get_Hash();
    public sealed virtual long get_Size();
    public sealed virtual string GetContentAsString();
    public sealed virtual string GetContentAsString(Encoding encoding);
    public sealed virtual Stream GetContentAsStream();
    protected virtual bool TryGetByName(string name, Object& result);
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Documents.Indexes.Static.DynamicBlittableJson : AbstractDynamicObject {
    private static int DocumentIdFieldNameIndex;
    private static int MetadataIdPropertyIndex;
    private static int MetadataHasValueIndex;
    private static int MetadataKeyIndex;
    private static int MetadataIdIndex;
    private static int MetadataChangeVectorIndex;
    private static int MetadataLastModifiedIndex;
    private static int CountIndex;
    private static int MetadataEtagIndex;
    private static CompareKey[] PrecomputedTable;
    private Document _doc;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <BlittableJson>k__BackingField;
    public BlittableJsonReaderObject BlittableJson { get; private set; }
    public object Item { get; }
    private static DynamicBlittableJson();
    public DynamicBlittableJson(Document document);
    public DynamicBlittableJson(BlittableJsonReaderObject blittableJson);
    [CompilerGeneratedAttribute]
public sealed virtual BlittableJsonReaderObject get_BlittableJson();
    [CompilerGeneratedAttribute]
private void set_BlittableJson(BlittableJsonReaderObject value);
    public void EnsureMetadata();
    public bool Set(Document document);
    public virtual bool Set(object item);
    public bool TryGetDocument(Document& doc);
    public virtual object GetId();
    public bool ContainsKey(string key);
    protected virtual bool TryGetByName(string name, Object& result);
    public object get_Item(string key);
    public T Value(string key);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.DynamicBlittableJson/<GetEnumerator>d__29")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.DynamicBlittableJson/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<System-Object,System-Object>>-GetEnumerator>d__30")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<object, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.GetEnumerator();
    public IDictionary`2<object, object> ToDictionary(Func`2<object, object> keySelector);
    public IDictionary`2<object, object> ToDictionary(Func`2<object, object> keySelector, IEqualityComparer`1<object> comparer);
    public IDictionary`2<object, object> ToDictionary(Func`2<object, object> keySelector, Func`2<object, object> elementSelector);
    public IDictionary`2<object, object> ToDictionary(Func`2<object, object> keySelector, Func`2<object, object> elementSelector, IEqualityComparer`1<object> comparer);
    public IEnumerable`1<object> SelectMany(Func`2<object, IEnumerable`1<object>> func);
    public IEnumerable`1<object> Select(Func`2<object, object> func);
    public IEnumerable`1<object> Where(Func`2<object, bool> predicate);
    public IEnumerable`1<object> OrderBy(Func`2<object, object> func);
    public IEnumerable`1<object> OrderByDescending(Func`2<object, object> func);
    public IEnumerable`1<object> Take(int count);
    public IEnumerable`1<object> Skip(int count);
    public IEnumerable`1<object> Reverse();
    public object DefaultIfEmpty(object defaultValue);
    public object GroupBy(Func`2<object, object> keySelector);
    public object GroupBy(Func`2<object, object> keySelector, Func`2<object, object> selector);
    public IEnumerable`1<object> OfType();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    private bool Equals(DynamicBlittableJson other);
    public virtual int GetHashCode();
    private static bool FastCompare(string name, int fieldLookup);
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Documents.Indexes.Static.DynamicDictionary : DynamicObject {
    private Dictionary`2<object, object> _dictionary;
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.Count { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection`1<object> Keys { get; }
    public ICollection`1<object> Values { get; }
    public DynamicDictionary(Dictionary`2<object, object> dictionary);
    public DynamicDictionary(DynamicBlittableJson dictionary, Func`2<object, object> keySelector);
    public DynamicDictionary(DynamicBlittableJson dictionary, Func`2<object, object> keySelector, IEqualityComparer`1<object> comparer);
    public DynamicDictionary(DynamicBlittableJson dictionary, Func`2<object, object> keySelector, Func`2<object, object> elementSelector);
    public DynamicDictionary(DynamicBlittableJson dictionary, Func`2<object, object> keySelector, Func`2<object, object> elementSelector, IEqualityComparer`1<object> comparer);
    public DynamicDictionary(IEnumerable`1<KeyValuePair`2<object, object>> dictionary);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.DynamicDictionary/<System-Collections-Generic-IEnumerable<System-Object>-GetEnumerator>d__7")]
private sealed virtual override IEnumerator`1<object> System.Collections.Generic.IEnumerable<System.Object>.GetEnumerator();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.DynamicDictionary/<GetEnumerator>d__8")]
public sealed virtual IEnumerator`1<KeyValuePair`2<object, object>> GetEnumerator();
    public IOrderedEnumerable`1<object> CreateOrderedEnumerable(Func`2<object, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public object Aggregate(Func`3<object, object, object> func);
    public object Aggregate(object seed, Func`3<object, object, object> func);
    public object Aggregate(object seed, Func`3<object, object, object> func, Func`2<object, object> resultSelector);
    public sealed virtual void Add(KeyValuePair`2<object, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<object, object> item);
    public bool Contains(KeyValuePair`2<TKey, TValue> item);
    public bool Contains(KeyValuePair`2<TKey, TValue> item, IEqualityComparer`1<KeyValuePair`2<TKey, TValue>> comparer);
    public DynamicDictionary ToDictionary(Func`2<T, object> keySelector, Func`2<T, object> elementSelector);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<object, object> item);
    public bool Remove(KeyValuePair`2<TKey, TValue> item);
    public int Count();
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.Object,System.Object>>.get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool ContainsKey(object key);
    public sealed virtual bool Remove(object key);
    public sealed virtual bool TryGetValue(object key, Object& value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection`1<object> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public DynamicDictionary OrderBy(Func`2<object, object> keySelector);
    public DynamicDictionary OrderBy(Func`2<object, object> keySelector, IComparer`1<object> comparer);
    public DynamicDictionary OrderByDescending(Func`2<object, object> keySelector);
    public DynamicDictionary OrderByDescending(Func`2<object, object> keySelector, IComparer`1<object> comparer);
    public IEnumerable`1<IGrouping`2<object, object>> GroupBy(Func`2<object, object> keySelector);
    public IEnumerable`1<IGrouping`2<object, object>> GroupBy(Func`2<object, object> keySelector, IEqualityComparer`1<object> comparer);
    public IEnumerable`1<IGrouping`2<object, object>> GroupBy(Func`2<object, object> keySelector, Func`2<object, object> elementSelector);
    public IEnumerable`1<IGrouping`2<object, object>> GroupBy(Func`2<object, object> keySelector, Func`2<object, object> elementSelector, IEqualityComparer`1<object> comparer);
    public IEnumerable`1<object> GroupBy(Func`2<object, object> keySelector, Func`3<object, IEnumerable`1<object>, object> resultSelector);
    public IEnumerable`1<object> GroupBy(Func`2<object, object> keySelector, Func`2<object, object> elementSelector, Func`3<object, IEnumerable`1<object>, object> resultSelector);
    public IEnumerable`1<object> GroupBy(Func`2<object, object> keySelector, Func`3<object, IEnumerable`1<object>, object> resultSelector, IEqualityComparer`1<object> comparer);
    public IEnumerable`1<object> GroupBy(Func`2<object, object> keySelector, Func`2<object, object> elementSelector, Func`3<object, IEnumerable`1<object>, object> resultSelector, IEqualityComparer`1<object> comparer);
    public KeyValuePair`2<object, object> Last();
    public KeyValuePair`2<object, object> Last(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public KeyValuePair`2<object, object> LastOrDefault();
    public KeyValuePair`2<object, object> LastOrDefault(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public DynamicDictionary SkipLast(int count);
    public DynamicDictionary Take(int count);
    public DynamicDictionary TakeWhile(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public DynamicDictionary TakeWhile(Func`3<KeyValuePair`2<object, object>, int, bool> predicate);
    public DynamicDictionary TakeLast(int count);
    public DynamicDictionary Union(IEnumerable`1<object> second);
    public DynamicDictionary Union(IEnumerable`1<object> second, IEqualityComparer`1<KeyValuePair`2<object, object>> comparer);
    public DynamicDictionary Intersect(IEnumerable`1<object> second);
    public DynamicDictionary Intersect(IEnumerable`1<object> second, IEqualityComparer`1<KeyValuePair`2<object, object>> comparer);
    public IEnumerable`1<TResult> OfType();
    public DynamicDictionary Prepend(KeyValuePair`2<TKey, TValue> element);
    public DynamicDictionary Where(Func`2<object, bool> predicate);
    public DynamicDictionary Where(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public DynamicDictionary Where(Func`3<KeyValuePair`2<object, object>, int, bool> predicate);
    public KeyValuePair`2<object, object> ElementAt(int index);
    public KeyValuePair`2<object, object> ElementAtOrDefault(int index);
    public DynamicDictionary Except(IEnumerable`1<object> second);
    public DynamicDictionary Except(IEnumerable`1<object> second, IEqualityComparer`1<KeyValuePair`2<object, object>> comparer);
    public DynamicDictionary Reverse();
    public bool All(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public bool Any(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public bool Any();
    public DynamicDictionary Append(KeyValuePair`2<TKey, TValue> element);
    public double Average(Func`2<object, int> selector);
    public Nullable`1<double> Average(Func`2<object, Nullable`1<int>> selector);
    public double Average(Func`2<object, long> selector);
    public Nullable`1<double> Average(Func`2<object, Nullable`1<long>> selector);
    public float Average(Func`2<object, float> selector);
    public Nullable`1<float> Average(Func`2<object, Nullable`1<float>> selector);
    public double Average(Func`2<object, double> selector);
    public Nullable`1<double> Average(Func`2<object, Nullable`1<double>> selector);
    public decimal Average(Func`2<object, decimal> selector);
    public Nullable`1<decimal> Average(Func`2<object, Nullable`1<decimal>> selector);
    public KeyValuePair`2<object, object> Single();
    public KeyValuePair`2<object, object> Single(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public KeyValuePair`2<object, object> SingleOrDefault();
    public KeyValuePair`2<object, object> SingleOrDefault(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public DynamicDictionary Skip(int count);
    public DynamicDictionary SkipWhile(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public DynamicDictionary SkipWhile(Func`3<KeyValuePair`2<object, object>, int, bool> predicate);
    public DynamicDictionary DefaultIfEmpty();
    public DynamicDictionary Distinct();
    public DynamicDictionary Distinct(IEqualityComparer`1<KeyValuePair`2<object, object>> comparer);
    public KeyValuePair`2<object, object> First();
    public KeyValuePair`2<object, object> First(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public KeyValuePair`2<object, object> FirstOrDefault();
    public KeyValuePair`2<object, object> FirstOrDefault(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public DynamicDictionary GroupJoin(DynamicDictionary inner, Func`2<KeyValuePair`2<object, object>, object> outerKeySelector, Func`2<KeyValuePair`2<object, object>, object> innerKeySelector, Func`3<KeyValuePair`2<object, object>, object, KeyValuePair`2<object, object>> resultSelector);
    public DynamicDictionary GroupJoin(DynamicDictionary inner, Func`2<KeyValuePair`2<object, object>, object> outerKeySelector, Func`2<KeyValuePair`2<object, object>, object> innerKeySelector, Func`3<KeyValuePair`2<object, object>, object, KeyValuePair`2<object, object>> resultSelector, IEqualityComparer`1<object> comparer);
    public IEnumerable`1<object> Join(IDictionary`2<object, object> items, Func`2<object, object> outerKeySelector, Func`2<object, object> innerKeySelector, Func`3<object, object, object> resultSelector);
    public IEnumerable`1<object> Join(IDictionary`2<object, object> items, Func`2<object, object> outerKeySelector, Func`2<object, object> innerKeySelector, Func`3<object, object, object> resultSelector, IEqualityComparer`1<object> comparer);
    public long LongCount();
    public long LongCount(Func`2<KeyValuePair`2<object, object>, bool> predicate);
    public DynamicDictionary Zip(DynamicDictionary second, Func`3<KeyValuePair`2<object, object>, KeyValuePair`2<object, object>, KeyValuePair`2<object, object>> resultSelector);
    public DynamicDictionary Concat(DynamicDictionary second);
    public object Min();
    public object Max();
    public DynamicDictionary SelectMany(Func`2<KeyValuePair`2<object, object>, IEnumerable`1<KeyValuePair`2<object, object>>> selector);
    public IEnumerable`1<KeyValuePair`2<object, object>> SelectMany(Func`3<KeyValuePair`2<object, object>, int, IEnumerable`1<KeyValuePair`2<object, object>>> selector);
    public IEnumerable`1<KeyValuePair`2<object, object>> SelectMany(Func`3<KeyValuePair`2<object, object>, int, IEnumerable`1<KeyValuePair`2<object, object>>> collectionSelector, Func`3<KeyValuePair`2<object, object>, KeyValuePair`2<object, object>, KeyValuePair`2<object, object>> resultSelector);
    public IEnumerable`1<KeyValuePair`2<object, object>> SelectMany(Func`2<KeyValuePair`2<object, object>, IEnumerable`1<KeyValuePair`2<object, object>>> collectionSelector, Func`3<KeyValuePair`2<object, object>, KeyValuePair`2<object, object>, KeyValuePair`2<object, object>> resultSelector);
    public IEnumerable`1<object> SelectMany(Func`2<KeyValuePair`2<object, object>, IEnumerable`1<object>> selector);
    public IEnumerable`1<KeyValuePair`2<object, object>> Select();
    public IEnumerable`1<object> Select(Func`2<object, object> func);
    public IEnumerable`1<object> Select(Func`3<object, int, object> func);
    public int Sum(Func`2<object, int> selector);
    public Nullable`1<int> Sum(Func`2<object, Nullable`1<int>> selector);
    public long Sum(Func`2<object, long> selector);
    public Nullable`1<long> Sum(Func`2<object, Nullable`1<long>> selector);
    public float Sum(Func`2<object, float> selector);
    public Nullable`1<float> Sum(Func`2<object, Nullable`1<float>> selector);
    public double Sum(Func`2<object, double> selector);
    public Nullable`1<double> Sum(Func`2<object, Nullable`1<double>> selector);
    public decimal Sum(Func`2<object, decimal> selector);
    public Nullable`1<decimal> Sum(Func`2<object, Nullable`1<decimal>> selector);
    private static object ToDynamicDictionarySupportedType(object value);
    private static Dictionary`2<object, object> EnumerableToDictionary(IEnumerable`1<object> second);
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Documents.Indexes.Static.DynamicNullObject : DynamicObject {
    public static DynamicNullObject Null;
    public static DynamicNullObject ExplicitNull;
    public bool IsExplicitNull;
    [DynamicAttribute]
public object Item { get; }
    [DynamicAttribute]
public object Item { get; }
    [DynamicAttribute]
public object Item { get; }
    private DynamicNullObject(bool isExplicitNull);
    private static DynamicNullObject();
    public virtual string ToString();
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.DynamicNullObject/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static bool op_True(DynamicNullObject left);
    public static bool op_False(DynamicNullObject left);
    public static object op_OnesComplement(DynamicNullObject left);
    public static object op_LogicalNot(DynamicNullObject left);
    public static object op_ExclusiveOr(DynamicNullObject left, object right);
    public static object op_BitwiseAnd(DynamicNullObject left, object right);
    public static object op_BitwiseOr(DynamicNullObject left, object right);
    public static DynamicNullObject op_Increment(DynamicNullObject left);
    public static DynamicNullObject op_Decrement(DynamicNullObject left);
    public static object op_Addition(DynamicNullObject left, object right);
    public static object op_Subtraction(DynamicNullObject left, object right);
    public static object op_Multiply(DynamicNullObject left, object right);
    public static object op_Division(DynamicNullObject left, object right);
    public static object op_Modulus(DynamicNullObject left, object right);
    public static bool op_GreaterThanOrEqual(DynamicNullObject left, object right);
    public static bool op_LessThanOrEqual(DynamicNullObject left, object right);
    public static bool op_GreaterThan(DynamicNullObject left, object right);
    public static bool op_LessThan(DynamicNullObject left, object right);
    public static bool op_Equality(DynamicNullObject left, object right);
    public static bool op_Inequality(DynamicNullObject left, object right);
    public static double op_Implicit(DynamicNullObject o);
    public static Nullable`1<double> op_Implicit(DynamicNullObject o);
    public static int op_Implicit(DynamicNullObject o);
    public static Nullable`1<int> op_Implicit(DynamicNullObject o);
    public static long op_Implicit(DynamicNullObject o);
    public static Nullable`1<long> op_Implicit(DynamicNullObject o);
    public static decimal op_Implicit(DynamicNullObject o);
    public static Nullable`1<decimal> op_Implicit(DynamicNullObject o);
    public static float op_Implicit(DynamicNullObject o);
    public static Nullable`1<float> op_Implicit(DynamicNullObject o);
    public static string op_Implicit(DynamicNullObject self);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public object get_Item(string key);
    public object get_Item(long key);
    public object get_Item(double key);
}
public class Raven.Server.Documents.Indexes.Static.EsprimaReferencedCollectionVisitor : EsprimaVisitor {
    public HashSet`1<CollectionName> ReferencedCollection;
    [CompilerGeneratedAttribute]
private bool <HasCompareExchangeReferences>k__BackingField;
    public bool HasCompareExchangeReferences { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_HasCompareExchangeReferences();
    [CompilerGeneratedAttribute]
private void set_HasCompareExchangeReferences(bool value);
    public virtual void VisitCallExpression(CallExpression callExpression);
    [CompilerGeneratedAttribute]
internal static bool <VisitCallExpression>g__TryGetIdentifier|5_0(CallExpression callExpression, Identifier& identifier, Boolean& noTracking);
}
public class Raven.Server.Documents.Indexes.Static.EsprimaVisitor : object {
    public virtual void VisitProgram(Program program);
    public virtual void VisitStatement(Statement statement);
    public virtual void VisitUnknownNode(Node node);
    public virtual void VisitUnknownObject(object obj);
    private void VisitCatchClause(CatchClause catchClause);
    public virtual void VisitFunctionDeclaration(FunctionDeclaration functionDeclaration);
    public virtual void VisitWithStatement(WithStatement withStatement);
    public virtual void VisitWhileStatement(WhileStatement whileStatement);
    public virtual void VisitVariableDeclaration(VariableDeclaration variableDeclaration);
    public virtual void VisitTryStatement(TryStatement tryStatement);
    public virtual void VisitThrowStatement(ThrowStatement throwStatement);
    public virtual void VisitSwitchStatement(SwitchStatement switchStatement);
    public virtual void VisitSwitchCase(SwitchCase switchCase);
    public virtual void VisitReturnStatement(ReturnStatement returnStatement);
    public virtual void VisitLabeledStatement(LabeledStatement labeledStatement);
    public virtual void VisitIfStatement(IfStatement ifStatement);
    public virtual void VisitEmptyStatement(EmptyStatement emptyStatement);
    public virtual void VisitDebuggerStatement(DebuggerStatement debuggerStatement);
    public virtual void VisitExpressionStatement(ExpressionStatement expressionStatement);
    public virtual void VisitForStatement(ForStatement forStatement);
    public virtual void VisitForInStatement(ForInStatement forInStatement);
    public virtual void VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    public virtual void VisitExpression(Expression expression);
    public virtual void VisitArrowFunctionExpression(ArrowFunctionExpression arrowFunctionExpression);
    public virtual void VisitUnaryExpression(UnaryExpression unaryExpression);
    public virtual void VisitUpdateExpression(UpdateExpression updateExpression);
    public virtual void VisitThisExpression(ThisExpression thisExpression);
    public virtual void VisitSequenceExpression(SequenceExpression sequenceExpression);
    public virtual void VisitObjectExpression(ObjectExpression objectExpression);
    public virtual void VisitNewExpression(NewExpression newExpression);
    public virtual void VisitMemberExpression(MemberExpression memberExpression);
    public virtual void VisitLogicalExpression(BinaryExpression binaryExpression);
    public virtual void VisitLiteral(Literal literal);
    public virtual void VisitIdentifier(Identifier identifier);
    public virtual void VisitFunctionExpression(IFunction function);
    public virtual void Visit(Node node);
    public virtual void VisitClassExpression(ClassExpression classExpression);
    public virtual void VisitExportDefaultDeclaration(ExportDefaultDeclaration exportDefaultDeclaration);
    public virtual void VisitExportAllDeclaration(ExportAllDeclaration exportAllDeclaration);
    public virtual void VisitExportNamedDeclaration(ExportNamedDeclaration exportNamedDeclaration);
    public virtual void VisitExportSpecifier(ExportSpecifier exportSpecifier);
    public virtual void VisitImportDeclaration(ImportDeclaration importDeclaration);
    public virtual void VisitImportNamespaceSpecifier(ImportNamespaceSpecifier importNamespaceSpecifier);
    public virtual void VisitImportDefaultSpecifier(ImportDefaultSpecifier importDefaultSpecifier);
    public virtual void VisitImportSpecifier(ImportSpecifier importSpecifier);
    public virtual void VisitMethodDefinition(MethodDefinition methodDefinitions);
    public virtual void VisitForOfStatement(ForOfStatement forOfStatement);
    public virtual void VisitClassDeclaration(ClassDeclaration classDeclaration);
    public virtual void VistClassBody(ClassBody classBody);
    public virtual void VisitYieldExpression(YieldExpression yieldExpression);
    public virtual void VisitTaggedTemplateExpression(TaggedTemplateExpression taggedTemplateExpression);
    public virtual void VisitSuper(Super super);
    public virtual void VisitMetaProperty(MetaProperty metaProperty);
    public virtual void VisitObjectPattern(ObjectPattern objectPattern);
    public virtual void VisitSpreadElement(SpreadElement spreadElement);
    public virtual void VisitAssignmentPattern(AssignmentPattern assignmentPattern);
    public virtual void VisitArrayPattern(ArrayPattern arrayPattern);
    public virtual void VisitVariableDeclarator(VariableDeclarator variableDeclarator);
    public virtual void VisitTemplateLiteral(TemplateLiteral templateLiteral);
    public virtual void VisitTemplateElement(TemplateElement templateElement);
    public virtual void VisitRestElement(RestElement restElement);
    public virtual void VisitProperty(Property property);
    public virtual void VisitConditionalExpression(ConditionalExpression conditionalExpression);
    public virtual void VisitCallExpression(CallExpression callExpression);
    public virtual void VisitBinaryExpression(BinaryExpression binaryExpression);
    public virtual void VisitArrayExpression(ArrayExpression arrayExpression);
    public virtual void VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    public virtual void VisitContinueStatement(ContinueStatement continueStatement);
    public virtual void VisitBreakStatement(BreakStatement breakStatement);
    public virtual void VisitBlockStatement(Node blockStatement);
}
public static class Raven.Server.Documents.Indexes.Static.Extensions.DynamicExtensionMethods : object {
    public static BoostedValue Boost(object o, object value);
    public static object IfEntityIs(object o, string collection);
    public static object ParseInt(object o);
    public static object ParseInt(object o, int defaultValue);
    public static object ParseDouble(object o);
    public static object ParseDouble(object o, double defaultValue);
    public static object ParseDecimal(object o);
    public static object ParseDecimal(object o, decimal defaultValue);
    public static object ParseLong(object o);
    public static object ParseLong(object o, long defaultValue);
    private static bool TryGetString(object o, String& value);
}
[ExtensionAttribute]
public static class Raven.Server.Documents.Indexes.Static.Extensions.LinqOnDynamic : object {
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object First(IGrouping`2<object, object> self, Func`2<object, bool> predicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object FirstOrDefault(IGrouping`2<object, object> self);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object FirstOrDefault(IGrouping`2<object, object> self, Func`2<object, bool> predicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object Last(IGrouping`2<object, object> self);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object Last(IGrouping`2<object, object> self, Func`2<object, bool> predicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object LastOrDefault(IGrouping`2<object, object> self);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object LastOrDefault(IGrouping`2<object, object> self, Func`2<object, bool> predicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object Single(IGrouping`2<object, object> self);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object Single(IGrouping`2<object, object> self, Func`2<object, bool> predicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object SingleOrDefault(IGrouping`2<object, object> self);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object SingleOrDefault(IGrouping`2<object, object> self, Func`2<object, bool> predicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object ElementAt(IGrouping`2<object, object> self, int index);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object ElementAtOrDefault(IGrouping`2<object, object> self, int index);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object Min(IGrouping`2<object, object> self);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object Min(IGrouping`2<object, object> self, Func`2<object, bool> predicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object Max(IGrouping`2<object, object> self, Func`2<object, bool> predicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static object Max(IGrouping`2<object, object> self);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<IGrouping`2<object, object>> GroupBy(IEnumerable`1<object> source, Func`2<object, object> keySelector);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<IGrouping`2<object, object>> GroupBy(IEnumerable`1<object> source, Func`2<object, object> keySelector, Func`2<object, object> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<object> Select(IEnumerable`1<object> source, Func`2<object, object> func);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<object> Select(IEnumerable`1<object> source, Func`2<IGrouping`2<object, object>, object> func);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<object> Select(IEnumerable`1<object> source, Func`3<object, int, object> func);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<object> SelectMany(object source, Func`3<object, int, IEnumerable`1<object>> collectionSelector, Func`3<object, object, object> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<object> SelectMany(object source, Func`2<object, IEnumerable`1<object>> collectionSelector, Func`3<object, object, object> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<object> SelectMany(object source, Func`2<object, IEnumerable`1<object>> selector);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<object> SelectMany(IGrouping`2<object, object> source, Func`3<object, int, IEnumerable`1<object>> collectionSelector, Func`3<object, object, object> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<object> SelectMany(IGrouping`2<object, object> source, Func`2<object, IEnumerable`1<object>> collectionSelector, Func`3<object, object, object> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<object> SelectMany(IGrouping`2<object, object> source, Func`2<object, IEnumerable`1<object>> selector);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IEnumerable`1<object> DefaultIfEmpty(IEnumerable`1<object> self);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IDictionary`2<object, object> ToDictionary(IEnumerable`1<T> source, Func`2<T, object> keySelector, Func`2<T, object> elementSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should never be used directly.")]
public static IDictionary`2<object, object> ToDictionary(IEnumerable`1<T> source, Func`2<T, object> keySelector, Func`2<T, object> elementSelector, IEqualityComparer`1<object> comparer);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.Extensions.LinqOnDynamic/<Select>d__31")]
[ExtensionAttribute]
private static IEnumerable`1<object> Select(object self);
}
public interface Raven.Server.Documents.Indexes.Static.IIndexItemFilterBehavior {
    public abstract virtual bool ShouldFilter(IndexItem item);
}
public static class Raven.Server.Documents.Indexes.Static.IndexCompilationCache : object {
    private static ConcurrentDictionary`2<CacheKey, Lazy`1<AbstractStaticIndexBase>> _indexCache;
    private static IndexCompilationCache();
    public static AbstractStaticIndexBase GetIndexInstance(IndexDefinition definition, RavenConfiguration configuration, long indexVersion);
    private static StaticIndexBase GetDocumentsIndexInstance(IndexDefinition definition, RavenConfiguration configuration, IndexType type, long indexVersion);
    private static TIndexBase GetIndexInstance(IndexDefinition definition, RavenConfiguration configuration, IndexType type, long indexVersion);
    private static CacheKey GetCacheKey(IndexDefinition definition);
    internal static AbstractStaticIndexBase GenerateIndex(IndexDefinition definition, RavenConfiguration configuration, IndexType type, long indexVersion);
}
public static class Raven.Server.Documents.Indexes.Static.IndexCompiler : object {
    private static Logger Logger;
    internal static bool EnableDebugging;
    private static string IndexNamespace;
    internal static string IndexExtension;
    internal static string AdditionalSourceExtension;
    internal static string IndexNamePrefix;
    private static Lazy`1<ConcurrentDictionary`2<string, AdditionalAssemblyServerSide>> AdditionalAssemblies;
    private static Assembly LuceneAssembly;
    private static AssemblyName LuceneAssemblyName;
    [ThreadStaticAttribute]
private static bool DisableMatchingAdditionalAssembliesByNameValue;
    private static string IndexesStaticNamespace;
    private static UsingDirectiveSyntax[] Usings;
    public static MetadataReference[] References;
    private static IndexCompiler();
    private static IDisposable DisableMatchingAdditionalAssembliesByName();
    private static ConcurrentDictionary`2<string, AdditionalAssemblyServerSide> DiscoverAdditionalAssemblies();
    private static MetadataReference CreateMetadataReferenceFromAssembly(Assembly assembly);
    public static AbstractStaticIndexBase Compile(IndexDefinition definition, long indexVersion);
    private static CompilationResult CompileInternal(string originalName, string cSharpSafeName, MemberDeclarationSyntax class, IndexDefinition definition);
    private static ValueTuple`3<UsingDirectiveSyntax[], List`1<SyntaxTree>, MetadataReference[]> GetUsingDirectiveAndSyntaxTreesAndReferences(IndexDefinition definition, string cSharpSafeName);
    private static string AddUsingIndexStatic(string ext);
    private static MetadataReference[] GetReferences(IndexDefinition definition);
    private static MemberDeclarationSyntax CreateClass(string name, IndexDefinition definition, long indexVersion);
    private static List`1<CompiledIndexField> GetIndexedFields(IndexDefinition definition, FieldNamesValidator fieldNamesValidator);
    private static List`1<StatementSyntax> HandleMap(IndexSourceType type, string map, FieldNamesValidator fieldNamesValidator, MethodDetectorRewriter methodsDetector, StackDepthRetriever stackDepthRetriever, SyntaxList`1& members);
    private static StatementSyntax HandleReduce(string reduce, FieldNamesValidator fieldNamesValidator, MethodDetectorRewriter methodsDetector, StackDepthRetriever stackDepthRetriever, CompiledIndexField[]& groupByFields);
    private static List`1<StatementSyntax> HandleSyntaxInCountersMap(FieldNamesValidator fieldValidator, MapFunctionProcessor mapRewriter, ExpressionSyntax expression, SyntaxList`1& members);
    private static List`1<StatementSyntax> HandleSyntaxInTimeSeriesMap(FieldNamesValidator fieldValidator, MapFunctionProcessor mapRewriter, ExpressionSyntax expression, SyntaxList`1& members);
    private static List`1<StatementSyntax> HandleSyntaxInMap(FieldNamesValidator fieldValidator, MapFunctionProcessor mapRewriter, ExpressionSyntax expression, SyntaxList`1& members);
    private static ValueTuple`2<List`1<StatementSyntax>, ExpressionSyntax> HandleSyntaxInMapBase(FieldNamesValidator fieldValidator, MapFunctionProcessor mapRewriter, ExpressionSyntax expression, SyntaxList`1& members, string identifier);
    private static StatementSyntax HandleSyntaxInReduce(ReduceFunctionProcessor reduceFunctionProcessor, MethodsInGroupByValidator methodsInGroupByValidator, ExpressionSyntax expression, CompiledIndexField[]& groupByFields);
    private static ArrayCreationExpressionSyntax GetArrayCreationExpression(IEnumerable`1<CompiledIndexField> items, Action`2<StringBuilder, CompiledIndexField> write);
    private static string GetCSharpSafeName(string name);
    private static string NormalizeFunction(string function);
    [CompilerGeneratedAttribute]
internal static MetadataReference <GetReferences>g__FromAssemblyName|21_0(string name);
    [CompilerGeneratedAttribute]
internal static MetadataReference <GetReferences>g__FromAssemblyPath|21_1(string path);
    [CompilerGeneratedAttribute]
internal static HashSet`1<MetadataReference> <GetReferences>g__FromPackage|21_2(string packageName, string packageVersion, string packageSourceUrl);
    [CompilerGeneratedAttribute]
internal static MetadataReference <GetReferences>g__RegisterAssembly|21_3(Assembly assembly);
    [CompilerGeneratedAttribute]
internal static Assembly <GetReferences>g__LoadAssembly|21_4(string path);
    [CompilerGeneratedAttribute]
internal static void <GetReferences>g__RegisterPackage|21_5(NuGetPackage package, bool userDefined, HashSet`1<MetadataReference> references);
}
public class Raven.Server.Documents.Indexes.Static.IndexingFunc : MulticastDelegate {
    public IndexingFunc(object object, IntPtr method);
    public virtual IEnumerable Invoke(IEnumerable`1<object> items);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<object> items, AsyncCallback callback, object object);
    public virtual IEnumerable EndInvoke(IAsyncResult result);
}
public class Raven.Server.Documents.Indexes.Static.JavaScript.AttachmentNameObjectInstance : ObjectInstanceBase {
    private Dictionary`2<JsValue, PropertyDescriptor> _properties;
    private BlittableJsonReaderObject _attachmentName;
    public AttachmentNameObjectInstance(Engine engine, BlittableJsonReaderObject attachmentName);
    public virtual bool DefineOwnProperty(JsValue property, PropertyDescriptor desc);
    public virtual bool Delete(JsValue property);
    public virtual IEnumerable`1<KeyValuePair`2<JsValue, PropertyDescriptor>> GetOwnProperties();
    public virtual PropertyDescriptor GetOwnProperty(JsValue property);
    public virtual List`1<JsValue> GetOwnPropertyKeys(Types types);
    public virtual bool HasProperty(JsValue property);
    public virtual bool PreventExtensions();
    public virtual void RemoveOwnProperty(JsValue property);
    public virtual bool Set(JsValue property, JsValue value, JsValue receiver);
    [ObsoleteAttribute("Will be removed")]
protected virtual void AddProperty(JsValue property, PropertyDescriptor descriptor);
    protected virtual void SetOwnProperty(JsValue property, PropertyDescriptor desc);
    protected virtual bool TryGetProperty(JsValue property, PropertyDescriptor& descriptor);
}
public class Raven.Server.Documents.Indexes.Static.JavaScript.AttachmentObjectInstance : ObjectInstanceBase {
    private static string GetContentAsStringMethodName;
    private Dictionary`2<JsValue, PropertyDescriptor> _properties;
    private DynamicAttachment _attachment;
    public AttachmentObjectInstance(Engine engine, DynamicAttachment attachment);
    private JsValue GetContentAsString(JsValue self, JsValue[] args);
    public virtual bool DefineOwnProperty(JsValue property, PropertyDescriptor desc);
    public virtual bool Delete(JsValue property);
    public virtual IEnumerable`1<KeyValuePair`2<JsValue, PropertyDescriptor>> GetOwnProperties();
    public virtual PropertyDescriptor GetOwnProperty(JsValue property);
    public virtual List`1<JsValue> GetOwnPropertyKeys(Types types);
    public virtual bool HasProperty(JsValue property);
    public virtual bool PreventExtensions();
    public virtual void RemoveOwnProperty(JsValue property);
    public virtual bool Set(JsValue property, JsValue value, JsValue receiver);
    [ObsoleteAttribute("Will be removed")]
protected virtual void AddProperty(JsValue property, PropertyDescriptor descriptor);
    protected virtual void SetOwnProperty(JsValue property, PropertyDescriptor desc);
    protected virtual bool TryGetProperty(JsValue property, PropertyDescriptor& descriptor);
}
public class Raven.Server.Documents.Indexes.Static.JavaScript.DynamicJsNull : JsValue {
    public static DynamicJsNull ImplicitNull;
    public static DynamicJsNull ExplicitNull;
    public bool IsExplicitNull;
    private DynamicJsNull(bool isExplicitNull);
    private static DynamicJsNull();
    public virtual object ToObject();
    public virtual string ToString();
    public virtual bool Equals(JsValue other);
    public sealed virtual bool Equals(JsNull other);
    public sealed virtual bool Equals(DynamicJsNull other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public abstract class Raven.Server.Documents.Indexes.Static.JavaScript.ObjectInstanceBase : ObjectInstance {
    protected static PropertyDescriptor ImplicitNull;
    protected ObjectInstanceBase(Engine engine);
    private static ObjectInstanceBase();
}
public class Raven.Server.Documents.Indexes.Static.JavaScript.RecursiveJsFunction : object {
    private List`1<JsValue> _result;
    private Engine _engine;
    private JsValue _item;
    private ScriptFunction _func;
    private HashSet`1<JsValue> _results;
    private Queue`1<object> _queue;
    public RecursiveJsFunction(Engine engine, JsValue item, ScriptFunction func);
    public JsValue Execute();
    private void AddItem(JsValue current);
    private static object NullIfEmptyEnumerable(JsValue item);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.JavaScript.RecursiveJsFunction/<Yield>d__10")]
private static IEnumerable`1<JsValue> Yield(JsArray array);
}
public class Raven.Server.Documents.Indexes.Static.JavaScriptIndex : AbstractJavaScriptIndex {
    public static string NoTracking;
    public static string Load;
    public static string CmpXchg;
    public JavaScriptIndex(IndexDefinition definition, RavenConfiguration configuration, long indexVersion);
    private static string GetMapCode();
    protected virtual void OnInitializeEngine(Engine engine);
    protected virtual void ProcessMaps(ObjectInstance definitions, JintPreventResolvingTasksReferenceResolver resolver, List`1<string> mapList, List`1<MapMetadata> mapReferencedCollections, Dictionary`2& collectionFunctions);
    private JsValue GetDocumentId(JsValue self, JsValue[] args);
    private JsValue AttachmentsFor(JsValue self, JsValue[] args);
    private JsValue MetadataFor(JsValue self, JsValue[] args);
    private JsValue TimeSeriesNamesFor(JsValue self, JsValue[] args);
    private JsValue CounterNamesFor(JsValue self, JsValue[] args);
    private JsValue LoadAttachment(JsValue self, JsValue[] args);
    private JsValue LoadAttachments(JsValue self, JsValue[] args);
}
internal class Raven.Server.Documents.Indexes.Static.JavaScriptIndexFuncException : Exception {
    private static String[] _newLineSplitters;
    public JavaScriptIndexFuncException(string message);
    public JavaScriptIndexFuncException(string message, Exception innerException);
    private static JavaScriptIndexFuncException();
    internal static ValueTuple`2<string, bool> PrepareErrorMessageForJavaScriptIndexFuncException(string script, JavaScriptException jse);
}
public static class Raven.Server.Documents.Indexes.Static.JavaScriptIndexUtils : object {
    public static IEnumerable`1<ReturnStatement> GetReturnStatements(IFunction function);
    public static IEnumerable`1<ReturnStatement> GetReturnStatements(Node stmt);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.JavaScriptIndexUtils/<GetReturnStatements>d__2")]
private static IEnumerable`1<ReturnStatement> GetReturnStatements(IEnumerable`1<StatementListItem> items);
    public static bool GetValue(Engine engine, object item, JsValue& jsItem, bool isMapReduce);
    public static object StringifyObject(JsValue jsValue);
}
public class Raven.Server.Documents.Indexes.Static.JavaScriptMapOperation : object {
    public Function MapFunc;
    public bool HasDynamicReturns;
    public bool HasBoostedFields;
    public HashSet`1<string> Fields;
    public Dictionary`2<string, IndexFieldOptions> FieldOptions;
    private Engine _engine;
    private JintPreventResolvingTasksReferenceResolver _resolver;
    private JsValue[] _oneItemArray;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private JsArray <MoreArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MapString>k__BackingField;
    public string IndexName { get; public set; }
    public JsArray MoreArguments { get; public set; }
    public string MapString { get; internal set; }
    public JavaScriptMapOperation(Engine engine, JintPreventResolvingTasksReferenceResolver resolver);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.JavaScriptMapOperation/<IndexingFunction>d__13")]
public IEnumerable IndexingFunction(IEnumerable`1<object> items);
    public void Analyze(Engine engine);
    private Nullable`1<ValueTuple`2<Function, IFunction>> CheckIfSimpleMapExpression(Engine engine, IFunction function);
    [CompilerGeneratedAttribute]
public JsArray get_MoreArguments();
    [CompilerGeneratedAttribute]
public void set_MoreArguments(JsArray value);
    [CompilerGeneratedAttribute]
public string get_MapString();
    [CompilerGeneratedAttribute]
internal void set_MapString(string value);
    private bool CompareFields(ObjectExpression oe);
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__IsBoostExpression|14_0(Node expression);
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__IsArrowFunctionExpressionWithObjectExpressionBody|14_1(CallExpression callExpression, ObjectExpression& oea);
}
public class Raven.Server.Documents.Indexes.Static.JavaScriptReduceOperation : object {
    private long _indexVersion;
    private JsValue[] _oneItemArray;
    private JintPreventResolvingTasksReferenceResolver _resolver;
    private Dictionary`2<BlittableJsonReaderObject, List`1<BlittableJsonReaderObject>> _groupedItems;
    [CompilerGeneratedAttribute]
private Engine <Engine>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptFunction <Reduce>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptFunction <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReduceString>k__BackingField;
    private CompiledIndexField[] _groupByFields;
    private bool _singleField;
    private UnmanagedBuffersPoolWithLowMemoryHandling _bufferPool;
    private ByteStringContext _byteStringContext;
    public Engine Engine { get; }
    public ScriptFunction Reduce { get; }
    public ScriptFunction Key { get; }
    public string ReduceString { get; internal set; }
    public JavaScriptReduceOperation(ScriptFunction reduce, ScriptFunction key, Engine engine, JintPreventResolvingTasksReferenceResolver resolver, long indexVersion);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.JavaScriptReduceOperation/<IndexingFunction>d__6")]
public IEnumerable IndexingFunction(IEnumerable`1<object> items);
    private void EnsureGroupItemCreated();
    private JsValue ConstructGrouping(List`1<BlittableJsonReaderObject> values);
    [CompilerGeneratedAttribute]
public Engine get_Engine();
    [CompilerGeneratedAttribute]
public ScriptFunction get_Reduce();
    [CompilerGeneratedAttribute]
public ScriptFunction get_Key();
    [CompilerGeneratedAttribute]
public string get_ReduceString();
    [CompilerGeneratedAttribute]
internal void set_ReduceString(string value);
    internal CompiledIndexField[] GetReduceFieldsNames();
    public void SetBufferPoolForTestingPurposes(UnmanagedBuffersPoolWithLowMemoryHandling bufferPool);
    public void SetAllocatorForTestingPurposes(ByteStringContext byteStringContext);
    [CompilerGeneratedAttribute]
private JsValue <ConstructGrouping>g__ConstructKey|8_0(<>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
private JsArray <ConstructGrouping>g__ConstructValues|8_1(<>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
private CompiledIndexField[] <GetReduceFieldsNames>g__CreateFieldsFromObjectExpression|26_0(ObjectExpression oe);
    [CompilerGeneratedAttribute]
internal static CompiledIndexField <GetReduceFieldsNames>g__CreateField|26_1(string propertyName, String[] path);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.JavaScriptReduceOperation/<<GetReduceFieldsNames>g__GetPropertyPath|26_2>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GetReduceFieldsNames>g__GetPropertyPath|26_2(MemberExpression e);
}
[DefaultMemberAttribute("Item")]
internal class Raven.Server.Documents.Indexes.Static.LazyCompressedJsString : JsString {
    internal LazyCompressedStringValue _lazyValue;
    public char Item { get; }
    public int Length { get; }
    public LazyCompressedJsString(LazyCompressedStringValue lazyValue);
    public virtual string ToString();
    public virtual bool Equals(JsString obj);
    protected virtual bool IsLooselyEqual(JsValue value);
    public virtual int GetHashCode();
    public virtual char get_Item(int index);
    public virtual int get_Length();
}
[DefaultMemberAttribute("Item")]
internal class Raven.Server.Documents.Indexes.Static.LazyJsString : JsString {
    internal LazyStringValue _lazyValue;
    public char Item { get; }
    public int Length { get; }
    public LazyJsString(LazyStringValue lazyValue);
    public virtual string ToString();
    public virtual bool Equals(JsString obj);
    protected virtual bool IsLooselyEqual(JsValue value);
    public virtual int GetHashCode();
    public virtual char get_Item(int index);
    public virtual int get_Length();
}
public static class Raven.Server.Documents.Indexes.Static.Linq.DynamicEnumerable : object {
    public static IEnumerable`1<object> Distinct(IEnumerable source);
    public static IEnumerable`1<object> Union(object source, object other);
    public static object First(IEnumerable source);
    public static object First(IEnumerable source, Func`2<object, bool> predicate);
    public static object FirstOrDefault(IEnumerable source);
    public static object FirstOrDefault(IEnumerable source, Func`2<object, bool> predicate);
    public static object Last(IEnumerable source);
    public static object Last(IEnumerable source, Func`2<object, bool> predicate);
    public static object LastOrDefault(IEnumerable source);
    public static object LastOrDefault(IEnumerable source, Func`2<object, bool> predicate);
    public static object Single(IEnumerable source);
    public static object Single(IEnumerable source, Func`2<object, bool> predicate);
    public static object SingleOrDefault(IEnumerable source);
    public static object SingleOrDefault(IEnumerable source, Func`2<object, bool> predicate);
    public static object ElementAt(IEnumerable source, int index);
    public static object ElementAtOrDefault(IEnumerable source, int index);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.Linq.DynamicEnumerable/<Yield>d__16")]
private static IEnumerable`1<object> Yield(IEnumerator enumerator);
    public static object Min(IEnumerable source);
    public static object Min(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    public static object Max(IEnumerable`1<TSource> source);
    public static object Max(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    public static IEnumerable`1<object> Concat(object source, object other);
    public static IEnumerable`1<object> Intersect(object source, object other);
    public static IOrderedEnumerable`1<object> OrderBy(IEnumerable source, Func`2<object, object> keySelector);
    public static IOrderedEnumerable`1<object> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    public static IOrderedEnumerable`1<object> OrderByDescending(IEnumerable source, Func`2<object, object> keySelector);
    public static IOrderedEnumerable`1<object> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
}
public class Raven.Server.Documents.Indexes.Static.MapIndex : MapIndexBase`2<MapIndexDefinition, IndexField> {
    private HashSet`1<string> _referencedCollections;
    private HashSet`1<string> _suggestionsActive;
    internal AbstractStaticIndexBase _compiled;
    private Nullable`1<bool> _isSideBySide;
    private HandleDocumentReferences _handleReferences;
    private HandleCompareExchangeReferences _handleCompareExchangeReferences;
    public bool HasBoostedFields { get; }
    public bool IsMultiMap { get; }
    private MapIndex(MapIndexDefinition definition, AbstractStaticIndexBase compiled);
    public virtual bool get_HasBoostedFields();
    public virtual bool get_IsMultiMap();
    public virtual void ResetIsSideBySideAfterReplacement();
    protected virtual IIndexingWork[] CreateIndexWorkExecutors();
    public virtual InMemoryReferencesInfo GetInMemoryReferencesState(string collection, bool isCompareExchange);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    internal virtual bool IsStale(QueryOperationContext queryContext, TransactionOperationContext indexContext, Nullable`1<long> cutoff, Nullable`1<long> referenceCutoff, Nullable`1<long> compareExchangeReferenceCutoff, List`1<string> stalenessReasons);
    protected virtual void HandleDocumentChange(DocumentChange change);
    public virtual ValueTuple`2<ICollection`1<string>, ICollection`1<string>> GetEntriesFields();
    protected virtual long CalculateIndexEtag(QueryOperationContext queryContext, TransactionOperationContext indexContext, QueryMetadata query, bool isStale);
    protected virtual IndexingState GetIndexingStateInternal(QueryOperationContext queryContext, TransactionOperationContext indexContext);
    protected virtual bool ShouldReplace();
    public virtual Dictionary`2<string, HashSet`1<CollectionName>> GetReferencedCollections();
    public virtual bool WorksOnAnyCollection(HashSet`1<string> collections);
    public virtual IIndexedItemEnumerator GetMapEnumerator(IEnumerable`1<IndexItem> items, string collection, TransactionOperationContext indexContext, IndexingStatsScope stats, IndexType type);
    public virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType tombstoneType);
    public static Index CreateNew(IndexDefinition definition, DocumentDatabase documentDatabase, SingleIndexConfiguration forcedConfiguration);
    public static Index Open(StorageEnvironment environment, DocumentDatabase documentDatabase);
    public static void Update(Index index, IndexDefinition definition, DocumentDatabase documentDatabase);
    private static MapIndex CreateIndexInstance(IndexDefinition definition, RavenConfiguration configuration, long indexVersion);
    public static IndexInformationHolder CreateIndexInformationHolder(IndexDefinition definition, RavenConfiguration configuration, long indexVersion, AbstractStaticIndexBase& staticIndex);
}
public class Raven.Server.Documents.Indexes.Static.MapIndexDefinition : IndexDefinitionBaseServerSide`1<IndexField> {
    private bool _hasDynamicFields;
    private bool _hasCompareExchange;
    public IndexDefinition IndexDefinition;
    public bool HasDynamicFields { get; }
    public bool HasCompareExchange { get; }
    public MapIndexDefinition(IndexDefinition definition, IEnumerable`1<string> collections, String[] outputFields, bool hasDynamicFields, bool hasCompareExchange, long indexVersion);
    public virtual bool get_HasDynamicFields();
    public virtual bool get_HasCompareExchange();
    private static IndexField[] GetFields(IndexDefinition definition, String[] outputFields);
    protected virtual void PersistFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected virtual void PersistMapFields(JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    protected internal virtual IndexDefinition GetOrCreateIndexDefinitionInternal();
    public virtual IndexDefinitionCompareDifferences Compare(IndexDefinitionBaseServerSide indexDefinition);
    public virtual IndexDefinitionCompareDifferences Compare(IndexDefinition indexDefinition);
    protected virtual int ComputeRestOfHash(int hashCode);
    public static IndexDefinition Load(StorageEnvironment environment, Int64& version);
    private static IndexDefinition ReadIndexDefinition(BlittableJsonReaderObject reader);
}
public class Raven.Server.Documents.Indexes.Static.MismatchedReferencesWarningHandler : object {
    private Dictionary`2<string, Dictionary`2<string, LoadFailure>> _mismatchedReferences;
    internal static int MaxMismatchedReferencesPerSource;
    internal static int MaxMismatchedDocumentLoadsPerIndex;
    [CompilerGeneratedAttribute]
private bool <LastLoadMismatched>k__BackingField;
    public bool LastLoadMismatched { get; public set; }
    public bool IsEmpty { get; }
    public bool IsFull { get; }
    [CompilerGeneratedAttribute]
public bool get_LastLoadMismatched();
    [CompilerGeneratedAttribute]
public void set_LastLoadMismatched(bool value);
    public bool get_IsEmpty();
    public bool get_IsFull();
    public Dictionary`2<string, Dictionary`2<string, LoadFailure>> GetLoadFailures();
    public void HandleMismatchedReference(Document referencedDocument, string referencedCollectionName, LazyStringValue sourceId, string actualCollection);
    public void RemoveMismatchedReferenceOnMatchingLoad(Document document, string sourceId);
}
public class Raven.Server.Documents.Indexes.Static.NuGet.MultiSourceNuGetFetcher : object {
    public static MultiSourceNuGetFetcher Instance;
    private bool _initialized;
    private PathSetting _rootPath;
    private ConcurrentDictionary`2<string, Lazy`1<NuGetFetcher>> _fetchers;
    [CompilerGeneratedAttribute]
private string <DefaultPackageSourceUrl>k__BackingField;
    private bool _allowPreleasePackages;
    public string DefaultPackageSourceUrl { get; private set; }
    private static MultiSourceNuGetFetcher();
    [CompilerGeneratedAttribute]
public string get_DefaultPackageSourceUrl();
    [CompilerGeneratedAttribute]
private void set_DefaultPackageSourceUrl(string value);
    public void Initialize(PathSetting rootPath, string packageSourceUrl, bool allowPreleasePackages);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Static.NuGet.MultiSourceNuGetFetcher/<DownloadAsync>d__11")]
public Task`1<NuGetPackage> DownloadAsync(string packageName, string packageVersion, string packageSourceUrl, CancellationToken token);
    private void AssertInitialized();
    [CompilerGeneratedAttribute]
private Lazy`1<NuGetFetcher> <DownloadAsync>b__11_0(string url);
}
public class Raven.Server.Documents.Indexes.Static.NuGet.NuGetFetcher : object {
    private string _rootPath;
    private PackageSource _packageSource;
    private SourceRepository _sourceRepository;
    private SourceCacheContext _sourceCacheContext;
    private FrameworkReducer _frameworkReducer;
    private NuGetFramework _framework;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`2<string, string>, Lazy`1<Task`1<NuGetPackage>>> _pendingPackages;
    public NuGetFetcher(string packageSourceUrl, string rootPath);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Static.NuGet.NuGetFetcher/<ValidateConnectivity>d__8")]
public Task ValidateConnectivity();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Static.NuGet.NuGetFetcher/<DownloadAsync>d__9")]
public Task`1<NuGetPackage> DownloadAsync(string package, string version, bool allowPreleasePackages, CancellationToken token);
    private static NuGetFramework GetCurrentNuGetFramework();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Static.NuGet.NuGetFetcher/<DownloadPackageAsync>d__11")]
private Task`1<NuGetPackage> DownloadPackageAsync(PackageIdentity identity, bool allowPreleasePackages, CancellationToken token);
    private static string GetRuntimeNativeDirectory();
    [CompilerGeneratedAttribute]
private void <ValidateConnectivity>g__Throw|8_0(Exception e);
}
public static class Raven.Server.Documents.Indexes.Static.NuGet.NuGetNativeLibraryResolver : object {
    private static object _locker;
    private static HashSet`1<string> _registeredPaths;
    private static Dictionary`2<Assembly, Reference`1<bool>> _registeredAssemblies;
    private static Dictionary`2<string, string> _nativeLibraries;
    private static NuGetNativeLibraryResolver();
    public static void RegisterPath(string path);
    public static void RegisterAssembly(Assembly assembly);
    public static void EnsureAssembliesRegisteredToNativeLibraries();
    private static IntPtr Resolver(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> dllImportSearchPath);
    private static bool IsNativeLibrary(string libraryPath);
}
public class Raven.Server.Documents.Indexes.Static.NuGet.ProjectContext : object {
    private static Logger Logger;
    [CompilerGeneratedAttribute]
private PackageExtractionContext <PackageExtractionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private XDocument <OriginalPackagesConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetActionType <ActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <OperationId>k__BackingField;
    public PackageExtractionContext PackageExtractionContext { get; public set; }
    public ISourceControlManagerProvider SourceControlManagerProvider { get; }
    public ExecutionContext ExecutionContext { get; }
    public XDocument OriginalPackagesConfig { get; public set; }
    public NuGetActionType ActionType { get; public set; }
    public Guid OperationId { get; public set; }
    private static ProjectContext();
    [CompilerGeneratedAttribute]
public sealed virtual PackageExtractionContext get_PackageExtractionContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackageExtractionContext(PackageExtractionContext value);
    public sealed virtual ISourceControlManagerProvider get_SourceControlManagerProvider();
    public sealed virtual ExecutionContext get_ExecutionContext();
    [CompilerGeneratedAttribute]
public sealed virtual XDocument get_OriginalPackagesConfig();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OriginalPackagesConfig(XDocument value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetActionType get_ActionType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ActionType(NuGetActionType value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_OperationId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OperationId(Guid value);
    public sealed virtual void Log(MessageLevel level, string message, Object[] args);
    public sealed virtual void Log(ILogMessage message);
    public sealed virtual void ReportError(string message);
    public sealed virtual void ReportError(ILogMessage message);
    public sealed virtual FileConflictAction ResolveFileConflict(string message);
}
public class Raven.Server.Documents.Indexes.Static.RecursiveFunction : object {
    private static DynamicArray Empty;
    private List`1<object> _result;
    private object _item;
    private Func`2<object, object> _func;
    private HashSet`1<object> _results;
    private Queue`1<object> _queue;
    public RecursiveFunction(object item, Func`2<object, object> func);
    private static RecursiveFunction();
    public IEnumerable`1<object> Execute();
    private void AddItem(object current);
    private static object NullIfEmptyEnumerable(object item);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Static.RecursiveFunction/<Yield>d__10")]
private static IEnumerable`1<object> Yield(IEnumerator`1<object> enumerator);
}
internal class Raven.Server.Documents.Indexes.Static.Roslyn.FieldNamesValidator : object {
    private CaptureSelectNewFieldNamesVisitor _visitor;
    private HashSet`1<CompiledIndexField> _baseFields;
    private string _baseFunction;
    public CompiledIndexField[] Fields { get; }
    public CompiledIndexField[] ExtractedFields { get; }
    public bool Validate(string indexingFunction, ExpressionSyntax expression, bool throwOnError);
    public CompiledIndexField[] get_Fields();
    public CompiledIndexField[] get_ExtractedFields();
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.MapFunctionProcessor : CSharpSyntaxRewriter {
    public CSharpSyntaxRewriter CollectionRetriever;
    private ReferencedCollectionsRetriever _refCollectionsRetriever;
    private CompareExchangeReferenceDetectorRewriter _compareExchangeReferenceDetector;
    private SelectManyRewriter _selectManyRewriter;
    public HashSet`1<string> ReferencedCollections { get; }
    public bool HasLoadCompareExchangeValue { get; }
    public MapFunctionProcessor(CSharpSyntaxRewriter collectionRetriever, SelectManyRewriter selectManyRewriter);
    public HashSet`1<string> get_ReferencedCollections();
    public bool get_HasLoadCompareExchangeValue();
    public virtual SyntaxNode Visit(SyntaxNode node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.CaptureDictionaryFieldsNamesVisitor : CSharpSyntaxRewriter {
    public static string SupportedGenericDictionaryType;
    public HashSet`1<CompiledIndexField> Fields;
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual SyntaxNode VisitQueryBody(QueryBodySyntax node);
    private void CaptureFieldNames(SyntaxNode node);
    public virtual SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public static bool IsDictionaryObjectCreationExpression(ObjectCreationExpressionSyntax node);
}
internal class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.CaptureSelectNewFieldNamesVisitor : CSharpSyntaxRewriter {
    private Nullable`1<bool> _isQueryExpression;
    public HashSet`1<CompiledIndexField> Fields;
    public static HashSet`1<string> KnownMethodsToInspect;
    private static CaptureSelectNewFieldNamesVisitor();
    public virtual SyntaxNode Visit(SyntaxNode node);
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual SyntaxNode VisitQueryBody(QueryBodySyntax node);
    private void CaptureFieldNames(SyntaxNode node, Action`1<CaptureDictionaryFieldsNamesVisitor> visitDictionaryNodeExpression);
    public virtual SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    private static void ThrowIndexingFunctionMustReturnAnonymousObjectOrDictionary(bool maybeNew);
    public void Reset();
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.CoalesceRewriter : CSharpSyntaxRewriter {
    public static CoalesceRewriter Instance;
    private static CoalesceRewriter();
    public virtual SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.CollectionNameRetriever : CSharpSyntaxRewriter {
    [CompilerGeneratedAttribute]
private String[] <CollectionNames>k__BackingField;
    public String[] CollectionNames { get; protected set; }
    public static CollectionNameRetriever QuerySyntax { get; }
    public static CollectionNameRetriever MethodSyntax { get; }
    [CompilerGeneratedAttribute]
public String[] get_CollectionNames();
    [CompilerGeneratedAttribute]
protected void set_CollectionNames(String[] value);
    public static CollectionNameRetriever get_QuerySyntax();
    public static CollectionNameRetriever get_MethodSyntax();
    public static InvocationExpressionSyntax UnwrapNode(InvocationExpressionSyntax node);
}
public abstract class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.CollectionNameRetrieverBase : CSharpSyntaxRewriter {
    [CompilerGeneratedAttribute]
private HashSet`1<Collection> <Collections>k__BackingField;
    public HashSet`1<Collection> Collections { get; protected set; }
    [CompilerGeneratedAttribute]
public HashSet`1<Collection> get_Collections();
    [CompilerGeneratedAttribute]
protected void set_Collections(HashSet`1<Collection> value);
    private static string ExtractName(ElementAccessExpressionSyntax indexer, string name);
    private static string ExtractName(MemberAccessExpressionSyntax member);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.CompareExchangeReferenceDetectorRewriter : CSharpSyntaxRewriter {
    [CompilerGeneratedAttribute]
private bool <HasLoadCompareExchangeValue>k__BackingField;
    public bool HasLoadCompareExchangeValue { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_HasLoadCompareExchangeValue();
    [CompilerGeneratedAttribute]
private void set_HasLoadCompareExchangeValue(bool value);
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.ConditionalAccessExpressionRewriter : CSharpSyntaxRewriter {
    public static ConditionalAccessExpressionRewriter Instance;
    private static ConditionalAccessExpressionRewriter();
    public virtual SyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.Counters.CountersCollectionNameRetriever : CollectionNameRetrieverBase {
    public static CollectionNameRetrieverBase QuerySyntax { get; }
    public static CollectionNameRetrieverBase MethodSyntax { get; }
    public static CollectionNameRetrieverBase get_QuerySyntax();
    public static CollectionNameRetrieverBase get_MethodSyntax();
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.DynamicExtensionMethodsRewriter : CSharpSyntaxRewriter {
    private static String[] MethodNames;
    public static DynamicExtensionMethodsRewriter Instance;
    private static DynamicExtensionMethodsRewriter();
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.DynamicInvocationExpressionsRewriter : CSharpSyntaxRewriter {
    public static DynamicInvocationExpressionsRewriter Instance;
    private static DynamicInvocationExpressionsRewriter();
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    private SyntaxNode HandleEnumerableCount(InvocationExpressionSyntax node);
    private SyntaxNode HandleEnumerableDistinct(InvocationExpressionSyntax node);
    private SyntaxNode HandleEnumerableRange(InvocationExpressionSyntax node);
    private static string GetParentMethod(InvocationExpressionSyntax currentInvocation);
    [CompilerGeneratedAttribute]
internal static ArgumentSyntax <GetParentMethod>g__GetArgument|6_0(InvocationExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.DynamicLambdaExpressionsRewriter : CSharpSyntaxRewriter {
    public static DynamicLambdaExpressionsRewriter Instance;
    private static DynamicLambdaExpressionsRewriter();
    public virtual SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    private SyntaxNode HandleMethod(LambdaExpressionSyntax node, InvocationExpressionSyntax invocation, string method);
    private static SyntaxNode ModifyLambdaForMinMax(LambdaExpressionSyntax node);
    private static SyntaxNode ModifyLambdaForBools(LambdaExpressionSyntax node);
    private static string GetInvocationParent(SyntaxNode node);
    private static SyntaxNode ModifyLambdaForPredicates(LambdaExpressionSyntax node);
    private SyntaxNode ModifyLambdaForSelectMany(LambdaExpressionSyntax node, InvocationExpressionSyntax currentInvocation);
    private static bool IsSelectManyCalledOnValueCollection(InvocationExpressionSyntax invocation);
    private static bool IsDictionaryReturned(LambdaExpressionSyntax node);
    private static SyntaxNode ModifyLambdaForDynamicEnumerable(LambdaExpressionSyntax node);
    private static SyntaxNode ModifyLambdaForSelect(LambdaExpressionSyntax node, InvocationExpressionSyntax currentInvocation);
    private static string GetParentMethod(InvocationExpressionSyntax currentInvocation);
    private static SyntaxNode ModifyLambdaForNumerics(LambdaExpressionSyntax node);
    private static SyntaxNode ModifyLambdaForZip(LambdaExpressionSyntax node);
    private static SyntaxNode ModifyLambdaForAggregate(LambdaExpressionSyntax node);
    private static SyntaxNode ModifyLambdaForTakeSkipWhile(LambdaExpressionSyntax node);
    private static CastExpressionSyntax GetAsCastExpression(CSharpSyntaxNode expressionBody);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.InitializerExpressionRewriter : CSharpSyntaxRewriter {
    public static InitializerExpressionRewriter Instance;
    private static InitializerExpressionRewriter();
    public virtual SyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node);
    private static ExpressionSyntax CastExpression(TypeSyntax typeToCast, int rankCount, ExpressionSyntax expression);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.IsRewriter : CSharpSyntaxRewriter {
    public static IsRewriter Instance;
    private static IsRewriter();
    public virtual SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node);
    private static bool ShouldApply(BinaryExpressionSyntax node);
    private static string GetIdentifier(BinaryExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.MethodDetectorRewriter : CSharpSyntaxRewriter {
    public IndexMethods Methods;
    [CompilerGeneratedAttribute]
private long <IndexVersion>k__BackingField;
    private long IndexVersion { get; private set; }
    public MethodDetectorRewriter(long indexVersion);
    [CompilerGeneratedAttribute]
private long get_IndexVersion();
    [CompilerGeneratedAttribute]
private void set_IndexVersion(long value);
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual SyntaxNode VisitGroupClause(GroupClauseSyntax node);
    private void AssertLoadDocumentHasConstantCollectionName(InvocationExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.MethodDynamicParametersRewriter : CSharpSyntaxRewriter {
    private static string DynamicString;
    private static string SystemNamespacePrefix;
    private static string IEnumerableString;
    private static string DynamicArrayString;
    private static TypeSyntax DynamicArrayTypeSyntax;
    private static IdentifierNameSyntax DynamicIdentifier;
    private static IdentifierNameSyntax VarIdentifier;
    private static GenericNameSyntax IEnumerableDynamicNameSyntax;
    private INamedTypeSymbol IEnumerableSymbol;
    private SemanticModel _semanticModel;
    public SemanticModel SemanticModel { get; internal set; }
    private static MethodDynamicParametersRewriter();
    public SemanticModel get_SemanticModel();
    internal void set_SemanticModel(SemanticModel value);
    public virtual SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node);
    private static MethodDeclarationSyntax ModifyReturnStatements(MethodDeclarationSyntax method);
    private static StatementSyntax ModifySingleStatement(ReturnStatementSyntax returnStatement, StatementSyntax statement);
    private static ReturnStatementSyntax CreateNewReturnStatement(ReturnStatementSyntax returnStatement);
    private bool ShouldModifyReturnType(MethodDeclarationSyntax node, SyntaxNode& returnType);
    private bool ShouldModifyType(ITypeSymbol typeSymbol, SyntaxNode& newType);
    private ParameterListSyntax RewriteParametersToDynamicTypes(MethodDeclarationSyntax node, List`1& statements);
    private static LocalDeclarationStatementSyntax CreateDynamicArrayDeclarationStatement(SyntaxToken identifier);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.NoTrackingRewriter : CSharpSyntaxRewriter {
    public static NoTrackingRewriter Instance;
    private static NoTrackingRewriter();
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    public static bool TryRemoveNoTracking(string expression, String& result);
    [CompilerGeneratedAttribute]
internal static bool <TryRemoveNoTracking>g__TryStrip|3_0(string expression, string toStrip, String& result);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.NullRewriter : CSharpSyntaxRewriter {
    public static NullRewriter Instance;
    private static SyntaxNode Null;
    private static NullRewriter();
    public virtual SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node);
    private static bool ShouldApply(LiteralExpressionSyntax node);
}
internal class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.RavenLinqOptimizer : CSharpSyntaxRewriter {
    private FieldNamesValidator _validator;
    private int _recursiveCallCounter;
    public RavenLinqOptimizer(FieldNamesValidator validator);
    public IDisposable RecursiveCall();
    public virtual SyntaxNode VisitQueryExpression(QueryExpressionSyntax node);
    private void ThrowIndexRewritingException(QueryExpressionSyntax node, ForEachStatementSyntax stmt);
    private static bool TryRewriteBodyClause(QueryClauseSyntax clause, YieldStatementSyntax dummyYield, BlockSyntax& body);
    private static YieldStatementSyntax FindDummyYieldIn(SyntaxNode parent);
    internal static ExpressionSyntax MaybeParenthesizedExpression(ExpressionSyntax es);
    internal static ExpressionSyntax StripExpressionParenthesis(ExpressionSyntax expr);
    internal static SyntaxNode StripExpressionParentParenthesis(SyntaxNode expr);
    [CompilerGeneratedAttribute]
private void <RecursiveCall>b__3_0();
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.RavenLinqPrettifier : CSharpSyntaxRewriter {
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    private static CSharpSyntaxNode GetBodyAndRemoveCastingIfNeeded(SimpleLambdaExpressionSyntax sourceExp);
    private static ParenthesizedLambdaExpressionSyntax GetSelectorLambdaFromSelectManyExpression(InvocationExpressionSyntax node);
    private static SimpleLambdaExpressionSyntax GetSimpleLambdaExpressionSyntax(InvocationExpressionSyntax node);
    private static bool AllParentsAreMethods(InvocationExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.RecurseRewriter : CSharpSyntaxRewriter {
    public static RecurseRewriter Instance;
    private static RecurseRewriter();
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
}
public abstract class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.ReduceIndex.GroupByFieldsRetriever : CSharpSyntaxRewriter {
    [CompilerGeneratedAttribute]
private CompiledIndexField[] <GroupByFields>k__BackingField;
    public CompiledIndexField[] GroupByFields { get; protected set; }
    public static GroupByFieldsRetriever QuerySyntax { get; }
    public static GroupByFieldsRetriever MethodSyntax { get; }
    [CompilerGeneratedAttribute]
public CompiledIndexField[] get_GroupByFields();
    [CompilerGeneratedAttribute]
protected void set_GroupByFields(CompiledIndexField[] value);
    public static GroupByFieldsRetriever get_QuerySyntax();
    public static GroupByFieldsRetriever get_MethodSyntax();
}
public abstract class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.ReduceIndex.MethodsInGroupByValidator : CSharpSyntaxWalker {
    protected static String[] ForbiddenMethods;
    protected Dictionary`2<string, string> SearchPatterns;
    public static MethodsInGroupByValidator MethodSyntaxValidator { get; }
    public static MethodsInGroupByValidator QuerySyntaxValidator { get; }
    private static MethodsInGroupByValidator();
    public static MethodsInGroupByValidator get_MethodSyntaxValidator();
    public static MethodsInGroupByValidator get_QuerySyntaxValidator();
    public void Start(ExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.ReduceIndex.MethodsInGroupByValidatorMethodSyntax : MethodsInGroupByValidator {
    private ParameterSyntax _root;
    public void SetSearchPatterns();
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.ReduceIndex.MethodsInGroupByValidatorQuerySyntax : MethodsInGroupByValidator {
    private SyntaxToken _root;
    public virtual void VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual void VisitFromClause(FromClauseSyntax node);
    public void SetSearchPatterns();
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.ReduceIndex.ReduceFunctionProcessor : CSharpSyntaxRewriter {
    private ResultsVariableNameRewriter _setResultsVariable;
    private GroupByFieldsRetriever _getGroupByFields;
    private SelectManyRewriter _selectManyRewriter;
    public CompiledIndexField[] GroupByFields { get; }
    public ReduceFunctionProcessor(ResultsVariableNameRewriter setResultsVariable, GroupByFieldsRetriever getGroupByFields, SelectManyRewriter selectManyRewriter);
    public CompiledIndexField[] get_GroupByFields();
    public virtual SyntaxNode Visit(SyntaxNode node);
}
public abstract class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.ReduceIndex.ResultsVariableNameRewriter : CSharpSyntaxRewriter {
    public static string ResultsVariable;
    protected bool _visited;
    public static ResultsVariableNameRewriter MethodSyntax { get; }
    public static ResultsVariableNameRewriter QuerySyntax { get; }
    public static ResultsVariableNameRewriter get_MethodSyntax();
    public static ResultsVariableNameRewriter get_QuerySyntax();
}
internal class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.ReferencedCollectionsRetriever : CSharpSyntaxRewriter {
    public HashSet`1<string> ReferencedCollections;
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
}
public static class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.RewritersHelper : object {
    public static HashSet`1<CompiledIndexField> ExtractFields(AnonymousObjectCreationExpressionSyntax anonymousObjectCreationExpressionSyntax, bool retrieveOriginal, bool nestFields);
    public static CompiledIndexField ExtractField(MemberAccessExpressionSyntax expression, bool nestFields);
    private static String[] ExtractPath(MemberAccessExpressionSyntax expression);
}
public abstract class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.SelectManyRewriter : CSharpSyntaxRewriter {
    public static SelectManyRewriter SelectMethodOnProperties;
    public static SelectManyRewriter MethodSyntax { get; }
    public static SelectManyRewriter QuerySyntax { get; }
    private static SelectManyRewriter();
    public static SelectManyRewriter get_MethodSyntax();
    public static SelectManyRewriter get_QuerySyntax();
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.SpatialFieldRewriter : CSharpSyntaxRewriter {
    public static SpatialFieldRewriter Instance;
    private static SpatialFieldRewriter();
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    private static AnonymousObjectMemberDeclaratorSyntax GetAnonymousObjectMemberDeclaratorSyntax(SyntaxNode node);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.StackDepthRetriever : CSharpSyntaxRewriter {
    private int _letCounter;
    private int _selectDepth;
    public int StackSize { get; }
    public int get_StackSize();
    public void Clear();
    public void VisitMethodQuery(string cSharpCode);
    public virtual SyntaxNode VisitLetClause(LetClauseSyntax queryLetClause);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.ThrowOnInvalidMethodCalls : CSharpSyntaxRewriter {
    private static List`1<ForbiddenMethod> ForbiddenMethods;
    private SyntaxNode _root;
    private static ThrowOnInvalidMethodCalls();
    public virtual SyntaxNode Visit(SyntaxNode node);
    public virtual SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual SyntaxNode VisitOrderByClause(OrderByClauseSyntax node);
    private static bool TryCheckForDictionary(SyntaxNode node);
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    private static void ThrowOrderByException(string text);
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.TimeSeries.TimeSeriesCollectionNameRetriever : CollectionNameRetrieverBase {
    public static CollectionNameRetrieverBase QuerySyntax { get; }
    public static CollectionNameRetrieverBase MethodSyntax { get; }
    public static CollectionNameRetrieverBase get_QuerySyntax();
    public static CollectionNameRetrieverBase get_MethodSyntax();
}
public class Raven.Server.Documents.Indexes.Static.Roslyn.Rewriters.WhereRewriter : CSharpSyntaxRewriter {
    public static WhereRewriter Instance { get; }
    public static WhereRewriter get_Instance();
    public virtual SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual SyntaxNode VisitWhereClause(WhereClauseSyntax node);
    private static ExpressionSyntax HandleCondition(ExpressionSyntax expression);
    private static SyntaxNode HandleMethod(LambdaExpressionSyntax node, InvocationExpressionSyntax invocation, string method);
    private static SyntaxNode ModifyLambdaForBools(LambdaExpressionSyntax node);
}
[ExtensionAttribute]
public static class Raven.Server.Documents.Indexes.Static.Roslyn.RoslynHelper : object {
    public static SyntaxList`1<UsingDirectiveSyntax> CreateUsings(UsingDirectiveSyntax[] usings);
    public static ClassDeclarationSyntax PublicClass(string className);
    public static ConstructorDeclarationSyntax PublicCtor(string className);
    public static NamespaceDeclarationSyntax CreateNamespace(string namespace);
    public static MemberAccessExpressionSyntax This(string methodName);
    [ExtensionAttribute]
public static AssignmentExpressionSyntax Assign(MemberAccessExpressionSyntax member, ExpressionSyntax value);
    [ExtensionAttribute]
public static AssignmentExpressionSyntax Assign(MemberAccessExpressionSyntax member, string value);
    [ExtensionAttribute]
public static ClassDeclarationSyntax WithBaseClass(ClassDeclarationSyntax class);
    [ExtensionAttribute]
public static ExpressionStatementSyntax AsExpressionStatement(ExpressionSyntax syntax);
    [ExtensionAttribute]
public static InvocationExpressionSyntax Invoke(MemberAccessExpressionSyntax member, ExpressionSyntax[] arguments);
}
public class Raven.Server.Documents.Indexes.Static.Sharding.OrchestratorIndexingScope : CurrentIndexingScope {
    public bool SupportsDynamicFieldsCreation { get; }
    public bool SupportsSpatialFieldsCreation { get; }
    public OrchestratorIndexingScope(TransactionOperationContext context, UnmanagedBuffersPoolWithLowMemoryHandling unmanagedBuffersPool);
    public virtual bool get_SupportsDynamicFieldsCreation();
    public virtual bool get_SupportsSpatialFieldsCreation();
}
internal class Raven.Server.Documents.Indexes.Static.Spatial.BBoxStrategyThatSupportsAllShapes : BBoxStrategy {
    public BBoxStrategyThatSupportsAllShapes(SpatialContext ctx, string fieldNamePrefix);
    private static IRectangle GetRectangle(IShape shape);
    public virtual AbstractField[] CreateIndexableFields(IShape shape);
    public virtual ConstantScoreQuery MakeQuery(SpatialArgs args);
    public virtual Filter MakeFilter(SpatialArgs args);
}
internal class Raven.Server.Documents.Indexes.Static.Spatial.RecursivePrefixTreeStrategyThatSupportsWithin : PrefixTreeStrategy {
    private int _prefixGridScanLevel;
    public RecursivePrefixTreeStrategyThatSupportsWithin(SpatialPrefixTree grid, string fieldName);
    public virtual Filter MakeFilter(SpatialArgs args);
    public virtual string ToString();
}
public class Raven.Server.Documents.Indexes.Static.Spatial.ShapeStringConverter : object {
    private SpatialOptions _options;
    private static Regex RegexBox;
    private static Regex RegexGeoUriCoord;
    private static Regex RegexGeoUriUncert;
    private static double KmToMiles;
    public ShapeStringConverter(SpatialOptions options);
    private static ShapeStringConverter();
    public string ConvertToWKT(string shape);
    private static bool TryParseBox(string value, String& shape);
    private bool TryParseGeoUri(string uriString, String& shape);
    private string MakePoint(double x, double y);
    private string MakeCircle(double x, double y, double radius);
}
public class Raven.Server.Documents.Indexes.Static.Spatial.ShapeStringReadWriter : object {
    private static WktSanitizer WktSanitizer;
    private SpatialOptions _options;
    private NtsSpatialContext _context;
    private ShapeStringConverter _shapeStringConverter;
    private static double DegreesToRadians;
    private static double RadiansToDegrees;
    private static Regex CircleShape;
    public ShapeStringReadWriter(SpatialOptions options, NtsSpatialContext context);
    private static ShapeStringReadWriter();
    public IShape ReadShape(string shape, Nullable`1<SpatialUnits> unitOverride);
    public string WriteShape(IShape shape);
    public static double TranslateCircleRadius(double radius, SpatialUnits units);
    public static double TranslateDegreesToRadius(double degrees, SpatialUnits units, SpatialOptions options);
    private static string TranslateCircleRadius(string shapeWkt, SpatialUnits units);
}
public class Raven.Server.Documents.Indexes.Static.Spatial.SpatialDistanceFieldComparatorSource : FieldComparatorSource {
    private IPoint _center;
    private IndexQueryServerSide _query;
    private double _roundFactor;
    private SpatialField _spatialField;
    public SpatialDistanceFieldComparatorSource(SpatialField spatialField, IPoint center, IndexQueryServerSide query, double roundFactor);
    public virtual FieldComparator NewComparator(string fieldname, int numHits, int sortPos, bool reversed);
}
public class Raven.Server.Documents.Indexes.Static.Spatial.SpatialField : object {
    private static NtsSpatialContext GeoContext;
    public SpatialStrategy Strategy;
    private SpatialOptions _options;
    private NtsSpatialContext _ntsContext;
    private ShapeStringReadWriter _shapeStringReadWriter;
    public SpatialUnits Units { get; }
    private static SpatialField();
    public SpatialField(string fieldName, SpatialOptions options);
    public SpatialUnits get_Units();
    private static NtsSpatialContext CreateNtsContext(SpatialOptions options);
    public NtsSpatialContext GetContext();
    private static SpatialStrategy CreateStrategy(string fieldName, SpatialOptions opt, NtsSpatialContext context);
    public AbstractField[] LuceneCreateIndexableFields(object value);
    public CoraxSpatialPointEntry[] CoraxCreateIndexableFields(object value);
    private bool TryReadShape(object value, IShape& shape);
    public IShape ReadShape(string shapeWkt, Nullable`1<SpatialUnits> unitOverride);
    private string WriteShape(IShape shape);
    public IShape ReadCircle(double radius, double latitude, double longitude, Nullable`1<SpatialUnits> unitOverride);
    public IShape ReadPoint(double latitude, double longitude);
}
public abstract class Raven.Server.Documents.Indexes.Static.StaticCountersAndTimeSeriesIndexBase : AbstractStaticIndexBase {
    public void AddMap(string collection, string name, IndexingFunc map);
}
public abstract class Raven.Server.Documents.Indexes.Static.StaticCountersIndexBase : StaticCountersAndTimeSeriesIndexBase {
}
public abstract class Raven.Server.Documents.Indexes.Static.StaticIndexBase : AbstractStaticIndexBase {
    public void AddMap(string collection, IndexingFunc map);
    public object LoadAttachments(object doc);
    public object LoadAttachment(object doc, object attachmentName);
    public object Id(object doc);
    public object MetadataFor(object doc);
    public object AsJson(object doc);
    public object AttachmentsFor(object doc);
    public object CounterNamesFor(object doc);
    public object TimeSeriesNamesFor(object doc);
    [DoesNotReturnAttribute]
private static void ThrowInvalidDocType(object doc, string funcName);
}
public class Raven.Server.Documents.Indexes.Static.StaticIndexItemEnumerator`1 : object {
    private IndexingStatsScope _documentReadStats;
    private IEnumerator`1<IndexItem> _itemsEnumerator;
    private Dictionary`2<string, IEnumerable> _resultsOfCurrentDocument;
    private Dictionary`2<string, MultipleIndexingFunctionsEnumerator`1<TType, TType>> _multipleIndexingFunctionsEnumerator;
    private bool _singleKey;
    private string _firstKey;
    private bool _allItems;
    private string _allItemsKey;
    private IIndexItemFilterBehavior _filter;
    [CompilerGeneratedAttribute]
private IndexItem <Current>k__BackingField;
    public IndexItem Current { get; private set; }
    public StaticIndexItemEnumerator`1(IEnumerable`1<IndexItem> items, IIndexItemFilterBehavior filter, Dictionary`2<string, List`1<IndexingFunc>> funcs, string collection, IndexingStatsScope stats, IndexType type);
    public sealed virtual bool MoveNext(DocumentsOperationContext ctx, IEnumerable& resultsOfCurrentDocument, Nullable`1& etag);
    public sealed virtual void OnError();
    [CompilerGeneratedAttribute]
public sealed virtual IndexItem get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(IndexItem value);
    public sealed virtual void Dispose();
}
public abstract class Raven.Server.Documents.Indexes.Static.StaticTimeSeriesIndexBase : StaticCountersAndTimeSeriesIndexBase {
}
public class Raven.Server.Documents.Indexes.Static.TimeCountingEnumerable : object {
    private IEnumerable _enumerable;
    private IndexingStatsScope _stats;
    public TimeCountingEnumerable(IEnumerable enumerable, IndexingStatsScope stats);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator GetEnumerator();
}
public class Raven.Server.Documents.Indexes.Static.TimeSeries.DynamicTimeSeriesSegment : AbstractDynamicObject {
    internal TimeSeriesSegmentEntry _segmentEntry;
    private DynamicArray _entries;
    private DynamicArray _min;
    private DynamicArray _max;
    private DynamicArray _sum;
    private Nullable`1<TimeSeriesSegmentSummary> _summary;
    private string _name;
    public string Name { get; }
    public DateTime Start { get; }
    public DateTime End { get; }
    public DynamicArray Min { get; }
    public DynamicArray Max { get; }
    public DynamicArray Sum { get; }
    public int Count { get; }
    public DynamicArray Entries { get; }
    private TimeSeriesSegmentSummary Summary { get; }
    public virtual object GetId();
    public virtual bool Set(object item);
    public string get_Name();
    public DateTime get_Start();
    public DateTime get_End();
    public DynamicArray get_Min();
    public DynamicArray get_Max();
    public DynamicArray get_Sum();
    public int get_Count();
    public DynamicArray get_Entries();
    protected virtual bool TryGetByName(string name, Object& result);
    private TimeSeriesSegmentSummary get_Summary();
    [ConditionalAttribute("DEBUG")]
private void AssertSegment();
}
public class Raven.Server.Documents.Indexes.Static.TimeSeries.MapReduceTimeSeriesIndex : MapReduceIndex {
    private HashSet`1<string> _referencedCollections;
    internal AbstractStaticIndexBase _compiled;
    public MapReduceTimeSeriesIndex(MapReduceIndexDefinition definition, AbstractStaticIndexBase compiled);
    protected virtual IIndexingWork[] CreateIndexWorkExecutors();
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual IIndexedItemEnumerator GetMapEnumerator(IEnumerable`1<IndexItem> items, string collection, TransactionOperationContext indexContext, IndexingStatsScope stats, IndexType type);
    public virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType tombstoneType);
    public virtual int HandleMap(IndexItem indexItem, IEnumerable mapResults, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public virtual long GetLastItemEtagInCollection(QueryOperationContext queryContext, string collection);
    protected virtual IndexItem GetItemByEtag(QueryOperationContext queryContext, long etag);
    protected virtual void SubscribeToChanges(DocumentDatabase documentDatabase);
    protected virtual void UnsubscribeFromChanges(DocumentDatabase documentDatabase);
    protected virtual void HandleDocumentChange(DocumentChange change);
    private void HandleTimeSeriesChange(TimeSeriesChange change);
    internal virtual void UpdateProgressStats(QueryOperationContext queryContext, CollectionStats progressStats, string collectionName, Stopwatch overallDuration);
}
public class Raven.Server.Documents.Indexes.Static.TimeSeries.MapTimeSeriesIndex : MapIndexBase`2<MapIndexDefinition, IndexField> {
    private HashSet`1<string> _referencedCollections;
    internal AbstractStaticIndexBase _compiled;
    private Nullable`1<bool> _isSideBySide;
    private HandleTimeSeriesReferences _handleReferences;
    private HandleCompareExchangeTimeSeriesReferences _handleCompareExchangeReferences;
    public bool HasBoostedFields { get; }
    public bool IsMultiMap { get; }
    private MapTimeSeriesIndex(MapIndexDefinition definition, AbstractStaticIndexBase compiled);
    public virtual bool get_HasBoostedFields();
    public virtual bool get_IsMultiMap();
    public virtual IQueryResultRetriever GetQueryResultRetriever(IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsOperationContext documentsContext, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
    protected virtual void SubscribeToChanges(DocumentDatabase documentDatabase);
    protected virtual void UnsubscribeFromChanges(DocumentDatabase documentDatabase);
    protected virtual void HandleDocumentChange(DocumentChange change);
    protected virtual IIndexingWork[] CreateIndexWorkExecutors();
    public virtual InMemoryReferencesInfo GetInMemoryReferencesState(string collection, bool isCompareExchange);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    protected virtual IndexItem GetItemByEtag(QueryOperationContext queryContext, long etag);
    protected virtual bool ShouldReplace();
    public virtual void ResetIsSideBySideAfterReplacement();
    internal virtual bool IsStale(QueryOperationContext queryContext, TransactionOperationContext indexContext, Nullable`1<long> cutoff, Nullable`1<long> referenceCutoff, Nullable`1<long> compareExchangeReferenceCutoff, List`1<string> stalenessReasons);
    public virtual Dictionary`2<string, HashSet`1<CollectionName>> GetReferencedCollections();
    public virtual bool WorksOnAnyCollection(HashSet`1<string> collections);
    protected virtual long CalculateIndexEtag(QueryOperationContext queryContext, TransactionOperationContext indexContext, QueryMetadata query, bool isStale);
    protected virtual IndexingState GetIndexingStateInternal(QueryOperationContext queryContext, TransactionOperationContext indexContext);
    public virtual long GetLastItemEtagInCollection(QueryOperationContext queryContext, string collection);
    public virtual ValueTuple`2<ICollection`1<string>, ICollection`1<string>> GetEntriesFields();
    public virtual IIndexedItemEnumerator GetMapEnumerator(IEnumerable`1<IndexItem> items, string collection, TransactionOperationContext indexContext, IndexingStatsScope stats, IndexType type);
    public virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType tombstoneType);
    public static Index CreateNew(IndexDefinition definition, DocumentDatabase documentDatabase, SingleIndexConfiguration forcedConfiguration);
    public static Index Open(StorageEnvironment environment, DocumentDatabase documentDatabase);
    private static MapTimeSeriesIndex CreateIndexInstance(IndexDefinition definition, RavenConfiguration configuration, long indexVersion);
    public static void Update(Index index, IndexDefinition definition, DocumentDatabase documentDatabase);
    private void HandleTimeSeriesChange(TimeSeriesChange change);
    internal virtual void UpdateProgressStats(QueryOperationContext queryContext, CollectionStats progressStats, string collectionName, Stopwatch overallDuration);
}
public class Raven.Server.Documents.Indexes.Static.TimeSeries.TimeSeriesJavaScriptIndex : AbstractCountersAndTimeSeriesJavaScriptIndex {
    private static string MapPrefix;
    public TimeSeriesJavaScriptIndex(IndexDefinition definition, RavenConfiguration configuration, long indexVersion);
}
public class Raven.Server.Documents.Indexes.Static.TimeSeries.TimeSeriesSegmentObjectInstance : ObjectInstance {
    private DynamicTimeSeriesSegment _segment;
    private Dictionary`2<string, PropertyDescriptor> _properties;
    public TimeSeriesSegmentObjectInstance(Engine engine, DynamicTimeSeriesSegment segment);
    public virtual bool Delete(JsValue property);
    public virtual PropertyDescriptor GetOwnProperty(JsValue property);
    private PropertyDescriptor GetPropertyValue(string property);
    public virtual bool Set(JsValue property, JsValue value, JsValue receiver);
    public virtual IEnumerable`1<KeyValuePair`2<JsValue, PropertyDescriptor>> GetOwnProperties();
    public virtual List`1<JsValue> GetOwnPropertyKeys(Types types);
}
public static class Raven.Server.Documents.Indexes.StaticIndexHelper : object {
    public static bool IsStaleDueToReferences(MapIndex index, QueryOperationContext queryContext, TransactionOperationContext indexContext, Nullable`1<long> referenceCutoff, Nullable`1<long> compareExchangeReferenceCutoff, List`1<string> stalenessReasons);
    public static bool IsStaleDueToReferences(MapCountersIndex index, QueryOperationContext queryContext, TransactionOperationContext indexContext, Nullable`1<long> referenceCutoff, Nullable`1<long> compareExchangeReferenceCutoff, List`1<string> stalenessReasons);
    public static bool IsStaleDueToReferences(MapTimeSeriesIndex index, QueryOperationContext queryContext, TransactionOperationContext indexContext, Nullable`1<long> referenceCutoff, Nullable`1<long> compareExchangeReferenceCutoff, List`1<string> stalenessReasons);
    public static bool IsStaleDueToReferences(MapReduceIndex index, QueryOperationContext queryContext, TransactionOperationContext indexContext, Nullable`1<long> referenceCutoff, Nullable`1<long> compareExchangeReferenceCutoff, List`1<string> stalenessReasons);
    private static bool IsStaleDueToReferences(Index index, AbstractStaticIndexBase compiled, QueryOperationContext queryContext, TransactionOperationContext indexContext, Nullable`1<long> referenceCutoff, Nullable`1<long> compareExchangeReferenceCutoff, List`1<string> stalenessReasons);
    public static long CalculateIndexEtag(Index index, AbstractStaticIndexBase compiled, int length, Byte* indexEtagBytes, Byte* writePos, QueryOperationContext queryContext, TransactionOperationContext indexContext);
    public static Dictionary`2<string, long> GetLastProcessedDocumentTombstonesPerCollection(Index index, HashSet`1<string> referencedCollections, IEnumerable`1<string> collections, Dictionary`2<string, HashSet`1<CollectionName>> compiledReferencedCollections, IndexStorage indexStorage);
    public static ValueTuple`2<Nullable`1<long>, Nullable`1<long>> GetLastProcessedCompareExchangeReferenceEtags(Index index, AbstractStaticIndexBase compiled, TransactionOperationContext indexContext);
    internal static Dictionary`2<string, long> GetLastProcessedEtagsPerCollection(Index index, HashSet`1<string> collections, IndexStorage indexStorage);
    public static bool ShouldReplace(Index index, Nullable`1& isSideBySide);
    public static void HandleDeleteBySourceDocumentId(MapReduceIndex index, HandleReferences handleReferences, HandleCompareExchangeReferences handleCompareExchangeReferences, Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public static void HandleDeleteBySourceDocument(HandleReferences handleReferences, HandleCompareExchangeReferences handleCompareExchangeReferences, Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    public static void HandleReferencesDelete(HandleReferences handleReferences, HandleCompareExchangeReferences handleCompareExchangeReferences, Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    private static void HandleDeleteBySourceDocument(Tombstone tombstone, Lazy`1<IndexWriteOperationBase> writer, IndexingStatsScope stats);
    [CompilerGeneratedAttribute]
internal static InternalScope<ByteStringMemoryCache> <HandleDeleteBySourceDocumentId>g__ToPrefixKey|10_0(LazyStringValue key, TransactionOperationContext context, Slice& prefixKey);
}
public class Raven.Server.Documents.Indexes.StaticIndexInformationHolder : IndexInformationHolder {
    public AbstractStaticIndexBase Compiled;
    public StaticIndexInformationHolder(IndexDefinitionBaseServerSide definition, IndexingConfiguration configuration, AbstractStaticIndexBase staticIndex);
    public StaticIndexInformationHolder(Index index);
}
public class Raven.Server.Documents.Indexes.Test.EmptyItemEnumerator : object {
    public IndexItem Current { get; }
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext(DocumentsOperationContext ctx, IEnumerable& resultsOfCurrentDocument, Nullable`1& etag);
    public sealed virtual void OnError();
    public sealed virtual IndexItem get_Current();
}
public class Raven.Server.Documents.Indexes.Test.TestIndexConfiguration : SingleIndexConfiguration {
    public bool RunInMemory { get; }
    public TestIndexConfiguration(IndexConfiguration clientConfiguration, RavenConfiguration databaseConfiguration);
    public virtual bool get_RunInMemory();
}
public class Raven.Server.Documents.Indexes.Test.TestIndexParameters : object {
    [CompilerGeneratedAttribute]
private IndexDefinition <IndexDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private object <QueryParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxDocumentsToProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <WaitForNonStaleResultsTimeoutInSec>k__BackingField;
    public IndexDefinition IndexDefinition { get; public set; }
    public string Query { get; public set; }
    public object QueryParameters { get; public set; }
    public Nullable`1<int> MaxDocumentsToProcess { get; public set; }
    public Nullable`1<int> WaitForNonStaleResultsTimeoutInSec { get; public set; }
    [CompilerGeneratedAttribute]
public IndexDefinition get_IndexDefinition();
    [CompilerGeneratedAttribute]
public void set_IndexDefinition(IndexDefinition value);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public object get_QueryParameters();
    [CompilerGeneratedAttribute]
public void set_QueryParameters(object value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxDocumentsToProcess();
    [CompilerGeneratedAttribute]
public void set_MaxDocumentsToProcess(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_WaitForNonStaleResultsTimeoutInSec();
    [CompilerGeneratedAttribute]
public void set_WaitForNonStaleResultsTimeoutInSec(Nullable`1<int> value);
}
public class Raven.Server.Documents.Indexes.Test.TestIndexResult : object {
    public List`1<BlittableJsonReaderObject> IndexEntries;
    public List`1<Document> QueryResults;
    public List`1<BlittableJsonReaderObject> MapResults;
    public List`1<BlittableJsonReaderObject> ReduceResults;
    public bool HasDynamicFields;
    public bool IsStale;
    public IndexType IndexType;
    [AsyncStateMachineAttribute("Raven.Server.Documents.Indexes.Test.TestIndexResult/<WriteTestIndexResultAsync>d__7")]
public Task WriteTestIndexResultAsync(Stream responseBodyStream, DocumentsOperationContext context);
}
public class Raven.Server.Documents.Indexes.Test.TestIndexRun : object {
    public List`1<BlittableJsonReaderObject> MapResults;
    public List`1<BlittableJsonReaderObject> ReduceResults;
    public ManualResetEventSlim BatchCompleted;
    private JsonOperationContext _context;
    private Dictionary`2<string, CollectionIterationStats> _collectionTracker;
    private int _docsToProcessPerCollection;
    private int _collectionsCount;
    public TestIndexRun(JsonOperationContext context, int docsToProcessPerCollection, int numberOfCollections);
    public TestIndexWriteOperation CreateIndexWriteOperationWrapper(IndexWriteOperationBase writer, Index index);
    public void HandleCanContinueBatch(CanContinueBatchResult result, string collection);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Test.TestIndexRun/<CreateEnumeratorWrapper>d__11")]
public IEnumerable`1<IndexItem> CreateEnumeratorWrapper(IEnumerable`1<IndexItem> enumerator, string collection);
    public void WaitForProcessingOfSampleDocs(TimeSpan waitForProcessingTimespan);
    public void AddMapResult(object result);
    public void AddMapResult(BlittableJsonReaderObject mapResult, string collection);
    public void AddReduceResult(object result);
    private BlittableJsonReaderObject ConvertToBlittable(object result);
}
public class Raven.Server.Documents.Indexes.Test.TestIndexWriteOperation : IndexWriteOperationBase {
    private IndexWriteOperationBase _inner;
    private TestIndexRun _testIndexRun;
    public TestIndexWriteOperation(IndexWriteOperationBase writerRetriever, Index index);
    public virtual void Dispose();
    public virtual void Commit(IndexingStatsScope stats);
    public virtual void Optimize(CancellationToken token);
    public virtual void UpdateDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public virtual void IndexDocument(LazyStringValue key, LazyStringValue sourceDocumentId, object document, IndexingStatsScope stats, JsonOperationContext indexContext);
    public virtual long EntriesCount();
    public virtual ValueTuple`2<long, long> GetAllocations();
    public virtual void Delete(LazyStringValue key, IndexingStatsScope stats);
    public virtual void DeleteBySourceDocument(LazyStringValue sourceDocumentId, IndexingStatsScope stats);
    public virtual void DeleteReduceResult(LazyStringValue reduceKeyHash, IndexingStatsScope stats);
}
public class Raven.Server.Documents.Indexes.TimeSeriesIndexItem : IndexItem {
    public TimeSeriesIndexItem(LazyStringValue id, LazyStringValue sourceDocumentId, long etag, DateTime lastModified, string timeSeriesName, int size, TimeSeriesSegmentEntry item);
    protected virtual string ToStringInternal();
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Indexes.Workers.CanContinueBatchParameters : ValueType {
    [CompilerGeneratedAttribute]
private IndexingStatsScope <Stats>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingWorkType <WorkType>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryOperationContext <QueryContext>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionOperationContext <IndexingContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<IndexWriteOperationBase> <IndexWriteOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <Sw>k__BackingField;
    public IndexingStatsScope Stats { get; }
    public IndexingWorkType WorkType { get; }
    public QueryOperationContext QueryContext { get; }
    public TransactionOperationContext IndexingContext { get; }
    public Lazy`1<IndexWriteOperationBase> IndexWriteOperation { get; }
    public long CurrentEtag { get; }
    public long MaxEtag { get; }
    public long Count { get; }
    public Stopwatch Sw { get; }
    public CanContinueBatchParameters(IndexingStatsScope stats, IndexingWorkType workType, QueryOperationContext queryContext, TransactionOperationContext indexingContext, Lazy`1<IndexWriteOperationBase> indexWriteOperation, long currentEtag, long maxEtag, long count, Stopwatch sw);
    [CompilerGeneratedAttribute]
public IndexingStatsScope get_Stats();
    [CompilerGeneratedAttribute]
public IndexingWorkType get_WorkType();
    [CompilerGeneratedAttribute]
public QueryOperationContext get_QueryContext();
    [CompilerGeneratedAttribute]
public TransactionOperationContext get_IndexingContext();
    [CompilerGeneratedAttribute]
public Lazy`1<IndexWriteOperationBase> get_IndexWriteOperation();
    [CompilerGeneratedAttribute]
public long get_CurrentEtag();
    [CompilerGeneratedAttribute]
public long get_MaxEtag();
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public Stopwatch get_Sw();
}
public class Raven.Server.Documents.Indexes.Workers.CleanupDocuments : object {
    private Logger _logger;
    private Index _index;
    private IndexingConfiguration _configuration;
    private DocumentsStorage _documentsStorage;
    private IndexStorage _indexStorage;
    private MapReduceIndexingContext _mapReduceContext;
    public string Name { get; }
    public CleanupDocuments(Index index, DocumentsStorage documentsStorage, IndexStorage indexStorage, IndexingConfiguration configuration, MapReduceIndexingContext mapReduceContext);
    public sealed virtual string get_Name();
    public virtual ValueTuple`2<bool, CanContinueBatchResult> Execute(QueryOperationContext queryContext, TransactionOperationContext indexContext, Lazy`1<IndexWriteOperationBase> writeOperation, IndexingStatsScope stats, CancellationToken token);
}
public class Raven.Server.Documents.Indexes.Workers.Counters.HandleCompareExchangeCountersReferences : HandleCompareExchangeReferences {
    private HashSet`1<string> _collectionsWithCompareExchangeReferences;
    private CountersStorage _countersStorage;
    public HandleCompareExchangeCountersReferences(Index index, HashSet`1<string> collectionsWithCompareExchangeReferences, CountersStorage countersStorage, DocumentsStorage documentsStorage, IndexStorage indexStorage, IndexingConfiguration configuration);
    protected virtual IndexItem GetItem(DocumentsOperationContext databaseContext, Slice key);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    protected virtual IEnumerable`1<Reference> GetItemReferences(QueryOperationContext queryContext, CollectionName referencedCollection, long lastEtag, long pageSize);
    protected virtual IEnumerable`1<Reference> GetTombstoneReferences(QueryOperationContext queryContext, CollectionName referencedCollection, long lastEtag, long pageSize);
    protected virtual bool TryGetReferencedCollectionsFor(string collection, HashSet`1& referencedCollections);
    [CompilerGeneratedAttribute]
private Reference <GetItemReferences>b__5_0(ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject> x);
    [CompilerGeneratedAttribute]
private Reference <GetTombstoneReferences>b__6_0(ValueTuple`2<CompareExchangeKey, long> x);
}
public class Raven.Server.Documents.Indexes.Workers.Counters.HandleCountersReferences : HandleReferences {
    private CountersStorage _countersStorage;
    public HandleCountersReferences(Index index, Dictionary`2<string, HashSet`1<CollectionName>> referencedCollections, CountersStorage countersStorage, DocumentsStorage documentsStorage, IndexStorage indexStorage, IndexingConfiguration configuration);
    protected virtual IndexItem GetItem(DocumentsOperationContext databaseContext, Slice key);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
}
public class Raven.Server.Documents.Indexes.Workers.Counters.MapCounters : MapItems {
    private CountersStorage _countersStorage;
    public MapCounters(Index index, CountersStorage countersStorage, IndexStorage indexStorage, MapReduceIndexingContext mapReduceContext, IndexingConfiguration configuration);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Workers.Counters.MapCounters/<GetItemsEnumerator>d__2")]
protected virtual IEnumerable`1<IndexItem> GetItemsEnumerator(QueryOperationContext queryContext, string collection, long lastEtag, long pageSize);
    private IEnumerable`1<CounterGroupItemMetadata> GetCountersEnumerator(QueryOperationContext queryContext, string collection, long lastEtag, long pageSize);
}
public class Raven.Server.Documents.Indexes.Workers.HandleCompareExchangeReferences : HandleDocumentReferences {
    private HashSet`1<string> _collectionsWithCompareExchangeReferences;
    private static HashSet`1<CollectionName> _referencedCollections;
    protected bool ItemsAndReferencesAreUsingSameEtagPool { get; }
    public HandleCompareExchangeReferences(Index index, HashSet`1<string> collectionsWithCompareExchangeReferences, DocumentsStorage documentsStorage, IndexStorage indexStorage, IndexingConfiguration configuration);
    private static HandleCompareExchangeReferences();
    protected virtual bool get_ItemsAndReferencesAreUsingSameEtagPool();
    protected virtual IEnumerable`1<Reference> GetItemReferences(QueryOperationContext queryContext, CollectionName referencedCollection, long lastEtag, long pageSize);
    protected virtual IEnumerable`1<Reference> GetTombstoneReferences(QueryOperationContext queryContext, CollectionName referencedCollection, long lastEtag, long pageSize);
    protected virtual bool TryGetReferencedCollectionsFor(string collection, HashSet`1& referencedCollections);
    protected static bool TryGetReferencedCollectionsFor(HashSet`1<string> collectionsWithCompareExchangeReferences, string collection, HashSet`1& referencedCollections);
    [CompilerGeneratedAttribute]
private Reference <GetItemReferences>b__5_0(ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject> x);
    [CompilerGeneratedAttribute]
private Reference <GetTombstoneReferences>b__6_0(ValueTuple`2<CompareExchangeKey, long> x);
}
public class Raven.Server.Documents.Indexes.Workers.HandleDocumentReferences : HandleReferences {
    public HandleDocumentReferences(Index index, Dictionary`2<string, HashSet`1<CollectionName>> referencedCollections, DocumentsStorage documentsStorage, IndexStorage indexStorage, IndexingConfiguration configuration);
    protected HandleDocumentReferences(Index index, Dictionary`2<string, HashSet`1<CollectionName>> referencedCollections, DocumentsStorage documentsStorage, IndexStorage indexStorage, ReferencesBase referencesStorage, IndexingConfiguration configuration);
    protected virtual IndexItem GetItem(DocumentsOperationContext databaseContext, Slice key);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
}
public abstract class Raven.Server.Documents.Indexes.Workers.HandleReferences : HandleReferencesBase {
    private Dictionary`2<string, HashSet`1<CollectionName>> _referencedCollections;
    protected HandleReferences(Index index, Dictionary`2<string, HashSet`1<CollectionName>> referencedCollections, DocumentsStorage documentsStorage, IndexStorage indexStorage, ReferencesBase referencesStorage, IndexingConfiguration configuration);
    protected virtual bool TryGetReferencedCollectionsFor(string collection, HashSet`1& referencedCollections);
}
public abstract class Raven.Server.Documents.Indexes.Workers.HandleReferencesBase : object {
    private ReferencesState _referencesState;
    private Logger _logger;
    private Index _index;
    protected DocumentsStorage _documentsStorage;
    private IndexingConfiguration _configuration;
    protected IndexStorage _indexStorage;
    protected ReferencesBase _referencesStorage;
    protected Reference _reference;
    public string Name { get; }
    protected bool ItemsAndReferencesAreUsingSameEtagPool { get; }
    protected HandleReferencesBase(Index index, DocumentsStorage documentsStorage, IndexStorage indexStorage, ReferencesBase referencesStorage, IndexingConfiguration configuration);
    public sealed virtual string get_Name();
    protected virtual bool get_ItemsAndReferencesAreUsingSameEtagPool();
    public sealed virtual ValueTuple`2<bool, CanContinueBatchResult> Execute(QueryOperationContext queryContext, TransactionOperationContext indexContext, Lazy`1<IndexWriteOperationBase> writeOperation, IndexingStatsScope stats, CancellationToken token);
    protected abstract virtual bool TryGetReferencedCollectionsFor(string collection, HashSet`1& referencedCollections);
    private ValueTuple`2<bool, CanContinueBatchResult> HandleItems(ActionType actionType, QueryOperationContext queryContext, TransactionOperationContext indexContext, Lazy`1<IndexWriteOperationBase> writeOperation, IndexingStatsScope stats, long pageSize, TimeSpan maxTimeForDocumentTransactionToRemainOpen, CancellationToken token);
    private void UpdateReferences(TransactionOperationContext indexContext, string collection);
    private static void RenewTransactionIfNeeded(QueryOperationContext queryContext, CanContinueBatchResult batchContinuationResult, HashSet`1<Slice> indexed, IDisposable& readTransaction);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Workers.HandleReferencesBase/<GetItemsFromCollectionThatReference>d__18")]
private IEnumerable`1<IndexItem> GetItemsFromCollectionThatReference(QueryOperationContext queryContext, TransactionOperationContext indexContext, string collection, Reference referencedItem, long lastIndexedEtag, HashSet`1<Slice> indexed, ReferenceState referenceState);
    protected virtual IEnumerable`1<Reference> GetItemReferences(QueryOperationContext queryContext, CollectionName referencedCollection, long lastEtag, long pageSize);
    protected virtual IEnumerable`1<Reference> GetTombstoneReferences(QueryOperationContext queryContext, CollectionName referencedCollection, long lastEtag, long pageSize);
    public InMemoryReferencesInfo GetReferencesInfo(string collection);
    protected abstract virtual IndexItem GetItem(DocumentsOperationContext databaseContext, Slice key);
    public abstract virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    [CompilerGeneratedAttribute]
private bool <HandleItems>g__CanContinueReferenceBatch|15_0(<>c__DisplayClass15_0& , <>c__DisplayClass15_1& );
    [CompilerGeneratedAttribute]
internal static void <GetItemsFromCollectionThatReference>g__DisposeItem|18_0(<>c__DisplayClass18_0& , <>c__DisplayClass18_1& );
    [CompilerGeneratedAttribute]
private Reference <GetItemReferences>b__19_0(Document document);
    [CompilerGeneratedAttribute]
private Reference <GetTombstoneReferences>b__20_0(Tombstone tombstone);
}
public interface Raven.Server.Documents.Indexes.Workers.IIndexingWork {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual ValueTuple`2<bool, CanContinueBatchResult> Execute(QueryOperationContext queryContext, TransactionOperationContext indexContext, Lazy`1<IndexWriteOperationBase> writeOperation, IndexingStatsScope stats, CancellationToken token);
}
public enum Raven.Server.Documents.Indexes.Workers.IndexingWorkType : Enum {
    public int value__;
    public static IndexingWorkType None;
    public static IndexingWorkType Cleanup;
    public static IndexingWorkType References;
    public static IndexingWorkType Map;
    public static IndexingWorkType Reduce;
}
public class Raven.Server.Documents.Indexes.Workers.MapDocuments : MapItems {
    private DocumentsStorage _documentsStorage;
    public MapDocuments(Index index, DocumentsStorage documentsStorage, IndexStorage indexStorage, MapReduceIndexingContext mapReduceContext, IndexingConfiguration configuration);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Workers.MapDocuments/<GetItemsEnumerator>d__2")]
protected virtual IEnumerable`1<IndexItem> GetItemsEnumerator(QueryOperationContext queryContext, string collection, long lastEtag, long pageSize);
    private IEnumerable`1<Document> GetDocumentsEnumerator(QueryOperationContext queryContext, string collection, long lastEtag, long pageSize);
}
public abstract class Raven.Server.Documents.Indexes.Workers.MapItems : object {
    private Logger _logger;
    private Index _index;
    private MapReduceIndexingContext _mapReduceContext;
    private IndexingConfiguration _configuration;
    private IndexStorage _indexStorage;
    public string Name { get; }
    protected MapItems(Index index, IndexStorage indexStorage, MapReduceIndexingContext mapReduceContext, IndexingConfiguration configuration);
    public sealed virtual string get_Name();
    public sealed virtual ValueTuple`2<bool, CanContinueBatchResult> Execute(QueryOperationContext queryContext, TransactionOperationContext indexContext, Lazy`1<IndexWriteOperationBase> writeOperation, IndexingStatsScope stats, CancellationToken token);
    protected abstract virtual IEnumerable`1<IndexItem> GetItemsEnumerator(QueryOperationContext queryContext, string collection, long lastEtag, long pageSize);
}
public class Raven.Server.Documents.Indexes.Workers.TimeSeries.HandleCompareExchangeTimeSeriesReferences : HandleCompareExchangeReferences {
    private HashSet`1<string> _collectionsWithCompareExchangeReferences;
    private TimeSeriesStorage _timeSeriesStorage;
    public HandleCompareExchangeTimeSeriesReferences(Index index, HashSet`1<string> collectionsWithCompareExchangeReferences, TimeSeriesStorage timeSeriesStorage, DocumentsStorage documentsStorage, IndexStorage indexStorage, IndexingConfiguration configuration);
    protected virtual IndexItem GetItem(DocumentsOperationContext databaseContext, Slice key);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
    protected virtual IEnumerable`1<Reference> GetItemReferences(QueryOperationContext queryContext, CollectionName referencedCollection, long lastEtag, long pageSize);
    protected virtual IEnumerable`1<Reference> GetTombstoneReferences(QueryOperationContext queryContext, CollectionName referencedCollection, long lastEtag, long pageSize);
    protected virtual bool TryGetReferencedCollectionsFor(string collection, HashSet`1& referencedCollections);
    [CompilerGeneratedAttribute]
private Reference <GetItemReferences>b__5_0(ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject> x);
    [CompilerGeneratedAttribute]
private Reference <GetTombstoneReferences>b__6_0(ValueTuple`2<CompareExchangeKey, long> x);
}
public class Raven.Server.Documents.Indexes.Workers.TimeSeries.HandleTimeSeriesReferences : HandleReferences {
    private TimeSeriesStorage _timeSeriesStorage;
    public HandleTimeSeriesReferences(Index index, Dictionary`2<string, HashSet`1<CollectionName>> referencedCollections, TimeSeriesStorage timeSeriesStorage, DocumentsStorage documentsStorage, IndexStorage indexStorage, IndexingConfiguration configuration);
    protected virtual IndexItem GetItem(DocumentsOperationContext databaseContext, Slice key);
    public virtual void HandleDelete(Tombstone tombstone, string collection, Lazy`1<IndexWriteOperationBase> writer, TransactionOperationContext indexContext, IndexingStatsScope stats);
}
public class Raven.Server.Documents.Indexes.Workers.TimeSeries.MapTimeSeries : MapItems {
    private TimeSeriesStorage _timeSeriesStorage;
    public MapTimeSeries(Index index, TimeSeriesStorage timeSeriesStorage, IndexStorage indexStorage, MapReduceIndexingContext mapReduceContext, IndexingConfiguration configuration);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Indexes.Workers.TimeSeries.MapTimeSeries/<GetItemsEnumerator>d__2")]
protected virtual IEnumerable`1<IndexItem> GetItemsEnumerator(QueryOperationContext queryContext, string collection, long lastEtag, long pageSize);
    private IEnumerable`1<TimeSeriesSegmentEntry> GetTimeSeriesEnumerator(QueryOperationContext queryContext, string collection, long lastEtag, long pageSize);
}
[FlagsAttribute]
public enum Raven.Server.Documents.InitializeOptions : Enum {
    public int value__;
    public static InitializeOptions None;
    public static InitializeOptions GenerateNewDatabaseId;
    public static InitializeOptions SkipLoadingDatabaseRecord;
}
public interface Raven.Server.Documents.ITombstoneAware {
    public string TombstoneCleanerIdentifier { get; }
    public abstract virtual string get_TombstoneCleanerIdentifier();
    public abstract virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType type);
    public abstract virtual Dictionary`2<TombstoneDeletionBlockageSource, HashSet`1<string>> GetDisabledSubscribersCollections(HashSet`1<string> tombstoneCollections);
}
public class Raven.Server.Documents.JsonClassGenerator : object {
    private Lazy`1<IDictionary`2<Type, FieldType>> _knownTypes;
    private IDictionary`2<string, ClassType> _generatedTypes;
    private static string CodeLayout;
    internal IDictionary`2<Type, FieldType> KnownTypes { get; }
    public JsonClassGenerator(string language);
    internal IDictionary`2<Type, FieldType> get_KnownTypes();
    private static IDictionary`2<Type, FieldType> InitializeKnownTypes();
    public string Execute(BlittableJsonReaderObject document);
    private static string GenerateClassCodeFromSpec(IReadOnlyList`1<ClassType> classes);
    internal List`1<ClassType> GenerateClassesTypesFromObject(string name, BlittableJsonReaderObject document);
    internal ClassType GenerateClassTypesFromObject(string name, BlittableJsonReaderObject blittableObject);
    private FieldType GetArrayField(BlittableJsonReaderArray array, string name);
    private ClassType IncludeGeneratedClass(ClassType clazz);
    private FieldType GuessTokenTypeFromArray(string name, BlittableJsonReaderArray array);
    private FieldType GetTokenTypeFromPrimitiveType(BlittableJsonToken token, object value);
    private FieldType GuessTokenTypeFromContent(object value, BlittableJsonToken token);
}
public class Raven.Server.Documents.MoveAttachmentDetailsServer : ValueType {
    public AttachmentDetails Result;
    public CollectionName SourceCollectionName;
    public CollectionName DestinationCollectionName;
}
[FlagsAttribute]
public enum Raven.Server.Documents.NonPersistentDocumentFlags : Enum {
    public int value__;
    public static NonPersistentDocumentFlags None;
    public static NonPersistentDocumentFlags LegacyRevision;
    public static NonPersistentDocumentFlags LegacyHasRevisions;
    public static NonPersistentDocumentFlags FromSmuggler;
    public static NonPersistentDocumentFlags FromReplication;
    public static NonPersistentDocumentFlags ByAttachmentUpdate;
    public static NonPersistentDocumentFlags ResolveAttachmentsConflict;
    public static NonPersistentDocumentFlags SkipRevisionCreation;
    public static NonPersistentDocumentFlags Resolved;
    public static NonPersistentDocumentFlags SkipRevisionCreationForSmuggler;
    public static NonPersistentDocumentFlags ResolveCountersConflict;
    public static NonPersistentDocumentFlags ByCountersUpdate;
    public static NonPersistentDocumentFlags FromResolver;
    public static NonPersistentDocumentFlags ByEnforceRevisionConfiguration;
    public static NonPersistentDocumentFlags ResolveTimeSeriesConflict;
    public static NonPersistentDocumentFlags ByTimeSeriesUpdate;
    public static NonPersistentDocumentFlags LegacyDeleteMarker;
    public static NonPersistentDocumentFlags ForceRevisionCreation;
    public static NonPersistentDocumentFlags AllowDataAsNull;
    public static NonPersistentDocumentFlags FromResharding;
}
public abstract class Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1 : object {
    private ServerStore _server;
    private AbstractSubscriptionStorage`1<TSubscriptionConnectionsState> _subscriptionStorage;
    protected AbstractOngoingTasks`1(ServerStore server, AbstractSubscriptionStorage`1<TSubscriptionConnectionsState> subscriptionStorage);
    protected abstract virtual DatabaseTopology GetDatabaseTopology(DatabaseRecord databaseRecord);
    protected abstract virtual string GetDestinationUrlForRavenEtl(string name);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<GetBackupTasks>d__5")]
private IEnumerable`1<OngoingTaskBackup> GetBackupTasks(ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<GetRavenEtlTasks>d__6")]
private IEnumerable`1<OngoingTaskRavenEtl> GetRavenEtlTasks(ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<GetSqlEtlTasks>d__7")]
private IEnumerable`1<OngoingTaskSqlEtl> GetSqlEtlTasks(ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<GetOlapEtlTasks>d__8")]
private IEnumerable`1<OngoingTaskOlapEtl> GetOlapEtlTasks(ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<GetElasticEtlTasks>d__9")]
private IEnumerable`1<OngoingTaskElasticSearchEtl> GetElasticEtlTasks(ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<GetQueueEtlTasks>d__10")]
private IEnumerable`1<OngoingTaskQueueEtl> GetQueueEtlTasks(ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<GetPullReplicationAsSinkTasks>d__11")]
private IEnumerable`1<OngoingTaskPullReplicationAsSink> GetPullReplicationAsSinkTasks(ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    protected abstract virtual IEnumerable`1<OngoingTaskPullReplicationAsHub> GetPullReplicationAsHubTasks(JsonOperationContext context, ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<CollectExternalReplicationTasks>d__13")]
private IEnumerable`1<OngoingTaskReplication> CollectExternalReplicationTasks(ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<CollectSubscriptionTasks>d__14")]
private IEnumerable`1<OngoingTaskSubscription> CollectSubscriptionTasks(ClusterOperationContext context, ClusterTopology clusterTopology);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<GetQueueSinkTasks>d__15")]
private IEnumerable`1<OngoingTaskQueueSink> GetQueueSinkTasks(ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.AbstractOngoingTasks`1/<GetAllTasks>d__16")]
public IEnumerable`1<OngoingTask> GetAllTasks(ClusterOperationContext context, ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    public OngoingTask GetTask(ClusterOperationContext context, Nullable`1<long> taskId, string taskName, OngoingTaskType taskType, ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    protected abstract virtual OngoingTaskConnectionStatus GetEtlTaskConnectionStatus(DatabaseRecord record, EtlConfiguration`1<T> config, String& tag, String& error);
    protected abstract virtual OngoingTaskConnectionStatus GetQueueSinkTaskConnectionStatus(DatabaseRecord record, QueueSinkConfiguration config, String& tag, String& error);
    protected abstract virtual ValueTuple`2<string, OngoingTaskConnectionStatus> GetReplicationTaskConnectionStatus(DatabaseTopology databaseTopology, ClusterTopology clusterTopology, T replication, Dictionary`2<string, RavenConnectionString> connectionStrings, String& responsibleNodeTag, RavenConnectionString& connection);
    protected abstract virtual PeriodicBackupStatus GetBackupStatus(long taskId, PeriodicBackupConfiguration backupConfiguration, String& responsibleNodeTag, NextBackup& nextBackup, RunningBackup& onGoingBackup, Boolean& isEncrypted);
    private OngoingTaskReplication CreateExternalReplicationTaskInfo(ClusterTopology clusterTopology, DatabaseRecord databaseRecord, ExternalReplication watcher);
    private OngoingTaskSubscription CreateSubscriptionTaskInfo(ClusterOperationContext context, ClusterTopology clusterTopology, SubscriptionState subscriptionState);
    private OngoingTaskBackup CreateBackupTaskInfo(ClusterTopology clusterTopology, PeriodicBackupConfiguration backupConfiguration);
    private OngoingTaskRavenEtl CreateRavenEtlTaskInfo(ClusterTopology clusterTopology, DatabaseRecord databaseRecord, RavenEtlConfiguration ravenEtl);
    private OngoingTaskSqlEtl CreateSqlEtlTaskInfo(ClusterTopology clusterTopology, DatabaseRecord databaseRecord, SqlEtlConfiguration sqlEtl);
    private OngoingTaskOlapEtl CreateOlapEtlTaskInfo(ClusterTopology clusterTopology, DatabaseRecord databaseRecord, OlapEtlConfiguration olapEtl);
    private OngoingTaskElasticSearchEtl CreateElasticSearchEtlTaskInfo(ClusterTopology clusterTopology, DatabaseRecord databaseRecord, ElasticSearchEtlConfiguration elasticSearchEtl);
    private OngoingTaskQueueEtl CreateQueueEtlTaskInfo(ClusterTopology clusterTopology, DatabaseRecord databaseRecord, QueueEtlConfiguration queueEtl);
    private OngoingTaskPullReplicationAsSink CreatePullReplicationAsSinkTaskInfo(ClusterTopology clusterTopology, DatabaseRecord databaseRecord, PullReplicationAsSink sinkReplication);
    private OngoingTaskQueueSink CreateQueueSinkTaskInfo(ClusterTopology clusterTopology, DatabaseRecord databaseRecord, QueueSinkConfiguration queueSink);
}
public class Raven.Server.Documents.OngoingTasks.OngoingTasks : AbstractOngoingTasks`1<SubscriptionConnectionsState> {
    private DocumentDatabase _database;
    private ServerStore _server;
    public OngoingTasks(DocumentDatabase database);
    protected virtual DatabaseTopology GetDatabaseTopology(DatabaseRecord databaseRecord);
    protected virtual string GetDestinationUrlForRavenEtl(string name);
    [IteratorStateMachineAttribute("Raven.Server.Documents.OngoingTasks.OngoingTasks/<GetPullReplicationAsHubTasks>d__5")]
protected virtual IEnumerable`1<OngoingTaskPullReplicationAsHub> GetPullReplicationAsHubTasks(JsonOperationContext context, ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    protected virtual OngoingTaskConnectionStatus GetEtlTaskConnectionStatus(DatabaseRecord record, EtlConfiguration`1<T> config, String& tag, String& error);
    protected virtual OngoingTaskConnectionStatus GetQueueSinkTaskConnectionStatus(DatabaseRecord record, QueueSinkConfiguration config, String& tag, String& error);
    protected virtual ValueTuple`2<string, OngoingTaskConnectionStatus> GetReplicationTaskConnectionStatus(DatabaseTopology databaseTopology, ClusterTopology clusterTopology, T replication, Dictionary`2<string, RavenConnectionString> connectionStrings, String& responsibleNodeTag, RavenConnectionString& connection);
    protected virtual PeriodicBackupStatus GetBackupStatus(long taskId, PeriodicBackupConfiguration backupConfiguration, String& responsibleNodeTag, NextBackup& nextBackup, RunningBackup& onGoingBackup, Boolean& isEncrypted);
    private List`1<IAbstractIncomingReplicationHandler> GetIncomingReplicationHandlers();
}
public abstract class Raven.Server.Documents.Operations.AbstractOperation : object {
    private TimeSpan _throttleTime;
    private ThrottledNotification _throttle;
    public long Id;
    public OperationDescription Description;
    public OperationState State;
    [JsonDeserializationIgnoreAttribute]
public OperationCancelToken Token;
    [JsonDeserializationIgnoreAttribute]
public Task`1<IOperationResult> Task;
    [JsonDeserializationIgnoreAttribute]
public string DatabaseName;
    public bool Killable { get; }
    public bool get_Killable();
    public void SetCompleted();
    public bool IsCompleted();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Operations.AbstractOperation/<KillAsync>d__12")]
public Task KillAsync(bool waitForCompletion, CancellationToken token);
    public void NotifyCenter(OperationChanged notification, Action`1<OperationChanged> addToNotificationCenter);
    public DynamicJsonValue ToJson();
    [CompilerGeneratedAttribute]
internal static bool <NotifyCenter>g__ShouldThrottleMessage|13_1(OperationChanged notification);
}
public abstract class Raven.Server.Documents.Operations.AbstractOperations`1 : object {
    private IDocumentsChanges _changes;
    private TimeSpan _maxCompletedTaskLifeTime;
    protected ConcurrentDictionary`2<long, AbstractOperation> Active;
    protected ConcurrentDictionary`2<long, AbstractOperation> Completed;
    public bool HasActive { get; }
    protected AbstractOperations`1(IDocumentsChanges changes, TimeSpan maxCompletedTaskLifeTime);
    public abstract virtual Task`1<IOperationResult> AddLocalOperation(long id, OperationType operationType, string description, IOperationDetailedDescription detailedDescription, Func`2<Action`1<IOperationProgress>, Task`1<IOperationResult>> taskFactory, OperationCancelToken token);
    protected Task`1<IOperationResult> AddOperationInternalAsync(AbstractOperation operation, Func`2<Action`1<IOperationProgress>, Task`1<IOperationResult>> taskFactory);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Operations.AbstractOperations`1/<KillOperationAsync>d__7")]
public ValueTask KillOperationAsync(long id, CancellationToken token);
    public AbstractOperation GetOperation(long id);
    public abstract virtual long GetNextOperationId();
    public virtual void Dispose(ExceptionAggregator exceptionAggregator);
    public IEnumerable`1<AbstractOperation> GetAll();
    public ICollection`1<AbstractOperation> GetActive();
    public bool get_HasActive();
    protected TOperation CreateOperationInstance(long id, string databaseName, OperationType type, string description, IOperationDetailedDescription detailedDescription, OperationCancelToken token);
    protected virtual void RaiseNotifications(OperationStatusChange change, AbstractOperation operation);
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    internal void CleanupOperations();
    private static void CleanupOperationsInternal(ConcurrentDictionary`2<long, AbstractOperation> operations, TimeSpan maxCompletedTaskLifeTime);
}
public class Raven.Server.Documents.Operations.DatabaseOperations : Operations {
    public DatabaseOperations(DocumentDatabase database);
}
internal class Raven.Server.Documents.Operations.GetSegmentsSummaryOperation : object {
    private string _documentId;
    private string _name;
    private Nullable`1<DateTime> _from;
    private Nullable`1<DateTime> _to;
    public GetSegmentsSummaryOperation(string documentId, string name, Nullable`1<DateTime> from, Nullable`1<DateTime> to);
    public sealed virtual RavenCommand`1<SegmentsSummary> GetCommand(IDocumentStore store, DocumentConventions conventions, JsonOperationContext context, HttpCache cache);
}
public class Raven.Server.Documents.Operations.GetSubscriptionBatchesStateOperation : object {
    private string _subscriptionName;
    public GetSubscriptionBatchesStateOperation(string subscriptionName);
    public sealed virtual RavenCommand`1<SubscriptionBatchesState> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Server.Documents.Operations.Operation : AbstractOperation {
}
public class Raven.Server.Documents.Operations.OperationDescription : object {
    public string Description;
    public OperationType TaskType;
    public DateTime StartTime;
    public Nullable`1<DateTime> EndTime;
    public IOperationDetailedDescription DetailedDescription;
    public DynamicJsonValue ToJson();
}
public abstract class Raven.Server.Documents.Operations.Operations : AbstractOperations`1<Operation> {
    private string _databaseName;
    private OperationsStorage _operationsStorage;
    private AbstractNotificationCenter _notificationCenter;
    protected Operations(string databaseName, OperationsStorage operationsStorage, AbstractNotificationCenter notificationCenter, DocumentsChanges changes, TimeSpan maxCompletedTaskLifeTime);
    public virtual Task`1<IOperationResult> AddLocalOperation(long id, OperationType operationType, string description, IOperationDetailedDescription detailedDescription, Func`2<Action`1<IOperationProgress>, Task`1<IOperationResult>> taskFactory, OperationCancelToken token);
    public virtual long GetNextOperationId();
    protected virtual void RaiseNotifications(OperationStatusChange change, AbstractOperation operation);
    [CompilerGeneratedAttribute]
private void <RaiseNotifications>b__6_0(OperationChanged x);
}
public class Raven.Server.Documents.Operations.OperationsStorage : object {
    private StorageEnvironment _environment;
    private TransactionContextPool _contextPool;
    private static Slice NextOperationId;
    private static Slice OperationsTree;
    private static OperationsStorage();
    public void Initialize(StorageEnvironment environment, TransactionContextPool contextPool);
    public long GetNextOperationId();
}
public enum Raven.Server.Documents.Operations.OperationType : Enum {
    public int value__;
    [DescriptionAttribute("Setup")]
public static OperationType Setup;
    [DescriptionAttribute("Update by Query")]
public static OperationType UpdateByQuery;
    [DescriptionAttribute("Delete by Query")]
public static OperationType DeleteByQuery;
    [DescriptionAttribute("Database export")]
public static OperationType DatabaseExport;
    [DescriptionAttribute("Database import")]
public static OperationType DatabaseImport;
    [DescriptionAttribute("Collection import from CSV")]
public static OperationType CollectionImportFromCsv;
    [DescriptionAttribute("RavenDB Database migration")]
public static OperationType DatabaseMigrationRavenDb;
    [DescriptionAttribute("Database Restore")]
public static OperationType DatabaseRestore;
    [DescriptionAttribute("Database compact")]
public static OperationType DatabaseCompact;
    [DescriptionAttribute("Index compact")]
public static OperationType IndexCompact;
    [DescriptionAttribute("Delete by collection")]
public static OperationType DeleteByCollection;
    [DescriptionAttribute("Bulk Insert")]
public static OperationType BulkInsert;
    [DescriptionAttribute("Replay Transaction Commands")]
public static OperationType ReplayTransactionCommands;
    [DescriptionAttribute("Record Transaction Commands")]
public static OperationType RecordTransactionCommands;
    [DescriptionAttribute("Certificate generation")]
public static OperationType CertificateGeneration;
    [DescriptionAttribute("Migration from v3.x")]
public static OperationType MigrationFromLegacyData;
    [DescriptionAttribute("Database Backup")]
public static OperationType DatabaseBackup;
    [DescriptionAttribute("Migration from SQL")]
public static OperationType MigrationFromSql;
    [DescriptionAttribute("Database Migration")]
public static OperationType DatabaseMigration;
    [DescriptionAttribute("Database Revert")]
public static OperationType DatabaseRevert;
    [DescriptionAttribute("Enforce Revision Configuration")]
public static OperationType EnforceRevisionConfiguration;
    [DescriptionAttribute("Debug package")]
public static OperationType DebugPackage;
    [DescriptionAttribute("Dump Raw Index Data - Debug")]
public static OperationType DumpRawIndexData;
    [DescriptionAttribute("Lucene: optimize index")]
public static OperationType LuceneOptimizeIndex;
    [DescriptionAttribute("Resharding")]
public static OperationType Resharding;
    [DescriptionAttribute("Adopt Orphaned Revisions")]
public static OperationType AdoptOrphanedRevisions;
}
public class Raven.Server.Documents.Operations.RevertRevisionsOperation : object {
    private RevertRevisionsRequest _request;
    public RevertRevisionsOperation(DateTime time, long window);
    public RevertRevisionsOperation(RevertRevisionsRequest request);
    public sealed virtual RavenCommand`1<OperationIdResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Server.Documents.Operations.SegmentsSummary : object {
    [CompilerGeneratedAttribute]
private List`1<SegmentSummary> <Results>k__BackingField;
    public List`1<SegmentSummary> Results { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<SegmentSummary> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(List`1<SegmentSummary> value);
}
public class Raven.Server.Documents.Operations.ServerOperations : Operations {
    public ServerOperations(ServerStore serverStore, OperationsStorage operationsStorage);
}
public class Raven.Server.Documents.Patch.AdminJsConsole : object {
    private DocumentDatabase _database;
    public Logger Log;
    private RavenServer _server;
    public AdminJsConsole(RavenServer server, DocumentDatabase database);
    public string ApplyScript(AdminJsScript script);
}
public class Raven.Server.Documents.Patch.AdminJsScript : object {
    public string Script;
    public AdminJsScript(string script);
}
public class Raven.Server.Documents.Patch.AdminJsScriptKey : Key {
    private string _script;
    public string Script { get; }
    public AdminJsScriptKey(string script);
    public string get_Script();
    public virtual void GenerateScript(ScriptRunner runner);
    private bool Equals(AdminJsScriptKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Server.Documents.Patch.BatchPatchDocumentCommand : PatchDocumentCommandBase {
    private BlittableJsonReaderArray _ids;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<string, PatchResult>> _patchResults;
    public BatchPatchDocumentCommand(JsonOperationContext context, BlittableJsonReaderArray ids, bool skipPatchIfChangeVectorMismatch, ValueTuple`2<PatchRequest, BlittableJsonReaderObject> patch, ValueTuple`2<PatchRequest, BlittableJsonReaderObject> patchIfMissing, BlittableJsonReaderObject createIfMissing, bool isTest, bool debugMode, bool collectResultsNeeded);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    public virtual string HandleReply(DynamicJsonArray reply, HashSet`1<string> modifiedCollections);
    [PreserveBaseOverridesAttribute]
public virtual override IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, BatchPatchDocumentCommand> ToDto(DocumentsOperationContext context);
}
public class Raven.Server.Documents.Patch.BatchPatchDocumentCommandDto : PatchDocumentCommandDtoBase`1<BatchPatchDocumentCommand> {
    public BlittableJsonReaderArray Ids;
    public virtual BatchPatchDocumentCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
[DebuggerDisplayAttribute("Blittable JS object")]
public class Raven.Server.Documents.Patch.BlittableObjectInstance : ObjectInstance {
    public bool Changed;
    private BlittableObjectInstance _parent;
    private Document _doc;
    private bool _set;
    public Nullable`1<DateTime> LastModified;
    public string ChangeVector;
    public BlittableJsonReaderObject Blittable;
    public string DocumentId;
    public HashSet`1<string> Deletes;
    public Dictionary`2<string, BlittableObjectProperty> OwnValues;
    public Dictionary`2<string, BlittableJsonToken> OriginalPropertiesTypes;
    public RetrieverInput IndexRetriever;
    public Dictionary`2<string, IndexField> IndexFields;
    public bool AnyDynamicIndexFields;
    public ProjectionOptions Projection;
    public BlittableObjectInstance Metadata;
    public Nullable`1<SpatialResult> Distance { get; }
    public Nullable`1<float> IndexScore { get; }
    internal Nullable`1<DocumentFlags> DocumentFlags { get; }
    public BlittableObjectInstance(Engine engine, BlittableObjectInstance parent, BlittableJsonReaderObject blittable, string id, Nullable`1<DateTime> lastModified, string changeVector);
    public BlittableObjectInstance(Engine engine, BlittableObjectInstance parent, BlittableJsonReaderObject blittable, Document doc);
    public Nullable`1<SpatialResult> get_Distance();
    public Nullable`1<float> get_IndexScore();
    internal Nullable`1<DocumentFlags> get_DocumentFlags();
    private void MarkChanged();
    public ObjectInstance GetOrCreate(string key);
    public bool TryGetOriginalDocumentIfUnchanged(Document& doc);
    public virtual bool Delete(JsValue property);
    public virtual PropertyDescriptor GetOwnProperty(JsValue property);
    public PropertyDescriptor GetOwnProperty(string property);
    public virtual bool Set(JsValue property, JsValue value, JsValue receiver);
    public virtual bool DefineOwnProperty(JsValue property, PropertyDescriptor desc);
    private bool SetDirect(string property, JsValue value);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Patch.BlittableObjectInstance/<GetOwnProperties>d__34")]
public virtual IEnumerable`1<KeyValuePair`2<JsValue, PropertyDescriptor>> GetOwnProperties();
    public virtual List`1<JsValue> GetOwnPropertyKeys(Types types);
    private void RecordNumericFieldType(string key, BlittableJsonToken type);
    public void Reset();
    [CompilerGeneratedAttribute]
private BlittableObjectProperty <GetOrCreate>g__GenerateProperty|23_0(string propertyName);
}
public class Raven.Server.Documents.Patch.JavaScriptUtils : object {
    private JsonOperationContext _context;
    private ScriptRunner _runner;
    private List`1<IDisposable> _disposables;
    private Engine _scriptEngine;
    internal JsValue CurrentlyProcessedObject;
    public bool ReadOnly;
    private JsonOperationContext Context { get; }
    public JavaScriptUtils(ScriptRunner runner, Engine engine);
    private JsonOperationContext get_Context();
    internal JsValue Count(JsValue self, JsValue[] args);
    internal JsValue Key(JsValue self, JsValue[] args);
    internal JsValue Sum(JsValue self, JsValue[] args);
    internal JsValue GetMetadata(JsValue self, JsValue[] args);
    internal JsArray AttachmentsFor(JsValue self, JsValue[] args);
    internal JsValue LoadAttachment(JsValue self, JsValue[] args);
    internal JsValue LoadAttachments(JsValue self, JsValue[] args);
    internal JsValue GetTimeSeriesNamesFor(JsValue self, JsValue[] args);
    internal JsValue GetCounterNamesFor(JsValue self, JsValue[] args);
    private JsArray GetNamesFor(JsValue self, JsValue[] args, string metadataKey, string methodName);
    internal JsValue GetDocumentId(JsValue self, JsValue[] args);
    internal JsValue TranslateToJs(Engine engine, JsonOperationContext context, object o, bool needsClone);
    private void AssertAdminScriptInstance();
    private BlittableJsonReaderObject Clone(BlittableJsonReaderObject origin, JsonOperationContext context);
    public void Clear();
    public void Reset(JsonOperationContext ctx);
    [CompilerGeneratedAttribute]
internal static JsArray <AttachmentsFor>g__EmptyArray|13_0(Engine engine);
    [CompilerGeneratedAttribute]
internal static void <LoadAttachment>g__ThrowInvalidFirstParameter|14_0(<>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static void <LoadAttachment>g__ThrowInvalidSecondParameter|14_1(<>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static JsArray <LoadAttachments>g__EmptyArray|15_2(Engine engine);
    [CompilerGeneratedAttribute]
internal static JsArray <GetNamesFor>g__EmptyArray|18_0(Engine engine);
}
public class Raven.Server.Documents.Patch.JintDateTimeConverter : object {
    public sealed virtual bool TryConvert(Engine engine, object value, JsValue& result);
}
public class Raven.Server.Documents.Patch.JintEnumConverter : object {
    public sealed virtual bool TryConvert(Engine engine, object value, JsValue& result);
}
public class Raven.Server.Documents.Patch.JintGuidConverter : object {
    public sealed virtual bool TryConvert(Engine engine, object value, JsValue& result);
}
public abstract class Raven.Server.Documents.Patch.JintNullPropagationReferenceResolver : object {
    private static JsNumber _numberPositiveZero;
    private static JsNumber _numberNegativeOne;
    protected JsValue _selfInstance;
    protected BlittableObjectInstance _args;
    private static JintNullPropagationReferenceResolver();
    public sealed virtual bool TryUnresolvableReference(Engine engine, Reference reference, JsValue& value);
    public virtual bool TryPropertyReference(Engine engine, Reference reference, JsValue& value);
    public sealed virtual bool TryGetCallable(Engine engine, object callee, JsValue& value);
    public sealed virtual bool CheckCoercible(JsValue value);
}
public class Raven.Server.Documents.Patch.JintPreventResolvingTasksReferenceResolver : JintNullPropagationReferenceResolver {
    public void ExplodeArgsOn(JsValue self, BlittableObjectInstance args);
    public virtual bool TryPropertyReference(Engine engine, Reference reference, JsValue& value);
    public static PropertyDescriptor GetRunningTaskResult(Task task);
}
public class Raven.Server.Documents.Patch.JintStringConverter : object {
    public sealed virtual bool TryConvert(Engine engine, object value, JsValue& result);
}
public class Raven.Server.Documents.Patch.JintTimeSpanConverter : object {
    public sealed virtual bool TryConvert(Engine engine, object value, JsValue& result);
}
public class Raven.Server.Documents.Patch.JsBlittableBridge : ValueType {
    private ManualBlittableJsonDocumentBuilder`1<UnmanagedWriteBuffer> _writer;
    private UsageMode _usageMode;
    private Engine _scriptEngine;
    [ThreadStaticAttribute]
private static HashSet`1<object> _recursive;
    private static double MaxJsDateMs;
    private static double MinJsDateMs;
    private static JsBlittableBridge();
    public JsBlittableBridge(ManualBlittableJsonDocumentBuilder`1<UnmanagedWriteBuffer> writer, UsageMode usageMode, Engine scriptEngine);
    private void WriteInstance(ObjectInstance jsObject, IResultModifier modifier, bool isRoot, bool filterProperties);
    private void WriteJsonValue(object parent, bool isRoot, string propertyName, object value);
    private void WriteArray(JsArray arrayInstance);
    private void WriteValue(object parent, bool isRoot, string propertyName, object value);
    private void WriteNestedObject(ObjectInstance obj, bool filterProperties);
    private void WriteObjectType(object target);
    private void WriteValueInternal(object target, ObjectInstance obj, bool filterProperties);
    private void WriteNumber(object parent, string propName, double d);
    private void WriteJsInstance(ObjectInstance obj, bool isRoot, bool filterProperties);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Patch.JsBlittableBridge/<GetObjectProperties>d__17")]
private IEnumerable`1<KeyValuePair`2<JsValue, PropertyDescriptor>> GetObjectProperties(ObjectWrapper objectWrapper);
    private JsValue SafelyGetJsValue(PropertyDescriptor property);
    private void WriteBlittableInstance(BlittableObjectInstance obj, bool isRoot, bool filterProperties);
    private static bool ShouldFilterProperty(bool filterProperties, string property);
    public static BlittableJsonReaderObject Translate(JsonOperationContext context, Engine scriptEngine, ObjectInstance objectInstance, IResultModifier modifier, UsageMode usageMode, bool isNested, bool removeSpecialMetadata);
    [CompilerGeneratedAttribute]
internal static bool <WriteNumber>g__WriteNumberBasedOnType|15_0(BlittableJsonToken type, <>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static void <WriteNumber>g__GuessNumberType|15_1(<>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static bool <WriteNumber>g__IsDoubleType|15_2(<>c__DisplayClass15_0& );
}
public class Raven.Server.Documents.Patch.PatchConflict : object {
    private DocumentDatabase _database;
    private List`1<object> _docs;
    private DocumentConflict _fstDocumentConflict;
    private bool _hasTombstone;
    private static string TombstoneResolverValue;
    private Logger _logger;
    public PatchConflict(DocumentDatabase database, IReadOnlyList`1<DocumentConflict> docs);
    private static PatchConflict();
    public bool TryResolveConflict(DocumentsOperationContext context, PatchRequest patch, BlittableJsonReaderObject& resolved);
}
public class Raven.Server.Documents.Patch.PatchDebugActions : object {
    public DynamicJsonArray LoadDocument;
    public DynamicJsonArray PutDocument;
    public DynamicJsonArray DeleteDocument;
    public DynamicJsonArray GetCounter;
    public DynamicJsonArray IncrementCounter;
    public DynamicJsonArray DeleteCounter;
    public DynamicJsonArray GetTimeSeries;
    public DynamicJsonArray AppendTimeSeries;
    public DynamicJsonArray IncrementTimeSeries;
    public DynamicJsonArray DeleteTimeSeries;
    public DynamicJsonValue GetDebugActions();
    public void Clear();
}
public class Raven.Server.Documents.Patch.PatchDocumentCommand : PatchDocumentCommandBase {
    private string _id;
    private LazyStringValue _expectedChangeVector;
    private bool _ignoreMaxStepsForScript;
    private SingleRun _run;
    private SingleRun _runIfMissing;
    private ReturnRun _returnRun;
    private IDisposable _disposableStatement;
    private IDisposable _disposableScriptRunner;
    private bool _isInitialized;
    [CompilerGeneratedAttribute]
private PatchResult <PatchResult>k__BackingField;
    public PatchResult PatchResult { get; private set; }
    public PatchDocumentCommand(JsonOperationContext context, string id, LazyStringValue expectedChangeVector, bool skipPatchIfChangeVectorMismatch, ValueTuple`2<PatchRequest, BlittableJsonReaderObject> patch, ValueTuple`2<PatchRequest, BlittableJsonReaderObject> patchIfMissing, BlittableJsonReaderObject createIfMissing, char identityPartsSeparator, bool isTest, bool debugMode, bool collectResultsNeeded, bool returnDocument, bool ignoreMaxStepsForScript);
    [CompilerGeneratedAttribute]
public PatchResult get_PatchResult();
    [CompilerGeneratedAttribute]
private void set_PatchResult(PatchResult value);
    private void InitializeCmd(DocumentsOperationContext context);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    public virtual string HandleReply(DynamicJsonArray reply, HashSet`1<string> modifiedCollections);
    [PreserveBaseOverridesAttribute]
public virtual override IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, DocumentMergedTransactionCommand> ToDto(DocumentsOperationContext context);
    public sealed virtual void Dispose();
}
public abstract class Raven.Server.Documents.Patch.PatchDocumentCommandBase : DocumentMergedTransactionCommand {
    private bool _skipPatchIfChangeVectorMismatch;
    private JsonOperationContext _externalContext;
    protected DocumentDatabase _database;
    private bool _isTest;
    private bool _debugMode;
    protected bool _returnDocument;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ValueTuple`2<PatchRequest, BlittableJsonReaderObject> _patchIfMissing;
    private BlittableJsonReaderObject _createIfMissing;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ValueTuple`2<PatchRequest, BlittableJsonReaderObject> _patch;
    [CompilerGeneratedAttribute]
private List`1<string> <DebugOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicJsonValue <DebugActions>k__BackingField;
    private bool ModifiedDocumentRequired { get; }
    public List`1<string> DebugOutput { get; private set; }
    public DynamicJsonValue DebugActions { get; private set; }
    protected PatchDocumentCommandBase(JsonOperationContext context, bool skipPatchIfChangeVectorMismatch, ValueTuple`2<PatchRequest, BlittableJsonReaderObject> patch, ValueTuple`2<PatchRequest, BlittableJsonReaderObject> patchIfMissing, BlittableJsonReaderObject createIfMissing, bool isTest, bool debugMode, bool collectResultsNeeded, bool returnDocument);
    private bool get_ModifiedDocumentRequired();
    [CompilerGeneratedAttribute]
public List`1<string> get_DebugOutput();
    [CompilerGeneratedAttribute]
private void set_DebugOutput(List`1<string> value);
    [CompilerGeneratedAttribute]
public DynamicJsonValue get_DebugActions();
    [CompilerGeneratedAttribute]
private void set_DebugActions(DynamicJsonValue value);
    protected PatchResult ExecuteOnDocument(DocumentsOperationContext context, string id, LazyStringValue expectedChangeVector, SingleRun run, SingleRun runIfMissing);
    protected virtual Document GetCurrentDocument(DocumentsOperationContext context, string id);
    private BlittableJsonReaderObject ExecuteScript(DocumentsOperationContext context, string id, SingleRun run, JsonOperationContext patchContext, object documentInstance, BlittableJsonReaderObject args);
    private NonPersistentDocumentFlags HandleMetadataUpdates(DocumentsOperationContext context, string id, SingleRun run);
    private NonPersistentDocumentFlags AddResolveFlagOrUpdateRelatedDocuments(DocumentsOperationContext context, string documentId, IEnumerable`1<string> documentsToUpdate, NonPersistentDocumentFlags resolveFlag);
    protected string HandleReply(string id, PatchResult patchResult, DynamicJsonArray reply, HashSet`1<string> modifiedCollections);
    protected void FillDto(PatchDocumentCommandDtoBase dto);
    public abstract virtual string HandleReply(DynamicJsonArray reply, HashSet`1<string> modifiedCollections);
}
public class Raven.Server.Documents.Patch.PatchDocumentCommandDto : PatchDocumentCommandDtoBase`1<PatchDocumentCommand> {
    public string Id;
    public LazyStringValue ExpectedChangeVector;
    public bool ReturnDocument;
    public virtual PatchDocumentCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public abstract class Raven.Server.Documents.Patch.PatchDocumentCommandDtoBase : object {
    public bool SkipPatchIfChangeVectorMismatch;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<PatchRequest, BlittableJsonReaderObject> Patch;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<PatchRequest, BlittableJsonReaderObject> PatchIfMissing;
    public BlittableJsonReaderObject CreateIfMissing;
    public bool IsTest;
    public bool DebugMode;
    public bool CollectResultsNeeded;
}
public abstract class Raven.Server.Documents.Patch.PatchDocumentCommandDtoBase`1 : PatchDocumentCommandDtoBase {
    public abstract virtual TCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public class Raven.Server.Documents.Patch.PatchRequest : Key {
    public string Script;
    public PatchRequestType Type;
    private Dictionary`2<string, DeclaredFunction> _functions;
    public PatchRequest(string script, PatchRequestType type, Dictionary`2<string, DeclaredFunction> functions);
    private bool Equals(PatchRequest other);
    public virtual void GenerateScript(ScriptRunner runner);
    private string GenerateRootScript();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static PatchRequest Parse(BlittableJsonReaderObject input, BlittableJsonReaderObject& args);
}
public enum Raven.Server.Documents.Patch.PatchRequestType : Enum {
    public int value__;
    public static PatchRequestType None;
    public static PatchRequestType Patch;
    public static PatchRequestType Conflict;
    public static PatchRequestType SqlEtl;
    public static PatchRequestType ElasticSearchEtl;
    public static PatchRequestType RavenEtl;
    public static PatchRequestType OlapEtl;
    public static PatchRequestType Smuggler;
    public static PatchRequestType EtlBehaviorFunctions;
    public static PatchRequestType QueueEtl;
    public static PatchRequestType QueueSink;
}
public class Raven.Server.Documents.Patch.ScriptRunner : object {
    private static string MaxStepsForScriptConfigurationKey;
    private static string AllowStringCompilationKey;
    private ConcurrentQueue`1<Holder> _cache;
    private ScriptRunnerCache _parent;
    internal bool _enableClr;
    private DateTime _creationTime;
    public List`1<Prepared`1<Script>> ScriptsSource;
    internal Dictionary`2<string, DeclaredFunction> TimeSeriesDeclaration;
    public long Runs;
    private DateTime _lastRun;
    [CompilerGeneratedAttribute]
private string <ScriptType>k__BackingField;
    public int NumberOfCachedScripts { get; }
    public string ScriptType { get; internal set; }
    public ScriptRunner(ScriptRunnerCache parent, bool enableClr);
    private static ScriptRunner();
    public int get_NumberOfCachedScripts();
    [CompilerGeneratedAttribute]
public string get_ScriptType();
    [CompilerGeneratedAttribute]
internal void set_ScriptType(string value);
    public DynamicJsonValue GetDebugInfo(bool detailed);
    public void AddScript(string script);
    public void AddTimeSeriesDeclaration(DeclaredFunction func);
    public ReturnRun GetRunner(bool ignoreValidationErrors, SingleRun& run);
    public void ReturnRunner(Holder holder);
    public static void TryCompileScript(string script);
    public static DateTime GetDateArg(JsValue arg, string signature, string argName);
    private static DateTime GetTimeSeriesDateArg(JsValue arg, string signature, string argName);
    private static string GetTypes(JsValue value);
    public bool RunIdleOperations();
    [CompilerGeneratedAttribute]
internal static void <GetDateArg>g__ThrowInvalidDateArgument|24_0(<>c__DisplayClass24_0& );
}
public class Raven.Server.Documents.Patch.ScriptRunnerCache : object {
    internal static string PolyfillJs;
    private long _generation;
    private RavenConfiguration _configuration;
    private ConcurrentDictionary`2<Key, Lazy`1<ScriptRunner>> _cache;
    public bool EnableClr;
    public DocumentDatabase Database;
    public RavenConfiguration Configuration { get; }
    public long Generation { get; }
    public int NumberOfCachedScripts { get; }
    private static ScriptRunnerCache();
    public ScriptRunnerCache(DocumentDatabase database, RavenConfiguration configuration);
    public RavenConfiguration get_Configuration();
    public long get_Generation();
    public int get_NumberOfCachedScripts();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Patch.ScriptRunnerCache/<GetDebugInfo>d__14")]
public IEnumerable`1<DynamicJsonValue> GetDebugInfo(bool detailed);
    public ReturnRun GetScriptRunner(Key key, bool readOnly, SingleRun& patchRun);
    public ReturnRun GetScriptRunner(Key key, bool readOnly, bool ignoreValidationErrors, SingleRun& patchRun);
    private ScriptRunner GetScriptRunner(Key script);
    private ScriptRunner GetScriptRunnerUnlikely(Key script);
    public void UpdateConfiguration(RavenConfiguration configuration);
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    public void RunIdleOperations();
}
public class Raven.Server.Documents.Patch.ScriptRunnerResult : object {
    private SingleRun _parent;
    public JsValue Instance;
    public Nullable`1<bool> BooleanValue { get; }
    public bool IsNull { get; }
    public string StringValue { get; }
    public JsValue RawJsValue { get; }
    public ScriptRunnerResult(SingleRun parent, JsValue instance);
    public ObjectInstance GetOrCreate(string property);
    public Nullable`1<bool> get_BooleanValue();
    public bool get_IsNull();
    public string get_StringValue();
    public JsValue get_RawJsValue();
    public BlittableJsonReaderObject TranslateToObject(JsonOperationContext context, IResultModifier modifier, UsageMode usageMode);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsGlacierClient : object {
    internal Size MaxUploadArchiveSize;
    internal Size MinOnePartUploadSizeLimit;
    private Size MaxOnePartUploadSizeLimit;
    private Size TotalArchiveSizeLimit;
    private AmazonGlacierClient _client;
    private string _region;
    private string _vaultName;
    private Progress _progress;
    private CancellationToken _cancellationToken;
    public RavenAwsGlacierClient(GlacierSettings glacierSettings, BackupConfiguration configuration, Progress progress, CancellationToken cancellationToken);
    public string UploadArchive(Stream stream, string archiveDescription);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsGlacierClient/<UploadArchiveAsync>d__11")]
private Task`1<string> UploadArchiveAsync(Stream stream, string archiveDescription);
    public Task PutVaultAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsGlacierClient/<TestConnectionAsync>d__13")]
public Task TestConnectionAsync();
    public sealed virtual void Dispose();
    private long GetPartSize(long length);
    [CompilerGeneratedAttribute]
private void <UploadArchiveAsync>b__11_0(object _, StreamTransferProgressArgs args);
    [CompilerGeneratedAttribute]
private void <UploadArchiveAsync>b__11_1(object _, StreamTransferProgressArgs args);
}
public class Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client : object {
    private Progress _progress;
    private CancellationToken _cancellationToken;
    internal Size MaxUploadPutObject;
    internal Size MinOnePartUploadSizeLimit;
    internal AmazonS3Config Config;
    private static Size TotalBlocksSizeLimit;
    private AmazonS3Client _client;
    private string _bucketName;
    private bool _usingCustomServerUrl;
    public string RemoteFolderName;
    public string Region;
    public RavenAwsS3Client(S3Settings s3Settings, BackupConfiguration configuration, Progress progress, CancellationToken cancellationToken);
    private static RavenAwsS3Client();
    public void PutObject(string key, Stream stream, Dictionary`2<string, string> metadata);
    public sealed virtual IMultiPartUploader GetUploader(string key, Dictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client/<PutObjectAsync>d__14")]
public Task PutObjectAsync(string key, Stream stream, Dictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client/<ListAllObjectsAsync>d__15")]
public Task`1<List`1<S3FileInfoDetails>> ListAllObjectsAsync(string prefix, string delimiter, bool listFolders);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client/<ListObjectsAsync>d__16")]
public Task`1<ListObjectsResult> ListObjectsAsync(string prefix, string delimiter, bool listFolders, bool includeFolders, Nullable`1<int> take, string continuationToken, string startAfter);
    public ListObjectsResult ListObjects(string prefix, string delimiter, bool listFolders, bool includeFolders, Nullable`1<int> take, string continuationToken, string startAfter);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client/<GetObjectAsync>d__18")]
public Task`1<Blob> GetObjectAsync(string key);
    public void DeleteObject(string key);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client/<DeleteObjectAsync>d__20")]
public Task DeleteObjectAsync(string key);
    public void DeleteMultipleObjects(List`1<string> objects);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client/<DeleteMultipleObjectsAsync>d__22")]
private Task DeleteMultipleObjectsAsync(List`1<string> objects);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client/<TestConnectionAsync>d__23")]
public Task TestConnectionAsync();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client/<AssertBucketPermissionsAsync>d__25")]
private Task AssertBucketPermissionsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client/<AssertBucketLocationAsync>d__26")]
private Task AssertBucketLocationAsync();
    public static void FillMetadata(MetadataCollection collection, IDictionary`2<string, string> metadata);
    private static IDictionary`2<string, string> ConvertMetadata(MetadataCollection collection);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Aws.RavenAwsS3Client/<MaybeHandleExceptionAsync>d__29")]
private Task MaybeHandleExceptionAsync(AmazonS3Exception exception);
    [CompilerGeneratedAttribute]
private void <PutObjectAsync>b__14_0(object _, StreamTransferProgressArgs args);
}
public class Raven.Server.Documents.PeriodicBackup.Aws.VaultNotFoundException : Exception {
    public VaultNotFoundException(string message);
    public VaultNotFoundException(string message, Exception innerException);
}
public class Raven.Server.Documents.PeriodicBackup.Azure.ContainerNotFoundException : Exception {
    public ContainerNotFoundException(string message);
}
public interface Raven.Server.Documents.PeriodicBackup.Azure.IRavenAzureClient {
    public string RemoteFolderName { get; }
    public Size MaxUploadPutBlob { get; public set; }
    public Size MaxSingleBlockSize { get; public set; }
    public abstract virtual void PutBlob(string blobName, Stream stream, Dictionary`2<string, string> metadata);
    public abstract virtual ListBlobResult ListBlobs(string prefix, string delimiter, bool listFolders, string continuationToken);
    public abstract virtual Task`1<ListBlobResult> ListBlobsAsync(string prefix, string delimiter, bool listFolders, string continuationToken);
    public abstract virtual Task`1<Blob> GetBlobAsync(string blobName);
    public abstract virtual void DeleteBlobs(List`1<string> blobsToDelete);
    public abstract virtual Task TestConnectionAsync();
    public abstract virtual string get_RemoteFolderName();
    public abstract virtual Size get_MaxUploadPutBlob();
    public abstract virtual void set_MaxUploadPutBlob(Size value);
    public abstract virtual Size get_MaxSingleBlockSize();
    public abstract virtual void set_MaxSingleBlockSize(Size value);
}
public class Raven.Server.Documents.PeriodicBackup.Azure.LegacyRavenAzureClient : RavenStorageClient {
    private bool _hasSasToken;
    private string _accountName;
    private Byte[] _accountKey;
    private string _sasToken;
    private string _containerName;
    private string _serverUrlForContainer;
    private string _serverUrlForAccountName;
    private static string AzureStorageVersion;
    private static long TotalBlocksSizeLimitInBytes;
    private Logger _logger;
    [CompilerGeneratedAttribute]
private string <RemoteFolderName>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxUploadPutBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxSingleBlockSize>k__BackingField;
    public string RemoteFolderName { get; }
    public Size MaxUploadPutBlob { get; public set; }
    public Size MaxSingleBlockSize { get; public set; }
    public LegacyRavenAzureClient(AzureSettings azureSettings, Progress progress, Logger logger, Nullable`1<CancellationToken> cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RemoteFolderName();
    [CompilerGeneratedAttribute]
public sealed virtual Size get_MaxUploadPutBlob();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxUploadPutBlob(Size value);
    [CompilerGeneratedAttribute]
public sealed virtual Size get_MaxSingleBlockSize();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxSingleBlockSize(Size value);
    private static Byte[] GetAccountKeyBytes(string accountKey);
    private static void VerifySasToken(string sasToken);
    private string GetUrl(string baseUrl, string parameters);
    public sealed virtual void PutBlob(string key, Stream stream, Dictionary`2<string, string> metadata);
    private void PutBlockApi(string key, Stream stream, Dictionary`2<string, string> metadata);
    private void PutBlock(Stream baseStream, RavenHttpClient client, string url, long length, int retryCount);
    private void PutBlockList(string baseUrl, RavenHttpClient client, List`1<string> blockIds, Dictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Azure.LegacyRavenAzureClient/<TestConnectionAsync>d__29")]
public sealed virtual Task TestConnectionAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Azure.LegacyRavenAzureClient/<ContainerExistsAsync>d__30")]
private Task`1<bool> ContainerExistsAsync();
    private static XmlDocument CreateXmlDocument(List`1<string> blockIds);
    public void PutContainer();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Azure.LegacyRavenAzureClient/<GetBlobAsync>d__33")]
public sealed virtual Task`1<Blob> GetBlobAsync(string key);
    public void DeleteContainer();
    public sealed virtual ListBlobResult ListBlobs(string prefix, string delimiter, bool listFolders, string marker);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Azure.LegacyRavenAzureClient/<ListBlobsAsync>d__36")]
public sealed virtual Task`1<ListBlobResult> ListBlobsAsync(string prefix, string delimiter, bool listFolders, string marker);
    public sealed virtual void DeleteBlobs(List`1<string> blobs);
    public List`1<string> GetContainerNames(int maxResults);
    private void SetAuthorizationHeader(RavenHttpClient httpClient, HttpMethod httpMethod, string url, HttpHeaders httpHeaders, HttpHeaders httpContentHeaders);
    private static string ComputeCanonicalizedHeaders(HttpMethod httpMethod, HttpHeaders httpHeaders, HttpHeaders httpContentHeaders);
    private string ComputeCanonicalizedResource(string url);
    public sealed virtual IMultiPartUploader GetUploader(string key, Dictionary`2<string, string> metadata);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<BlobProperties> <ListBlobsAsync>g__GetResult|36_0(<>c__DisplayClass36_0& );
}
public class Raven.Server.Documents.PeriodicBackup.Azure.RavenAzureClient : object {
    private Progress _progress;
    private CancellationToken _cancellationToken;
    private BlobContainerClient _client;
    [CompilerGeneratedAttribute]
private string <RemoteFolderName>k__BackingField;
    private string _storageContainer;
    private static Size TotalBlocksSizeLimit;
    [CompilerGeneratedAttribute]
private Size <MaxUploadPutBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxSingleBlockSize>k__BackingField;
    public string RemoteFolderName { get; }
    public Size MaxUploadPutBlob { get; public set; }
    public Size MaxSingleBlockSize { get; public set; }
    private RavenAzureClient(AzureSettings azureSettings, BackupConfiguration configuration, Progress progress, CancellationToken cancellationToken);
    private static RavenAzureClient();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RemoteFolderName();
    [CompilerGeneratedAttribute]
public sealed virtual Size get_MaxUploadPutBlob();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxUploadPutBlob(Size value);
    [CompilerGeneratedAttribute]
public sealed virtual Size get_MaxSingleBlockSize();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxSingleBlockSize(Size value);
    public sealed virtual void PutBlob(string blobName, Stream stream, Dictionary`2<string, string> metadata);
    public sealed virtual ListBlobResult ListBlobs(string prefix, string delimiter, bool listFolders, string continuationToken);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Azure.RavenAzureClient/<ListBlobsAsync>d__19")]
public sealed virtual Task`1<ListBlobResult> ListBlobsAsync(string prefix, string delimiter, bool listFolders, string continuationToken);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Azure.RavenAzureClient/<GetBlobAsync>d__20")]
public sealed virtual Task`1<Blob> GetBlobAsync(string blobName);
    public sealed virtual void DeleteBlobs(List`1<string> blobsToDelete);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Azure.RavenAzureClient/<TestConnectionAsync>d__22")]
public sealed virtual Task TestConnectionAsync();
    public sealed virtual void Report(long value);
    public sealed virtual void Dispose();
    private static void FillResult(ListBlobResult result, Page`1<BlobHierarchyItem> page, bool listFolders);
    private static void VerifySasToken(string sasToken);
    public static IRavenAzureClient Create(AzureSettings settings, BackupConfiguration configuration, Progress progress, CancellationToken cancellationToken);
    public sealed virtual IMultiPartUploader GetUploader(string key, Dictionary`2<string, string> metadata);
}
internal class Raven.Server.Documents.PeriodicBackup.Azure.SubStream : Stream {
    private Stream _baseStream;
    private long _length;
    private long _position;
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public SubStream(Stream baseStream, long offset, long length);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void CheckDisposed();
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[ExtensionAttribute]
internal static class Raven.Server.Documents.PeriodicBackup.BackupCompressionAlgorithmExtensions : object {
    [ExtensionAttribute]
public static ExportCompressionAlgorithm ToExportCompressionAlgorithm(BackupCompressionAlgorithm compressionAlgorithm);
    [ExtensionAttribute]
public static ExportCompressionAlgorithm ToExportCompressionAlgorithm(SnapshotBackupCompressionAlgorithm compressionAlgorithm);
}
public static class Raven.Server.Documents.PeriodicBackup.BackupConfigurationHelper : object {
    internal static bool SkipMinimumBackupAgeToKeepValidation;
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.BackupConfigurationHelper/<GetFullBackupDataDirectory>d__1")]
public static Task GetFullBackupDataDirectory(PathSetting path, string databaseName, int requestTimeoutInMs, bool getNodesInfo, ServerStore serverStore, Stream responseStream);
    public static void UpdateLocalPathIfNeeded(PeriodicBackupConfiguration configuration, ServerStore serverStore);
    public static ActualPathResult GetActualFullPath(ServerStore serverStore, string folderPath);
    public static void AssertBackupConfiguration(PeriodicBackupConfiguration configuration, BackupConfiguration localConfiguration);
    public static void AssertBackupConfigurationInternal(BackupConfiguration configuration);
    private static void AssertDirectUpload(PeriodicBackupConfiguration configuration, BackupConfiguration localConfiguration);
    internal static BackupDestination GetBackupDestinationForDirectUpload(bool backupToLocalFolder, BackupConfiguration configuration, BackupConfiguration localConfiguration);
    public static void AssertDestinationAndRegionAreAllowed(BackupConfiguration configuration, ServerStore serverStore);
    public static void AssertPeriodicBackup(PeriodicBackupConfiguration configuration, BackupConfiguration backupConfiguration, ServerStore serverStore, AuthenticateConnection authConnection);
    public static void AssertOneTimeBackup(BackupConfiguration configuration, ServerStore serverStore, AuthenticateConnection authConnection);
    [CompilerGeneratedAttribute]
internal static CrontabSchedule <AssertBackupConfiguration>g__VerifyBackupFrequency|4_0(string backupFrequency);
}
public class Raven.Server.Documents.PeriodicBackup.BackupDelayException : Exception {
    [CompilerGeneratedAttribute]
private TimeSpan <DelayPeriod>k__BackingField;
    public TimeSpan DelayPeriod { get; public set; }
    public BackupDelayException(string message);
    public BackupDelayException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public TimeSpan get_DelayPeriod();
    [CompilerGeneratedAttribute]
public void set_DelayPeriod(TimeSpan value);
}
public static class Raven.Server.Documents.PeriodicBackup.BackupHelper : object {
    public static void AssertFreeSpaceForSnapshot(string directoryPath, long sizeInBytes, string action, Logger logger);
    public static bool BackupTypeChanged(PeriodicBackupConfiguration previous, PeriodicBackupConfiguration current);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.BackupHelper/<RunWithRetriesAsync>d__2")]
public static Task`1<long> RunWithRetriesAsync(int maxRetries, Func`1<Task`1<long>> action, string infoMessage, string errorMessage, SmugglerResult smugglerResult, Action`1<IOperationProgress> onProgress, OperationCancelToken operationCancelToken);
}
public enum Raven.Server.Documents.PeriodicBackup.BackupKind : Enum {
    public int value__;
    public static BackupKind None;
    public static BackupKind Full;
    public static BackupKind Incremental;
}
public class Raven.Server.Documents.PeriodicBackup.BackupParameters : object {
    [CompilerGeneratedAttribute]
private PeriodicBackupStatus <BackupStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private RetentionPolicy <RetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOneTimeBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFullBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BackupToLocalFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private PathSetting <TempBackupPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public PeriodicBackupStatus BackupStatus { get; public set; }
    public long OperationId { get; public set; }
    public RetentionPolicy RetentionPolicy { get; public set; }
    public DateTime StartTimeUtc { get; public set; }
    public bool IsOneTimeBackup { get; public set; }
    public bool IsFullBackup { get; public set; }
    public bool BackupToLocalFolder { get; public set; }
    public PathSetting TempBackupPath { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public PeriodicBackupStatus get_BackupStatus();
    [CompilerGeneratedAttribute]
public void set_BackupStatus(PeriodicBackupStatus value);
    [CompilerGeneratedAttribute]
public long get_OperationId();
    [CompilerGeneratedAttribute]
public void set_OperationId(long value);
    [CompilerGeneratedAttribute]
public RetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(RetentionPolicy value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTimeUtc();
    [CompilerGeneratedAttribute]
public void set_StartTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_IsOneTimeBackup();
    [CompilerGeneratedAttribute]
public void set_IsOneTimeBackup(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFullBackup();
    [CompilerGeneratedAttribute]
public void set_IsFullBackup(bool value);
    [CompilerGeneratedAttribute]
public bool get_BackupToLocalFolder();
    [CompilerGeneratedAttribute]
public void set_BackupToLocalFolder(bool value);
    [CompilerGeneratedAttribute]
public PathSetting get_TempBackupPath();
    [CompilerGeneratedAttribute]
public void set_TempBackupPath(PathSetting value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public class Raven.Server.Documents.PeriodicBackup.BackupTask : object {
    public static string DateTimeFormat;
    private static string LegacyDateTimeFormat;
    private static string InProgressExtension;
    protected DocumentDatabase Database;
    protected BackupConfiguration Configuration;
    protected BackupResult BackupResult;
    protected RetentionPolicyBaseParameters RetentionPolicyParameters;
    private PeriodicBackupStatus _previousBackupStatus;
    internal bool _isFullBackup;
    private bool _isOneTimeBackup;
    private bool _backupToLocalFolder;
    private long _operationId;
    private PathSetting _tempBackupPath;
    private Logger _logger;
    public OperationCancelToken TaskCancelToken;
    private bool _isServerWide;
    private bool _isBackupEncrypted;
    private Action`1<IOperationProgress> _onProgress;
    private string _taskName;
    internal TestingStuff _forTestingPurposes;
    private DateTime _startTimeUtc;
    protected Action OnBackupException;
    public BackupTask(DocumentDatabase database, BackupParameters backupParameters, BackupConfiguration configuration, OperationCancelToken token, Logger logger, TestingStuff forTestingPurposes);
    private static BackupTask();
    public BackupResult RunPeriodicBackup(Action`1<IOperationProgress> onProgress, PeriodicBackupStatus& runningBackupStatus);
    protected T GetBackupConfigurationFromScript(T backupSettings, Func`2<BlittableJsonReaderObject, T> deserializeSettingsFunc, Action`1<T> updateServerWideSettingsFunc);
    internal static T GetBackupConfigurationFromScript(T backupSettings, Func`2<BlittableJsonReaderObject, T> deserializeSettingsFunc, DocumentDatabase documentDatabase, Action`1<T> updateServerWideSettingsFunc, bool serverWide);
    public static bool IsBackupEncrypted(DocumentDatabase database, BackupConfiguration configuration);
    private long GetDatabaseEtagForBackup();
    private void GenerateFolderNameAndBackupDirectory(LocalSettings localSettings, DateTime startTimeInUtc, String& nowAsString, String& folderName, PathSetting& backupDirectory);
    private static string GetFormattedDate(DateTime dateTime);
    private BackupResult GenerateBackupResult();
    public static bool DirectoryContainsBackupFiles(string fullPath, Func`2<string, bool> isBackupFile);
    private static bool IsAnyBackupFile(string filePath);
    private string GetFileName(bool isFullBackup, string backupFolder, string nowAsString, BackupType backupType, String& backupFilePath);
    private string GetBackupExtension(BackupType type, bool isFullBackup);
    private static string GetFileNameFor(string backupExtension, string nowAsString, string backupFolder, String& backupFilePath, bool throwWhenFileExists);
    private InternalBackupResult CreateLocalBackupOrSnapshot(PeriodicBackupStatus status, string backupFilePath, string folderName, string fileName, Nullable`1<long> startEtag, Nullable`1<long> startRaftIndex);
    protected virtual void RenameFile(string tempBackupFilePath, string backupFilePath);
    protected virtual Stream GetStreamForBackupDestination(string filePath, string folderName, string fileName);
    public static string GetBackupDescription(BackupType backupType, bool isFull);
    protected virtual void DeleteFile(string path);
    protected virtual void ValidateFreeSpaceForSnapshot(string filePath);
    private void BackupTypeValidation();
    private void EnsureSnapshotProcessed(DatabaseSummary databaseSummary, SmugglerResult snapshotSmugglerResult, long indexesCount);
    protected void AddInfo(string message);
    private InternalBackupResult CreateBackup(DatabaseSmugglerOptionsServerSide options, string backupFilePath, string folderName, string fileName, Nullable`1<long> startDocumentEtag, Nullable`1<long> startRaftIndex);
    protected virtual void FlushToDisk(Stream outputStream);
    public Stream GetOutputStream(Stream fileStream);
    protected virtual void UploadToServer(string backupFilePath, string folderName, string fileName);
    private void UpdateOperationId(PeriodicBackupStatus runningBackupStatus);
    public static string GetDateTimeFormat(string fileName);
    [CompilerGeneratedAttribute]
private void <RunPeriodicBackup>b__23_1(LocalSettings settings);
    [CompilerGeneratedAttribute]
internal static string <GetBackupConfigurationFromScript>g__GetStdError|25_0(<>c__DisplayClass25_0`1& );
    [CompilerGeneratedAttribute]
private void <UploadToServer>b__49_1(S3Settings settings);
    [CompilerGeneratedAttribute]
private void <UploadToServer>b__49_3(GlacierSettings settings);
    [CompilerGeneratedAttribute]
private void <UploadToServer>b__49_5(AzureSettings settings);
    [CompilerGeneratedAttribute]
private void <UploadToServer>b__49_7(GoogleCloudSettings settings);
    [CompilerGeneratedAttribute]
private void <UploadToServer>b__49_9(FtpSettings settings);
}
public class Raven.Server.Documents.PeriodicBackup.BackupUploader : object {
    private UploaderSettings _settings;
    private List`1<LongRunningWork> _threads;
    private ConcurrentSet`1<Exception> _exceptions;
    private RetentionPolicyBaseParameters _retentionPolicyParameters;
    private bool _isFullBackup;
    public OperationCancelToken TaskCancelToken;
    private Logger _logger;
    private BackupResult _backupResult;
    private Action`1<IOperationProgress> _onProgress;
    private static string AzureName;
    private static string S3Name;
    private static string GlacierName;
    private static string GoogleCloudName;
    private static string FtpName;
    public bool AnyUploads { get; }
    public BackupUploader(UploaderSettings settings, RetentionPolicyBaseParameters retentionPolicyParameters, Logger logger, BackupResult backupResult, Action`1<IOperationProgress> onProgress, OperationCancelToken taskCancelToken);
    public bool get_AnyUploads();
    public void ExecuteUpload();
    private void Execute();
    public void ExecuteDelete();
    private void UploadToS3(S3Settings settings, Stream stream, Progress progress);
    private void UploadToGlacier(GlacierSettings settings, Stream stream, Progress progress);
    private void UploadToFtp(FtpSettings settings, Stream stream, Progress progress);
    private void UploadToAzure(AzureSettings settings, Stream stream, Progress progress);
    private void UploadToGoogleCloud(GoogleCloudSettings settings, Stream stream, Progress progress);
    private void DeleteFromS3(S3Settings settings);
    private void DeleteFromAzure(AzureSettings settings);
    private void DeleteFromGoogleCloud(GoogleCloudSettings settings);
    private string CombinePathAndKey(string path);
    public static string CombinePathAndKey(string path, string folderName, string fileName);
    private void CreateUploadTaskIfNeeded(S settings, Action`3<S, FileStream, Progress> uploadToServer, T uploadStatus, string targetName);
    private void CreateDeletionTaskIfNeeded(T settings, Action`1<T> deleteFromServer, string targetName);
    private void AddInfo(string message);
    private string GetArchiveDescription();
    public static string GetBackupDescription(BackupType backupType, bool isFullBackup);
    private static string MsToHumanReadableString(long milliseconds);
    private static string Pluralize(int number);
    private string ReportSuccess(string name);
    private string ReportDeletion(string name);
}
public class Raven.Server.Documents.PeriodicBackup.ConcurrentBackupsCounter : object {
    private object _locker;
    private LicenseManager _licenseManager;
    private Dictionary`2<string, int> _runningBackupsPerDatabase;
    private int _maxConcurrentBackups;
    private TimeSpan _concurrentBackupsDelay;
    private bool _skipModifications;
    public int MaxNumberOfConcurrentBackups { get; }
    public int CurrentNumberOfRunningBackups { get; }
    public ConcurrentBackupsCounter(BackupConfiguration backupConfiguration, LicenseManager licenseManager);
    public int get_MaxNumberOfConcurrentBackups();
    public int get_CurrentNumberOfRunningBackups();
    public void StartBackup(string databaseName, string backupName, Logger logger);
    public void FinishBackup(string databaseName, string backupName, PeriodicBackupStatus backupStatus, Nullable`1<TimeSpan> elapsed, Logger logger);
    public void ModifyMaxConcurrentBackups();
    public int GetNumberOfCoresToUseForBackup(int utilizedCores);
    [CompilerGeneratedAttribute]
internal static void <FinishBackup>g__AddBackupTimings|12_0(BackupStatus perDestinationBackupStatus, string backupTypeName, <>c__DisplayClass12_0& , <>c__DisplayClass12_1& , <>c__DisplayClass12_2& );
}
public class Raven.Server.Documents.PeriodicBackup.CurrentResponsibleNodeNotResponding : ResponsibleNodeForBackup {
    private string _currentResponsibleNode;
    private TimeSpan _moveToNewResponsibleNodeGracePeriod;
    public ChosenNodeReason Reason { get; }
    public string ReasonForDecisionLog { get; }
    public bool ShouldLog { get; }
    public CurrentResponsibleNodeNotResponding(string nodeTag, string taskName, string currentResponsibleNode, TimeSpan moveToNewResponsibleNodeGracePeriod);
    public virtual ChosenNodeReason get_Reason();
    public virtual string get_ReasonForDecisionLog();
    public virtual bool get_ShouldLog();
}
public class Raven.Server.Documents.PeriodicBackup.CurrentResponsibleNodeRemovedFromTopology : ResponsibleNodeForBackup {
    private string _currentResponsibleNode;
    public ChosenNodeReason Reason { get; }
    public string ReasonForDecisionLog { get; }
    public bool ShouldLog { get; }
    public CurrentResponsibleNodeRemovedFromTopology(string nodeTag, string taskName, string currentResponsibleNode);
    public virtual ChosenNodeReason get_Reason();
    public virtual string get_ReasonForDecisionLog();
    public virtual bool get_ShouldLog();
}
public class Raven.Server.Documents.PeriodicBackup.DatabaseSummary : object {
    [CompilerGeneratedAttribute]
private long <DocumentsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AttachmentsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RevisionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ConflictsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CounterEntriesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompareExchangeCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompareExchangeTombstonesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <IdentitiesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TimeSeriesSegmentsCount>k__BackingField;
    public long DocumentsCount { get; public set; }
    public long AttachmentsCount { get; public set; }
    public long RevisionsCount { get; public set; }
    public long ConflictsCount { get; public set; }
    public long CounterEntriesCount { get; public set; }
    public long CompareExchangeCount { get; public set; }
    public long CompareExchangeTombstonesCount { get; public set; }
    public long IdentitiesCount { get; public set; }
    public long TimeSeriesSegmentsCount { get; public set; }
    [CompilerGeneratedAttribute]
public long get_DocumentsCount();
    [CompilerGeneratedAttribute]
public void set_DocumentsCount(long value);
    [CompilerGeneratedAttribute]
public long get_AttachmentsCount();
    [CompilerGeneratedAttribute]
public void set_AttachmentsCount(long value);
    [CompilerGeneratedAttribute]
public long get_RevisionsCount();
    [CompilerGeneratedAttribute]
public void set_RevisionsCount(long value);
    [CompilerGeneratedAttribute]
public long get_ConflictsCount();
    [CompilerGeneratedAttribute]
public void set_ConflictsCount(long value);
    [CompilerGeneratedAttribute]
public long get_CounterEntriesCount();
    [CompilerGeneratedAttribute]
public void set_CounterEntriesCount(long value);
    [CompilerGeneratedAttribute]
public long get_CompareExchangeCount();
    [CompilerGeneratedAttribute]
public void set_CompareExchangeCount(long value);
    [CompilerGeneratedAttribute]
public long get_CompareExchangeTombstonesCount();
    [CompilerGeneratedAttribute]
public void set_CompareExchangeTombstonesCount(long value);
    [CompilerGeneratedAttribute]
public long get_IdentitiesCount();
    [CompilerGeneratedAttribute]
public void set_IdentitiesCount(long value);
    [CompilerGeneratedAttribute]
public long get_TimeSeriesSegmentsCount();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesSegmentsCount(long value);
}
public class Raven.Server.Documents.PeriodicBackup.DecryptingXChaCha20Oly1305Stream : Stream {
    private Stream _inner;
    private Byte[] _key;
    private Byte[] _pullState;
    private Byte[] _encryptedBuffer;
    private Byte[] _plainTextBuffer;
    private Memory`1<byte> _plainTextWindow;
    private bool _initialized;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DecryptingXChaCha20Oly1305Stream(Stream inner, Byte[] key);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.DecryptingXChaCha20Oly1305Stream/<InitializeAsync>d__8")]
public ValueTask InitializeAsync();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void DecryptBuffer(int read);
    private bool TryReadFromBuffer(Byte[] buffer, int offset, int count, Int32& read);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.DecryptingXChaCha20Oly1305Stream/<ReadAsync>d__14")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [ConditionalAttribute("DEBUG")]
public void EnsureInitialized();
    protected virtual void Dispose(bool disposing);
}
public class Raven.Server.Documents.PeriodicBackup.DirectUpload.AwsS3DirectUploadStream : DirectUploadStream`1<RavenAwsS3Client> {
    private RetentionPolicyBaseParameters _retentionPolicyParameters;
    [CompilerGeneratedAttribute]
private long <MinOnePartUploadSizeInBytes>k__BackingField;
    protected long MinOnePartUploadSizeInBytes { get; }
    public AwsS3DirectUploadStream(Parameters<RavenAwsS3Client> parameters);
    [CompilerGeneratedAttribute]
protected virtual long get_MinOnePartUploadSizeInBytes();
    protected virtual void Dispose(bool disposing);
}
public class Raven.Server.Documents.PeriodicBackup.DirectUpload.AwsS3MultiPartUploader : object {
    private AmazonS3Client _client;
    private string _bucketName;
    private Progress _progress;
    private string _key;
    private Dictionary`2<string, string> _metadata;
    private CancellationToken _cancellationToken;
    private string _uploadId;
    private int _partNumber;
    private List`1<PartETag> _partEtags;
    public AwsS3MultiPartUploader(AmazonS3Client client, string bucketName, Progress progress, string key, Dictionary`2<string, string> metadata, CancellationToken cancellationToken);
    public sealed virtual void Initialize();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.DirectUpload.AwsS3MultiPartUploader/<InitializeAsync>d__11")]
public sealed virtual Task InitializeAsync();
    public sealed virtual void UploadPart(Stream stream);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.DirectUpload.AwsS3MultiPartUploader/<UploadPartAsync>d__13")]
public sealed virtual Task UploadPartAsync(Stream stream);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.DirectUpload.AwsS3MultiPartUploader/<UploadPartAsync>d__14")]
public Task UploadPartAsync(Stream stream, long size);
    public sealed virtual void CompleteUpload();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.DirectUpload.AwsS3MultiPartUploader/<CompleteUploadAsync>d__16")]
public sealed virtual Task CompleteUploadAsync();
    [CompilerGeneratedAttribute]
private void <UploadPartAsync>b__14_0(object _, StreamTransferProgressArgs args);
}
public class Raven.Server.Documents.PeriodicBackup.DirectUpload.AzureDirectUploadStream : DirectUploadStream`1<IRavenAzureClient> {
    private RetentionPolicyBaseParameters _retentionPolicyParameters;
    [CompilerGeneratedAttribute]
private long <MinOnePartUploadSizeInBytes>k__BackingField;
    protected long MinOnePartUploadSizeInBytes { get; }
    public AzureDirectUploadStream(Parameters<IRavenAzureClient> parameters);
    [CompilerGeneratedAttribute]
protected virtual long get_MinOnePartUploadSizeInBytes();
    protected virtual void Dispose(bool disposing);
}
public class Raven.Server.Documents.PeriodicBackup.DirectUpload.AzureMultiPartUploader : object {
    private BlockBlobClient _blockBlobClient;
    private Dictionary`2<string, string> _metadata;
    private Progress _progress;
    private CancellationToken _cancellationToken;
    private List`1<string> _base64BlockIds;
    private int _partNumber;
    public AzureMultiPartUploader(BlobContainerClient client, string key, Dictionary`2<string, string> metadata, Progress progress, CancellationToken cancellationToken);
    public sealed virtual void Initialize();
    public sealed virtual Task InitializeAsync();
    public sealed virtual void UploadPart(Stream stream);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.DirectUpload.AzureMultiPartUploader/<UploadPartAsync>d__10")]
public sealed virtual Task UploadPartAsync(Stream stream);
    public sealed virtual void CompleteUpload();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.DirectUpload.AzureMultiPartUploader/<CompleteUploadAsync>d__12")]
public sealed virtual Task CompleteUploadAsync();
}
public class Raven.Server.Documents.PeriodicBackup.DirectUpload.DirectUploadBackupTask : BackupTask {
    private BackupDestination _destination;
    internal DirectUploadBackupTask(DocumentDatabase database, BackupParameters backupParameters, BackupConfiguration configuration, OperationCancelToken token, Logger logger, TestingStuff forTestingPurposes);
    protected virtual Stream GetStreamForBackupDestination(string filePath, string folderName, string fileName);
    private Parameters<T> GetDirectUploadParameters(Func`2<Progress, T> clientFactory, string remoteFolderName, string folderName, string fileName);
    protected virtual void UploadToServer(string backupFilePath, string folderName, string fileName);
    protected virtual void ValidateFreeSpaceForSnapshot(string filePath);
    protected virtual void RenameFile(string backupFilePath, string tempBackupFilePath);
    protected virtual void DeleteFile(string path);
    protected virtual void FlushToDisk(Stream outputStream);
    [CompilerGeneratedAttribute]
private void <GetStreamForBackupDestination>b__2_1(S3Settings settings);
    [CompilerGeneratedAttribute]
private void <GetStreamForBackupDestination>b__2_4(AzureSettings settings);
}
public abstract class Raven.Server.Documents.PeriodicBackup.DirectUpload.DirectUploadStream`1 : Stream {
    private IMultiPartUploader _multiPartUploader;
    private CloudUploadStatus _cloudUploadStatus;
    private Action`1<string> _onProgress;
    private IDisposable _backupStatusIDisposable;
    private long _position;
    private MemoryStream _writeStream;
    private MemoryStream _uploadStream;
    private Task _uploadTask;
    private bool _disposed;
    private bool _abortUpload;
    [CompilerGeneratedAttribute]
private T <Client>k__BackingField;
    protected T Client { get; }
    protected long MinOnePartUploadSizeInBytes { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected DirectUploadStream`1(Parameters<T> parameters);
    [CompilerGeneratedAttribute]
protected T get_Client();
    protected abstract virtual long get_MinOnePartUploadSizeInBytes();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.DirectUpload.DirectUploadStream`1/<WriteAsync>d__21")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private void StartUploadTask();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__15_0();
    [CompilerGeneratedAttribute]
private Task <Write>b__20_0();
    [CompilerGeneratedAttribute]
private Task <Dispose>b__23_0();
}
public interface Raven.Server.Documents.PeriodicBackup.DirectUpload.IDirectUploader {
    public abstract virtual IMultiPartUploader GetUploader(string key, Dictionary`2<string, string> metadata);
}
public interface Raven.Server.Documents.PeriodicBackup.DirectUpload.IMultiPartUploader {
    public abstract virtual void Initialize();
    public abstract virtual Task InitializeAsync();
    public abstract virtual void UploadPart(Stream stream);
    public abstract virtual Task UploadPartAsync(Stream stream);
    public abstract virtual void CompleteUpload();
    public abstract virtual Task CompleteUploadAsync();
}
public class Raven.Server.Documents.PeriodicBackup.EncryptingXChaCha20Poly1305Stream : Stream {
    private Stream _inner;
    private Byte[] _key;
    private Byte[] _pushState;
    private Byte[] _encryptedBuffer;
    private Byte[] _innerBuffer;
    private int _pos;
    private bool _shouldFlush;
    private bool _initialized;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public EncryptingXChaCha20Poly1305Stream(Stream inner, Byte[] key);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.EncryptingXChaCha20Poly1305Stream/<InitializeAsync>d__9")]
public Task InitializeAsync();
    public void Initialize();
    public virtual void Flush();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.EncryptingXChaCha20Poly1305Stream/<FlushAsync>d__12")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public void Flush(bool flushToDisk);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private int EncryptBuffer();
    private void FlushAndEncryptBuffer();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.EncryptingXChaCha20Poly1305Stream/<FlushAndEncryptBufferAsync>d__19")]
private Task FlushAndEncryptBufferAsync();
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.EncryptingXChaCha20Poly1305Stream/<WriteAsync>d__21")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [ConditionalAttribute("DEBUG")]
public void EnsureInitialized();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.EncryptingXChaCha20Poly1305Stream/<DisposeAsync>d__35")]
public virtual ValueTask DisposeAsync();
}
public class Raven.Server.Documents.PeriodicBackup.GoogleCloud.RavenGoogleCloudClient : object {
    private static Size DownloadChunkSize;
    private StorageClient _client;
    private string _projectId;
    private CancellationToken CancellationToken;
    private string _bucketName;
    private Progress _progress;
    private static string ProjectIdPropertyName;
    public RavenGoogleCloudClient(GoogleCloudSettings settings, BackupConfiguration configuration, Progress progress, Nullable`1<CancellationToken> cancellationToken);
    private static RavenGoogleCloudClient();
    public Object UploadObject(string fileName, Stream stream, Dictionary`2<string, string> metadata);
    public Task`1<Object> UploadObjectAsync(string fileName, Stream stream, Dictionary`2<string, string> metadata);
    public Stream DownloadObject(string fileName);
    public Task`1<Object> GetObjectAsync(string fileName);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.GoogleCloud.RavenGoogleCloudClient/<GetObjectSizeAsync>d__12")]
public Task`1<Size> GetObjectSizeAsync(string fileName);
    public Task DeleteObjectAsync(string fileName);
    public void DeleteObject(string fileName);
    public PagedEnumerable`2<Buckets, Bucket> ListBuckets();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.GoogleCloud.RavenGoogleCloudClient/<ListObjectsAsync>d__16")]
public Task`1<List`1<Object>> ListObjectsAsync(string prefix, string delimiter);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.GoogleCloud.RavenGoogleCloudClient/<TestConnection>d__17")]
public Task TestConnection();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <UploadObject>b__8_0(IUploadProgress p);
    [CompilerGeneratedAttribute]
private void <UploadObjectAsync>b__9_0(IUploadProgress p);
}
public class Raven.Server.Documents.PeriodicBackup.MentorNode : ResponsibleNodeForBackup {
    public ChosenNodeReason Reason { get; }
    public string ReasonForDecisionLog { get; }
    public bool ShouldLog { get; }
    public MentorNode(string nodeTag, string taskName);
    public virtual ChosenNodeReason get_Reason();
    public virtual string get_ReasonForDecisionLog();
    public virtual bool get_ShouldLog();
}
public class Raven.Server.Documents.PeriodicBackup.NonExistingResponsibleNode : ResponsibleNodeForBackup {
    public ChosenNodeReason Reason { get; }
    public string ReasonForDecisionLog { get; }
    public bool ShouldLog { get; }
    public NonExistingResponsibleNode(string nodeTag, string taskName);
    public virtual ChosenNodeReason get_Reason();
    public virtual string get_ReasonForDecisionLog();
    public virtual bool get_ShouldLog();
}
public class Raven.Server.Documents.PeriodicBackup.PeriodicBackup : object {
    private SemaphoreSlim _updateBackupTaskSemaphore;
    private DisposeOnce`1<SingleAttempt> _disposeOnce;
    private PeriodicBackupRunner _periodicBackupRunner;
    private Logger _logger;
    private BackupTimer _backupTimer;
    [CompilerGeneratedAttribute]
private RunningBackupTask <RunningTask>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationCancelToken <CancelToken>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTimeInUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private PeriodicBackupConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private PeriodicBackupStatus <BackupStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private PeriodicBackupStatus <RunningBackupStatus>k__BackingField;
    public RunningBackupTask RunningTask { get; public set; }
    public OperationCancelToken CancelToken { get; public set; }
    public DateTime StartTimeInUtc { get; public set; }
    public PeriodicBackupConfiguration Configuration { get; public set; }
    public PeriodicBackupStatus BackupStatus { get; public set; }
    public PeriodicBackupStatus RunningBackupStatus { get; public set; }
    public bool Disposed { get; }
    public PeriodicBackup(PeriodicBackupRunner periodicBackupRunner, ConcurrentSet`1<Task> inactiveRunningPeriodicBackupsTasks, Logger logger);
    [CompilerGeneratedAttribute]
public RunningBackupTask get_RunningTask();
    [CompilerGeneratedAttribute]
public void set_RunningTask(RunningBackupTask value);
    [CompilerGeneratedAttribute]
public OperationCancelToken get_CancelToken();
    [CompilerGeneratedAttribute]
public void set_CancelToken(OperationCancelToken value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTimeInUtc();
    [CompilerGeneratedAttribute]
public void set_StartTimeInUtc(DateTime value);
    [CompilerGeneratedAttribute]
public PeriodicBackupConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(PeriodicBackupConfiguration value);
    [CompilerGeneratedAttribute]
public PeriodicBackupStatus get_BackupStatus();
    [CompilerGeneratedAttribute]
public void set_BackupStatus(PeriodicBackupStatus value);
    [CompilerGeneratedAttribute]
public PeriodicBackupStatus get_RunningBackupStatus();
    [CompilerGeneratedAttribute]
public void set_RunningBackupStatus(PeriodicBackupStatus value);
    public bool get_Disposed();
    public IDisposable UpdateBackupTask();
    public void DisableFutureBackups();
    private void CancelFutureTasks();
    public void UpdateTimer(NextBackup nextBackup, bool lockTaken, bool discardIfDisabled);
    private void UpdateTimerInternal(NextBackup nextBackup, bool discardIfDisabled);
    public bool HasScheduledBackup();
    internal Timer GetTimer();
    internal NextBackup GetNextBackup();
    internal Nullable`1<DateTime> GetCreatedAt();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <UpdateBackupTask>b__33_0();
}
public enum Raven.Server.Documents.PeriodicBackup.PeriodicBackupConnectionType : Enum {
    public int value__;
    public static PeriodicBackupConnectionType None;
    public static PeriodicBackupConnectionType Local;
    public static PeriodicBackupConnectionType S3;
    public static PeriodicBackupConnectionType Glacier;
    public static PeriodicBackupConnectionType Azure;
    public static PeriodicBackupConnectionType GoogleCloud;
    public static PeriodicBackupConnectionType FTP;
}
internal class Raven.Server.Documents.PeriodicBackup.PeriodicBackupInfo : object {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullBackupFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IncrementalBackupFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private NextBackup <NextBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    public string Database { get; public set; }
    public string Name { get; public set; }
    public long TaskId { get; public set; }
    public string FullBackupFrequency { get; public set; }
    public string IncrementalBackupFrequency { get; public set; }
    public NextBackup NextBackup { get; public set; }
    public Nullable`1<DateTime> CreatedAt { get; public set; }
    public bool Disposed { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public string get_FullBackupFrequency();
    [CompilerGeneratedAttribute]
public void set_FullBackupFrequency(string value);
    [CompilerGeneratedAttribute]
public string get_IncrementalBackupFrequency();
    [CompilerGeneratedAttribute]
public void set_IncrementalBackupFrequency(string value);
    [CompilerGeneratedAttribute]
public NextBackup get_NextBackup();
    [CompilerGeneratedAttribute]
public void set_NextBackup(NextBackup value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_Disposed();
    [CompilerGeneratedAttribute]
public void set_Disposed(bool value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.PeriodicBackup.PeriodicBackupRunner : object {
    private Logger _logger;
    private DocumentDatabase _database;
    private ServerStore _serverStore;
    private CancellationTokenSource _cancellationToken;
    private PathSetting _tempBackupPath;
    private string _originalDatabaseName;
    private ConcurrentDictionary`2<long, PeriodicBackup> _periodicBackups;
    private ConcurrentSet`1<Task> _inactiveRunningPeriodicBackupsTasks;
    private bool _disposed;
    private Nullable`1<DateTime> _databaseWakeUpTimeUtc;
    public TimeSpan MaxTimerTimeout;
    internal TestingStuff _forTestingPurposes;
    public ICollection`1<PeriodicBackup> PeriodicBackups { get; }
    public string TombstoneCleanerIdentifier { get; }
    public PeriodicBackupRunner(DocumentDatabase database, ServerStore serverStore, Nullable`1<DateTime> wakeup);
    public ICollection`1<PeriodicBackup> get_PeriodicBackups();
    public NextBackup GetNextBackupDetails(PeriodicBackupConfiguration configuration, PeriodicBackupStatus backupStatus, String& responsibleNodeTag);
    private NextBackup GetNextBackupDetails(PeriodicBackupConfiguration configuration, PeriodicBackupStatus backupStatus, string responsibleNodeTag, bool skipErrorLog);
    private static bool IsFullBackupOrSnapshot(string filePath);
    internal void TimerCallback(object backupTaskDetails);
    internal void LongPeriodTimerCallback(object backupTaskDetails);
    private void StartBackupTaskAndRescheduleIfNeeded(PeriodicBackup periodicBackup, NextBackup currentBackup);
    public string WhoseTaskIsIt(long taskId);
    public long StartBackupTask(long taskId, bool isFullBackup, Nullable`1<long> operationId, Nullable`1<DateTime> startTimeUtc);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.PeriodicBackupRunner/<DelayAsync>d__22")]
public Task DelayAsync(long taskId, DateTime delayUntil, X509Certificate2 clientCert, CancellationToken token);
    public IdleDatabaseActivity GetNextIdleDatabaseActivity(string databaseName);
    private long CreateBackupTask(PeriodicBackup periodicBackup, bool isFullBackup, DateTime startTimeInUtc, Nullable`1<long> operationId);
    private Task`1<IOperationResult> StartBackupThread(PeriodicBackup periodicBackup, BackupTask backupTask, TaskCompletionSource`1<IOperationResult> tcs, Action`1<IOperationProgress> onProgress);
    private void RunBackupThread(PeriodicBackup periodicBackup, BackupTask backupTask, string threadName, TaskCompletionSource`1<IOperationResult> tcs, Action`1<IOperationProgress> onProgress);
    private void ScheduleNextBackup(PeriodicBackup periodicBackup, Nullable`1<TimeSpan> elapsed, bool lockTaken);
    private static string GetBackupTypeText(bool isFullBackup, BackupType backupType);
    private bool ShouldRunBackupAfterTimerCallbackAndRescheduleIfNeeded(NextBackup backupInfo, PeriodicBackup& periodicBackup);
    public PeriodicBackupStatus GetBackupStatus(long taskId);
    private PeriodicBackupStatus GetBackupStatus(long taskId, PeriodicBackupStatus inMemoryBackupStatus);
    private static PeriodicBackupStatus GetBackupStatusFromCluster(ServerStore serverStore, string databaseName, long taskId);
    private long GetMinLastEtag();
    public void UpdateConfigurations(List`1<PeriodicBackupConfiguration> configurations);
    private void UpdatePeriodicBackup(long taskId, PeriodicBackupConfiguration newConfiguration, TaskStatus taskState);
    private TaskStatus GetTaskStatus(PeriodicBackupConfiguration configuration, String& responsibleNodeTag, bool disableLog);
    private void WaitForTaskCompletion(Task task);
    public sealed virtual void Dispose();
    public BackupInfo GetBackupInfo();
    public BackupInfo GetBackupInfo(ClusterOperationContext context);
    private void OnMissingNextBackupInfo(PeriodicBackupConfiguration configuration);
    private void OnParsingError(OnParsingErrorParameters parameters);
    public RunningBackup OnGoingBackup(long taskId);
    public sealed virtual string get_TombstoneCleanerIdentifier();
    public sealed virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType tombstoneType);
    internal List`1<PeriodicBackupInfo> GetPeriodicBackupsInformation();
    public sealed virtual Dictionary`2<TombstoneDeletionBlockageSource, HashSet`1<string>> GetDisabledSubscribersCollections(HashSet`1<string> tombstoneCollections);
    public void HandleDatabaseValueChanged(string type, object changeState);
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
private PeriodicBackupInfo <GetPeriodicBackupsInformation>b__48_0(PeriodicBackup x);
}
public class Raven.Server.Documents.PeriodicBackup.PinnedMentorNode : ResponsibleNodeForBackup {
    public ChosenNodeReason Reason { get; }
    public string ReasonForDecisionLog { get; }
    public bool ShouldLog { get; }
    public PinnedMentorNode(string nodeTag, string taskName);
    public virtual ChosenNodeReason get_Reason();
    public virtual string get_ReasonForDecisionLog();
    public virtual bool get_ShouldLog();
}
public class Raven.Server.Documents.PeriodicBackup.Progress : object {
    [CompilerGeneratedAttribute]
private UploadProgress <UploadProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <OnUploadProgress>k__BackingField;
    public UploadProgress UploadProgress { get; }
    public Action OnUploadProgress { get; public set; }
    public Progress(UploadProgress progress);
    [CompilerGeneratedAttribute]
public UploadProgress get_UploadProgress();
    [CompilerGeneratedAttribute]
public Action get_OnUploadProgress();
    [CompilerGeneratedAttribute]
public void set_OnUploadProgress(Action value);
    public static Progress Get(UploadProgress uploadProgress, Action`1<string> onProgress);
}
public class Raven.Server.Documents.PeriodicBackup.ProgressableStreamContent : HttpContent {
    private static int DefaultBufferSize;
    private Stream _content;
    private Progress _progress;
    public long Uploaded;
    public ProgressableStreamContent(Stream content, Progress progress);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.ProgressableStreamContent/<SerializeToStreamAsync>d__5")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
}
public class Raven.Server.Documents.PeriodicBackup.RavenFtpClient : RavenStorageClient {
    private string _url;
    private Nullable`1<int> _port;
    private string _userName;
    private string _password;
    private string _certificateAsBase64;
    private static int DefaultFtpPort;
    public static bool ValidateAnyCertificate;
    public RavenFtpClient(FtpSettings ftpSettings, Progress progress, Nullable`1<CancellationToken> cancellationToken);
    public void UploadFile(string folderName, string fileName, Stream stream);
    private string CreateNestedFoldersIfNeeded(string folderName, String& path);
    private void ExtractUrlAndDirectories(String& url, List`1& dirs);
    internal FtpClient CreateFtpClient(string url, bool keepAlive);
    private static void OnValidateCertificate(BaseFtpClient control, FtpSslValidationEventArgs e);
    public void TestConnection();
    private string GetPath();
    private List`1<string> GetItemsInternal(string url, string path, FtpObjectType type);
    public List`1<string> GetFolders();
    public List`1<string> GetFiles(string folderName);
    public void DeleteFolder(string folderName);
    [CompilerGeneratedAttribute]
private void <UploadFile>b__8_0(FtpProgress p);
}
public abstract class Raven.Server.Documents.PeriodicBackup.RavenStorageClient : object {
    private List`1<RavenHttpClient> _clients;
    protected CancellationToken CancellationToken;
    protected Progress Progress;
    protected static int MaxRetriesForMultiPartUpload;
    protected RavenStorageClient(Progress progress, Nullable`1<CancellationToken> cancellationToken);
    protected RavenHttpClient GetClient(Nullable`1<TimeSpan> timeout);
    public virtual void Dispose();
}
public abstract class Raven.Server.Documents.PeriodicBackup.ResponsibleNodeForBackup : object {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    public string NodeTag { get; }
    public string TaskName { get; }
    public ChosenNodeReason Reason { get; }
    public string ReasonForDecisionLog { get; }
    public bool ShouldLog { get; }
    protected ResponsibleNodeForBackup(string nodeTag, string taskName);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public string get_TaskName();
    public abstract virtual ChosenNodeReason get_Reason();
    public abstract virtual string get_ReasonForDecisionLog();
    public abstract virtual bool get_ShouldLog();
}
public abstract class Raven.Server.Documents.PeriodicBackup.ResponsibleNodeForBackupWithLimitedLogging : ResponsibleNodeForBackup {
    private long _taskId;
    private Dictionary`2<long, ChosenNodeReason> _lastChosenNodeReasonPerTask;
    public bool ShouldLog { get; }
    protected ResponsibleNodeForBackupWithLimitedLogging(string nodeTag, PeriodicBackupConfiguration configuration, Dictionary`2<long, ChosenNodeReason> lastChosenNodeReasonPerTask);
    public virtual bool get_ShouldLog();
}
public abstract class Raven.Server.Documents.PeriodicBackup.Restore.AbstractRestoreBackupTask : object {
    [CompilerGeneratedAttribute]
private RestoreBackupConfigurationBase <RestoreConfiguration>k__BackingField;
    protected ServerStore ServerStore;
    protected RestoreResult Result;
    protected Action`1<IOperationProgress> Progress;
    protected List`1<string> FilesToRestore;
    protected RestoreSettings RestoreSettings;
    protected OperationCancelToken OperationCancelToken;
    protected IRestoreSource RestoreSource;
    protected bool HasEncryptionKey;
    protected DocumentDatabase Database;
    protected JsonOperationContext Context;
    protected static Logger Logger;
    protected bool DatabaseValidation;
    protected bool DeleteDatabaseOnFailure;
    protected InitializeOptions Options;
    private bool _restoringToDefaultDataDirectory;
    private IDisposable _disposeContext;
    protected RestoreBackupConfigurationBase RestoreConfiguration { get; protected set; }
    protected string DatabaseName { get; }
    protected AbstractRestoreBackupTask(ServerStore serverStore, RestoreBackupConfigurationBase restoreConfiguration, IRestoreSource restoreSource, List`1<string> filesToRestore, OperationCancelToken operationCancelToken);
    private static AbstractRestoreBackupTask();
    [CompilerGeneratedAttribute]
protected RestoreBackupConfigurationBase get_RestoreConfiguration();
    [CompilerGeneratedAttribute]
protected void set_RestoreConfiguration(RestoreBackupConfigurationBase value);
    protected string get_DatabaseName();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AbstractRestoreBackupTask/<ExecuteAsync>d__23")]
public Task`1<IOperationResult> ExecuteAsync(Action`1<IOperationProgress> onProgress);
    protected abstract virtual Task RestoreAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AbstractRestoreBackupTask/<InitializeAsync>d__25")]
protected virtual Task InitializeAsync();
    protected virtual DatabaseRecord GetDatabaseRecord();
    protected virtual IOperationResult OperationResult();
    protected virtual RavenConfiguration CreateDatabaseConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AbstractRestoreBackupTask/<OnBeforeRestoreAsync>d__29")]
protected virtual Task`1<IDisposable> OnBeforeRestoreAsync();
    protected virtual Task OnAfterRestoreBeforeReturnAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AbstractRestoreBackupTask/<OnAfterRestoreAsync>d__31")]
protected virtual Task OnAfterRestoreAsync();
    protected void CreateDocumentDatabase();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AbstractRestoreBackupTask/<SaveDatabaseRecordAsync>d__33")]
protected Task`1<long> SaveDatabaseRecordAsync(string databaseName, DatabaseRecord databaseRecord, Dictionary`2<string, BlittableJsonReaderObject> databaseValues, SmugglerResult restoreResult, Action`1<IOperationProgress> onProgress);
    protected void CreateRestoreSettings();
    protected void ModifyDatabaseRecordSettings();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AbstractRestoreBackupTask/<SmugglerRestoreAsync>d__36")]
protected Task SmugglerRestoreAsync(DocumentDatabase database, JsonOperationContext context, DatabaseDestination lastFileDestination);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AbstractRestoreBackupTask/<GetInputStreamAsync>d__37")]
protected Task`1<Stream> GetInputStreamAsync(Stream stream, Byte[] databaseEncryptionKey);
    protected void DisableOngoingTasksIfNeeded(DatabaseRecord databaseRecord);
    private ClusterTopology GetClusterTopology();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AbstractRestoreBackupTask/<ImportSingleBackupFileAsync>d__40")]
protected Task ImportSingleBackupFileAsync(DocumentDatabase database, Action`1<IOperationProgress> onProgress, RestoreResult restoreResult, string filePath, JsonOperationContext context, DatabaseDestination destination, DatabaseSmugglerOptionsServerSide options, bool isLastFile);
    protected virtual void ConfigureSettingsForSmugglerRestore(DocumentDatabase database, SmugglerBase smuggler, string filePath, bool isLastFile);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AbstractRestoreBackupTask/<OnErrorAsync>d__42")]
private Task OnErrorAsync(Action`1<IOperationProgress> onProgress, Exception e);
    private bool IsDefaultDataDirectory(string dataDirectory, string databaseName);
    private string GetDataDirectory();
    private static bool HasFilesOrDirectories(string location);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <CreateDocumentDatabase>b__32_0(LogMode logMode, string txt);
}
public class Raven.Server.Documents.PeriodicBackup.Restore.AzureRestorePoints : RestorePointsBase {
    private RavenConfiguration _configuration;
    private CancellationToken _cancellationToken;
    private IRavenAzureClient _client;
    public AzureRestorePoints(RavenConfiguration configuration, TransactionOperationContext context, AzureSettings azureSettings, CancellationToken cancellationToken);
    public virtual Task`1<RestorePoints> FetchRestorePoints(string path, Nullable`1<int> shardNumber);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AzureRestorePoints/<GetFiles>d__5")]
protected virtual Task`1<List`1<FileInfoDetails>> GetFiles(string path);
    protected virtual ParsedBackupFolderName ParseFolderNameFrom(string path);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.AzureRestorePoints/<GetZipArchive>d__7")]
protected virtual Task`1<ZipArchive> GetZipArchive(string filePath);
    protected virtual string GetFileName(string fullPath);
    public virtual void Dispose();
}
public class Raven.Server.Documents.PeriodicBackup.Restore.FileInfoDetails : object {
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModified>k__BackingField;
    public string DirectoryPath { get; }
    public string FullPath { get; }
    public DateTime LastModified { get; public set; }
    public FileInfoDetails(string fullPath, string directoryPath, DateTime lastModified);
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
public DateTime get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(DateTime value);
}
public class Raven.Server.Documents.PeriodicBackup.Restore.GoogleCloudRestorePoints : RestorePointsBase {
    private RavenConfiguration _configuration;
    private CancellationToken _cancellationToken;
    private RavenGoogleCloudClient _client;
    public GoogleCloudRestorePoints(RavenConfiguration configuration, TransactionOperationContext context, GoogleCloudSettings client, CancellationToken cancellationToken);
    public virtual Task`1<RestorePoints> FetchRestorePoints(string path, Nullable`1<int> shardNumber);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.GoogleCloudRestorePoints/<GetFiles>d__5")]
protected virtual Task`1<List`1<FileInfoDetails>> GetFiles(string path);
    protected virtual ParsedBackupFolderName ParseFolderNameFrom(string path);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.GoogleCloudRestorePoints/<GetZipArchive>d__7")]
protected virtual Task`1<ZipArchive> GetZipArchive(string filePath);
    protected virtual string GetFileName(string fullPath);
    public virtual void Dispose();
}
public interface Raven.Server.Documents.PeriodicBackup.Restore.IRestoreSource {
    public abstract virtual Task`1<Stream> GetStream(string path);
    public abstract virtual Task`1<ZipArchive> GetZipArchiveForSnapshot(string path, Action`1<string> onProgress);
    public abstract virtual Task`1<List`1<string>> GetFilesForRestore();
    public abstract virtual string GetBackupPath(string smugglerFile);
    public abstract virtual string GetBackupLocation();
}
public class Raven.Server.Documents.PeriodicBackup.Restore.ListObjectsResult : object {
    [CompilerGeneratedAttribute]
private List`1<S3FileInfoDetails> <FileInfoDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContinuationToken>k__BackingField;
    public List`1<S3FileInfoDetails> FileInfoDetails { get; public set; }
    public string ContinuationToken { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<S3FileInfoDetails> get_FileInfoDetails();
    [CompilerGeneratedAttribute]
public void set_FileInfoDetails(List`1<S3FileInfoDetails> value);
    [CompilerGeneratedAttribute]
public string get_ContinuationToken();
    [CompilerGeneratedAttribute]
public void set_ContinuationToken(string value);
}
public class Raven.Server.Documents.PeriodicBackup.Restore.LocalRestorePoints : RestorePointsBase {
    public LocalRestorePoints(TransactionOperationContext context);
    public virtual Task`1<RestorePoints> FetchRestorePoints(string directoryPath, Nullable`1<int> shardNumber);
    protected virtual Task`1<List`1<FileInfoDetails>> GetFiles(string directoryPath);
    protected virtual ParsedBackupFolderName ParseFolderNameFrom(string path);
    protected virtual Task`1<ZipArchive> GetZipArchive(string filePath);
    protected virtual string GetFileName(string fullPath);
    public virtual void Dispose();
}
internal class Raven.Server.Documents.PeriodicBackup.Restore.RestoreBackupTask : AbstractRestoreBackupTask {
    public RestoreBackupTask(ServerStore serverStore, RestoreBackupConfigurationBase restoreConfiguration, IRestoreSource restoreSource, List`1<string> filesToRestore, OperationCancelToken operationCancelToken);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreBackupTask/<RestoreAsync>d__1")]
protected virtual Task RestoreAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreBackupTask/<InitializeAsync>d__2")]
protected virtual Task InitializeAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
}
public class Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromAzure : object {
    private ServerStore _serverStore;
    private CancellationToken _cancellationToken;
    private IRavenAzureClient _client;
    private string _remoteFolderName;
    public RestoreFromAzure(ServerStore serverStore, RestoreFromAzureConfiguration restoreFromConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromAzure/<GetStream>d__5")]
public sealed virtual Task`1<Stream> GetStream(string path);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromAzure/<GetZipArchiveForSnapshot>d__6")]
public sealed virtual Task`1<ZipArchive> GetZipArchiveForSnapshot(string path, Action`1<string> onProgress);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromAzure/<GetFilesForRestore>d__7")]
public sealed virtual Task`1<List`1<string>> GetFilesForRestore();
    public sealed virtual string GetBackupPath(string fileName);
    public sealed virtual string GetBackupLocation();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromGoogleCloud : object {
    private ServerStore _serverStore;
    private CancellationToken _cancellationToken;
    private RavenGoogleCloudClient _client;
    private string _remoteFolderName;
    public RestoreFromGoogleCloud(ServerStore serverStore, RestoreFromGoogleCloudConfiguration restoreFromConfiguration, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> GetStream(string path);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromGoogleCloud/<GetZipArchiveForSnapshot>d__6")]
public sealed virtual Task`1<ZipArchive> GetZipArchiveForSnapshot(string path, Action`1<string> onProgress);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromGoogleCloud/<GetFilesForRestore>d__7")]
public sealed virtual Task`1<List`1<string>> GetFilesForRestore();
    public sealed virtual string GetBackupPath(string fileName);
    public sealed virtual string GetBackupLocation();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromLocal : object {
    private string _backupLocation;
    public RestoreFromLocal(RestoreBackupConfiguration restoreConfiguration);
    public sealed virtual Task`1<Stream> GetStream(string path);
    public sealed virtual Task`1<ZipArchive> GetZipArchiveForSnapshot(string path, Action`1<string> onProgress);
    public sealed virtual Task`1<List`1<string>> GetFilesForRestore();
    public sealed virtual string GetBackupPath(string fileName);
    public sealed virtual string GetBackupLocation();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromS3 : object {
    private ServerStore _serverStore;
    private CancellationToken _cancellationToken;
    private RavenAwsS3Client _client;
    private string _remoteFolderName;
    public RestoreFromS3(ServerStore serverStore, RestoreFromS3Configuration restoreFromConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromS3/<GetStream>d__5")]
public sealed virtual Task`1<Stream> GetStream(string path);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromS3/<GetZipArchiveForSnapshot>d__6")]
public sealed virtual Task`1<ZipArchive> GetZipArchiveForSnapshot(string path, Action`1<string> onProgress);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreFromS3/<GetFilesForRestore>d__7")]
public sealed virtual Task`1<List`1<string>> GetFilesForRestore();
    public sealed virtual string GetBackupPath(string fileName);
    public sealed virtual string GetBackupLocation();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.PeriodicBackup.Restore.RestorePoint : object {
    [CompilerGeneratedAttribute]
private DateTime <DateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSnapshotRestore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEncrypted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIncremental>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FilesToRestore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    public DateTime DateTime { get; public set; }
    public string Location { get; public set; }
    public string FileName { get; public set; }
    public bool IsSnapshotRestore { get; public set; }
    public bool IsEncrypted { get; public set; }
    public bool IsIncremental { get; public set; }
    public int FilesToRestore { get; public set; }
    public string DatabaseName { get; public set; }
    public string NodeTag { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_DateTime();
    [CompilerGeneratedAttribute]
public void set_DateTime(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSnapshotRestore();
    [CompilerGeneratedAttribute]
public void set_IsSnapshotRestore(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEncrypted();
    [CompilerGeneratedAttribute]
public void set_IsEncrypted(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsIncremental();
    [CompilerGeneratedAttribute]
public void set_IsIncremental(bool value);
    [CompilerGeneratedAttribute]
public int get_FilesToRestore();
    [CompilerGeneratedAttribute]
public void set_FilesToRestore(int value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
}
public class Raven.Server.Documents.PeriodicBackup.Restore.RestorePoints : object {
    [CompilerGeneratedAttribute]
private List`1<RestorePoint> <List>k__BackingField;
    public List`1<RestorePoint> List { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<RestorePoint> get_List();
    [CompilerGeneratedAttribute]
public void set_List(List`1<RestorePoint> value);
}
public abstract class Raven.Server.Documents.PeriodicBackup.Restore.RestorePointsBase : object {
    public static Regex BackupFolderRegex;
    public static Regex FileNameRegex;
    private SortedList`2<DateTime, RestorePoint> _sortedList;
    private TransactionOperationContext _context;
    protected RestorePointsBase(TransactionOperationContext context);
    private static RestorePointsBase();
    public abstract virtual Task`1<RestorePoints> FetchRestorePoints(string path, Nullable`1<int> shardNumber);
    protected abstract virtual Task`1<List`1<FileInfoDetails>> GetFiles(string path);
    protected abstract virtual ParsedBackupFolderName ParseFolderNameFrom(string path);
    protected abstract virtual Task`1<ZipArchive> GetZipArchive(string filePath);
    protected abstract virtual string GetFileName(string fullPath);
    public abstract virtual void Dispose();
    public static ParsedBackupFolderName ParseFolderName(string folderName);
    public static bool TryExtractDateFromFileName(string filePath, DateTime& lastModified);
    protected Task`1<RestorePoints> FetchRestorePointsForPath(string path, bool assertLegacyBackups, Nullable`1<int> shardNumber);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestorePointsBase/<FetchRestorePointsForPaths>d__15")]
protected Task`1<RestorePoints> FetchRestorePointsForPaths(IEnumerable`1<string> paths, bool assertLegacyBackups, Nullable`1<int> shardNumber);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestorePointsBase/<FetchRestorePointsInternal>d__16")]
private Task FetchRestorePointsInternal(string path, bool assertLegacyBackups, Nullable`1<int> shardNumber);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestorePointsBase/<UpdateRestorePoints>d__17")]
private Task UpdateRestorePoints(List`1<FileInfoDetails> fileInfos);
    public static bool IsBackupOrSnapshot(string filePath);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestorePointsBase/<CheckIfSnapshotIsEncrypted>d__19")]
private Task`1<bool> CheckIfSnapshotIsEncrypted(string fullPath);
    protected internal static string GetDirectoryName(string path, char delimiter);
}
public class Raven.Server.Documents.PeriodicBackup.Restore.RestoreSettings : object {
    public static string SettingsFileName;
    public static string SmugglerValuesFileName;
    [CompilerGeneratedAttribute]
private DatabaseRecord <DatabaseRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, BlittableJsonReaderObject> <DatabaseValues>k__BackingField;
    public Dictionary`2<string, SubscriptionState> Subscriptions;
    public DatabaseRecord DatabaseRecord { get; public set; }
    public Dictionary`2<string, BlittableJsonReaderObject> DatabaseValues { get; public set; }
    private static RestoreSettings();
    [CompilerGeneratedAttribute]
public DatabaseRecord get_DatabaseRecord();
    [CompilerGeneratedAttribute]
public void set_DatabaseRecord(DatabaseRecord value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, BlittableJsonReaderObject> get_DatabaseValues();
    [CompilerGeneratedAttribute]
public void set_DatabaseValues(Dictionary`2<string, BlittableJsonReaderObject> value);
}
internal class Raven.Server.Documents.PeriodicBackup.Restore.RestoreSnapshotTask : AbstractRestoreBackupTask {
    private Stopwatch _sw;
    private string _firstFile;
    private string _extension;
    private ZipArchive _zipArchive;
    public RestoreSnapshotTask(ServerStore serverStore, RestoreBackupConfigurationBase restoreConfiguration, IRestoreSource restoreSource, string firstFile, string extension, List`1<string> filesToRestore, OperationCancelToken operationCancelToken);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreSnapshotTask/<RestoreAsync>d__5")]
protected virtual Task RestoreAsync();
    private static void RemoveSubscriptionFromDatabaseValues(RestoreSettings restoreSettings);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreSnapshotTask/<HandleSubscriptionFromSnapshot>d__7")]
private static Task HandleSubscriptionFromSnapshot(List`1<string> filesToRestore, Dictionary`2<string, SubscriptionState> subscription, string databaseName, DocumentDatabase database);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreSnapshotTask/<InitializeAsync>d__8")]
protected virtual Task InitializeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreSnapshotTask/<OnAfterRestoreBeforeReturnAsync>d__9")]
protected virtual Task OnAfterRestoreBeforeReturnAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreSnapshotTask/<OnAfterRestoreAsync>d__10")]
protected virtual Task OnAfterRestoreAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreSnapshotTask/<RestoreSnapshotAsync>d__11")]
private Task`1<RestoreSettings> RestoreSnapshotAsync(JsonOperationContext context, string backupPath, Action`1<IOperationProgress> onProgress, RestoreResult restoreResult);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreSnapshotTask/<RestoreFromSmugglerFileAsync>d__12")]
private Task RestoreFromSmugglerFileAsync(Action`1<IOperationProgress> onProgress, DocumentDatabase database, string smugglerFile, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreSnapshotTask/<GetSnapshotInputStreamAsync>d__13")]
private Task`1<Stream> GetSnapshotInputStreamAsync(Stream fileStream, string database);
    private void RegenerateDatabaseIdInIndexes(DocumentDatabase database);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
    [CompilerGeneratedAttribute]
private void <OnAfterRestoreBeforeReturnAsync>b__9_0(string message);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1();
}
public static class Raven.Server.Documents.PeriodicBackup.Restore.RestoreUtils : object {
    public static RestoreBackupConfigurationBase GetRestoreConfigurationAndSource(ServerStore serverStore, BlittableJsonReaderObject restoreConfiguration, IRestoreSource& restoreSource, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreUtils/<CreateBackupTaskAsync>d__1")]
public static Task`1<AbstractRestoreBackupTask> CreateBackupTaskAsync(ServerStore serverStore, RestoreBackupConfigurationBase configuration, IRestoreSource restoreSource, long operationId, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreUtils/<CopyRemoteStreamLocallyAsync>d__2")]
public static Task`1<Stream> CopyRemoteStreamLocallyAsync(Stream stream, Size size, RavenConfiguration configuration, Action`1<string> onProgress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.RestoreUtils/<GetOrderedFilesToRestoreAsync>d__3")]
private static Task`1<List`1<string>> GetOrderedFilesToRestoreAsync(IRestoreSource restoreSource, RestoreBackupConfigurationBase configuration);
    private static void AssertFreeSpace(Size size, string basePath);
}
public class Raven.Server.Documents.PeriodicBackup.Restore.S3FileInfoDetails : object {
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModified>k__BackingField;
    public string FullPath { get; public set; }
    public DateTime LastModified { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
public void set_FullPath(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(DateTime value);
}
public class Raven.Server.Documents.PeriodicBackup.Restore.S3RestorePoints : RestorePointsBase {
    private RavenConfiguration _configuration;
    private CancellationToken _cancellationToken;
    private RavenAwsS3Client _client;
    public S3RestorePoints(RavenConfiguration configuration, TransactionOperationContext context, S3Settings s3Settings, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.S3RestorePoints/<FetchRestorePoints>d__4")]
public virtual Task`1<RestorePoints> FetchRestorePoints(string path, Nullable`1<int> shardNumber);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.S3RestorePoints/<GetFiles>d__5")]
protected virtual Task`1<List`1<FileInfoDetails>> GetFiles(string path);
    protected virtual ParsedBackupFolderName ParseFolderNameFrom(string path);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.S3RestorePoints/<GetZipArchive>d__7")]
protected virtual Task`1<ZipArchive> GetZipArchive(string filePath);
    protected virtual string GetFileName(string fullPath);
    public virtual void Dispose();
}
public class Raven.Server.Documents.PeriodicBackup.Restore.Sharding.ShardedRestoreOrchestrationTask : AbstractRestoreBackupTask {
    private long _operationId;
    private IOperationResult _result;
    public ShardedRestoreOrchestrationTask(ServerStore serverStore, RestoreBackupConfigurationBase configuration, long operationId, OperationCancelToken operationCancelToken);
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.Sharding.ShardedRestoreOrchestrationTask/<InitializeAsync>d__3")]
protected virtual Task InitializeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.Sharding.ShardedRestoreOrchestrationTask/<OnBeforeRestoreAsync>d__4")]
protected virtual Task`1<IDisposable> OnBeforeRestoreAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.Sharding.ShardedRestoreOrchestrationTask/<RestoreAsync>d__5")]
protected virtual Task RestoreAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.PeriodicBackup.Restore.Sharding.ShardedRestoreOrchestrationTask/<OnAfterRestoreAsync>d__6")]
protected virtual Task OnAfterRestoreAsync();
    protected virtual IOperationResult OperationResult();
    private void InitializeShardingConfiguration();
    private static RavenCommand`1<OperationIdResult> GenerateCommandForShard(DocumentConventions conventions, int shardNumber, RestoreBackupConfigurationBase configuration);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
}
public class Raven.Server.Documents.PeriodicBackup.Restore.Sharding.ShardedRestoreProgress : RestoreProgress {
    [CompilerGeneratedAttribute]
private int <ShardNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    public int ShardNumber { get; public set; }
    public string NodeTag { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_ShardNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShardNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NodeTag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NodeTag(string value);
    public sealed virtual void Fill(IOperationProgress progress, int shardNumber, string nodeTag);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.PeriodicBackup.Restore.Sharding.ShardedRestoreResult : object {
    [CompilerGeneratedAttribute]
private List`1<ShardNodeRestoreResult> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public List`1<ShardNodeRestoreResult> Results { get; public set; }
    public string Message { get; private set; }
    public bool ShouldPersist { get; }
    public bool CanMerge { get; }
    [CompilerGeneratedAttribute]
public sealed virtual List`1<ShardNodeRestoreResult> get_Results();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Results(List`1<ShardNodeRestoreResult> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    public sealed virtual DynamicJsonValue ToJson();
    public sealed virtual bool get_ShouldPersist();
    public sealed virtual bool get_CanMerge();
    public sealed virtual void MergeWith(IOperationResult result);
    public sealed virtual void CombineWith(IOperationResult result, int shardNumber, string nodeTag);
}
public class Raven.Server.Documents.PeriodicBackup.Restore.Sharding.ShardNodeRestoreResult : ShardNodeOperationResult`1<RestoreResult> {
    public bool ShouldPersist { get; }
    public virtual bool get_ShouldPersist();
}
internal class Raven.Server.Documents.PeriodicBackup.Restore.Sharding.SingleShardRestoreBackupTask : RestoreBackupTask {
    private int _shardNumber;
    public SingleShardRestoreBackupTask(ServerStore serverStore, RestoreBackupConfigurationBase restoreConfiguration, List`1<string> filesToRestore, IRestoreSource restoreSource, OperationCancelToken operationCancelToken);
    protected virtual Task`1<IDisposable> OnBeforeRestoreAsync();
    protected virtual Task OnAfterRestoreAsync();
    protected virtual DatabaseRecord GetDatabaseRecord();
    protected virtual RavenConfiguration CreateDatabaseConfiguration();
    protected virtual void ConfigureSettingsForSmugglerRestore(DocumentDatabase database, SmugglerBase smuggler, string filePath, bool isLastFile);
    private int GetMinShard(ShardingConfiguration config);
}
public class Raven.Server.Documents.PeriodicBackup.Retention.AzureRetentionPolicyRunner : RetentionPolicyRunnerBase {
    private IRavenAzureClient _client;
    private static string Delimiter;
    private string _continuationToken;
    protected string Name { get; }
    public AzureRetentionPolicyRunner(RetentionPolicyBaseParameters parameters, IRavenAzureClient client);
    protected virtual string get_Name();
    protected virtual GetFoldersResult GetSortedFolders();
    protected virtual string GetFolderName(string folderPath);
    protected virtual GetBackupFolderFilesResult GetBackupFilesInFolder(string folder, DateTime startDateOfRetentionRange);
    protected virtual void DeleteFolders(List`1<string> folders);
}
public class Raven.Server.Documents.PeriodicBackup.Retention.FtpRetentionPolicyRunner : RetentionPolicyRunnerBase {
    private RavenFtpClient _client;
    protected string Name { get; }
    public FtpRetentionPolicyRunner(RetentionPolicyBaseParameters parameters, RavenFtpClient client);
    protected virtual string get_Name();
    protected virtual GetFoldersResult GetSortedFolders();
    protected virtual string GetFolderName(string folderPath);
    protected virtual GetBackupFolderFilesResult GetBackupFilesInFolder(string folder, DateTime startDateOfRetentionRange);
    protected virtual void DeleteFolders(List`1<string> folders);
}
public class Raven.Server.Documents.PeriodicBackup.Retention.GetBackupFolderFilesResult : object {
    [CompilerGeneratedAttribute]
private string <FirstFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastFile>k__BackingField;
    public string FirstFile { get; public set; }
    public string LastFile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FirstFile();
    [CompilerGeneratedAttribute]
public void set_FirstFile(string value);
    [CompilerGeneratedAttribute]
public string get_LastFile();
    [CompilerGeneratedAttribute]
public void set_LastFile(string value);
}
public class Raven.Server.Documents.PeriodicBackup.Retention.GetFoldersResult : object {
    [CompilerGeneratedAttribute]
private List`1<string> <List>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMore>k__BackingField;
    public List`1<string> List { get; public set; }
    public bool HasMore { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_List();
    [CompilerGeneratedAttribute]
public void set_List(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_HasMore();
    [CompilerGeneratedAttribute]
public void set_HasMore(bool value);
}
public class Raven.Server.Documents.PeriodicBackup.Retention.GlacierRetentionPolicyRunner : RetentionPolicyRunnerBase {
    private RavenAwsGlacierClient _client;
    protected string Name { get; }
    public GlacierRetentionPolicyRunner(RetentionPolicyBaseParameters parameters, RavenAwsGlacierClient client);
    protected virtual string get_Name();
    protected virtual GetFoldersResult GetSortedFolders();
    protected virtual string GetFolderName(string folderPath);
    protected virtual GetBackupFolderFilesResult GetBackupFilesInFolder(string folder, DateTime startDateOfRetentionRange);
    protected virtual void DeleteFolders(List`1<string> folders);
}
public class Raven.Server.Documents.PeriodicBackup.Retention.GoogleCloudRetentionPolicyRunner : RetentionPolicyRunnerBase {
    private RavenGoogleCloudClient _client;
    protected string Name { get; }
    public GoogleCloudRetentionPolicyRunner(RetentionPolicyBaseParameters parameters, RavenGoogleCloudClient client);
    protected virtual string get_Name();
    protected virtual GetFoldersResult GetSortedFolders();
    protected virtual string GetFolderName(string folderPath);
    protected virtual GetBackupFolderFilesResult GetBackupFilesInFolder(string folder, DateTime startDateOfRetentionRange);
    protected virtual void DeleteFolders(List`1<string> folders);
}
public class Raven.Server.Documents.PeriodicBackup.Retention.LocalRetentionPolicyRunner : RetentionPolicyRunnerBase {
    private string _folderPath;
    protected string Name { get; }
    public LocalRetentionPolicyRunner(RetentionPolicyBaseParameters parameters, string folderPath);
    protected virtual string get_Name();
    protected virtual GetFoldersResult GetSortedFolders();
    protected virtual string GetFolderName(string folderPath);
    protected virtual GetBackupFolderFilesResult GetBackupFilesInFolder(string folder, DateTime startDateOfRetentionRange);
    private static GetBackupFolderFilesResult GetBackupFilesInFolderInternal(string folder);
    protected virtual void DeleteFolders(List`1<string> folders);
}
public class Raven.Server.Documents.PeriodicBackup.Retention.RetentionPolicyBaseParameters : object {
    [CompilerGeneratedAttribute]
private RetentionPolicy <RetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFullBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<string> <OnProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public RetentionPolicy RetentionPolicy { get; public set; }
    public string DatabaseName { get; public set; }
    public bool IsFullBackup { get; public set; }
    public Action`1<string> OnProgress { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    [CompilerGeneratedAttribute]
public RetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public void set_RetentionPolicy(RetentionPolicy value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFullBackup();
    [CompilerGeneratedAttribute]
public void set_IsFullBackup(bool value);
    [CompilerGeneratedAttribute]
public Action`1<string> get_OnProgress();
    [CompilerGeneratedAttribute]
public void set_OnProgress(Action`1<string> value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
}
public abstract class Raven.Server.Documents.PeriodicBackup.Retention.RetentionPolicyRunnerBase : object {
    private static Logger Logger;
    private RetentionPolicy _retentionPolicy;
    private string _databaseName;
    private bool _isFullBackup;
    private Action`1<string> _onProgress;
    protected CancellationToken CancellationToken;
    protected string Name { get; }
    protected RetentionPolicyRunnerBase(RetentionPolicyBaseParameters parameters);
    private static RetentionPolicyRunnerBase();
    protected abstract virtual GetFoldersResult GetSortedFolders();
    protected abstract virtual string GetFolderName(string folderPath);
    protected abstract virtual GetBackupFolderFilesResult GetBackupFilesInFolder(string folder, DateTime startDateOfRetentionRange);
    protected abstract virtual void DeleteFolders(List`1<string> folders);
    protected abstract virtual string get_Name();
    public void Execute();
    private bool UpdateFoldersToDelete(GetFoldersResult folders, DateTime now, List`1<string> foldersToDelete);
    private bool GotFreshIncrementalBackup(GetBackupFolderFilesResult backupFiles, DateTime now);
}
public class Raven.Server.Documents.PeriodicBackup.Retention.S3RetentionPolicyRunner : RetentionPolicyRunnerBase {
    private RavenAwsS3Client _client;
    private static string Delimiter;
    private string _folderContinuationToken;
    protected string Name { get; }
    public S3RetentionPolicyRunner(RetentionPolicyBaseParameters parameters, RavenAwsS3Client client);
    protected virtual string get_Name();
    protected virtual GetFoldersResult GetSortedFolders();
    protected virtual string GetFolderName(string folderPath);
    protected virtual GetBackupFolderFilesResult GetBackupFilesInFolder(string folder, DateTime startDateOfRetentionRange);
    protected virtual void DeleteFolders(List`1<string> folders);
}
public class Raven.Server.Documents.PeriodicBackup.SameResponsibleNode : ResponsibleNodeForBackup {
    public ChosenNodeReason Reason { get; }
    public string ReasonForDecisionLog { get; }
    public bool ShouldLog { get; }
    public SameResponsibleNode(string nodeTag, string taskName);
    public virtual ChosenNodeReason get_Reason();
    public virtual string get_ReasonForDecisionLog();
    public virtual bool get_ShouldLog();
}
public class Raven.Server.Documents.PeriodicBackup.SameResponsibleNodeDueToMissingHighlyAvailableTasks : ResponsibleNodeForBackupWithLimitedLogging {
    public ChosenNodeReason Reason { get; }
    public string ReasonForDecisionLog { get; }
    public SameResponsibleNodeDueToMissingHighlyAvailableTasks(string nodeTag, PeriodicBackupConfiguration configuration, Dictionary`2<long, ChosenNodeReason> lastChosenNodeReasonPerTask);
    public virtual ChosenNodeReason get_Reason();
    public virtual string get_ReasonForDecisionLog();
}
public class Raven.Server.Documents.PeriodicBackup.SameResponsibleNodeDueToResourceLimitations : ResponsibleNodeForBackupWithLimitedLogging {
    private DatabasePromotionStatus _promotionStatus;
    public ChosenNodeReason Reason { get; }
    public string ReasonForDecisionLog { get; }
    public SameResponsibleNodeDueToResourceLimitations(string lastResponsibleNode, PeriodicBackupConfiguration configuration, Dictionary`2<long, ChosenNodeReason> lastChosenNodeReasonPerTask, DatabasePromotionStatus promotionStatus);
    public virtual ChosenNodeReason get_Reason();
    public virtual string get_ReasonForDecisionLog();
    private string GetReasonFromPromotionStatus();
}
public class Raven.Server.Documents.PeriodicBackup.UploaderSettings : object {
    public BackupConfiguration Configuration;
    public S3Settings S3Settings;
    public GlacierSettings GlacierSettings;
    public AzureSettings AzureSettings;
    public GoogleCloudSettings GoogleCloudSettings;
    public FtpSettings FtpSettings;
    public string FilePath;
    public string FolderName;
    public string FileName;
    public string DatabaseName;
    public string TaskName;
    public Nullable`1<BackupType> BackupType;
    public UploaderSettings(BackupConfiguration configuration);
}
public abstract class Raven.Server.Documents.Queries.AbstractDatabaseQueryRunner : AbstractQueryRunner {
    public DocumentDatabase Database;
    protected QueryRunner QueryRunner { get; }
    protected AbstractDatabaseQueryRunner(DocumentDatabase database);
    protected QueryRunner get_QueryRunner();
    public Index GetIndex(string indexName, bool throwIfNotExists);
    public abstract virtual Task`1<DocumentQueryResult> ExecuteQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    public abstract virtual Task ExecuteStreamQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<Document> writer, OperationCancelToken token);
    public abstract virtual Task ExecuteStreamIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<BlittableJsonReaderObject> writer, bool ignoreLimit, OperationCancelToken token);
    public abstract virtual Task`1<IndexEntriesQueryResult> ExecuteIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, bool ignoreLimit, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    public abstract virtual Task`1<IOperationResult> ExecuteDeleteQuery(IndexQueryServerSide query, QueryOperationOptions options, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    public abstract virtual Task`1<IOperationResult> ExecutePatchQuery(IndexQueryServerSide query, QueryOperationOptions options, PatchRequest patch, BlittableJsonReaderObject patchArgs, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    public abstract virtual Task`1<SuggestionQueryResult> ExecuteSuggestionQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.AbstractDatabaseQueryRunner/<ExecuteSuggestion>d__12")]
protected Task`1<SuggestionQueryResult> ExecuteSuggestion(IndexQueryServerSide query, Index index, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    protected Task`1<IOperationResult> ExecuteDelete(IndexQueryServerSide query, Index index, QueryOperationOptions options, QueryOperationContext queryContext, Action`1<DeterminateProgress> onProgress, OperationCancelToken token);
    protected Task`1<IOperationResult> ExecutePatch(IndexQueryServerSide query, Index index, QueryOperationOptions options, PatchRequest patch, BlittableJsonReaderObject patchArgs, QueryOperationContext queryContext, Action`1<DeterminateProgress> onProgress, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.AbstractDatabaseQueryRunner/<ExecuteOperation>d__15`1")]
private Task`1<IOperationResult> ExecuteOperation(IndexQueryServerSide query, Index index, QueryOperationOptions options, QueryOperationContext queryContext, Action`1<DeterminateProgress> onProgress, Func`3<string, bool, BulkOperationCommand`1<T>> createCommandForId, OperationCancelToken token);
    private static IndexQueryServerSide ConvertToOperationQuery(IndexQueryServerSide query, QueryOperationOptions options);
    [CompilerGeneratedAttribute]
private BulkOperationCommand`1<DeleteDocumentCommand> <ExecuteDelete>b__13_0(string key, bool retrieveDetails);
}
public abstract class Raven.Server.Documents.Queries.AbstractDocumentStreamQueryResultWriter`1 : object {
    public static string ErrorPropertyName;
    protected AsyncBlittableJsonTextWriter Writer;
    protected JsonOperationContext Context;
    public bool SupportError { get; }
    public bool SupportStatistics { get; }
    protected AbstractDocumentStreamQueryResultWriter`1(Stream stream, JsonOperationContext context);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void StartResponse();
    public sealed virtual void StartResults();
    public sealed virtual void EndResults();
    public abstract virtual ValueTask AddResultAsync(T res, CancellationToken token);
    public sealed virtual void EndResponse();
    public sealed virtual ValueTask WriteErrorAsync(Exception e);
    public sealed virtual ValueTask WriteErrorAsync(string error);
    public sealed virtual void WriteQueryStatistics(long resultEtag, bool isStale, string indexName, long totalResults, DateTime timestamp);
    public bool get_SupportError();
    public sealed virtual bool get_SupportStatistics();
}
public abstract class Raven.Server.Documents.Queries.AbstractQueryRunner : object {
    public static string AllDocsCollectionName;
    public static string CollectionIndexPrefix;
    public static string DynamicIndexPrefix;
    private long _nextQueryId;
    private ConcurrentSet`1<ExecutingQueryInfo> _currentlyRunningQueries;
    public IEnumerable`1<ExecutingQueryInfo> CurrentlyRunningQueries { get; }
    public IEnumerable`1<ExecutingQueryInfo> get_CurrentlyRunningQueries();
    public QueryMarker MarkQueryAsRunning(string name, IndexQueryServerSide query, OperationCancelToken token, bool isStreaming);
    public static string GetIndexName(IndexQueryServerSide query);
}
public class Raven.Server.Documents.Queries.AST.BetweenExpression : QueryExpression {
    public QueryExpression Source;
    public ValueExpression Max;
    public ValueExpression Min;
    public bool MinInclusive;
    public bool MaxInclusive;
    public BetweenExpression(QueryExpression source, ValueExpression min, ValueExpression max);
    public virtual string ToString();
    public virtual string GetText(IndexQueryServerSide parent);
    public virtual string GetTextWithAlias(IndexQueryServerSide parent);
    public virtual bool Equals(QueryExpression other);
}
public class Raven.Server.Documents.Queries.AST.BinaryExpression : QueryExpression {
    public QueryExpression Left;
    public OperatorType Operator;
    public QueryExpression Right;
    public bool Parenthesis;
    public bool IsRangeOperation { get; }
    public bool IsGreaterThan { get; }
    public bool IsLessThan { get; }
    public BinaryExpression(QueryExpression left, QueryExpression right, OperatorType op);
    public bool get_IsRangeOperation();
    public bool get_IsGreaterThan();
    public bool get_IsLessThan();
    public virtual string ToString();
    public virtual string GetText(IndexQueryServerSide parent);
    public virtual string GetTextWithAlias(IndexQueryServerSide parent);
    public virtual bool Equals(QueryExpression other);
    private static string GetOperatorText(OperatorType operatorType);
}
public class Raven.Server.Documents.Queries.AST.DeclaredFunction : object {
    public string Name;
    public string FunctionText;
    public Program JavaScript;
    public TimeSeriesFunction TimeSeries;
    public FunctionType Type;
    public List`1<QueryExpression> Parameters;
}
public enum Raven.Server.Documents.Queries.AST.ExpressionType : Enum {
    public int value__;
    public static ExpressionType None;
    public static ExpressionType Field;
    public static ExpressionType Between;
    public static ExpressionType Binary;
    public static ExpressionType In;
    public static ExpressionType Value;
    public static ExpressionType Method;
    public static ExpressionType True;
    public static ExpressionType Negated;
}
public class Raven.Server.Documents.Queries.AST.FieldExpression : QueryExpression {
    public List`1<StringSegment> Compound;
    public bool IsQuoted;
    private string _field;
    private string _fieldWithoutAlias;
    public bool HasCollectionOperator { get; }
    public string FieldValue { get; }
    public string FieldValueWithoutAlias { get; }
    public FieldExpression(List`1<StringSegment> path);
    public bool get_HasCollectionOperator();
    public string get_FieldValue();
    private string GetFieldValue(bool ignoreArrayQualifier);
    private string JoinCompoundFragments(int start);
    public string get_FieldValueWithoutAlias();
    public virtual string ToString();
    public virtual string GetText(IndexQueryServerSide parent);
    public virtual string GetTextWithAlias(IndexQueryServerSide parent);
    public virtual bool Equals(QueryExpression other);
}
public class Raven.Server.Documents.Queries.AST.FromClause : ValueType {
    [CompilerGeneratedAttribute]
private FieldExpression <From>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<StringSegment> <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryExpression <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Index>k__BackingField;
    public FieldExpression From { get; public set; }
    public Nullable`1<StringSegment> Alias { get; public set; }
    public QueryExpression Filter { get; public set; }
    public bool Index { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public FieldExpression get_From();
    [CompilerGeneratedAttribute]
public void set_From(FieldExpression value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<StringSegment> get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(Nullable`1<StringSegment> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public QueryExpression get_Filter();
    [CompilerGeneratedAttribute]
public void set_Filter(QueryExpression value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(bool value);
}
public class Raven.Server.Documents.Queries.AST.InExpression : QueryExpression {
    public bool All;
    public QueryExpression Source;
    public List`1<QueryExpression> Values;
    public InExpression(QueryExpression source, List`1<QueryExpression> values, bool all);
    public virtual string ToString();
    public virtual string GetText(IndexQueryServerSide parent);
    public virtual string GetTextWithAlias(IndexQueryServerSide parent);
    public virtual bool Equals(QueryExpression other);
}
public class Raven.Server.Documents.Queries.AST.JavascriptCodeQueryVisitor : QueryVisitor {
    private StringBuilder _sb;
    private HashSet`1<string> _knownAliases;
    private static String[] UnsupportedQueryMethodsInJavascript;
    public JavascriptCodeQueryVisitor(StringBuilder sb, Query q);
    private static JavascriptCodeQueryVisitor();
    public virtual void VisitInclude(List`1<QueryExpression> includes);
    public virtual void VisitUpdate(StringSegment update);
    public virtual void VisitSelectFunctionBody(StringSegment func);
    public virtual void VisitSelect(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> select, bool isDistinct);
    public virtual void VisitSelectDistinct();
    public virtual void VisitLoad(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> load);
    public virtual void VisitOrderBy(List`1<ValueTuple`3<QueryExpression, OrderByFieldType, bool>> orderBy);
    public virtual void VisitDeclaredFunction(string func);
    public virtual void VisitNegatedExpression(NegatedExpression expr);
    public virtual void VisitCompoundWhereExpression(BinaryExpression where);
    public virtual void VisitMethod(MethodExpression expr);
    public virtual void VisitValue(ValueExpression expr);
    public virtual void VisitIn(InExpression expr);
    public virtual void VisitBetween(BetweenExpression expr);
    public virtual void VisitField(FieldExpression field);
    private static void EscapeFieldName(StringBuilder sb, string name);
    public virtual void VisitTrue();
    public virtual void VisitSimpleWhereExpression(BinaryExpression expr);
    public virtual void VisitGroupByExpression(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> expressions);
    public virtual void VisitFromClause(FieldExpression from, Nullable`1<StringSegment> alias, QueryExpression filter, bool index);
}
public class Raven.Server.Documents.Queries.AST.JsonQueryVisitor : QueryVisitor {
    private JsonWriter _writer;
    public JsonQueryVisitor(JsonWriter writer);
    public virtual void VisitNegatedExpression(NegatedExpression expr);
    public virtual void VisitInclude(List`1<QueryExpression> includes);
    public virtual void VisitUpdate(StringSegment update);
    public virtual void VisitSelectFunctionBody(StringSegment func);
    public virtual void VisitSelect(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> select, bool isDistinct);
    public virtual void VisitSelectDistinct();
    private void WriteExpressionList(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> expressions);
    public virtual void VisitLoad(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> load);
    public virtual void VisitOrderBy(List`1<ValueTuple`3<QueryExpression, OrderByFieldType, bool>> orderBy);
    public virtual void VisitDeclaredFunctions(Dictionary`2<string, DeclaredFunction> declaredFunctions);
    public virtual void VisitWhereClause(QueryExpression where);
    public virtual void VisitFilterClause(QueryExpression filter);
    public virtual void VisitCompoundWhereExpression(BinaryExpression where);
    public virtual void VisitMethod(MethodExpression expr);
    public virtual void VisitValue(ValueExpression expr);
    public virtual void VisitIn(InExpression expr);
    public virtual void VisitBetween(BetweenExpression expr);
    public virtual void VisitField(FieldExpression field);
    public virtual void VisitTrue();
    public virtual void VisitSimpleWhereExpression(BinaryExpression expr);
    public virtual void VisitGroupByExpression(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> expressions);
    public virtual void VisitFromClause(FieldExpression from, Nullable`1<StringSegment> alias, QueryExpression filter, bool index);
}
public class Raven.Server.Documents.Queries.AST.MethodExpression : QueryExpression {
    private string _text;
    private string _textWithAlias;
    public StringSegment Name;
    public StringSegment Alias;
    public List`1<QueryExpression> Arguments;
    public MethodExpression(StringSegment name, List`1<QueryExpression> arguments);
    public virtual string ToString();
    public virtual string GetText(IndexQueryServerSide parent);
    public virtual string GetTextWithAlias(IndexQueryServerSide parent);
    public virtual bool Equals(QueryExpression other);
}
public class Raven.Server.Documents.Queries.AST.NegatedExpression : QueryExpression {
    public QueryExpression Expression;
    public NegatedExpression(QueryExpression expr);
    public virtual string ToString();
    public virtual string GetText(IndexQueryServerSide parent);
    public virtual string GetTextWithAlias(IndexQueryServerSide parent);
    public virtual bool Equals(QueryExpression other);
}
public enum Raven.Server.Documents.Queries.AST.NumberToken : Enum {
    public int value__;
    public static NumberToken Long;
    public static NumberToken Double;
}
public enum Raven.Server.Documents.Queries.AST.OperatorType : Enum {
    public int value__;
    public static OperatorType Equal;
    public static OperatorType NotEqual;
    public static OperatorType LessThan;
    public static OperatorType GreaterThan;
    public static OperatorType LessThanEqual;
    public static OperatorType GreaterThanEqual;
    public static OperatorType And;
    public static OperatorType Or;
}
public enum Raven.Server.Documents.Queries.AST.OrderByFieldType : Enum {
    public int value__;
    public static OrderByFieldType Implicit;
    public static OrderByFieldType String;
    public static OrderByFieldType Long;
    public static OrderByFieldType Double;
    public static OrderByFieldType AlphaNumeric;
    public static OrderByFieldType Random;
    public static OrderByFieldType Score;
    public static OrderByFieldType Distance;
    public static OrderByFieldType Custom;
}
public class Raven.Server.Documents.Queries.AST.ParameterToken : object {
    public int TokenStart;
}
public class Raven.Server.Documents.Queries.AST.Query : object {
    public bool IsDistinct;
    public QueryExpression Where;
    public QueryExpression Filter;
    public FromClause From;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> Select;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> Load;
    public List`1<QueryExpression> Include;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`3<QueryExpression, OrderByFieldType, bool>> OrderBy;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> GroupBy;
    public Dictionary`2<string, DeclaredFunction> DeclaredFunctions;
    public string QueryText;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`3<string, Program, HashSet`1<string>> SelectFunctionBody;
    public string UpdateBody;
    public ValueExpression Offset;
    public ValueExpression Limit;
    public ValueExpression FilterLimit;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`3<QueryExpression, OrderByFieldType, bool>> CachedOrderBy;
    public Query ShallowCopy();
    public bool TryAddFunction(DeclaredFunction func);
    public virtual string ToString();
    public bool TryAddTimeSeriesFunction(DeclaredFunction func);
}
public abstract class Raven.Server.Documents.Queries.AST.QueryExpression : object {
    public ExpressionType Type;
    public abstract virtual string ToString();
    public abstract virtual string GetText(IndexQueryServerSide parent);
    public abstract virtual string GetTextWithAlias(IndexQueryServerSide parent);
    public abstract virtual bool Equals(QueryExpression other);
}
[ExtensionAttribute]
public static class Raven.Server.Documents.Queries.AST.QueryExpressionExtensions : object {
    internal static object True;
    internal static object False;
    private static QueryExpressionExtensions();
    private static object Evaluate(QueryExpression q, BlittableJsonReaderObject value);
    [ExtensionAttribute]
public static bool IsMatchedBy(QueryExpression where, BlittableJsonReaderObject value, BlittableJsonReaderObject queryParameters, bool shouldCaseSensitiveStringCompare);
    private static bool IsMatchedBy(BinaryExpression be, BlittableJsonReaderObject value, BlittableJsonReaderObject queryParameters, bool shouldCaseSensitiveStringCompare);
    private static bool AreEqual(object left, object right, bool shouldCaseSensitiveStringCompare);
    private static Nullable`1<int> Compare(object left, object right, bool shouldCaseSensitiveStringCompare);
    private static object GetValue(QueryExpression qe, BlittableJsonReaderObject value, BlittableJsonReaderObject queryParameters);
    public static object GetFieldValue(string value, ValueTokenType type, BlittableJsonReaderObject queryParameters);
    [CompilerGeneratedAttribute]
internal static bool <AreEqual>g__AreEqual|3_0(string s, bool caseSensitive, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static Nullable`1<int> <Compare>g__Compare|4_0(string s, bool caseSensitive, <>c__DisplayClass4_0& );
}
public enum Raven.Server.Documents.Queries.AST.QueryType : Enum {
    public int value__;
    public static QueryType Select;
    public static QueryType Update;
}
public abstract class Raven.Server.Documents.Queries.AST.QueryVisitor : object {
    public void Visit(Query q);
    public virtual void VisitFilterClause(QueryExpression filter);
    public virtual void VisitLimit(ValueExpression limit);
    public virtual void VisitOffset(ValueExpression offset);
    public virtual void VisitInclude(List`1<QueryExpression> includes);
    public virtual void VisitUpdate(StringSegment update);
    public virtual void VisitSelectFunctionBody(StringSegment func);
    public virtual void VisitNegatedExpression(NegatedExpression expr);
    public virtual void VisitSelect(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> select, bool isDistinct);
    public virtual void VisitSelectDistinct();
    public virtual void VisitLoad(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> load);
    public virtual void VisitOrderBy(List`1<ValueTuple`3<QueryExpression, OrderByFieldType, bool>> orderBy);
    public virtual void VisitDeclaredFunctions(Dictionary`2<string, DeclaredFunction> declaredFunctions);
    public virtual void VisitWhereClause(QueryExpression where);
    protected virtual void VisitBinaryExpression(BinaryExpression where);
    public virtual void VisitCompoundWhereExpression(BinaryExpression where);
    public void VisitExpression(QueryExpression expr);
    public virtual void VisitMethod(MethodExpression expr);
    public virtual void VisitValue(ValueExpression expr);
    public virtual void VisitIn(InExpression expr);
    public virtual void VisitBetween(BetweenExpression expr);
    public virtual void VisitField(FieldExpression field);
    public virtual void VisitTrue();
    [DoesNotReturnAttribute]
private static void GetValueThrowInvalidExprType(QueryExpression expr);
    [DoesNotReturnAttribute]
protected static void ThrowInvalidOperationType(BinaryExpression where);
    public virtual void VisitSimpleWhereExpression(BinaryExpression expr);
    public virtual void VisitGroupByExpression(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> expressions);
    public virtual void VisitFromClause(FieldExpression from, Nullable`1<StringSegment> alias, QueryExpression filter, bool index);
    public virtual void VisitDeclaredFunction(string func);
}
public class Raven.Server.Documents.Queries.AST.RangeGroup : ValueType {
    public long Ticks;
    public int Months;
    public Alignment TicksAlignment;
    private static long TicksInMillisecond;
    private DateTime _origin;
    private DateTime _start;
    private DateTime _end;
    private bool _init;
    private static int TicksInOneSecond;
    private long AlignedTicks { get; }
    public DateTime Start { get; }
    public DateTime End { get; }
    private long get_AlignedTicks();
    public DateTime get_Start();
    public DateTime get_End();
    private void AssertInit();
    private void AssertNotInit();
    public void InitializeRange(DateTime origin);
    public void InitializeFullRange(DateTime start, DateTime end);
    private void InitByTicks(DateTime first);
    private void InitByMonth(DateTime start);
    public void MoveToNextRange(DateTime timestamp);
    public void MoveToNextRange();
    public bool WithinRange(DateTime timestamp);
    public bool WithinNextRange(DateTime timestamp);
    public static RangeGroup ParseRangeFromString(string s, Nullable`1<DateTime> from);
    private static void ParseRange(string source, Int32& offset, RangeGroup& range, long duration);
    public static TimeValue ParseTimePeriodFromString(long duration, string source, Int32& offset);
    public static TimeValue ParseTimePeriodFromString(string source, Int32& offset);
    private static void AssertValidDurationInMonths(long duration);
    private static bool TryConsumeMatch(string source, Int32& offset, string additionalMatch);
    private static long ParseNumber(string source, Int32& offset);
    public TimeValue ToTimeValue();
}
public class Raven.Server.Documents.Queries.AST.StringQueryVisitor : QueryVisitor {
    private StringBuilder _sb;
    public StringQueryVisitor(StringBuilder sb);
    public virtual void VisitLimit(ValueExpression limit);
    public virtual void VisitOffset(ValueExpression offset);
    public virtual void VisitInclude(List`1<QueryExpression> includes);
    public virtual void VisitUpdate(StringSegment update);
    public virtual void VisitSelectFunctionBody(StringSegment func);
    public virtual void VisitSelect(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> select, bool isDistinct);
    public virtual void VisitSelectDistinct();
    private void VisitExpressionList(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> expressions);
    public virtual void VisitLoad(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> load);
    public virtual void VisitOrderBy(List`1<ValueTuple`3<QueryExpression, OrderByFieldType, bool>> orderBy);
    public virtual void VisitDeclaredFunction(string func);
    public virtual void VisitWhereClause(QueryExpression where);
    public virtual void VisitFilterClause(QueryExpression where);
    public virtual void VisitNegatedExpression(NegatedExpression expr);
    public virtual void VisitCompoundWhereExpression(BinaryExpression where);
    private static void InvalidOperatorTypeForWhere(BinaryExpression where);
    public virtual void VisitMethod(MethodExpression expr);
    public virtual void VisitValue(ValueExpression expr);
    public virtual void VisitIn(InExpression expr);
    public virtual void VisitBetween(BetweenExpression expr);
    private void EnsureSpace();
    private void EnsureLine();
    public virtual void VisitField(FieldExpression field);
    public virtual void VisitTrue();
    public virtual void VisitSimpleWhereExpression(BinaryExpression expr);
    public virtual void VisitGroupByExpression(List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> expressions);
    private static bool RequiresQuotes(StringSegment s);
    public virtual void VisitFromClause(FieldExpression from, Nullable`1<StringSegment> alias, QueryExpression filter, bool index);
    private void AppendStringSegment(StringSegment stringSegment);
}
public class Raven.Server.Documents.Queries.AST.TimeSeriesBetweenExpression : BetweenExpression {
    [CompilerGeneratedAttribute]
private QueryExpression <MinExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryExpression <MaxExpression>k__BackingField;
    public QueryExpression MinExpression { get; }
    public QueryExpression MaxExpression { get; }
    public TimeSeriesBetweenExpression(QueryExpression source, QueryExpression min, QueryExpression max);
    [CompilerGeneratedAttribute]
public QueryExpression get_MinExpression();
    [CompilerGeneratedAttribute]
public QueryExpression get_MaxExpression();
    public virtual string ToString();
    public virtual string GetText(IndexQueryServerSide parent);
    public virtual bool Equals(QueryExpression other);
}
public class Raven.Server.Documents.Queries.AST.TimeSeriesFunction : object {
    public TimeSeriesBetweenExpression Between;
    public QueryExpression Source;
    public QueryExpression Where;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> Select;
    public Nullable`1<StringSegment> LoadTagAs;
    public ValueExpression Last;
    public ValueExpression First;
    public ValueExpression Offset;
    public ValueExpression Scale;
    public TimeSeriesGroupBy GroupBy;
}
public class Raven.Server.Documents.Queries.AST.TimeSeriesGroupBy : ValueType {
    public ValueExpression TimePeriod;
    public bool Tag;
    public FieldExpression Field;
    public MethodExpression With;
    public bool HasGroupByTag { get; }
    public bool get_HasGroupByTag();
}
public class Raven.Server.Documents.Queries.AST.TrueExpression : QueryExpression {
    public virtual string ToString();
    public virtual string GetText(IndexQueryServerSide parent);
    public virtual string GetTextWithAlias(IndexQueryServerSide parent);
    public virtual bool Equals(QueryExpression other);
}
public class Raven.Server.Documents.Queries.AST.ValueExpression : QueryExpression {
    public StringSegment Token;
    public ValueTokenType Value;
    public ValueExpression(StringSegment token, ValueTokenType type);
    public virtual string ToString();
    public virtual string GetText(IndexQueryServerSide parent);
    public virtual string GetTextWithAlias(IndexQueryServerSide parent);
    public virtual bool Equals(QueryExpression other);
    public object GetValue(BlittableJsonReaderObject queryParameters);
}
public enum Raven.Server.Documents.Queries.AST.ValueTokenType : Enum {
    public int value__;
    public static ValueTokenType Parameter;
    public static ValueTokenType Long;
    public static ValueTokenType Double;
    public static ValueTokenType String;
    public static ValueTokenType True;
    public static ValueTokenType False;
    public static ValueTokenType Null;
}
public class Raven.Server.Documents.Queries.CollectionQueryEnumerable : object {
    private DocumentDatabase _database;
    private DocumentsStorage _documents;
    private FieldsToFetch _fieldsToFetch;
    private DocumentsOperationContext _context;
    private IncludeDocumentsCommand _includeDocumentsCommand;
    private IncludeRevisionsCommand _includeRevisionsCommand;
    private IncludeCompareExchangeValuesCommand _includeCompareExchangeValuesCommand;
    private Reference`1<long> _totalResults;
    private Reference`1<int> _scannedResults;
    private Reference`1<long> _skippedResults;
    private CancellationToken _token;
    private string _collection;
    private IndexQueryServerSide _query;
    private QueryTimingsScope _queryTimings;
    private bool _isAllDocsCollection;
    [CompilerGeneratedAttribute]
private string <StartAfterId>k__BackingField;
    [CompilerGeneratedAttribute]
private Reference`1<long> <AlreadySeenIdsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentFields <Fields>k__BackingField;
    public string StartAfterId { get; public set; }
    public Reference`1<long> AlreadySeenIdsCount { get; public set; }
    public DocumentFields Fields { get; public set; }
    public CollectionQueryEnumerable(DocumentDatabase database, DocumentsStorage documents, FieldsToFetch fieldsToFetch, string collection, IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsOperationContext context, IncludeDocumentsCommand includeDocumentsCommand, IncludeRevisionsCommand includeRevisionsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, Reference`1<long> totalResults, Reference`1<int> scannedResults, Reference`1<long> skippedResults, CancellationToken token);
    [CompilerGeneratedAttribute]
public string get_StartAfterId();
    [CompilerGeneratedAttribute]
public void set_StartAfterId(string value);
    [CompilerGeneratedAttribute]
public Reference`1<long> get_AlreadySeenIdsCount();
    [CompilerGeneratedAttribute]
public void set_AlreadySeenIdsCount(Reference`1<long> value);
    [CompilerGeneratedAttribute]
public DocumentFields get_Fields();
    [CompilerGeneratedAttribute]
public void set_Fields(DocumentFields value);
    public sealed virtual IEnumerator`1<Document> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Raven.Server.Documents.Queries.Counters.CounterIncludesField : object {
    public Dictionary`2<string, HashSet`1<string>> Counters;
    public void AddCounter(string counter, string sourcePath);
}
public class Raven.Server.Documents.Queries.DocumentIdQueryResult : DocumentQueryResult {
    private DeterminateProgress _progress;
    private Action`1<DeterminateProgress> _onProgress;
    private OperationCancelToken _token;
    public Queue`1<string> DocumentIds;
    public DocumentIdQueryResult(DeterminateProgress progress, Action`1<DeterminateProgress> onProgress, Nullable`1<long> indexDefinitionRaftIndex, OperationCancelToken token);
    public virtual ValueTask AddResultAsync(Document result, CancellationToken token);
}
public class Raven.Server.Documents.Queries.DocumentQueryResult : QueryResultServerSide`1<Document> {
    public static DocumentQueryResult NotModifiedResult;
    private ICounterIncludes _counterIncludes;
    private IRevisionIncludes _revisionIncludes;
    private ITimeSeriesIncludes _timeSeriesIncludes;
    private Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> _compareExchangeValueIncludes;
    public bool SupportsInclude { get; }
    public bool SupportsHighlighting { get; }
    public bool SupportsExplanations { get; }
    public bool SupportsExceptionHandling { get; }
    public DocumentQueryResult(Nullable`1<long> indexDefinitionRaftIndex);
    private static DocumentQueryResult();
    public virtual bool get_SupportsInclude();
    public virtual bool get_SupportsHighlighting();
    public virtual bool get_SupportsExplanations();
    public virtual bool get_SupportsExceptionHandling();
    public virtual void AddCounterIncludes(ICounterIncludes includeCountersCommand);
    public virtual ICounterIncludes GetCounterIncludes();
    public virtual void AddTimeSeriesIncludes(ITimeSeriesIncludes includeTimeSeriesCommand);
    public virtual ITimeSeriesIncludes GetTimeSeriesIncludes();
    public virtual void AddCompareExchangeValueIncludes(ICompareExchangeValueIncludes values);
    public virtual Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> GetCompareExchangeValueIncludes();
    public virtual void AddRevisionIncludes(IRevisionIncludes revisions);
    public virtual IRevisionIncludes GetRevisionIncludes();
    public virtual ValueTask AddResultAsync(Document result, CancellationToken token);
    public virtual void AddHighlightings(Dictionary`2<string, Dictionary`2<string, String[]>> highlightings);
    public virtual void AddExplanation(ExplanationResult explanation);
    public virtual ValueTask HandleExceptionAsync(Exception e, CancellationToken token);
    private static string CreateExplanation(Explanation explanation);
}
public class Raven.Server.Documents.Queries.Dynamic.CollectionQueryResultsIterationState : PulsedEnumerationState`1<Document> {
    public long Start;
    public long Take;
    public CollectionQueryResultsIterationState(DocumentsOperationContext context, Size pulseLimit);
    public virtual void OnMoveNext(Document current);
}
public class Raven.Server.Documents.Queries.Dynamic.CollectionQueryRunner : AbstractDatabaseQueryRunner {
    public static int UnboundedQueryResultMarker;
    public CollectionQueryRunner(DocumentDatabase database);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.CollectionQueryRunner/<ExecuteQuery>d__2")]
public virtual Task`1<DocumentQueryResult> ExecuteQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.CollectionQueryRunner/<ExecuteStreamQuery>d__3")]
public virtual Task ExecuteStreamQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<Document> writer, OperationCancelToken token);
    public virtual Task`1<IndexEntriesQueryResult> ExecuteIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, bool ignoreLimit, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    public virtual Task ExecuteStreamIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<BlittableJsonReaderObject> writer, bool ignoreLimit, OperationCancelToken token);
    public virtual Task`1<IOperationResult> ExecuteDeleteQuery(IndexQueryServerSide query, QueryOperationOptions options, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    public virtual Task`1<IOperationResult> ExecutePatchQuery(IndexQueryServerSide query, QueryOperationOptions options, PatchRequest patch, BlittableJsonReaderObject patchArgs, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    public virtual Task`1<SuggestionQueryResult> ExecuteSuggestionQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.CollectionQueryRunner/<ExecuteCollectionQueryAsync>d__9")]
private ValueTask ExecuteCollectionQueryAsync(QueryResultServerSide`1<Document> resultToFill, IndexQueryServerSide query, string collection, QueryOperationContext context, bool pulseReadingTransaction, CancellationToken token);
    private void FillCountOfResultsAndIndexEtag(QueryResultServerSide`1<Document> resultToFill, QueryMetadata query, QueryOperationContext context);
    private static string GetCollectionName(IndexQueryServerSide query, String& indexName);
}
public class Raven.Server.Documents.Queries.Dynamic.DynamicQueryMapping : object {
    [CompilerGeneratedAttribute]
private string <ForCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DynamicQueryMappingItem> <MapFields>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DynamicQueryMappingItem> <GroupByFields>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <GroupByFieldNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGroupBy>k__BackingField;
    public List`1<Index> SupersededIndexes;
    public string ForCollection { get; private set; }
    public Dictionary`2<string, DynamicQueryMappingItem> MapFields { get; private set; }
    public Dictionary`2<string, DynamicQueryMappingItem> GroupByFields { get; private set; }
    public List`1<string> GroupByFieldNames { get; private set; }
    public bool IsGroupBy { get; private set; }
    [CompilerGeneratedAttribute]
public string get_ForCollection();
    [CompilerGeneratedAttribute]
private void set_ForCollection(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DynamicQueryMappingItem> get_MapFields();
    [CompilerGeneratedAttribute]
private void set_MapFields(Dictionary`2<string, DynamicQueryMappingItem> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DynamicQueryMappingItem> get_GroupByFields();
    [CompilerGeneratedAttribute]
private void set_GroupByFields(Dictionary`2<string, DynamicQueryMappingItem> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_GroupByFieldNames();
    [CompilerGeneratedAttribute]
private void set_GroupByFieldNames(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_IsGroupBy();
    [CompilerGeneratedAttribute]
private void set_IsGroupBy(bool value);
    internal AutoIndexDefinitionBaseServerSide CreateAutoIndexDefinition();
    internal void ExtendMappingBasedOn(AutoIndexDefinitionBaseServerSide definitionOfExistingIndex);
    public static DynamicQueryMapping Create(IndexQueryServerSide query);
    public static DynamicQueryMapping Create(Index index);
    private static Dictionary`2<string, DynamicQueryMappingItem> CreateGroupByFields(IndexQueryServerSide query, Dictionary`2<string, DynamicQueryMappingItem> mapFields);
    [DoesNotReturnAttribute]
private static void ThrowUnknownAggregationOperation(AggregationOperation operation);
    [CompilerGeneratedAttribute]
internal static void <ExtendMappingBasedOn>g__Update|22_0(Dictionary`2<string, DynamicQueryMappingItem> fields, Dictionary`2<string, T> indexFields, bool isGroupBy);
}
public class Raven.Server.Documents.Queries.Dynamic.DynamicQueryMappingItem : object {
    public QueryFieldName Name;
    public bool IsFullTextSearch;
    public bool IsExactSearch;
    public bool HasSuggestions;
    public bool HasHighlighting;
    public bool IsSpecifiedInWhere;
    public AutoSpatialOptions Spatial;
    [CompilerGeneratedAttribute]
private AggregationOperation <AggregationOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private GroupByArrayBehavior <GroupByArrayBehavior>k__BackingField;
    public AggregationOperation AggregationOperation { get; private set; }
    public GroupByArrayBehavior GroupByArrayBehavior { get; }
    private DynamicQueryMappingItem(QueryFieldName name, AggregationOperation aggregationOperation, GroupByArrayBehavior groupByArrayBehavior, bool isSpecifiedInWhere, bool isFullTextSearch, bool isExactSearch, bool hasHighlighting, bool hasSuggestions, AutoSpatialOptions spatial);
    [CompilerGeneratedAttribute]
public AggregationOperation get_AggregationOperation();
    [CompilerGeneratedAttribute]
private void set_AggregationOperation(AggregationOperation value);
    [CompilerGeneratedAttribute]
public GroupByArrayBehavior get_GroupByArrayBehavior();
    public static DynamicQueryMappingItem Create(QueryFieldName name, AggregationOperation aggregation);
    public static DynamicQueryMappingItem Create(QueryFieldName name, AggregationOperation aggregation, bool isFullTextSearch, bool isExactSearch, bool hasHighlighting, bool hasSuggestions, AutoSpatialOptions spatial);
    public static DynamicQueryMappingItem Create(QueryFieldName name, AggregationOperation aggregation, Dictionary`2<QueryFieldName, WhereField> whereFields);
    public static DynamicQueryMappingItem CreateGroupBy(QueryFieldName name, GroupByArrayBehavior groupByArrayBehavior, Dictionary`2<QueryFieldName, WhereField> whereFields);
    public static DynamicQueryMappingItem CreateGroupBy(QueryFieldName name, GroupByArrayBehavior groupByArrayBehavior, bool isSpecifiedInWhere, bool isFullTextSearch, bool isExactSearch);
    public void SetAggregation(AggregationOperation aggregation);
}
public class Raven.Server.Documents.Queries.Dynamic.DynamicQueryMatchResult : object {
    public static DynamicQueryMatchResult Failure;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicQueryMatchType <MatchType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastMappedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfMappedFields>k__BackingField;
    public string IndexName { get; public set; }
    public DynamicQueryMatchType MatchType { get; public set; }
    public long LastMappedEtag { get; public set; }
    public long NumberOfMappedFields { get; public set; }
    public DynamicQueryMatchResult(string match, DynamicQueryMatchType matchType);
    private static DynamicQueryMatchResult();
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public DynamicQueryMatchType get_MatchType();
    [CompilerGeneratedAttribute]
public void set_MatchType(DynamicQueryMatchType value);
    [CompilerGeneratedAttribute]
public long get_LastMappedEtag();
    [CompilerGeneratedAttribute]
public void set_LastMappedEtag(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfMappedFields();
    [CompilerGeneratedAttribute]
public void set_NumberOfMappedFields(long value);
    public bool IsComplete();
}
public enum Raven.Server.Documents.Queries.Dynamic.DynamicQueryMatchType : Enum {
    public int value__;
    public static DynamicQueryMatchType Failure;
    public static DynamicQueryMatchType Partial;
    public static DynamicQueryMatchType CompleteButIdle;
    public static DynamicQueryMatchType Complete;
}
public class Raven.Server.Documents.Queries.Dynamic.DynamicQueryRunner : AbstractDatabaseQueryRunner {
    private IndexStore _indexStore;
    public DynamicQueryRunner(DocumentDatabase database);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.DynamicQueryRunner/<ExecuteStreamQuery>d__2")]
public virtual Task ExecuteStreamQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<Document> writer, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.DynamicQueryRunner/<ExecuteQuery>d__3")]
public virtual Task`1<DocumentQueryResult> ExecuteQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.DynamicQueryRunner/<ExecuteIndexEntriesQuery>d__4")]
public virtual Task`1<IndexEntriesQueryResult> ExecuteIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, bool ignoreLimit, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    public virtual Task ExecuteStreamIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<BlittableJsonReaderObject> writer, bool ignoreLimit, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.DynamicQueryRunner/<ExecuteDeleteQuery>d__6")]
public virtual Task`1<IOperationResult> ExecuteDeleteQuery(IndexQueryServerSide query, QueryOperationOptions options, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.DynamicQueryRunner/<ExecutePatchQuery>d__7")]
public virtual Task`1<IOperationResult> ExecutePatchQuery(IndexQueryServerSide query, QueryOperationOptions options, PatchRequest patch, BlittableJsonReaderObject patchArgs, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.DynamicQueryRunner/<ExecuteSuggestionQuery>d__8")]
public virtual Task`1<SuggestionQueryResult> ExecuteSuggestionQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.DynamicQueryRunner/<MatchIndex>d__9")]
public Task`1<ValueTuple`2<Nullable`1<long>, Index>> MatchIndex(IndexQueryServerSide query, bool createAutoIndexIfNoMatchIsFound, Nullable`1<TimeSpan> customStalenessWaitTimeout, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.DynamicQueryRunner/<CreateAutoIndexIfNeeded>d__10")]
private Task`1<ValueTuple`2<Nullable`1<long>, Index>> CreateAutoIndexIfNeeded(IndexQueryServerSide query, bool createAutoIndexIfNoMatchIsFound, Nullable`1<TimeSpan> customStalenessWaitTimeout, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.Dynamic.DynamicQueryRunner/<CleanupSupersededAutoIndexes>d__11")]
private Task CleanupSupersededAutoIndexes(Index index, DynamicQueryMapping map, string raftRequestId, CancellationToken token);
    public List`1<Explanation> ExplainIndexSelection(IndexQueryServerSide query, String& indexName);
    private bool TryMatchExistingIndexToQuery(DynamicQueryMapping map, Index& index);
}
public class Raven.Server.Documents.Queries.Dynamic.DynamicQueryToIndexMatcher : object {
    private IndexStore _indexStore;
    public DynamicQueryToIndexMatcher(IndexStore indexStore);
    public DynamicQueryMatchResult Match(DynamicQueryMapping query, List`1<Explanation> explanations);
    internal DynamicQueryMatchResult ConsiderUsageOfIndex(DynamicQueryMapping query, AutoIndexDefinitionBaseServerSide definition, List`1<Explanation> explanations);
    private static DynamicQueryMatchType AssertMapReduceFields(DynamicQueryMapping query, AutoMapReduceIndexDefinition definition, DynamicQueryMatchType currentBestState, List`1<Explanation> explanations);
    [CompilerGeneratedAttribute]
internal static bool <Match>g__BetterMatchAvailable|3_0(Boolean& bothComplete, <>c__DisplayClass3_0& , <>c__DisplayClass3_1& );
}
public class Raven.Server.Documents.Queries.ExecutingQueryInfo : object {
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexQuery <QueryInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private long <QueryId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStreaming>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationCancelToken <Token>k__BackingField;
    private Stopwatch _stopwatch;
    public DateTime StartTime { get; }
    public string IndexName { get; public set; }
    public IIndexQuery QueryInfo { get; }
    public long QueryId { get; }
    public bool IsStreaming { get; }
    public OperationCancelToken Token { get; }
    public long DurationInMs { get; }
    public TimeSpan Duration { get; }
    public ExecutingQueryInfo(DateTime startTime, string indexName, IIndexQuery queryInfo, long queryId, bool isStreaming, OperationCancelToken token);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public IIndexQuery get_QueryInfo();
    [CompilerGeneratedAttribute]
public long get_QueryId();
    [CompilerGeneratedAttribute]
public bool get_IsStreaming();
    [CompilerGeneratedAttribute]
public OperationCancelToken get_Token();
    public long get_DurationInMs();
    public TimeSpan get_Duration();
    public void Write(TWriter writer, JsonOperationContext context);
}
public class Raven.Server.Documents.Queries.Explanation.ExplanationField : object {
    private string _optionsAsStringOrParameterName;
    private ValueTokenType _optionsType;
    private ExplanationOptions _options;
    public ExplanationOptions GetOptions(JsonOperationContext context, BlittableJsonReaderObject parameters);
    public void AddOptions(string optionsAsStringOrParameterName, ValueTokenType type);
}
public class Raven.Server.Documents.Queries.Explanation.ExplanationResult : object {
    public string Key;
    public Explanation Explanation;
}
public static class Raven.Server.Documents.Queries.Facets.FacetedQueryHelper : object {
    public static string GetRangeName(string field, string text);
}
public static class Raven.Server.Documents.Queries.Facets.FacetedQueryParser : object {
    public static Dictionary`2<string, FacetResult> Parse(JsonOperationContext context, FacetQuery query, SearchEngineType searchEngineType);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.Facets.FacetedQueryParser/<ProcessFacetSetup>d__1")]
private static IEnumerable`1<ValueTuple`2<FacetBase, List`1<QueryExpression>>> ProcessFacetSetup(FacetSetup setup);
    private static FacetResult ProcessFacet(FacetBase facet, List`1<QueryExpression> facetRanges, FacetQuery query, SearchEngineType searchEngineType);
    private static ParsedRange ParseRange(QueryExpression expression, FacetQuery query, SearchEngineType searchEngineType, RangeType& type);
    private static string ExtractFieldName(BinaryExpression be, FacetQuery query);
    private static ValueTuple`2<string, RangeType> ConvertFieldValueForLucene(string value, ValueTokenType type, BlittableJsonReaderObject queryParameters);
    private static ValueTuple`2<string, RangeType> ConvertFieldValueForCorax(string value, ValueTokenType type, BlittableJsonReaderObject queryParameters);
    [DoesNotReturnAttribute]
private static void ThrowDifferentTypesOfRangeValues(FacetQuery query, RangeType type1, RangeType type2, string field);
    [DoesNotReturnAttribute]
private static void ThrowUnknownFacetType(FacetBase facet);
    [DoesNotReturnAttribute]
private static void ThrowWhenOptionsAreUsedForRangeFacet();
    [DoesNotReturnAttribute]
private static void ThrowRangeDefinedOnDifferentFields(FacetQuery query, string fieldName, string differentField);
    [DoesNotReturnAttribute]
private static void ThrowInvalidFieldInFacetQuery(FacetQuery query, SelectField field);
    [DoesNotReturnAttribute]
private static void ThrowUnsupportedRangeOperator(FacetQuery query, OperatorType op);
    [DoesNotReturnAttribute]
private static void ThrowUnsupportedRangeExpression(FacetQuery query, QueryExpression expression);
    [CompilerGeneratedAttribute]
internal static ParsedRange <ParseRange>g__GetForSearchEngine|3_0(ParsedRange inner, <>c__DisplayClass3_0& );
}
public class Raven.Server.Documents.Queries.Facets.FacetedQueryResult : QueryResult`2<List`1<FacetResult>, List`1<Document>> {
    public static FacetedQueryResult NotModifiedResult;
    [CompilerGeneratedAttribute]
private bool <NotModified>k__BackingField;
    public bool NotModified { get; private set; }
    private static FacetedQueryResult();
    [CompilerGeneratedAttribute]
public bool get_NotModified();
    [CompilerGeneratedAttribute]
private void set_NotModified(bool value);
}
public class Raven.Server.Documents.Queries.Facets.FacetField : SelectField {
    private string _optionsAsStringOrParameterName;
    private ValueTokenType _optionsType;
    public Dictionary`2<FacetAggregation, HashSet`1<FacetAggregationField>> Aggregations;
    public List`1<QueryExpression> Ranges;
    public string FacetSetupDocumentId;
    private FacetOptions _options;
    internal bool HasOptions { get; }
    internal bool get_HasOptions();
    public FacetOptions GetOptions(JsonOperationContext context, BlittableJsonReaderObject parameters);
    public void AddAggregation(FacetAggregation aggregation, QueryFieldName name, StringSegment displayName);
    public void AddOptions(string optionsAsStringOrParameterName, ValueTokenType type);
}
public class Raven.Server.Documents.Queries.Facets.FacetQuery : object {
    public IndexQueryServerSide Query;
    public Dictionary`2<string, FacetSetup> Facets;
    public long FacetsEtag;
    public bool Legacy;
    private FacetQuery(IndexQueryServerSide query, Dictionary`2<string, FacetSetup> facets, long facetsEtag);
    public static FacetQuery Create(DocumentsOperationContext context, IndexQueryServerSide query);
}
public static class Raven.Server.Documents.Queries.FieldOptionsHelper : object {
    public static T GetOptions(string optionsAsStringOrParameterName, ValueTokenType optionsType, BlittableJsonReaderObject parameters, JsonOperationContext context);
    public static void ValidateOptions(string optionsAsStringOrParameterName, ValueTokenType optionsType);
}
public class Raven.Server.Documents.Queries.FieldsToFetch : object {
    public Dictionary`2<string, FieldToFetch> Fields;
    public Dictionary`2<string, IndexField> IndexFields;
    public bool AnyDynamicIndexFields;
    public bool ExtractAllFromIndex;
    public bool AnyExtractableFromIndex;
    public bool AnyTimeSeries;
    public bool SingleBodyOrMethodWithNoAlias;
    public bool IsProjection;
    public bool IsDistinct;
    public ProjectionOptions Projection;
    public FieldsToFetch(IndexQueryServerSide query, IndexDefinitionBaseServerSide indexDefinition, IndexType indexType);
    private static FieldToFetch GetFieldToFetch(IndexDefinitionBaseServerSide indexDefinition, QueryMetadata metadata, Nullable`1<ProjectionBehavior> projectionBehavior, SelectField selectField, Dictionary`2<string, FieldToFetch> results, IndexType indexType, String& selectFieldKey, Boolean& anyExtractableFromIndex, Boolean& extractAllStoredFields, Boolean& anyTimeSeries);
    private static bool ShouldTryToExtractBySourceAliasName(string selectFieldName, SelectField selectField);
    [DoesNotReturnAttribute]
private static void ThrowInvalidFetchAllStoredDocuments();
    private static Dictionary`2<string, FieldToFetch> GetFieldsToFetch(QueryMetadata metadata, Nullable`1<ProjectionBehavior> projectionBehavior, IndexDefinitionBaseServerSide indexDefinition, IndexType indexType, Boolean& anyExtractableFromIndex, Boolean& extractAllStoredFields, Boolean& singleFieldNoAlias, Boolean& anyTimeSeries);
    public bool ContainsField(string name);
}
public class Raven.Server.Documents.Queries.GroupByField : object {
    public QueryFieldName Name;
    public GroupByArrayBehavior GroupByArrayBehavior;
    public string Alias;
    public GroupByField(QueryFieldName name, GroupByArrayBehavior byArrayBehavior, string alias);
}
public class Raven.Server.Documents.Queries.HasSpecialMethodVisitor : EsprimaVisitor {
    private QueryMetadata _queryMetadata;
    public HasSpecialMethodVisitor(QueryMetadata queryMetadata);
    public virtual void VisitCallExpression(CallExpression callExpression);
}
public class Raven.Server.Documents.Queries.Highlightings.HighlightingField : object {
    private string _optionsAsStringOrParameterName;
    private ValueTokenType _optionsType;
    private HighlightingOptions _options;
    private int _fragmentCount;
    private int _fragmentLength;
    public QueryFieldName Field;
    public int FragmentCount { get; }
    public int FragmentLength { get; }
    public HighlightingField(QueryFieldName field);
    public int get_FragmentCount();
    public int get_FragmentLength();
    public HighlightingOptions GetOptions(JsonOperationContext context, BlittableJsonReaderObject parameters);
    public void AddOptions(string optionsAsStringOrParameterName, ValueTokenType type);
    public void AddFragmentLength(string fragmentLengthAsString, ValueTokenType type);
    public void AddFragmentCount(string fragmentCountAsString, ValueTokenType type);
}
public class Raven.Server.Documents.Queries.IndexEntriesQueryResult : QueryResultServerSide`1<BlittableJsonReaderObject> {
    public static IndexEntriesQueryResult NotModifiedResult;
    public bool SupportsExceptionHandling { get; }
    public bool SupportsInclude { get; }
    public bool SupportsHighlighting { get; }
    public bool SupportsExplanations { get; }
    public IndexEntriesQueryResult(Nullable`1<long> indexDefinitionRaftIndex);
    private static IndexEntriesQueryResult();
    public virtual ValueTask AddResultAsync(BlittableJsonReaderObject result, CancellationToken token);
    public virtual void AddHighlightings(Dictionary`2<string, Dictionary`2<string, String[]>> highlightings);
    public virtual void AddExplanation(ExplanationResult explanationResult);
    public virtual ValueTask HandleExceptionAsync(Exception e, CancellationToken token);
    public virtual void AddCounterIncludes(ICounterIncludes includeCountersCommand);
    public virtual ICounterIncludes GetCounterIncludes();
    public virtual void AddTimeSeriesIncludes(ITimeSeriesIncludes includeTimeSeriesCommand);
    public virtual ITimeSeriesIncludes GetTimeSeriesIncludes();
    public virtual void AddCompareExchangeValueIncludes(ICompareExchangeValueIncludes values);
    public virtual Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> GetCompareExchangeValueIncludes();
    public virtual IRevisionIncludes GetRevisionIncludes();
    public virtual void AddRevisionIncludes(IRevisionIncludes revisions);
    public virtual bool get_SupportsExceptionHandling();
    public virtual bool get_SupportsInclude();
    public virtual bool get_SupportsHighlighting();
    public virtual bool get_SupportsExplanations();
}
public enum Raven.Server.Documents.Queries.IndexFieldType : Enum {
    public int value__;
    public static IndexFieldType String;
    public static IndexFieldType Long;
    public static IndexFieldType Double;
}
public class Raven.Server.Documents.Queries.IndexQueryServerSide : IndexQuery`1<BlittableJsonReaderObject> {
    [JsonDeserializationIgnoreAttribute]
public QueryResultReturnOptions ReturnOptions;
    [JsonDeserializationIgnoreAttribute]
public Nullable`1<long> Offset;
    [JsonDeserializationIgnoreAttribute]
public Nullable`1<long> Limit;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <FilterLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryTimingsScope <Timings>k__BackingField;
    [JsonDeserializationIgnoreAttribute]
public SpatialDistanceFieldComparator Distances;
    public long Start;
    public long PageSize;
    public Nullable`1<DocumentFields> DocumentFields;
    public List`1<string> Diagnostics;
    public string ClientVersion;
    public bool AddTimeSeriesNames;
    public bool DisableAutoIndexCreation;
    public bool IsStream;
    public string ClientQueryId;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <SourceQueryJson>k__BackingField;
    private BlittableJsonReaderObject _asJson;
    [JsonDeserializationIgnoreAttribute]
public Nullable`1<long> FilterLimit { get; public set; }
    [JsonDeserializationIgnoreAttribute]
public QueryMetadata Metadata { get; private set; }
    [JsonDeserializationIgnoreAttribute]
public QueryTimingsScope Timings { get; private set; }
    public string ServerSideQuery { get; }
    [JsonDeserializationIgnoreAttribute]
public BlittableJsonReaderObject SourceQueryJson { get; public set; }
    [JsonDeserializationIgnoreAttribute]
public bool IsCountQuery { get; }
    public IndexQueryServerSide(QueryMetadata metadata);
    public IndexQueryServerSide(string query, BlittableJsonReaderObject queryParameters);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_FilterLimit();
    [CompilerGeneratedAttribute]
public void set_FilterLimit(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public QueryMetadata get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(QueryMetadata value);
    [CompilerGeneratedAttribute]
public QueryTimingsScope get_Timings();
    [CompilerGeneratedAttribute]
private void set_Timings(QueryTimingsScope value);
    public static void AddStringToHttpContext(HttpContext httpContext, string str, TrafficWatchChangeType type);
    public string get_ServerSideQuery();
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_SourceQueryJson();
    [CompilerGeneratedAttribute]
public void set_SourceQueryJson(BlittableJsonReaderObject value);
    public bool get_IsCountQuery();
    public BlittableJsonReaderObject ToJson(JsonOperationContext context);
    public static IndexQueryServerSide Create(HttpContext httpContext, BlittableJsonReaderObject json, QueryMetadataCache cache, RequestTimeTracker tracker, bool addSpatialProperties, string clientQueryId, QueryType queryType);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.IndexQueryServerSide/<CreateAsync>d__40")]
public static Task`1<IndexQueryServerSide> CreateAsync(HttpContext httpContext, long start, long pageSize, JsonOperationContext context, RequestTimeTracker tracker, bool addSpatialProperties, string clientQueryId, string overrideQuery);
    private static void SetupTimings(IndexQueryServerSide indexQuery);
    private static void SetupTracker(IndexQueryServerSide indexQuery, RequestTimeTracker tracker);
    private static void SetupClientVersion(IndexQueryServerSide indexQuery, HttpContext httpContext);
    private static void AssertPaging(IndexQueryServerSide indexQuery);
    public ValueTuple`2<List`1<Slice>, string> ExtractIdsFromQuery(ServerStore serverStore, ByteStringContext allocator, AbstractCompareExchangeStorage compareExchangeStorage);
    [CompilerGeneratedAttribute]
internal static void <Create>g__SetupPagingFromQueryMetadata|39_0(<>c__DisplayClass39_0& );
    [CompilerGeneratedAttribute]
internal static void <CreateAsync>g__SetupPagingFromQueryMetadata|40_0(<>c__DisplayClass40_0& );
}
public class Raven.Server.Documents.Queries.InvalidQueryRunner : AbstractDatabaseQueryRunner {
    internal static string ErrorMessage;
    public InvalidQueryRunner(DocumentDatabase database);
    public virtual Task`1<DocumentQueryResult> ExecuteQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    public virtual Task ExecuteStreamQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<Document> writer, OperationCancelToken token);
    public virtual Task`1<IndexEntriesQueryResult> ExecuteIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, bool ignoreLimit, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    public virtual Task ExecuteStreamIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<BlittableJsonReaderObject> writer, bool ignoreLimit, OperationCancelToken token);
    public virtual Task`1<IOperationResult> ExecuteDeleteQuery(IndexQueryServerSide query, QueryOperationOptions options, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    public virtual Task`1<IOperationResult> ExecutePatchQuery(IndexQueryServerSide query, QueryOperationOptions options, PatchRequest patch, BlittableJsonReaderObject patchArgs, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    public virtual Task`1<SuggestionQueryResult> ExecuteSuggestionQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
}
public interface Raven.Server.Documents.Queries.IStreamQueryResultWriter`1 {
    public bool SupportStatistics { get; }
    public abstract virtual void StartResponse();
    public abstract virtual void StartResults();
    public abstract virtual void EndResults();
    public abstract virtual ValueTask AddResultAsync(T res, CancellationToken token);
    public abstract virtual void EndResponse();
    public abstract virtual ValueTask WriteErrorAsync(Exception e);
    public abstract virtual ValueTask WriteErrorAsync(string error);
    public abstract virtual void WriteQueryStatistics(long resultEtag, bool isStale, string indexName, long totalResults, DateTime timestamp);
    public abstract virtual bool get_SupportStatistics();
}
public class Raven.Server.Documents.Queries.LiveRunningQueriesCollector : LivePerformanceCollector`1<ExecutingQueryCollection> {
    private ServerStore _serverStore;
    private HashSet`1<string> _dbNames;
    protected TimeSpan SleepTime { get; }
    public LiveRunningQueriesCollector(ServerStore serverStore, HashSet`1<string> dbNames);
    protected virtual TimeSpan get_SleepTime();
    protected virtual bool ShouldEnqueue(List`1<ExecutingQueryCollection> items);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.LiveRunningQueriesCollector/<StartCollectingStats>d__6")]
protected virtual Task StartCollectingStats();
    protected virtual List`1<ExecutingQueryCollection> PreparePerformanceStats();
    protected virtual void WriteStats(List`1<ExecutingQueryCollection> stats, AsyncBlittableJsonTextWriter writer, JsonOperationContext context);
    [CompilerGeneratedAttribute]
private bool <PreparePerformanceStats>g__ShouldFilterOut|7_0(string database);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.LiveRunningQueriesCollector/<<PreparePerformanceStats>g__GetQueries|7_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<ExecutingQueryCollection> <PreparePerformanceStats>g__GetQueries|7_1(string database, AbstractQueryRunner queryRunner);
}
public class Raven.Server.Documents.Queries.LuceneIntegration.CachingQuery : Query {
    private static ConditionalWeakTable`2<IndexReader, IndexReaderCachedQueries> CacheByReader;
    public static MultipleUseFlag InLowMemoryMode;
    private static CacheByReaderCleaner Cleaner;
    private Query _inner;
    private Index _index;
    private string _query;
    public float Boost { get; public set; }
    public CachingQuery(Query inner, Index index, string query);
    private static CachingQuery();
    public virtual float get_Boost();
    public virtual void set_Boost(float value);
    public virtual Query Rewrite(IndexReader reader, IState state);
    public virtual Weight CreateWeight(Searcher searcher, IState state);
    private bool Equals(CachingQuery other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString(string field);
}
public class Raven.Server.Documents.Queries.LuceneIntegration.FastBitArray : ValueType {
    public UInt64[] Bits;
    public bool Disposed { get; }
    public Size Size { get; }
    public FastBitArray(int countOfBits);
    public FastBitArray(UInt64[] bits);
    public bool get_Disposed();
    public Size get_Size();
    public void Set(int index);
    public int IndexOfFirstSetBit();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.LuceneIntegration.FastBitArray/<Iterate>d__9")]
public IEnumerable`1<int> Iterate(int from);
}
public class Raven.Server.Documents.Queries.LuceneIntegration.FastBitArrayScorer : Scorer {
    private FastBitArray _docs;
    private bool _disposeArray;
    private IEnumerator`1<int> _enum;
    private int _currentDocId;
    internal FastBitArrayScorer(FastBitArray docs, Similarity similarity, bool disposeArray);
    public virtual int DocID();
    public virtual int NextDoc(IState state);
    public virtual int Advance(int target, IState state);
    public virtual float Score(IState state);
}
public class Raven.Server.Documents.Queries.LuceneIntegration.InQuery : Query {
    public List`1<string> Matches;
    public string Field;
    public InQuery(string field, List`1<string> matches);
    public virtual Weight CreateWeight(Searcher searcher, IState state);
    private bool Equals(InQuery other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString(string fld);
}
public class Raven.Server.Documents.Queries.LuceneQueryBuilder : object {
    private static KeywordAnalyzer KeywordAnalyzer;
    private static ConstantScoreAutoRewrite _secondaryBetweenRewriteMethod;
    private static LuceneQueryBuilder();
    public static Query BuildQuery(TransactionOperationContext serverContext, DocumentsOperationContext context, QueryMetadata metadata, QueryExpression whereExpression, Index index, BlittableJsonReaderObject parameters, Analyzer analyzer, QueryBuilderFactories factories, List`1<string> buildSteps);
    public static MoreLikeThisQuery BuildMoreLikeThisQuery(TransactionOperationContext serverContext, DocumentsOperationContext context, QueryMetadata metadata, Index index, QueryExpression whereExpression, BlittableJsonReaderObject parameters, LuceneRavenPerFieldAnalyzerWrapper analyzer, QueryBuilderFactories factories);
    private static Query ToMoreLikeThisQuery(TransactionOperationContext serverContext, DocumentsOperationContext context, Query query, QueryExpression expression, QueryMetadata metadata, Index index, BlittableJsonReaderObject parameters, Analyzer analyzer, QueryBuilderFactories factories, String& baseDocument, BlittableJsonReaderObject& options);
    private static Query ToLuceneQuery(TransactionOperationContext serverContext, DocumentsOperationContext documentsContext, Query query, QueryExpression expression, QueryMetadata metadata, Index index, BlittableJsonReaderObject parameters, Analyzer analyzer, QueryBuilderFactories factories, bool exact, Nullable`1<int> proximity, bool secondary, List`1<string> buildSteps);
    private static Query TranslateOperationOnLong(Index index, string luceneFieldName, long valueAsLong, OperatorType whereOperator);
    private static Query TranslateDateRangeQuery(Index index, BinaryExpression where, QueryFieldName fieldName, long ticks);
    private static Query TranslateBetweenQuery(Query query, QueryMetadata metadata, Index index, BlittableJsonReaderObject parameters, bool exact, BetweenExpression be, bool secondary);
    private static Query TranslateDateTimeBetween(Index index, BetweenExpression be, QueryFieldName fieldName, long ticksFirst, long ticksSecond);
    private static bool IsExact(Index index, bool exact, QueryFieldName fieldName);
    public static QueryExpression EvaluateMethod(Query query, QueryMetadata metadata, TransactionOperationContext serverContext, AbstractCompareExchangeStorage compareExchangeStorage, MethodExpression method, BlittableJsonReaderObject& parameters);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.LuceneQueryBuilder/<GetValuesForIn>d__12")]
private static IEnumerable`1<ValueTuple`2<string, ValueTokenType>> GetValuesForIn(Query query, InExpression expression, QueryMetadata metadata, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private static void ThrowInvalidInValue(Query query, BlittableJsonReaderObject parameters, QueryExpression val);
    private static QueryFieldName ExtractIndexFieldName(Query query, BlittableJsonReaderObject parameters, QueryExpression field, QueryMetadata metadata);
    private static QueryFieldName ExtractIndexFieldName(ValueExpression field, QueryMetadata metadata, BlittableJsonReaderObject parameters);
    private static Query HandleExists(Query query, BlittableJsonReaderObject parameters, MethodExpression expression, QueryMetadata metadata);
    private static Query HandleLucene(Query query, MethodExpression expression, QueryMetadata metadata, BlittableJsonReaderObject parameters, Analyzer analyzer, bool exact);
    private static Query HandleStartsWith(Query query, MethodExpression expression, QueryMetadata metadata, Index index, BlittableJsonReaderObject parameters, bool exact);
    private static Query HandleEndsWith(Query query, MethodExpression expression, QueryMetadata metadata, Index index, BlittableJsonReaderObject parameters, bool exact);
    private static Query HandleProximity(TransactionOperationContext serverContext, DocumentsOperationContext context, Query query, MethodExpression expression, QueryMetadata metadata, Index index, BlittableJsonReaderObject parameters, Analyzer analyzer, QueryBuilderFactories factories, bool exact);
    private static Query HandleFuzzy(TransactionOperationContext serverContext, DocumentsOperationContext context, Query query, MethodExpression expression, QueryMetadata metadata, Index index, BlittableJsonReaderObject parameters, Analyzer analyzer, QueryBuilderFactories factories, bool exact);
    private static Query HandleBoost(TransactionOperationContext serverContext, DocumentsOperationContext context, Query query, MethodExpression expression, QueryMetadata metadata, Index index, BlittableJsonReaderObject parameters, Analyzer analyzer, QueryBuilderFactories factories, bool exact, List`1<string> buildSteps);
    private static Query HandleRegex(Query query, MethodExpression expression, QueryMetadata metadata, BlittableJsonReaderObject parameters, QueryBuilderFactories factories);
    private static bool IsStringFamily(object value);
    private static Query HandleSearch(Query query, MethodExpression expression, QueryMetadata metadata, BlittableJsonReaderObject parameters, Analyzer analyzer, Nullable`1<int> proximity);
    private static Query HandleSpatial(Query query, MethodExpression expression, QueryMetadata metadata, BlittableJsonReaderObject parameters, MethodType spatialMethod, Func`2<string, SpatialField> getSpatialField);
    internal static IShape HandleWkt(Query query, MethodExpression expression, QueryMetadata metadata, BlittableJsonReaderObject parameters, string fieldName, SpatialField spatialField, SpatialUnits& units);
    internal static IShape HandleCircle(Query query, MethodExpression expression, QueryMetadata metadata, BlittableJsonReaderObject parameters, string fieldName, SpatialField spatialField, SpatialUnits& units);
    private static Nullable`1<SpatialUnits> GetSpatialUnits(Query query, ValueExpression value, QueryMetadata metadata, BlittableJsonReaderObject parameters, string fieldName);
    private static Query HandleExact(TransactionOperationContext serverContext, DocumentsOperationContext context, Query query, MethodExpression expression, QueryMetadata metadata, Index index, BlittableJsonReaderObject parameters, Analyzer analyzer, QueryBuilderFactories factories);
    internal static ValueTuple`3<string, IndexFieldType, LuceneTermType> GetLuceneField(string fieldName, ValueTokenType valueType);
    [CompilerGeneratedAttribute]
internal static LuceneTermType <HandleSearch>g__GetTermType|25_0(string termValue);
    [CompilerGeneratedAttribute]
internal static void <HandleSearch>g__AddEscapePosition|25_4(int i, <>c__DisplayClass25_1& );
    [CompilerGeneratedAttribute]
internal static string <HandleSearch>g__YieldValue|25_2(string input, int startIndex, int length, List`1<int> escapePositions);
    [CompilerGeneratedAttribute]
internal static bool <HandleSearch>g__IsEscaped|25_3(string input, int index);
}
public class Raven.Server.Documents.Queries.LuceneQueryHelper : object {
    public static string Asterisk;
    public static char AsteriskChar;
    public static string Null;
    private static ThreadLocal`1<LowerCaseKeywordAnalyzer> WildcardAnalyzer;
    private static LuceneQueryHelper();
    public static Query Equal(string fieldName, LuceneTermType termType, string value, bool exact);
    public static Query Equal(Index index, string fieldName, long value);
    public static Query Equal(Index index, string fieldName, double value);
    public static Query NotEqual(string fieldName, LuceneTermType termType, string value, bool exact);
    public static Query NotEqual(Index index, string fieldName, long value);
    public static Query NotEqual(Index index, string fieldName, double value);
    public static Query LessThan(Index index, string fieldName, LuceneTermType termType, string value, bool exact);
    public static Query LessThan(Index index, string fieldName, long value);
    public static Query LessThan(Index index, string fieldName, double value);
    public static Query LessThanOrEqual(Index index, string fieldName, LuceneTermType termType, string value, bool exact);
    public static Query LessThanOrEqual(Index index, string fieldName, long value);
    public static Query LessThanOrEqual(Index index, string fieldName, double value);
    public static Query GreaterThan(Index index, string fieldName, LuceneTermType termType, string value, bool exact);
    public static Query GreaterThan(Index index, string fieldName, long value);
    public static Query GreaterThan(Index index, string fieldName, double value);
    public static Query GreaterThanOrEqual(Index index, string fieldName, LuceneTermType termType, string value, bool exact);
    public static Query GreaterThanOrEqual(Index index, string fieldName, long value);
    public static Query GreaterThanOrEqual(Index index, string fieldName, double value);
    public static Query Between(Index index, string fieldName, LuceneTermType termType, string fromValue, bool fromInclusive, string toValue, bool toInclusive, bool exact);
    public static Query Between(Index index, string fieldName, long fromValue, bool fromInclusive, long toValue, bool toInclusive);
    public static Query Between(Index index, string fieldName, double fromValue, bool fromInclusive, double toValue, bool toInclusive);
    public static Query Term(string fieldName, string term, LuceneTermType type, Nullable`1<float> boost, Nullable`1<float> similarity, bool exact);
    public static Query AnalyzedTerm(string fieldName, string term, LuceneTermType type, Analyzer analyzer, Nullable`1<float> boost, Nullable`1<float> similarity);
    public static string GetTermValue(string value, LuceneTermType type, bool exact);
    private static Query CreateRange(Index index, string fieldName, string minValue, LuceneTermType minValueType, bool inclusiveMin, string maxValue, LuceneTermType maxValueType, bool inclusiveMax, bool exact);
    private static Query CreateRange(Index index, string fieldName, long minValue, bool inclusiveMin, long maxValue, bool inclusiveMax);
    private static Query CreateRange(Index index, string fieldName, double minValue, bool inclusiveMin, double maxValue, bool inclusiveMax);
    private static Query MaybeCacheQuery(Index index, Query query);
}
public enum Raven.Server.Documents.Queries.LuceneTermType : Enum {
    public int value__;
    public static LuceneTermType String;
    public static LuceneTermType Double;
    public static LuceneTermType Long;
    public static LuceneTermType Null;
    public static LuceneTermType WildCard;
    public static LuceneTermType Prefix;
}
public enum Raven.Server.Documents.Queries.MethodType : Enum {
    public int value__;
    public static MethodType Id;
    public static MethodType Search;
    public static MethodType Boost;
    public static MethodType Regex;
    public static MethodType StartsWith;
    public static MethodType EndsWith;
    public static MethodType Lucene;
    public static MethodType Exists;
    public static MethodType Exact;
    public static MethodType Intersect;
    public static MethodType Fuzzy;
    public static MethodType Proximity;
    public static MethodType Count;
    public static MethodType Sum;
    public static MethodType Min;
    public static MethodType Max;
    public static MethodType Average;
    public static MethodType Last;
    public static MethodType CompareExchange;
    public static MethodType Spatial_Circle;
    public static MethodType Spatial_Wkt;
    public static MethodType Spatial_Point;
    public static MethodType Spatial_Within;
    public static MethodType Spatial_Contains;
    public static MethodType Spatial_Disjoint;
    public static MethodType Spatial_Intersects;
    public static MethodType MoreLikeThis;
    public static MethodType Array;
    public static MethodType Highlight;
    public static MethodType Explanation;
    public static MethodType Timings;
    public static MethodType Counters;
    public static MethodType Revisions;
    public static MethodType TimeSeries;
    public static MethodType Unknown;
}
public class Raven.Server.Documents.Queries.MoreLikeThis.Corax.MoreLikeThisQuery : MoreLikeThisQueryBase {
    [CompilerGeneratedAttribute]
private IQueryMatch <BaseDocumentQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryMatch <FilterQuery>k__BackingField;
    public IQueryMatch BaseDocumentQuery { get; public set; }
    public IQueryMatch FilterQuery { get; public set; }
    [CompilerGeneratedAttribute]
public IQueryMatch get_BaseDocumentQuery();
    [CompilerGeneratedAttribute]
public void set_BaseDocumentQuery(IQueryMatch value);
    [CompilerGeneratedAttribute]
public IQueryMatch get_FilterQuery();
    [CompilerGeneratedAttribute]
public void set_FilterQuery(IQueryMatch value);
}
internal class Raven.Server.Documents.Queries.MoreLikeThis.Corax.RavenMoreLikeThis : MoreLikeThisBase {
    private Parameters _builderParameters;
    private Analyzer _analyzer;
    private AnalyzersScope _analyzersScope;
    public RavenMoreLikeThis(Parameters builderParameters, Analyzer analyzer);
    protected virtual PriorityQueue`1<Object[]> CreateQueue(Dictionary`2<string, int> words);
    private float Idf(long docFreq, long totalAmountOfDocs);
    protected virtual void AddTermFrequencies(TextReader r, Dictionary`2<string, int> termFreqMap, string fieldName);
    public IQueryMatch Like(long documentId);
    internal IQueryMatch Like(BlittableJsonReaderObject json);
    private IQueryMatch CreateQuery(PriorityQueue`1<Object[]> q);
    public virtual void SetMaxDocFreqPct(int maxPercentage);
    protected PriorityQueue`1<Object[]> RetrieveTerms(long documentId);
    public sealed virtual void Dispose();
}
internal class Raven.Server.Documents.Queries.MoreLikeThis.Corax.RavenRavenMoreLikeThis : RavenMoreLikeThis {
    public RavenRavenMoreLikeThis(Parameters builderParameters, MoreLikeThisOptions options);
}
public class Raven.Server.Documents.Queries.MoreLikeThis.Lucene.LuceneMoreLikeThis : MoreLikeThisBase {
    private Similarity _similarity;
    private IState _state;
    private IndexReader _ir;
    private Analyzer _analyzer;
    public Analyzer Analyzer { get; public set; }
    public LuceneMoreLikeThis(IndexReader ir, IState state);
    public LuceneMoreLikeThis(IndexReader ir, Similarity sim, IState state);
    public Analyzer get_Analyzer();
    public void set_Analyzer(Analyzer value);
    public virtual void SetMaxDocFreqPct(int maxPercentage);
    public Query Like(int docNum);
    public Query Like(FileInfo f);
    public Query Like(Stream isRenamed);
    public Query Like(TextReader r);
    internal Query Like(BlittableJsonReaderObject json);
    private Query CreateQuery(PriorityQueue`1<Object[]> q);
    protected virtual PriorityQueue`1<Object[]> CreateQueue(Dictionary`2<string, int> words);
    protected virtual PriorityQueue`1<Object[]> RetrieveTerms(int docNum);
    protected void AddTermFrequencies(Dictionary`2<string, int> termFreqMap, ITermFreqVector vector);
    protected virtual void AddTermFrequencies(TextReader r, Dictionary`2<string, int> termFreqMap, string fieldName);
    public PriorityQueue`1<Object[]> RetrieveTerms(TextReader r);
    public String[] RetrieveInterestingTerms(TextReader r);
}
public class Raven.Server.Documents.Queries.MoreLikeThis.Lucene.MoreLikeThisQuery : MoreLikeThisQueryBase {
    [CompilerGeneratedAttribute]
private Query <BaseDocumentQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private Query <FilterQuery>k__BackingField;
    public Query BaseDocumentQuery { get; public set; }
    public Query FilterQuery { get; public set; }
    [CompilerGeneratedAttribute]
public Query get_BaseDocumentQuery();
    [CompilerGeneratedAttribute]
public void set_BaseDocumentQuery(Query value);
    [CompilerGeneratedAttribute]
public Query get_FilterQuery();
    [CompilerGeneratedAttribute]
public void set_FilterQuery(Query value);
}
internal class Raven.Server.Documents.Queries.MoreLikeThis.Lucene.RavenMoreLikeThis : LuceneMoreLikeThis {
    private IndexReader _ir;
    private IState _state;
    public RavenMoreLikeThis(IndexReader ir, MoreLikeThisOptions options, IState state);
    protected virtual PriorityQueue`1<Object[]> RetrieveTerms(int docNum);
}
public abstract class Raven.Server.Documents.Queries.MoreLikeThis.MoreLikeThisBase : object {
    public static int DEFAULT_MAX_NUM_TOKENS_PARSED;
    public static Analyzer DEFAULT_ANALYZER;
    public static int DEFAULT_MAX_DOC_FREQ;
    public static bool DEFAULT_BOOST;
    public static int DEFAULT_MIN_WORD_LENGTH;
    public static int DEFAULT_MAX_WORD_LENGTH;
    protected HashSet`1<string> _stopWords;
    public static int DEFAULT_MAX_QUERY_TERMS;
    protected int _minTermFreq;
    protected int _minDocFreq;
    protected int _maxDocfreq;
    protected bool _boost;
    protected String[] _fieldNames;
    protected int _maxNumTokensParsed;
    protected int _minWordLen;
    protected int _maxWordLen;
    protected int _maxQueryTerms;
    protected float _boostFactor;
    public float BoostFactor { get; public set; }
    public int MinTermFreq { get; public set; }
    public int MinDocFreq { get; public set; }
    public int MaxDocFreq { get; public set; }
    public bool Boost { get; public set; }
    public int MinWordLen { get; public set; }
    public int MaxWordLen { get; public set; }
    public int MaxQueryTerms { get; public set; }
    public int MaxNumTokensParsed { get; public set; }
    private static MoreLikeThisBase();
    public float get_BoostFactor();
    public void set_BoostFactor(float value);
    public int get_MinTermFreq();
    public void set_MinTermFreq(int value);
    public int get_MinDocFreq();
    public void set_MinDocFreq(int value);
    public int get_MaxDocFreq();
    public void set_MaxDocFreq(int value);
    public bool get_Boost();
    public void set_Boost(bool value);
    public String[] GetFieldNames();
    public void SetFieldNames(String[] fieldNames);
    public int get_MinWordLen();
    public void set_MinWordLen(int value);
    public int get_MaxWordLen();
    public void set_MaxWordLen(int value);
    public void SetStopWords(HashSet`1<string> stopWords);
    public ISet`1<string> GetStopWords();
    public int get_MaxQueryTerms();
    public void set_MaxQueryTerms(int value);
    public int get_MaxNumTokensParsed();
    public void set_MaxNumTokensParsed(int value);
    protected bool IsNoiseWord(string term);
    protected abstract virtual PriorityQueue`1<Object[]> CreateQueue(Dictionary`2<string, int> words);
    protected static bool HasFlagWithBitPacking(BlittableJsonToken token);
    internal PriorityQueue`1<Object[]> RetrieveTerms(BlittableJsonReaderObject json);
    protected void RetrieveTerms(BlittableJsonReaderObject json, Dictionary`2<string, int> words);
    public abstract virtual void SetMaxDocFreqPct(int maxPercentage);
    protected abstract virtual void AddTermFrequencies(TextReader r, Dictionary`2<string, int> termFreqMap, string fieldName);
    protected void ProcessTerms(BlittableJsonToken token, LazyStringValue name, object value, Dictionary`2<string, int> words);
}
public abstract class Raven.Server.Documents.Queries.MoreLikeThis.MoreLikeThisQueryBase : object {
    [CompilerGeneratedAttribute]
private string <BaseDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Options>k__BackingField;
    public string BaseDocument { get; public set; }
    public BlittableJsonReaderObject Options { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BaseDocument();
    [CompilerGeneratedAttribute]
public void set_BaseDocument(string value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(BlittableJsonReaderObject value);
}
public class Raven.Server.Documents.Queries.OrderByField : ValueType {
    public QueryFieldName Name;
    public OrderByFieldType OrderingType;
    public bool Ascending;
    public Argument[] Arguments;
    public Nullable`1<MethodType> Method;
    public string OrderByName;
    public AggregationOperation AggregationOperation;
    public OrderByField(QueryFieldName name, OrderByFieldType orderingType, bool ascending, Nullable`1<MethodType> method, Argument[] arguments);
}
public class Raven.Server.Documents.Queries.Parser.QueryParser : object {
    private static String[] OperatorStartMatches;
    private static String[] BinaryOperators;
    private static String[] StaticValues;
    private static String[] OrderByOptions;
    private static String[] OrderByAsOptions;
    private int _depth;
    private QueryParser _timeSeriesParser;
    private NextTokenOptions _state;
    private int _statePos;
    private bool _insideTimeSeriesBody;
    private string _fromAlias;
    public static string TimeSeries;
    public QueryScanner Scanner;
    private static String[] AliasKeywords;
    private static QueryParser();
    public void Init(string q);
    public Query Parse(QueryType queryType, bool recursive);
    public bool TryParse(Query& query, String& message, QueryType queryType, bool recursive);
    private DeclaredFunction SelectTimeSeries();
    private void Paging(ValueExpression& offset, ValueExpression& limit, ValueExpression& filterLimit);
    [DoesNotReturnAttribute]
private void ThrowInvalidQueryException(string message, Exception e);
    private static Program ValidateScript(string script);
    [DoesNotReturnAttribute]
private static void ThrowUnknownQueryType(QueryType queryType);
    internal static string AddLineAndColumnNumberToErrorMessage(Exception e, string msg);
    private List`1<QueryExpression> IncludeClause();
    private DeclaredFunction DeclaredFunction();
    private TimeSeriesFunction ParseTimeSeriesBody(string name);
    [DoesNotReturnAttribute]
private void ThrowCannotHaveBothClauses(string clause1, string clause2, string functionName);
    private ValueExpression GetTimePeriodValueExpression(string functionName, string clause);
    private List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> GroupBy();
    private List`1<ValueTuple`3<QueryExpression, OrderByFieldType, bool>> OrderBy();
    private List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> SelectClause(string clause, Query query);
    private List`1<ValueTuple`2<QueryExpression, Nullable`1<StringSegment>>> SelectClauseExpressions(string clause, bool aliasAsRequired, Query query);
    private MethodExpression GetTimeSeriesExpression(Query query);
    private bool TryParseFromClause(FromClause& fromClause, String& message);
    private bool TryParseExpressionAfterFromKeyword(FromClause& fromClause, String& message);
    private bool Alias(bool aliasAsRequired, Nullable`1& alias);
    internal bool Parameter(StringSegment& p);
    internal bool Expression(QueryExpression& op);
    private bool Binary(QueryExpression& op);
    private bool TrySimplifyBinaryExpression(QueryExpression right, OperatorType type, bool negate, bool allowSimplification, QueryExpression& op);
    private QueryExpression NegateExpressionWithoutParenthesis(QueryExpression expr);
    private bool Parenthesis(QueryExpression& op);
    private bool Operator(OperatorField fieldOption, QueryExpression& op);
    private BetweenExpression ReadBetweenExpression(FieldExpression field);
    private TimeSeriesBetweenExpression ReadTimeSeriesBetweenExpression(QueryExpression source);
    private bool Method(FieldExpression field, MethodExpression& op);
    private List`1<QueryExpression> ReadMethodArguments();
    [DoesNotReturnAttribute]
private void ThrowParseException(string msg);
    [DoesNotReturnAttribute]
private void ThrowQueryException(string msg);
    [DoesNotReturnAttribute]
private void ThrowQueryTooComplexException();
    private bool Value(ValueExpression& val);
    internal bool Field(FieldExpression& token);
    [CompilerGeneratedAttribute]
private bool <Paging>g__TryScanLimit|17_0(ValueExpression& offset, ValueExpression& limit);
    [CompilerGeneratedAttribute]
private bool <Paging>g__TryScanOffset|17_1(ValueExpression& offset);
    [CompilerGeneratedAttribute]
internal static bool <NegateExpressionWithoutParenthesis>g__ShouldRecurse|40_0(BinaryExpression e);
}
public class Raven.Server.Documents.Queries.Parser.QueryScanner : ValueType {
    private int _pos;
    private string _q;
    public int Column;
    public int Line;
    private int _tokenStart;
    private int _tokenLength;
    public string Input { get; }
    public StringSegment Token { get; }
    public int Position { get; }
    public ReadOnlySpan`1<char> CurrentToken { get; }
    public string get_Input();
    public StringSegment get_Token();
    public int get_Position();
    public ReadOnlySpan`1<char> get_CurrentToken();
    public virtual string ToString();
    public void Init(string q);
    public bool AtEndOfInput();
    public bool SkipUntil(char match);
    public bool NextToken();
    public Nullable`1<NumberToken> TryNumber();
    public bool Identifier(bool skipWhitespace, bool beginning, bool isParameter);
    private bool SkipWhitespace(bool skipWhitespace);
    public bool TryScan(char match, bool skipWhitespace);
    public bool TryPeek(char match, bool skipWhitespace);
    private bool TryPeek(string match, bool skipWhitespace);
    public bool TryPeek(String[] matches, bool skipWhitespace);
    public bool TryScan(string match, bool skipWhitespace);
    public bool TryScanMultiWordsToken(string a, string b);
    public bool TryScan(String[] matches, String& found);
    public bool CurrentTokenMatchesAnyOf(String[] options);
    public bool String(StringSegment& str, bool fieldPath);
    private StringSegment GetEscapedString(char quoteChar);
    public void Reset(int pos);
    public bool FunctionBody(bool isCurly);
    public bool TimeSeriesFunctionBody();
    public void GoBack(int matchLength);
    public void GoBack();
}
public class Raven.Server.Documents.Queries.QueryBuilderFactories : object {
    [CompilerGeneratedAttribute]
private Func`2<string, SpatialField> <GetSpatialFieldFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, Regex> <GetRegexFactory>k__BackingField;
    public Func`2<string, SpatialField> GetSpatialFieldFactory { get; public set; }
    public Func`2<string, Regex> GetRegexFactory { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<string, SpatialField> get_GetSpatialFieldFactory();
    [CompilerGeneratedAttribute]
public void set_GetSpatialFieldFactory(Func`2<string, SpatialField> value);
    [CompilerGeneratedAttribute]
public Func`2<string, Regex> get_GetRegexFactory();
    [CompilerGeneratedAttribute]
public void set_GetRegexFactory(Func`2<string, Regex> value);
}
public static class Raven.Server.Documents.Queries.QueryBuilderHelper : object {
    internal static int ScoreId;
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.QueryBuilderHelper/<GetValues>d__1")]
internal static IEnumerable`1<ValueTuple`2<object, ValueTokenType>> GetValues(Query query, QueryMetadata metadata, BlittableJsonReaderObject parameters, ValueExpression value);
    public static long ParseInt64WithSeparators(string token);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidInt64(string token);
    public static long GetLongValue(Query query, QueryMetadata metadata, BlittableJsonReaderObject parameters, QueryExpression expression, long nullValue);
    public static ValueTuple`2<object, ValueTokenType> GetValue(Query query, QueryMetadata metadata, BlittableJsonReaderObject parameters, QueryExpression expression, bool allowObjectsInParameters);
    internal static object UnwrapParameter(object parameterValue, ValueTokenType parameterType);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.QueryBuilderHelper/<UnwrapArray>d__7")]
internal static IEnumerable`1<ValueTuple`2<object, ValueTokenType>> UnwrapArray(BlittableJsonReaderArray array, string queryText, BlittableJsonReaderObject parameters);
    public static ValueTokenType GetValueTokenType(object parameterValue, string queryText, BlittableJsonReaderObject parameters, bool unwrapArrays);
    public static bool AreValueTokenTypesValid(ValueTokenType previous, ValueTokenType current);
    internal static void AssertValueIsString(string fieldName, ValueTokenType fieldType);
    internal static void AssertValueIsNumber(string fieldName, ValueTokenType fieldType);
    [DoesNotReturnAttribute]
internal static void ThrowQueryTooComplexException(QueryMetadata metadata, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
internal static void ThrowUnhandledValueTokenType(ValueTokenType type);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperatorInSearch(QueryMetadata metadata, BlittableJsonReaderObject parameters, FieldExpression fieldExpression);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidParameterType(ValueTokenType expectedValueType, ValueTuple`2<object, ValueTokenType> item, string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
internal static void ThrowMethodExpectsArgumentOfTheFollowingType(string methodName, ValueTokenType expectedType, ValueTokenType gotType, string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
public static void ThrowParametersWereNotProvided(string queryText);
    [DoesNotReturnAttribute]
public static void ThrowParameterValueWasNotProvided(string parameterName, string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
internal static void ThrowUnexpectedParameterValue(object parameter, string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
internal static void ThrowValueTypeMismatch(string fieldName, ValueTokenType fieldType, ValueTokenType expectedType);
    [DoesNotReturnAttribute]
internal static void ThrowValueTypeMismatch(ValueTokenType fieldType, ValueTokenType expectedType);
    internal static UnaryMatchOperation TranslateUnaryMatchOperation(OperatorType current);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.QueryBuilderHelper/<GetValuesForIn>d__23")]
internal static IEnumerable`1<ValueTuple`2<string, ValueTokenType>> GetValuesForIn(Query query, InExpression expression, QueryMetadata metadata, BlittableJsonReaderObject parameters);
    internal static bool TryGetTime(Index index, object value, Int64& ticks);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidInValue(Query query, BlittableJsonReaderObject parameters, QueryExpression val);
    internal static QueryFieldName ExtractIndexFieldName(Query query, BlittableJsonReaderObject parameters, QueryExpression field, QueryMetadata metadata);
    internal static FieldMetadata GetFieldIdForOrderBy(ByteStringContext allocator, string fieldName, Index index, bool hasDynamics, Lazy`1<List`1<string>> dynamicFields, IndexFieldsMapping indexMapping, FieldsToFetch queryMapping, bool isForQuery);
    internal static FieldMetadata GetFieldMetadata(ByteStringContext allocator, string fieldName, Index index, IndexFieldsMapping indexMapping, FieldsToFetch queryMapping, bool hasDynamics, Lazy`1<List`1<string>> dynamicFields, bool isForQuery, bool exact, bool isSorting, bool hasBoost, bool handleSearch);
    internal static bool IsExact(Index index, bool exact, QueryFieldName fieldName);
    internal static QueryExpression EvaluateMethod(Query query, QueryMetadata metadata, TransactionOperationContext serverContext, AbstractCompareExchangeStorage compareExchangeStorage, MethodExpression method, BlittableJsonReaderObject parameters);
    internal static string CoraxGetValueAsString(object value);
    internal static ComparerType GetComparerType(bool ascending, OrderMetadata order);
    internal static IShape HandleWkt(Parameters builderParameters, string fieldName, MethodExpression expression, SpatialField spatialField, SpatialUnits& units);
    internal static IShape HandleCircle(Query query, MethodExpression expression, QueryMetadata metadata, BlittableJsonReaderObject parameters, string fieldName, SpatialField spatialField, SpatialUnits& units);
    private static Nullable`1<SpatialUnits> GetSpatialUnits(Query query, ValueExpression value, QueryMetadata metadata, BlittableJsonReaderObject parameters, string fieldName);
    internal static bool TryUseTime(Index index, string fieldName, object valueFirst, object valueSecond, bool exact, Int64& ticksFirst, Int64& ticksSecond);
    internal static bool TryUseTime(Index index, string fieldName, object value, bool exact, Int64& ticks);
    internal static MethodExpression FindMoreLikeThisExpression(QueryExpression expression);
    internal static string GetValueAsString(object value);
    [CompilerGeneratedAttribute]
internal static void <GetFieldMetadata>g__ThrowNotFoundInIndex|28_0(<>c__DisplayClass28_0& );
}
public class Raven.Server.Documents.Queries.QueryFieldName : object {
    public static QueryFieldName Empty;
    public static QueryFieldName DocumentId;
    public static QueryFieldName Count;
    public string Value;
    public bool IsQuoted;
    public QueryFieldName(string name, bool isQuoted);
    private static QueryFieldName();
    public static string op_Implicit(QueryFieldName self);
    private bool Equals(QueryFieldName other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Raven.Server.Documents.Queries.QueryMetadata : object {
    internal static string SelectOutput;
    private Dictionary`2<string, QueryFieldName> _aliasToName;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<StringSegment, ValueTuple`5<string, bool, bool, bool, string>> RootAliasPaths;
    public string FilterScript;
    public bool AddSpatialProperties;
    public bool IsDistinct;
    public bool IsDynamic;
    public bool IsGroupBy;
    [CompilerGeneratedAttribute]
private bool <HasFacet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSuggest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMoreLikeThis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasBoost>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasIntersect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCmpXchg>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCmpXchgIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasHighlightings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExplanations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTimings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCounterSelect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCmpXchgSelect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTimeSeriesSelect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCollectionQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DeclaredFunction> <DeclaredFunctions>k__BackingField;
    public string CollectionName;
    public string IndexName;
    public string AutoIndexName;
    public Query Query;
    public string QueryText;
    public HashSet`1<QueryFieldName> IndexFieldNames;
    public Dictionary`2<QueryFieldName, WhereField> WhereFields;
    public GroupByField[] GroupBy;
    public OrderByField[] OrderBy;
    public SelectField[] SelectFields;
    public HighlightingField[] Highlightings;
    public ExplanationField Explanation;
    public CounterIncludesField CounterIncludes;
    public RevisionIncludeField RevisionIncludes;
    public TimeSeriesIncludesField TimeSeriesIncludes;
    public ulong CacheKey;
    public bool CanCache;
    public String[] Includes;
    public String[] CompareExchangeValueIncludes;
    public bool HasIncludeOrLoad;
    public bool HasOrderByCustom;
    public bool HasOrderByRandom;
    public DateTime CreatedAt;
    public DateTime LastQueriedAt;
    public List`1<SpatialProperty> SpatialProperties;
    public List`1<SpatialShapeBase> SpatialShapes;
    public Nullable`1<bool> CountInJs;
    public string SumInJs;
    public OrderByField[] CachedOrderBy;
    private List`1<string> _groupByFieldsByName;
    private HashSet`1<string> _orderByFieldNames;
    private QueryData _queryData;
    [ThreadStaticAttribute]
private static HashSet`1<string> _duplicateAliasHelper;
    private static HashSet`1<string> JsBaseObjects;
    public bool HasFacet { get; private set; }
    public bool HasSuggest { get; private set; }
    public bool HasMoreLikeThis { get; private set; }
    public bool HasBoost { get; private set; }
    public bool HasIntersect { get; private set; }
    public bool HasCmpXchg { get; private set; }
    public bool HasCmpXchgIncludes { get; internal set; }
    public bool HasHighlightings { get; private set; }
    public bool HasExplanations { get; private set; }
    public bool HasTimings { get; private set; }
    public bool HasCounterSelect { get; internal set; }
    public bool HasCmpXchgSelect { get; internal set; }
    public bool HasTimeSeriesSelect { get; internal set; }
    public bool IsCollectionQuery { get; private set; }
    public Dictionary`2<string, DeclaredFunction> DeclaredFunctions { get; }
    public List`1<string> GroupByFieldNames { get; }
    public HashSet`1<string> OrderByFieldNames { get; }
    public QueryData QueryData { get; }
    public QueryMetadata(string query, BlittableJsonReaderObject parameters, ulong cacheKey, bool addSpatialProperties, QueryType queryType);
    public QueryMetadata(Query query, BlittableJsonReaderObject parameters, ulong cacheKey, bool addSpatialProperties);
    private static QueryMetadata();
    internal static Query ParseQuery(string q, QueryType queryType);
    private void BuildFilterScript(Query query);
    [CompilerGeneratedAttribute]
public bool get_HasFacet();
    [CompilerGeneratedAttribute]
private void set_HasFacet(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasSuggest();
    [CompilerGeneratedAttribute]
private void set_HasSuggest(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMoreLikeThis();
    [CompilerGeneratedAttribute]
private void set_HasMoreLikeThis(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasBoost();
    [CompilerGeneratedAttribute]
private void set_HasBoost(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasIntersect();
    [CompilerGeneratedAttribute]
private void set_HasIntersect(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasCmpXchg();
    [CompilerGeneratedAttribute]
private void set_HasCmpXchg(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasCmpXchgIncludes();
    [CompilerGeneratedAttribute]
internal void set_HasCmpXchgIncludes(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasHighlightings();
    [CompilerGeneratedAttribute]
private void set_HasHighlightings(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasExplanations();
    [CompilerGeneratedAttribute]
private void set_HasExplanations(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasTimings();
    [CompilerGeneratedAttribute]
private void set_HasTimings(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasCounterSelect();
    [CompilerGeneratedAttribute]
internal void set_HasCounterSelect(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasCmpXchgSelect();
    [CompilerGeneratedAttribute]
internal void set_HasCmpXchgSelect(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasTimeSeriesSelect();
    [CompilerGeneratedAttribute]
internal void set_HasTimeSeriesSelect(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCollectionQuery();
    [CompilerGeneratedAttribute]
private void set_IsCollectionQuery(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DeclaredFunction> get_DeclaredFunctions();
    public List`1<string> get_GroupByFieldNames();
    public HashSet`1<string> get_OrderByFieldNames();
    public QueryData get_QueryData();
    private void AddExistField(QueryFieldName fieldName, BlittableJsonReaderObject parameters);
    public void AddWhereField(QueryFieldName fieldName, BlittableJsonReaderObject parameters, bool search, bool exact, AutoSpatialOptions spatial, Nullable`1<OperatorType> operatorType, bool isNegated, string methodName);
    private void Build(BlittableJsonReaderObject parameters);
    private void HandleDeclaredFunctions();
    private void HandleDeclaredFunctionBody(IEnumerable`1<Node> body);
    private void HandleDeclaredFunctionStaticMemberExpression(StaticMemberExpression staticMemberExpression);
    private void HandleQueryInclude(BlittableJsonReaderObject parameters);
    private void AddToRevisionsInclude(RevisionIncludeField revisionIncludes, MethodExpression expression, BlittableJsonReaderObject parameters);
    private static ExplanationField CreateExplanationField(MethodExpression expression);
    private HighlightingField CreateHighlightingField(MethodExpression expression, BlittableJsonReaderObject parameters);
    private void HandleSelectFunctionBody(BlittableJsonReaderObject parameters);
    private void AddToCounterIncludes(CounterIncludesField counterIncludes, MethodExpression expression, BlittableJsonReaderObject parameters);
    private void AddCounterToInclude(CounterIncludesField counterIncludes, BlittableJsonReaderObject parameters, ValueTuple`2<object, ValueTokenType> parameterValue, string sourcePath);
    private void AddToTimeSeriesIncludes(TimeSeriesIncludesField timeSeriesIncludes, MethodExpression expression, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowUseOfReserveFunctionBodyMethodName(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowInvalidFunctionSelectWithMoreFields(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowMissingAliasOnSelectFunctionBody(BlittableJsonReaderObject parameters);
    public static ValueTuple`2<string, string> ParseExpressionPath(QueryExpression expr, string path, Nullable`1<StringSegment> alias);
    private void HandleLoadClause(BlittableJsonReaderObject parameters);
    private void ThrowInvalidWith(QueryExpression expr, string msg, BlittableJsonReaderObject parameters);
    private OrderByField ExtractOrderByFromMethod(MethodExpression me, string fromAlias, OrderByFieldType orderingType, bool asc, BlittableJsonReaderObject parameters);
    private void FillSelectFields(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowDuplicateFunctionAliasInSelectClause(BlittableJsonReaderObject parameters, string finalAlias);
    [DoesNotReturnAttribute]
private void ThrowInvalidDuplicateAliasInSelectClause(BlittableJsonReaderObject parameters, string finalAlias);
    private SelectField GetSelectField(BlittableJsonReaderObject parameters, QueryExpression expression, string alias);
    private SelectField[] ConvertSelectArguments(BlittableJsonReaderObject parameters, string alias, MethodExpression me, string methodName);
    private void CheckIfProjectionHasSpecialMethod(Program ast);
    private SuggestionField CreateSuggest(MethodExpression expression, string alias, BlittableJsonReaderObject parameters);
    private FacetField CreateFacet(MethodExpression expression, string alias, BlittableJsonReaderObject parameters);
    private void AddFacetAggregation(MethodExpression me, FacetField field, FacetAggregation aggregation, BlittableJsonReaderObject parameters);
    private SelectField GetSelectValue(string alias, FieldExpression expressionField, BlittableJsonReaderObject parameters);
    public QueryFieldName GetIndexFieldName(FieldExpression fe, BlittableJsonReaderObject parameters);
    public QueryFieldName GetIndexFieldName(QueryFieldName fieldNameOrAlias, BlittableJsonReaderObject parameters);
    private GroupByField GetGroupByField(QueryExpression expression, string alias, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private static void ThrowBetweenMustHaveFieldSource(string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private static void ThrowIncompatibleTypesOfVariables(object fieldName, string queryText, BlittableJsonReaderObject parameters, QueryExpression[] valueTokens);
    [DoesNotReturnAttribute]
private static void ThrowIncompatibleTypesOfParameters(object fieldName, string queryText, BlittableJsonReaderObject parameters, QueryExpression[] valueTokens);
    [DoesNotReturnAttribute]
private static void ThrowUnknownAggregationMethodInSelectOfGroupByQuery(string methodName, string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private static void ThrowMissingFieldNameArgumentOfSumMethod(string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private static void ThrowIncorrectNumberOfArgumentsOfSumMethod(int count, string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private static void ThrowUnknownMethodInSelect(string methodName, string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private static void ThrowUnhandledExpressionTypeInSelect(string expressionType, string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperatorTypeInOrderBy(string type, string queryText, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowUnknownAlias(string alias, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowInvalidArgumentToId(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowInvalidAggregationMethod(BlittableJsonReaderObject parameters, string methodName);
    [DoesNotReturnAttribute]
private void ThrowInvalidIdInGroupByQuery(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowFacetQueryCannotBeGroupBy(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowFacetQueryCannotBeDistinct(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowInvalidNumberOfArgumentsOfFacetAggregation(FacetAggregation method, int expected, int got, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowInvalidArgumentToIdInFacet(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowInvalidFacetUsingSetupDocument(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowInvalidArgumentExpressionInFacetQuery(QueryExpression expression, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowFacetQueryMustContainsOnlyFacetInSelect(QueryExpression expression, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowSuggestionQueryMustContainsOnlySuggestInSelect(QueryExpression expression, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowSuggestionQueryCannotBeFacet(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowFacetQueryCannotBeSuggest(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowSuggestionQueryCannotBeDistinct(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowSuggestionQueryCannotBeGroupBy(BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowSuggestMethodArgumentMustBeValue(int index, QueryExpression argument, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowSuggestMethodMustHaveTwoOrThreeArguments(int count, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowInvalidNumberOfArgumentsForCounter(string methodName, BlittableJsonReaderObject parameters, int argsCount);
    [DoesNotReturnAttribute]
private void ThrowInvalidNumberOfArgumentsForCompareExchange(string methodName, BlittableJsonReaderObject parameters, int argsCount);
    [DoesNotReturnAttribute]
private void ThrowCounterInvalidArgument(string methodName, QueryExpression expression, BlittableJsonReaderObject parameters);
    [DoesNotReturnAttribute]
private void ThrowInvalidArgumentToGetMetadata(BlittableJsonReaderObject parameters);
    internal string GetSpatialFieldName(MethodExpression spatialExpression, BlittableJsonReaderObject parameters);
    internal QueryFieldName ExtractFieldNameFromFirstArgument(List`1<QueryExpression> arguments, string methodName, BlittableJsonReaderObject parameters);
    internal QueryFieldName ExtractFieldNameFromArgument(QueryExpression argument, bool withoutAlias, string methodName, BlittableJsonReaderObject parameters, string queryText);
    public string GetUpdateBody(BlittableJsonReaderObject parameters);
    private ValueTuple`2<Program, HashSet`1<string>> ValidateScript(BlittableJsonReaderObject parameters);
    private bool NotInRootAliasPaths(string key);
    private bool ShouldStripAlias(FieldExpression expr);
    internal bool IsAliasedField(FieldExpression fe);
    [CompilerGeneratedAttribute]
private void <HandleQueryInclude>g__AddInclude|115_0(QueryExpression include, string path, List`1& listToAdd, <>c__DisplayClass115_0& );
    [CompilerGeneratedAttribute]
private string <CreateFacet>g__ExtractFieldNameFromBinaryExpression|139_0(BinaryExpression binaryExpression, <>c__DisplayClass139_0& , <>c__DisplayClass139_1& );
}
public class Raven.Server.Documents.Queries.QueryMetadataCache : object {
    private static int CacheSize;
    private QueryMetadata[] _cache;
    public bool TryGetMetadata(IndexQueryBase`1<BlittableJsonReaderObject> query, bool addSpatialProperties, UInt64& metadataHash, QueryMetadata& metadata);
    public void MaybeAddToCache(QueryMetadata metadata, string indexName);
    private static ulong GetQueryMetadataHash(IndexQueryBase`1<BlittableJsonReaderObject> query);
    public QueryMetadata[] GetQueryCache();
}
public static class Raven.Server.Documents.Queries.QueryMethod : object {
    public static MethodType GetMethodType(string methodName, bool throwIfNoMatch);
    [DoesNotReturnAttribute]
public static object ThrowMethodNotSupported(MethodType methodType, string queryText, BlittableJsonReaderObject parameters);
}
public abstract class Raven.Server.Documents.Queries.QueryResultServerSide`1 : QueryResult`2<List`1<T>, List`1<T>> {
    [CompilerGeneratedAttribute]
private List`1<string> <TimeSeriesFields>k__BackingField;
    [CompilerGeneratedAttribute]
private SpatialProperty[] <SpatialProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private SpatialShapeBase[] <SpatialShapes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotModified>k__BackingField;
    public List`1<string> TimeSeriesFields { get; public set; }
    public SpatialProperty[] SpatialProperties { get; public set; }
    public SpatialShapeBase[] SpatialShapes { get; public set; }
    public bool SupportsExceptionHandling { get; }
    public bool SupportsInclude { get; }
    public bool SupportsHighlighting { get; }
    public bool SupportsExplanations { get; }
    public bool NotModified { get; public set; }
    protected QueryResultServerSide`1(Nullable`1<long> indexDefinitionRaftIndex);
    [CompilerGeneratedAttribute]
public List`1<string> get_TimeSeriesFields();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesFields(List`1<string> value);
    public void RegisterTimeSeriesFields(IndexQueryServerSide query, FieldsToFetch fields);
    [CompilerGeneratedAttribute]
public SpatialProperty[] get_SpatialProperties();
    [CompilerGeneratedAttribute]
public void set_SpatialProperties(SpatialProperty[] value);
    [CompilerGeneratedAttribute]
public SpatialShapeBase[] get_SpatialShapes();
    [CompilerGeneratedAttribute]
public void set_SpatialShapes(SpatialShapeBase[] value);
    public void RegisterSpatialProperties(IndexQueryServerSide query);
    public abstract virtual ValueTask AddResultAsync(T result, CancellationToken token);
    public abstract virtual void AddHighlightings(Dictionary`2<string, Dictionary`2<string, String[]>> highlightings);
    public abstract virtual void AddExplanation(ExplanationResult explanationResult);
    public abstract virtual ValueTask HandleExceptionAsync(Exception e, CancellationToken token);
    public abstract virtual bool get_SupportsExceptionHandling();
    public abstract virtual bool get_SupportsInclude();
    public abstract virtual bool get_SupportsHighlighting();
    public abstract virtual bool get_SupportsExplanations();
    [CompilerGeneratedAttribute]
public bool get_NotModified();
    [CompilerGeneratedAttribute]
public void set_NotModified(bool value);
    public abstract virtual void AddCounterIncludes(ICounterIncludes counters);
    public abstract virtual ICounterIncludes GetCounterIncludes();
    public abstract virtual void AddTimeSeriesIncludes(ITimeSeriesIncludes timeSeries);
    public abstract virtual ITimeSeriesIncludes GetTimeSeriesIncludes();
    public abstract virtual void AddCompareExchangeValueIncludes(ICompareExchangeValueIncludes values);
    public abstract virtual Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> GetCompareExchangeValueIncludes();
    public abstract virtual void AddRevisionIncludes(IRevisionIncludes revisions);
    public abstract virtual IRevisionIncludes GetRevisionIncludes();
    public virtual void Dispose();
}
public class Raven.Server.Documents.Queries.QueryRunner : AbstractDatabaseQueryRunner {
    private static int NumberOfRetries;
    private StaticIndexQueryRunner _static;
    private AbstractDatabaseQueryRunner _dynamic;
    private CollectionQueryRunner _collection;
    public QueryRunner(DocumentDatabase database);
    public AbstractDatabaseQueryRunner GetRunner(IndexQueryServerSide query);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.QueryRunner/<ExecuteQuery>d__6")]
public virtual Task`1<DocumentQueryResult> ExecuteQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.QueryRunner/<ExecuteStreamQuery>d__7")]
public virtual Task ExecuteStreamQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<Document> writer, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.QueryRunner/<ExecuteStreamIndexEntriesQuery>d__8")]
public virtual Task ExecuteStreamIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<BlittableJsonReaderObject> writer, bool ignoreLimit, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.QueryRunner/<ExecuteFacetedQuery>d__9")]
public Task`1<FacetedQueryResult> ExecuteFacetedQuery(IndexQueryServerSide query, Nullable`1<long> existingResultEtag, QueryOperationContext queryContext, OperationCancelToken token);
    public TermsQueryResultServerSide ExecuteGetTermsQuery(string indexName, string field, string fromValue, Nullable`1<long> existingResultEtag, int pageSize, QueryOperationContext queryContext, OperationCancelToken token, Index& index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.QueryRunner/<ExecuteSuggestionQuery>d__11")]
public virtual Task`1<SuggestionQueryResult> ExecuteSuggestionQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.QueryRunner/<ExecuteIndexEntriesQuery>d__12")]
public virtual Task`1<IndexEntriesQueryResult> ExecuteIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, bool ignoreLimit, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.QueryRunner/<ExecuteDeleteQuery>d__13")]
public virtual Task`1<IOperationResult> ExecuteDeleteQuery(IndexQueryServerSide query, QueryOperationOptions options, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.QueryRunner/<ExecutePatchQuery>d__14")]
public virtual Task`1<IOperationResult> ExecutePatchQuery(IndexQueryServerSide query, QueryOperationOptions options, PatchRequest patch, BlittableJsonReaderObject patchArgs, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    private Task WaitForIndexBeingLikelyReplacedDuringQuery();
    public List`1<Explanation> ExplainDynamicIndexSelection(IndexQueryServerSide query, String& indexName);
    private static Exception CreateRetriesFailedException(Exception inner);
    public static void AssertValidQuery(IndexQueryServerSide query, QueryResultServerSide`1<TQueryResult> result);
}
public static class Raven.Server.Documents.Queries.QueryValidator : object {
    public static void ValidateTimings(List`1<QueryExpression> arguments, string queryText, BlittableJsonReaderObject parameters);
    public static void ValidateExplanations(List`1<QueryExpression> arguments, string queryText, BlittableJsonReaderObject parameters);
    public static void ValidateHighlight(List`1<QueryExpression> arguments, string queryText, BlittableJsonReaderObject parameters);
    public static void ValidateCircle(List`1<QueryExpression> arguments, string queryText, BlittableJsonReaderObject parameters);
    public static void ValidateWkt(List`1<QueryExpression> arguments, string queryText, BlittableJsonReaderObject parameters);
    public static void ValidatePoint(List`1<QueryExpression> arguments, string queryText, BlittableJsonReaderObject parameters);
    public static void ValidateIncludeCounter(List`1<QueryExpression> arguments, string queryText, BlittableJsonReaderObject parameters);
    public static void ValidateRevisions(List`1<QueryExpression> arguments, string queryText, BlittableJsonReaderObject parameters);
    public static void ValidateIncludeTimeseries(List`1<QueryExpression> arguments, string queryText, BlittableJsonReaderObject parameters);
    public static void ValidateIncludeCompareExchangeValue(List`1<QueryExpression> arguments, string queryText, BlittableJsonReaderObject parameters);
}
public class Raven.Server.Documents.Queries.RavenBooleanQuery : BooleanQuery {
    private OperatorType _operator;
    public bool IsBoosted { get; }
    public RavenBooleanQuery(OperatorType operator);
    public RavenBooleanQuery(Query left, Query right, OperatorType operator, List`1<string> buildSteps);
    public bool get_IsBoosted();
    public bool TryAnd(Query right, List`1<string> buildSteps);
    public void And(Query left, Query right, List`1<string> buildSteps);
    public bool TryOr(Query right, List`1<string> buildSteps);
    public void Or(Query left, Query right, List`1<string> buildSteps);
    private void AddInternal(Query query, Occur occur, OperatorType operator, List`1<string> buildSteps);
    [DoesNotReturnAttribute]
private void ThrowInvalidOperator(OperatorType operator);
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperatorType(OperatorType operatorType);
    [CompilerGeneratedAttribute]
internal static int <AddInternal>g__SingleToInt32Bits|9_0(float value);
}
public class Raven.Server.Documents.Queries.Results.Counters.CountersQueryResultRetriever : TimeSeriesQueryResultRetriever {
    public CountersQueryResultRetriever(DocumentDatabase database, IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsStorage documentsStorage, JsonOperationContext context, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
}
public interface Raven.Server.Documents.Queries.Results.IQueryResultRetriever {
    public abstract virtual ValueTuple`2<Document, List`1<Document>> Get(RetrieverInput& retrieverInput, CancellationToken token);
    public abstract virtual bool TryGetKeyLucene(RetrieverInput& retrieverInput, String& key);
    public abstract virtual bool TryGetKeyCorax(TermsReader searcher, long id, UnmanagedSpan& key);
    public abstract virtual Document DirectGet(RetrieverInput& retrieverInput, string id, DocumentFields fields);
}
public class Raven.Server.Documents.Queries.Results.MapQueryResultRetriever : QueryResultRetrieverBase {
    private DocumentsOperationContext _context;
    private QueryTimingsScope _storageScope;
    public MapQueryResultRetriever(DocumentDatabase database, IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsStorage documentsStorage, DocumentsOperationContext context, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
    public virtual ValueTuple`2<Document, List`1<Document>> Get(RetrieverInput& retrieverInput, CancellationToken token);
    public virtual bool TryGetKeyLucene(RetrieverInput& retrieverInput, String& key);
    public virtual bool TryGetKeyCorax(TermsReader searcher, long id, UnmanagedSpan& key);
    public virtual Document DirectGet(RetrieverInput& retrieverInput, string id, DocumentFields fields);
    protected virtual Document LoadDocument(string id);
    protected virtual Nullable`1<long> GetCounter(string docId, string name);
    protected virtual DynamicJsonValue GetCounterRaw(string docId, string name);
}
public class Raven.Server.Documents.Queries.Results.MapReduceQueryResultRetriever : StoredValueQueryResultRetriever {
    public MapReduceQueryResultRetriever(DocumentDatabase database, IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsStorage documentsStorage, JsonOperationContext context, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
}
public class Raven.Server.Documents.Queries.Results.ProjectionOptions : object {
    public bool MustExtractFromIndex;
    public bool MustExtractFromDocument;
    public bool MustExtractOrThrow;
    internal IndexQueryServerSide _query;
    public ProjectionOptions(IndexQueryServerSide query);
    [DoesNotReturnAttribute]
public void ThrowCouldNotExtractProjectionOnDocumentBecauseDocumentDoesNotExistException(string documentId);
    [DoesNotReturnAttribute]
public void ThrowCouldNotExtractFieldFromDocumentBecauseDocumentDoesNotExistException(string documentId, string fieldName);
    [DoesNotReturnAttribute]
public void ThrowCouldNotExtractFieldFromDocumentBecauseDocumentDoesNotContainSuchField(string documentId, string fieldName);
    [DoesNotReturnAttribute]
public void ThrowCouldNotExtractFieldFromIndexBecauseIndexDoesNotContainSuchFieldOrFieldValueIsNotStored(string fieldName);
}
public abstract class Raven.Server.Documents.Queries.Results.QueryResultRetrieverBase : object {
    public static int LoadedDocumentsCacheSize;
    public static ScoreDoc ZeroScore;
    public static ScoreDoc OneScore;
    private ScriptRunnerCache _scriptRunnerCache;
    protected IndexQueryServerSide _query;
    private JsonOperationContext _context;
    private IncludeDocumentsCommand _includeDocumentsCommand;
    private IncludeRevisionsCommand _includeRevisionsCommand;
    private IncludeCompareExchangeValuesCommand _includeCompareExchangeValuesCommand;
    private char _identitySeparator;
    private BlittableJsonTraverser _blittableTraverser;
    private LruDictionary`2<string, Document> _loadedDocuments;
    private Dictionary`2<string, Document> _loadedDocumentsByAliasName;
    private HashSet`1<string> _loadedDocumentIds;
    protected DocumentFields DocumentFields;
    protected DocumentsStorage DocumentsStorage;
    protected FieldsToFetch FieldsToFetch;
    protected QueryTimingsScope RetrieverScope;
    protected SearchEngineType SearchEngineType;
    private QueryTimingsScope _projectionScope;
    private QueryTimingsScope _projectionStorageScope;
    private QueryTimingsScope _functionScope;
    private QueryTimingsScope _loadScope;
    private TimeSeriesRetriever _timeSeriesRetriever;
    protected QueryResultRetrieverBase(ScriptRunnerCache scriptRunnerCache, IndexQueryServerSide query, QueryTimingsScope queryTimings, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, DocumentsStorage documentsStorage, JsonOperationContext context, bool reduceResults, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand, char identitySeparator);
    private static QueryResultRetrieverBase();
    protected virtual void ValidateFieldsToFetch(FieldsToFetch fieldsToFetch);
    protected void FinishDocumentSetup(Document doc, RetrieverInput& retrieverInput);
    public abstract virtual ValueTuple`2<Document, List`1<Document>> Get(RetrieverInput& retrieverInput, CancellationToken token);
    public abstract virtual bool TryGetKeyLucene(RetrieverInput& retrieverInput, String& key);
    public abstract virtual bool TryGetKeyCorax(TermsReader searcher, long id, UnmanagedSpan& key);
    public abstract virtual Document DirectGet(RetrieverInput& retrieverInput, string id, DocumentFields fields);
    protected abstract virtual Document LoadDocument(string id);
    protected abstract virtual Nullable`1<long> GetCounter(string docId, string name);
    protected abstract virtual DynamicJsonValue GetCounterRaw(string docId, string name);
    protected ValueTuple`2<Document, List`1<Document>> GetProjection(RetrieverInput& retrieverInput, string lowerId, CancellationToken token);
    private bool TryExtractValueFromIndex(RetrieverInput& retrieverInput, FieldToFetch fieldToFetch, DynamicJsonValue result);
    public ValueTuple`2<Document, List`1<Document>> GetProjectionFromDocument(Document doc, RetrieverInput& retrieverInput, FieldsToFetch fieldsToFetch, JsonOperationContext context, CancellationToken token);
    private ValueTuple`2<Document, List`1<Document>> GetProjectionFromDocumentInternal(Document doc, RetrieverInput& retrieverInput, FieldsToFetch fieldsToFetch, JsonOperationContext context, CancellationToken token);
    protected ValueTuple`2<Document, List`1<Document>> AddProjectionToResult(Document doc, RetrieverInput& retrieverInput, FieldsToFetch fieldsToFetch, DynamicJsonValue result, string key, object fieldVal);
    private ValueTuple`2<Document, List`1<Document>> CreateNewDocument(Document doc, string key, object fieldVal);
    protected static void AddProjectionToResult(DynamicJsonValue result, string key, object fieldVal);
    [DoesNotReturnAttribute]
private static void ThrowInvalidQueryBodyResponse(object fieldVal);
    protected Document ReturnProjection(DynamicJsonValue result, Document doc, JsonOperationContext context, RetrieverInput& retrieverInput);
    private bool LuceneTryExtractValueFromIndex(FieldToFetch fieldToFetch, Document indexDocument, DynamicJsonValue toFill, IState state);
    private bool CoraxTryExtractValueFromIndex(FieldToFetch fieldToFetch, RetrieverInput& retrieverInput, DynamicJsonValue toFill);
    internal static FieldType GetFieldType(string field, Document indexDocument);
    private static bool TryGetValueFromCoraxIndex(JsonOperationContext context, string fieldName, RetrieverInput& retrieverInput, Object& value);
    private static object ConvertType(JsonOperationContext context, IFieldable field, FieldType fieldType, IState state);
    [DoesNotReturnAttribute]
private static void ThrowBinaryValuesNotSupported();
    private bool TryGetValue(FieldToFetch fieldToFetch, Document document, RetrieverInput& retrieverInput, Dictionary`2<string, IndexField> indexFields, Nullable`1<bool> anyDynamicIndexFields, String& key, Object& value, CancellationToken token);
    protected object GetFunctionValue(FieldToFetch fieldToFetch, string documentId, Object[] args, CancellationToken token);
    private object InvokeFunction(string methodName, Query query, string documentId, Object[] args, QueryTimingsScope timings, CancellationToken token);
    private static bool TryGetTimeSeriesFunction(string methodName, Query query, DeclaredFunction& func);
    private bool TryGetFieldValueFromDocument(Document document, FieldToFetch field, Object& value);
    private static string GetIdFromDocument(Document document);
    [DoesNotReturnAttribute]
private static void ThrowOnlyArrayFieldCanHaveMultipleValues(FieldToFetch fieldToFetch);
    [CompilerGeneratedAttribute]
internal static void <TryGetValueFromCoraxIndex>g__SetValue|47_0(Object& value, object newVal);
}
public class Raven.Server.Documents.Queries.Results.RetrieverInput : ValueType {
    public IndexFieldsMapping KnownFields;
    public EntryTermsReader CoraxTermsReader;
    public IState State;
    public Document LuceneDocument;
    public string DocumentId;
    public ScoreDoc Score;
    public Nullable`1<float> CoraxScore;
    public Nullable`1<SpatialResult> CoraxDistance;
    public IndexSearcher CoraxIndexSearcher;
    public Func`2<string, bool> HasTime;
    public RetrieverInput(Document luceneDocument, ScoreDoc score, IState state);
    public RetrieverInput(IndexSearcher searcher, IndexFieldsMapping knownFields, EntryTermsReader& reader, string id, Func`2<string, bool> hasTime, Nullable`1<float> score, Nullable`1<SpatialResult> distance);
    public bool IsLuceneDocument();
}
public class Raven.Server.Documents.Queries.Results.Sharding.ShardedMapReduceResultRetriever : QueryResultRetrieverBase {
    public ShardedMapReduceResultRetriever(ScriptRunnerCache scriptRunnerCache, IndexQueryServerSide query, QueryTimingsScope queryTimings, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, DocumentsStorage documentsStorage, JsonOperationContext context, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand, char identitySeparator);
    public virtual ValueTuple`2<Document, List`1<Document>> Get(RetrieverInput& retrieverInput, CancellationToken token);
    public virtual bool TryGetKeyLucene(RetrieverInput& retrieverInput, String& key);
    public virtual bool TryGetKeyCorax(TermsReader searcher, long id, UnmanagedSpan& key);
    public virtual Document DirectGet(RetrieverInput& retrieverInput, string id, DocumentFields fields);
    protected virtual Document LoadDocument(string id);
    protected virtual Nullable`1<long> GetCounter(string docId, string name);
    protected virtual DynamicJsonValue GetCounterRaw(string docId, string name);
}
public abstract class Raven.Server.Documents.Queries.Results.StoredValueQueryResultRetriever : QueryResultRetrieverBase {
    private string _storedValueFieldName;
    private JsonOperationContext _context;
    private QueryTimingsScope _storageScope;
    protected StoredValueQueryResultRetriever(string storedValueFieldName, DocumentDatabase database, IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsStorage documentsStorage, JsonOperationContext context, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
    protected virtual void ValidateFieldsToFetch(FieldsToFetch fieldsToFetch);
    protected virtual Document LoadDocument(string id);
    protected virtual Nullable`1<long> GetCounter(string docId, string name);
    protected virtual DynamicJsonValue GetCounterRaw(string docId, string name);
    public virtual Document DirectGet(RetrieverInput& retrieverInput, string id, DocumentFields fields);
    public virtual ValueTuple`2<Document, List`1<Document>> Get(RetrieverInput& retrieverInput, CancellationToken token);
    public virtual bool TryGetKeyLucene(RetrieverInput& retrieverInput, String& key);
    public virtual bool TryGetKeyCorax(TermsReader searcher, long id, UnmanagedSpan& key);
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Documents.Queries.Results.TimeSeries.AggregationHolder : object {
    public static object NullBucket;
    private ObjectPool`2<ITimeSeriesAggregation[], TimeSeriesAggregationReset> _pool;
    private int _poolSize;
    private DocumentsOperationContext _context;
    private InterpolationType _interpolationType;
    private AggregationType[] _types;
    private String[] _names;
    private Nullable`1<double> _percentile;
    private Dictionary`2<object, ITimeSeriesAggregation[]> _current;
    private Dictionary`2<object, PreviousAggregation> _previous;
    public bool HasValues { get; }
    public ITimeSeriesAggregation[] Item { get; }
    public AggregationHolder(DocumentsOperationContext context, Dictionary`2<AggregationType, string> types, InterpolationType interpolationType, Nullable`1<double> percentile);
    private static AggregationHolder();
    public bool Contains(AggregationType type);
    public bool get_HasValues();
    private ITimeSeriesAggregation[] TimeSeriesAggregationFactory();
    public ITimeSeriesAggregation[] get_Item(object bucket);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.Results.TimeSeries.AggregationHolder/<AddCurrentToResults>d__17")]
public IEnumerable`1<DynamicJsonValue> AddCurrentToResults(RangeGroup range, Nullable`1<double> scale);
    private DynamicJsonValue ToJson(Nullable`1<double> scale, Nullable`1<DateTime> from, Nullable`1<DateTime> to, object key, ITimeSeriesAggregation[] value);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.Results.TimeSeries.AggregationHolder/<GetGapsPerBucket>d__19")]
private IEnumerable`1<ValueTuple`3<object, PreviousAggregation, ITimeSeriesAggregation[]>> GetGapsPerBucket(DateTime to);
    private object GetNameFromKey(object key);
    private void UpdatePrevious(object key, RangeGroup range, ITimeSeriesAggregation[] values);
    private object Clone(object value);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.Results.TimeSeries.AggregationHolder/<FillMissingGaps>d__24")]
private IEnumerable`1<DynamicJsonValue> FillMissingGaps(RangeGroup range, Nullable`1<double> scale);
    private static void LinearInterpolation(double quotient, List`1<double> valuesA, List`1<double> valuesB, Double[] result);
}
public class Raven.Server.Documents.Queries.Results.TimeSeries.AverageAggregation : TimeSeriesAggregationBase {
    private List`1<double> _count;
    public AverageAggregation(string name);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Segment(Span`1<StatefulTimestampValue> values, bool isRaw);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Step(Span`1<double> values, bool isRaw);
    private sealed virtual override IEnumerable`1<double> Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.GetFinalValues(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<double> scale);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Clear();
    private void InitValuesIfNeeded(int upTo);
}
public interface Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation {
    public bool Any { get; }
    public string Name { get; }
    public int NumberOfValues { get; }
    public AggregationType Aggregation { get; }
    public abstract virtual void Segment(Span`1<StatefulTimestampValue> values, bool isRaw);
    public abstract virtual void Step(Span`1<double> values, bool isRaw);
    public abstract virtual IEnumerable`1<double> GetFinalValues(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<double> scale);
    public abstract virtual void Clear();
    public abstract virtual bool get_Any();
    public abstract virtual string get_Name();
    public abstract virtual int get_NumberOfValues();
    public abstract virtual AggregationType get_Aggregation();
}
public class Raven.Server.Documents.Queries.Results.TimeSeries.PercentileAggregation : TimeSeriesAggregationBase {
    private double _percentileFactor;
    private List`1<SortedDictionary`2<double, int>> _rankedValues;
    private List`1<long> _count;
    public int NumberOfValues { get; }
    public PercentileAggregation(string name, Nullable`1<double> percentile);
    public sealed virtual int get_NumberOfValues();
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Segment(Span`1<StatefulTimestampValue> values, bool isRaw);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Step(Span`1<double> values, bool isRaw);
    private sealed virtual override IEnumerable`1<double> Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.GetFinalValues(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<double> scale);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Clear();
    private void InitValuesIfNeeded(int upTo);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Queries.Results.TimeSeries.PercentileAggregation/<GetPercentile>d__11")]
private IEnumerable`1<double> GetPercentile(double scale);
}
public class Raven.Server.Documents.Queries.Results.TimeSeries.SlopeAggregation : TimeSeriesAggregationBase {
    private List`1<double> _first;
    public SlopeAggregation(string name);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Step(Span`1<double> values, bool isRaw);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Segment(Span`1<StatefulTimestampValue> values, bool isRaw);
    private sealed virtual override IEnumerable`1<double> Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.GetFinalValues(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<double> scale);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Clear();
    private void InitValuesIfNeeded(int upTo);
    private void StepOnRollup(Span`1<double> values);
    private void SegmentOnRollup(Span`1<StatefulTimestampValue> values);
}
public class Raven.Server.Documents.Queries.Results.TimeSeries.StandardDeviationAggregation : TimeSeriesAggregationBase {
    private List`1<List`1<double>> _allValues;
    public StandardDeviationAggregation(string name);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Segment(Span`1<StatefulTimestampValue> values, bool isRaw);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Step(Span`1<double> values, bool isRaw);
    private sealed virtual override IEnumerable`1<double> Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.GetFinalValues(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<double> scale);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Clear();
    private void InitValuesIfNeeded(int upTo);
}
public class Raven.Server.Documents.Queries.Results.TimeSeries.TimeSeriesAggregation : TimeSeriesAggregationBase {
    public TimeSeriesAggregation(AggregationType type, string name);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Segment(Span`1<StatefulTimestampValue> values, bool isRaw);
    private sealed virtual override void Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.Step(Span`1<double> values, bool isRaw);
    private sealed virtual override IEnumerable`1<double> Raven.Server.Documents.Queries.Results.TimeSeries.ITimeSeriesAggregation.GetFinalValues(Nullable`1<DateTime> from, Nullable`1<DateTime> to, Nullable`1<double> scale);
    private void SegmentOnRollup(Span`1<StatefulTimestampValue> values);
    private void StepOnRollup(Span`1<double> values);
    private void InitValuesIfNeeded(int upTo);
}
public abstract class Raven.Server.Documents.Queries.Results.TimeSeries.TimeSeriesAggregationBase : object {
    [CompilerGeneratedAttribute]
private AggregationType <Aggregation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    protected List`1<double> _values;
    protected IEnumerable`1<double> _finalValues;
    public AggregationType Aggregation { get; }
    public string Name { get; }
    public bool Any { get; }
    public int NumberOfValues { get; }
    protected TimeSeriesAggregationBase(AggregationType type, string name);
    [CompilerGeneratedAttribute]
public sealed virtual AggregationType get_Aggregation();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual bool get_Any();
    public sealed virtual int get_NumberOfValues();
    public sealed virtual void Clear();
}
public class Raven.Server.Documents.Queries.Results.TimeSeries.TimeSeriesQueryResultRetriever : StoredValueQueryResultRetriever {
    public TimeSeriesQueryResultRetriever(DocumentDatabase database, IndexQueryServerSide query, QueryTimingsScope queryTimings, DocumentsStorage documentsStorage, JsonOperationContext context, SearchEngineType searchEngineType, FieldsToFetch fieldsToFetch, IncludeDocumentsCommand includeDocumentsCommand, IncludeCompareExchangeValuesCommand includeCompareExchangeValuesCommand, IncludeRevisionsCommand includeRevisionsCommand);
}
public class Raven.Server.Documents.Queries.Results.TimeSeries.TimeSeriesRetriever : object {
    private Dictionary`2<ValueExpression, object> _valuesDictionary;
    private Dictionary`2<FieldExpression, object> _argumentValuesDictionary;
    private BlittableJsonReaderObject _queryParameters;
    private DocumentsOperationContext _context;
    private LruDictionary`2<string, Document> _loadedDocuments;
    private CancellationToken _token;
    private Dictionary`2<LazyStringValue, object> _bucketByTag;
    private string _source;
    private string _collection;
    private bool _quoted;
    private String[] _namedValues;
    private bool _configurationFetched;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`3<long, DateTime, DateTime> _stats;
    private Nullable`1<double> _scale;
    private bool _individualValuesOnly;
    private static String[] SupportedDateTimeFormats;
    public TimeSeriesRetriever(DocumentsOperationContext context, BlittableJsonReaderObject queryParameters, LruDictionary`2<string, Document> loadedDocuments, CancellationToken token);
    private static TimeSeriesRetriever();
    private static Dictionary`2<AggregationType, string> AllAggregationTypes();
    public IEnumerable`1<DynamicJsonValue> InvokeTimeSeriesFunction(DeclaredFunction declaredFunction, string documentId, Object[] args, ResultType& resultType);
    private static RangeGroup InitializeRangeSpecs(string groupByTimePeriod, DateTime from, DateTime to, Nullable`1<TimeSpan> offset);
    private static bool IsLastDuplicate(TimeSeriesValuesSegment segment, AggregationHolder aggregationHolder);
    private ValueTuple`3<long, DateTime, DateTime> GetStatsAndRemoveQuotesIfNeeded(string documentId);
    private static InterpolationType GetInterpolationType(MethodExpression groupByWith);
    private Nullable`1<double> GetScale(DeclaredFunction declaredFunction, ValueExpression scaleExpression);
    private static object GetValueFromRolledUpEntry(int index, SingleResult singleResult);
    private object GetNamedValue(string fieldValue, SingleResult singleResult, bool isRaw);
    public BlittableJsonReaderObject MaterializeResults(IEnumerable`1<DynamicJsonValue> array, ResultType type, bool addProjectionToResult, bool fromStudio);
    public TimeSeriesStreamingRetrieverResult PrepareForStreaming(IEnumerable`1<DynamicJsonValue> array, bool addProjectionToResult, bool fromStudio);
    private long GetCount(ResultType type, DynamicJsonValue results);
    private long GetRawSum(DynamicJsonValue value);
    private long GetAggregatedSum(DynamicJsonValue value);
    private void AddNames(DynamicJsonValue result);
    private ValueTuple`2<DateTime, DateTime> GetFromAndTo(DeclaredFunction declaredFunction, string documentId, Object[] args, TimeSeriesFunction timeSeriesFunction);
    private TimeValue GetTimePeriodFromValueExpression(ValueExpression valueExpression, string methodName, string functionName, string documentId);
    private Nullable`1<TimeSpan> GetOffset(ValueExpression offsetExpression, string name);
    private string GetCollection(string documentId);
    private static object GetValueFromArgument(DeclaredFunction declaredFunction, Object[] args, FieldExpression fe);
    private static int GetParameterIndex(DeclaredFunction declaredFunction, StringSegment str);
    private static object GetFieldFromDocument(FieldExpression fe, Document document);
    private object GetValueFromLoadedTag(FieldExpression fe, SingleResult singleResult);
    private AggregationHolder GetAggregationHolder(TimeSeriesFunction timeSeriesFunction);
    private Dictionary`2<AggregationType, string> GetAggregationTypesFromSelectExpressions(TimeSeriesFunction timeSeriesFunction, Nullable`1& percentile);
    private Nullable`1<DateTime> GetDateValue(QueryExpression qe, DeclaredFunction func, Object[] args);
    public static DateTime ParseDateTime(string valueAsStr);
    [CompilerGeneratedAttribute]
internal static bool <InvokeTimeSeriesFunction>g__CompareLazyNumbers|18_10(LazyNumberValue lnv, object right, <>c__DisplayClass18_2& );
    [CompilerGeneratedAttribute]
internal static bool <InvokeTimeSeriesFunction>g__CompareDateTimes|18_11(Nullable`1<DateTime> dateTime, object right, <>c__DisplayClass18_2& );
    [CompilerGeneratedAttribute]
internal static bool <InvokeTimeSeriesFunction>g__CompareLazyStrings|18_12(LazyStringValue lsv, object right, <>c__DisplayClass18_2& );
    [CompilerGeneratedAttribute]
internal static bool <InvokeTimeSeriesFunction>g__CompareStrings|18_13(string s, object right, <>c__DisplayClass18_2& );
}
public class Raven.Server.Documents.Queries.Revisions.RevisionIncludeField : object {
    internal HashSet`1<string> RevisionsChangeVectorsPaths;
    internal Nullable`1<DateTime> RevisionsBeforeDateTime;
    public void AddRevision(string path);
    public void AddRevision(DateTime dateTime);
}
public class Raven.Server.Documents.Queries.SelectField : object {
    public Nullable`1<ValueTokenType> ValueTokenType;
    public QueryFieldName Name;
    public string Alias;
    public object Value;
    public string SourceAlias;
    public bool IsEdge;
    public bool IsVertex;
    public bool IsParameter;
    public bool IsQuoted;
    public string LoadFromAlias;
    public AggregationOperation AggregationOperation;
    public bool IsGroupByKey;
    public GroupByField[] GroupByKeys;
    public String[] GroupByKeyNames;
    public string Function;
    public bool SourceIsArray;
    public SelectField[] FunctionArgs;
    public bool HasSourceAlias;
    public bool IsFacet;
    public bool IsSuggest;
    public bool IsCounter;
    public FieldExpression ExpressionField;
    public static SelectField Create(QueryFieldName name, string alias);
    public static SelectField Create(QueryFieldName name, string alias, string sourceAlias, bool array, bool hasSourceAlias, bool isParameter, bool isQuoted, string loadFromAlias);
    public static SelectField CreateGroupByAggregation(QueryFieldName name, string alias, AggregationOperation aggregation);
    public static SelectField CreateGroupByKeyField(string alias, GroupByField[] groupByKeys);
    public static SelectField CreateMethodCall(string methodName, string alias, SelectField[] args);
    public static SelectField CreateCounterField(string alias, SelectField[] args);
    public static SelectField CreateValue(string val, string alias, ValueTokenType type);
}
public class Raven.Server.Documents.Queries.Sharding.ShardedIndexEntriesQueryResult : IndexEntriesQueryResult {
}
public class Raven.Server.Documents.Queries.Sharding.ShardedQueryResult : QueryResultServerSide`1<BlittableJsonReaderObject> {
    private IRevisionIncludes _includeRevisions;
    private ICounterIncludes _counterIncludes;
    private ITimeSeriesIncludes _includeTimeSeries;
    private ICompareExchangeValueIncludes _includeCompareExchangeValues;
    private List`1<IDisposable> _shardContextsToDispose;
    public bool SupportsExceptionHandling { get; }
    public bool SupportsInclude { get; }
    public bool SupportsHighlighting { get; }
    public bool SupportsExplanations { get; }
    public virtual ValueTask AddResultAsync(BlittableJsonReaderObject result, CancellationToken token);
    public virtual void AddHighlightings(Dictionary`2<string, Dictionary`2<string, String[]>> highlightings);
    public virtual void AddExplanation(ExplanationResult explanationResult);
    public virtual ValueTask HandleExceptionAsync(Exception e, CancellationToken token);
    public virtual bool get_SupportsExceptionHandling();
    public virtual bool get_SupportsInclude();
    public virtual bool get_SupportsHighlighting();
    public virtual bool get_SupportsExplanations();
    public virtual void AddCounterIncludes(ICounterIncludes counters);
    public virtual ICounterIncludes GetCounterIncludes();
    public virtual void AddTimeSeriesIncludes(ITimeSeriesIncludes timeSeries);
    public virtual ITimeSeriesIncludes GetTimeSeriesIncludes();
    public virtual void AddCompareExchangeValueIncludes(ICompareExchangeValueIncludes values);
    public virtual Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> GetCompareExchangeValueIncludes();
    public virtual void AddRevisionIncludes(IRevisionIncludes revisions);
    public virtual IRevisionIncludes GetRevisionIncludes();
    public void AddToDispose(IDisposable disposable);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Queries.Sorting.AlphaNumeric.AlphaNumericComparatorSource : FieldComparatorSource {
    private DocumentsOperationContext _context;
    public AlphaNumericComparatorSource(DocumentsOperationContext context);
    public virtual FieldComparator NewComparator(string fieldname, int numHits, int sortPos, bool reversed);
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Documents.Queries.Sorting.AlphaNumeric.AlphaNumericFieldComparator : FieldComparator {
    private UnmanagedString[] _values;
    private string _field;
    private UnmanagedString _bottom;
    private Int32[] _order;
    private UnmanagedStringArray _lookup;
    private static UnmanagedString NullValue;
    public IComparable Item { get; }
    public AlphaNumericFieldComparator(string field, int numHits);
    private static AlphaNumericFieldComparator();
    private static UnmanagedString GetNullValueUnmanagedString();
    public virtual int Compare(int slot1, int slot2);
    private static bool IsNull(UnmanagedString str1);
    public virtual void SetBottom(int slot);
    public virtual int CompareBottom(int doc, IState state);
    public virtual void Copy(int slot, int doc, IState state);
    public virtual void SetNextReader(IndexReader reader, int docBase, IState state);
    public virtual IComparable get_Item(int slot);
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Documents.Queries.Sorting.AlphaNumeric.RandomFieldComparator : FieldComparator {
    private Random _random;
    private Int32[] _values;
    private int _bottom;
    private Int32[] _currentReaderValues;
    public IComparable Item { get; }
    internal RandomFieldComparator(string field, int numHits);
    public virtual int Compare(int slot1, int slot2);
    public virtual int CompareBottom(int doc, IState state);
    public virtual void Copy(int slot, int doc, IState state);
    public virtual void SetNextReader(IndexReader reader, int docBase, IState state);
    public virtual IComparable get_Item(int slot);
    public virtual void SetBottom(int bottom);
}
public class Raven.Server.Documents.Queries.Sorting.AlphaNumeric.RandomFieldComparatorSource : FieldComparatorSource {
    public static RandomFieldComparatorSource Instance;
    private static RandomFieldComparatorSource();
    public virtual FieldComparator NewComparator(string fieldname, int numHits, int sortPos, bool reversed);
}
public class Raven.Server.Documents.Queries.Sorting.AlphaNumeric.RandomSortField : SortField {
    public FieldComparatorSource ComparatorSource { get; }
    public RandomSortField(string field);
    public virtual FieldComparator GetComparator(int numHits, int sortPos);
    public virtual FieldComparatorSource get_ComparatorSource();
}
public class Raven.Server.Documents.Queries.Sorting.Custom.CustomComparatorSource : FieldComparatorSource {
    private IndexQueryServerSide _query;
    private SorterFactory _factory;
    public CustomComparatorSource(string sorterName, string databaseName, IndexQueryServerSide query);
    public virtual FieldComparator NewComparator(string fieldName, int numHits, int sortPos, bool reversed);
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Documents.Queries.Sorting.Custom.TestFieldComparator : FieldComparator {
    private FieldComparator _comparator;
    private List`1<string> _diagnostics;
    public IComparable Item { get; }
    public TestFieldComparator(FieldComparator comparator, List`1<string> diagnostics);
    public virtual int Compare(int slot1, int slot2);
    public virtual void SetBottom(int slot);
    public virtual int CompareBottom(int doc, IState state);
    public virtual void Copy(int slot, int doc, IState state);
    public virtual void SetNextReader(IndexReader reader, int docBase, IState state);
    public virtual IComparable get_Item(int slot);
    private void Executed(string method, string args);
    private void Executed(string method, string args, object result);
    private void Executing(string method, string args);
}
public class Raven.Server.Documents.Queries.StaticIndexQueryRunner : AbstractDatabaseQueryRunner {
    public StaticIndexQueryRunner(DocumentDatabase database);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StaticIndexQueryRunner/<ExecuteQuery>d__1")]
public virtual Task`1<DocumentQueryResult> ExecuteQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StaticIndexQueryRunner/<ExecuteStreamQuery>d__2")]
public virtual Task ExecuteStreamQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<Document> writer, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StaticIndexQueryRunner/<ExecuteStreamIndexEntriesQuery>d__3")]
public virtual Task ExecuteStreamIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, HttpResponse response, IStreamQueryResultWriter`1<BlittableJsonReaderObject> writer, bool ignoreLimit, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StaticIndexQueryRunner/<ExecuteIndexEntriesQuery>d__4")]
public virtual Task`1<IndexEntriesQueryResult> ExecuteIndexEntriesQuery(IndexQueryServerSide query, QueryOperationContext queryContext, bool ignoreLimit, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StaticIndexQueryRunner/<ExecuteFacetedQuery>d__5")]
public Task`1<FacetedQueryResult> ExecuteFacetedQuery(IndexQueryServerSide query, Nullable`1<long> existingResultEtag, QueryOperationContext queryContext, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StaticIndexQueryRunner/<ExecuteDeleteQuery>d__6")]
public virtual Task`1<IOperationResult> ExecuteDeleteQuery(IndexQueryServerSide query, QueryOperationOptions options, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StaticIndexQueryRunner/<ExecutePatchQuery>d__7")]
public virtual Task`1<IOperationResult> ExecutePatchQuery(IndexQueryServerSide query, QueryOperationOptions options, PatchRequest patch, BlittableJsonReaderObject patchArgs, QueryOperationContext queryContext, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StaticIndexQueryRunner/<ExecuteSuggestionQuery>d__8")]
public virtual Task`1<SuggestionQueryResult> ExecuteSuggestionQuery(IndexQueryServerSide query, QueryOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
}
public class Raven.Server.Documents.Queries.StreamBlittableDocumentQueryResultWriter : AbstractDocumentStreamQueryResultWriter`1<BlittableJsonReaderObject> {
    private bool _first;
    public StreamBlittableDocumentQueryResultWriter(Stream stream, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StreamBlittableDocumentQueryResultWriter/<AddResultAsync>d__2")]
public virtual ValueTask AddResultAsync(BlittableJsonReaderObject res, CancellationToken token);
}
public class Raven.Server.Documents.Queries.StreamDocumentIndexEntriesQueryResult : StreamQueryResult`1<BlittableJsonReaderObject> {
    public StreamDocumentIndexEntriesQueryResult(HttpResponse response, IStreamQueryResultWriter`1<BlittableJsonReaderObject> writer, Nullable`1<long> indexDefinitionRaftIndex, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StreamDocumentIndexEntriesQueryResult/<AddResultAsync>d__0")]
public virtual ValueTask AddResultAsync(BlittableJsonReaderObject result, CancellationToken token);
}
public class Raven.Server.Documents.Queries.StreamDocumentQueryResult : StreamQueryResult`1<Document> {
    private DocumentsOperationContext _context;
    public StreamDocumentQueryResult(HttpResponse response, IStreamQueryResultWriter`1<Document> writer, DocumentsOperationContext context, Nullable`1<long> indexDefinitionRaftIndex, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StreamDocumentQueryResult/<AddResultAsync>d__1")]
public virtual ValueTask AddResultAsync(Document result, CancellationToken token);
}
public class Raven.Server.Documents.Queries.StreamJsonDocumentQueryResultWriter : AbstractDocumentStreamQueryResultWriter`1<Document> {
    private bool _first;
    public StreamJsonDocumentQueryResultWriter(Stream stream, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StreamJsonDocumentQueryResultWriter/<AddResultAsync>d__2")]
public virtual ValueTask AddResultAsync(Document res, CancellationToken token);
}
public class Raven.Server.Documents.Queries.StreamJsonlDocumentQueryResultWriter : object {
    private AsyncBlittableJsonTextWriter _writer;
    private JsonOperationContext _context;
    public bool SupportError { get; }
    public bool SupportStatistics { get; }
    public StreamJsonlDocumentQueryResultWriter(Stream stream, JsonOperationContext context);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void StartResponse();
    public sealed virtual void StartResults();
    public sealed virtual void EndResults();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StreamJsonlDocumentQueryResultWriter/<AddResultAsync>d__7")]
public sealed virtual ValueTask AddResultAsync(Document res, CancellationToken token);
    public sealed virtual void EndResponse();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StreamJsonlDocumentQueryResultWriter/<WriteErrorAsync>d__9")]
public sealed virtual ValueTask WriteErrorAsync(Exception e);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StreamJsonlDocumentQueryResultWriter/<WriteErrorAsync>d__10")]
public sealed virtual ValueTask WriteErrorAsync(string error);
    public sealed virtual void WriteQueryStatistics(long resultEtag, bool isStale, string indexName, long totalResults, DateTime timestamp);
    public bool get_SupportError();
    public sealed virtual bool get_SupportStatistics();
}
public abstract class Raven.Server.Documents.Queries.StreamQueryResult`1 : QueryResultServerSide`1<T> {
    private IStreamQueryResultWriter`1<T> _writer;
    private OperationCancelToken _token;
    private bool _anyWrites;
    private bool _anyExceptions;
    public bool SupportsExceptionHandling { get; }
    public bool SupportsInclude { get; }
    public bool SupportsHighlighting { get; }
    public bool SupportsExplanations { get; }
    protected StreamQueryResult`1(HttpResponse response, IStreamQueryResultWriter`1<T> writer, Nullable`1<long> indexDefinitionRaftIndex, OperationCancelToken token);
    public IStreamQueryResultWriter`1<T> GetWriter();
    public OperationCancelToken GetToken();
    public bool HasAnyWrites();
    public virtual void AddHighlightings(Dictionary`2<string, Dictionary`2<string, String[]>> highlightings);
    public virtual void AddExplanation(ExplanationResult explanationResult);
    public virtual void AddCounterIncludes(ICounterIncludes includeCountersCommand);
    public virtual void AddTimeSeriesIncludes(ITimeSeriesIncludes includeTimeSeriesCommand);
    public virtual ICounterIncludes GetCounterIncludes();
    public virtual IRevisionIncludes GetRevisionIncludes();
    public virtual ITimeSeriesIncludes GetTimeSeriesIncludes();
    public virtual void AddCompareExchangeValueIncludes(ICompareExchangeValueIncludes values);
    public virtual void AddRevisionIncludes(IRevisionIncludes revisions);
    public virtual Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> GetCompareExchangeValueIncludes();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Queries.StreamQueryResult`1/<HandleExceptionAsync>d__18")]
public virtual ValueTask HandleExceptionAsync(Exception e, CancellationToken token);
    public void StartResponseIfNeeded();
    public virtual bool get_SupportsExceptionHandling();
    public virtual bool get_SupportsInclude();
    public virtual bool get_SupportsHighlighting();
    public virtual bool get_SupportsExplanations();
    public void Flush();
    private void StartResponse();
    private void EndResponse();
}
public class Raven.Server.Documents.Queries.Suggestions.SuggestionField : SelectField {
    private string _termAsStringOrParameterName;
    private ValueTokenType _termType;
    private List`1<string> _terms;
    private string _optionsAsStringOrParameterName;
    private ValueTokenType _optionsType;
    private SuggestionOptions _options;
    internal bool HasOptions { get; }
    internal bool get_HasOptions();
    public List`1<string> GetTerms(JsonOperationContext context, BlittableJsonReaderObject parameters);
    public SuggestionOptions GetOptions(JsonOperationContext context, BlittableJsonReaderObject parameters);
    public void AddTerm(string termAsStringOrParameterName, ValueTokenType type);
    public void AddOptions(string optionsAsStringOrParameterName, ValueTokenType type);
}
public class Raven.Server.Documents.Queries.Suggestions.SuggestionQueryResult : QueryResult`2<List`1<SuggestionResult>, List`1<Document>> {
    public static SuggestionQueryResult NotModifiedResult;
    [CompilerGeneratedAttribute]
private bool <NotModified>k__BackingField;
    public bool NotModified { get; private set; }
    private static SuggestionQueryResult();
    [CompilerGeneratedAttribute]
public bool get_NotModified();
    [CompilerGeneratedAttribute]
private void set_NotModified(bool value);
}
public class Raven.Server.Documents.Queries.TermsQueryResultServerSide : TermsQueryResult {
    public static TermsQueryResultServerSide NotModifiedResult;
    [CompilerGeneratedAttribute]
private bool <NotModified>k__BackingField;
    public bool NotModified { get; private set; }
    private static TermsQueryResultServerSide();
    [CompilerGeneratedAttribute]
public bool get_NotModified();
    [CompilerGeneratedAttribute]
private void set_NotModified(bool value);
}
public class Raven.Server.Documents.Queries.TimeSeries.TimeSeriesIncludesField : object {
    public Dictionary`2<string, HashSet`1<AbstractTimeSeriesRange>> TimeSeries;
    public void AddTimeSeries(string timeseries, string fromStr, string toStr, string sourcePath);
    public void AddTimeSeries(string timeseries, TimeSeriesRangeType type, TimeValue time, string sourcePath);
    public void AddTimeSeries(string timeseries, TimeSeriesRangeType type, int count, string sourcePath);
}
public class Raven.Server.Documents.Queries.TimeSeries.TimeseriesIncludesHelper : object {
    public static ValueTuple`2<TimeSeriesRangeType, TimeValue> ParseTime(MethodExpression expression, string queryText, BlittableJsonReaderObject parameters);
    public static ValueTuple`2<TimeSeriesRangeType, int> ParseCount(MethodExpression expression, string queryText, BlittableJsonReaderObject parameters);
    internal static string ExtractValueFromExpression(QueryExpression expression);
}
public class Raven.Server.Documents.Queries.Timings.QueryTimingsScope : StatsScope`2<object, QueryTimingsScope> {
    private QueryInspectionNode _queryPlan;
    private QueryTimings _base;
    public QueryTimingsScope(bool start);
    public void SetQueryPlan(QueryInspectionNode plan);
    protected virtual QueryTimingsScope OpenNewScope(object stats, bool start);
    public QueryTimings ToTimings();
    public void WithBase(QueryTimings timings);
}
public abstract class Raven.Server.Documents.Queries.WhereExpressionVisitor : object {
    protected string QueryText;
    protected WhereExpressionVisitor(string queryText);
    public void Visit(QueryExpression expression, BlittableJsonReaderObject parameters);
    protected virtual void VisitBinaryExpression(BinaryExpression be);
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperatorType(QueryExpression expression);
    [DoesNotReturnAttribute]
private void ThrowUnexpectedExpression(QueryExpression expression, BlittableJsonReaderObject parameters);
    protected ValueTokenType GetValueTokenType(BlittableJsonReaderObject parameters, ValueExpression value, bool unwrapArrays);
    public abstract virtual void VisitBooleanMethod(QueryExpression leftSide, QueryExpression rightSide, OperatorType operatorType, BlittableJsonReaderObject parameters);
    public abstract virtual void VisitFieldToken(QueryExpression fieldName, QueryExpression value, BlittableJsonReaderObject parameters, Nullable`1<OperatorType> operatorType);
    public abstract virtual void VisitBetween(QueryExpression fieldName, QueryExpression firstValue, QueryExpression secondValue, BlittableJsonReaderObject parameters);
    public abstract virtual void VisitIn(QueryExpression fieldName, List`1<QueryExpression> values, BlittableJsonReaderObject parameters);
    public abstract virtual void VisitMethodTokens(StringSegment name, List`1<QueryExpression> arguments, BlittableJsonReaderObject parameters);
}
public class Raven.Server.Documents.Queries.WhereField : object {
    public AutoSpatialOptions Spatial;
    public bool IsFullTextSearch;
    public bool IsExactSearch;
    public WhereField(bool isFullTextSearch, bool isExactSearch, AutoSpatialOptions spatial);
}
public class Raven.Server.Documents.QueueSink.Commands.BatchQueueSinkScriptCommand : DocumentMergedTransactionCommand {
    private List`1<BlittableJsonReaderObject> _messages;
    private string _script;
    private QueueSinkStatsScope _scriptProcessingScope;
    private QueueSinkProcessStatistics _statistics;
    private Logger _logger;
    [CompilerGeneratedAttribute]
private int <ProcessedSuccessfully>k__BackingField;
    public int ProcessedSuccessfully { get; private set; }
    public BatchQueueSinkScriptCommand(string script, List`1<BlittableJsonReaderObject> messages, QueueSinkStatsScope scriptProcessingScope, QueueSinkProcessStatistics statistics, Logger logger);
    private BatchQueueSinkScriptCommand(string script, List`1<BlittableJsonReaderObject> messages);
    [CompilerGeneratedAttribute]
public int get_ProcessedSuccessfully();
    [CompilerGeneratedAttribute]
private void set_ProcessedSuccessfully(int value);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    [PreserveBaseOverridesAttribute]
public virtual override IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, DocumentMergedTransactionCommand> ToDto(DocumentsOperationContext context);
}
public class Raven.Server.Documents.QueueSink.Handlers.QueueSinkHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.QueueSink.Handlers.QueueSinkHandler/<PostScriptTest>d__0")]
[RavenActionAttribute("/databases/*/admin/queue-sink/test", "POST", "2", "False", "False", "True", "0")]
public Task PostScriptTest();
    [AsyncStateMachineAttribute("Raven.Server.Documents.QueueSink.Handlers.QueueSinkHandler/<PerformanceLive>d__1")]
[RavenActionAttribute("/databases/*/queue-sink/performance/live", "GET", "3", "1", "False", "False", "True", "0")]
public Task PerformanceLive();
    private Dictionary`2<string, List`1<QueueSinkProcess>> GetProcessesToReportOn();
}
public interface Raven.Server.Documents.QueueSink.IQueueSinkConsumer {
    public abstract virtual Byte[] Consume(CancellationToken cancellationToken);
    public abstract virtual Byte[] Consume(TimeSpan timeout);
    public abstract virtual void Commit();
}
public class Raven.Server.Documents.QueueSink.KafkaQueueSink : QueueSinkProcess {
    public KafkaQueueSink(QueueSinkConfiguration configuration, QueueSinkScript script, DocumentDatabase database, string tag);
    protected virtual IQueueSinkConsumer CreateConsumer();
    private static string ExportAsPem(object object);
    [CompilerGeneratedAttribute]
private void <CreateConsumer>b__1_0(IConsumer`2<string, Byte[]> consumer, Error error);
    [CompilerGeneratedAttribute]
private void <CreateConsumer>b__1_1(IConsumer`2<string, Byte[]> consumer, LogMessage logMessage);
}
public class Raven.Server.Documents.QueueSink.KafkaSinkConsumer : object {
    private IConsumer`2<string, Byte[]> _consumer;
    public KafkaSinkConsumer(IConsumer`2<string, Byte[]> consumer);
    public sealed virtual Byte[] Consume(CancellationToken cancellationToken);
    public sealed virtual Byte[] Consume(TimeSpan timeout);
    public sealed virtual void Commit();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.QueueSink.QueueSinkLoader : object {
    private static string AlertTitle;
    private QueueSinkProcess[] _processes;
    private HashSet`1<string> _uniqueConfigurationNames;
    private DatabaseRecord _databaseRecord;
    private object _loadProcessedLock;
    private DocumentDatabase _database;
    private ServerStore _serverStore;
    protected Logger Logger;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<ValueTuple`3<string, string, QueueSinkProcessStatistics>> BatchCompleted;
    [CompilerGeneratedAttribute]
private Action`1<QueueSinkProcess> ProcessAdded;
    [CompilerGeneratedAttribute]
private Action`1<QueueSinkProcess> ProcessRemoved;
    public List`1<QueueSinkConfiguration> Sinks;
    public QueueSinkProcess[] Processes { get; }
    public QueueSinkLoader(DocumentDatabase documentDatabase, ServerStore serverStore);
    public QueueSinkProcess[] get_Processes();
    [CompilerGeneratedAttribute]
public void add_BatchCompleted(Action`1<ValueTuple`3<string, string, QueueSinkProcessStatistics>> value);
    [CompilerGeneratedAttribute]
public void remove_BatchCompleted(Action`1<ValueTuple`3<string, string, QueueSinkProcessStatistics>> value);
    public void OnBatchCompleted(string configurationName, string scriptName, QueueSinkProcessStatistics statistics);
    [CompilerGeneratedAttribute]
public void add_ProcessAdded(Action`1<QueueSinkProcess> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessAdded(Action`1<QueueSinkProcess> value);
    [CompilerGeneratedAttribute]
public void add_ProcessRemoved(Action`1<QueueSinkProcess> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessRemoved(Action`1<QueueSinkProcess> value);
    public void Initialize(DatabaseRecord record);
    private void LoadProcesses(DatabaseRecord record, List`1<QueueSinkConfiguration> newQueueSinkDestinations, List`1<QueueSinkProcess> toRemove);
    [IteratorStateMachineAttribute("Raven.Server.Documents.QueueSink.QueueSinkLoader/<GetRelevantProcesses>d__25`2")]
private IEnumerable`1<QueueSinkProcess> GetRelevantProcesses(List`1<T> configurations, HashSet`1<string> uniqueNames);
    private bool ValidateConfiguration(QueueSinkConfiguration config, HashSet`1<string> uniqueNames);
    private void OnProcessRemoved(QueueSinkProcess process);
    private void OnProcessAdded(QueueSinkProcess process);
    public virtual void Dispose();
    private bool IsMyQueueSinkTask(DatabaseRecord record, T queueSinkTask, Dictionary`2& responsibleNodes);
    public static QueueSinkProcessState GetProcessState(List`1<QueueSinkScript> scripts, DocumentDatabase database, string configurationName);
    private void LogConfigurationError(QueueSinkConfiguration config, List`1<string> errors);
    private static string GetStopReason(QueueSinkProcess process, List`1<QueueSinkConfiguration> myQueueSink, Dictionary`2<string, string> responsibleNodes);
    public void HandleDatabaseRecordChange(DatabaseRecord record);
    public long GetSinkCountByBroker(QueueBrokerType brokerType);
}
public abstract class Raven.Server.Documents.QueueSink.QueueSinkProcess : object {
    internal static string KafkaTag;
    internal static string RabbitMqTag;
    private static int MinBatchSize;
    private CancellationTokenSource _cts;
    private LongRunningWork _longRunningWork;
    private static Size DefaultMaximumMemoryAllocation;
    private ThreadStats _threadAllocations;
    private MultipleUseFlag _lowMemoryFlag;
    private Size _currentMaximumAllowedMemory;
    protected Logger Logger;
    private int _statsId;
    private QueueSinkStatsAggregator _lastStats;
    private ConcurrentQueue`1<QueueSinkStatsAggregator> _lastQueueSinkStats;
    private IQueueSinkConsumer _consumer;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueSinkProcessStatistics <Statistics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueSinkConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueSinkScript <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <FallbackTime>k__BackingField;
    protected CancellationToken CancellationToken { get; }
    protected string GroupId { get; }
    public DocumentDatabase Database { get; }
    public QueueSinkProcessStatistics Statistics { get; }
    public long TaskId { get; }
    public string Tag { get; }
    public string Name { get; }
    public QueueSinkConfiguration Configuration { get; }
    public QueueSinkScript Script { get; }
    public Nullable`1<TimeSpan> FallbackTime { get; protected set; }
    protected QueueSinkProcess(QueueSinkConfiguration configuration, QueueSinkScript script, DocumentDatabase database, string tag);
    private static QueueSinkProcess();
    public static QueueSinkProcess CreateInstance(QueueSinkScript script, QueueSinkConfiguration configuration, DocumentDatabase database);
    protected CancellationToken get_CancellationToken();
    protected string get_GroupId();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public QueueSinkProcessStatistics get_Statistics();
    public long get_TaskId();
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public QueueSinkConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public QueueSinkScript get_Script();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_FallbackTime();
    [CompilerGeneratedAttribute]
protected void set_FallbackTime(Nullable`1<TimeSpan> value);
    public OngoingTaskConnectionStatus GetConnectionStatus();
    public static QueueSinkProcessState GetProcessState(DocumentDatabase database, string configurationName, string scriptName);
    protected void UpdateProcessState(QueueSinkProcessState state);
    private void Run();
    private void AddPerformanceStats(QueueSinkStatsAggregator stats);
    protected abstract virtual IQueueSinkConsumer CreateConsumer();
    public void Start();
    public static TestQueueSinkScriptResult TestScript(TestQueueSinkScript testScript, DocumentsOperationContext context, DocumentDatabase database);
    public void Stop(string reason);
    private void HandleScriptParseException(Exception e);
    private void EnterFallbackMode();
    public QueueSinkPerformanceStats[] GetPerformanceStats();
    public QueueSinkStatsAggregator GetLatestPerformanceStats();
    private bool CanContinueBatch(QueueSinkStatsScope stats, int batchSize, DocumentsOperationContext ctx);
    protected void EnsureThreadAllocationStats();
    public sealed virtual void Dispose();
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    [CompilerGeneratedAttribute]
private void <Dispose>b__59_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__59_1();
    [CompilerGeneratedAttribute]
private void <Dispose>b__59_2();
}
public class Raven.Server.Documents.QueueSink.QueueSinkProcessStatistics : object {
    private string _processTag;
    private string _processName;
    private DatabaseNotificationCenter _notificationCenter;
    [CompilerGeneratedAttribute]
private int <ConsumeSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConsumeErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastConsumeErrorTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Queue`1<QueueSinkErrorInfo> <ConsumeErrorsInCurrentBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private Queue`1<QueueSinkErrorInfo> <ScriptExecutionErrorsInCurrentBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasLatestConsumeSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private AlertRaised <LastAlert>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScriptExecutionErrors>k__BackingField;
    public int ConsumeSuccesses { get; private set; }
    public int ConsumeErrors { get; public set; }
    public Nullable`1<DateTime> LastConsumeErrorTime { get; private set; }
    public Queue`1<QueueSinkErrorInfo> ConsumeErrorsInCurrentBatch { get; }
    public Queue`1<QueueSinkErrorInfo> ScriptExecutionErrorsInCurrentBatch { get; }
    public bool WasLatestConsumeSuccessful { get; public set; }
    public AlertRaised LastAlert { get; public set; }
    private int ScriptExecutionErrors { get; private set; }
    public QueueSinkProcessStatistics(string processTag, string processName, DatabaseNotificationCenter notificationCenter);
    [CompilerGeneratedAttribute]
public int get_ConsumeSuccesses();
    [CompilerGeneratedAttribute]
private void set_ConsumeSuccesses(int value);
    [CompilerGeneratedAttribute]
public int get_ConsumeErrors();
    [CompilerGeneratedAttribute]
public void set_ConsumeErrors(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastConsumeErrorTime();
    [CompilerGeneratedAttribute]
private void set_LastConsumeErrorTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Queue`1<QueueSinkErrorInfo> get_ConsumeErrorsInCurrentBatch();
    [CompilerGeneratedAttribute]
public Queue`1<QueueSinkErrorInfo> get_ScriptExecutionErrorsInCurrentBatch();
    [CompilerGeneratedAttribute]
public bool get_WasLatestConsumeSuccessful();
    [CompilerGeneratedAttribute]
public void set_WasLatestConsumeSuccessful(bool value);
    [CompilerGeneratedAttribute]
public AlertRaised get_LastAlert();
    [CompilerGeneratedAttribute]
public void set_LastAlert(AlertRaised value);
    [CompilerGeneratedAttribute]
private int get_ScriptExecutionErrors();
    [CompilerGeneratedAttribute]
private void set_ScriptExecutionErrors(int value);
    public void ConsumeSuccess(int items);
    public void RecordConsumeError(string error, int count);
    public void RecordScriptExecutionError(Exception e);
    private void CreateAlertIfAnyConsumeErrors(string preMessage);
    private void CreateAlertIfAnyScriptExecutionErrors(string preMessage);
    public IDisposable NewBatch();
    [CompilerGeneratedAttribute]
private void <NewBatch>b__39_0();
}
public class Raven.Server.Documents.QueueSink.RabbitMqQueueSink : QueueSinkProcess {
    public RabbitMqQueueSink(QueueSinkConfiguration configuration, QueueSinkScript script, DocumentDatabase database, string tag);
    protected virtual IQueueSinkConsumer CreateConsumer();
    private IModel CreateRabbitMqChannel();
}
public class Raven.Server.Documents.QueueSink.RabbitMqSinkConsumer : DefaultBasicConsumer {
    private IModel _channel;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BlockingCollection`1<ValueTuple`3<Byte[], IBasicProperties, ulong>> _deliveries;
    private ulong _latestDeliveryTag;
    public RabbitMqSinkConsumer(IModel channel);
    public virtual void HandleBasicDeliver(string consumerTag, ulong deliveryTag, bool redelivered, string exchange, string routingKey, IBasicProperties properties, ReadOnlyMemory`1<byte> body);
    public sealed virtual Byte[] Consume(CancellationToken cancellationToken);
    public sealed virtual Byte[] Consume(TimeSpan timeout);
    private void UpdateDeliveryTag(ulong deliveryTag);
    public sealed virtual void Commit();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.QueueSink.Stats.Performance.LiveQueueSinkPerformanceCollector : DatabaseAwareLivePerformanceCollector`1<QueueSinkTaskPerformanceStats> {
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, QueueSinkProcessAndPerformanceStatsList>> _perQueueSinkProcessStats;
    public LiveQueueSinkPerformanceCollector(DocumentDatabase database, Dictionary`2<string, List`1<QueueSinkProcess>> queueSinks);
    [AsyncStateMachineAttribute("Raven.Server.Documents.QueueSink.Stats.Performance.LiveQueueSinkPerformanceCollector/<StartCollectingStats>d__2")]
protected virtual Task StartCollectingStats();
    protected virtual List`1<QueueSinkTaskPerformanceStats> PreparePerformanceStats();
    protected virtual void WriteStats(List`1<QueueSinkTaskPerformanceStats> stats, AsyncBlittableJsonTextWriter writer, JsonOperationContext context);
    private void ProcessRemoved(QueueSinkProcess queueSink);
    private void ProcessAdded(QueueSinkProcess queueSink);
    private void BatchCompleted(ValueTuple`3<string, string, QueueSinkProcessStatistics> change);
}
public class Raven.Server.Documents.QueueSink.Stats.Performance.QueueSinkPerformanceOperation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueSinkPerformanceOperation[] <Operations>k__BackingField;
    public string Name { get; public set; }
    public double DurationInMs { get; }
    public QueueSinkPerformanceOperation[] Operations { get; public set; }
    public QueueSinkPerformanceOperation(TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public QueueSinkPerformanceOperation[] get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(QueueSinkPerformanceOperation[] value);
}
public class Raven.Server.Documents.QueueSink.Stats.Performance.QueueSinkPerformanceStats : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueSinkPerformanceOperation <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfReadMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfProcessedMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <CurrentlyAllocated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BatchPullStopReason>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScriptProcessingErrorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReadErrorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SuccessfullyProcessed>k__BackingField;
    public int Id { get; public set; }
    public DateTime Started { get; public set; }
    public Nullable`1<DateTime> Completed { get; public set; }
    public double DurationInMs { get; }
    public QueueSinkPerformanceOperation Details { get; public set; }
    public int NumberOfReadMessages { get; public set; }
    public int NumberOfProcessedMessages { get; public set; }
    public Size CurrentlyAllocated { get; public set; }
    public string BatchPullStopReason { get; public set; }
    public int ScriptProcessingErrorCount { get; public set; }
    public int ReadErrorCount { get; public set; }
    public Nullable`1<bool> SuccessfullyProcessed { get; public set; }
    public QueueSinkPerformanceStats(TimeSpan duration);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public QueueSinkPerformanceOperation get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(QueueSinkPerformanceOperation value);
    [CompilerGeneratedAttribute]
public int get_NumberOfReadMessages();
    [CompilerGeneratedAttribute]
public void set_NumberOfReadMessages(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfProcessedMessages();
    [CompilerGeneratedAttribute]
public void set_NumberOfProcessedMessages(int value);
    [CompilerGeneratedAttribute]
public Size get_CurrentlyAllocated();
    [CompilerGeneratedAttribute]
public void set_CurrentlyAllocated(Size value);
    [CompilerGeneratedAttribute]
public string get_BatchPullStopReason();
    [CompilerGeneratedAttribute]
public void set_BatchPullStopReason(string value);
    [CompilerGeneratedAttribute]
public int get_ScriptProcessingErrorCount();
    [CompilerGeneratedAttribute]
public void set_ScriptProcessingErrorCount(int value);
    [CompilerGeneratedAttribute]
public int get_ReadErrorCount();
    [CompilerGeneratedAttribute]
public void set_ReadErrorCount(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SuccessfullyProcessed();
    [CompilerGeneratedAttribute]
public void set_SuccessfullyProcessed(Nullable`1<bool> value);
}
public class Raven.Server.Documents.QueueSink.Stats.Performance.QueueSinkProcessPerformanceStats : object {
    [CompilerGeneratedAttribute]
private string <ScriptName>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueSinkPerformanceStats[] <Performance>k__BackingField;
    public string ScriptName { get; public set; }
    public QueueSinkPerformanceStats[] Performance { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ScriptName();
    [CompilerGeneratedAttribute]
public void set_ScriptName(string value);
    [CompilerGeneratedAttribute]
public QueueSinkPerformanceStats[] get_Performance();
    [CompilerGeneratedAttribute]
public void set_Performance(QueueSinkPerformanceStats[] value);
}
public class Raven.Server.Documents.QueueSink.Stats.Performance.QueueSinkTaskPerformanceStats : object {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueBrokerType <BrokerType>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueSinkProcessPerformanceStats[] <Stats>k__BackingField;
    public long TaskId { get; public set; }
    public string TaskName { get; public set; }
    public QueueBrokerType BrokerType { get; public set; }
    public QueueSinkProcessPerformanceStats[] Stats { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
public void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public QueueBrokerType get_BrokerType();
    [CompilerGeneratedAttribute]
public void set_BrokerType(QueueBrokerType value);
    [CompilerGeneratedAttribute]
public QueueSinkProcessPerformanceStats[] get_Stats();
    [CompilerGeneratedAttribute]
public void set_Stats(QueueSinkProcessPerformanceStats[] value);
}
public class Raven.Server.Documents.QueueSink.Stats.QueueSinkBatchPhases : object {
    public static string QueueReading;
    public static string ScriptProcessing;
}
public class Raven.Server.Documents.QueueSink.Stats.QueueSinkRunStats : object {
    public Size CurrentlyAllocated;
    public int NumberOfReadMessages;
    public int NumberOfProcessedMessages;
    public int ReadErrorCount;
    public int ScriptProcessingErrorCount;
    public string BatchPullStopReason;
}
public class Raven.Server.Documents.QueueSink.Stats.QueueSinkStatsAggregator : StatsAggregator`2<QueueSinkRunStats, QueueSinkStatsScope> {
    private IStatsAggregator _lastStats;
    private QueueSinkPerformanceStats modreq(System.Runtime.CompilerServices.IsVolatile) _performanceStats;
    public QueueSinkStatsAggregator(int id, IStatsAggregator lastStats);
    public void Start();
    public virtual QueueSinkStatsScope CreateScope();
    public QueueSinkPerformanceStats ToPerformanceStats();
    public QueueSinkPerformanceStats ToPerformanceLiveStatsWithDetails();
    private QueueSinkPerformanceStats CreatePerformanceStats(bool completed);
}
public class Raven.Server.Documents.QueueSink.Stats.QueueSinkStatsScope : StatsScope`2<QueueSinkRunStats, QueueSinkStatsScope> {
    private QueueSinkRunStats _stats;
    public QueueSinkStatsScope(QueueSinkRunStats stats, bool start);
    protected virtual QueueSinkStatsScope OpenNewScope(QueueSinkRunStats stats, bool start);
    public QueueSinkPerformanceOperation ToQueueSinkPerformanceOperation(string name);
    public void RecordReadMessage();
    public void RecordProcessedMessage();
    public void RecordReadError();
    public void RecordScriptProcessingError();
    public void RecordPullCompleteReason(string reason);
    public void RecordCurrentlyAllocated(long allocatedInBytes);
}
public class Raven.Server.Documents.QueueSink.Test.TestQueueMessageCommand : PatchDocumentCommand {
    private BlittableJsonReaderObject _message;
    public TestQueueMessageCommand(JsonOperationContext context, PatchRequest patch, BlittableJsonReaderObject message);
    protected virtual Document GetCurrentDocument(DocumentsOperationContext context, string id);
}
public class Raven.Server.Documents.QueueSink.Test.TestQueueSinkScript : object {
    public QueueSinkConfiguration Configuration;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
public class Raven.Server.Documents.QueueSink.Test.TestQueueSinkScriptResult : object {
    [CompilerGeneratedAttribute]
private List`1<string> <DebugOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicJsonValue <Actions>k__BackingField;
    public List`1<string> DebugOutput { get; public set; }
    public DynamicJsonValue Actions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_DebugOutput();
    [CompilerGeneratedAttribute]
public void set_DebugOutput(List`1<string> value);
    [CompilerGeneratedAttribute]
public DynamicJsonValue get_Actions();
    [CompilerGeneratedAttribute]
public void set_Actions(DynamicJsonValue value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.RaftIndexWaiter : object {
    private long _lastCompletedIndex;
    private AsyncManualResetEvent _notifiedListeners;
    public long LastIndex { get; }
    public RaftIndexWaiter(CancellationToken token);
    public long get_LastIndex();
    public void SetAndNotifyListenersIfHigher(long newIndex);
    public void NotifyListenersAboutError(Exception e);
    [AsyncStateMachineAttribute("Raven.Server.Documents.RaftIndexWaiter/<WaitAsync>d__7")]
public Task WaitAsync(long index, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.RaftIndexWaiter/<WaitAsync>d__8")]
public Task WaitAsync(long index, TimeSpan timeout);
    private void ThrowCanceledException(long index);
    private void ThrowTimeoutException(TimeSpan value, long index, long lastIndex);
    public sealed virtual void Dispose();
}
internal class Raven.Server.Documents.RecordingCommandDetails`2 : RecordingDetails {
    public IReplayableCommandDto`3<TOperationContext, TTransaction, MergedTransactionCommand`2<TOperationContext, TTransaction>> Command;
    public RecordingCommandDetails`2(string type);
}
internal class Raven.Server.Documents.RecordingDetails : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <DateTime>k__BackingField;
    public string Type { get; }
    public DateTime DateTime { get; }
    public RecordingDetails(string type);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public DateTime get_DateTime();
}
public class Raven.Server.Documents.Refresh.RefreshStorage : AbstractBackgroundWorkStorage {
    private static string DocumentsByRefresh;
    public RefreshStorage(DocumentDatabase database, Transaction tx);
    protected virtual void ProcessDocument(DocumentsOperationContext context, Slice lowerId, string id, DateTime currentTime);
    protected virtual void HandleDocumentConflict(BackgroundWorkParameters options, Slice ticksAsSlice, Slice clonedId, Queue`1<DocumentExpirationInfo> expiredDocs, Int32& totalCount);
    private ValueTuple`2<bool, string> GetConflictedExpiration(DocumentsOperationContext context, DateTime currentTime, Slice clonedId);
}
internal class Raven.Server.Documents.ReplayProgress : object {
    public long CommandsProgress;
}
public class Raven.Server.Documents.ReplayTransactionsException : Exception {
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    public string Context { get; }
    public string Message { get; }
    public ReplayTransactionsException(string message, PeepingTomStream peepingTomStream);
    [CompilerGeneratedAttribute]
public string get_Context();
    public virtual string get_Message();
}
internal static class Raven.Server.Documents.ReplayTxCommandHelper : object {
    [AsyncIteratorStateMachineAttribute("Raven.Server.Documents.ReplayTxCommandHelper/<ReplayAsync>d__0")]
internal static IAsyncEnumerable`1<ReplayProgress> ReplayAsync(DocumentDatabase database, Stream replayStream);
    [AsyncStateMachineAttribute("Raven.Server.Documents.ReplayTxCommandHelper/<ReadStartRecordingDetailsAsync>d__2")]
private static Task ReadStartRecordingDetailsAsync(IAsyncEnumerator`1<BlittableJsonReaderObject> iterator, DocumentsOperationContext context, PeepingTomStream peepingTomStream);
    private static MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> DeserializeCommand(DocumentsOperationContext context, DocumentDatabase database, string type, BlittableJsonReaderObject wrapCmdReader, PeepingTomStream peepingTomStream);
    private static IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> DeserializeCommandDto(string type, JsonSerializer jsonSerializer, BlittableJsonReader reader, PeepingTomStream peepingTomStream);
    internal static JsonSerializer GetJsonSerializer();
}
public abstract class Raven.Server.Documents.Replication.AbstractReplicationLoader`2 : object {
    private ReaderWriterLockSlim _locker;
    private int _replicationStatsId;
    private string _databaseName;
    public TContextPool ContextPool;
    public CancellationToken Token;
    internal ServerStore _server;
    protected Logger _logger;
    protected ConcurrentDictionary`2<string, IAbstractIncomingReplicationHandler> _incoming;
    internal TestingStuff<TContextPool, TOperationContext> ForTestingPurposes;
    public IEnumerable`1<IncomingConnectionInfo> IncomingConnections { get; }
    public IEnumerable`1<IAbstractIncomingReplicationHandler> IncomingHandlers { get; }
    public string DatabaseName { get; }
    public ServerStore Server { get; }
    protected AbstractReplicationLoader`2(ServerStore serverStore, string databaseName, TContextPool contextPool, CancellationToken token);
    public IEnumerable`1<IncomingConnectionInfo> get_IncomingConnections();
    public IEnumerable`1<IAbstractIncomingReplicationHandler> get_IncomingHandlers();
    public string get_DatabaseName();
    public ServerStore get_Server();
    internal TestingStuff<TContextPool, TOperationContext> ForTestingPurposesOnly();
    public int GetNextReplicationStatsId();
    protected bool ValidateConnectionString(Dictionary`2<string, RavenConnectionString> ravenConnectionStrings, ExternalReplicationBase externalReplication, RavenConnectionString& connectionString);
    protected SupportedFeatures GetSupportedVersions(TcpConnectionOptions tcpConnectionOptions);
    protected ReplicationInitialRequest GetReplicationInitialRequest(TcpConnectionOptions tcpConnectionOptions, SupportedFeatures supportedVersions, MemoryBuffer buffer);
    protected ReplicationLatestEtagRequest IncomingInitialHandshake(TcpConnectionOptions tcpConnectionOptions, MemoryBuffer buffer, PullReplicationParams replParams);
    protected ReplicationLatestEtagRequest GetLatestEtagMessage(TcpConnectionOptions tcpConnectionOptions, MemoryBuffer buffer);
    public X509Certificate2 GetCertificateForReplication(ReplicationNode node, AuthorizationInfo& authorizationInfo);
    public void EnsureNotDeleted(string node);
    protected virtual void AssertValidConnection(IncomingConnectionInfo connectionInfo);
    protected virtual DynamicJsonValue GetInitialRequestMessage(ReplicationLatestEtagRequest replicationLatestEtagRequest, PullReplicationParams replParams);
    public ClusterTopology GetClusterTopology();
    protected DatabaseTopology GetTopologyForShard(int shard);
    protected abstract virtual CancellationToken GetCancellationToken();
    public virtual void Dispose();
}
public class Raven.Server.Documents.Replication.AllowedPathsValidator : object {
    private JsonOperationContext _allowedPathsContext;
    private List`1<LazyStringValue> _allowedPaths;
    private List`1<LazyStringValue> _allowedPathsPrefixes;
    private DocumentInfoHelper _documentInfoHelper;
    public AllowedPathsValidator(String[] allowedPaths);
    private LazyStringValue GetDocumentId(Slice key);
    public string GetItemInformation(ReplicationBatchItem item);
    public bool ShouldAllow(ReplicationBatchItem item);
    private bool AllowId(LazyStringValue id);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Replication.BucketMigrationReplication : ReplicationNode {
    public ShardBucketMigration ShardBucketMigration;
    public int Bucket;
    public int Shard;
    public string Node;
    public long MigrationIndex;
    public BucketMigrationReplication(ShardBucketMigration shardBucketMigration, string destResponsibleNode);
    public virtual ReplicationType GetReplicationType();
    public bool ForBucketMigration(ShardBucketMigration migration);
    public virtual int GetHashCode();
    public virtual string FromString();
    public virtual bool IsEqualTo(ReplicationNode other);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.Replication.ChangeVectorEntry : ValueType {
    public string DbId;
    public long Etag;
    public int NodeTag;
    public void Append(StringBuilder sb);
    public virtual string ToString();
    public sealed virtual bool Equals(ChangeVectorEntry other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(ChangeVectorEntry other);
    public static ChangeVectorEntry op_Implicit(ValueTuple`3<string, long, int> entry);
}
[ExtensionAttribute]
public static class Raven.Server.Documents.Replication.ChangeVectorExtensions : object {
    [ExtensionAttribute]
public static string AsChangeVectorDbId(Guid DbId);
    [ExtensionAttribute]
public static string SerializeVector(ChangeVectorEntry[] self);
    [ExtensionAttribute]
public static string SerializeVector(List`1<ChangeVectorEntry> self);
    public static void ToBase26(StringBuilder sb, int tag);
    public static int FromBase26(string tag);
}
[ExtensionAttribute]
public static class Raven.Server.Documents.Replication.ChangeVectorParser : object {
    public static string RaftTag;
    public static string TrxnTag;
    public static string SinkTag;
    public static string MoveTag;
    public static int RaftInt;
    public static int TrxnInt;
    public static int SinkInt;
    public static int MoveInt;
    public static int DbBase64IdSize;
    private static ChangeVectorParser();
    [ExtensionAttribute]
public static int ParseNodeTag(string nodeTag);
    public static int ParseNodeTag(string changeVector, int start, int end);
    private static void AssertValidNodeTagChar(char ch);
    [DoesNotReturnAttribute]
private static void ThrowInvalidNodeTag(char ch);
    private static long ParseEtag(string changeVector, int start, int end);
    [ExtensionAttribute]
public static List`1<ChangeVectorEntry> ToChangeVectorList(string changeVector);
    [ExtensionAttribute]
public static ChangeVectorEntry[] ToChangeVector(string changeVector);
    public static void MergeChangeVector(string changeVector, List`1<ChangeVectorEntry> entries);
    public static bool MergeChangeVectorDown(string changeVector, List`1<ChangeVectorEntry> entries);
    [ConditionalAttribute("DEBUG")]
public static void AssertChangeVector(string changeVector);
    [DoesNotReturnAttribute]
private static void ThrowInvalidEndOfString(string state, string cv);
    [DoesNotReturnAttribute]
private static void ThrowInvalidState(State state, string cv);
}
public class Raven.Server.Documents.Replication.ConflictManager : object {
    private DocumentDatabase _database;
    private Logger _log;
    private ResolveConflictOnReplicationConfigurationChange _conflictResolver;
    public ConflictManager(DocumentDatabase database, ResolveConflictOnReplicationConfigurationChange conflictResolver);
    public void HandleConflictForDocument(DocumentsOperationContext documentsContext, string id, string collection, long lastModifiedTicks, BlittableJsonReaderObject doc, ChangeVector changeVector, DocumentFlags flags);
    private bool IsSameCollection(DocumentsOperationContext documentsContext, string id, string collection);
    public static void AssertChangeVectorNotNull(string conflictedChangeVector);
    private bool TryResolveConflictByScript(DocumentsOperationContext documentsContext, DocumentConflict conflict);
    private void HandleHiloConflict(DocumentsOperationContext context, string id, BlittableJsonReaderObject doc, ChangeVector changeVector);
    private static void InvalidConflictWhenThereIsNone(string id);
    public bool TryResolveIdenticalDocument(DocumentsOperationContext context, string id, BlittableJsonReaderObject incomingDoc, long lastModifiedTicks, ChangeVector incomingChangeVector);
    public static ChangeVector MergeConflicts(DocumentsOperationContext context, IEnumerable`1<DocumentConflict> conflicts);
    public static int Compare(DocumentConflict x, DocumentConflict y, IChangeVectorOperationContext context);
}
public class Raven.Server.Documents.Replication.ConnectionShutdownInfo : object {
    private TimeSpan _initialTimeout;
    private int _retriesCount;
    public string DestinationDbId;
    public long LastHeartbeatTicks;
    public double MaxConnectionTimeout;
    public Queue`1<Exception> Errors;
    [CompilerGeneratedAttribute]
private TimeSpan <NextTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <RetryOn>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetriesCount>k__BackingField;
    public TimeSpan NextTimeout { get; public set; }
    public DateTime RetryOn { get; public set; }
    public ReplicationNode Node { get; public set; }
    public int RetriesCount { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_NextTimeout();
    [CompilerGeneratedAttribute]
public void set_NextTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTime get_RetryOn();
    [CompilerGeneratedAttribute]
public void set_RetryOn(DateTime value);
    [CompilerGeneratedAttribute]
public ReplicationNode get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(ReplicationNode value);
    [CompilerGeneratedAttribute]
public int get_RetriesCount();
    [CompilerGeneratedAttribute]
public void set_RetriesCount(int value);
    public void Reset();
    public void OnError(Exception e);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.Replication.DocumentInfoHelper : object {
    private LazyStringValue _tmpLazyStringInstance;
    private JsonOperationContext _context;
    private bool _contextOwner;
    public DocumentInfoHelper(JsonOperationContext context);
    public LazyStringValue GetDocumentId(Slice key);
    public LazyStringValue GetDocumentId(LazyStringValue key);
    public LazyStringValue GetDocumentId(ReplicationBatchItem item);
    public string GetItemInformation(ReplicationBatchItem item);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Replication.ExternalReplicationState : object {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastSentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationChangeVector>k__BackingField;
    public long TaskId { get; public set; }
    public string NodeTag { get; public set; }
    public long LastSentEtag { get; public set; }
    public string SourceChangeVector { get; public set; }
    public string DestinationChangeVector { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public long get_LastSentEtag();
    [CompilerGeneratedAttribute]
public void set_LastSentEtag(long value);
    [CompilerGeneratedAttribute]
public string get_SourceChangeVector();
    [CompilerGeneratedAttribute]
public void set_SourceChangeVector(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationChangeVector();
    [CompilerGeneratedAttribute]
public void set_DestinationChangeVector(string value);
    public static string GenerateItemName(string databaseName, long taskId);
    public DynamicJsonValue ToJson();
}
public abstract class Raven.Server.Documents.Replication.Incoming.AbstractIncomingReplicationHandler`2 : object {
    private LongRunningWork _incomingWork;
    private DisposeOnce`1<SingleAttempt> _disposeOnce;
    private ServerStore _server;
    private IDisposable _connectionOptionsDisposable;
    private TContextPool _contextPool;
    private string _databaseName;
    private ConcurrentQueue`1<IncomingReplicationStatsAggregator> _lastReplicationStats;
    private IncomingReplicationStatsAggregator _lastStats;
    private TcpClient _tcpClient;
    protected Stream _stream;
    private AbstractReplicationLoader`2<TContextPool, TOperationContext> _parent;
    protected TcpConnectionOptions _tcpConnectionOptions;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ValueTuple`2<IDisposable, MemoryBuffer> _copiedBuffer;
    protected CancellationTokenSource _cts;
    protected StreamsTempFile _attachmentStreamsTempFile;
    protected long _lastDocumentEtag;
    protected AsyncManualResetEvent _replicationFromAnotherSource;
    protected Logger Logger;
    protected Action`1<DataForReplicationCommand<TContextPool, TOperationContext>> AfterItemsReadFromStream;
    [CompilerGeneratedAttribute]
private Action`1<ReplicationPulse> HandleReplicationPulse;
    [CompilerGeneratedAttribute]
private IncomingConnectionInfo <ConnectionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private SupportedFeatures <SupportedFeatures>k__BackingField;
    public long LastDocumentEtag { get; }
    public IncomingConnectionInfo ConnectionInfo { get; protected set; }
    public SupportedFeatures SupportedFeatures { get; public set; }
    public string SourceFormatted { get; }
    protected string IncomingReplicationThreadName { get; }
    public string FromToString { get; }
    public bool IsDisposed { get; }
    protected AbstractIncomingReplicationHandler`2(AbstractReplicationLoader`2<TContextPool, TOperationContext> parent, TcpConnectionOptions tcpConnectionOptions, MemoryBuffer buffer, ReplicationLatestEtagRequest replicatedLastEtag);
    public sealed virtual long get_LastDocumentEtag();
    [CompilerGeneratedAttribute]
public void add_HandleReplicationPulse(Action`1<ReplicationPulse> value);
    [CompilerGeneratedAttribute]
public void remove_HandleReplicationPulse(Action`1<ReplicationPulse> value);
    [CompilerGeneratedAttribute]
public sealed virtual IncomingConnectionInfo get_ConnectionInfo();
    [CompilerGeneratedAttribute]
protected void set_ConnectionInfo(IncomingConnectionInfo value);
    [CompilerGeneratedAttribute]
public SupportedFeatures get_SupportedFeatures();
    [CompilerGeneratedAttribute]
public void set_SupportedFeatures(SupportedFeatures value);
    public sealed virtual string get_SourceFormatted();
    protected string get_IncomingReplicationThreadName();
    public virtual string get_FromToString();
    public virtual void ClearEvents();
    public void Start();
    public void DoIncomingReplication();
    protected void ReceiveReplicationBatches();
    internal void HandleSingleReplicationBatch(TOperationContext context, BlittableJsonReaderObject message, BlittableJsonTextWriter writer);
    protected void AddReplicationPerformance(IncomingReplicationStatsAggregator stats);
    public sealed virtual IncomingReplicationPerformanceStats[] GetReplicationPerformance();
    public sealed virtual IncomingReplicationStatsAggregator GetLatestReplicationPerformance();
    private void HandleReceivedDocumentsAndAttachmentsBatch(TOperationContext context, BlittableJsonReaderObject message, long lastDocumentEtag, IncomingReplicationStatsScope stats);
    protected void ReadItemsFromSource(int replicatedDocs, TOperationContext context, ByteStringContext allocator, DataForReplicationCommand<TContextPool, TOperationContext> data, Reader reader, IncomingReplicationStatsScope stats);
    protected void ReadAttachmentStreamsFromSource(int attachmentStreamCount, ByteStringContext allocator, DataForReplicationCommand<TContextPool, TOperationContext> dataForReplicationCommand, Reader reader, IncomingReplicationStatsScope stats);
    protected void ReceiveSingleDocumentsBatch(TOperationContext context, int replicatedItemsCount, int attachmentStreamCount, long lastEtag, IncomingReplicationStatsScope stats);
    protected virtual DynamicJsonValue GetHeartbeatStatusMessage(TOperationContext context, long lastDocumentEtag, string handledMessageType);
    internal void SendHeartbeatStatusToSource(TOperationContext context, BlittableJsonTextWriter writer, long lastDocumentEtag, string handledMessageType);
    protected void AddReplicationPulse(ReplicationPulseDirection direction, string exceptionMessage);
    protected abstract virtual void EnsureNotDeleted();
    protected abstract virtual void OnDocumentsReceived();
    protected abstract virtual void InvokeOnAttachmentStreamsReceived(int attachmentStreamCount);
    protected abstract virtual void InvokeOnFailed(Exception exception);
    protected abstract virtual Task HandleBatchAsync(TOperationContext context, DataForReplicationCommand<TContextPool, TOperationContext> batch, long lastEtag);
    protected abstract virtual RavenConfiguration GetConfiguration();
    protected abstract virtual ByteStringContext GetContextAllocator(TOperationContext context);
    protected abstract virtual int GetNextReplicationStatsId();
    protected abstract virtual void HandleHeartbeatMessage(TOperationContext jsonOperationContext, BlittableJsonReaderObject blittableJsonReaderObject);
    public abstract virtual ReplicationPerformanceType GetReplicationPerformanceType();
    public sealed virtual bool get_IsDisposed();
    public sealed virtual void Dispose();
    protected virtual void DisposeInternal();
    [CompilerGeneratedAttribute]
private void <Start>b__40_0(object x);
    [CompilerGeneratedAttribute]
private void <ReceiveReplicationBatches>g__HandleSocketException|42_0(SocketException e);
}
public interface Raven.Server.Documents.Replication.Incoming.IAbstractIncomingReplicationHandler {
    public bool IsDisposed { get; }
    public IncomingConnectionInfo ConnectionInfo { get; }
    public string SourceFormatted { get; }
    public long LastDocumentEtag { get; }
    public abstract virtual bool get_IsDisposed();
    public abstract virtual IncomingConnectionInfo get_ConnectionInfo();
    public abstract virtual string get_SourceFormatted();
    public abstract virtual long get_LastDocumentEtag();
    public abstract virtual IncomingReplicationPerformanceStats[] GetReplicationPerformance();
    public abstract virtual IncomingReplicationStatsAggregator GetLatestReplicationPerformance();
    public abstract virtual ReplicationPerformanceType GetReplicationPerformanceType();
}
public class Raven.Server.Documents.Replication.Incoming.IncomingMigrationReplicationHandler : IncomingReplicationHandler {
    private ReplicationLoader _parent;
    private long _currentMigrationIndex;
    private ShardedDocumentDatabase _shardedDatabase;
    public static string MigrationTag;
    public IncomingMigrationReplicationHandler(TcpConnectionOptions options, ReplicationLatestEtagRequest replicatedLastEtag, ShardReplicationLoader parent, MemoryBuffer bufferToCopy, ReplicationType replicationType, long migrationIndex);
    protected virtual DocumentMergedTransactionCommand GetMergeDocumentsCommand(DocumentsOperationContext context, DataForReplicationCommand<DocumentsContextPool, DocumentsOperationContext> data, long lastDocumentEtag);
    protected virtual void HandleHeartbeatMessage(DocumentsOperationContext documentsContext, BlittableJsonReaderObject message);
}
public class Raven.Server.Documents.Replication.Incoming.IncomingPullReplicationHandler : IncomingReplicationHandler {
    public PullReplicationParams _incomingPullReplicationParams;
    private bool _preventIncomingSinkDeletions;
    private AllowedPathsValidator _allowedPathsValidator;
    public string CertificateThumbprint;
    public string FromToString { get; }
    public IncomingPullReplicationHandler(TcpConnectionOptions options, ReplicationLatestEtagRequest replicatedLastEtag, ReplicationLoader parent, MemoryBuffer bufferToCopy, ReplicationType replicationType, PullReplicationParams pullReplicationParams);
    private void ValidateIncomingReplicationItemsPaths(DataForReplicationCommand<DocumentsContextPool, DocumentsOperationContext> dataForReplicationCommand);
    protected virtual void DisposeInternal();
    public virtual string get_FromToString();
    protected virtual DocumentMergedTransactionCommand GetMergeDocumentsCommand(DocumentsOperationContext context, DataForReplicationCommand<DocumentsContextPool, DocumentsOperationContext> data, long lastDocumentEtag);
    protected virtual DocumentMergedTransactionCommand GetUpdateChangeVectorCommand(string changeVector, long lastDocumentEtag, IncomingConnectionInfo connectionInfo, AsyncManualResetEvent trigger);
}
public class Raven.Server.Documents.Replication.Incoming.IncomingReplicationAllocator : object {
    private long _maxSizeForContextUseInBytes;
    private long _minSizeToAllocateNonContextUseInBytes;
    [CompilerGeneratedAttribute]
private long <TotalDocumentsSizeInBytes>k__BackingField;
    private List`1<Allocation> _nativeAllocationList;
    private Allocation _currentAllocation;
    private ByteStringContext _allocator;
    public long TotalDocumentsSizeInBytes { get; private set; }
    public IncomingReplicationAllocator(ByteStringContext allocator, Nullable`1<Size> maxSizeToSend);
    [CompilerGeneratedAttribute]
public long get_TotalDocumentsSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_TotalDocumentsSizeInBytes(long value);
    public Byte* AllocateMemory(int size);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Replication.Incoming.IncomingReplicationHandler : AbstractIncomingReplicationHandler`2<DocumentsContextPool, DocumentsOperationContext> {
    private DocumentDatabase _database;
    private ReplicationLoader _parent;
    public long LastHeartbeatTicks;
    public ReplicationType ReplicationType;
    [CompilerGeneratedAttribute]
private Action`2<IncomingReplicationHandler, Exception> Failed;
    [CompilerGeneratedAttribute]
private Action`1<IncomingReplicationHandler> DocumentsReceived;
    [CompilerGeneratedAttribute]
private Action`2<IncomingReplicationHandler, int> AttachmentStreamsReceived;
    [ThreadStaticAttribute]
public static bool IsIncomingInternalReplication;
    private Task _prevChangeVectorUpdate;
    public IncomingReplicationHandler(TcpConnectionOptions options, ReplicationLatestEtagRequest replicatedLastEtag, ReplicationLoader parent, MemoryBuffer bufferToCopy, ReplicationType replicationType);
    private static IncomingReplicationHandler();
    [CompilerGeneratedAttribute]
public void add_Failed(Action`2<IncomingReplicationHandler, Exception> value);
    [CompilerGeneratedAttribute]
public void remove_Failed(Action`2<IncomingReplicationHandler, Exception> value);
    [CompilerGeneratedAttribute]
public void add_DocumentsReceived(Action`1<IncomingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void remove_DocumentsReceived(Action`1<IncomingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void add_AttachmentStreamsReceived(Action`2<IncomingReplicationHandler, int> value);
    [CompilerGeneratedAttribute]
public void remove_AttachmentStreamsReceived(Action`2<IncomingReplicationHandler, int> value);
    protected virtual ByteStringContext GetContextAllocator(DocumentsOperationContext context);
    protected virtual RavenConfiguration GetConfiguration();
    public virtual void ClearEvents();
    public void OnReplicationFromAnotherSource();
    protected virtual void EnsureNotDeleted();
    protected virtual int GetNextReplicationStatsId();
    protected virtual DocumentMergedTransactionCommand GetUpdateChangeVectorCommand(string changeVector, long lastDocumentEtag, IncomingConnectionInfo connectionInfo, AsyncManualResetEvent trigger);
    protected virtual DocumentMergedTransactionCommand GetMergeDocumentsCommand(DocumentsOperationContext context, DataForReplicationCommand<DocumentsContextPool, DocumentsOperationContext> data, long lastDocumentEtag);
    protected virtual void HandleHeartbeatMessage(DocumentsOperationContext documentsContext, BlittableJsonReaderObject message);
    public virtual ReplicationPerformanceType GetReplicationPerformanceType();
    protected virtual Task HandleBatchAsync(DocumentsOperationContext context, DataForReplicationCommand<DocumentsContextPool, DocumentsOperationContext> batch, long lastEtag);
    protected virtual DynamicJsonValue GetHeartbeatStatusMessage(DocumentsOperationContext documentsContext, long lastDocumentEtag, string handledMessageType);
    protected virtual void InvokeOnAttachmentStreamsReceived(int attachmentStreamCount);
    protected virtual void InvokeOnFailed(Exception exception);
    protected virtual void OnDocumentsReceived();
}
internal class Raven.Server.Documents.Replication.Incoming.MergedDocumentReplicationCommandDto : object {
    public ReplicationBatchItem[] ReplicatedItemDtos;
    public long LastEtag;
    public SupportedFeatures SupportedFeatures;
    public string SourceDatabaseId;
    public KeyValuePair`2[] ReplicatedAttachmentStreams;
    public sealed virtual MergedDocumentReplicationCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
    private AttachmentReplicationItem CreateReplicationAttachmentStream(DocumentsOperationContext context, KeyValuePair`2<string, Stream> arg);
}
public class Raven.Server.Documents.Replication.IncomingReplicationFailureToConnectReporter : object {
    private ReplicationNode _node;
    private IncomingReplicationStatsAggregator _stats;
    public string DestinationFormatted { get; }
    public IncomingReplicationFailureToConnectReporter(ReplicationNode node, IncomingReplicationStatsAggregator stats);
    public sealed virtual string get_DestinationFormatted();
    public sealed virtual IncomingReplicationPerformanceStats[] GetReplicationPerformance();
}
public class Raven.Server.Documents.Replication.InterruptibleRead`2 : object {
    private bool _isDisposed;
    private Task`1<Result<TContextPool, TOperationContext>> _prevCall;
    private Dictionary`2<AsyncManualResetEvent, Task`1<Task>> _previousWait;
    private TContextPool _contextPool;
    private Stream _stream;
    public InterruptibleRead`2(TContextPool contextPool, Stream stream);
    public Result<TContextPool, TOperationContext> ParseToMemory(AsyncManualResetEvent interrupt, string debugTag, int timeout, MemoryBuffer buffer, CancellationToken token);
    private Result<TContextPool, TOperationContext> ReturnAndClearValue();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Replication.InterruptibleRead`2/<ReadNextObject>d__9")]
private Task`1<Result<TContextPool, TOperationContext>> ReadNextObject(string debugTag, MemoryBuffer buffer, CancellationToken token);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static void <Dispose>g__SafelyDispose|10_0(IDisposable toDispose);
}
public abstract class Raven.Server.Documents.Replication.Outgoing.AbstractOutgoingReplicationHandler`2 : object {
    private TContextPool _contextPool;
    private TcpConnectionInfo _connectionInfo;
    private ServerStore _server;
    private DateTime _startedAt;
    private string _databaseName;
    private AbstractDatabaseNotificationCenter _notificationCenter;
    private OutgoingReplicationStatsScope _statsInstance;
    private string _outgoingReplicationThreadName;
    internal ReplicationStats _stats;
    internal long _lastSentDocumentEtag;
    internal string DestinationDbId;
    protected CancellationTokenSource _cts;
    protected LongRunningWork _longRunningSendingWork;
    protected AsyncManualResetEvent _connectionDisposed;
    protected MemoryBuffer _buffer;
    protected Stream _stream;
    protected TcpClient _tcpClient;
    protected TcpConnectionOptions _tcpConnectionOptions;
    protected ConcurrentQueue`1<OutgoingReplicationStatsAggregator> _lastReplicationStats;
    protected InterruptibleRead`2<TContextPool, TOperationContext> _interruptibleRead;
    protected OutgoingReplicationStatsAggregator _lastStats;
    protected Logger Logger;
    [CompilerGeneratedAttribute]
private SupportedFeatures <SupportedFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationNode <Destination>k__BackingField;
    public string LastSentChangeVector;
    [CompilerGeneratedAttribute]
private string <LastAcceptedChangeVector>k__BackingField;
    public long LastHeartbeatTicks;
    public int MissingAttachmentsRetries;
    [CompilerGeneratedAttribute]
private Action`1<ReplicationPulse> HandleReplicationPulse;
    private SingleUseFlag _disposed;
    public ServerStore Server { get; }
    public long LastSentDocumentEtag { get; }
    public TcpConnectionInfo ConnectionInfo { get; }
    public SupportedFeatures SupportedFeatures { get; protected set; }
    internal CancellationToken CancellationToken { get; }
    public bool IsConnectionDisposed { get; }
    public ReplicationNode Destination { get; }
    public string LastAcceptedChangeVector { get; public set; }
    public ReplicationNode Node { get; }
    public string DestinationFormatted { get; }
    public string OutgoingReplicationThreadName { get; public set; }
    public string FromToString { get; }
    protected AbstractOutgoingReplicationHandler`2(TcpConnectionInfo connectionInfo, ServerStore server, string databaseName, AbstractDatabaseNotificationCenter notificationCenter, ReplicationNode node, TContextPool contextPool, CancellationToken token);
    public ServerStore get_Server();
    public sealed virtual long get_LastSentDocumentEtag();
    public TcpConnectionInfo get_ConnectionInfo();
    [CompilerGeneratedAttribute]
public SupportedFeatures get_SupportedFeatures();
    [CompilerGeneratedAttribute]
protected void set_SupportedFeatures(SupportedFeatures value);
    internal CancellationToken get_CancellationToken();
    public sealed virtual bool get_IsConnectionDisposed();
    [CompilerGeneratedAttribute]
public sealed virtual ReplicationNode get_Destination();
    [CompilerGeneratedAttribute]
public sealed virtual string get_LastAcceptedChangeVector();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastAcceptedChangeVector(string value);
    public sealed virtual ReplicationNode get_Node();
    public sealed virtual string get_DestinationFormatted();
    public void set_OutgoingReplicationThreadName(string value);
    public string get_OutgoingReplicationThreadName();
    [CompilerGeneratedAttribute]
public void add_HandleReplicationPulse(Action`1<ReplicationPulse> value);
    [CompilerGeneratedAttribute]
public void remove_HandleReplicationPulse(Action`1<ReplicationPulse> value);
    public virtual string get_FromToString();
    public sealed virtual void Start();
    private void Replication();
    private Task`1<SupportedFeatures> NegotiateReplicationVersion(TcpConnectionInfo info, Stream stream, AuthorizationInfo authorizationInfo);
    private NegotiationResponse ReadHeaderResponseAndThrowIfUnAuthorized(JsonOperationContext context, BlittableJsonTextWriter writer, Stream stream, string url);
    private void SendDropMessage(JsonOperationContext context, BlittableJsonTextWriter writer, TcpConnectionHeaderResponse headerResponse);
    protected virtual void ProcessHandshakeResponse(ValueTuple`2<ReplyType, ReplicationMessageReply> response);
    internal ValueTuple`2<ReplyType, ReplicationMessageReply> HandleServerResponse(bool getFullResponse);
    internal ReplicationMessageReply HandleServerResponse(BlittableJsonReaderObject replicationBatchReplyMessage, bool allowNotify);
    private void RaiseAlertAndThrowMissingAttachmentException(string msg, string exceptionDetails);
    protected virtual DynamicJsonValue GetInitialHandshakeRequest();
    private ReplicationType GetReplicationType();
    protected void InitialHandshake();
    internal void SendHeartbeat(string changeVector);
    public sealed virtual string GetNode();
    public sealed virtual OutgoingReplicationPerformanceStats[] GetReplicationPerformance();
    protected void EnsureValidStats(OutgoingReplicationStatsScope stats);
    internal void WriteToServer(DynamicJsonValue val);
    protected void AddReplicationPerformance(OutgoingReplicationStatsAggregator stats);
    protected void UpdateDestinationChangeVector(ReplicationMessageReply replicationBatchReply);
    protected virtual void UpdateDestinationChangeVectorHeartbeat(ReplicationMessageReply replicationBatchReply);
    [DoesNotReturnAttribute]
protected static void ThrowTimeout(int timeout);
    [DoesNotReturnAttribute]
protected static void ThrowConnectionClosed();
    protected virtual void HandleReplicationErrors(Action replicationAction);
    protected virtual DynamicJsonValue GetSendPreliminaryDataRequest();
    private void SendPreliminaryData();
    protected void AddReplicationPulse(ReplicationPulseDirection direction, string exceptionMessage);
    protected abstract virtual void AddAlertOnFailureToReachOtherSide(string msg, Exception e);
    protected abstract virtual void Replicate();
    protected abstract virtual void OnSuccessfulTwoWaysCommunication();
    protected abstract virtual void OnFailed(Exception e);
    protected abstract virtual long GetLastHeartbeatTicks();
    protected abstract virtual void InitiatePullReplicationAsSink(SupportedFeatures socketResultSupportedFeatures, X509Certificate2 certificate);
    protected abstract virtual void AssertDatabaseNotDisposed();
    protected abstract virtual X509Certificate2 GetCertificateForReplication(ReplicationNode destination, AuthorizationInfo& authorizationInfo);
    protected abstract virtual void OnBeforeDispose();
    public virtual void Dispose();
    private void DisposeTcpClient();
    [CompilerGeneratedAttribute]
private void <Start>b__59_0(object x);
    [CompilerGeneratedAttribute]
private void <HandleReplicationErrors>g__HandleOperationCancelException|81_0(OperationCanceledException e);
    [CompilerGeneratedAttribute]
private void <HandleReplicationErrors>g__HandleIOException|81_1(IOException e);
    [CompilerGeneratedAttribute]
private void <HandleReplicationErrors>g__HandleLegacyReplicationViolationException|81_2(LegacyReplicationViolationException e);
    [CompilerGeneratedAttribute]
private void <HandleReplicationErrors>g__HandleException|81_3(Exception e);
}
public abstract class Raven.Server.Documents.Replication.Outgoing.DatabaseOutgoingReplicationHandler : AbstractOutgoingReplicationHandler`2<DocumentsContextPool, DocumentsOperationContext> {
    public static string AlertTitle;
    internal DocumentDatabase _database;
    protected AsyncManualResetEvent _waitForChanges;
    internal ReplicationLoader _parent;
    internal DateTime _lastDocumentSentTime;
    [CompilerGeneratedAttribute]
private Action`2<DatabaseOutgoingReplicationHandler, Exception> Failed;
    [CompilerGeneratedAttribute]
private Action`1<DatabaseOutgoingReplicationHandler> SuccessfulTwoWaysCommunication;
    [CompilerGeneratedAttribute]
private Action`1<DatabaseOutgoingReplicationHandler> SuccessfulReplication;
    [CompilerGeneratedAttribute]
private Action`1<DatabaseOutgoingReplicationHandler> DocumentsSend;
    public long NextReplicateTicks;
    internal TestingStuff ForTestingPurposes;
    protected DatabaseOutgoingReplicationHandler(ReplicationLoader parent, DocumentDatabase database, ReplicationNode node, TcpConnectionInfo connectionInfo);
    [CompilerGeneratedAttribute]
public void add_Failed(Action`2<DatabaseOutgoingReplicationHandler, Exception> value);
    [CompilerGeneratedAttribute]
public void remove_Failed(Action`2<DatabaseOutgoingReplicationHandler, Exception> value);
    [CompilerGeneratedAttribute]
public void add_SuccessfulTwoWaysCommunication(Action`1<DatabaseOutgoingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void remove_SuccessfulTwoWaysCommunication(Action`1<DatabaseOutgoingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void add_SuccessfulReplication(Action`1<DatabaseOutgoingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void remove_SuccessfulReplication(Action`1<DatabaseOutgoingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void add_DocumentsSend(Action`1<DatabaseOutgoingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void remove_DocumentsSend(Action`1<DatabaseOutgoingReplicationHandler> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(DatabaseOutgoingReplicationHandler other);
    public ReplicationPerformanceType GetReplicationPerformanceType();
    public OutgoingReplicationStatsAggregator GetLatestReplicationPerformance();
    public void StartPullReplicationAsHub(Stream stream, SupportedFeatures supportedVersions);
    private void PullReplication();
    protected virtual void AssertDatabaseNotDisposed();
    protected virtual X509Certificate2 GetCertificateForReplication(ReplicationNode destination, AuthorizationInfo& authorizationInfo);
    protected virtual void InitiatePullReplicationAsSink(SupportedFeatures supportedFeatures, X509Certificate2 certificate);
    protected virtual void HandleReplicationErrors(Action replicationAction);
    public abstract virtual ReplicationDocumentSenderBase CreateDocumentSender(Stream stream, Logger logger);
    protected virtual void Replicate();
    protected virtual DynamicJsonValue GetInitialHandshakeRequest();
    protected virtual void AddAlertOnFailureToReachOtherSide(string msg, Exception e);
    private bool WaitForChanges(int timeout, CancellationToken token);
    protected virtual void UpdateDestinationChangeVectorHeartbeat(ReplicationMessageReply replicationBatchReply);
    protected virtual long GetLastHeartbeatTicks();
    private void OnDocumentChange(DocumentChange change);
    private void OnCounterChange(CounterChange change);
    private void OnTimeSeriesChange(TimeSeriesChange change);
    private void OnChangeInternal(bool triggeredByReplicationThread);
    protected virtual void OnBeforeDispose();
    public virtual void Dispose();
    protected virtual void OnSuccessfulTwoWaysCommunication();
    protected virtual void OnFailed(Exception e);
    private void OnSuccessfulReplication();
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
private void <StartPullReplicationAsHub>b__23_0(object x);
}
public interface Raven.Server.Documents.Replication.Outgoing.IAbstractOutgoingReplicationHandler {
    public ReplicationNode Node { get; }
    public long LastSentDocumentEtag { get; }
    public string LastAcceptedChangeVector { get; public set; }
    public ReplicationNode Destination { get; }
    public bool IsConnectionDisposed { get; }
    public abstract virtual ReplicationNode get_Node();
    public abstract virtual long get_LastSentDocumentEtag();
    public abstract virtual string get_LastAcceptedChangeVector();
    public abstract virtual void set_LastAcceptedChangeVector(string value);
    public abstract virtual ReplicationNode get_Destination();
    public abstract virtual bool get_IsConnectionDisposed();
    public abstract virtual string GetNode();
    public abstract virtual void Start();
}
public interface Raven.Server.Documents.Replication.Outgoing.IReportIncomingReplicationPerformance {
    public string DestinationFormatted { get; }
    public abstract virtual string get_DestinationFormatted();
    public abstract virtual IncomingReplicationPerformanceStats[] GetReplicationPerformance();
}
public interface Raven.Server.Documents.Replication.Outgoing.IReportOutgoingReplicationPerformance {
    public string DestinationFormatted { get; }
    public abstract virtual string get_DestinationFormatted();
    public abstract virtual OutgoingReplicationPerformanceStats[] GetReplicationPerformance();
}
public class Raven.Server.Documents.Replication.Outgoing.OutgoingExternalReplicationHandler : DatabaseOutgoingReplicationHandler {
    private Nullable`1<long> _taskId;
    public OutgoingExternalReplicationHandler(ReplicationLoader parent, DocumentDatabase database, ExternalReplication node, TcpConnectionInfo connectionInfo);
    protected virtual DynamicJsonValue GetInitialHandshakeRequest();
    public virtual ReplicationDocumentSenderBase CreateDocumentSender(Stream stream, Logger logger);
    private void UpdateExternalReplicationInfo();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(DatabaseOutgoingReplicationHandler _);
}
public class Raven.Server.Documents.Replication.Outgoing.OutgoingInternalReplicationHandler : DatabaseOutgoingReplicationHandler {
    private long _lastDestinationEtag;
    public OutgoingInternalReplicationHandler(ReplicationLoader parent, DocumentDatabase database, InternalReplication node, TcpConnectionInfo connectionInfo);
    public virtual ReplicationDocumentSenderBase CreateDocumentSender(Stream stream, Logger logger);
    protected virtual void UpdateDestinationChangeVectorHeartbeat(ReplicationMessageReply replicationBatchReply);
    public void UpdateSibling(ReplicationMessageReply replicationBatchReply);
}
public class Raven.Server.Documents.Replication.Outgoing.OutgoingMigrationReplicationHandler : DatabaseOutgoingReplicationHandler {
    private ShardedDocumentDatabase _shardedDatabase;
    public BucketMigrationReplication BucketMigrationNode;
    public long LastSentEtag;
    public OutgoingMigrationReplicationHandler(ShardReplicationLoader parent, ShardedDocumentDatabase database, BucketMigrationReplication node, TcpConnectionInfo connectionInfo);
    private void TryNotifySourceMigrationCompleted(DatabaseOutgoingReplicationHandler handler);
    public virtual ReplicationDocumentSenderBase CreateDocumentSender(Stream stream, Logger logger);
    protected virtual DynamicJsonValue GetInitialHandshakeRequest();
    public virtual int GetHashCode();
    public virtual void Dispose();
}
public abstract class Raven.Server.Documents.Replication.Outgoing.OutgoingPullReplicationHandler : DatabaseOutgoingReplicationHandler {
    public String[] PathsToSend;
    private String[] _destinationAcceptablePaths;
    public PullReplicationParams OutgoingPullReplicationParams;
    public string CertificateThumbprint;
    protected OutgoingPullReplicationHandler(ReplicationLoader parent, DocumentDatabase database, ReplicationNode node, TcpConnectionInfo connectionInfo);
    public virtual ReplicationDocumentSenderBase CreateDocumentSender(Stream stream, Logger logger);
    protected virtual void ProcessHandshakeResponse(ValueTuple`2<ReplyType, ReplicationMessageReply> response);
}
internal class Raven.Server.Documents.Replication.Outgoing.OutgoingPullReplicationHandlerAsHub : OutgoingPullReplicationHandler {
    public string PullReplicationDefinitionName;
    public string FromToString { get; }
    public OutgoingPullReplicationHandlerAsHub(ReplicationLoader parent, DocumentDatabase database, PullReplicationAsHub node, TcpConnectionInfo connectionInfo);
    public virtual string get_FromToString();
}
public class Raven.Server.Documents.Replication.Outgoing.OutgoingPullReplicationHandlerAsSink : OutgoingPullReplicationHandler {
    private PullReplicationAsSink _node;
    public OutgoingPullReplicationHandlerAsSink(ReplicationLoader parent, DocumentDatabase database, PullReplicationAsSink node, TcpConnectionInfo connectionInfo);
    protected virtual DynamicJsonValue GetSendPreliminaryDataRequest();
    protected virtual void ProcessHandshakeResponse(ValueTuple`2<ReplyType, ReplicationMessageReply> response);
}
public static class Raven.Server.Documents.Replication.Outgoing.ReplicationMessageType : object {
    public static string Heartbeat;
    public static string Documents;
}
public class Raven.Server.Documents.Replication.OutgoingReplicationFailureToConnectReporter : object {
    private ReplicationNode _node;
    private OutgoingReplicationStatsAggregator _stats;
    public string DestinationFormatted { get; }
    public OutgoingReplicationFailureToConnectReporter(ReplicationNode node, OutgoingReplicationStatsAggregator stats);
    public sealed virtual string get_DestinationFormatted();
    public sealed virtual OutgoingReplicationPerformanceStats[] GetReplicationPerformance();
}
internal class Raven.Server.Documents.Replication.PutResolvedConflictsCommandDto : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`3<DocumentConflict, long, bool>> ResolvedConflicts;
    public sealed virtual PutResolvedConflictsCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public static class Raven.Server.Documents.Replication.ReplicationHelper : object {
    public static ReplicationNode GetReplicationNodeByType(BlittableJsonReaderObject bjro);
}
public class Raven.Server.Documents.Replication.ReplicationItems.AttachmentReplicationItem : ReplicationBatchItem {
    public LazyStringValue Name;
    public LazyStringValue ContentType;
    public Slice Key;
    public Slice Base64Hash;
    public Stream Stream;
    public long Size { get; }
    public long StreamSize { get; }
    public virtual long get_Size();
    public long get_StreamSize();
    public virtual DynamicJsonValue ToDebugJson();
    public static AttachmentReplicationItem From(DocumentsOperationContext context, Attachment attachment);
    public virtual long AssertChangeVectorSize();
    public virtual void Write(Slice changeVector, Stream stream, Byte[] tempBuffer, OutgoingReplicationStatsScope stats);
    public virtual void Read(JsonOperationContext context, ByteStringContext allocator, IncomingReplicationStatsScope stats);
    protected virtual ReplicationBatchItem CloneInternal(JsonOperationContext context, ByteStringContext allocator);
    public void ReadStream(ByteStringContext allocator, StreamsTempFile attachmentStreamsTempFile, IncomingReplicationStatsScope stats);
    public void WriteStream(Stream stream, Byte[] tempBuffer, OutgoingReplicationStatsScope stats);
    protected virtual void InnerDispose();
}
public class Raven.Server.Documents.Replication.ReplicationItems.AttachmentTombstoneReplicationItem : ReplicationBatchItem {
    public Slice Key;
    public DocumentFlags Flags;
    public long Size { get; }
    public virtual long get_Size();
    public virtual DynamicJsonValue ToDebugJson();
    public virtual long AssertChangeVectorSize();
    public virtual void Write(Slice changeVector, Stream stream, Byte[] tempBuffer, OutgoingReplicationStatsScope stats);
    public virtual void Read(JsonOperationContext context, ByteStringContext allocator, IncomingReplicationStatsScope stats);
    protected virtual ReplicationBatchItem CloneInternal(JsonOperationContext context, ByteStringContext allocator);
    protected virtual void InnerDispose();
}
public class Raven.Server.Documents.Replication.ReplicationItems.CounterReplicationItem : ReplicationBatchItem {
    public LazyStringValue Collection;
    public LazyStringValue Id;
    public BlittableJsonReaderObject Values;
    public long Size { get; }
    public virtual long get_Size();
    public virtual DynamicJsonValue ToDebugJson();
    public virtual long AssertChangeVectorSize();
    public virtual void Write(Slice changeVector, Stream stream, Byte[] tempBuffer, OutgoingReplicationStatsScope stats);
    public virtual void Read(JsonOperationContext context, ByteStringContext allocator, IncomingReplicationStatsScope stats);
    protected virtual ReplicationBatchItem CloneInternal(JsonOperationContext context, ByteStringContext allocator);
    protected virtual void InnerDispose();
}
public class Raven.Server.Documents.Replication.ReplicationItems.DocumentReplicationItem : ReplicationBatchItem {
    public BlittableJsonReaderObject Data;
    public LazyStringValue Collection;
    public LazyStringValue Id;
    public DocumentFlags Flags;
    public long Size { get; }
    public virtual long get_Size();
    public virtual DynamicJsonValue ToDebugJson();
    public static DocumentReplicationItem From(Document doc, DocumentsOperationContext context);
    public static DocumentReplicationItem From(DocumentConflict doc);
    public virtual long AssertChangeVectorSize();
    private long GetReplicationBatchItemSize(bool includeDetails);
    public virtual void Write(Slice changeVector, Stream stream, Byte[] tempBuffer, OutgoingReplicationStatsScope stats);
    public virtual void Read(JsonOperationContext context, ByteStringContext allocator, IncomingReplicationStatsScope stats);
    protected virtual ReplicationBatchItem CloneInternal(JsonOperationContext context, ByteStringContext allocator);
    protected virtual void InnerDispose();
    public virtual string ToString();
}
public class Raven.Server.Documents.Replication.ReplicationItems.Reader : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<IDisposable, MemoryBuffer> _copiedBuffer;
    private Stream _stream;
    private IncomingReplicationAllocator _allocator;
    public Reader(Stream stream, ValueTuple`2<IDisposable, MemoryBuffer> copiedBuffer, IncomingReplicationAllocator allocator);
    internal Byte* ReadExactly(int size);
    private Byte* ReadExactlyUnlikely(int size, int diff);
    internal void ReadExactly(Byte* ptr, int size);
    internal void ReadExactly(long size, Stream file);
    internal Byte* AllocateMemory(int size);
}
public abstract class Raven.Server.Documents.Replication.ReplicationItems.ReplicationBatchItem : object {
    private bool _isDisposed;
    public long Etag;
    public short TransactionMarker;
    public ReplicationItemType Type;
    public string ChangeVector;
    public long LastModifiedTicks;
    protected Reader Reader;
    private List`1<IDisposable> _garbage;
    public long Size { get; }
    public virtual string ToString();
    public virtual long get_Size();
    public abstract virtual long AssertChangeVectorSize();
    public abstract virtual void Write(Slice changeVector, Stream stream, Byte[] tempBuffer, OutgoingReplicationStatsScope stats);
    public abstract virtual void Read(JsonOperationContext context, ByteStringContext allocator, IncomingReplicationStatsScope stats);
    protected abstract virtual ReplicationBatchItem CloneInternal(JsonOperationContext context, ByteStringContext allocator);
    public ReplicationBatchItem Clone(JsonOperationContext context, ByteStringContext allocator);
    public static ReplicationBatchItem ReadTypeAndInstantiate(Reader reader);
    public void ReadChangeVectorAndMarker();
    public virtual DynamicJsonValue ToDebugJson();
    protected int WriteCommon(Slice changeVector, Byte* tempBuffer);
    protected void SetLazyStringValue(JsonOperationContext context, LazyStringValue& prop);
    protected void SetLazyStringValueFromString(JsonOperationContext context, LazyStringValue& prop);
    public void ToDispose(IDisposable obj);
    protected abstract virtual void InnerDispose();
    public sealed virtual void Dispose();
    [DoesNotReturnAttribute]
public static void ThrowTooManyChangeVectorEntries(ReplicationBatchItem item, string id);
}
public class Raven.Server.Documents.Replication.ReplicationItems.RevisionTombstoneReplicationItem : ReplicationBatchItem {
    public LazyStringValue Collection;
    public LazyStringValue Id;
    public DocumentFlags Flags;
    public long Size { get; }
    public virtual long get_Size();
    public virtual DynamicJsonValue ToDebugJson();
    public virtual long AssertChangeVectorSize();
    public virtual void Write(Slice changeVector, Stream stream, Byte[] tempBuffer, OutgoingReplicationStatsScope stats);
    public virtual void Read(JsonOperationContext context, ByteStringContext allocator, IncomingReplicationStatsScope stats);
    protected virtual ReplicationBatchItem CloneInternal(JsonOperationContext context, ByteStringContext allocator);
    public void StripDocumentIdFromKeyIfNeeded(JsonOperationContext context);
    public static InternalScope<ByteStringMemoryCache> TryExtractChangeVectorSliceFromKey(ByteStringContext allocator, LazyStringValue key, Slice& changeVectorSlice);
    public static void TryExtractDocumentIdAndChangeVectorFromKey(LazyStringValue key, String& docId, String& changeVector);
    protected virtual void InnerDispose();
}
public class Raven.Server.Documents.Replication.ReplicationItems.TimeSeriesDeletedRangeItem : ReplicationBatchItem {
    public Slice Key;
    public LazyStringValue Collection;
    public DateTime From;
    public DateTime To;
    public long Size { get; }
    public virtual long get_Size();
    public virtual DynamicJsonValue ToDebugJson();
    public virtual long AssertChangeVectorSize();
    public virtual void Write(Slice changeVector, Stream stream, Byte[] tempBuffer, OutgoingReplicationStatsScope stats);
    public virtual void Read(JsonOperationContext context, ByteStringContext allocator, IncomingReplicationStatsScope stats);
    protected virtual ReplicationBatchItem CloneInternal(JsonOperationContext context, ByteStringContext allocator);
    protected virtual void InnerDispose();
}
public class Raven.Server.Documents.Replication.ReplicationItems.TimeSeriesReplicationItem : ReplicationBatchItem {
    public Slice Key;
    public LazyStringValue Name;
    public LazyStringValue Collection;
    public TimeSeriesValuesSegment Segment;
    public long Size { get; }
    public virtual long get_Size();
    public virtual DynamicJsonValue ToDebugJson();
    public virtual long AssertChangeVectorSize();
    public virtual void Write(Slice changeVector, Stream stream, Byte[] tempBuffer, OutgoingReplicationStatsScope stats);
    public virtual void Read(JsonOperationContext context, ByteStringContext allocator, IncomingReplicationStatsScope stats);
    protected virtual ReplicationBatchItem CloneInternal(JsonOperationContext context, ByteStringContext allocator);
    protected virtual void InnerDispose();
}
public class Raven.Server.Documents.Replication.ReplicationItems.TombstoneReplicationItem : object {
    public static ReplicationBatchItem From(DocumentsOperationContext context, Tombstone doc);
}
public class Raven.Server.Documents.Replication.ReplicationLoader : AbstractReplicationLoader`2<DocumentsContextPool, DocumentsOperationContext> {
    private Timer _reconnectAttemptTimer;
    private long _reconnectInProgress;
    private ReaderWriterLockSlim _locker;
    [CompilerGeneratedAttribute]
private Action`1<IncomingReplicationHandler> IncomingReplicationAdded;
    [CompilerGeneratedAttribute]
private Action`1<IncomingReplicationHandler> IncomingReplicationRemoved;
    [CompilerGeneratedAttribute]
private Action`1<DatabaseOutgoingReplicationHandler> OutgoingReplicationAdded;
    [CompilerGeneratedAttribute]
private Action`1<DatabaseOutgoingReplicationHandler> OutgoingReplicationRemoved;
    internal ManualResetEventSlim DebugWaitAndRunReplicationOnce;
    internal int MinimalHeartbeatInterval;
    public DocumentDatabase Database;
    private SingleUseFlag _isInitialized;
    public ResolveConflictOnReplicationConfigurationChange ConflictResolver;
    private ConcurrentSet`1<DatabaseOutgoingReplicationHandler> _outgoing;
    private ConcurrentDictionary`2<ReplicationNode, ConnectionShutdownInfo> _outgoingFailureInfo;
    private ConcurrentSet`1<ConnectionShutdownInfo> _reconnectQueue;
    private ConcurrentDictionary`2<IncomingConnectionInfo, DateTime> _incomingLastActivityTime;
    internal ConcurrentDictionary`2<IncomingConnectionInfo, ConcurrentQueue`1<IncomingConnectionRejectionInfo>> _incomingRejectionStats;
    private ConcurrentBag`1<ReplicationNode> _internalDestinations;
    private HashSet`1<ExternalReplicationBase> _externalDestinations;
    private List`1<ReplicationNode> _destinations;
    protected ClusterTopology _clusterTopology;
    private int _numberOfSiblings;
    public ConflictSolver ConflictSolverConfig;
    private CancellationToken _shutdownToken;
    private HubInfoForCleaner _hubInfoForCleaner;
    private ConcurrentQueue`1<TaskCompletionSource`1<object>> _waitForReplicationTasks;
    private ConcurrentDictionary`2<ReplicationNode, LastEtagPerDestination> _lastSendEtagPerDestination;
    [CompilerGeneratedAttribute]
private Action`2<IncomingReplicationHandler, int> AttachmentStreamsReceived;
    internal static TimeSpan MaxInactiveTime;
    public ConcurrentDictionary`2<ReplicationNode, OutgoingReplicationFailureToConnectReporter> OutgoingConnectionsLastFailureToConnect;
    public ConcurrentDictionary`2<ReplicationNode, IncomingReplicationFailureToConnectReporter> IncomingConnectionsLastFailureToConnect;
    private static string ExternalReplicationTag;
    [CompilerGeneratedAttribute]
private Action`1<ReplicationPulse> OutgoingReplicationConnectionFailed;
    [CompilerGeneratedAttribute]
private Action`2<ReplicationNode, OutgoingReplicationFailureToConnectReporter> OutgoingReplicationConnectionErrored;
    [CompilerGeneratedAttribute]
private Action`2<ReplicationNode, IncomingReplicationFailureToConnectReporter> IncomingReplicationConnectionErrored;
    public IEnumerable`1<ReplicationNode> OutgoingConnections { get; }
    public IEnumerable`1<DatabaseOutgoingReplicationHandler> OutgoingHandlers { get; }
    public IEnumerable`1<ReplicationNode> ReconnectQueue { get; }
    public IReadOnlyDictionary`2<ReplicationNode, ConnectionShutdownInfo> OutgoingFailureInfo { get; }
    public IReadOnlyDictionary`2<IncomingConnectionInfo, DateTime> IncomingLastActivityTime { get; }
    public IReadOnlyDictionary`2<IncomingConnectionInfo, ConcurrentQueue`1<IncomingConnectionRejectionInfo>> IncomingRejectionStats { get; }
    public List`1<ReplicationNode> Destinations { get; }
    public string TombstoneCleanerIdentifier { get; }
    public ReplicationLoader(DocumentDatabase database, ServerStore server);
    private static ReplicationLoader();
    [CompilerGeneratedAttribute]
public void add_IncomingReplicationAdded(Action`1<IncomingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void remove_IncomingReplicationAdded(Action`1<IncomingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void add_IncomingReplicationRemoved(Action`1<IncomingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void remove_IncomingReplicationRemoved(Action`1<IncomingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void add_OutgoingReplicationAdded(Action`1<DatabaseOutgoingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void remove_OutgoingReplicationAdded(Action`1<DatabaseOutgoingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void add_OutgoingReplicationRemoved(Action`1<DatabaseOutgoingReplicationHandler> value);
    [CompilerGeneratedAttribute]
public void remove_OutgoingReplicationRemoved(Action`1<DatabaseOutgoingReplicationHandler> value);
    public IEnumerable`1<ReplicationNode> get_OutgoingConnections();
    public IEnumerable`1<DatabaseOutgoingReplicationHandler> get_OutgoingHandlers();
    public IEnumerable`1<ReplicationNode> get_ReconnectQueue();
    public IReadOnlyDictionary`2<ReplicationNode, ConnectionShutdownInfo> get_OutgoingFailureInfo();
    [CompilerGeneratedAttribute]
public void add_AttachmentStreamsReceived(Action`2<IncomingReplicationHandler, int> value);
    [CompilerGeneratedAttribute]
public void remove_AttachmentStreamsReceived(Action`2<IncomingReplicationHandler, int> value);
    public IReadOnlyDictionary`2<IncomingConnectionInfo, DateTime> get_IncomingLastActivityTime();
    public IReadOnlyDictionary`2<IncomingConnectionInfo, ConcurrentQueue`1<IncomingConnectionRejectionInfo>> get_IncomingRejectionStats();
    public List`1<ReplicationNode> get_Destinations();
    public long GetMinimalEtagForReplication();
    public long GetMinimalEtagForTombstoneCleanupWithHubReplication();
    private Task DatabaseValueChanged(string databaseName, long index, string type, ClusterDatabaseChangeType changeType, object changeState);
    public void AcceptIncomingConnection(TcpConnectionOptions tcpConnectionOptions, TcpConnectionHeaderMessage header, X509Certificate2 certificate, MemoryBuffer buffer);
    private void CreatePullReplicationAsHub(TcpConnectionOptions tcpConnectionOptions, ReplicationInitialRequest initialRequest, SupportedFeatures supportedVersions, PullReplicationDefinition pullReplicationDefinition, TcpConnectionHeaderMessage header);
    public void RunPullReplicationAsSink(TcpConnectionOptions tcpConnectionOptions, MemoryBuffer buffer, PullReplicationAsSink destination, DatabaseOutgoingReplicationHandler source);
    private void OnAttachmentStreamsReceived(IncomingReplicationHandler source, int attachmentsStreamCount);
    private void CreateIncomingInstance(TcpConnectionOptions tcpConnectionOptions, MemoryBuffer buffer, PullReplicationParams pullReplicationParams);
    internal void AddAndStartOutgoingReplication(ReplicationNode node);
    private IncomingReplicationHandler CreateIncomingReplicationHandler(TcpConnectionOptions tcpConnectionOptions, MemoryBuffer buffer, PullReplicationParams incomingPullParams);
    protected virtual IncomingReplicationHandler CreateIncomingReplicationHandler(TcpConnectionOptions tcpConnectionOptions, MemoryBuffer buffer, PullReplicationParams incomingPullParams, ReplicationLatestEtagRequest getLatestEtagMessage);
    protected virtual DynamicJsonValue GetInitialRequestMessage(ReplicationLatestEtagRequest getLatestEtagMessage, PullReplicationParams replParams);
    protected virtual void AssertValidConnection(IncomingConnectionInfo connectionInfo);
    public void Initialize(DatabaseRecord record, long index);
    public void HandleDatabaseRecordChange(DatabaseRecord newRecord, long index);
    private void UpdateConnectionStrings(DatabaseRecord newRecord);
    private void HandleConflictResolverChange(DatabaseRecord newRecord, long index);
    private void HandleTopologyChange(DatabaseRecord newRecord);
    protected virtual void HandleReplicationChanges(DatabaseRecord newRecord, List`1<IDisposable> instancesToDispose);
    private void HandleHubPullReplication(DatabaseRecord newRecord, List`1<IDisposable> instancesToDispose);
    private void ForceTryReconnectAll();
    private bool IsMyTask(Dictionary`2<string, RavenConnectionString> connectionStrings, DatabaseTopology topology, ExternalReplicationBase task);
    public static ExternalReplicationState GetExternalReplicationState(ServerStore server, string database, long taskId);
    private static ExternalReplicationState GetExternalReplicationState(ServerStore server, string database, long taskId, TransactionOperationContext context);
    private void DropIncomingConnections(IEnumerable`1<ReplicationNode> connectionsToRemove, List`1<IDisposable> instancesToDispose);
    private void DisposeConnections(List`1<IDisposable> instancesToDispose);
    private ValueTuple`2<List`1<ExternalReplicationBase>, List`1<ExternalReplicationBase>> FindExternalReplicationChanges(DatabaseRecord databaseRecord, HashSet`1<ExternalReplicationBase> current, List`1<ExternalReplicationBase> newDestinations);
    private void HandleExternalReplication(DatabaseRecord newRecord, List`1<IDisposable> instancesToDispose);
    private void SetExternalReplicationProperties(DatabaseRecord newRecord, List`1<ExternalReplicationBase> externalReplications);
    private List`1<ExternalReplicationBase> GetMyNewDestinations(DatabaseRecord newRecord, List`1<ExternalReplicationBase> added);
    protected virtual CancellationToken GetCancellationToken();
    public void CompleteDeletionIfNeeded(CancellationTokenSource cts);
    private void HandleInternalReplication(DatabaseRecord newRecord, List`1<IDisposable> instancesToDispose);
    private void StartOutgoingConnections(IReadOnlyCollection`1<ReplicationNode> connectionsToAdd);
    protected void DropOutgoingConnections(IEnumerable`1<ReplicationNode> connectionsToRemove, List`1<IDisposable> instancesToDispose);
    private TcpConnectionInfo GetConnectionInfo(ReplicationNode node);
    protected virtual DatabaseOutgoingReplicationHandler GetOutgoingReplicationHandlerInstance(TcpConnectionInfo info, ReplicationNode node);
    private TcpConnectionInfo GetPullReplicationTcpInfo(PullReplicationAsSink pullReplicationAsSink, X509Certificate2 certificate, string database);
    private TcpConnectionInfo GetExternalReplicationTcpInfo(ExternalReplication exNode, X509Certificate2 certificate, string database);
    public ValueTuple`2<string, OngoingTaskConnectionStatus> GetExternalReplicationDestination(long taskId);
    public ValueTuple`2<string, OngoingTaskConnectionStatus> GetPullReplicationDestination(long taskId, string db);
    private void OnIncomingReceiveFailed(IncomingReplicationHandler instance, Exception e);
    private void OnOutgoingSendingFailed(DatabaseOutgoingReplicationHandler instance, Exception e);
    private void UpdateLastEtag(DatabaseOutgoingReplicationHandler instance);
    private void OnOutgoingSendingSucceeded(DatabaseOutgoingReplicationHandler instance);
    private void ResetReplicationFailuresInfo(DatabaseOutgoingReplicationHandler instance);
    private void OnIncomingReceiveSucceeded(IncomingReplicationHandler instance);
    public virtual void Dispose();
    public sealed virtual string get_TombstoneCleanerIdentifier();
    [CompilerGeneratedAttribute]
public void add_OutgoingReplicationConnectionFailed(Action`1<ReplicationPulse> value);
    [CompilerGeneratedAttribute]
public void remove_OutgoingReplicationConnectionFailed(Action`1<ReplicationPulse> value);
    [CompilerGeneratedAttribute]
public void add_OutgoingReplicationConnectionErrored(Action`2<ReplicationNode, OutgoingReplicationFailureToConnectReporter> value);
    [CompilerGeneratedAttribute]
public void remove_OutgoingReplicationConnectionErrored(Action`2<ReplicationNode, OutgoingReplicationFailureToConnectReporter> value);
    [CompilerGeneratedAttribute]
public void add_IncomingReplicationConnectionErrored(Action`2<ReplicationNode, IncomingReplicationFailureToConnectReporter> value);
    [CompilerGeneratedAttribute]
public void remove_IncomingReplicationConnectionErrored(Action`2<ReplicationNode, IncomingReplicationFailureToConnectReporter> value);
    public sealed virtual Dictionary`2<string, long> GetLastProcessedTombstonesPerCollection(TombstoneType tombstoneType);
    public sealed virtual Dictionary`2<TombstoneDeletionBlockageSource, HashSet`1<string>> GetDisabledSubscribersCollections(HashSet`1<string> tombstoneCollections);
    public int GetMinNumberOfReplicas();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Replication.ReplicationLoader/<WaitForReplicationAsync>d__123")]
public Task`1<int> WaitForReplicationAsync(DocumentsOperationContext context, int numberOfReplicasToWaitFor, TimeSpan waitForReplicasTimeout, ChangeVector lastChangeVector);
    private Task WaitForNextReplicationAsync();
    private int ReplicatedPastInternalDestinations(DocumentsOperationContext context, HashSet`1<string> internalUrls, ChangeVector changeVector);
    public static bool IsOfTypePreventDeletions(ReplicationBatchItem item);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <.ctor>b__54_0(object state);
    [CompilerGeneratedAttribute]
private void <DatabaseValueChanged>g__DisposeRelatedPullReplication|57_0(string hub, string certThumbprint, string sourceDatabase);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <DisposeConnections>b__82_0(object toDispose);
    [CompilerGeneratedAttribute]
private void <DisposeConnections>b__82_1(IDisposable instance);
    [CompilerGeneratedAttribute]
private InternalReplication <HandleInternalReplication>b__89_0(string r);
    [CompilerGeneratedAttribute]
private InternalReplication <HandleInternalReplication>b__89_1(string r);
    [CompilerGeneratedAttribute]
private void <Dispose>b__107_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__107_1();
    [CompilerGeneratedAttribute]
private void <Dispose>b__107_2();
}
public class Raven.Server.Documents.Replication.ReplicationMessageReply : object {
    [CompilerGeneratedAttribute]
private ReplyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastEtagAccepted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AcceptablePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private PreventDeletionsMode <PreventDeletionsMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentEtag>k__BackingField;
    public ReplyType Type { get; public set; }
    public long LastEtagAccepted { get; public set; }
    public string Exception { get; public set; }
    public string Message { get; public set; }
    public string MessageType { get; public set; }
    public string DatabaseChangeVector { get; public set; }
    public String[] AcceptablePaths { get; public set; }
    public PreventDeletionsMode PreventDeletionsMode { get; public set; }
    public string DatabaseId { get; public set; }
    public string NodeTag { get; public set; }
    public long CurrentEtag { get; public set; }
    [CompilerGeneratedAttribute]
public ReplyType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ReplyType value);
    [CompilerGeneratedAttribute]
public long get_LastEtagAccepted();
    [CompilerGeneratedAttribute]
public void set_LastEtagAccepted(long value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_MessageType();
    [CompilerGeneratedAttribute]
public void set_MessageType(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseChangeVector();
    [CompilerGeneratedAttribute]
public void set_DatabaseChangeVector(string value);
    [CompilerGeneratedAttribute]
public String[] get_AcceptablePaths();
    [CompilerGeneratedAttribute]
public void set_AcceptablePaths(String[] value);
    [CompilerGeneratedAttribute]
public PreventDeletionsMode get_PreventDeletionsMode();
    [CompilerGeneratedAttribute]
public void set_PreventDeletionsMode(PreventDeletionsMode value);
    [CompilerGeneratedAttribute]
public string get_DatabaseId();
    [CompilerGeneratedAttribute]
public void set_DatabaseId(string value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public long get_CurrentEtag();
    [CompilerGeneratedAttribute]
public void set_CurrentEtag(long value);
}
public class Raven.Server.Documents.Replication.ReplicationOperation : object {
}
public class Raven.Server.Documents.Replication.ResolveConflictOnReplicationConfigurationChange : object {
    private DocumentDatabase _database;
    private Logger _log;
    private ReplicationLoader _replicationLoader;
    internal Dictionary`2<string, ScriptResolver> ScriptConflictResolversCache;
    private long _processedRaftIndex;
    private SemaphoreSlim _runOnce;
    public long ConflictsCount { get; }
    public ResolveConflictOnReplicationConfigurationChange(ReplicationLoader replicationLoader, Logger log);
    public long get_ConflictsCount();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Replication.ResolveConflictOnReplicationConfigurationChange/<RunOnceAsync>d__9")]
private Task`1<IDisposable> RunOnceAsync();
    public void WaitForBackgroundResolveTask();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Replication.ResolveConflictOnReplicationConfigurationChange/<RunConflictResolversOnce>d__11")]
public Task RunConflictResolversOnce(ConflictSolver solver, long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Replication.ResolveConflictOnReplicationConfigurationChange/<ResolveConflictsInBackground>d__12")]
private Task ResolveConflictsInBackground(ConflictSolver solver);
    private void UpdateScriptResolvers(ConflictSolver conflictSolver);
    private bool ValidatedResolveByScriptInput(ScriptResolver scriptResolver, IReadOnlyList`1<DocumentConflict> conflicts, LazyStringValue collection);
    public void PutResolvedDocument(DocumentsOperationContext context, DocumentConflict resolved, bool resolvedToLatest, DocumentConflict incoming);
    private void SaveConflictedDocumentsAsRevisions(DocumentsOperationContext context, string id, DocumentConflict incoming);
    public void SaveLocalAsRevision(DocumentsOperationContext context, string id);
    private void DeleteDocumentFromDifferentCollectionIfNeeded(DocumentsOperationContext ctx, DocumentConflict conflict);
    public bool TryResolveConflictByScriptInternal(DocumentsOperationContext context, ScriptResolver scriptResolver, IReadOnlyList`1<DocumentConflict> conflicts, LazyStringValue collection, DocumentConflict& resolvedConflict);
    public DocumentConflict ResolveToLatest(DocumentsOperationContext context, List`1<DocumentConflict> conflicts);
    private void ResolveAttachmentsConflicts(DocumentsOperationContext context, DocumentConflict resolved, bool resolvedToLatest);
    [CompilerGeneratedAttribute]
private void <RunOnceAsync>b__9_0();
}
public class Raven.Server.Documents.Replication.Senders.ExternalReplicationDocumentSender : ReplicationDocumentSenderBase {
    public ExternalReplicationDocumentSender(Stream stream, DatabaseOutgoingReplicationHandler parent, Logger log);
    protected virtual TimeSpan GetDelayReplication();
    protected virtual bool ShouldSkip(DocumentsOperationContext context, ReplicationBatchItem item, OutgoingReplicationStatsScope stats, SkippedReplicationItemsInfo skippedReplicationItemsInfo);
}
public class Raven.Server.Documents.Replication.Senders.FilteredReplicationDocumentSender : ExternalReplicationDocumentSender {
    private AllowedPathsValidator _pathsToSend;
    private AllowedPathsValidator _destinationAcceptablePaths;
    private bool _shouldSkipSendingTombstones;
    public FilteredReplicationDocumentSender(Stream stream, OutgoingPullReplicationHandler parent, Logger log, String[] pathsToSend, String[] destinationAcceptablePaths);
    protected virtual bool ShouldSkip(DocumentsOperationContext context, ReplicationBatchItem item, OutgoingReplicationStatsScope stats, SkippedReplicationItemsInfo skippedReplicationItemsInfo);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <ShouldSkip>g__ValidatorSaysToSkip|4_0(AllowedPathsValidator validator, <>c__DisplayClass4_0& );
}
public class Raven.Server.Documents.Replication.Senders.InternalReplicationDocumentSender : ReplicationDocumentSenderBase {
    public InternalReplicationDocumentSender(Stream stream, DatabaseOutgoingReplicationHandler parent, Logger log);
}
public class Raven.Server.Documents.Replication.Senders.MergedAsyncEnumerator`1 : object {
    private IComparer`1<T> _comparer;
    private List`1<IAsyncEnumerator`1<T>> _workEnumerators;
    private T _currentItem;
    private IAsyncEnumerator`1<T> _currentEnumerator;
    public T Current { get; }
    public MergedAsyncEnumerator`1(IComparer`1<T> comparer);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Replication.Senders.MergedAsyncEnumerator`1/<AddAsyncEnumerator>d__5")]
public ValueTask AddAsyncEnumerator(IAsyncEnumerator`1<T> enumerator);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Replication.Senders.MergedAsyncEnumerator`1/<MoveNextAsync>d__6")]
public sealed virtual ValueTask`1<bool> MoveNextAsync();
    public void Reset();
    public sealed virtual T get_Current();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Replication.Senders.MergedAsyncEnumerator`1/<DisposeAsync>d__10")]
public sealed virtual ValueTask DisposeAsync();
}
public class Raven.Server.Documents.Replication.Senders.MergedEnumerator`1 : object {
    protected IComparer`1<T> Comparer;
    protected List`1<IEnumerator`1<T>> WorkEnumerators;
    protected T CurrentItem;
    protected IEnumerator`1<T> CurrentEnumerator;
    private object System.Collections.IEnumerator.Current { get; }
    public T Current { get; }
    public MergedEnumerator`1(IComparer`1<T> comparer);
    public virtual void AddEnumerator(IEnumerator`1<T> enumerator);
    public virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual T get_Current();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Replication.Senders.MergedReplicationBatchEnumerator : MergedEnumerator`1<ReplicationBatchItem> {
    private OutgoingReplicationStatsScope _documentRead;
    private OutgoingReplicationStatsScope _attachmentRead;
    private OutgoingReplicationStatsScope _tombstoneRead;
    private OutgoingReplicationStatsScope _countersRead;
    private OutgoingReplicationStatsScope _timeSeriesRead;
    public MergedReplicationBatchEnumerator(OutgoingReplicationStatsScope documentRead, OutgoingReplicationStatsScope attachmentRead, OutgoingReplicationStatsScope tombstoneRead, OutgoingReplicationStatsScope counterRead, OutgoingReplicationStatsScope timeSeriesRead);
    public void AddEnumerator(ReplicationItemType type, IEnumerator`1<ReplicationBatchItem> enumerator);
    public virtual void AddEnumerator(IEnumerator`1<ReplicationBatchItem> enumerator);
    private OutgoingReplicationStatsScope GetStatsFor(ReplicationItemType type);
    public virtual bool MoveNext();
}
public class Raven.Server.Documents.Replication.Senders.MigrationReplicationDocumentSender : ReplicationDocumentSenderBase {
    public BucketMigrationReplication Destination;
    public ShardedDocumentDatabase Database;
    public OutgoingMigrationReplicationHandler Parent;
    public MigrationReplicationDocumentSender(Stream stream, OutgoingMigrationReplicationHandler parent, Logger log);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Replication.Senders.MigrationReplicationDocumentSender/<GetReplicationItems>d__4")]
protected virtual IEnumerable`1<ReplicationBatchItem> GetReplicationItems(DocumentsOperationContext ctx, long etag, ReplicationStats stats, ReplicationSupportedFeatures replicationSupportedFeatures);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Replication.Senders.MigrationReplicationDocumentSender/<ReplicationBatchItemsForBucket>d__5")]
public static IEnumerable`1<ReplicationBatchItem> ReplicationBatchItemsForBucket(ShardedDocumentsStorage documentsStorage, DocumentsOperationContext ctx, long etag, ReplicationStats stats, int bucket);
    protected virtual bool ShouldSkip(DocumentsOperationContext context, ReplicationBatchItem item, OutgoingReplicationStatsScope stats, SkippedReplicationItemsInfo skippedReplicationItemsInfo);
}
public class Raven.Server.Documents.Replication.Senders.ReplicationBatchItemByEtagComparer : Comparer`1<ReplicationBatchItem> {
    public static ReplicationBatchItemByEtagComparer Instance;
    private static ReplicationBatchItemByEtagComparer();
    public virtual int Compare(ReplicationBatchItem x, ReplicationBatchItem y);
}
public abstract class Raven.Server.Documents.Replication.Senders.ReplicationDocumentSenderBase : object {
    protected Logger Log;
    private long _lastEtag;
    private SortedList`2<long, ReplicationBatchItem> _orderedReplicaItems;
    private Dictionary`2<Slice, AttachmentReplicationItem> _replicaAttachmentStreams;
    private Byte[] _tempBuffer;
    private Stream _stream;
    internal DatabaseOutgoingReplicationHandler _parent;
    private OutgoingReplicationStatsScope _statsInstance;
    protected ReplicationStats _stats;
    [CompilerGeneratedAttribute]
private bool <MissingAttachmentsInLastBatch>k__BackingField;
    private HashSet`1<Slice> _deduplicatedAttachmentHashes;
    private Queue`1<Slice> _deduplicatedAttachmentHashesLru;
    private int _numberOfAttachmentsTrackedForDeduplication;
    private ByteStringContext _allocator;
    public bool MissingAttachmentsInLastBatch { get; private set; }
    protected ReplicationDocumentSenderBase(Stream stream, DatabaseOutgoingReplicationHandler parent, Logger log);
    [CompilerGeneratedAttribute]
public bool get_MissingAttachmentsInLastBatch();
    [CompilerGeneratedAttribute]
private void set_MissingAttachmentsInLastBatch(bool value);
    protected virtual IEnumerable`1<ReplicationBatchItem> GetReplicationItems(DocumentsOperationContext ctx, long etag, ReplicationStats stats, ReplicationSupportedFeatures replicationSupportedFeatures);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Replication.Senders.ReplicationDocumentSenderBase/<GetReplicationItems>d__19")]
protected internal static IEnumerable`1<ReplicationBatchItem> GetReplicationItems(DocumentDatabase database, DocumentsOperationContext ctx, long etag, ReplicationStats stats, ReplicationSupportedFeatures replicationSupportedFeatures);
    public bool ExecuteReplicationOnce(TcpConnectionOptions tcpConnectionOptions, OutgoingReplicationStatsScope stats, Int64& next);
    private void AssertNoLegacyReplicationViolation(ReplicationBatchItem item);
    private void AssertNotTimeSeriesForLegacyReplication(ReplicationBatchItem item);
    private void AssertNotCounterForLegacyReplication(ReplicationBatchItem item);
    private void AssertNotClusterTransactionDocumentForLegacyReplication(ReplicationBatchItem item);
    private void AssertNotIncrementalTimeSeriesForLegacyReplication(ReplicationBatchItem item);
    protected virtual TimeSpan GetDelayReplication();
    private bool AddReplicationItemToBatch(DocumentsOperationContext context, ReplicationBatchItem item, OutgoingReplicationStatsScope stats, ReplicationBatchState state, SkippedReplicationItemsInfo skippedReplicationItemsInfo);
    private bool ShouldSendAttachmentStream(AttachmentReplicationItem attachment);
    protected virtual bool ShouldSkip(DocumentsOperationContext context, ReplicationBatchItem item, OutgoingReplicationStatsScope stats, SkippedReplicationItemsInfo skippedReplicationItemsInfo);
    private void SendDocumentsBatch(DocumentsOperationContext documentsContext, OutgoingReplicationStatsScope stats);
    private void EnsureValidStats(OutgoingReplicationStatsScope stats);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Replication.ShardedExternalReplicationState : object {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceShardedDatabaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceDatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ShardedExternalReplicationStateForSingleSource> <ReplicationStates>k__BackingField;
    public string NodeTag { get; public set; }
    public string SourceShardedDatabaseId { get; public set; }
    public string SourceDatabaseName { get; public set; }
    public Dictionary`2<string, ShardedExternalReplicationStateForSingleSource> ReplicationStates { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public string get_SourceShardedDatabaseId();
    [CompilerGeneratedAttribute]
public void set_SourceShardedDatabaseId(string value);
    [CompilerGeneratedAttribute]
public string get_SourceDatabaseName();
    [CompilerGeneratedAttribute]
public void set_SourceDatabaseName(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ShardedExternalReplicationStateForSingleSource> get_ReplicationStates();
    [CompilerGeneratedAttribute]
public void set_ReplicationStates(Dictionary`2<string, ShardedExternalReplicationStateForSingleSource> value);
    public static string GenerateShardedItemName(string databaseName, string sourceDatabaseName, string sourceDatabaseId);
    private DynamicJsonValue BuildReplicationStatesJson();
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.Replication.ShardedExternalReplicationStateForSingleSource : object {
    [CompilerGeneratedAttribute]
private long <LastSourceEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastSourceChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ExternalReplicationState> <DestinationStates>k__BackingField;
    public long LastSourceEtag { get; public set; }
    public string LastSourceChangeVector { get; public set; }
    public Dictionary`2<string, ExternalReplicationState> DestinationStates { get; public set; }
    [CompilerGeneratedAttribute]
public long get_LastSourceEtag();
    [CompilerGeneratedAttribute]
public void set_LastSourceEtag(long value);
    [CompilerGeneratedAttribute]
public string get_LastSourceChangeVector();
    [CompilerGeneratedAttribute]
public void set_LastSourceChangeVector(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ExternalReplicationState> get_DestinationStates();
    [CompilerGeneratedAttribute]
public void set_DestinationStates(Dictionary`2<string, ExternalReplicationState> value);
    public DynamicJsonValue BuildDestinationStatesJson();
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.Replication.ShardReplicationLoader : ReplicationLoader {
    private ShardedDocumentDatabase _database;
    private int _myShardNumber;
    private string _shardedName;
    public ShardReplicationLoader(ShardedDocumentDatabase database, ServerStore server);
    protected virtual IncomingReplicationHandler CreateIncomingReplicationHandler(TcpConnectionOptions tcpConnectionOptions, MemoryBuffer buffer, PullReplicationParams incomingPullParams, ReplicationLatestEtagRequest getLatestEtagMessage);
    protected virtual DatabaseOutgoingReplicationHandler GetOutgoingReplicationHandlerInstance(TcpConnectionInfo info, ReplicationNode node);
    protected virtual void HandleReplicationChanges(DatabaseRecord newRecord, List`1<IDisposable> instancesToDispose);
    private void OnDocumentReceived(IncomingReplicationHandler handler);
    private void HandleMigrationReplication(DatabaseRecord newRecord, List`1<IDisposable> instancesToDispose);
    public static ShardedExternalReplicationState GetShardedExternalReplicationStates(ServerStore server, string database, string source, string sourceDbId);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(IncomingReplicationHandler handler);
}
public class Raven.Server.Documents.Replication.Stats.IncomingConnectionInfo : object {
    [CompilerGeneratedAttribute]
private string <SourceDatabaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceDatabaseBase64Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceDatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceMachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteIp>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationType <ReplicationsType>k__BackingField;
    public string SourceDatabaseId { get; public set; }
    public string SourceDatabaseBase64Id { get; public set; }
    public string SourceDatabaseName { get; public set; }
    public string SourceUrl { get; public set; }
    public string SourceMachineName { get; public set; }
    public string SourceTag { get; public set; }
    public string RemoteIp { get; public set; }
    public ReplicationType ReplicationsType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SourceDatabaseId();
    [CompilerGeneratedAttribute]
public void set_SourceDatabaseId(string value);
    [CompilerGeneratedAttribute]
public string get_SourceDatabaseBase64Id();
    [CompilerGeneratedAttribute]
public void set_SourceDatabaseBase64Id(string value);
    [CompilerGeneratedAttribute]
public string get_SourceDatabaseName();
    [CompilerGeneratedAttribute]
public void set_SourceDatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_SourceUrl();
    [CompilerGeneratedAttribute]
public void set_SourceUrl(string value);
    [CompilerGeneratedAttribute]
public string get_SourceMachineName();
    [CompilerGeneratedAttribute]
public void set_SourceMachineName(string value);
    [CompilerGeneratedAttribute]
public string get_SourceTag();
    [CompilerGeneratedAttribute]
public void set_SourceTag(string value);
    [CompilerGeneratedAttribute]
public string get_RemoteIp();
    [CompilerGeneratedAttribute]
public void set_RemoteIp(string value);
    [CompilerGeneratedAttribute]
public ReplicationType get_ReplicationsType();
    [CompilerGeneratedAttribute]
public void set_ReplicationsType(ReplicationType value);
    public static IncomingConnectionInfo FromGetLatestEtag(ReplicationLatestEtagRequest message);
    public virtual string ToString();
    public string DebugInfoString();
    public sealed virtual bool Equals(IncomingConnectionInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(IncomingConnectionInfo left, IncomingConnectionInfo right);
    public static bool op_Inequality(IncomingConnectionInfo left, IncomingConnectionInfo right);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.Replication.Stats.IncomingReplicationRunStats : ReplicationRunStatsBase {
    public int InputCount;
    public long LastEtag;
    public string DatabaseChangeVector;
    public Size ReceivedLastBatchSize;
    public int DocumentReadCount;
    public Size DocumentReadSize;
    public int DocumentTombstoneReadCount;
    public Size DocumentTombstoneReadSize;
    public int AttachmentTombstoneReadCount;
    public Size AttachmentTombstoneReadSize;
    public int AttachmentReadCount;
    public Size AttachmentReadSize;
    public int AttachmentStreamReadCount;
    public Size AttachmentStreamReadSize;
    public int RevisionTombstoneReadCount;
    public Size RevisionTombstoneReadSize;
    public int RevisionReadCount;
    public Size RevisionReadSize;
    public int CounterReadCount;
    public Size CounterReadSize;
    public int TimeSeriesReadCount;
    public Size TimeSeriesReadSize;
    public int TimeSeriesDeletedRangeReadCount;
    public Size TimeSeriesDeletedRangeReadSize;
}
public class Raven.Server.Documents.Replication.Stats.IncomingReplicationStatsAggregator : StatsAggregator`2<IncomingReplicationRunStats, IncomingReplicationStatsScope> {
    private IncomingReplicationPerformanceStats modreq(System.Runtime.CompilerServices.IsVolatile) _performanceStats;
    public IncomingReplicationStatsAggregator(int id, StatsAggregator`2<IncomingReplicationRunStats, IncomingReplicationStatsScope> lastStats);
    public virtual IncomingReplicationStatsScope CreateScope();
    public IncomingReplicationPerformanceStats ToReplicationPerformanceLiveStatsWithDetails();
    public IncomingReplicationPerformanceStats ToReplicationPerformanceStats();
    private IncomingReplicationPerformanceStats CreateIndexingPerformanceStats(bool completed);
}
public class Raven.Server.Documents.Replication.Stats.IncomingReplicationStatsScope : StatsScope`2<IncomingReplicationRunStats, IncomingReplicationStatsScope> {
    private IncomingReplicationRunStats _stats;
    public IncomingReplicationStatsScope(IncomingReplicationRunStats stats, bool start);
    protected virtual IncomingReplicationStatsScope OpenNewScope(IncomingReplicationRunStats stats, bool start);
    public ReplicationPerformanceOperation ToReplicationPerformanceOperation(string name);
    public void RecordDocumentRead(long sizeInBytes);
    public void RecordDocumentTombstoneRead(long sizeInBytes);
    public void RecordAttachmentTombstoneRead(long sizeInBytes);
    public void RecordRevisionTombstoneRead(long sizeInBytes);
    public void RecordRevisionRead(long sizeInBytes);
    public void RecordAttachmentRead(long sizeInBytes);
    public void RecordAttachmentStreamRead(long sizeInBytes);
    public void RecordCountersRead(int numberOfCounters, long sizeInBytes);
    public void RecordTimeSeriesRead(long sizeInBytes);
    public void RecordTimeSeriesDeletedRangeRead(long sizeInBytes);
    public void RecordInputAttempt();
    public void RecordLastEtag(long etag);
    public void RecordDatabaseChangeVector(string changeVector);
    public void AddError(Exception exception);
}
public class Raven.Server.Documents.Replication.Stats.LiveReplicationPerformanceCollector : DatabaseAwareLivePerformanceCollector`1<IReplicationPerformanceStats> {
    private ConcurrentDictionary`2<string, ReplicationHandlerAndPerformanceStatsList`2<IncomingReplicationHandler, IncomingReplicationStatsAggregator>> _incoming;
    private ConcurrentDictionary`2<DatabaseOutgoingReplicationHandler, ReplicationHandlerAndPerformanceStatsList`2<DatabaseOutgoingReplicationHandler, OutgoingReplicationStatsAggregator>> _outgoing;
    private ConcurrentDictionary`2<ReplicationNode, OutgoingReplicationFailureToConnectReporter> _outgoingErrors;
    private ConcurrentDictionary`2<ReplicationNode, IncomingReplicationFailureToConnectReporter> _incomingErrors;
    public LiveReplicationPerformanceCollector(DocumentDatabase database);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Replication.Stats.LiveReplicationPerformanceCollector/<StartCollectingStats>d__5")]
protected virtual Task StartCollectingStats();
    private void OutgoingReplicationConnectionFailed(ReplicationNode node, OutgoingReplicationFailureToConnectReporter outgoingFailureReporter);
    private void IncomingReplicationConnectionFailed(ReplicationNode node, IncomingReplicationFailureToConnectReporter incomingFailureReporter);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Replication.Stats.LiveReplicationPerformanceCollector/<PrepareInitialPerformanceStats>d__8")]
private IEnumerable`1<IReplicationPerformanceStats> PrepareInitialPerformanceStats();
    protected virtual List`1<IReplicationPerformanceStats> PreparePerformanceStats();
    protected virtual void WriteStats(List`1<IReplicationPerformanceStats> stats, AsyncBlittableJsonTextWriter writer, JsonOperationContext context);
    private void OutgoingHandlerRemoved(DatabaseOutgoingReplicationHandler handler);
    private void OutgoingHandlerAdded(DatabaseOutgoingReplicationHandler handler);
    private void OutgoingDocumentsSend(DatabaseOutgoingReplicationHandler handler);
    private void IncomingHandlerRemoved(IncomingReplicationHandler handler);
    private void IncomingHandlerAdded(IncomingReplicationHandler handler);
    private void IncomingDocumentsReceived(IncomingReplicationHandler handler);
}
public class Raven.Server.Documents.Replication.Stats.LiveReplicationPulsesCollector : object {
    private DocumentDatabase _database;
    public AsyncQueue`1<ReplicationPulse> Pulses;
    public LiveReplicationPulsesCollector(DocumentDatabase database);
    private void OutgoingHandlerRemoved(DatabaseOutgoingReplicationHandler handler);
    private void OutgoingHandlerAdded(DatabaseOutgoingReplicationHandler handler);
    private void HandleReplicationPulse(ReplicationPulse pulse);
    private void IncomingHandlerRemoved(IncomingReplicationHandler handler);
    private void IncomingHandlerAdded(IncomingReplicationHandler handler);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Replication.Stats.OutgoingReplicationRunStats : ReplicationRunStatsBase {
    public long LastEtag;
    public Size LastBatchSize;
    public string LastAcceptedChangeVector;
    public int InputCount;
    public int ArtificialDocumentSkipCount;
    public int SystemDocumentSkipCount;
    public int ChangeVectorSkipCount;
    public int DocumentOutputCount;
    public Size DocumentOutputSize;
    public int RevisionOutputCount;
    public Size RevisionOutputSize;
    public int TimeSeriesOutputCount;
    public Size TimeSeriesOutputSize;
    public int AttachmentOutputCount;
    public Size AttachmentOutputSize;
    public int AttachmentStreamOutputCount;
    public Size AttachmentStreamOutputSize;
    public int CounterOutputCount;
    public Size CounterOutputSize;
    public int DocumentTombstoneOutputCount;
    public Size DocumentTombstoneOutputSize;
    public int AttachmentTombstoneOutputCount;
    public Size AttachmentTombstoneOutputSize;
    public int RevisionTombstoneOutputCount;
    public Size RevisionTombstoneOutputSize;
    public int TimeSeriesDeletedRangeOutputCount;
    public Size TimeSeriesDeletedRangeOutputSize;
}
public class Raven.Server.Documents.Replication.Stats.OutgoingReplicationStatsAggregator : StatsAggregator`2<OutgoingReplicationRunStats, OutgoingReplicationStatsScope> {
    private OutgoingReplicationPerformanceStats modreq(System.Runtime.CompilerServices.IsVolatile) _performanceStats;
    public OutgoingReplicationStatsAggregator(int id, StatsAggregator`2<OutgoingReplicationRunStats, OutgoingReplicationStatsScope> lastStats);
    public virtual OutgoingReplicationStatsScope CreateScope();
    public OutgoingReplicationPerformanceStats ToReplicationPerformanceLiveStatsWithDetails();
    public OutgoingReplicationPerformanceStats ToReplicationPerformanceStats();
    private OutgoingReplicationPerformanceStats CreateIndexingPerformanceStats(bool completed);
}
public class Raven.Server.Documents.Replication.Stats.OutgoingReplicationStatsScope : StatsScope`2<OutgoingReplicationRunStats, OutgoingReplicationStatsScope> {
    private OutgoingReplicationRunStats _stats;
    public OutgoingReplicationStatsScope(OutgoingReplicationRunStats stats, bool start);
    protected virtual OutgoingReplicationStatsScope OpenNewScope(OutgoingReplicationRunStats stats, bool start);
    public void RecordInputAttempt();
    public void RecordArtificialDocumentSkip();
    public void RecordChangeVectorSkip();
    public void RecordAttachmentOutput(long sizeInBytes);
    public void RecordAttachmentStreamOutput(long sizeInBytes);
    public void RecordAttachmentTombstoneOutput(long sizeInBytes);
    public void RecordRevisionTombstoneOutput(long sizeInBytes);
    public void RecordDocumentOutput(long sizeInBytes);
    public void RecordDocumentTombstoneOutput(long sizeInBytes);
    public void RecordRevisionOutput(long sizeInBytes);
    public void RecordTimeSeriesOutput(long sizeInBytes);
    public void RecordCountersOutput(int numberOfCounters, long sizeInBytes);
    public void RecordTimeSeriesDeletedRangeOutput(long sizeInBytes);
    public void RecordLastEtag(long etag);
    public void RecordLastAcceptedChangeVector(string changeVector);
    public ReplicationPerformanceOperation ToReplicationPerformanceOperation(string name);
    public void AddError(Exception exception);
}
public enum Raven.Server.Documents.Replication.Stats.ReplicationPulseDirection : Enum {
    public int value__;
    public static ReplicationPulseDirection OutgoingInitiate;
    public static ReplicationPulseDirection OutgoingInitiateError;
    public static ReplicationPulseDirection OutgoingBegin;
    public static ReplicationPulseDirection OutgoingError;
    public static ReplicationPulseDirection OutgoingEnd;
    public static ReplicationPulseDirection OutgoingHeartbeat;
    public static ReplicationPulseDirection OutgoingHeartbeatError;
    public static ReplicationPulseDirection OutgoingHeartbeatAcknowledge;
    public static ReplicationPulseDirection OutgoingHeartbeatAcknowledgeError;
    public static ReplicationPulseDirection OutgoingGetTcpInfo;
    public static ReplicationPulseDirection IncomingInitiate;
    public static ReplicationPulseDirection IncomingInitiateError;
    public static ReplicationPulseDirection IncomingBegin;
    public static ReplicationPulseDirection IncomingError;
    public static ReplicationPulseDirection IncomingEnd;
    public static ReplicationPulseDirection IncomingHeartbeat;
    public static ReplicationPulseDirection IncomingHeartbeatAcknowledge;
}
public abstract class Raven.Server.Documents.Replication.Stats.ReplicationRunStatsBase : object {
    public List`1<ReplicationError> Errors;
    public void AddError(Exception exception);
    private void AddError(string message);
}
public class Raven.Server.Documents.ResourceCache`1 : object {
    private FrozenDictionary`2<StringSegment, Task`1<TResource>> _readonlyCaseInsensitive;
    private FrozenDictionary`2<StringSegment, Task`1<TResource>> _readonlyCaseSensitive;
    private FrozenDictionary`2<Task`1<TResource>, ResourceDetails<TResource>> _readonlyResourceDetails;
    private ConcurrentDictionary`2<StringSegment, Task`1<TResource>> _caseInsensitive;
    private ConcurrentDictionary`2<StringSegment, Task`1<TResource>> _caseSensitive;
    private ConcurrentDictionary`2<Task`1<TResource>, ResourceDetails<TResource>> _resourceDetails;
    private ConcurrentDictionary`2<StringSegment, ConcurrentSet`1<StringSegment>> _mappings;
    private TestingStuff<TResource> _forTestingPurposes;
    public IEnumerable`1<Task`1<TResource>> Values { get; }
    public int Count { get; }
    internal int DetailsCount { get; }
    public IEnumerable`1<Task`1<TResource>> get_Values();
    public int get_Count();
    internal int get_DetailsCount();
    public void Clear();
    public bool TryGetValue(StringSegment resourceName, Task`1& resourceTask);
    public bool TryGetValue(StringSegment resourceName, Task`1& resourceTask, ResourceDetails& details);
    private bool UnlikelyTryGet(StringSegment resourceName, Task`1& resourceTask);
    public bool TryRemove(StringSegment resourceName, Task`1<TResource> resourceTask);
    private void RemoveCaseSensitive(StringSegment resourceName, Task`1<TResource> resourceTask);
    public bool TryGetAndRemove(StringSegment resourceName, Task`1& resourceTask);
    public sealed virtual IEnumerator`1<KeyValuePair`2<StringSegment, Task`1<TResource>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Task`1<TResource> GetOrAdd(StringSegment databaseName, Task`1<TResource> task);
    public IDisposable RemoveLockAndReturn(string databaseName, Action`1<TResource> onSuccess, TResource& resource, string caller, string reason);
    internal TestingStuff<TResource> ForTestingPurposesOnly();
}
internal class Raven.Server.Documents.Revisions.DeleteRevisionsBeforeCommandDto : object {
    public string Collection;
    public DateTime Time;
    public sealed virtual DeleteRevisionsBeforeCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public class Raven.Server.Documents.Revisions.RevertRevisionsRequest : object {
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private long <WindowInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Collections>k__BackingField;
    public DateTime Time { get; public set; }
    public long WindowInSec { get; public set; }
    public String[] Collections { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(DateTime value);
    [CompilerGeneratedAttribute]
public long get_WindowInSec();
    [CompilerGeneratedAttribute]
public void set_WindowInSec(long value);
    [CompilerGeneratedAttribute]
public String[] get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(String[] value);
}
public class Raven.Server.Documents.Revisions.RevisionsOperations : object {
    private DocumentDatabase _database;
    public RevisionsOperations(DocumentDatabase database);
    public void DeleteRevisionsBefore(string collection, DateTime time);
}
public class Raven.Server.Documents.Revisions.RevisionsStorage : object {
    public TableSchema RevisionsSchema;
    public TableSchema CompressedRevisionsSchema;
    public long SizeLimitInBytes;
    public RevisionsConfiguration ConflictConfiguration;
    public static long NotDeletedRevisionMarker;
    public RevisionsOperations Operations;
    [CompilerGeneratedAttribute]
private RevisionsConfiguration <Configuration>k__BackingField;
    private DocumentDatabase _database;
    private DocumentsStorage _documentsStorage;
    private HashSet`1<string> _tableCreated;
    private Logger _logger;
    private static TimeSpan MaxEnforceConfigurationSingleBatchTime;
    private RevisionsCollectionConfiguration _emptyConfiguration;
    private static RevisionsCollectionConfiguration ZeroConfiguration;
    internal TestingStuff ForTestingPurposes;
    public RevisionsConfiguration Configuration { get; private set; }
    public RevisionsStorage(DocumentDatabase database, Transaction tx, TableSchema revisionsSchema, TableSchema compressedRevisionsSchema);
    private static RevisionsStorage();
    [CompilerGeneratedAttribute]
public RevisionsConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(RevisionsConfiguration value);
    public Table EnsureRevisionTableCreated(Transaction tx, CollectionName collection);
    internal Table EnsureRevisionTableCreated(Transaction tx, CollectionName collection, TableSchema schema);
    public void InitializeFromDatabaseRecord(DatabaseRecord dbRecord);
    private void CreateTrees(Transaction tx);
    public RevisionsCollectionConfiguration GetRevisionsConfiguration(string collection, DocumentFlags flags, bool deleteRevisionsWhenNoCofiguration);
    public bool ShouldVersionDocument(CollectionName collectionName, NonPersistentDocumentFlags nonPersistentFlags, BlittableJsonReaderObject existingDocument, BlittableJsonReaderObject document, DocumentsOperationContext context, string id, Nullable`1<long> lastModifiedTicks, DocumentFlags& documentFlags, RevisionsCollectionConfiguration& docConfiguration);
    public bool ShouldVersionOldDocument(DocumentsOperationContext context, DocumentFlags flags, BlittableJsonReaderObject oldDoc, ChangeVector changeVector, CollectionName collectionName);
    public bool Put(DocumentsOperationContext context, string id, BlittableJsonReaderObject document, DocumentFlags flags, NonPersistentDocumentFlags nonPersistentFlags, ChangeVector changeVector, long lastModifiedTicks, RevisionsCollectionConfiguration configuration, CollectionName collectionName);
    private BlittableJsonReaderObject AddCounterAndTimeSeriesSnapshotsIfNeeded(DocumentsOperationContext context, string id, BlittableJsonReaderObject document);
    private void PutFromRevisionIfChangeVectorIsGreater(DocumentsOperationContext context, BlittableJsonReaderObject document, string id, ChangeVector changeVector, long lastModifiedTicks, DocumentFlags flags, NonPersistentDocumentFlags nonPersistentFlags, CollectionName collectionName);
    private static bool RevertSnapshotFlag(BlittableJsonReaderObject metadata, string snapshotFlag, string flag);
    private static BlittableJsonReaderObject RevertSnapshotFlags(DocumentsOperationContext context, BlittableJsonReaderObject document, string documentId);
    private DeleteOldRevisionsResult DeleteOldRevisions(DocumentsOperationContext context, Table table, Slice lowerIdPrefix, CollectionName collectionName, RevisionsCollectionConfiguration configuration, NonPersistentDocumentFlags nonPersistentFlags, ChangeVector changeVector, long lastModifiedTicks, bool documentDeleted, bool skipForceCreated, DocumentFlags flags);
    private static bool ShouldAddConflictRevisionNotification(bool conflicted, NonPersistentDocumentFlags nonPersistentFlags, long deleted);
    public long DeleteRevisionsFor(DocumentsOperationContext context, string id, bool fromDelete);
    public void DeleteRevisionsBefore(DocumentsOperationContext context, string collection, DateTime time);
    private CollectionName GetCollectionFor(DocumentsOperationContext context, Slice prefixSlice);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetCollections>d__37")]
public IEnumerable`1<string> GetCollections(Transaction transaction);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetRevisionsForCollectionOrDefault>d__38")]
private IEnumerable`1<Document> GetRevisionsForCollectionOrDefault(DocumentsOperationContext context, Table table, Slice prefixSlice, RevisionsCollectionConfiguration configuration, long revisionsCount, bool stopWhenReachingAge, DeleteOldRevisionsResult result);
    private long DeleteRevisionsInternal(DocumentsOperationContext context, Table table, Slice lowerIdPrefix, CollectionName collectionName, ChangeVector changeVector, long lastModifiedTicks, IEnumerable`1<Document> revisionsToRemove, DeleteOldRevisionsResult result, DocumentFlags tombstoneFlags);
    private bool RevisionIsLast(DocumentsOperationContext context, Table table, Slice lowerIdPrefix, long etag);
    private bool ShouldAdoptRevision(DocumentsOperationContext context, Slice lowerId, Slice lowerIdPrefix, CollectionName collectionName, Table& table, Document& lastRevision);
    private Document GetLastRevisionFor(DocumentsOperationContext context, Slice lowerId, Slice lowerIdPrefix, CollectionName collectionName, Table& table);
    internal void DeleteRevisionFromTable(DocumentsOperationContext context, Table table, Dictionary`2<string, Table> writeTables, Document revision, CollectionName collectionName, ChangeVector changeVector, long lastModifiedTicks, DocumentFlags flags);
    public static bool ShouldSkipForceCreated(bool skipForceCreated, DocumentFlags revisionFlags);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetRevisionsForConflict>d__47")]
private IEnumerable`1<Document> GetRevisionsForConflict(DocumentsOperationContext context, Table table, Slice prefixSlice, NonPersistentDocumentFlags nonPersistentFlags, bool skipForceCreated, long revisionCount, bool documentDeleted, DeleteOldRevisionsResult result);
    private long GetConflictRevisionsCount(DocumentsOperationContext context, Table table, Slice prefixSlice);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetAllRevisions>d__49")]
private IEnumerable`1<Document> GetAllRevisions(DocumentsOperationContext context, Table table, Slice prefixSlice, Nullable`1<long> maxDeletesUponUpdate, Func`2<Document, bool> shouldSkip, DeleteOldRevisionsResult result);
    internal static void CreateRevisionTombstoneKeySlice(DocumentsOperationContext context, string documentId, string changeVector, Slice& changeVectorSlice, Slice& keySlice, List`1<IDisposable> toDispose);
    private static IDisposable CreateRevisionTombstoneKeySlice(DocumentsOperationContext context, Slice documentIdSlice, string changeVector, Slice& changeVectorSlice, Slice& keySlice);
    public void DeleteRevision(DocumentsOperationContext context, Slice key, string collection, string changeVector, long lastModifiedTicks, Slice changeVectorSlice);
    private void CreateTombstone(DocumentsOperationContext context, Slice keySlice, long revisionEtag, CollectionName collectionName, string changeVector, long lastModifiedTicks, DocumentFlags flags);
    internal static long IncrementCountOfRevisions(DocumentsOperationContext context, Slice prefixedLowerId, long delta);
    public void Delete(DocumentsOperationContext context, string id, Slice lowerId, CollectionName collectionName, ChangeVector changeVector, long lastModifiedTicks, NonPersistentDocumentFlags nonPersistentFlags, DocumentFlags flags);
    public void Delete(DocumentsOperationContext context, string id, BlittableJsonReaderObject deleteRevisionDocument, DocumentFlags flags, NonPersistentDocumentFlags nonPersistentFlags, ChangeVector changeVector, long lastModifiedTicks);
    private void Delete(DocumentsOperationContext context, Slice lowerId, Slice idSlice, string id, CollectionName collectionName, BlittableJsonReaderObject deleteRevisionDocument, ChangeVector changeVector, long lastModifiedTicks, NonPersistentDocumentFlags nonPersistentFlags, DocumentFlags flags);
    private void MarkRevisionsAsConflictedIfNeeded(DocumentsOperationContext context, Slice lowerId, Slice idSlice, DocumentFlags flags, TableValueReader tvr, Table table, Slice changeVectorSlice);
    private void MarkRevisionAsConflicted(DocumentsOperationContext context, TableValueReader tvr, Table table, Slice changeVectorSlice, Slice lowerId, Slice idSlice);
    private void EnsureValidRevisionTable(DocumentsOperationContext context, Slice changeVectorSlice, Table& table, TableValueReader& tvr);
    private InternalScope<ByteStringMemoryCache> GetKeyPrefix(DocumentsOperationContext context, Slice lowerId, Slice& prefixSlice);
    private static InternalScope<ByteStringMemoryCache> GetKeyPrefix(DocumentsOperationContext context, Byte* lowerId, int lowerIdSize, Slice& prefixSlice);
    private static InternalScope<ByteStringMemoryCache> GetLastKey(DocumentsOperationContext context, Slice lowerId, Slice& prefixSlice);
    private static InternalScope<ByteStringMemoryCache> GetKeyWithEtag(DocumentsOperationContext context, Slice lowerId, long etag, Slice& prefixSlice);
    private static long CountOfRevisions(DocumentsOperationContext context, Slice prefix);
    public Document GetRevisionBefore(DocumentsOperationContext context, string id, DateTime max);
    private Document GetRevisionBefore(DocumentsOperationContext context, Parameters parameters, string id, RevertResult progressResult);
    public Task`1<IOperationResult> EnforceConfigurationAsync(Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    public Task`1<IOperationResult> EnforceConfigurationAsync(Action`1<IOperationProgress> onProgress, bool includeForceCreated, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<EnforceConfigurationAsync>d__70")]
public Task`1<IOperationResult> EnforceConfigurationAsync(Action`1<IOperationProgress> onProgress, bool includeForceCreated, HashSet`1<string> collections, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<AdoptOrphanedAsync>d__71")]
public Task`1<IOperationResult> AdoptOrphanedAsync(Action`1<IOperationProgress> onProgress, HashSet`1<string> collections, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<AdoptOrphanedAsync>d__72")]
public Task`1<IOperationResult> AdoptOrphanedAsync(Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    private bool CanContinueBatch(List`1<string> idsToCheck, TimeSpan elapsed, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<PerformRevisionsOperationAsync>d__74`1")]
private Task PerformRevisionsOperationAsync(Action`1<IOperationProgress> onProgress, TOperationResult result, Func`4<List`1<string>, TOperationResult, OperationCancelToken, RevisionsScanningOperationCommand`1<TOperationResult>> createCommand, HashSet`1<string> collections, OperationCancelToken token);
    private List`1<IEnumerable`1<TableValueHolder>> GetRevisionsTables(DocumentsOperationContext context, HashSet`1<string> collections, long lastScannedEtag);
    public void ForceDeleteAllRevisionsFor(DocumentsOperationContext context, string id, DocumentFlags tombstoneFlags);
    private ValueTuple`2<bool, long> ForceDeleteAllRevisionsFor(DocumentsOperationContext context, Slice lowerId, Slice prefixSlice, CollectionName collectionName, Nullable`1<long> maxDeletesUponUpdate, Func`2<Document, bool> shouldSkip, DocumentFlags tombstoneFlags);
    private ValueTuple`2<bool, long> ForceDeleteAllRevisionsFor(DocumentsOperationContext context, Slice lowerId, Slice prefixSlice, CollectionName collectionName, Func`3<Table, DeleteOldRevisionsResult, IEnumerable`1<Document>> getRevisions, DocumentFlags tombstoneFlags);
    internal long EnforceConfigurationFor(DocumentsOperationContext context, string id, bool skipForceCreated, Boolean& moreWork);
    internal bool AdoptOrphanedFor(DocumentsOperationContext context, string id, DocumentFlags additionalFlags);
    private void CreateDeletedRevision(DocumentsOperationContext context, Table table, string id, CollectionName collectionName, long lastModifiedTicks, DocumentFlags flags);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<RevertRevisions>d__84")]
public Task`1<IOperationResult> RevertRevisions(DateTime before, TimeSpan window, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    public Task RevertDocumentsToRevisionsAsync(Dictionary`2<string, string> idToChangeVector, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<RevertRevisions>d__86")]
public Task`1<IOperationResult> RevertRevisions(DateTime before, TimeSpan window, Action`1<IOperationProgress> onProgress, HashSet`1<string> collections, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<RevertRevisionsInternal>d__87")]
private Task RevertRevisionsInternal(List`1<Document> list, string collection, DateTime before, DateTime minimalDate, long etagBarrier, Action`1<IOperationProgress> onProgress, RevertResult result, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<WriteRevertedRevisions>d__88")]
private Task WriteRevertedRevisions(List`1<Document> list, OperationCancelToken token);
    private bool PrepareRevertedRevisions(DocumentsOperationContext writeCtx, Parameters parameters, RevertResult result, List`1<Document> list, string collection, OperationCancelToken token);
    private NextRevisionIdResult ShouldProcessNextRevisionId(DocumentsOperationContext context, TableValueReader& reader, Parameters parameters, OperationResult result, LazyStringValue& id);
    private void RestoreRevision(DocumentsOperationContext readCtx, DocumentsOperationContext writeCtx, Parameters parameters, LazyStringValue id, RevertResult result, List`1<Document> list);
    public long GetRevisionsCount(DocumentsOperationContext context, string id);
    public long GetRevisionsCount(DocumentsOperationContext context, Slice id);
    public ValueTuple`2<Document[], long> GetRevisions(DocumentsOperationContext context, string id, long start, long take);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetRevisions>d__98")]
private IEnumerable`1<Document> GetRevisions(DocumentsOperationContext context, Slice prefixSlice, Slice lastKey, long start, long take);
    public void GetLatestRevisionsBinEntry(DocumentsOperationContext context, String& latestChangeVector);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetRevisionsBinEntries>d__100")]
public IEnumerable`1<Document> GetRevisionsBinEntries(DocumentsOperationContext context, long skip, long take);
    private bool IsRevisionsBinEntry(DocumentsOperationContext context, Table table, Slice lowerId, long revisionsBinEntryEtag);
    public Document GetRevision(DocumentsOperationContext context, string changeVector);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetRevisionsFrom>d__103")]
public IEnumerable`1<Document> GetRevisionsFrom(DocumentsOperationContext context, long etag, long take, DocumentFields fields, EventHandler`1<InvalidOperationException> onCorruptedDataHandler);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetRevisionsFrom>d__104")]
public IEnumerable`1<Document> GetRevisionsFrom(DocumentsOperationContext context, string collection, long etag, long take, DocumentFields fields);
    public long GetLastRevisionEtag(DocumentsOperationContext context, string collection);
    private bool LastRevision(DocumentsOperationContext context, string collection, TableValueHolder& result);
    public IEnumerable`1<ValueTuple`2<Document, Document>> GetCurrentAndPreviousRevisionsForSubscriptionsFrom(DocumentsOperationContext context, long etag, long start, long take);
    public IEnumerable`1<ValueTuple`2<Document, Document>> GetCurrentAndPreviousRevisionsForSubscriptionsFrom(DocumentsOperationContext context, CollectionName collectionName, long etag, long take);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetCurrentAndPreviousRevisionsFrom>d__109")]
private IEnumerable`1<ValueTuple`2<Document, Document>> GetCurrentAndPreviousRevisionsFrom(DocumentsOperationContext context, IEnumerable`1<TableValueHolder> iterator, Table table, long take);
    internal static Document TableValueToRevision(JsonOperationContext context, TableValueReader& tvr, DocumentFields fields);
    private static Document ParseRevisionPartial(JsonOperationContext context, TableValueReader& tvr, DocumentFields fields);
    public static Document ParseRawDataSectionRevisionWithValidation(JsonOperationContext context, TableValueReader& tvr, int expectedSize, Int64& etag);
    private ExternalScope<ByteStringMemoryCache> GetResolvedSlice(DocumentsOperationContext context, DateTime date, Slice& slice);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetResolvedDocumentsSince>d__114")]
public IEnumerable`1<Document> GetResolvedDocumentsSince(DocumentsOperationContext context, DateTime since, long take);
    public long GetNumberOfRevisionDocuments(DocumentsOperationContext context);
    internal TestingStuff ForTestingPurposesOnly();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Revisions.RevisionsStorage/<GetRevisionsByBucketFrom>d__119")]
public IEnumerable`1<Document> GetRevisionsByBucketFrom(DocumentsOperationContext context, int bucket, long etag);
    [StorageIndexEntryKeyGeneratorAttribute]
internal static Scope<ByteStringMemoryCache> GenerateBucketAndEtagIndexKeyForRevisions(Transaction tx, TableValueReader& tvr, Slice& slice);
    internal static void UpdateBucketStatsForRevisions(Transaction tx, Slice key, TableValueReader& oldValue, TableValueReader& newValue);
}
public static class Raven.Server.Documents.Schemas.Attachments : object {
    internal static TableSchema AttachmentsSchemaBase;
    internal static TableSchema ShardingAttachmentsSchemaBase;
    internal static Slice AttachmentsSlice;
    internal static Slice AttachmentsMetadataSlice;
    internal static Slice AttachmentsEtagSlice;
    internal static Slice AttachmentsHashSlice;
    internal static Slice AttachmentsTombstonesSlice;
    internal static Slice AttachmentsBucketAndEtagSlice;
    internal static Slice AttachmentsBucketAndHashSlice;
    internal static string AttachmentsTombstones;
    private static Attachments();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForAttachmentsSchema|11_0(TableSchema schema);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForShardingAttachmentsSchema|11_1();
}
public static class Raven.Server.Documents.Schemas.Collections : object {
    internal static TableSchema CollectionsSchemaBase;
    internal static Slice CollectionsSlice;
    public static TableSchema Current { get; }
    private static Collections();
    public static TableSchema get_Current();
}
public static class Raven.Server.Documents.Schemas.Conflicts : object {
    internal static TableSchema ConflictsSchemaBase;
    internal static TableSchema ShardingConflictsSchemaBase;
    internal static Slice IdAndChangeVectorSlice;
    internal static Slice AllConflictedDocsEtagsSlice;
    internal static Slice ConflictsSlice;
    internal static Slice ConflictsIdSlice;
    internal static Slice ConflictsBucketAndEtagSlice;
    internal static Slice ChangeVectorSlice;
    internal static Slice ConflictedCollectionSlice;
    private static Conflicts();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForConflictsSchema|10_0(TableSchema schema);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForShardingConflictsSchemaBase|10_1();
}
public static class Raven.Server.Documents.Schemas.Counters : object {
    internal static TableSchema CountersSchemaBase;
    internal static TableSchema ShardingCountersSchemaBase;
    internal static Slice AllCountersEtagSlice;
    internal static Slice CollectionCountersEtagsSlice;
    internal static Slice CounterKeysSlice;
    internal static Slice CountersBucketAndEtagSlice;
    private static Counters();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForCountersSchema|7_0(TableSchema schema);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForShardingCountersSchemaBase|7_1();
}
public static class Raven.Server.Documents.Schemas.CounterTombstones : object {
    internal static TableSchema CounterTombstonesSchemaBase;
    internal static TableSchema ShardingCounterTombstonesSchemaBase;
    internal static Slice CounterTombstoneKey;
    internal static Slice AllCounterTombstonesEtagSlice;
    internal static Slice CollectionCounterTombstonesEtagsSlice;
    internal static Slice CounterTombstonesBucketAndEtagSlice;
    private static CounterTombstones();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForCounterTombstonesSchema|7_0(TableSchema schema);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForShardingCounterTombstonesSchemaBase|7_1();
}
public static class Raven.Server.Documents.Schemas.DeletedRanges : object {
    internal static TableSchema DeleteRangesSchemaBase;
    internal static TableSchema ShardingDeleteRangesSchemaBase;
    internal static Slice PendingDeletionSegments;
    internal static Slice DeletedRangesKey;
    internal static Slice AllDeletedRangesEtagSlice;
    internal static Slice CollectionDeletedRangesEtagsSlice;
    internal static Slice DeletedRangesBucketAndEtagSlice;
    private static DeletedRanges();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForDeletedRangesSchema|8_0(TableSchema schema);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForShardingDeletedRangesSchemaBase|8_1();
}
public static class Raven.Server.Documents.Schemas.Documents : object {
    public static Slice CollectionEtagsSlice;
    internal static Slice DocsSlice;
    internal static Slice AllDocsEtagsSlice;
    internal static Slice AllDocsBucketAndEtagSlice;
    internal static TableSchema ShardingDocsSchemaBase;
    internal static TableSchema ShardingCompressedDocsSchemaBase;
    internal static TableSchema DocsSchemaBase;
    internal static TableSchema CompressedDocsSchemaBase;
    private static Documents();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForDocsSchemaBase|9_0(TableSchema docsSchema);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForShardingDocsSchemaBase|9_1(TableSchema docsSchema);
}
public static class Raven.Server.Documents.Schemas.Notifications : object {
    public static TableSchema NotificationsSchemaBase;
    public static Slice ByCreatedAt;
    public static Slice ByPostponedUntil;
    public static string NotificationsTree;
    public static TableSchema Current { get; }
    private static Notifications();
    public static TableSchema get_Current();
}
public static class Raven.Server.Documents.Schemas.Revisions : object {
    internal static TableSchema RevisionsSchemaBase;
    internal static TableSchema CompressedRevisionsSchemaBase;
    internal static TableSchema ShardingRevisionsSchemaBase;
    internal static TableSchema ShardingCompressedRevisionsSchemaBase;
    internal static Slice IdAndEtagSlice;
    internal static Slice DeleteRevisionEtagSlice;
    internal static Slice AllRevisionsEtagsSlice;
    internal static Slice CollectionRevisionsEtagsSlice;
    internal static Slice RevisionsCountSlice;
    internal static Slice RevisionsTombstonesSlice;
    internal static Slice RevisionsPrefix;
    internal static Slice ResolvedFlagByEtagSlice;
    internal static Slice RevisionsBucketAndEtagSlice;
    internal static string RevisionsTombstones;
    private static Revisions();
    private static void DefineIndexesForRevisionsSchema(TableSchema revisionsSchema, Slice changeVectorSlice);
    private static void DefineIndexesForShardingRevisionsSchemaBase(TableSchema schema, Slice changeVectorSlice);
}
public enum Raven.Server.Documents.Schemas.TableType : Enum {
    public byte value__;
    public static TableType None;
    public static TableType Documents;
    public static TableType Revisions;
    public static TableType Conflicts;
    public static TableType LegacyCounter;
    public static TableType Counters;
    public static TableType TimeSeries;
}
public static class Raven.Server.Documents.Schemas.TimeSeries : object {
    internal static TableSchema TimeSeriesSchemaBase;
    internal static TableSchema ShardingTimeSeriesSchemaBase;
    internal static Slice AllTimeSeriesEtagSlice;
    internal static Slice CollectionTimeSeriesEtagsSlice;
    internal static Slice TimeSeriesKeysSlice;
    internal static Slice TimeSeriesBucketAndEtagSlice;
    private static TimeSeries();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForTimeSeriesSchema|7_0(TableSchema schema);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForShardingTimeSeriesSchemaBase|7_1();
}
public static class Raven.Server.Documents.Schemas.Tombstones : object {
    internal static TableSchema TombstonesSchemaBase;
    internal static TableSchema ShardingTombstonesSchema;
    internal static Slice TombstonesSlice;
    internal static Slice AllTombstonesEtagsSlice;
    internal static Slice TombstonesPrefix;
    internal static Slice DeletedEtagsSlice;
    internal static Slice TombstonesBucketAndEtagSlice;
    private static Tombstones();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForTombstonesSchema|8_0(TableSchema schema);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__DefineIndexesForShardingTombstonesSchemaBase|8_1();
}
public class Raven.Server.Documents.Sharding.Background.ShardedDocumentsMigrator : object {
    private ShardedDocumentDatabase _database;
    private CancellationToken _token;
    private Logger _logger;
    public ShardedDocumentsMigrator(ShardedDocumentDatabase database);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Background.ShardedDocumentsMigrator/<ExecuteMoveDocumentsAsync>d__4")]
internal Task ExecuteMoveDocumentsAsync();
    private bool TryFindWrongBucket(DocumentsOperationContext context, ShardingConfiguration configuration, IEnumerable`1<BucketStats> bucketStatistics, Int32& bucket);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Background.ShardedDocumentsMigrator/<MoveDocumentsToShardAsync>d__6")]
private Task MoveDocumentsToShardAsync(int bucket, int moveToShard, ShardingConfiguration configuration);
}
public class Raven.Server.Documents.Sharding.BucketStats : object {
    public int Bucket;
    public long Size;
    public long NumberOfDocuments;
    public DateTime LastModified;
    public virtual DynamicJsonValue ToJson();
}
internal class Raven.Server.Documents.Sharding.BucketStatsHolder : object {
    private Dictionary`2<int, BucketStats> _values;
    private Dictionary`2<int, ChangeVector> _mergedChangeVectors;
    private static int BucketStatsSize;
    private static BucketStatsHolder();
    public void UpdateBucket(int bucket, long nowTicks, long sizeChange, long numOfDocsChanged);
    public void UpdateBucketAndChangeVector(DocumentsOperationContext ctx, int bucket, long nowTicks, long sizeChange, long numOfDocsChanged, int changeVectorIndex, TableValueReader& value);
    public void UpdateBucketStatsTreeBeforeCommit(Transaction tx);
    public void ClearBucketStatsOnFailure(IPagerLevelTransactionState _);
    private InternalScope<ByteStringMemoryCache> MergeStats(Transaction tx, Tree tree, BucketStats inMemoryStats, Slice keySlice, int bucket, BucketStats& stats, Slice& mergedCvSlice);
}
internal class Raven.Server.Documents.Sharding.Changes.DatabaseChangesForShard : DatabaseChanges {
    public DatabaseChangesForShard(ServerStore server, RequestExecutor requestExecutor, string databaseName, Action onDispose, string nodeTag);
}
public interface Raven.Server.Documents.Sharding.Changes.IAggressiveCacheChanges`1 {
    public abstract virtual IChangesObservable`1<TChange> ForAggressiveCaching();
}
public interface Raven.Server.Documents.Sharding.Changes.IShardedDatabaseChanges {
}
public class Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection : AbstractChangesClientConnection`1<TransactionOperationContext> {
    private ConcurrentDictionary`2<string, IDisposable> _matchingDocuments;
    private ConcurrentDictionary`2<string, IDisposable> _matchingIndexes;
    private ConcurrentDictionary`2<string, IDisposable> _matchingDocumentPrefixes;
    private ConcurrentDictionary`2<string, IDisposable> _matchingDocumentsInCollection;
    private ConcurrentDictionary`2<string, IDisposable> _matchingCounters;
    private ConcurrentDictionary`2<string, IDisposable> _matchingDocumentCounters;
    private ConcurrentDictionary`2<DocumentIdAndNamePair<TransactionOperationContext>, IDisposable> _matchingDocumentCounter;
    private ConcurrentDictionary`2<string, IDisposable> _matchingTimeSeries;
    private ConcurrentDictionary`2<string, IDisposable> _matchingAllDocumentTimeSeries;
    private ConcurrentDictionary`2<DocumentIdAndNamePair<TransactionOperationContext>, IDisposable> _matchingDocumentTimeSeries;
    private int _watchAllDocuments;
    private IDisposable _watchAllDocumentsUnsubscribe;
    private int _watchAllCounters;
    private IDisposable _watchAllCountersUnsubscribe;
    private int _watchAllTimeSeries;
    private IDisposable _watchAllTimeSeriesUnsubscribe;
    private int _watchAllIndexes;
    private IDisposable _watchAllIndexesUnsubscribe;
    private int _watchAggressiveCaching;
    private IDisposable _watchAggressiveCachingUnsubscribe;
    private ShardedDatabaseContext _context;
    private bool _throttleConnection;
    private Dictionary`2<int, ShardedDatabaseChanges> _changes;
    private IDisposable _releaseQueueContext;
    private JsonOperationContext _queueContext;
    private object _queueContextUsageLocker;
    public ShardedChangesClientConnection(WebSocket webSocket, ServerStore serverStore, ShardedDatabaseContext context, bool throttleConnection, bool fromStudio);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<EnsureConnectedAsync>d__26")]
private ValueTask EnsureConnectedAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchDocumentAsync>d__27")]
protected virtual ValueTask WatchDocumentAsync(string docId, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentAsync(string docId, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchAllDocumentsAsync>d__29")]
protected virtual ValueTask WatchAllDocumentsAsync(CancellationToken token);
    protected virtual ValueTask UnwatchAllDocumentsAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchCounterAsync>d__31")]
protected virtual ValueTask WatchCounterAsync(string name, CancellationToken token);
    protected virtual ValueTask UnwatchCounterAsync(string name, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchDocumentCountersAsync>d__33")]
protected virtual ValueTask WatchDocumentCountersAsync(string docId, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentCountersAsync(string docId, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchDocumentCounterAsync>d__35")]
protected virtual ValueTask WatchDocumentCounterAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentCounterAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchAllCountersAsync>d__37")]
protected virtual ValueTask WatchAllCountersAsync(CancellationToken token);
    protected virtual ValueTask UnwatchAllCountersAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchTimeSeriesAsync>d__39")]
protected virtual ValueTask WatchTimeSeriesAsync(string name, CancellationToken token);
    protected virtual ValueTask UnwatchTimeSeriesAsync(string name, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchAllDocumentTimeSeriesAsync>d__41")]
protected virtual ValueTask WatchAllDocumentTimeSeriesAsync(string docId, CancellationToken token);
    protected virtual ValueTask UnwatchAllDocumentTimeSeriesAsync(string docId, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchDocumentTimeSeriesAsync>d__43")]
protected virtual ValueTask WatchDocumentTimeSeriesAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentTimeSeriesAsync(BlittableJsonReaderArray parameters, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchAllTimeSeriesAsync>d__45")]
protected virtual ValueTask WatchAllTimeSeriesAsync(CancellationToken token);
    protected virtual ValueTask UnwatchAllTimeSeriesAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchDocumentPrefixAsync>d__47")]
protected virtual ValueTask WatchDocumentPrefixAsync(string name, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentPrefixAsync(string name, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchDocumentInCollectionAsync>d__49")]
protected virtual ValueTask WatchDocumentInCollectionAsync(string name, CancellationToken token);
    protected virtual ValueTask UnwatchDocumentInCollectionAsync(string name, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchAllIndexesAsync>d__51")]
protected virtual ValueTask WatchAllIndexesAsync(CancellationToken token);
    protected virtual ValueTask UnwatchAllIndexesAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchIndexAsync>d__53")]
protected virtual ValueTask WatchIndexAsync(string name, CancellationToken token);
    protected virtual ValueTask UnwatchIndexAsync(string name, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchAggressiveCachingAsync>d__55")]
protected virtual ValueTask WatchAggressiveCachingAsync(CancellationToken token);
    protected virtual ValueTask UnwatchAggressiveCachingAsync(CancellationToken token);
    public virtual DynamicJsonValue GetDebugInfo();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(BlittableJsonReaderObject value);
    protected virtual Message<TransactionOperationContext> CreateMessage(object message);
    private void OnDispose(object m);
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<WatchInternalAsync>d__65")]
private Task`1<IDisposable> WatchInternalAsync(Func`2<ShardedDatabaseChanges, IChangesObservable`1<BlittableJsonReaderObject>> factory, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedChangesClientConnection/<UnwatchInternalAsync>d__66`1")]
private ValueTask UnwatchInternalAsync(TKey key, ConcurrentDictionary`2<TKey, IDisposable> subscriptions, CancellationToken token);
    private static void UnwatchInternal(Int32& watch, IDisposable unsubscribe);
}
internal class Raven.Server.Documents.Sharding.Changes.ShardedDatabaseChanges : AbstractDatabaseChanges`1<ShardedDatabaseConnectionState> {
    private ShardedChangesClientConnection _shardedChangesClientConnection;
    public ShardedDatabaseChanges(ShardedChangesClientConnection shardedChangesClientConnection, ServerStore server, RequestExecutor requestExecutor, string databaseName, Action onDispose, string nodeTag, bool throttleConnection);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Changes.ShardedDatabaseChanges/<EnsureConnectedNow>d__2")]
public sealed virtual Task`1<IShardedDatabaseChanges> EnsureConnectedNow();
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForDocument(string docId);
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForAllDocuments();
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForDocumentsStartingWith(string docIdPrefix);
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForDocumentsInCollection(string collectionName);
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForDocumentsInCollection();
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForAllCounters();
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForCounter(string counterName);
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForCounterOfDocument(string documentId, string counterName);
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForCountersOfDocument(string documentId);
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForIndex(string indexName);
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForAllIndexes();
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForAllTimeSeries();
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForTimeSeries(string timeSeriesName);
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForTimeSeriesOfDocument(string documentId, string timeSeriesName);
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForTimeSeriesOfDocument(string documentId);
    public sealed virtual IChangesObservable`1<BlittableJsonReaderObject> ForAggressiveCaching();
    protected virtual ShardedDatabaseConnectionState CreateDatabaseConnectionState(Func`1<Task> onConnect, Func`1<Task> onDisconnect);
    protected virtual void ProcessNotification(string type, BlittableJsonReaderObject change);
}
internal class Raven.Server.Documents.Sharding.Changes.ShardedDatabaseConnectionState : AbstractDatabaseConnectionState {
    [CompilerGeneratedAttribute]
private Action`1<BlittableJsonReaderObject> _onChangeNotification;
    public ShardedDatabaseConnectionState(Func`1<Task> onConnect, Func`1<Task> onDisconnect);
    [CompilerGeneratedAttribute]
private void add__onChangeNotification(Action`1<BlittableJsonReaderObject> value);
    [CompilerGeneratedAttribute]
private void remove__onChangeNotification(Action`1<BlittableJsonReaderObject> value);
    public void Send(BlittableJsonReaderObject change);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Sparrow.Json.BlittableJsonReaderObject>.add_OnChangeNotification(Action`1<BlittableJsonReaderObject> value);
    private sealed virtual override void Raven.Client.Documents.Changes.IChangesConnectionState<Sparrow.Json.BlittableJsonReaderObject>.remove_OnChangeNotification(Action`1<BlittableJsonReaderObject> value);
}
public class Raven.Server.Documents.Sharding.Commands.Querying.ShardedQueryCommand : AbstractQueryCommand`2<QueryResult, BlittableJsonReaderObject> {
    private IndexQueryServerSide _indexQuery;
    private DocumentConventions _conventions;
    private BlittableJsonReaderObject _query;
    public QueryTimingsScope Scope;
    private string IndexName;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <RawResult>k__BackingField;
    public string RaftUniqueRequestId { get; }
    internal BlittableJsonReaderObject RawResult { get; internal set; }
    public ShardedQueryCommand(DocumentConventions conventions, BlittableJsonReaderObject query, IndexQueryServerSide indexQuery, QueryTimingsScope scope, bool metadataOnly, bool indexEntriesOnly, bool ignoreLimit, string indexName, bool canReadFromCache, string raftUniqueRequestId, TimeSpan globalHttpClientTimeout);
    [CompilerGeneratedAttribute]
public string get_RaftUniqueRequestId();
    [CompilerGeneratedAttribute]
internal BlittableJsonReaderObject get_RawResult();
    [CompilerGeneratedAttribute]
internal void set_RawResult(BlittableJsonReaderObject value);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    protected virtual ulong GetQueryHash(JsonOperationContext ctx);
    protected virtual HttpContent GetContent(JsonOperationContext ctx);
}
[IsReadOnlyAttribute]
internal class Raven.Server.Documents.Sharding.Commands.ShardedImportOperation : ValueType {
    private Dictionary`2<int, StreamDestinationHolder> _holders;
    private long _operationId;
    private DatabaseSmugglerOptionsServerSide _options;
    public Dictionary`2<int, Task`1<Stream>> ExposedStreamTasks;
    [CompilerGeneratedAttribute]
private HttpRequest <HttpRequest>k__BackingField;
    public HttpRequest HttpRequest { get; }
    public ShardedImportOperation(HttpRequest httpRequest, DatabaseSmugglerOptionsServerSide options, Dictionary`2<int, StreamDestinationHolder> holders, long operationId);
    [CompilerGeneratedAttribute]
public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual BlittableJsonReaderObject Combine(Dictionary`2<int, ShardExecutionResult`1<BlittableJsonReaderObject>> results);
    public sealed virtual RavenCommand`1<BlittableJsonReaderObject> CreateCommandForShard(int shardNumber);
}
public class Raven.Server.Documents.Sharding.Commands.ShardedSingleNodeBatchCommand : RavenCommand`1<BlittableJsonReaderObject> {
    private DocumentConventions _conventions;
    public int ShardNumber;
    private IndexBatchOptions _indexBatchOptions;
    private ReplicationBatchOptions _replicationBatchOptions;
    public List`1<SingleShardedCommand> Commands;
    public List`1<int> PositionInResponse;
    private List`1<Stream> _attachmentStreams;
    private HashSet`1<Stream> _uniqueAttachmentStreams;
    public bool IsReadRequest { get; }
    public ShardedSingleNodeBatchCommand(DocumentConventions conventions, int shardNumber, IndexBatchOptions indexBatchOptions, ReplicationBatchOptions replicationBatchOptions);
    public void AddCommand(SingleShardedCommand command);
    public void AssembleShardedReply(JsonOperationContext context, Object[] reply, Nullable`1<int> shardNumber);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
    public void Dispose();
}
public class Raven.Server.Documents.Sharding.Comparers.ConstantComparer : object {
    public static ConstantComparer Instance;
    private static ConstantComparer();
    public sealed virtual int Compare(BlittableJsonReaderObject x, BlittableJsonReaderObject y);
}
public class Raven.Server.Documents.Sharding.Comparers.DocumentLastModifiedComparer : object {
    public static DocumentLastModifiedComparer Throwing;
    public static DocumentLastModifiedComparer NotThrowing;
    private bool _throwIfCannotExtract;
    private DocumentLastModifiedComparer(bool throwIfCannotExtract);
    private static DocumentLastModifiedComparer();
    public sealed virtual int Compare(BlittableJsonReaderObject x, BlittableJsonReaderObject y);
    [CompilerGeneratedAttribute]
internal static bool <Compare>g__TryGetLastModified|4_0(BlittableJsonReaderObject json, DateTime& lastModified);
    [CompilerGeneratedAttribute]
internal static void <Compare>g__ThrowInvalidMissingLastModified|4_1();
}
public class Raven.Server.Documents.Sharding.Comparers.DocumentsComparer : object {
    private OrderByField[] _orderByFields;
    private bool _extractFromData;
    private Random[] _randoms;
    public DocumentsComparer(OrderByField[] orderByFields, bool extractFromData, bool hasOrderByRandom);
    private Random[] GetRandom(OrderByField[] orderByFields);
    public sealed virtual int Compare(BlittableJsonReaderObject x, BlittableJsonReaderObject y);
    private int CompareField(OrderByField& order, int index, BlittableJsonReaderObject x, BlittableJsonReaderObject y);
    private string GetString(BlittableJsonReaderObject blittable, string fieldName, int index);
    private bool TryGetLongValue(BlittableJsonReaderObject blittable, string fieldName, int index, Int64& value);
    private bool TryGetDoubleValue(BlittableJsonReaderObject blittable, string fieldName, int index, Double& value);
    [DoesNotReturnAttribute]
private static void ThrowIfCannotFindMetadata(BlittableJsonReaderObject blittable);
    [DoesNotReturnAttribute]
private static void ThrowIfCannotFindOrderByFields(BlittableJsonReaderObject metadata);
    [DoesNotReturnAttribute]
private static void ThrowIfNotExpectedType(string expectedType, object actualValue);
}
public abstract class Raven.Server.Documents.Sharding.Executors.AbstractExecutor : object {
    protected ServerStore ServerStore;
    protected AbstractExecutor(ServerStore store);
    public void ForgetAbout();
    public abstract virtual RequestExecutor GetRequestExecutorAt(int position);
    protected abstract virtual Memory`1<int> GetAllPositions();
    protected abstract virtual void OnCertificateChange(object sender, EventArgs e);
    public Task`1<TCombinedResult> ExecuteParallelForAllAsync(IShardedOperation`2<TResult, TCombinedResult> operation, CancellationToken token);
    public Task`1<TCombinedResult> ExecuteParallelForAllThrowAggregatedFailure(IShardedOperation`2<TResult, TCombinedResult> operation, CancellationToken token);
    public Task`1<TResult> ExecuteParallelForAllAsync(IShardedOperation`1<TResult> operation, CancellationToken token);
    protected Task`1<TResult> ExecuteForShardsAsync(Memory`1<int> shards, IShardedOperation`2<TResult, TResult> operation, CancellationToken token);
    public Task ExecuteParallelForShardsAsync(Memory`1<int> shards, IShardedOperation operation, CancellationToken token);
    public Task`1<TResult> ExecuteParallelForShardsAsync(Memory`1<int> shards, IShardedOperation`1<TResult> operation, CancellationToken token);
    public Task`1<TCombinedResult> ExecuteParallelForShardsAsync(Memory`1<int> shards, IShardedOperation`2<TResult, TCombinedResult> operation, CancellationToken token);
    public Task`1<TCombinedResult> ExecuteParallelAndIgnoreErrorsForShardsAsync(Memory`1<int> shards, IShardedOperation`2<TResult, TCombinedResult> operation, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Executors.AbstractExecutor/<ExecuteForShardsAsync>d__14`4")]
protected Task`1<TCombinedResult> ExecuteForShardsAsync(Memory`1<int> shards, IShardedOperation`2<TResult, TCombinedResult> operation, CancellationToken token);
    private static TCombinedResult BuildResults(IShardedOperation`2<TResult, TCombinedResult> operation, Dictionary`2<int, ShardExecutionResult`1<TResult>> commands);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Executors.AbstractExecutor/<ExecuteAsync>d__16`4")]
private Task ExecuteAsync(Memory`1<int> shards, IShardedOperation`2<TResult, TCombinedResult> operation, Dictionary`2<int, ShardExecutionResult`1<TResult>> commands, CancellationToken token);
    protected static void SafelyDisposeExecutors(IEnumerable`1<RequestExecutor> executors);
    protected static void SafelyDisposeExecutors(IEnumerable`1<Lazy`1<RequestExecutor>> executors);
    public virtual void Dispose();
    protected virtual override void Finalize();
}
public class Raven.Server.Documents.Sharding.Executors.AllOrchestratorNodesExecutor : AbstractExecutor {
    private ServerStore _store;
    private DatabaseRecord _record;
    private ClusterTopology _clusterTopology;
    private Dictionary`2<string, RequestExecutor> _current;
    private AllNodesExecutorState _state;
    public AllOrchestratorNodesExecutor(ServerStore store, DatabaseRecord record);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Executors.AllOrchestratorNodesExecutor/<ExecuteForNodeAsync>d__6`1")]
public Task`1<TResult> ExecuteForNodeAsync(RavenCommand`1<TResult> command, string nodeTag, CancellationToken token);
    public bool TryGetRequestExecutorForNode(string nodeTag, RequestExecutor& requestExecutor);
    public RequestExecutor GetRequestExecutorForNode(string nodeTag);
    private void UpdateExecutors(ClusterTopology clusterTopology, OrchestratorTopology orchestrator);
    public virtual void Dispose();
    public virtual RequestExecutor GetRequestExecutorAt(int position);
    protected virtual Memory`1<int> GetAllPositions();
    protected virtual void OnCertificateChange(object sender, EventArgs e);
}
public interface Raven.Server.Documents.Sharding.Executors.IExecutionMode {
}
public interface Raven.Server.Documents.Sharding.Executors.IFailureMode {
}
public class Raven.Server.Documents.Sharding.Executors.IgnoreFailure : ValueType {
}
public class Raven.Server.Documents.Sharding.Executors.OneByOneExecution : ValueType {
}
public class Raven.Server.Documents.Sharding.Executors.ParallelExecution : ValueType {
}
public class Raven.Server.Documents.Sharding.Executors.ShardExecutionResult`1 : object {
    public int ShardNumber;
    public RavenCommand`1<T> Command;
    public T Result;
    public Task CommandTask;
    public IDisposable ContextReleaser;
}
public class Raven.Server.Documents.Sharding.Executors.ShardExecutor : AbstractExecutor {
    private DatabaseRecord _databaseRecord;
    private string _databaseName;
    private Dictionary`2<int, Lazy`1<RequestExecutor>> _requestExecutors;
    private Int32[] _fullRange;
    public DocumentConventions Conventions;
    public ShardExecutor(ServerStore store, DatabaseRecord databaseRecord, string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Executors.ShardExecutor/<ExecuteSingleShardAsync>d__6`1")]
public Task`1<TResult> ExecuteSingleShardAsync(RavenCommand`1<TResult> command, int shardNumber, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Executors.ShardExecutor/<ExecuteSingleShardAsync>d__7`1")]
public Task`1<TResult> ExecuteSingleShardAsync(JsonOperationContext context, RavenCommand`1<TResult> command, int shardNumber, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Executors.ShardExecutor/<ExecuteSingleShardAsync>d__8")]
public Task ExecuteSingleShardAsync(RavenCommand command, int shardNumber, CancellationToken token);
    public Lazy`1<RequestExecutor> GetRequestExecutorAtLazily(int shardNumber);
    public virtual RequestExecutor GetRequestExecutorAt(int shardNumber);
    protected virtual Memory`1<int> GetAllPositions();
    protected virtual void OnCertificateChange(object sender, EventArgs e);
    private Dictionary`2<int, Lazy`1<RequestExecutor>> CreateExecutors();
    public virtual void Dispose();
}
public class Raven.Server.Documents.Sharding.Executors.ThrowAggregatedFailure : ValueType {
}
public class Raven.Server.Documents.Sharding.Executors.ThrowOnFirstFailure : ValueType {
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Analyzers.ShardedAdminAnalyzersHandlerProcessorForDelete : AbstractAdminAnalyzersHandlerProcessorForDelete`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminAnalyzersHandlerProcessorForDelete(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Analyzers.ShardedAdminAnalyzersHandlerProcessorForPut : AbstractAdminAnalyzersHandlerProcessorForPut`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminAnalyzersHandlerProcessorForPut(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Configuration.ShardedAdminConfigurationHandlerProcessorForGetDatabaseRecord : AbstractHandlerDatabaseProcessorForGetDatabaseRecord`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminConfigurationHandlerProcessorForGetDatabaseRecord(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Configuration.ShardedAdminConfigurationHandlerProcessorForGetSettings : AbstractAdminConfigurationHandlerProcessorForGetSettings`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminConfigurationHandlerProcessorForGetSettings(ShardedDatabaseRequestHandler requestHandler);
    protected virtual RavenConfiguration GetDatabaseConfiguration();
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Configuration.ShardedAdminConfigurationHandlerProcessorForPutClientConfiguration : AbstractAdminConfigurationHandlerProcessorForPutClientConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminConfigurationHandlerProcessorForPutClientConfiguration(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Configuration.ShardedAdminConfigurationHandlerProcessorForPutClientConfiguration/<WaitForIndexNotificationAsync>d__1")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Configuration.ShardedAdminConfigurationHandlerProcessorForPutSettings : AbstractAdminConfigurationHandlerProcessorForPutSettings`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminConfigurationHandlerProcessorForPutSettings(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Configuration.ShardedAdminConfigurationHandlerProcessorForPutSettings/<WaitForIndexNotificationAsync>d__1")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Configuration.ShardedAdminConfigurationHandlerProcessorForPutStudioConfiguration : AbstractAdminConfigurationHandlerProcessorForPutStudioConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminConfigurationHandlerProcessorForPutStudioConfiguration(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Configuration.ShardedAdminConfigurationHandlerProcessorForPutStudioConfiguration/<WaitForIndexNotificationAsync>d__1")]
protected virtual ValueTask WaitForIndexNotificationAsync(long index);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Indexes.ShardedAdminIndexHandlerProcessorForJavaScriptPut : AbstractAdminIndexHandlerProcessorForJavaScriptPut`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminIndexHandlerProcessorForJavaScriptPut(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexCreateController GetIndexCreateProcessor();
    protected virtual RavenConfiguration GetDatabaseConfiguration();
    protected virtual ValueTask HandleIndexesFromLegacyReplicationAsync();
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Indexes.ShardedAdminIndexHandlerProcessorForStart : AbstractAdminIndexHandlerProcessorForStart`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedAdminIndexHandlerProcessorForStart(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Indexes.ShardedAdminIndexHandlerProcessorForState : AbstractAdminIndexHandlerProcessorForState`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedAdminIndexHandlerProcessorForState(IndexState state, ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
    protected virtual AbstractIndexStateController GetIndexStateProcessor();
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Indexes.ShardedAdminIndexHandlerProcessorForStaticPut : AbstractAdminIndexHandlerProcessorForStaticPut`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminIndexHandlerProcessorForStaticPut(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexCreateController GetIndexCreateProcessor();
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Indexes.ShardedAdminIndexHandlerProcessorForStop : AbstractAdminIndexHandlerProcessorForStop`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedAdminIndexHandlerProcessorForStop(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Revisions.ShardedAdminRevisionsHandlerProcessorForAdoptOrphanedRevisions : ShardedAdminRevisionsHandlerProcessorForRevisionsOperation`2<Parameters, AdoptOrphanedRevisionsResult> {
    public string Description { get; }
    public ShardedAdminRevisionsHandlerProcessorForAdoptOrphanedRevisions(ShardedDatabaseRequestHandler requestHandler);
    public virtual string get_Description();
    protected virtual Parameters GetOperationParameters(BlittableJsonReaderObject json);
    protected virtual RavenCommand`1<OperationIdResult> GetCommand(JsonOperationContext context, int shardNumber, Parameters parameters);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Revisions.ShardedAdminRevisionsHandlerProcessorForDeleteRevisions : AbstractAdminRevisionsHandlerProcessorForDeleteRevisions`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminRevisionsHandlerProcessorForDeleteRevisions(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Revisions.ShardedAdminRevisionsHandlerProcessorForDeleteRevisions/<DeleteRevisionsAsync>d__1")]
protected virtual Task`1<long> DeleteRevisionsAsync(Parameters parameters, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Revisions.ShardedAdminRevisionsHandlerProcessorForEnforceRevisionsConfiguration : ShardedAdminRevisionsHandlerProcessorForRevisionsOperation`2<Parameters, EnforceConfigurationResult> {
    public string Description { get; }
    public ShardedAdminRevisionsHandlerProcessorForEnforceRevisionsConfiguration(ShardedDatabaseRequestHandler requestHandler);
    public virtual string get_Description();
    protected virtual Parameters GetOperationParameters(BlittableJsonReaderObject json);
    protected virtual RavenCommand`1<OperationIdResult> GetCommand(JsonOperationContext context, int shardNumber, Parameters parameters);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Revisions.ShardedAdminRevisionsHandlerProcessorForPostRevisionsConflictsConfiguration : AbstractAdminRevisionsHandlerProcessorForPostRevisionsConflictsConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminRevisionsHandlerProcessorForPostRevisionsConflictsConfiguration(ShardedDatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Revisions.ShardedAdminRevisionsHandlerProcessorForRevisionsOperation`2 : AbstractAdminRevisionsHandlerProcessorForRevisionsOperation`3<ShardedDatabaseRequestHandler, TransactionOperationContext, TOperationParameters> {
    public ShardedAdminRevisionsHandlerProcessorForRevisionsOperation`2(ShardedDatabaseRequestHandler requestHandler, OperationType operationType);
    protected virtual long GetNextOperationId();
    protected abstract virtual RavenCommand`1<OperationIdResult> GetCommand(JsonOperationContext context, int shardNumber, TOperationParameters parameters);
    protected virtual void ScheduleEnforceConfigurationOperation(long operationId, TOperationParameters parameters, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.TimeSeries.ShardedAdminTimeSeriesHandlerProcessorForDeleteTimeSeriesPolicy : AbstractAdminTimeSeriesHandlerProcessorForDeleteTimeSeriesPolicy`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminTimeSeriesHandlerProcessorForDeleteTimeSeriesPolicy(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.TimeSeries.ShardedAdminTimeSeriesHandlerProcessorForPutTimeSeriesPolicy : AbstractAdminTimeSeriesHandlerProcessorForPutTimeSeriesPolicy`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAdminTimeSeriesHandlerProcessorForPutTimeSeriesPolicy(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Tombstones.ShardedAdminTombstoneHandlerProcessorForCleanup : AbstractAdminTombstoneHandlerProcessorForCleanup`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedAdminTombstoneHandlerProcessorForCleanup(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<Response> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.Processors.Tombstones.ShardedAdminTombstoneHandlerProcessorForState : AbstractAdminTombstoneHandlerProcessorForState`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedAdminTombstoneHandlerProcessorForState(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<Response> command, OperationCancelToken token);
}
public class Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminAnalyzersHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminAnalyzersHandler/<Put>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/analyzers", "PUT")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminAnalyzersHandler/<Delete>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/analyzers", "DELETE")]
public Task Delete();
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminConfigurationHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminConfigurationHandler/<GetSettings>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/configuration/settings", "GET")]
public Task GetSettings();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminConfigurationHandler/<GetDatabaseRecord>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/record", "GET")]
public Task GetDatabaseRecord();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminConfigurationHandler/<PutSettings>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/configuration/settings", "PUT")]
public Task PutSettings();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminConfigurationHandler/<GetStudioConfiguration>d__3")]
[RavenShardedActionAttribute("/databases/*/admin/configuration/studio", "PUT")]
public Task GetStudioConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminConfigurationHandler/<PutClientConfiguration>d__4")]
[RavenShardedActionAttribute("/databases/*/admin/configuration/client", "PUT")]
public Task PutClientConfiguration();
}
public class Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminIndexHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminIndexHandler/<Put>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/indexes", "PUT")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminIndexHandler/<PutJavaScript>d__1")]
[RavenShardedActionAttribute("/databases/*/indexes", "PUT")]
public Task PutJavaScript();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminIndexHandler/<TestIndex>d__2")]
[RavenShardedActionAttribute("/databases/*/indexes/test", "POST")]
public Task TestIndex();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminIndexHandler/<Stop>d__3")]
[RavenShardedActionAttribute("/databases/*/admin/indexes/stop", "POST")]
public Task Stop();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminIndexHandler/<Start>d__4")]
[RavenShardedActionAttribute("/databases/*/admin/indexes/start", "POST")]
public Task Start();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminIndexHandler/<Enable>d__5")]
[RavenShardedActionAttribute("/databases/*/admin/indexes/enable", "POST")]
public Task Enable();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminIndexHandler/<Disable>d__6")]
[RavenShardedActionAttribute("/databases/*/admin/indexes/disable", "POST")]
public Task Disable();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminIndexHandler/<Dump>d__7")]
[RavenShardedActionAttribute("/databases/*/admin/indexes/dump", "POST")]
public Task Dump();
}
internal class Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminRevisionsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminRevisionsHandler/<DeleteRevisionsFor>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/revisions", "DELETE")]
public Task DeleteRevisionsFor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminRevisionsHandler/<ConfigConflictedRevisions>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/revisions/conflicts/config", "POST")]
public Task ConfigConflictedRevisions();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminRevisionsHandler/<EnforceConfigRevisions>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/revisions/config/enforce", "POST")]
public Task EnforceConfigRevisions();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminRevisionsHandler/<AdoptOrphans>d__3")]
[RavenShardedActionAttribute("/databases/*/admin/revisions/orphaned/adopt", "POST")]
public Task AdoptOrphans();
}
public class Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminShardingHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminShardingHandler/<ExecuteMoveDocuments>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/sharding/resharding/cleanup", "POST")]
public Task ExecuteMoveDocuments();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminShardingHandler/<AddPrefixedShardingSetting>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/sharding/prefixed", "PUT")]
public Task AddPrefixedShardingSetting();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminShardingHandler/<DeletePrefixedShardingSetting>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/sharding/prefixed", "DELETE")]
public Task DeletePrefixedShardingSetting();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminShardingHandler/<UpdatePrefixedShardingSetting>d__3")]
[RavenShardedActionAttribute("/databases/*/admin/sharding/prefixed", "POST")]
public Task UpdatePrefixedShardingSetting();
    private static void AssertValidShardsDistribution(PrefixedShardingSetting oldSetting, PrefixedShardingSetting updatedSetting, ShardingConfiguration configuration);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminShardingHandler/<AssertNoDocumentsStartingWithAsync>d__5")]
private Task`1<bool> AssertNoDocumentsStartingWithAsync(JsonOperationContext context, string prefix, String[] urls, string database);
}
public class Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminSortersHandler : ShardedDatabaseRequestHandler {
    [RavenShardedActionAttribute("/databases/*/admin/sorters", "PUT")]
public Task Put();
    [RavenShardedActionAttribute("/databases/*/admin/sorters", "DELETE")]
public Task Delete();
}
public class Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminTombstoneHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminTombstoneHandler/<Cleanup>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/tombstones/cleanup", "POST")]
public Task Cleanup();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Admin.ShardedAdminTombstoneHandler/<State>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/tombstones/state", "GET")]
public Task State();
}
public class Raven.Server.Documents.Sharding.Handlers.Batches.BatchPatchSingleShardedCommand : SingleShardedCommand {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<string, string>> List;
    public BufferedCommand BufferedCommand;
    [PreserveBaseOverridesAttribute]
[IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Batches.BatchPatchSingleShardedCommand/<Retry>d__2")]
public virtual override IEnumerable`1<BatchPatchSingleShardedCommand> Retry(ShardedDatabaseContext databaseContext, TransactionOperationContext context);
}
public class Raven.Server.Documents.Sharding.Handlers.Batches.BufferedCommand : object {
    public MemoryStream CommandStream;
    public bool IsIdentity;
    public bool IsServerSideIdentity;
    public bool IsNullOrEmptyId;
    public bool IsBatchPatch;
    public int IdStartPosition;
    public int ChangeVectorPosition;
    public int IdLength;
    public bool AddQuotes;
    public bool ModifyIdentityStreamRequired { get; }
    public bool get_ModifyIdentityStreamRequired();
    public MemoryStream ModifyIdentityStream(CommandData cmd);
    public MemoryStream ModifyBatchPatchStream(List`1<ValueTuple`2<string, string>> list);
}
public class Raven.Server.Documents.Sharding.Handlers.Batches.BufferedCommandCopier : BatchCommandStreamCopier {
    private BufferedCommand _bufferedCommand;
    public IDisposable UseCommand(BufferedCommand command);
    public virtual void OnId(UnmanagedJsonParser parser, int idLength, bool isNull);
    public virtual void OnIdsStart(UnmanagedJsonParser parser);
    public virtual void OnIdsEnd(UnmanagedJsonParser parser);
    public virtual void OnNullChangeVector(UnmanagedJsonParser parser);
}
public class Raven.Server.Documents.Sharding.Handlers.Batches.ShardedBatchCommand : object {
    private TransactionOperationContext _context;
    private ShardedDatabaseContext _databaseContext;
    private Dictionary`2<int, ShardedSingleNodeBatchCommand> _batchPerShard;
    private Object[] _result;
    public List`1<BufferedCommand> BufferedCommands;
    public ArraySegment`1<CommandData> ParsedCommands;
    public List`1<Stream> AttachmentStreams;
    [CompilerGeneratedAttribute]
private bool <IncludeReply>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ModifiedCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastTombstoneEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClusterTransaction>k__BackingField;
    public DynamicJsonArray Result { get; }
    public bool IncludeReply { get; public set; }
    public HashSet`1<string> ModifiedCollections { get; public set; }
    public string LastChangeVector { get; public set; }
    public long LastTombstoneEtag { get; public set; }
    public bool IsClusterTransaction { get; public set; }
    internal ShardedBatchCommand(TransactionOperationContext context, ShardedDatabaseContext databaseContext);
    public DynamicJsonArray get_Result();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeReply();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeReply(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<string> get_ModifiedCollections();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ModifiedCollections(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LastChangeVector();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastChangeVector(string value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_LastTombstoneEtag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastTombstoneEtag(long value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsClusterTransaction();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsClusterTransaction(bool value);
    public Dictionary`2<int, ShardedSingleNodeBatchCommand> GetCommands(ShardedBatchBehavior behavior, IndexBatchOptions indexBatchOptions, ReplicationBatchOptions replicationBatchOptions);
    public void MarkShardAsComplete(JsonOperationContext context, int shardNumber, bool isFromStudio);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Batches.ShardedBatchCommand/<GetRetryCommands>d__32")]
private IEnumerator`1<SingleShardedCommand> GetRetryCommands();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Batches.ShardedBatchCommand/<GetNewCommands>d__33")]
private IEnumerator`1<SingleShardedCommand> GetNewCommands(ShardedBatchBehavior behavior);
    private void ModifyId(CommandData& cmd, bool isServerSideIdentity);
    private ValueTuple`2<int, int> GetShardNumberForCommandType(CommandData cmd, bool isServerSideIdentity, String& documentId);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static void <GetNewCommands>g__AssertBehavior|33_0(ShardedBatchBehavior behavior, CommandType commandType, String& previousDocumentId, Nullable`1& previousBucket, int bucket, string documentId);
}
public class Raven.Server.Documents.Sharding.Handlers.Batches.ShardedBatchCommandsReader : AbstractBatchCommandsReader`2<ShardedBatchCommand, TransactionOperationContext> {
    public List`1<Stream> Streams;
    public List`1<BufferedCommand> BufferedCommands;
    private ShardedDatabaseContext _databaseContext;
    private BufferedCommandCopier _bufferedCommandCopier;
    private Lazy`1<StreamsTempFile> _streamsTempFile;
    public ShardedBatchCommandsReader(ShardedDatabaseRequestHandler handler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Batches.ShardedBatchCommandsReader/<SaveStreamAsync>d__6")]
public virtual ValueTask SaveStreamAsync(JsonOperationContext context, Stream input, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Batches.ShardedBatchCommandsReader/<ReadCommandAsync>d__7")]
public virtual Task`1<CommandData> ReadCommandAsync(JsonOperationContext ctx, Stream stream, JsonParserState state, UnmanagedJsonParser parser, MemoryBuffer buffer, BlittableMetadataModifier modifier, CancellationToken token);
    private static void ValidateSupportedCommand(CommandData command);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Batches.ShardedBatchCommandsReader/<GetCommandAsync>d__9")]
public virtual ValueTask`1<ShardedBatchCommand> GetCommandAsync(TransactionOperationContext context);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private StreamsTempFile <.ctor>b__5_0();
}
public class Raven.Server.Documents.Sharding.Handlers.Batches.ShardedBatchHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Batches.ShardedBatchHandler/<BulkDocs>d__0")]
[RavenShardedActionAttribute("/databases/*/bulk_docs", "POST")]
public Task BulkDocs();
}
public class Raven.Server.Documents.Sharding.Handlers.Batches.SingleShardedCommand : object {
    public string Id;
    public int ShardNumber;
    public Stream AttachmentStream;
    public Stream CommandStream;
    public int PositionInResponse;
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Batches.SingleShardedCommand/<Retry>d__5")]
public virtual IEnumerable`1<SingleShardedCommand> Retry(ShardedDatabaseContext databaseContext, TransactionOperationContext context);
}
public class Raven.Server.Documents.Sharding.Handlers.BulkInsert.BatchCommandStreamCopier : AbstractBatchCommandParsingObserver {
    private static int UninitializedPosition;
    protected int CommandStartBufferPosition;
    protected Stream CommandStream;
    public virtual void OnCommandStart(UnmanagedJsonParser parser);
    public virtual void OnCommandEnd(UnmanagedJsonParser parser);
    public virtual void OnParserBufferRefill(UnmanagedJsonParser parser);
    public virtual void OnId(UnmanagedJsonParser parser, int idLength, bool isNull);
    public virtual void OnIdsStart(UnmanagedJsonParser parser);
    public virtual void OnIdsEnd(UnmanagedJsonParser parser);
    public virtual void OnNullChangeVector(UnmanagedJsonParser parser);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.BulkInsert.BatchCommandStreamCopier/<CopyToAsync>d__10")]
public Task CopyToAsync(MemoryStream stream);
    public IDisposable UseStream(MemoryStream stream);
}
public class Raven.Server.Documents.Sharding.Handlers.BulkInsert.ShardedBatchCommandData : object {
    private JsonOperationContext _ctx;
    [CompilerGeneratedAttribute]
private MemoryStream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private AttachmentStream <AttachmentStream>k__BackingField;
    public MemoryStream Stream { get; }
    public CommandData Data { get; public set; }
    public CommandType Type { get; }
    public string Id { get; }
    public AttachmentStream AttachmentStream { get; public set; }
    public long ContentLength { get; }
    public ShardedBatchCommandData(JsonOperationContext ctx);
    [CompilerGeneratedAttribute]
public MemoryStream get_Stream();
    [CompilerGeneratedAttribute]
public CommandData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CommandData value);
    public sealed virtual CommandType get_Type();
    public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual AttachmentStream get_AttachmentStream();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AttachmentStream(AttachmentStream value);
    public sealed virtual long get_ContentLength();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Sharding.Handlers.BulkInsert.ShardedBulkInsertCommandsReader : AbstractBulkInsertBatchCommandsReader`1<ShardedBatchCommandData> {
    private BatchCommandStreamCopier _commandStreamCopier;
    public ShardedBulkInsertCommandsReader(JsonOperationContext ctx, Stream stream, MemoryBuffer buffer, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.BulkInsert.ShardedBulkInsertCommandsReader/<GetCommandAsync>d__2")]
public virtual Task`1<ShardedBatchCommandData> GetCommandAsync(JsonOperationContext ctx, BlittableMetadataModifier modifier);
}
public class Raven.Server.Documents.Sharding.Handlers.BulkInsert.ShardedBulkInsertHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.BulkInsert.ShardedBulkInsertHandler/<BulkInsert>d__0")]
[RavenShardedActionAttribute("/databases/*/bulk_insert", "POST")]
public Task BulkInsert();
}
public abstract class Raven.Server.Documents.Sharding.Handlers.ContinuationTokens.ContinuationToken : object {
    public static string ContinuationTokenQueryString;
    public static string PropertyName;
    private static Dictionary`2<Type, Func`2<BlittableJsonReaderObject, ContinuationToken>> ConverterCache;
    private static ContinuationToken();
    public string ToBase64(JsonOperationContext context);
    public abstract virtual DynamicJsonValue ToJson();
    public static T FromBase64(JsonOperationContext context, string token);
    private static BlittableJsonReaderObject Base64ToBlittable(JsonOperationContext context, string json);
    private static BlittableJsonReaderObject Base64ToBlittable(JsonOperationContext context, string json, Span`1<byte> bytes);
    private static bool TryGetStackSafeBytesLength(string str, Int32& length);
}
public class Raven.Server.Documents.Sharding.Handlers.ContinuationTokens.ShardedPagingContinuation : ContinuationToken {
    public int PageSize;
    public Dictionary`2<int, ShardPaging> Pages;
    private static int DeepPagingThreshold;
    public int Skip;
    public bool DeepPaging;
    public ShardedPagingContinuation(ShardedDatabaseContext databaseContext, int start, int pageSize);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.Sharding.Handlers.IncomingExternalReplicationHandlerForShard : IncomingReplicationHandler {
    private ShardedDocumentDatabase _shardedDatabase;
    public IncomingExternalReplicationHandlerForShard(TcpConnectionOptions options, ReplicationLatestEtagRequest replicatedLastEtag, ReplicationLoader parent, MemoryBuffer bufferToCopy, ReplicationType replicationType);
    protected virtual DocumentMergedTransactionCommand GetMergeDocumentsCommand(DocumentsOperationContext context, DataForReplicationCommand<DocumentsContextPool, DocumentsOperationContext> data, long lastDocumentEtag);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForDeleteAttachment : AbstractAttachmentHandlerProcessorForDeleteAttachment`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAttachmentHandlerProcessorForDeleteAttachment(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForDeleteAttachment/<DeleteAttachmentAsync>d__1")]
protected virtual ValueTask DeleteAttachmentAsync(TransactionOperationContext context, string docId, string name, LazyStringValue changeVector);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForGetAttachment : AbstractAttachmentHandlerProcessorForGetAttachment`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAttachmentHandlerProcessorForGetAttachment(ShardedDatabaseRequestHandler requestHandler, bool isDocument);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForGetAttachment/<GetAttachmentAsync>d__1")]
protected virtual ValueTask GetAttachmentAsync(TransactionOperationContext context, string documentId, string name, AttachmentType type, string changeVector, CancellationToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForGetAttachmentMetadataWithCounts : AbstractAttachmentHandlerProcessorForGetAttachmentMetadataWithCounts`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAttachmentHandlerProcessorForGetAttachmentMetadataWithCounts(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForGetAttachmentMetadataWithCounts/<HandleAttachmentMetadataWithCountsAsync>d__1")]
protected virtual ValueTask HandleAttachmentMetadataWithCountsAsync(string documentId);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForGetHashCount : AbstractAttachmentHandlerProcessorForGetHashCount`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAttachmentHandlerProcessorForGetHashCount(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForGetHashCount/<GetResponseAsync>d__1")]
protected virtual ValueTask`1<Response> GetResponseAsync(TransactionOperationContext context, string hash);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForHeadAttachment : AbstractAttachmentHandlerProcessorForHeadAttachment`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAttachmentHandlerProcessorForHeadAttachment(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForHeadAttachment/<HandleHeadAttachmentAsync>d__1")]
protected virtual ValueTask HandleHeadAttachmentAsync(string documentId, string name, string changeVector);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForPutAttachment : AbstractAttachmentHandlerProcessorForPutAttachment`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedAttachmentHandlerProcessorForPutAttachment(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Attachments.ShardedAttachmentHandlerProcessorForPutAttachment/<PutAttachmentsAsync>d__1")]
protected virtual ValueTask PutAttachmentsAsync(TransactionOperationContext context, string id, string name, Stream requestBodyStream, string contentType, string changeVector, CancellationToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Batches.ShardedBatchHandlerProcessorForBulkDocs : AbstractBatchHandlerProcessorForBulkDocs`3<ShardedBatchCommand, ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedBatchHandlerProcessorForBulkDocs(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Batches.ShardedBatchHandlerProcessorForBulkDocs/<HandleTransactionAsync>d__1")]
protected virtual ValueTask`1<DynamicJsonArray> HandleTransactionAsync(JsonOperationContext context, ShardedBatchCommand command, IndexBatchOptions indexBatchOptions, ReplicationBatchOptions replicationBatchOptions);
    protected virtual ValueTask WaitForIndexesAsync(IndexBatchOptions options, string lastChangeVector, long lastTombstoneEtag, HashSet`1<string> modifiedCollections, CancellationToken token);
    protected virtual ValueTask WaitForReplicationAsync(TransactionOperationContext context, ReplicationBatchOptions options, string lastChangeVector);
    private ShardedBatchBehavior GetBatchBehavior();
    protected virtual char GetIdentityPartsSeparator();
    protected virtual AbstractBatchCommandsReader`2<ShardedBatchCommand, TransactionOperationContext> GetCommandsReader();
    protected virtual AbstractClusterTransactionRequestProcessor`2<ShardedDatabaseRequestHandler, ShardedBatchCommand> GetClusterTransactionRequestProcessor();
}
public class Raven.Server.Documents.Sharding.Handlers.Processors.Batches.ShardedClusterTransactionRequestProcessor : AbstractClusterTransactionRequestProcessor`2<ShardedDatabaseRequestHandler, ShardedBatchCommand> {
    public ShardedClusterTransactionRequestProcessor(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ArraySegment`1<CommandData> GetParsedCommands(ShardedBatchCommand command);
    protected virtual ClusterConfiguration GetClusterConfiguration();
    public virtual Task WaitForDatabaseCompletion(Task`1<HashSet`1<string>> onDatabaseCompletionTask, long index, ClusterTransactionOptions options, CancellationToken token);
    protected virtual ClusterTransactionCommand CreateClusterTransactionCommand(ArraySegment`1<CommandData> parsedCommands, ClusterTransactionOptions options, string raftRequestId);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.BulkInsert.ShardedBulkInsertHandlerProcessor : AbstractBulkInsertHandlerProcessor`3<ShardedBatchCommandData, ShardedBulkInsertHandler, TransactionOperationContext> {
    private ShardedDatabaseContext _databaseContext;
    private static string SampleChangeVector;
    private ShardedBulkInsertOperation _operation;
    private CancellationTokenSource _cts;
    public ShardedBulkInsertHandlerProcessor(ShardedBulkInsertHandler requestHandler, ShardedDatabaseContext databaseContext, long operationId, bool skipOverwriteIfUnchanged, CancellationToken token);
    protected virtual AbstractBulkInsertBatchCommandsReader`1<ShardedBatchCommandData> GetCommandsReader(JsonOperationContext context, Stream requestBodyStream, MemoryBuffer buffer, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.BulkInsert.ShardedBulkInsertHandlerProcessor/<ExecuteCommands>d__6")]
protected virtual ValueTask ExecuteCommands(Task currentTask, int numberOfCommands, ShardedBatchCommandData[] array, long totalSize);
    protected virtual StreamsTempFile GetTempFile();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.BulkInsert.ShardedBulkInsertHandlerProcessor/<CopyAttachmentStream>d__8")]
protected virtual ValueTask`1<string> CopyAttachmentStream(Stream stream, Stream attachmentStream);
    protected virtual ValueTuple`2<long, int> GetSizeAndOperationsCount(ShardedBatchCommandData commandData);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.BulkInsert.ShardedBulkInsertHandlerProcessor/<OnErrorAsync>d__10")]
protected virtual Task OnErrorAsync(Exception exception);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.BulkInsert.ShardedBulkInsertHandlerProcessor/<DisposeAsync>d__11")]
public sealed virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Changes.ShardedChangesHandlerProcessorForDeleteConnections : AbstractChangesHandlerProcessorForDeleteConnections`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedChangesHandlerProcessorForDeleteConnections(ShardedDatabaseRequestHandler requestHandler);
    protected virtual void Disconnect(long connectionId);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Changes.ShardedChangesHandlerProcessorForGetChanges : AbstractChangesHandlerProcessorForGetChanges`3<ShardedDatabaseRequestHandler, TransactionOperationContext, ShardedChangesClientConnection> {
    public ShardedChangesHandlerProcessorForGetChanges(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ShardedChangesClientConnection CreateChangesClientConnection(WebSocket webSocket, bool throttleConnection, bool fromStudio);
    protected virtual void Connect(ShardedChangesClientConnection connection);
    protected virtual void Disconnect(ShardedChangesClientConnection connection);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Changes.ShardedChangesHandlerProcessorForGetConnectionsDebugInfo : AbstractChangesHandlerProcessorForGetConnectionsDebugInfo`3<ShardedDatabaseRequestHandler, TransactionOperationContext, ShardedChangesClientConnection> {
    public ShardedChangesHandlerProcessorForGetConnectionsDebugInfo(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ConcurrentDictionary`2<long, ShardedChangesClientConnection> GetConnections();
}
public class Raven.Server.Documents.Sharding.Handlers.Processors.Collections.CollectionResult : object {
    public BlittableJsonReaderArray Results;
    public string ContinuationToken;
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Collections.ShardedCollectionsHandlerProcessorForGetCollectionDocuments : AbstractCollectionsHandlerProcessorForGetCollectionDocuments`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedCollectionsHandlerProcessorForGetCollectionDocuments(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Collections.ShardedCollectionsHandlerProcessorForGetCollectionDocuments/<GetCollectionDocumentsAndWriteAsync>d__1")]
protected virtual ValueTask`1<ValueTuple`2<long, long>> GetCollectionDocumentsAndWriteAsync(TransactionOperationContext context, string name, int start, int pageSize, CancellationToken token);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Collections.ShardedCollectionsHandlerProcessorForGetCollectionDocuments/<GetDocuments>d__2")]
public IAsyncEnumerable`1<Document> GetDocuments(CombinedReadContinuationState documents, ShardedPagingContinuation pagingContinuation);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Collections.ShardedCollectionsHandlerProcessorForGetCollectionStats : AbstractCollectionsHandlerProcessorForGetCollectionStats`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedCollectionsHandlerProcessorForGetCollectionStats(ShardedDatabaseRequestHandler requestHandler, bool detailed);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Collections.ShardedCollectionsHandlerProcessorForGetCollectionStats/<GetStatsAsync>d__1")]
protected virtual ValueTask`1<DynamicJsonValue> GetStatsAsync(TransactionOperationContext context, bool detailed);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Collections.ShardedCollectionsHandlerProcessorForGetLastChangeVector : AbstractCollectionsHandlerProcessorForGetLastChangeVector`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedCollectionsHandlerProcessorForGetLastChangeVector(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<LastChangeVectorForCollectionResult> command, OperationCancelToken token);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Handlers.Processors.Collections.ShardedCollectionStatisticsOperation : ValueType {
    private HttpContext _httpContext;
    public HttpRequest HttpRequest { get; }
    public ShardedCollectionStatisticsOperation(HttpContext httpContext);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual CollectionStatistics Combine(Dictionary`2<int, ShardExecutionResult`1<CollectionStatistics>> results);
    public sealed virtual RavenCommand`1<CollectionStatistics> CreateCommandForShard(int shardNumber);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Handlers.Processors.Collections.ShardedDetailedCollectionStatisticsOperation : ValueType {
    private HttpContext _httpContext;
    public HttpRequest HttpRequest { get; }
    public ShardedDetailedCollectionStatisticsOperation(HttpContext httpContext);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual DetailedCollectionStatistics Combine(Dictionary`2<int, ShardExecutionResult`1<DetailedCollectionStatistics>> results);
    public sealed virtual RavenCommand`1<DetailedCollectionStatistics> CreateCommandForShard(int shardNumber);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Handlers.Processors.Collections.ShardedStreamDocumentsCollectionOperation : ValueType {
    private HttpContext _httpContext;
    private string _collectionName;
    private ShardedPagingContinuation _token;
    [CompilerGeneratedAttribute]
private string <ExpectedEtag>k__BackingField;
    public HttpRequest HttpRequest { get; }
    public string ExpectedEtag { get; }
    public ShardedStreamDocumentsCollectionOperation(HttpContext httpContext, string collectionName, string etag, ShardedPagingContinuation token);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual RavenCommand`1<StreamResult> CreateCommandForShard(int shardNumber);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExpectedEtag();
    public sealed virtual CombinedStreamResult CombineResults(Dictionary`2<int, ShardExecutionResult`1<StreamResult>> results);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.CompareExchange.ShardedCompareExchangeHandlerProcessorForGetCompareExchangeValues : AbstractCompareExchangeHandlerProcessorForGetCompareExchangeValues`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedCompareExchangeHandlerProcessorForGetCompareExchangeValues(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Configuration.ShardedConfigurationHandlerProcessorForGetClientConfiguration : AbstractConfigurationHandlerProcessorForGetClientConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedConfigurationHandlerProcessorForGetClientConfiguration(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ClientConfiguration GetDatabaseClientConfiguration();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Configuration.ShardedConfigurationHandlerProcessorForGetStudioConfiguration : AbstractConfigurationHandlerProcessorForGetStudioConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedConfigurationHandlerProcessorForGetStudioConfiguration(ShardedDatabaseRequestHandler requestHandler);
    protected virtual StudioConfiguration GetStudioConfiguration();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Configuration.ShardedConfigurationHandlerProcessorForGetTimeSeriesConfiguration : AbstractConfigurationHandlerProcessorForGetTimeSeriesConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedConfigurationHandlerProcessorForGetTimeSeriesConfiguration(ShardedDatabaseRequestHandler requestHandler);
    protected virtual TimeSeriesConfiguration GetTimeSeriesConfiguration();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Configuration.ShardedConfigurationHandlerProcessorForPostTimeSeriesConfiguration : AbstractConfigurationHandlerProcessorForPostTimeSeriesConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedConfigurationHandlerProcessorForPostTimeSeriesConfiguration(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Configuration.ShardedConfigurationHandlerProcessorForPostTimeSeriesConfiguration/<WaitForIndexNotificationAsync>d__1")]
protected virtual ValueTask WaitForIndexNotificationAsync(TransactionOperationContext context, long index);
}
[IsReadOnlyAttribute]
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Counters.ShardedCounterBatchOperation : ValueType {
    private HttpRequest _request;
    private Dictionary`2<int, CounterBatchCommand> _commandsPerShard;
    public HttpRequest HttpRequest { get; }
    internal ShardedCounterBatchOperation(HttpRequest request, Dictionary`2<int, CounterBatchCommand> commandsPerShard);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual CountersDetail Combine(Dictionary`2<int, ShardExecutionResult`1<CountersDetail>> results);
    public sealed virtual RavenCommand`1<CountersDetail> CreateCommandForShard(int shardNumber);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Counters.ShardedCountersHandlerProcessorForGetCounters : AbstractCountersHandlerProcessorForGetCounters`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedCountersHandlerProcessorForGetCounters(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Counters.ShardedCountersHandlerProcessorForGetCounters/<GetCountersAsync>d__1")]
protected virtual ValueTask`1<CountersDetail> GetCountersAsync(TransactionOperationContext context, string docId, StringValues counters, bool full);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Counters.ShardedCountersHandlerProcessorForPostCounters : AbstractCountersHandlerProcessorForPostCounters`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedCountersHandlerProcessorForPostCounters(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Counters.ShardedCountersHandlerProcessorForPostCounters/<ApplyCountersOperationsAsync>d__1")]
protected virtual ValueTask`1<CountersDetail> ApplyCountersOperationsAsync(TransactionOperationContext context, CounterBatch counterBatch);
    private List`1<string> GetDocIds(CounterBatch counterBatch);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.DataArchival.ShardedDataArchivalHandlerProcessorForGet : AbstractDataArchivalHandlerProcessorForGet`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedDataArchivalHandlerProcessorForGet(ShardedDatabaseRequestHandler requestHandler);
    protected virtual DataArchivalConfiguration GetDataArchivalConfiguration();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.DataArchival.ShardedDataArchivalHandlerProcessorForPost : AbstractDataArchivalHandlerProcessorForPost`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedDataArchivalHandlerProcessorForPost(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Debugging.ShardedStorageHandlerProcessorForGetEnvironmentReport : AbstractStorageHandlerProcessorForGetEnvironmentReport`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedStorageHandlerProcessorForGetEnvironmentReport(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Debugging.ShardedStorageHandlerProcessorForGetReport : AbstractStorageHandlerProcessorForGetReport`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedStorageHandlerProcessorForGetReport(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Debugging.ShardedStorageHandlerProcessorForGetScratchBufferReport : AbstractStorageHandlerProcessorForGetEnvironmentReport`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedStorageHandlerProcessorForGetScratchBufferReport(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Debugging.ShardedTransactionDebugHandlerProcessorForGetClusterInfo : AbstractTransactionDebugHandlerProcessorForGetClusterInfo`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedTransactionDebugHandlerProcessorForGetClusterInfo(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForDelete : AbstractDocumentHandlerProcessorForDelete`2<ShardedDocumentHandler, TransactionOperationContext> {
    public ShardedDocumentHandlerProcessorForDelete(ShardedDocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForDelete/<HandleDeleteDocumentAsync>d__1")]
protected virtual ValueTask HandleDeleteDocumentAsync(string docId, string changeVector);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForGenerateClassFromDocument : AbstractDocumentHandlerProcessorForGenerateClassFromDocument`2<ShardedDocumentHandler, TransactionOperationContext> {
    public ShardedDocumentHandlerProcessorForGenerateClassFromDocument(ShardedDocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForGenerateClassFromDocument/<HandleClassGenerationAsync>d__1")]
protected virtual ValueTask HandleClassGenerationAsync(string id, string lang);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForGet : AbstractDocumentHandlerProcessorForGet`3<ShardedDocumentHandler, TransactionOperationContext, BlittableJsonReaderObject> {
    private OperationCancelToken _operationCancelToken;
    protected bool SupportsShowingRequestInTrafficWatch { get; }
    protected CancellationToken CancellationToken { get; }
    public ShardedDocumentHandlerProcessorForGet(HttpMethod method, ShardedDocumentHandler requestHandler);
    protected virtual bool get_SupportsShowingRequestInTrafficWatch();
    protected virtual CancellationToken get_CancellationToken();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForGet/<GetDocumentsByIdImplAsync>d__6")]
protected virtual ValueTask`1<DocumentsByIdResult`1<ShardedDocumentHandler, TransactionOperationContext, BlittableJsonReaderObject, BlittableJsonReaderObject>> GetDocumentsByIdImplAsync(TransactionOperationContext context, List`1<ReadOnlyMemory`1<char>> ids, StringValues includePaths, RevisionIncludeField revisions, StringValues counters, HashSet`1<AbstractTimeSeriesRange> timeSeries, StringValues compareExchangeValues, bool metadataOnly, bool clusterWideTx, string etag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForGet/<WriteDocumentsAsync>d__7")]
protected virtual ValueTask`1<ValueTuple`2<long, long>> WriteDocumentsAsync(AsyncBlittableJsonTextWriter writer, TransactionOperationContext context, IEnumerable`1<BlittableJsonReaderObject> documentsToWrite, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForGet/<WriteDocumentsAsync>d__8")]
protected virtual ValueTask`1<ValueTuple`2<long, long>> WriteDocumentsAsync(AsyncBlittableJsonTextWriter writer, TransactionOperationContext context, IAsyncEnumerable`1<BlittableJsonReaderObject> documentsToWrite, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForGet/<WriteIncludesAsync>d__9")]
protected virtual ValueTask WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, TransactionOperationContext context, string propertyName, List`1<BlittableJsonReaderObject> includes, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForGet/<GetDocumentsImplAsync>d__10")]
protected virtual ValueTask`1<DocumentsResult<ShardedDocumentHandler, TransactionOperationContext, BlittableJsonReaderObject>> GetDocumentsImplAsync(TransactionOperationContext context, Nullable`1<long> etag, StartsWithParams<ShardedDocumentHandler, TransactionOperationContext, BlittableJsonReaderObject> startsWith, string changeVector);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForGetDocSize : AbstractDocumentHandlerProcessorForGetDocSize`2<ShardedDocumentHandler, TransactionOperationContext> {
    public ShardedDocumentHandlerProcessorForGetDocSize(ShardedDocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForGetDocSize/<HandleDocSizeAsync>d__1")]
protected virtual ValueTask HandleDocSizeAsync(string docId);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForHead : AbstractDocumentHandlerProcessorForHead`2<ShardedDocumentHandler, TransactionOperationContext> {
    public ShardedDocumentHandlerProcessorForHead(ShardedDocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForHead/<HandleHeadRequestAsync>d__1")]
protected virtual ValueTask HandleHeadRequestAsync(string docId, string changeVector);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForPatch : AbstractDocumentHandlerProcessorForPatch`2<ShardedDocumentHandler, TransactionOperationContext> {
    public ShardedDocumentHandlerProcessorForPatch(ShardedDocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForPatch/<HandleDocumentPatchAsync>d__1")]
protected virtual ValueTask HandleDocumentPatchAsync(string id, string changeVector, BlittableJsonReaderObject patchRequest, bool skipPatchIfChangeVectorMismatch, bool returnDebugInformation, bool test, TransactionOperationContext context);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForPut : AbstractDocumentHandlerProcessorForPut`2<ShardedDocumentHandler, TransactionOperationContext> {
    public ShardedDocumentHandlerProcessorForPut(ShardedDocumentHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Documents.ShardedDocumentHandlerProcessorForPut/<HandleDocumentPutAsync>d__1")]
protected virtual ValueTask HandleDocumentPutAsync(string id, string changeVector, BlittableJsonReaderObject doc, TransactionOperationContext context);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.DocumentsCompression.ShardedDocumentsCompressionHandlerProcessorForGet : AbstractDocumentsCompressionHandlerProcessorForGet`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedDocumentsCompressionHandlerProcessorForGet(ShardedDatabaseRequestHandler requestHandler);
    protected virtual DocumentsCompressionConfiguration GetDocumentsCompressionConfiguration();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.DocumentsCompression.ShardedDocumentsCompressionHandlerProcessorForPost : AbstractDocumentsCompressionHandlerProcessorForPost`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedDocumentsCompressionHandlerProcessorForPost(ShardedDatabaseRequestHandler requestHandler);
}
internal abstract class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.AbstractShardedEtlHandlerProcessorForTest`3 : AbstractEtlHandlerProcessorForTest`5<ShardedDatabaseRequestHandler, TransactionOperationContext, TTestEtlScript, TConfiguration, TConnectionString> {
    protected bool SupportsCurrentNode { get; }
    protected AbstractShardedEtlHandlerProcessorForTest`3(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual TestEtlScriptResult TestScript(TransactionOperationContext context, TTestEtlScript testScript);
    protected abstract virtual RavenCommand CreateCommand(BlittableJsonReaderObject json);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.ETL.AbstractShardedEtlHandlerProcessorForTest`3/<HandleRemoteNodeAsync>d__5")]
protected virtual ValueTask HandleRemoteNodeAsync(TransactionOperationContext context, TTestEtlScript testScript, BlittableJsonReaderObject testScriptJson);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.ShardedElasticSearchEtlHandlerProcessorForTest : AbstractShardedEtlHandlerProcessorForTest`3<TestElasticSearchEtlScript, ElasticSearchEtlConfiguration, ElasticSearchConnectionString> {
    public ShardedElasticSearchEtlHandlerProcessorForTest(ShardedDatabaseRequestHandler requestHandler);
    protected virtual TestElasticSearchEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
    protected virtual RavenCommand CreateCommand(BlittableJsonReaderObject json);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.ShardedEtlHandlerProcessorForDebugStats : AbstractEtlHandlerProcessorForDebugStats`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedEtlHandlerProcessorForDebugStats(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<EtlTaskDebugStats[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.ShardedEtlHandlerProcessorForPerformance : AbstractEtlHandlerProcessorForPerformance`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedEtlHandlerProcessorForPerformance(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<EtlTaskPerformanceStats[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.ShardedEtlHandlerProcessorForPerformanceLive : AbstractEtlHandlerProcessorForPerformanceLive`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedEtlHandlerProcessorForPerformanceLive(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual string GetDatabaseName();
    protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.ShardedEtlHandlerProcessorForProgress : AbstractEtlHandlerProcessorForProgress`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedEtlHandlerProcessorForProgress(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<EtlTaskProgress[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.ShardedEtlHandlerProcessorForStats : AbstractEtlHandlerProcessorForStats`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedEtlHandlerProcessorForStats(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<EtlTaskStats[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.ShardedOlapEtlHandlerProcessorForTest : AbstractShardedEtlHandlerProcessorForTest`3<TestOlapEtlScript, OlapEtlConfiguration, OlapConnectionString> {
    public ShardedOlapEtlHandlerProcessorForTest(ShardedDatabaseRequestHandler requestHandler);
    protected virtual TestOlapEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
    protected virtual RavenCommand CreateCommand(BlittableJsonReaderObject json);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.ShardedQueueEtlHandlerProcessorForPostScriptTest : AbstractShardedEtlHandlerProcessorForTest`3<TestQueueEtlScript, QueueEtlConfiguration, QueueConnectionString> {
    public ShardedQueueEtlHandlerProcessorForPostScriptTest(ShardedDatabaseRequestHandler requestHandler);
    protected virtual TestQueueEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
    protected virtual RavenCommand CreateCommand(BlittableJsonReaderObject json);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.ShardedRavenEtlHandlerProcessorForTest : AbstractShardedEtlHandlerProcessorForTest`3<TestRavenEtlScript, RavenEtlConfiguration, RavenConnectionString> {
    public ShardedRavenEtlHandlerProcessorForTest(ShardedDatabaseRequestHandler requestHandler);
    protected virtual TestRavenEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
    protected virtual RavenCommand CreateCommand(BlittableJsonReaderObject json);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.ETL.ShardedSqlEtlHandlerProcessorForTest : AbstractShardedEtlHandlerProcessorForTest`3<TestSqlEtlScript, SqlEtlConfiguration, SqlConnectionString> {
    public ShardedSqlEtlHandlerProcessorForTest(ShardedDatabaseRequestHandler requestHandler);
    protected virtual TestSqlEtlScript GetTestEtlScript(BlittableJsonReaderObject json);
    protected virtual RavenCommand CreateCommand(BlittableJsonReaderObject json);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Expiration.ShardedExpirationHandlerProcessorForGet : AbstractExpirationHandlerProcessorForGet`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedExpirationHandlerProcessorForGet(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ExpirationConfiguration GetExpirationConfiguration();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Expiration.ShardedExpirationHandlerProcessorForPost : AbstractExpirationHandlerProcessorForPost`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedExpirationHandlerProcessorForPost(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.HiLo.ShardedHiLoHandlerProcessorForGetNextHiLo : AbstractHiLoHandlerProcessorForGetNextHiLo`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedHiLoHandlerProcessorForGetNextHiLo(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.HiLo.ShardedHiLoHandlerProcessorForGetNextHiLo/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    private RavenCommand`1<HiLoResult> CreateCommand();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.HiLo.ShardedHiLoHandlerProcessorForReturnHiLo : AbstractHiLoHandlerProcessorForReturnHiLo`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedHiLoHandlerProcessorForReturnHiLo(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.HiLo.ShardedHiLoHandlerProcessorForReturnHiLo/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    private RavenCommand CreateCommand();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Identities.ShardedIdentityDebugHandlerProcessorForGetIdentities : AbstractIdentityDebugHandlerProcessorForGetIdentities`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIdentityDebugHandlerProcessorForGetIdentities(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Identities.ShardedIdentityHandlerProcessorForNextIdentityFor : AbstractIdentityHandlerProcessorForNextIdentityFor`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIdentityHandlerProcessorForNextIdentityFor(ShardedDatabaseRequestHandler requestHandler);
    protected virtual char GetDatabaseIdentityPartsSeparator();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Identities.ShardedIdentityHandlerProcessorForPostIdentity : AbstractIdentityHandlerProcessorForPostIdentity`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIdentityHandlerProcessorForPostIdentity(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedAdminIndexHandlerProcessorForDump : AbstractAdminIndexHandlerProcessorForDump`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedAdminIndexHandlerProcessorForDump(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForClearErrors : AbstractIndexHandlerProcessorForClearErrors`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForClearErrors(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForDebug : AbstractIndexHandlerProcessorForDebug`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForDebug(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForDebug/<HandleRemoteNodeAsync>d__4")]
protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForDelete : AbstractIndexHandlerProcessorForDelete`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIndexHandlerProcessorForDelete(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexDeleteController GetIndexDeleteProcessor();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForGetAll : AbstractIndexHandlerProcessorForGetAll`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIndexHandlerProcessorForGetAll(ShardedDatabaseRequestHandler requestHandler);
    protected virtual IndexDefinition[] GetIndexDefinitions(string indexName, int start, int pageSize);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexDefinition[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForGetAllNames : AbstractIndexHandlerProcessorForGetAllNames`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIndexHandlerProcessorForGetAllNames(ShardedDatabaseRequestHandler requestHandler);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<String[]> command, OperationCancelToken token);
    protected virtual String[] GetIndexNames(string name);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForGetDatabaseIndexStatistics : AbstractIndexHandlerProcessorForGetDatabaseIndexStatistics`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForGetDatabaseIndexStatistics(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexStats[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForGetErrors : AbstractIndexHandlerProcessorForGetErrors`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForGetErrors(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexErrors[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForGetIndexesStatus : AbstractIndexHandlerProcessorForGetIndexesStatus`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForGetIndexesStatus(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexingStatus> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForHasChanged : AbstractIndexHandlerProcessorForHasChanged`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIndexHandlerProcessorForHasChanged(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexHasChangedController GetHasChangedController();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForOpenFaultyIndex : AbstractIndexHandlerProcessorForOpenFaultyIndex`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForOpenFaultyIndex(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForPerformance : AbstractIndexHandlerProcessorForPerformance`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForPerformance(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexPerformanceStats[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForPerformanceLive : AbstractIndexHandlerProcessorForPerformanceLive`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForPerformanceLive(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual string GetDatabaseName();
    protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForProgress : AbstractIndexHandlerProcessorForProgress`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForProgress(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexProgress[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForReplace : AbstractIndexHandlerProcessorForReplace`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForReplace(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForReplace/<HandleRemoteNodeAsync>d__4")]
protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForReset : AbstractIndexHandlerProcessorForReset`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForReset(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForSetLockMode : AbstractIndexHandlerProcessorForSetLockMode`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIndexHandlerProcessorForSetLockMode(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexLockModeController GetIndexLockModeProcessor();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForSetPriority : AbstractIndexHandlerProcessorForSetPriority`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIndexHandlerProcessorForSetPriority(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractIndexPriorityController GetIndexPriorityProcessor();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForSource : AbstractIndexHandlerProcessorForSource`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIndexHandlerProcessorForSource(ShardedDatabaseRequestHandler requestHandler);
    protected virtual IndexInformationHolder GetIndex(string name);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForStale : AbstractIndexHandlerProcessorForStale`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForStale(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexStaleness> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForSuggestIndexMerge : AbstractIndexHandlerProcessorForSuggestIndexMerge`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIndexHandlerProcessorForSuggestIndexMerge(ShardedDatabaseRequestHandler requestHandler);
    protected virtual Dictionary`2<string, IndexDefinition> GetIndexes();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForTerms : AbstractIndexHandlerProcessorForTerms`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedIndexHandlerProcessorForTerms(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForTerms/<GetTermsAsync>d__1")]
protected virtual ValueTask`1<TermsQueryResultServerSide> GetTermsAsync(string indexName, string field, string fromValue, int pageSize, Nullable`1<long> resultEtag, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForTestIndex : AbstractAdminIndexHandlerProcessorForTestIndex`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForTestIndex(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual RavenCommand`1<BlittableJsonReaderObject> CreateCommandForNode(string nodeTag);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForTestIndex/<HandleRemoteNodeAsync>d__5")]
protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<BlittableJsonReaderObject> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexHandlerProcessorForTotalTime : AbstractIndexHandlerProcessorForTotalTime`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexHandlerProcessorForTotalTime(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexTotalTime[]> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Indexes.ShardedIndexProcessorForGenerateCSharpIndexDefinition : AbstractIndexProcessorForGenerateCSharpIndexDefinition`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIndexProcessorForGenerateCSharpIndexDefinition(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<string> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.IoMetrics.ShardedIoMetricsHandlerProcessorForLive : AbstractIoMetricsHandlerProcessorForLive`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedIoMetricsHandlerProcessorForLive(ShardedDatabaseRequestHandler requestHandler);
    protected virtual string GetDatabaseName();
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.MultiGet.ShardedMultiGetHandlerProcessorForPost : AbstractMultiGetHandlerProcessorForPost`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedMultiGetHandlerProcessorForPost(ShardedDatabaseRequestHandler requestHandler);
    protected virtual HandleRequest GetRequestHandler(RouteInformation routeInformation);
    protected virtual void FillRequestHandlerContext(RequestHandlerContext context);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Notifications.ShardedDatabaseNotificationCenterHandlerProcessorForDismiss : AbstractDatabaseNotificationCenterHandlerProcessorForDismiss`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    protected bool SupportsOptionalShardNumber { get; }
    public ShardedDatabaseNotificationCenterHandlerProcessorForDismiss(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractDatabaseNotificationCenter GetNotificationCenter();
    protected virtual bool get_SupportsCurrentNode();
    protected virtual bool get_SupportsOptionalShardNumber();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Notifications.ShardedDatabaseNotificationCenterHandlerProcessorForPostpone : AbstractDatabaseNotificationCenterHandlerProcessorForPostpone`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    protected bool SupportsOptionalShardNumber { get; }
    public ShardedDatabaseNotificationCenterHandlerProcessorForPostpone(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractDatabaseNotificationCenter GetNotificationCenter();
    protected virtual bool get_SupportsCurrentNode();
    protected virtual bool get_SupportsOptionalShardNumber();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Notifications.ShardedDatabaseNotificationCenterHandlerProcessorForWatch : AbstractDatabaseNotificationCenterHandlerProcessorForWatch`3<ShardedDatabaseRequestHandler, TransactionOperationContext, ShardedOperation> {
    protected bool SupportsCurrentNode { get; }
    protected bool SupportsOptionalShardNumber { get; }
    public ShardedDatabaseNotificationCenterHandlerProcessorForWatch(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractDatabaseNotificationCenter GetNotificationCenter();
    protected virtual AbstractOperations`1<ShardedOperation> GetOperations();
    protected virtual bool get_SupportsCurrentNode();
    protected virtual bool get_SupportsOptionalShardNumber();
    protected virtual string GetDatabaseName();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.NotSupportedInShardingProcessor : AbstractDatabaseHandlerProcessor`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    private string _message;
    public NotSupportedInShardingProcessor(ShardedDatabaseRequestHandler requestHandler, string message);
    public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForAddEtl : AbstractOngoingTasksHandlerProcessorForAddEtl`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForAddEtl(ShardedDatabaseRequestHandler requestHandler);
    protected virtual void AssertCanAddOrUpdateEtl(BlittableJsonReaderObject& etlConfiguration);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForAddQueueSink : AbstractOngoingTasksHandlerProcessorForAddQueueSink`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForAddQueueSink(ShardedDatabaseRequestHandler requestHandler);
    protected virtual void AssertCanAddOrUpdateQueueSink(BlittableJsonReaderObject& queueSinkConfiguration);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForBackupDatabaseNow : AbstractOngoingTasksHandlerProcessorForBackupDatabaseNow`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForBackupDatabaseNow(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<bool> ScheduleBackupOperationAsync(long taskId, bool isFullBackup, long operationId, Nullable`1<DateTime> _);
    protected virtual long GetNextOperationId();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForBackupDatabaseOnce : AbstractOngoingTasksHandlerProcessorForBackupDatabaseOnce`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForBackupDatabaseOnce(ShardedDatabaseRequestHandler requestHandler);
    protected virtual void ScheduleBackup(BackupConfiguration backupConfiguration, long operationId, string backupName, Stopwatch sw, DateTime startTime, OperationCancelToken token);
    protected virtual void AssertBackup(BackupConfiguration configuration);
    protected virtual long GetNextOperationId();
    protected virtual AbstractNotificationCenter GetNotificationCenter();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForDeleteOngoingTask : AbstractOngoingTasksHandlerProcessorForDeleteOngoingTask`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForDeleteOngoingTask(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForDeleteOngoingTask/<RaiseNotificationForSubscriptionTaskRemoval>d__1")]
protected virtual ValueTask RaiseNotificationForSubscriptionTaskRemoval();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForDeleteSubscriptionTasks : AbstractOngoingTasksHandlerProcessorForDeleteSubscriptionTasks`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForDeleteSubscriptionTasks(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForDeleteSubscriptionTasks/<RaiseNotificationForSubscriptionTaskRemoval>d__1")]
protected virtual ValueTask RaiseNotificationForSubscriptionTaskRemoval();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForGetOngoingTask : AbstractOngoingTasksHandlerProcessorForGetOngoingTask`3<ShardedDatabaseRequestHandler, TransactionOperationContext, SubscriptionConnectionsStateOrchestrator> {
    protected bool SupportsOptionalShardNumber { get; }
    public ShardedOngoingTasksHandlerProcessorForGetOngoingTask(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsOptionalShardNumber();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<OngoingTask> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForGetOngoingTasks : AbstractOngoingTasksHandlerProcessorForGetOngoingTasks`3<ShardedDatabaseRequestHandler, TransactionOperationContext, SubscriptionConnectionsStateOrchestrator> {
    protected long SubscriptionsCount { get; }
    protected bool SupportsOptionalShardNumber { get; }
    public ShardedOngoingTasksHandlerProcessorForGetOngoingTasks(ShardedDatabaseRequestHandler requestHandler);
    protected virtual long get_SubscriptionsCount();
    protected virtual bool get_SupportsOptionalShardNumber();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<OngoingTasksResult> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForGetPeriodicBackupTimers : AbstractOngoingTasksHandlerProcessorForGetPeriodicBackupTimers`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedOngoingTasksHandlerProcessorForGetPeriodicBackupTimers(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<PeriodicBackupTimersResponse> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForGetPullReplicationHubTasksInfo : AbstractOngoingTasksHandlerProcessorForGetPullReplicationHubTasksInfo`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForGetPullReplicationHubTasksInfo(ShardedDatabaseRequestHandler requestHandler);
    protected virtual void AssertCanExecute();
    protected virtual IEnumerable`1<OngoingTaskPullReplicationAsHub> GetOngoingTasks(TransactionOperationContext context, DatabaseRecord databaseRecord, ClusterTopology clusterTopology, long key);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForPostSubscriptionTasksState : AbstractOngoingTasksHandlerProcessorForPostSubscriptionTasksState`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForPostSubscriptionTasksState(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractSubscriptionStorage GetSubscriptionStorage();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForPutConnectionString : AbstractOngoingTasksHandlerProcessorForPutConnectionString`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForPutConnectionString(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForRemoveConnectionString : AbstractOngoingTasksHandlerProcessorForRemoveConnectionString`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForRemoveConnectionString(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForResetEtl : AbstractOngoingTasksHandlerProcessorForResetEtl`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForResetEtl(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForToggleTaskState : AbstractOngoingTasksHandlerProcessorForToggleTaskState`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    [CompilerGeneratedAttribute]
private bool <RequireAdmin>k__BackingField;
    protected bool RequireAdmin { get; }
    public ShardedOngoingTasksHandlerProcessorForToggleTaskState(ShardedDatabaseRequestHandler requestHandler, bool requireAdmin);
    [CompilerGeneratedAttribute]
protected virtual bool get_RequireAdmin();
    protected virtual AbstractSubscriptionStorage GetSubscriptionStorage();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.OngoingTasks.ShardedOngoingTasksHandlerProcessorForUpdatePeriodicBackup : AbstractOngoingTasksHandlerProcessorForUpdatePeriodicBackup`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForUpdatePeriodicBackup(ShardedDatabaseRequestHandler requestHandler);
    protected virtual BackupConfiguration GetBackupConfiguration();
    protected virtual void OnBeforeUpdateConfiguration(PeriodicBackupConfiguration& configuration, JsonOperationContext context);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Operations.ShardedOperationsHandlerProcessorForGetAll : AbstractOperationsHandlerProcessorForGetAll`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOperationsHandlerProcessorForGetAll(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractOperation GetOperation(long operationId);
    protected virtual IEnumerable`1<AbstractOperation> GetAllOperations();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Operations.ShardedOperationsHandlerProcessorForGetNextOperationId : AbstractOperationsHandlerProcessorForGetNextOperationId`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOperationsHandlerProcessorForGetNextOperationId(ShardedDatabaseRequestHandler requestHandler);
    protected virtual long GetNextOperationId();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Operations.ShardedOperationsHandlerProcessorForKill : AbstractOperationsHandlerProcessorForKill`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOperationsHandlerProcessorForKill(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ValueTask KillOperationAsync(long operationId, CancellationToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Operations.ShardedOperationsHandlerProcessorForState : AbstractOperationsHandlerProcessorForState`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOperationsHandlerProcessorForState(ShardedDatabaseRequestHandler requestHandler);
    protected virtual OperationState GetOperationState(long operationId);
}
internal abstract class Raven.Server.Documents.Sharding.Handlers.Processors.Queries.AbstractShardedOperationQueriesHandlerProcessor : AbstractOperationQueriesHandlerProcessor`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected AbstractDatabaseNotificationCenter NotificationCenter { get; }
    protected RavenConfiguration Configuration { get; }
    protected AbstractShardedOperationQueriesHandlerProcessor(ShardedDatabaseRequestHandler requestHandler, QueryMetadataCache queryMetadataCache);
    protected virtual long GetNextOperationId();
    protected virtual IDisposable AllocateContextForAsyncOperation(TransactionOperationContext& asyncOperationContext);
    protected virtual AbstractDatabaseNotificationCenter get_NotificationCenter();
    protected virtual RavenConfiguration get_Configuration();
    protected abstract virtual ValueTuple`2<Func`3<JsonOperationContext, int, RavenCommand`1<OperationIdResult>>, OperationType> GetOperation(IndexQueryServerSide query, long operationId, QueryOperationOptions options);
    protected virtual void ScheduleOperation(TransactionOperationContext asyncOperationContext, IDisposable returnAsyncOperationContext, IndexQueryServerSide query, long operationId, QueryOperationOptions options);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesDebugHandlerProcessorForKillQuery : AbstractQueriesDebugHandlerProcessorForKillQuery`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedQueriesDebugHandlerProcessorForKillQuery(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractQueryRunner GetQueryRunner();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesDebugHandlerProcessorForQueriesCacheList : AbstractQueriesDebugHandlerProcessorForQueriesCacheList`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedQueriesDebugHandlerProcessorForQueriesCacheList(ShardedDatabaseRequestHandler requestHandler);
    protected virtual QueryMetadataCache GetQueryMetadataCache();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesDebugHandlerProcessorForRunningQueries : AbstractQueriesDebugHandlerProcessorForRunningQueries`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedQueriesDebugHandlerProcessorForRunningQueries(ShardedDatabaseRequestHandler requestHandler);
    protected virtual AbstractQueryRunner GetQueryRunner();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesHandlerProcessorForDelete : AbstractShardedOperationQueriesHandlerProcessor {
    protected HttpMethod QueryMethod { get; }
    public ShardedQueriesHandlerProcessorForDelete(ShardedDatabaseRequestHandler requestHandler);
    protected virtual HttpMethod get_QueryMethod();
    protected virtual ValueTuple`2<Func`3<JsonOperationContext, int, RavenCommand`1<OperationIdResult>>, OperationType> GetOperation(IndexQueryServerSide query, long operationId, QueryOperationOptions options);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesHandlerProcessorForGet : AbstractQueriesHandlerProcessorForGet`4<ShardedQueriesHandler, TransactionOperationContext, TransactionOperationContext, BlittableJsonReaderObject> {
    protected AbstractDatabaseNotificationCenter NotificationCenter { get; }
    protected RavenConfiguration Configuration { get; }
    public ShardedQueriesHandlerProcessorForGet(ShardedQueriesHandler requestHandler, HttpMethod method);
    protected virtual IDisposable AllocateContextForQueryOperation(TransactionOperationContext& queryContext, TransactionOperationContext& context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesHandlerProcessorForGet/<GetIndexEntriesAsync>d__2")]
protected virtual ValueTask`1<IndexEntriesQueryResult> GetIndexEntriesAsync(TransactionOperationContext queryContext, TransactionOperationContext context, IndexQueryServerSide query, Nullable`1<long> existingResultEtag, bool ignoreLimit, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesHandlerProcessorForGet/<ExplainAsync>d__3")]
protected virtual ValueTask ExplainAsync(TransactionOperationContext queryContext, IndexQueryServerSide query, OperationCancelToken token);
    protected virtual AbstractDatabaseNotificationCenter get_NotificationCenter();
    protected virtual RavenConfiguration get_Configuration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesHandlerProcessorForGet/<GetFacetedQueryResultAsync>d__8")]
protected virtual ValueTask`1<FacetedQueryResult> GetFacetedQueryResultAsync(IndexQueryServerSide query, TransactionOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesHandlerProcessorForGet/<GetSuggestionQueryResultAsync>d__9")]
protected virtual ValueTask`1<SuggestionQueryResult> GetSuggestionQueryResultAsync(IndexQueryServerSide query, TransactionOperationContext queryContext, Nullable`1<long> existingResultEtag, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesHandlerProcessorForGet/<GetQueryResultsAsync>d__10")]
protected virtual ValueTask`1<QueryResultServerSide`1<BlittableJsonReaderObject>> GetQueryResultsAsync(IndexQueryServerSide query, TransactionOperationContext queryContext, Nullable`1<long> existingResultEtag, bool metadataOnly, OperationCancelToken token);
    protected virtual void AssertIndexQuery(IndexQueryServerSide indexQuery);
    private static TimingsScope Timings(IndexQueryServerSide query);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesHandlerProcessorForPatch : AbstractShardedOperationQueriesHandlerProcessor {
    protected HttpMethod QueryMethod { get; }
    public ShardedQueriesHandlerProcessorForPatch(ShardedDatabaseRequestHandler requestHandler);
    protected virtual HttpMethod get_QueryMethod();
    protected virtual ValueTuple`2<Func`3<JsonOperationContext, int, RavenCommand`1<OperationIdResult>>, OperationType> GetOperation(IndexQueryServerSide query, long operationId, QueryOperationOptions options);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesHandlerProcessorForPatchTest : AbstractQueriesHandlerProcessorForPatchTest`2<ShardedQueriesHandler, TransactionOperationContext> {
    protected AbstractDatabaseNotificationCenter NotificationCenter { get; }
    protected RavenConfiguration Configuration { get; }
    public ShardedQueriesHandlerProcessorForPatchTest(ShardedQueriesHandler requestHandler);
    protected virtual AbstractDatabaseNotificationCenter get_NotificationCenter();
    protected virtual RavenConfiguration get_Configuration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Queries.ShardedQueriesHandlerProcessorForPatchTest/<HandleDocumentPatchTestAsync>d__5")]
protected virtual ValueTask HandleDocumentPatchTestAsync(IndexQueryServerSide query, string docId, TransactionOperationContext context);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Rachis.ShardedRachisHandlerProcessorForWaitForIndexNotifications : AbstractRachisHandlerProcessorForWaitForIndexNotifications`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedRachisHandlerProcessorForWaitForIndexNotifications(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Rachis.ShardedRachisHandlerProcessorForWaitForIndexNotifications/<WaitForCommandsAsync>d__1")]
protected virtual ValueTask WaitForCommandsAsync(TransactionOperationContext context, WaitForIndexNotificationRequest commands);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Refresh.ShardedRefreshHandlerProcessorForGetRefreshConfiguration : AbstractRefreshHandlerProcessorForGetRefreshConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedRefreshHandlerProcessorForGetRefreshConfiguration(ShardedDatabaseRequestHandler requestHandler);
    protected virtual RefreshConfiguration GetRefreshConfiguration();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Refresh.ShardedRefreshHandlerProcessorForPostRefreshConfiguration : AbstractRefreshHandlerProcessorForPostRefreshConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedRefreshHandlerProcessorForPostRefreshConfiguration(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedOngoingTasksHandlerProcessorForUpdateExternalReplication : AbstractOngoingTasksHandlerProcessorForUpdateExternalReplication`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedOngoingTasksHandlerProcessorForUpdateExternalReplication(ShardedDatabaseRequestHandler requestHandler);
    protected virtual void FillResponsibleNode(TransactionOperationContext context, DynamicJsonValue responseJson, ExternalReplication watcher);
    protected virtual void OnBeforeUpdateConfiguration(BlittableJsonReaderObject& configuration, JsonOperationContext context);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedPullReplicationHandlerProcessorForDefineHub : AbstractPullReplicationHandlerProcessorForDefineHub`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedPullReplicationHandlerProcessorForDefineHub(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ValueTask AssertCanExecuteAsync();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedPullReplicationHandlerProcessorForGenerateCertificate : AbstractPullReplicationHandlerProcessorForGenerateCertificate`1<ShardedDatabaseRequestHandler> {
    public ShardedPullReplicationHandlerProcessorForGenerateCertificate(ShardedDatabaseRequestHandler requestHandler);
    protected virtual void AssertCanExecute();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedPullReplicationHandlerProcessorForGetListHubAccess : AbstractPullReplicationHandlerProcessorForGetListHubAccess`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedPullReplicationHandlerProcessorForGetListHubAccess(ShardedDatabaseRequestHandler requestHandler);
    protected virtual void AssertCanExecute();
    protected virtual string GetDatabaseName();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedPullReplicationHandlerProcessorForRegisterHubAccess : AbstractPullReplicationHandlerProcessorForRegisterHubAccess`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedPullReplicationHandlerProcessorForRegisterHubAccess(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ValueTask AssertCanExecuteAsync();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedPullReplicationHandlerProcessorForUnregisterHubAccess : AbstractPullReplicationHandlerProcessorForUnregisterHubAccess`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedPullReplicationHandlerProcessorForUnregisterHubAccess(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ValueTask AssertCanExecuteAsync();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedPullReplicationHandlerProcessorForUpdatePullReplicationOnSinkNode : AbstractPullReplicationHandlerProcessorForUpdatePullReplicationOnSinkNode`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedPullReplicationHandlerProcessorForUpdatePullReplicationOnSinkNode(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ValueTask AssertCanExecuteAsync();
    protected virtual void FillResponsibleNode(TransactionOperationContext context, DynamicJsonValue responseJson, PullReplicationAsSink pullReplication);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetActiveConnections : AbstractReplicationHandlerProcessorForGetActiveConnections`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedReplicationHandlerProcessorForGetActiveConnections(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationActiveConnectionsPreview> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetConflicts : AbstractReplicationHandlerProcessorForGetConflicts`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    private ShardedPagingContinuation _continuationToken;
    public ShardedReplicationHandlerProcessorForGetConflicts(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetConflicts/<GetConflictsPreviewAsync>d__2")]
protected virtual ValueTask`1<GetConflictsPreviewResult> GetConflictsPreviewAsync(TransactionOperationContext context, long start, int pageSize);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetConflicts/<GetConflictsForDocumentAsync>d__3")]
protected virtual Task GetConflictsForDocumentAsync(TransactionOperationContext context, string documentId);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetConflictSolver : AbstractReplicationHandlerProcessorForGetConflictSolver`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedReplicationHandlerProcessorForGetConflictSolver(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetIncomingActivityTimes : AbstractReplicationHandlerProcessorForGetIncomingActivityTimes`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedReplicationHandlerProcessorForGetIncomingActivityTimes(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationIncomingLastActivityTimePreview> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetIncomingRejectionInfo : AbstractReplicationHandlerProcessorForGetIncomingRejectionInfo`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedReplicationHandlerProcessorForGetIncomingRejectionInfo(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationIncomingRejectionInfoPreview> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetOutgoingFailureStats : AbstractReplicationHandlerProcessorForGetOutgoingFailureStats`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedReplicationHandlerProcessorForGetOutgoingFailureStats(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationOutgoingsFailurePreview> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetOutgoingReconnectionQueue : AbstractReplicationHandlerProcessorForGetOutgoingReconnectionQueue`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedReplicationHandlerProcessorForGetOutgoingReconnectionQueue(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationOutgoingReconnectionQueuePreview> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetPerformance : AbstractReplicationHandlerProcessorForGetPerformance`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedReplicationHandlerProcessorForGetPerformance(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ReplicationPerformance> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetPerformanceLive : AbstractReplicationHandlerProcessorForGetPerformanceLive`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedReplicationHandlerProcessorForGetPerformanceLive(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual string GetDatabaseName();
    protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetPulsesLive : AbstractReplicationHandlerProcessorForGetPulsesLive`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedReplicationHandlerProcessorForGetPulsesLive(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual string GetDatabaseName();
    protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetTombstones : AbstractReplicationHandlerProcessorForGetTombstones`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    private ShardedPagingContinuation _continuationToken;
    public ShardedReplicationHandlerProcessorForGetTombstones(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Replication.ShardedReplicationHandlerProcessorForGetTombstones/<GetTombstonesAsync>d__2")]
protected virtual ValueTask`1<GetTombstonesPreviewResult> GetTombstonesAsync(TransactionOperationContext context, int start, int pageSize);
}
[IsReadOnlyAttribute]
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedDeleteRevisionsOperation : ValueType {
    private Dictionary`2<int, DeleteRevisionsCommand> _cmds;
    private HttpContext _httpContext;
    public HttpRequest HttpRequest { get; }
    public ShardedDeleteRevisionsOperation(HttpContext httpContext, Dictionary`2<int, DeleteRevisionsCommand> cmds);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual Result Combine(Dictionary`2<int, ShardExecutionResult`1<Result>> results);
    public sealed virtual RavenCommand`1<Result> CreateCommandForShard(int shardNumber);
}
[IsReadOnlyAttribute]
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedGetResolvedRevisionsOperation : ValueType {
    private JsonOperationContext _context;
    private ShardedDatabaseRequestHandler _handler;
    private DateTime _since;
    private int _take;
    public HttpRequest HttpRequest { get; }
    public ShardedGetResolvedRevisionsOperation(JsonOperationContext context, ShardedDatabaseRequestHandler handler, DateTime since, int take);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual List`1<BlittableJsonReaderObject> Combine(Dictionary`2<int, ShardExecutionResult`1<ResolvedRevisions>> results);
    public sealed virtual RavenCommand`1<ResolvedRevisions> CreateCommandForShard(int shardNumber);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevertRevisionsByIdOperation : ValueType {
    private Dictionary`2<int, Dictionary`2<string, string>> _shardsToDocs;
    public HttpRequest HttpRequest { get; }
    public ShardedRevertRevisionsByIdOperation(Dictionary`2<int, Dictionary`2<string, string>> shardsToDocs);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual RavenCommand`1<object> CreateCommandForShard(int shardNumber);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetResolvedRevisions : AbstractRevisionsHandlerProcessorForGetResolvedRevisions`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedRevisionsHandlerProcessorForGetResolvedRevisions(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetResolvedRevisions/<GetResolvedRevisionsAndWriteAsync>d__1")]
protected virtual ValueTask GetResolvedRevisionsAndWriteAsync(TransactionOperationContext context, DateTime since, int take, CancellationToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisions : AbstractRevisionsHandlerProcessorForGetRevisions`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedRevisionsHandlerProcessorForGetRevisions(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisions/<GetRevisionByChangeVectorAsync>d__1")]
protected virtual ValueTask GetRevisionByChangeVectorAsync(TransactionOperationContext context, StringValues changeVectors, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisions/<GetRevisionsAsync>d__2")]
protected virtual ValueTask GetRevisionsAsync(TransactionOperationContext context, string id, Nullable`1<DateTime> before, int start, int pageSize, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisions/<WriteRevisionsResultAsync>d__3")]
public static ValueTask WriteRevisionsResultAsync(JsonOperationContext context, ShardedDatabaseRequestHandler handler, BlittableJsonReaderObject[] array, Nullable`1<long> totalResult, ContinuationToken continuationToken);
    private void AddPagingPerformanceHint(PagingOperationType operation, string action, string details, long numberOfResults, int pageSize, long duration, long totalDocumentsSizeInBytes);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisionsBin : AbstractRevisionsHandlerProcessorForGetRevisionsBin`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedRevisionsHandlerProcessorForGetRevisionsBin(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisionsBin/<GetAndWriteRevisionsBinAsync>d__1")]
protected virtual ValueTask GetAndWriteRevisionsBinAsync(TransactionOperationContext context, int start, int pageSize);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisionsConfiguration : AbstractRevisionsHandlerProcessorForGetRevisionsConfiguration`1<ShardedDatabaseRequestHandler> {
    public ShardedRevisionsHandlerProcessorForGetRevisionsConfiguration(ShardedDatabaseRequestHandler requestHandler);
    protected virtual RevisionsConfiguration GetRevisionsConfiguration();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisionsConflictsConfiguration : AbstractRevisionsHandlerProcessorForGetRevisionsConflictsConfiguration`1<ShardedDatabaseRequestHandler> {
    public ShardedRevisionsHandlerProcessorForGetRevisionsConflictsConfiguration(ShardedDatabaseRequestHandler requestHandler);
    protected virtual RevisionsCollectionConfiguration GetRevisionsConflicts();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisionsCount : AbstractRevisionsHandlerProcessorForGetRevisionsCount`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedRevisionsHandlerProcessorForGetRevisionsCount(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisionsCount/<GetRevisionsCountAsync>d__1")]
protected virtual ValueTask`1<DocumentRevisionsCount> GetRevisionsCountAsync(string docId);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForGetRevisionsDebug : AbstractRevisionsHandlerProcessorForGetRevisionsDebug`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedRevisionsHandlerProcessorForGetRevisionsDebug(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<BlittableJsonReaderObject> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForPostRevisionsConfiguration : AbstractRevisionsHandlerProcessorForPostRevisionsConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedRevisionsHandlerProcessorForPostRevisionsConfiguration(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForRevertRevisions : AbstractRevisionsHandlerProcessorForRevertRevisions`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedRevisionsHandlerProcessorForRevertRevisions(ShardedDatabaseRequestHandler requestHandler);
    protected virtual void ScheduleRevertRevisions(long operationId, RevertRevisionsRequest configuration, OperationCancelToken token);
    protected virtual long GetNextOperationId();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForRevertRevisionsForDocument : AbstractRevisionsHandlerProcessorForRevertRevisionsForDocument`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedRevisionsHandlerProcessorForRevertRevisionsForDocument(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Revisions.ShardedRevisionsHandlerProcessorForRevertRevisionsForDocument/<RevertDocumentsAsync>d__1")]
protected virtual Task RevertDocumentsAsync(Dictionary`2<string, string> idToChangeVector, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.SampleData.ShardedSampleDataHandlerProcessorForGetSampleDataClasses : AbstractSampleDataHandlerProcessorForGetSampleDataClasses`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedSampleDataHandlerProcessorForGetSampleDataClasses(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.SampleData.ShardedSampleDataHandlerProcessorForPostSampleData : AbstractSampleDataHandlerProcessorForPostSampleData`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedSampleDataHandlerProcessorForPostSampleData(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.SampleData.ShardedSampleDataHandlerProcessorForPostSampleData/<ExecuteSmugglerAsync>d__1")]
protected virtual ValueTask ExecuteSmugglerAsync(JsonOperationContext context, Stream sampleDataStream, DatabaseItemType operateOnTypes);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.SampleData.ShardedSampleDataHandlerProcessorForPostSampleData/<IsDatabaseEmptyAsync>d__2")]
protected virtual ValueTask`1<bool> IsDatabaseEmptyAsync();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Smuggler.ShardedSmugglerHandlerProcessorForExport : AbstractSmugglerHandlerProcessorForExport`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedSmugglerHandlerProcessorForExport(ShardedDatabaseRequestHandler requestHandler);
    protected virtual long GetNextOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Smuggler.ShardedSmugglerHandlerProcessorForExport/<ExportAsync>d__2")]
protected virtual ValueTask`1<IOperationResult> ExportAsync(JsonOperationContext context, IDisposable returnToContextPool, long operationId, DatabaseSmugglerOptionsServerSide options, long startDocumentEtag, long startRaftIndex, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Smuggler.ShardedSmugglerHandlerProcessorForExport/<ExportShardedDatabaseInternalAsync>d__3")]
private Task`1<IOperationResult> ExportShardedDatabaseInternalAsync(DatabaseSmugglerOptionsServerSide options, Action`1<IOperationProgress> onProgress, JsonOperationContext jsonOperationContext, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Smuggler.ShardedSmugglerHandlerProcessorForImport : AbstractSmugglerHandlerProcessorForImport`2<ShardedSmugglerHandler, TransactionOperationContext> {
    public ShardedSmugglerHandlerProcessorForImport(ShardedSmugglerHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Smuggler.ShardedSmugglerHandlerProcessorForImport/<ImportAsync>d__1")]
protected virtual ValueTask ImportAsync(JsonOperationContext context, Nullable`1<long> operationId);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Sorters.ShardedSortersHandlerProcessorForGet : AbstractSortersHandlerProcessorForGet`1<TransactionOperationContext> {
    public ShardedSortersHandlerProcessorForGet(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForDatabaseHealthCheck : AbstractStatsHandlerProcessorForDatabaseHealthCheck`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStatsHandlerProcessorForDatabaseHealthCheck(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForDatabaseHealthCheck/<GetNoContentStatusAsync>d__1")]
protected virtual Task GetNoContentStatusAsync();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForEssentialStats : AbstractStatsHandlerProcessorForEssentialStats`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStatsHandlerProcessorForEssentialStats(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForEssentialStats/<GetEssentialDatabaseStatisticsAsync>d__1")]
protected virtual ValueTask`1<EssentialDatabaseStatistics> GetEssentialDatabaseStatisticsAsync(TransactionOperationContext context);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForGetDatabaseStatistics : AbstractStatsHandlerProcessorForGetDatabaseStatistics`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedStatsHandlerProcessorForGetDatabaseStatistics(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForGetDatabaseStatistics/<HandleRemoteNodeAsync>d__4")]
protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<DatabaseStatistics> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForGetDetailedDatabaseStatistics : AbstractStatsHandlerProcessorForGetDetailedDatabaseStatistics`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedStatsHandlerProcessorForGetDetailedDatabaseStatistics(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<DetailedDatabaseStatistics> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForGetMetrics : AbstractStatsHandlerProcessorForGetMetrics`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedStatsHandlerProcessorForGetMetrics(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForGetMetricsBytes : AbstractStatsHandlerProcessorForGetMetricsBytes`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedStatsHandlerProcessorForGetMetricsBytes(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForGetMetricsPuts : AbstractStatsHandlerProcessorForGetMetricsPuts`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedStatsHandlerProcessorForGetMetricsPuts(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForPostValidateUnusedIds : AbstractStatsHandlerProcessorForPostValidateUnusedIds`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStatsHandlerProcessorForPostValidateUnusedIds(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Stats.ShardedStatsHandlerProcessorForPostValidateUnusedIds/<ValidateUnusedIdsOnAllNodesAsync>d__1")]
protected virtual Task ValidateUnusedIdsOnAllNodesAsync(HashSet`1<string> unusedIds, string databaseName, CancellationToken token);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamDocumentsOperation : ValueType {
    private string _startsWith;
    private string _matches;
    private string _exclude;
    private string _startAfter;
    private string _format;
    private HttpContext _httpContext;
    private ShardedPagingContinuation _token;
    [CompilerGeneratedAttribute]
private string <ExpectedEtag>k__BackingField;
    public HttpRequest HttpRequest { get; }
    public string ExpectedEtag { get; }
    public ShardedStreamDocumentsOperation(HttpContext httpContext, string etag, ShardedPagingContinuation token);
    public ShardedStreamDocumentsOperation(HttpContext httpContext, string startsWith, string matches, string exclude, string startAfter, string format, string etag, ShardedPagingContinuation token);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual RavenCommand`1<StreamResult> CreateCommandForShard(int shardNumber);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExpectedEtag();
    public sealed virtual CombinedStreamResult CombineResults(Dictionary`2<int, ShardExecutionResult`1<StreamResult>> results);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetDocs : AbstractStreamingHandlerProcessorForGetDocs`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStreamingHandlerProcessorForGetDocs(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetDocs/<GetDocumentsAndWriteAsync>d__1")]
protected virtual ValueTask GetDocumentsAndWriteAsync(TransactionOperationContext context, int start, int pageSize, string startsWith, string excludes, string matches, string startAfter, string format, OperationCancelToken token);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetDocs/<OrderDocumentsByLastModified>d__2")]
public IAsyncEnumerable`1<BlittableJsonReaderObject> OrderDocumentsByLastModified(CombinedReadContinuationState documents, ShardedPagingContinuation pagingContinuation);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetDocs/<OrderDocumentsById>d__3")]
public IAsyncEnumerable`1<BlittableJsonReaderObject> OrderDocumentsById(CombinedReadContinuationState documents, ShardedPagingContinuation pagingContinuation);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetStreamQuery : AbstractStreamingHandlerProcessorForGetStreamQuery`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStreamingHandlerProcessorForGetStreamQuery(ShardedDatabaseRequestHandler requestHandler, HttpMethod method);
    protected virtual RequestTimeTracker GetTimeTracker();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetStreamQuery/<GetDocumentDataAsync>d__2")]
protected virtual ValueTask`1<BlittableJsonReaderObject> GetDocumentDataAsync(TransactionOperationContext context, string fromDocument);
    protected virtual IDisposable AllocateContext(TransactionOperationContext& context);
    protected virtual QueryMetadataCache GetQueryMetadataCache();
    protected virtual IStreamQueryResultWriter`1<BlittableJsonReaderObject> GetBlittableQueryResultWriter(string format, bool isDebug, JsonOperationContext context, HttpResponse response, Stream responseBodyStream, bool fromSharded, String[] propertiesArray, string fileNamePrefix);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetStreamQuery/<ExecuteQueryAsync>d__6")]
private ValueTask`1<ShardedStreamQueryResult> ExecuteQueryAsync(TransactionOperationContext context, IndexQueryServerSide query, string debug, bool ignoreLimit, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetStreamQuery/<ExecuteAndWriteQueryStreamAsync>d__7")]
protected virtual ValueTask ExecuteAndWriteQueryStreamAsync(TransactionOperationContext context, IndexQueryServerSide query, string format, String[] propertiesArray, string fileNamePrefix, bool ignoreLimit, bool _, OperationCancelToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetStreamQuery/<ExecuteAndWriteIndexQueryStreamEntriesAsync>d__8")]
protected virtual ValueTask ExecuteAndWriteIndexQueryStreamEntriesAsync(TransactionOperationContext context, IndexQueryServerSide query, string format, string debug, String[] propertiesArray, string fileNamePrefix, bool ignoreLimit, bool _, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetTimeSeries : AbstractStreamingHandlerProcessorForGetTimeSeries`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStreamingHandlerProcessorForGetTimeSeries(ShardedDatabaseRequestHandler requestHandler);
    protected virtual IDisposable OpenReadTransaction(TransactionOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamingHandlerProcessorForGetTimeSeries/<GetAndWriteTimeSeriesAsync>d__2")]
protected virtual ValueTask GetAndWriteTimeSeriesAsync(TransactionOperationContext context, string docId, string name, DateTime from, DateTime to, Nullable`1<TimeSpan> offset, CancellationToken token);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamQueryOperation : ValueType {
    private HttpContext _httpContext;
    private Func`1<ValueTuple`2<JsonOperationContext, IDisposable>> _allocateJsonContext;
    private IComparer`1<BlittableJsonReaderObject> _comparer;
    private Dictionary`2<int, PostQueryStreamCommand> _queryStreamCommands;
    private long _skip;
    private long _take;
    private CancellationToken _token;
    [CompilerGeneratedAttribute]
private string <ExpectedEtag>k__BackingField;
    public HttpRequest HttpRequest { get; }
    public string ExpectedEtag { get; }
    public ShardedStreamQueryOperation(HttpContext httpContext, Func`1<ValueTuple`2<JsonOperationContext, IDisposable>> allocateJsonContext, IComparer`1<BlittableJsonReaderObject> comparer, Dictionary`2<int, PostQueryStreamCommand> queryStreamCommands, long skip, long take, CancellationToken token);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual RavenCommand`1<StreamResult> CreateCommandForShard(int shardNumber);
    [CompilerGeneratedAttribute]
public string get_ExpectedEtag();
    public sealed virtual ShardedStreamQueryResult Combine(Dictionary`2<int, ShardExecutionResult`1<StreamResult>> results);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamQueryResult : ValueType {
    private MergedEnumerator`1<BlittableJsonReaderObject> _enumerator;
    private long _skip;
    private long _take;
    public StreamQueryStatistics Statistics;
    public ShardedStreamQueryResult(MergedEnumerator`1<BlittableJsonReaderObject> enumerator, long skip, long take, StreamQueryStatistics statistics);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Streaming.ShardedStreamQueryResult/<GetEnumerator>d__5")]
public IEnumerator`1<BlittableJsonReaderObject> GetEnumerator();
    public sealed virtual void Dispose();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Studio.ShardedStudioCollectionFieldsHandlerProcessorForGetCollectionFields : AbstractStudioCollectionFieldsHandlerProcessorForGetCollectionFields`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStudioCollectionFieldsHandlerProcessorForGetCollectionFields(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Studio.ShardedStudioCollectionFieldsHandlerProcessorForGetCollectionFields/<GetFieldsAsync>d__1")]
protected virtual ValueTask`1<Dictionary`2<LazyStringValue, FieldType>> GetFieldsAsync(TransactionOperationContext context, string collection, string prefix);
    protected virtual DocumentsTransaction OpenReadTransaction(TransactionOperationContext context);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Studio.ShardedStudioCollectionHandlerProcessorForDeleteCollection : AbstractStudioCollectionHandlerProcessorForDeleteCollection`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStudioCollectionHandlerProcessorForDeleteCollection(ShardedDatabaseRequestHandler requestHandler);
    protected virtual void ScheduleDeleteCollection(TransactionOperationContext context, IDisposable returnToContextPool, string collectionName, HashSet`1<string> excludeIds, long operationId);
    protected virtual long GetNextOperationId();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Studio.ShardedStudioStatsHandlerProcessorForGetFooterStats : AbstractStudioStatsHandlerProcessorForGetFooterStats`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStudioStatsHandlerProcessorForGetFooterStats(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Studio.ShardedStudioStatsHandlerProcessorForGetFooterStats/<GetFooterStatisticsAsync>d__1")]
protected virtual ValueTask`1<FooterStatistics> GetFooterStatisticsAsync();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionHandlerProcessorForDeleteSubscription : AbstractSubscriptionHandlerProcessorForDeleteSubscription`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedSubscriptionHandlerProcessorForDeleteSubscription(ShardedDatabaseRequestHandler requestHandler);
    public virtual void RaiseNotificationForTaskRemoved(string subscriptionName);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForDropSubscriptionConnection : AbstractSubscriptionsHandlerProcessorForDropSubscriptionConnection`3<ShardedDatabaseRequestHandler, TransactionOperationContext, SubscriptionConnectionsStateOrchestrator> {
    public ShardedSubscriptionsHandlerProcessorForDropSubscriptionConnection(ShardedDatabaseRequestHandler requestHandler);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForGetConnectionDetails : AbstractSubscriptionsHandlerProcessorForGetConnectionDetails`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedSubscriptionsHandlerProcessorForGetConnectionDetails(ShardedDatabaseRequestHandler requestHandler);
    protected virtual SubscriptionConnectionsDetails GetConnectionDetails(ClusterOperationContext context, string subscriptionName);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<SubscriptionConnectionsDetails> command, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForGetResend : AbstractSubscriptionsHandlerProcessorForGetResend`3<ShardedDatabaseRequestHandler, TransactionOperationContext, SubscriptionConnectionsStateOrchestrator> {
    public ShardedSubscriptionsHandlerProcessorForGetResend(ShardedDatabaseRequestHandler requestHandler);
    protected virtual HashSet`1<long> GetActiveBatches(ClusterOperationContext _, SubscriptionState subscriptionState);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForGetSubscription : AbstractSubscriptionsHandlerProcessorForGetSubscription`3<ShardedDatabaseRequestHandler, TransactionOperationContext, ShardedSubscriptionData> {
    public ShardedSubscriptionsHandlerProcessorForGetSubscription(ShardedDatabaseRequestHandler requestHandler);
    protected virtual IEnumerable`1<ShardedSubscriptionData> GetAllSubscriptions(ClusterOperationContext context, int start, int pageSize, bool history, bool running);
    protected virtual ShardedSubscriptionData GetSubscriptionByName(ClusterOperationContext context, bool history, bool running, string name);
    protected virtual ShardedSubscriptionData GetSubscriptionById(ClusterOperationContext context, bool history, bool running, long id);
    protected virtual DynamicJsonValue SubscriptionStateAsJson(ShardedSubscriptionData state);
    private static DynamicJsonArray GetSubscriptionConnectionsJson(List`1<OrchestratedSubscriptionConnection> subscriptionList);
    private static DynamicJsonArray GetShardedWorkersJson(IDictionary`2<string, ShardedSubscriptionWorker> subscriptionList);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForGetSubscriptionState : AbstractSubscriptionsHandlerProcessorForGetSubscriptionState`3<ShardedDatabaseRequestHandler, TransactionOperationContext, SubscriptionConnectionsStateOrchestrator> {
    public ShardedSubscriptionsHandlerProcessorForGetSubscriptionState(ShardedDatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForPerformanceLive : AbstractSubscriptionsHandlerProcessorForPerformanceLive`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedSubscriptionsHandlerProcessorForPerformanceLive(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual string GetDatabaseName();
    protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForPostSubscription : AbstractSubscriptionsHandlerProcessorForPostSubscription`3<ShardedSubscriptionsHandler, TransactionOperationContext, SubscriptionConnectionsStateOrchestrator> {
    public ShardedSubscriptionsHandlerProcessorForPostSubscription(ShardedSubscriptionsHandler requestHandler);
    public virtual ParsedSubscription ParseSubscriptionQuery(string query);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForPostSubscription/<CreateSubscriptionInternalAsync>d__2")]
protected virtual ValueTask CreateSubscriptionInternalAsync(BlittableJsonReaderObject bjro, Nullable`1<long> id, Nullable`1<bool> disabled, SubscriptionCreationOptions options, ClusterOperationContext context);
    protected virtual void SetSubscriptionChangeVectorOnUpdate(SubscriptionUpdateOptions options, SubscriptionState state);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForPutSubscription : AbstractSubscriptionsHandlerProcessorForPutSubscription`2<ShardedSubscriptionsHandler, TransactionOperationContext> {
    public ShardedSubscriptionsHandlerProcessorForPutSubscription(ShardedSubscriptionsHandler requestHandler);
    public virtual ParsedSubscription ParseSubscriptionQuery(string query);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForPutSubscription/<CreateInternalAsync>d__2")]
protected virtual ValueTask CreateInternalAsync(BlittableJsonReaderObject bjro, SubscriptionCreationOptions options, TransactionOperationContext context, Nullable`1<long> id, Nullable`1<bool> disabled);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForTrySubscription : AbstractSubscriptionsHandlerProcessorForTrySubscription`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedSubscriptionsHandlerProcessorForTrySubscription(ShardedDatabaseRequestHandler requestHandler);
    public virtual ParsedSubscription ParseSubscriptionQuery(string query);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.Subscriptions.ShardedSubscriptionsHandlerProcessorForTrySubscription/<TryoutSubscriptionAsync>d__2")]
protected virtual ValueTask TryoutSubscriptionAsync(TransactionOperationContext context, ParsedSubscription subscription, SubscriptionTryout tryout, int pageSize);
    private static void WriteBlittable(BlittableJsonReaderObject bjro, AsyncBlittableJsonTextWriter writer);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Tcp.ShardedTcpManagementHandlerProcessorForDelete : AbstractTcpManagementHandlerProcessorForDelete`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedTcpManagementHandlerProcessorForDelete(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ConcurrentSet`1<TcpConnectionOptions> GetRunningTcpConnections();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.Tcp.ShardedTcpManagementHandlerProcessorForGetAll : AbstractTcpManagementHandlerProcessorForGetAll`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedTcpManagementHandlerProcessorForGetAll(ShardedDatabaseRequestHandler requestHandler);
    protected virtual ConcurrentSet`1<TcpConnectionOptions> GetRunningTcpConnections();
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForGetDebugSegmentsSummary : AbstractTimeSeriesHandlerProcessorForGetDebugSegmentsSummary`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedTimeSeriesHandlerProcessorForGetDebugSegmentsSummary(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForGetDebugSegmentsSummary/<GetSegmentsSummaryAndWriteAsync>d__1")]
protected virtual ValueTask GetSegmentsSummaryAndWriteAsync(TransactionOperationContext context, string docId, string name, DateTime from, DateTime to);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForGetTimeSeries : AbstractTimeSeriesHandlerProcessorForGetTimeSeries`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedTimeSeriesHandlerProcessorForGetTimeSeries(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForGetTimeSeries/<GetTimeSeriesAndWriteAsync>d__1")]
protected virtual ValueTask`1<TimeSeriesRangeResult> GetTimeSeriesAndWriteAsync(TransactionOperationContext context, string docId, string name, DateTime from, DateTime to, int start, int pageSize, bool includeDoc, bool includeTags, bool fullResults);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForGetTimeSeriesRanges : AbstractTimeSeriesHandlerProcessorForGetTimeSeriesRanges`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedTimeSeriesHandlerProcessorForGetTimeSeriesRanges(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForGetTimeSeriesRanges/<GetTimeSeriesRangesAndWriteAsync>d__1")]
protected virtual ValueTask GetTimeSeriesRangesAndWriteAsync(TransactionOperationContext context, string documentId, StringValues names, StringValues fromList, StringValues toList, int start, int pageSize, bool includeDoc, bool includeTags, bool returnFullResults, CancellationToken token);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForGetTimeSeriesStats : AbstractTimeSeriesHandlerProcessorForGetTimeSeriesStats`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedTimeSeriesHandlerProcessorForGetTimeSeriesStats(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForGetTimeSeriesStats/<GetTimeSeriesStatsAndWriteAsync>d__1")]
protected virtual ValueTask GetTimeSeriesStatsAndWriteAsync(TransactionOperationContext context, string docId);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForPostTimeSeries : AbstractTimeSeriesHandlerProcessorForPostTimeSeries`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedTimeSeriesHandlerProcessorForPostTimeSeries(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForPostTimeSeries/<ApplyTimeSeriesOperationAsync>d__1")]
protected virtual ValueTask ApplyTimeSeriesOperationAsync(string docId, TimeSeriesOperation operation, TransactionOperationContext context);
}
internal class Raven.Server.Documents.Sharding.Handlers.Processors.TimeSeries.ShardedTimeSeriesHandlerProcessorForPostTimeSeriesNamesConfiguration : AbstractTimeSeriesHandlerProcessorForPostTimeSeriesNamesConfiguration`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedTimeSeriesHandlerProcessorForPostTimeSeriesNamesConfiguration(ShardedDatabaseRequestHandler requestHandler);
}
public class Raven.Server.Documents.Sharding.Handlers.ReshardingHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ReshardingHandler/<StartResharding>d__0")]
[RavenActionAttribute("/admin/resharding/start", "POST", "1", "False", "False", "True", "0")]
public Task StartResharding();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ReshardingHandler/<GetBucket>d__1")]
[RavenActionAttribute("/debug/sharding/find/bucket", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetBucket();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedAdminTimesSeriesHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAdminTimesSeriesHandler/<AddTimeSeriesPolicy>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/timeseries/policy", "PUT")]
public Task AddTimeSeriesPolicy();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAdminTimesSeriesHandler/<RemoveTimeSeriesPolicy>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/timeseries/policy", "DELETE")]
public Task RemoveTimeSeriesPolicy();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedAllDocumentIdsDebugHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAllDocumentIdsDebugHandler/<ExportAllDocIds>d__0")]
[RavenShardedActionAttribute("/databases/*/debug/documents/export-all-ids", "GET")]
public Task ExportAllDocIds();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedAnalyzersHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAnalyzersHandler/<Get>d__0")]
[RavenShardedActionAttribute("/databases/*/analyzers", "GET")]
public Task Get();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedAttachmentHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAttachmentHandler/<Head>d__0")]
[RavenShardedActionAttribute("/databases/*/attachments", "HEAD")]
public Task Head();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAttachmentHandler/<Delete>d__1")]
[RavenShardedActionAttribute("/databases/*/attachments", "DELETE")]
public Task Delete();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAttachmentHandler/<Exists>d__2")]
[RavenShardedActionAttribute("/databases/*/debug/attachments/hash", "GET")]
public Task Exists();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAttachmentHandler/<GetAttachmentMetadataWithCounts>d__3")]
[RavenShardedActionAttribute("/databases/*/debug/attachments/metadata", "GET")]
public Task GetAttachmentMetadataWithCounts();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAttachmentHandler/<Put>d__4")]
[RavenShardedActionAttribute("/databases/*/attachments", "PUT")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAttachmentHandler/<Get>d__5")]
[RavenShardedActionAttribute("/databases/*/attachments", "GET")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAttachmentHandler/<GetPost>d__6")]
[RavenShardedActionAttribute("/databases/*/attachments", "POST")]
public Task GetPost();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedAttachmentHandler/<GetAttachments>d__7")]
[RavenShardedActionAttribute("/databases/*/attachments/bulk", "POST")]
public Task GetAttachments();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedChangesHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedChangesHandler/<GetChanges>d__0")]
[RavenShardedActionAttribute("/databases/*/changes", "GET")]
public Task GetChanges();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedChangesHandler/<GetConnectionsDebugInfo>d__1")]
[RavenShardedActionAttribute("/databases/*/changes/debug", "GET")]
public Task GetConnectionsDebugInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedChangesHandler/<DeleteConnections>d__2")]
[RavenShardedActionAttribute("/databases/*/changes", "DELETE")]
public Task DeleteConnections();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedCollectionHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedCollectionHandler/<GetCollectionStats>d__0")]
[RavenShardedActionAttribute("/databases/*/collections/stats", "GET")]
public Task GetCollectionStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedCollectionHandler/<GetDetailedCollectionStats>d__1")]
[RavenShardedActionAttribute("/databases/*/collections/stats/detailed", "GET")]
public Task GetDetailedCollectionStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedCollectionHandler/<GetCollectionDocuments>d__2")]
[RavenShardedActionAttribute("/databases/*/collections/docs", "GET")]
public Task GetCollectionDocuments();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedCollectionHandler/<GetLastDocumentChangeVectorForCollection>d__3")]
[RavenShardedActionAttribute("/databases/*/collections/last-change-vector", "GET")]
public Task GetLastDocumentChangeVectorForCollection();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedCompareExchangeHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedCompareExchangeHandler/<GetCompareExchangeValues>d__0")]
[RavenShardedActionAttribute("/databases/*/cmpxchg", "GET")]
public Task GetCompareExchangeValues();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedCompareExchangeHandler/<PutCompareExchangeValue>d__1")]
[RavenShardedActionAttribute("/databases/*/cmpxchg", "PUT")]
public Task PutCompareExchangeValue();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedCompareExchangeHandler/<DeleteCompareExchangeValue>d__2")]
[RavenShardedActionAttribute("/databases/*/cmpxchg", "DELETE")]
public Task DeleteCompareExchangeValue();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedConfigurationHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedConfigurationHandler/<GetStudioConfiguration>d__0")]
[RavenShardedActionAttribute("/databases/*/configuration/studio", "GET")]
public Task GetStudioConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedConfigurationHandler/<GetClientConfiguration>d__1")]
[RavenShardedActionAttribute("/databases/*/configuration/client", "GET")]
public Task GetClientConfiguration();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedCountersHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedCountersHandler/<Get>d__0")]
[RavenShardedActionAttribute("/databases/*/counters", "GET")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedCountersHandler/<Batch>d__1")]
[RavenShardedActionAttribute("/databases/*/counters", "POST")]
public Task Batch();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedDataArchivalHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDataArchivalHandler/<GetDataArchivalConfig>d__0")]
[RavenShardedActionAttribute("/databases/*/data-archival/config", "GET")]
public Task GetDataArchivalConfig();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDataArchivalHandler/<ConfigDataArchival>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/data-archival/config", "POST")]
public Task ConfigDataArchival();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseDebugInfoPackageHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseDebugInfoPackageHandler/<GetInfoPackage>d__0")]
[RavenShardedActionAttribute("/databases/*/debug/info-package", "GET")]
public Task GetInfoPackage();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseNotificationCenterHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseNotificationCenterHandler/<Get>d__0")]
[RavenShardedActionAttribute("/databases/*/notification-center/watch", "GET")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseNotificationCenterHandler/<Dismiss>d__1")]
[RavenShardedActionAttribute("/databases/*/notification-center/dismiss", "POST")]
public Task Dismiss();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseNotificationCenterHandler/<Postpone>d__2")]
[RavenShardedActionAttribute("/databases/*/notification-center/postpone", "POST")]
public Task Postpone();
}
public abstract class Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseRequestHandler : AbstractDatabaseRequestHandler`1<TransactionOperationContext> {
    public ShardedDatabaseContext DatabaseContext;
    public HttpMethod Method;
    public string RelativeShardUrl;
    public string BaseShardUrl;
    public ShardedContinuationTokensHandler ContinuationTokens;
    public static List`1<string> HeadersToCopy;
    public ShardExecutor ShardExecutor { get; }
    public string DatabaseName { get; }
    public char IdentityPartsSeparator { get; }
    private static ShardedDatabaseRequestHandler();
    public ShardExecutor get_ShardExecutor();
    private void ModifyHeaders(HttpRequestMessage request);
    public Task`1<TResult> ExecuteSingleShardAsync(JsonOperationContext context, RavenCommand`1<TResult> command, int shardNumber, CancellationToken token);
    public void InitForOfflineOperation(RequestHandlerContext context);
    public virtual void Init(RequestHandlerContext context);
    public virtual Task CheckForChanges(RequestHandlerContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseRequestHandler/<WaitForIndexToBeAppliedAsync>d__15")]
public virtual Task WaitForIndexToBeAppliedAsync(TransactionOperationContext context, long index);
    public virtual bool IsShutdownRequested();
    [DoesNotReturnAttribute]
public virtual void ThrowShutdownException(Exception inner);
    public virtual OperationCancelToken CreateHttpRequestBoundTimeLimitedOperationToken();
    public virtual OperationCancelToken CreateHttpRequestBoundTimeLimitedOperationTokenForQuery();
    public virtual OperationCancelToken CreateHttpRequestBoundTimeLimitedOperationToken(TimeSpan cancelAfter);
    public virtual OperationCancelToken CreateHttpRequestBoundOperationToken();
    public virtual OperationCancelToken CreateTimeLimitedBackgroundOperationTokenForQueryOperation();
    public virtual OperationCancelToken CreateTimeLimitedBackgroundOperationTokenForCollectionOperation();
    public virtual OperationCancelToken CreateTimeLimitedBackgroundOperationToken();
    public virtual OperationCancelToken CreateBackgroundOperationToken();
    public virtual string get_DatabaseName();
    public virtual char get_IdentityPartsSeparator();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseRequestHandler/<WaitForIndexNotificationAsync>d__30")]
public virtual Task WaitForIndexNotificationAsync(long index);
    public virtual bool ShouldAddPagingPerformanceHint(long numberOfResults);
    public virtual void AddPagingPerformanceHint(PagingOperationType operation, string action, string details, long numberOfResults, long pageSize, long duration, long totalDocumentsSizeInBytes);
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseTcpConnectionInfoHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDatabaseTcpConnectionInfoHandler/<Get>d__0")]
[RavenShardedActionAttribute("/databases/*/info/tcp", "GET")]
public Task Get();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedDocumentDebugHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentDebugHandler/<HugeDocuments>d__0")]
[RavenShardedActionAttribute("/databases/*/debug/documents/huge", "GET")]
public Task HugeDocuments();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedDocumentHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentHandler/<Head>d__0")]
[RavenShardedActionAttribute("/databases/*/docs", "HEAD")]
public Task Head();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentHandler/<GetDocSize>d__1")]
[RavenShardedActionAttribute("/databases/*/docs/size", "GET")]
public Task GetDocSize();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentHandler/<Get>d__2")]
[RavenShardedActionAttribute("/databases/*/docs", "GET")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentHandler/<PostGet>d__3")]
[RavenShardedActionAttribute("/databases/*/docs", "POST")]
public Task PostGet();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentHandler/<Delete>d__4")]
[RavenShardedActionAttribute("/databases/*/docs", "DELETE")]
public Task Delete();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentHandler/<Put>d__5")]
[RavenShardedActionAttribute("/databases/*/docs", "PUT")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentHandler/<Patch>d__6")]
[RavenShardedActionAttribute("/databases/*/docs", "PATCH")]
public Task Patch();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentHandler/<GenerateClassFromDocument>d__7")]
[RavenShardedActionAttribute("/databases/*/docs/class", "GET")]
public Task GenerateClassFromDocument();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedDocumentsCompressionHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentsCompressionHandler/<GetDocumentsCompressionConfig>d__0")]
[RavenShardedActionAttribute("/databases/*/documents-compression/config", "GET")]
public Task GetDocumentsCompressionConfig();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedDocumentsCompressionHandler/<ConfigDocumentsCompression>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/documents-compression/config", "POST")]
public Task ConfigDocumentsCompression();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedElasticSearchEtlConnectionHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedElasticSearchEtlConnectionHandler/<TestConnection>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/etl/elasticsearch/test-connection", "POST")]
public Task TestConnection();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedElasticSearchEtlHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedElasticSearchEtlHandler/<Test>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/etl/elasticsearch/test", "POST")]
public Task Test();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedEtlHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedEtlHandler/<Stats>d__0")]
[RavenShardedActionAttribute("/databases/*/etl/stats", "GET")]
public Task Stats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedEtlHandler/<DebugStats>d__1")]
[RavenShardedActionAttribute("/databases/*/etl/debug/stats", "GET")]
public Task DebugStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedEtlHandler/<Performance>d__2")]
[RavenShardedActionAttribute("/databases/*/etl/performance", "GET")]
public Task Performance();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedEtlHandler/<PerformanceLive>d__3")]
[RavenShardedActionAttribute("/databases/*/etl/performance/live", "GET")]
public Task PerformanceLive();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedEtlHandler/<Progress>d__4")]
[RavenShardedActionAttribute("/databases/*/etl/progress", "GET")]
public Task Progress();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedExpirationHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedExpirationHandler/<GetExpirationConfig>d__0")]
[RavenShardedActionAttribute("/databases/*/expiration/config", "GET")]
public Task GetExpirationConfig();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedExpirationHandler/<ConfigExpiration>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/expiration/config", "POST")]
public Task ConfigExpiration();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedHiLoHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedHiLoHandler/<GetNextHiLo>d__0")]
[RavenShardedActionAttribute("/databases/*/hilo/next", "GET")]
public Task GetNextHiLo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedHiLoHandler/<ReturnHiLo>d__1")]
[RavenShardedActionAttribute("/databases/*/hilo/return", "PUT")]
public Task ReturnHiLo();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedIdentityDebugHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIdentityDebugHandler/<GetIdentities>d__0")]
[RavenShardedActionAttribute("/databases/*/debug/identities", "GET")]
public Task GetIdentities();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedIdentityHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIdentityHandler/<NextIdentityFor>d__0")]
[RavenShardedActionAttribute("/databases/*/identity/next", "POST")]
public Task NextIdentityFor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIdentityHandler/<SeedIdentityFor>d__1")]
[RavenShardedActionAttribute("/databases/*/identity/seed", "POST")]
public Task SeedIdentityFor();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedIncomingReplicationHandler : AbstractIncomingReplicationHandler`2<TransactionContextPool, TransactionOperationContext> {
    private ShardedReplicationContext _parent;
    private string _sourceShardedDatabaseId;
    private string _sourceShardedDatabaseName;
    private bool _shardedSource;
    private Dictionary`2<int, ShardedOutgoingReplicationHandler> _handlers;
    private string _lastAcceptedChangeVector;
    private Dictionary`2<int, long> _lastSentEtagPerDestination;
    private string _lastAcceptedChangeVectorDuringHeartbeat;
    private DocumentInfoHelper _documentInfoHelper;
    public ShardedIncomingReplicationHandler(TcpConnectionOptions tcpConnectionOptions, ShardedReplicationContext parent, MemoryBuffer buffer, ReplicationLatestEtagRequest replicatedLastEtag);
    public StreamsTempFile GetTempFile();
    private TcpConnectionInfo GetConnectionInfo(ShardReplicationNode node);
    protected virtual void EnsureNotDeleted();
    protected virtual void InvokeOnFailed(Exception exception);
    protected virtual void HandleHeartbeatMessage(TransactionOperationContext jsonOperationContext, BlittableJsonReaderObject blittableJsonReaderObject);
    protected virtual DynamicJsonValue GetHeartbeatStatusMessage(TransactionOperationContext context, long lastDocumentEtag, string handledMessageType);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIncomingReplicationHandler/<GetInitialHandshakeResponseFromShardsAsync>d__15")]
internal Task`1<ValueTuple`2<string, long>> GetInitialHandshakeResponseFromShardsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIncomingReplicationHandler/<HandleNonShardedSourceAsync>d__16")]
private Task`1<ValueTuple`2<string, long>> HandleNonShardedSourceAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIncomingReplicationHandler/<HandleShardedSourceAsync>d__17")]
private Task`1<ValueTuple`2<string, long>> HandleShardedSourceAsync();
    protected virtual void OnDocumentsReceived();
    protected virtual void InvokeOnAttachmentStreamsReceived(int attachmentStreamCount);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIncomingReplicationHandler/<HandleBatchAsync>d__20")]
protected virtual Task HandleBatchAsync(TransactionOperationContext context, DataForReplicationCommand<TransactionContextPool, TransactionOperationContext> dataForReplicationCommand, long lastEtag);
    private ReplicationBatches PrepareReplicationDataForShards(TransactionOperationContext context, DataForReplicationCommand<TransactionContextPool, TransactionOperationContext> dataForReplicationCommand);
    private void EnsureNotNullAttachmentStreams(Dictionary`2<int, ReplicationBatch> batches);
    public virtual ReplicationPerformanceType GetReplicationPerformanceType();
    protected virtual ByteStringContext GetContextAllocator(TransactionOperationContext context);
    protected virtual RavenConfiguration GetConfiguration();
    protected virtual int GetNextReplicationStatsId();
    private int GetShardNumberForReplicationItem(TransactionOperationContext context, ReplicationBatchItem item);
    protected virtual void DisposeInternal();
    [CompilerGeneratedAttribute]
private void <DisposeInternal>b__29_0(KeyValuePair`2<int, ShardedOutgoingReplicationHandler> instance);
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Replace>d__0")]
[RavenShardedActionAttribute("/databases/*/indexes/replace", "POST")]
public Task Replace();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<GetAll>d__1")]
[RavenShardedActionAttribute("/databases/*/indexes", "GET")]
public Task GetAll();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Stats>d__2")]
[RavenShardedActionAttribute("/databases/*/indexes/stats", "GET")]
public Task Stats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Stale>d__3")]
[RavenShardedActionAttribute("/databases/*/indexes/staleness", "GET")]
public Task Stale();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Progress>d__4")]
[RavenShardedActionAttribute("/databases/*/indexes/progress", "GET")]
public Task Progress();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Reset>d__5")]
[RavenShardedActionAttribute("/databases/*/indexes", "RESET")]
public Task Reset();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<SetLockMode>d__6")]
[RavenShardedActionAttribute("/databases/*/indexes/set-lock", "POST")]
public Task SetLockMode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<SetPriority>d__7")]
[RavenShardedActionAttribute("/databases/*/indexes/set-priority", "POST")]
public Task SetPriority();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<ClearErrors>d__8")]
[RavenShardedActionAttribute("/databases/*/indexes/errors", "DELETE")]
public Task ClearErrors();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<GetErrors>d__9")]
[RavenShardedActionAttribute("/databases/*/indexes/errors", "GET")]
public Task GetErrors();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Status>d__10")]
[RavenShardedActionAttribute("/databases/*/indexes/status", "GET")]
public Task Status();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<OpenFaultyIndex>d__11")]
[RavenShardedActionAttribute("/databases/*/index/open-faulty-index", "POST")]
public Task OpenFaultyIndex();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Delete>d__12")]
[RavenShardedActionAttribute("/databases/*/indexes", "DELETE")]
public Task Delete();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<GenerateCSharpIndexDefinition>d__13")]
[RavenShardedActionAttribute("/databases/*/indexes/c-sharp-index-definition", "GET")]
public Task GenerateCSharpIndexDefinition();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<GetIndexHistory>d__14")]
[RavenShardedActionAttribute("/databases/*/indexes/history", "GET")]
public Task GetIndexHistory();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<HasChanged>d__15")]
[RavenShardedActionAttribute("/databases/*/indexes/has-changed", "POST")]
public Task HasChanged();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Debug>d__16")]
[RavenShardedActionAttribute("/databases/*/indexes/debug", "GET")]
public Task Debug();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Source>d__17")]
[RavenShardedActionAttribute("/databases/*/indexes/source", "GET")]
public Task Source();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Performance>d__18")]
[RavenShardedActionAttribute("/databases/*/indexes/performance", "GET")]
public Task Performance();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<PerformanceLive>d__19")]
[RavenShardedActionAttribute("/databases/*/indexes/performance/live", "GET")]
public Task PerformanceLive();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<Terms>d__20")]
[RavenShardedActionAttribute("/databases/*/indexes/terms", "GET")]
public Task Terms();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<TotalTime>d__21")]
[RavenShardedActionAttribute("/databases/*/indexes/total-time", "GET")]
public Task TotalTime();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<SuggestIndexMerge>d__22")]
[RavenShardedActionAttribute("/databases/*/indexes/suggest-index-merge", "GET")]
public Task SuggestIndexMerge();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<TestJavaScriptIndex>d__23")]
[RavenShardedActionAttribute("/databases/*/indexes/try", "POST")]
public Task TestJavaScriptIndex();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<FinishRolling>d__24")]
[RavenShardedActionAttribute("/databases/*/indexes/finish-rolling", "POST")]
public Task FinishRolling();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIndexHandler/<ConvertAutoIndex>d__25")]
[RavenShardedActionAttribute("/databases/*/indexes/auto/convert", "GET")]
public Task ConvertAutoIndex();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedIoMetricsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIoMetricsHandler/<Live>d__0")]
[RavenShardedActionAttribute("/databases/*/debug/io-metrics/live", "GET")]
public Task Live();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedIoMetricsHandler/<Get>d__1")]
[RavenShardedActionAttribute("/databases/*/debug/io-metrics", "GET")]
public Task Get();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedJsonPatchHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedJsonPatchHandler/<DocOperations>d__0")]
[RavenShardedActionAttribute("/databases/*/json-patch", "PATCH")]
public Task DocOperations();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedLegacyReplicationHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedLegacyReplicationHandler/<LastEtag>d__0")]
[RavenShardedActionAttribute("/databases/*/replication/lastEtag", "GET")]
public Task LastEtag();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedLegacyReplicationHandler/<Documents>d__1")]
[RavenShardedActionAttribute("/databases/*/replication/replicateDocs", "POST")]
public Task Documents();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedLegacyReplicationHandler/<Attachments>d__2")]
[RavenShardedActionAttribute("/databases/*/replication/replicateAttachments", "POST")]
public Task Attachments();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedLegacyReplicationHandler/<Heartbeat>d__3")]
[RavenShardedActionAttribute("/databases/*/replication/heartbeat", "POST")]
public Task Heartbeat();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedLegacyReplicationHandler/<LastQueried>d__4")]
[RavenShardedActionAttribute("/databases/*/indexes/last-queried", "POST")]
public Task LastQueried();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedLegacyReplicationHandler/<SideBySideIndexes>d__5")]
[RavenShardedActionAttribute("/databases/*/side-by-side-indexes", "PUT")]
public Task SideBySideIndexes();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedLegacyReplicationHandler/<PutTransformer>d__6")]
[RavenShardedActionAttribute("/databases/*/transformers/$", "PUT")]
public Task PutTransformer();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedLegacyReplicationHandler/<DeleteTransformer>d__7")]
[RavenShardedActionAttribute("/databases/*/transformers/$", "DELETE")]
public Task DeleteTransformer();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedMultiGetHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedMultiGetHandler/<Post>d__0")]
[RavenShardedActionAttribute("/databases/*/multi_get", "POST")]
public Task Post();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedOlapEtlHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOlapEtlHandler/<PostScriptTest>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/etl/olap/test", "POST")]
public Task PostScriptTest();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<GetOngoingTasks>d__0")]
[RavenShardedActionAttribute("/databases/*/tasks", "GET")]
public Task GetOngoingTasks();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<PutConnectionString>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/connection-strings", "PUT")]
public Task PutConnectionString();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<GetConnectionStrings>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/connection-strings", "GET")]
public Task GetConnectionStrings();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<RemoveConnectionString>d__3")]
[RavenShardedActionAttribute("/databases/*/admin/connection-strings", "DELETE")]
public Task RemoveConnectionString();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<AddEtl>d__4")]
[RavenShardedActionAttribute("/databases/*/admin/etl", "PUT")]
public Task AddEtl();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<ResetEtl>d__5")]
[RavenShardedActionAttribute("/databases/*/admin/etl", "RESET")]
public Task ResetEtl();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<DeleteSubscriptionTask>d__6")]
[RavenShardedActionAttribute("/databases/*/subscription-tasks", "DELETE")]
public Task DeleteSubscriptionTask();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<DeleteOngoingTask>d__7")]
[RavenShardedActionAttribute("/databases/*/admin/tasks", "DELETE")]
public Task DeleteOngoingTask();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<ToggleSubscriptionTaskState>d__8")]
[RavenShardedActionAttribute("/databases/*/subscription-tasks/state", "POST")]
public Task ToggleSubscriptionTaskState();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<ToggleTaskState>d__9")]
[RavenShardedActionAttribute("/databases/*/admin/tasks/state", "POST")]
public Task ToggleTaskState();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<GetOngoingTaskInfo>d__10")]
[RavenShardedActionAttribute("/databases/*/task", "GET")]
public Task GetOngoingTaskInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<UpdatePeriodicBackup>d__11")]
[RavenShardedActionAttribute("/databases/*/admin/periodic-backup", "POST")]
public Task UpdatePeriodicBackup();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<GetConfiguration>d__12")]
[RavenShardedActionAttribute("/databases/*/admin/periodic-backup/config", "GET")]
public Task GetConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<GetPeriodicBackupTimers>d__13")]
[RavenShardedActionAttribute("/databases/*/admin/debug/periodic-backup/timers", "GET")]
public Task GetPeriodicBackupTimers();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<FullBackupDataDirectory>d__14")]
[RavenShardedActionAttribute("/databases/*/admin/backup-data-directory", "GET")]
public Task FullBackupDataDirectory();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<UpdateExternalReplication>d__15")]
[RavenShardedActionAttribute("/databases/*/admin/tasks/external-replication", "POST")]
public Task UpdateExternalReplication();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<GetHubTasksInfo>d__16")]
[RavenShardedActionAttribute("/databases/*/tasks/pull-replication/hub", "GET")]
public Task GetHubTasksInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<BackupDatabase>d__17")]
[RavenShardedActionAttribute("/databases/*/admin/backup/database", "POST")]
public Task BackupDatabase();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<BackupDatabaseOnce>d__18")]
[RavenShardedActionAttribute("/databases/*/admin/backup", "POST")]
public Task BackupDatabaseOnce();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOngoingTasksHandler/<AddQueueSink>d__19")]
[RavenShardedActionAttribute("/databases/*/admin/queue-sink", "PUT")]
public Task AddQueueSink();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedOperationsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOperationsHandler/<GetNextOperationId>d__0")]
[RavenShardedActionAttribute("/databases/*/operations/next-operation-id", "GET")]
public Task GetNextOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOperationsHandler/<Kill>d__1")]
[RavenShardedActionAttribute("/databases/*/operations/kill", "POST")]
public Task Kill();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOperationsHandler/<GetAll>d__2")]
[RavenShardedActionAttribute("/databases/*/operations", "GET")]
public Task GetAll();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedOperationsHandler/<State>d__3")]
[RavenShardedActionAttribute("/databases/*/operations/state", "GET")]
public Task State();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedOutgoingReplicationHandler : AbstractOutgoingReplicationHandler`2<TransactionContextPool, TransactionOperationContext> {
    private string _sourceDatabaseId;
    private ShardedReplicationContext _parent;
    private BlockingCollection`1<ReplicationBatch> _batches;
    private Byte[] _tempBuffer;
    private long _lastEtag;
    private TaskCompletionSource`1<ValueTuple`2<string, long>> _firstChangeVector;
    public string DestinationDatabaseName;
    [CompilerGeneratedAttribute]
private string <MissingAttachmentMessage>k__BackingField;
    public string MissingAttachmentMessage { get; public set; }
    public ShardedOutgoingReplicationHandler(ShardedReplicationContext parent, ShardReplicationNode node, TcpConnectionInfo connectionInfo, string sourceDatabaseId);
    [CompilerGeneratedAttribute]
public string get_MissingAttachmentMessage();
    [CompilerGeneratedAttribute]
public void set_MissingAttachmentMessage(string value);
    protected virtual void Replicate();
    private void SendDocumentsBatch(TransactionOperationContext context, ReplicationBatch batch, OutgoingReplicationStatsScope stats);
    protected virtual void UpdateDestinationChangeVectorHeartbeat(ReplicationMessageReply replicationBatchReply);
    public Task`1<ValueTuple`2<string, long>> GetFirstChangeVectorFromShardAsync();
    protected virtual DynamicJsonValue GetInitialHandshakeRequest();
    protected virtual void AddAlertOnFailureToReachOtherSide(string msg, Exception e);
    protected virtual void InitiatePullReplicationAsSink(SupportedFeatures socketResultSupportedFeatures, X509Certificate2 certificate);
    protected virtual void AssertDatabaseNotDisposed();
    protected virtual X509Certificate2 GetCertificateForReplication(ReplicationNode destination, AuthorizationInfo& authorizationInfo);
    protected virtual void OnBeforeDispose();
    protected virtual void OnSuccessfulTwoWaysCommunication();
    protected virtual void OnFailed(Exception e);
    protected virtual long GetLastHeartbeatTicks();
    public Task SendBatch(ReplicationBatch batch);
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedPerformanceMetricsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedPerformanceMetricsHandler/<IoMetrics>d__0")]
[RavenShardedActionAttribute("/databases/*/debug/perf-metrics", "GET")]
public Task IoMetrics();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedPullReplicationHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedPullReplicationHandler/<UpdatePullReplicationOnSinkNode>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/tasks/sink-pull-replication", "POST")]
public Task UpdatePullReplicationOnSinkNode();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedPullReplicationHandler/<DefineHub>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/tasks/pull-replication/hub", "PUT")]
public Task DefineHub();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedPullReplicationHandler/<GeneratePullReplicationCertificate>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/pull-replication/generate-certificate", "POST")]
public Task GeneratePullReplicationCertificate();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedPullReplicationHandler/<RegisterHubAccess>d__3")]
[RavenShardedActionAttribute("/databases/*/admin/tasks/pull-replication/hub/access", "PUT")]
public Task RegisterHubAccess();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedPullReplicationHandler/<ListHubAccess>d__4")]
[RavenShardedActionAttribute("/databases/*/admin/tasks/pull-replication/hub/access", "GET")]
public Task ListHubAccess();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedPullReplicationHandler/<UnregisterHubAccess>d__5")]
[RavenShardedActionAttribute("/databases/*/admin/tasks/pull-replication/hub/access", "DELETE")]
public Task UnregisterHubAccess();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedQueriesDebugHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueriesDebugHandler/<KillQuery>d__0")]
[RavenShardedActionAttribute("/databases/*/debug/queries/kill", "POST")]
public Task KillQuery();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueriesDebugHandler/<RunningQueries>d__1")]
[RavenShardedActionAttribute("/databases/*/debug/queries/running", "GET")]
public Task RunningQueries();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueriesDebugHandler/<QueriesCacheList>d__2")]
[RavenShardedActionAttribute("/databases/*/debug/queries/cache/list", "GET")]
public Task QueriesCacheList();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedQueriesHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueriesHandler/<Post>d__0")]
[RavenShardedActionAttribute("/databases/*/queries", "POST")]
public Task Post();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueriesHandler/<Get>d__1")]
[RavenShardedActionAttribute("/databases/*/queries", "GET")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueriesHandler/<Patch>d__2")]
[RavenShardedActionAttribute("/databases/*/queries", "PATCH")]
public Task Patch();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueriesHandler/<PatchTest>d__3")]
[RavenShardedActionAttribute("/databases/*/queries/test", "PATCH")]
public Task PatchTest();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueriesHandler/<Delete>d__4")]
[RavenShardedActionAttribute("/databases/*/queries", "DELETE")]
public Task Delete();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedQueueEtlConnectionHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueueEtlConnectionHandler/<GetTestKafkaConnectionResult>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/etl/queue/kafka/test-connection", "POST")]
public Task GetTestKafkaConnectionResult();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueueEtlConnectionHandler/<GetTestRabbitMqConnectionResult>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/etl/queue/rabbitmq/test-connection", "POST")]
public Task GetTestRabbitMqConnectionResult();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueueEtlConnectionHandler/<GetTestAzureQueueStorageConnectionResult>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/etl/queue/azurequeuestorage/test-connection", "POST")]
public Task GetTestAzureQueueStorageConnectionResult();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedQueueEtlHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedQueueEtlHandler/<PostScriptTest>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/etl/queue/test", "POST")]
public Task PostScriptTest();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedRachisDatabaseHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRachisDatabaseHandler/<WaitFor>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/rachis/wait-for-index-notifications", "POST")]
public Task WaitFor();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedRavenEtlHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRavenEtlHandler/<PostScriptTest>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/etl/raven/test", "POST")]
public Task PostScriptTest();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedRefreshHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRefreshHandler/<GetRefreshConfiguration>d__0")]
[RavenShardedActionAttribute("/databases/*/refresh/config", "GET")]
public Task GetRefreshConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRefreshHandler/<PostRefreshConfiguration>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/refresh/config", "POST")]
public Task PostRefreshConfiguration();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<GetConflictSolver>d__0")]
[RavenShardedActionAttribute("/databases/*/replication/conflicts/solver", "GET")]
public Task GetConflictSolver();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<GetReplicationConflicts>d__1")]
[RavenShardedActionAttribute("/databases/*/replication/conflicts", "GET")]
public Task GetReplicationConflicts();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<GetAllTombstones>d__2")]
[RavenShardedActionAttribute("/databases/*/replication/tombstones", "GET")]
public Task GetAllTombstones();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<Performance>d__3")]
[RavenShardedActionAttribute("/databases/*/replication/performance", "GET")]
public Task Performance();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<GetReplicationActiveConnections>d__4")]
[RavenShardedActionAttribute("/databases/*/replication/active-connections", "GET")]
public Task GetReplicationActiveConnections();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<PerformanceLive>d__5")]
[RavenShardedActionAttribute("/databases/*/replication/performance/live", "GET")]
public Task PerformanceLive();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<PulsesLive>d__6")]
[RavenShardedActionAttribute("/databases/*/replication/pulses/live", "GET")]
public Task PulsesLive();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<GetReplicationOutgoingFailureStats>d__7")]
[RavenShardedActionAttribute("/databases/*/replication/debug/outgoing-failures", "GET")]
public Task GetReplicationOutgoingFailureStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<GetReplicationIncomingActivityTimes>d__8")]
[RavenShardedActionAttribute("/databases/*/replication/debug/incoming-last-activity-time", "GET")]
public Task GetReplicationIncomingActivityTimes();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<GetReplicationIncomingRejectionInfo>d__9")]
[RavenShardedActionAttribute("/databases/*/replication/debug/incoming-rejection-info", "GET")]
public Task GetReplicationIncomingRejectionInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedReplicationHandler/<GetReplicationReconnectionQueue>d__10")]
[RavenShardedActionAttribute("/databases/*/replication/debug/outgoing-reconnect-queue", "GET")]
public Task GetReplicationReconnectionQueue();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler/<GetRevisionsFor>d__0")]
[RavenShardedActionAttribute("/databases/*/revisions", "GET")]
public Task GetRevisionsFor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler/<GetRevisionsCountFor>d__1")]
[RavenShardedActionAttribute("/databases/*/revisions/count", "GET")]
public Task GetRevisionsCountFor();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler/<PostRevisionsConfiguration>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/revisions/config", "POST")]
public Task PostRevisionsConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler/<GetRevisionsConfiguration>d__3")]
[RavenShardedActionAttribute("/databases/*/revisions/config", "GET")]
public Task GetRevisionsConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler/<GetRevisionsBin>d__4")]
[RavenShardedActionAttribute("/databases/*/revisions/bin", "GET")]
public Task GetRevisionsBin();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler/<GetConflictRevisionsConfig>d__5")]
[RavenShardedActionAttribute("/databases/*/revisions/conflicts/config", "GET")]
public Task GetConflictRevisionsConfig();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler/<Revert>d__6")]
[RavenShardedActionAttribute("/databases/*/revisions/revert", "POST")]
public Task Revert();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler/<RevertDocument>d__7")]
[RavenShardedActionAttribute("/databases/*/revisions/revert/docs", "POST")]
public Task RevertDocument();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler/<GetResolvedConflictsSince>d__8")]
[RavenShardedActionAttribute("/databases/*/revisions/resolved", "GET")]
public Task GetResolvedConflictsSince();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedRevisionsHandler/<GetRevisions>d__9")]
[RavenShardedActionAttribute("/databases/*/debug/documents/get-revisions", "GET")]
public Task GetRevisions();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedSampleDataHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSampleDataHandler/<CreateSampleData>d__0")]
[RavenShardedActionAttribute("/databases/*/studio/sample-data", "POST")]
public Task CreateSampleData();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSampleDataHandler/<GetSampleDataClasses>d__1")]
[RavenShardedActionAttribute("/databases/*/studio/sample-data/classes", "GET")]
public Task GetSampleDataClasses();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedScriptRunnersDebugInfoHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedScriptRunnersDebugInfoHandler/<GetJSDebugInfo>d__0")]
[RavenShardedActionAttribute("/databases/*/debug/script-runners", "GET")]
public Task GetJSDebugInfo();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler/<ValidateOptions>d__0")]
[RavenShardedActionAttribute("/databases/*/smuggler/validate-options", "POST")]
public Task ValidateOptions();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler/<PostExport>d__1")]
[RavenShardedActionAttribute("/databases/*/smuggler/export", "POST")]
public Task PostExport();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler/<PostImportAsync>d__2")]
[RavenShardedActionAttribute("/databases/*/smuggler/import", "POST")]
public Task PostImportAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler/<PostImportDirectory>d__3")]
[RavenShardedActionAttribute("/databases/*/admin/smuggler/import-dir", "GET")]
public Task PostImportDirectory();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler/<GetImport>d__4")]
[RavenShardedActionAttribute("/databases/*/admin/smuggler/import", "GET")]
public Task GetImport();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler/<PostImportFromS3Directory>d__5")]
[RavenShardedActionAttribute("/databases/*/admin/smuggler/import-s3-dir", "GET")]
public Task PostImportFromS3Directory();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler/<MigrateFromRavenDB>d__6")]
[RavenShardedActionAttribute("/databases/*/admin/smuggler/migrate/ravendb", "POST")]
public Task MigrateFromRavenDB();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler/<GetMigratedServerUrls>d__7")]
[RavenShardedActionAttribute("/databases/*/migrate/get-migrated-server-urls", "GET")]
public Task GetMigratedServerUrls();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler/<MigrateFromAnotherDatabase>d__8")]
[RavenShardedActionAttribute("/databases/*/admin/smuggler/migrate", "POST")]
public Task MigrateFromAnotherDatabase();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSmugglerHandler/<ImportFromCsv>d__9")]
[RavenShardedActionAttribute("/databases/*/smuggler/import/csv", "POST")]
public Task ImportFromCsv();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedSortersHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSortersHandler/<Get>d__0")]
[RavenShardedActionAttribute("/databases/*/sorters", "GET")]
public Task Get();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedSqlEtlHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSqlEtlHandler/<TestConnection>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/etl/sql/test-connection", "POST")]
public Task TestConnection();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSqlEtlHandler/<Test>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/etl/sql/test", "POST")]
public Task Test();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedStatsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStatsHandler/<EssentialStats>d__0")]
[RavenShardedActionAttribute("/databases/*/stats/essential", "GET")]
public Task EssentialStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStatsHandler/<DetailedStats>d__1")]
[RavenShardedActionAttribute("/databases/*/stats/detailed", "GET")]
public Task DetailedStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStatsHandler/<Stats>d__2")]
[RavenShardedActionAttribute("/databases/*/stats", "GET")]
public Task Stats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStatsHandler/<DatabaseHealthCheck>d__3")]
[RavenShardedActionAttribute("/databases/*/healthcheck", "GET")]
public Task DatabaseHealthCheck();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStatsHandler/<Metrics>d__4")]
[RavenShardedActionAttribute("/databases/*/metrics", "GET")]
public Task Metrics();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStatsHandler/<PutsMetrics>d__5")]
[RavenShardedActionAttribute("/databases/*/metrics/puts", "GET")]
public Task PutsMetrics();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStatsHandler/<BytesMetrics>d__6")]
[RavenShardedActionAttribute("/databases/*/metrics/bytes", "GET")]
public Task BytesMetrics();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStatsHandler/<ValidateUnusedIds>d__7")]
[RavenShardedActionAttribute("/databases/*/admin/validate-unused-ids", "POST")]
public Task ValidateUnusedIds();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedStorageHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStorageHandler/<Report>d__0")]
[RavenShardedActionAttribute("/databases/*/debug/storage/report", "GET")]
public Task Report();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStorageHandler/<GetEnvironmentReport>d__1")]
[RavenShardedActionAttribute("/databases/*/debug/storage/environment/report", "GET")]
public Task GetEnvironmentReport();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStorageHandler/<ManualFlush>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/storage/manual-flush", "POST")]
public Task ManualFlush();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStorageHandler/<ManualSync>d__3")]
[RavenShardedActionAttribute("/databases/*/admin/storage/manual-sync", "POST")]
public Task ManualSync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStorageHandler/<Trees>d__4")]
[RavenShardedActionAttribute("/databases/*/debug/storage/trees", "GET")]
public Task Trees();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStorageHandler/<BTreeStructure>d__5")]
[RavenShardedActionAttribute("/databases/*/debug/storage/btree-structure", "GET")]
public Task BTreeStructure();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStorageHandler/<FixedSizeTreeStructure>d__6")]
[RavenShardedActionAttribute("/databases/*/debug/storage/fst-structure", "GET")]
public Task FixedSizeTreeStructure();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStorageHandler/<AllEnvironmentsReport>d__7")]
[RavenShardedActionAttribute("/databases/*/debug/storage/all-environments/report", "GET")]
public Task AllEnvironmentsReport();
}
internal class Raven.Server.Documents.Sharding.Handlers.ShardedStreamingHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStreamingHandler/<StreamDocsGet>d__0")]
[RavenShardedActionAttribute("/databases/*/streams/docs", "GET")]
public Task StreamDocsGet();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStreamingHandler/<StreamQueryGet>d__1")]
[RavenShardedActionAttribute("/databases/*/streams/queries", "GET")]
public Task StreamQueryGet();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStreamingHandler/<StreamQueryPost>d__2")]
[RavenShardedActionAttribute("/databases/*/streams/queries", "POST")]
public Task StreamQueryPost();
    [RavenShardedActionAttribute("/databases/*/streams/queries", "HEAD")]
public Task SteamQueryHead();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStreamingHandler/<Stream>d__4")]
[RavenShardedActionAttribute("/databases/*/streams/timeseries", "GET")]
public Task Stream();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedStudioCollectionFieldsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStudioCollectionFieldsHandler/<GetCollectionFields>d__0")]
[RavenShardedActionAttribute("/databases/*/studio/collections/fields", "GET")]
public Task GetCollectionFields();
}
internal class Raven.Server.Documents.Sharding.Handlers.ShardedStudioStatsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStudioStatsHandler/<GetFooterStats>d__0")]
[RavenShardedActionAttribute("/databases/*/studio/footer/stats", "GET")]
public Task GetFooterStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedStudioStatsHandler/<GetLicenseLimitsUsage>d__1")]
[RavenShardedActionAttribute("/databases/*/studio/license/limits-usage", "GET")]
public Task GetLicenseLimitsUsage();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<Create>d__0")]
[RavenShardedActionAttribute("/databases/*/subscriptions", "PUT")]
public Task Create();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<Update>d__1")]
[RavenShardedActionAttribute("/databases/*/subscriptions/update", "POST")]
public Task Update();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<CreateSubscriptionInternalAsync>d__2")]
public Task CreateSubscriptionInternalAsync(BlittableJsonReaderObject bjro, Nullable`1<long> id, Nullable`1<bool> disabled, SubscriptionCreationOptions options, JsonOperationContext context, ParsedSubscription sub);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<TryValidateChangeVector>d__4")]
private Task`1<ChangeVectorValidationResult> TryValidateChangeVector(SubscriptionCreationOptions options, ParsedSubscription sub);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<GetResponsibleNodesAndWaitForExecution>d__5")]
private Task GetResponsibleNodesAndWaitForExecution(string name, long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<Delete>d__6")]
[RavenShardedActionAttribute("/databases/*/subscriptions", "DELETE")]
public Task Delete();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<GetSubscriptionState>d__7")]
[RavenShardedActionAttribute("/databases/*/subscriptions/state", "GET")]
public Task GetSubscriptionState();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<GetAll>d__8")]
[RavenShardedActionAttribute("/databases/*/subscriptions", "GET")]
public Task GetAll();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<PerformanceLive>d__9")]
[RavenShardedActionAttribute("/databases/*/subscriptions/performance/live", "GET")]
public Task PerformanceLive();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<DropSubscriptionConnection>d__10")]
[RavenShardedActionAttribute("/databases/*/subscriptions/drop", "POST")]
public Task DropSubscriptionConnection();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<GetSubscriptionConnectionDetails>d__11")]
[RavenShardedActionAttribute("/databases/*/subscriptions/connection-details", "GET")]
public Task GetSubscriptionConnectionDetails();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<Try>d__12")]
[RavenShardedActionAttribute("/databases/*/subscriptions/try", "POST")]
public Task Try();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedSubscriptionsHandler/<GetSubscriptionResend>d__13")]
[RavenShardedActionAttribute("/databases/*/debug/subscriptions/resend", "GET")]
public Task GetSubscriptionResend();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedTcpManagementHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTcpManagementHandler/<GetAll>d__0")]
[RavenShardedActionAttribute("/databases/*/tcp", "GET")]
public Task GetAll();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTcpManagementHandler/<Delete>d__1")]
[RavenShardedActionAttribute("/databases/*/tcp", "DELETE")]
public Task Delete();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedTimeSeriesHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTimeSeriesHandler/<Batch>d__0")]
[RavenShardedActionAttribute("/databases/*/timeseries", "POST")]
public Task Batch();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTimeSeriesHandler/<Read>d__1")]
[RavenShardedActionAttribute("/databases/*/timeseries", "GET")]
public Task Read();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTimeSeriesHandler/<ReadRanges>d__2")]
[RavenShardedActionAttribute("/databases/*/timeseries/ranges", "GET")]
public Task ReadRanges();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTimeSeriesHandler/<PostTimeSeriesConfiguration>d__3")]
[RavenShardedActionAttribute("/databases/*/admin/timeseries/config", "POST")]
public Task PostTimeSeriesConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTimeSeriesHandler/<GetTimeSeriesConfiguration>d__4")]
[RavenShardedActionAttribute("/databases/*/timeseries/config", "GET")]
public Task GetTimeSeriesConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTimeSeriesHandler/<Stats>d__5")]
[RavenShardedActionAttribute("/databases/*/timeseries/stats", "GET")]
public Task Stats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTimeSeriesHandler/<ConfigTimeSeriesNames>d__6")]
[RavenShardedActionAttribute("/databases/*/timeseries/names/config", "POST")]
public Task ConfigTimeSeriesNames();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTimeSeriesHandler/<GetSegmentSummary>d__7")]
[RavenShardedActionAttribute("/databases/*/timeseries/debug/segments-summary", "GET")]
public Task GetSegmentSummary();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedTransactionDebugHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTransactionDebugHandler/<TxInfo>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/debug/txinfo", "GET")]
public Task TxInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTransactionDebugHandler/<ClusterTxInfo>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/debug/cluster/txinfo", "GET")]
public Task ClusterTxInfo();
}
public class Raven.Server.Documents.Sharding.Handlers.ShardedTransactionsRecordingHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTransactionsRecordingHandler/<ReplayRecording>d__0")]
[RavenShardedActionAttribute("/databases/*/transactions/replay", "POST")]
public Task ReplayRecording();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTransactionsRecordingHandler/<StartRecording>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/transactions/start-recording", "POST")]
public Task StartRecording();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Handlers.ShardedTransactionsRecordingHandler/<StopRecording>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/transactions/stop-recording", "POST")]
public Task StopRecording();
}
public class Raven.Server.Documents.Sharding.NotificationCenter.BackgroundWork.ShardedDatabaseStatsSender : AbstractDatabaseStatsSender {
    private ShardedDatabaseContext _context;
    public ShardedDatabaseStatsSender(ShardedDatabaseContext context, ShardedDatabaseNotificationCenter notificationCenter);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.NotificationCenter.BackgroundWork.ShardedDatabaseStatsSender/<GetStatsAsync>d__2")]
protected virtual ValueTask`1<NotificationCenterDatabaseStats> GetStatsAsync();
}
public class Raven.Server.Documents.Sharding.NotificationCenter.ShardedDatabaseNotificationCenter : AbstractDatabaseNotificationCenter {
    private ShardedDatabaseContext _context;
    public ShardedDatabaseNotificationCenter(ShardedDatabaseContext context);
    public virtual void Initialize();
}
public abstract class Raven.Server.Documents.Sharding.Operations.AbstractShardedMultiOperation : object {
    protected long Id;
    protected ShardedDatabaseContext ShardedDatabaseContext;
    private Action`1<IOperationProgress> _onProgress;
    protected ConcurrentDictionary`2<ShardedDatabaseIdentifier, Operation> Operations;
    private Dictionary`2<int, IOperationProgress> _progresses;
    protected AbstractShardedMultiOperation(long id, ShardedDatabaseContext shardedDatabaseContext, Action`1<IOperationProgress> onProgress);
    public abstract virtual ValueTask`1<TResult> ExecuteCommandForShard(RavenCommand`1<TResult> command, int shardNumber, CancellationToken token);
    public abstract virtual Operation CreateOperationInstance(ShardedDatabaseIdentifier key, long operationId);
    public abstract virtual ValueTask KillAsync(CancellationToken token);
    public void Watch(ShardedDatabaseIdentifier key, Operation operation);
    private void MaybeNotifyAboutProgress();
    private void NotifyAboutProgress(IOperationProgress progress);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.AbstractShardedMultiOperation/<WaitForCompletionAsync>d__12`1")]
public Task`1<IOperationResult> WaitForCompletionAsync(CancellationToken token);
}
internal class Raven.Server.Documents.Sharding.Operations.BulkInsert.ShardedBulkInsertOperation : BulkInsertOperationBase`1<ShardedBatchCommandData> {
    private bool _skipOverwriteIfUnchanged;
    private ShardedBulkInsertHandler _requestHandler;
    private ShardedDatabaseContext _databaseContext;
    private TransactionOperationContext _context;
    private Dictionary`2<int, ShardedBulkInsertWriter> _writers;
    private List`1<IDisposable> _returnContexts;
    private Dictionary`2<int, BulkInsertCommand> _bulkInsertCommands;
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    public CompressionLevel CompressionLevel { get; public set; }
    public HttpRequest HttpRequest { get; }
    public ShardedBulkInsertOperation(long id, bool skipOverwriteIfUnchanged, ShardedBulkInsertHandler requestHandler, ShardedDatabaseContext databaseContext, JsonContextPoolBase`1<TransactionOperationContext> contextPool, CancellationToken token);
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual HttpResponseMessage Combine(Dictionary`2<int, ShardExecutionResult`1<HttpResponseMessage>> results);
    public sealed virtual RavenCommand`1<HttpResponseMessage> CreateCommandForShard(int shardNumber);
    protected virtual Task WaitForId();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.BulkInsert.ShardedBulkInsertOperation/<StoreAsync>d__17")]
public virtual Task StoreAsync(ShardedBatchCommandData command, string id);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.BulkInsert.ShardedBulkInsertOperation/<EnsureStreamAsync>d__18")]
protected virtual Task EnsureStreamAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.BulkInsert.ShardedBulkInsertOperation/<GetExceptionFromOperation>d__19")]
protected virtual Task`1<BulkInsertAbortedException> GetExceptionFromOperation();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.BulkInsert.ShardedBulkInsertOperation/<AbortAsync>d__20")]
public virtual Task AbortAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.BulkInsert.ShardedBulkInsertOperation/<DisposeAsync>d__21")]
public sealed virtual ValueTask DisposeAsync();
}
internal class Raven.Server.Documents.Sharding.Operations.BulkInsert.ShardedBulkInsertWriter : BulkInsertWriterBase {
    private bool _first;
    private MemoryStream _currentWriter;
    public ShardedBulkInsertWriter(JsonOperationContext ctx, CancellationToken token);
    protected virtual void OnCurrentWriteStreamSet(MemoryStream currentWriteStream);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.BulkInsert.ShardedBulkInsertWriter/<WriteStreamAsync>d__4")]
public Task WriteStreamAsync(Stream src);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.BulkInsert.ShardedBulkInsertWriter/<WriteStreamDirectlyToRequestAsync>d__5")]
public Task WriteStreamDirectlyToRequestAsync(Stream src);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Operations.FetchDocumentsFromShardsOperation : ValueType {
    private JsonOperationContext _context;
    private ShardedDatabaseContext _databaseContext;
    private Dictionary`2<int, IdsByShard`1<string>> _idsByShards;
    private String[] _includePaths;
    private RevisionIncludeField _includeRevisions;
    private StringValues _counterIncludes;
    private HashSet`1<AbstractTimeSeriesRange> _timeSeriesIncludes;
    private String[] _compareExchangeValueIncludes;
    private bool _metadataOnly;
    private bool _clusterWideTx;
    [CompilerGeneratedAttribute]
private HttpRequest <HttpRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpectedEtag>k__BackingField;
    public HttpRequest HttpRequest { get; }
    public string ExpectedEtag { get; }
    public FetchDocumentsFromShardsOperation(JsonOperationContext context, HttpRequest httpRequest, ShardedDatabaseContext databaseContext, Dictionary`2<int, IdsByShard`1<string>> idsByShards, String[] includePaths, RevisionIncludeField includeRevisions, StringValues counterIncludes, HashSet`1<AbstractTimeSeriesRange> timeSeriesIncludes, String[] compareExchangeValueIncludes, string etag, bool metadataOnly, bool clusterWideTx);
    [CompilerGeneratedAttribute]
public sealed virtual HttpRequest get_HttpRequest();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExpectedEtag();
    public sealed virtual GetShardedDocumentsResult CombineResults(Dictionary`2<int, ShardExecutionResult`1<GetDocumentsResult>> results);
    public sealed virtual RavenCommand`1<GetDocumentsResult> CreateCommandForShard(int shardNumber);
}
public class Raven.Server.Documents.Sharding.Operations.GetShardedDocumentsResult : object {
    public List`1<BlittableJsonReaderObject> Includes;
    public Dictionary`2<string, BlittableJsonReaderObject> Documents;
    public HashSet`1<string> MissingDocumentIncludes;
    public IRevisionIncludes RevisionIncludes;
    public ICounterIncludes CounterIncludes;
    public ITimeSeriesIncludes TimeSeriesIncludes;
    public Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> CompareExchangeValueIncludes;
    public bool HasNullId;
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Operations.GetShardedOperationStateOperation : ValueType {
    private HttpContext _httpContext;
    private long _id;
    private string _nodeTag;
    public HttpRequest HttpRequest { get; }
    public GetShardedOperationStateOperation(HttpContext httpContext, long id, string nodeTag);
    public sealed virtual RavenCommand`1<OperationState> CreateCommandForShard(int shardNumber);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual OperationState Combine(Dictionary`2<int, ShardExecutionResult`1<OperationState>> results);
}
public interface Raven.Server.Documents.Sharding.Operations.IShardedOperation {
    private sealed virtual override object Raven.Server.Documents.Sharding.Operations.IShardedOperation<System.Object,System.Object>.Combine(Dictionary`2<int, ShardExecutionResult`1<object>> results);
}
public interface Raven.Server.Documents.Sharding.Operations.IShardedOperation`1 {
}
public interface Raven.Server.Documents.Sharding.Operations.IShardedOperation`2 {
    public HttpRequest HttpRequest { get; }
    public List`1<string> HeadersToCopy { get; }
    public abstract virtual HttpRequest get_HttpRequest();
    public abstract virtual TCombinedResult Combine(Dictionary`2<int, ShardExecutionResult`1<TResult>> results);
    public virtual List`1<string> get_HeadersToCopy();
    public virtual TCombinedResult CombineCommands(Dictionary`2<int, ShardExecutionResult`1<TResult>> results);
    public abstract virtual RavenCommand`1<TResult> CreateCommandForShard(int shardNumber);
    public virtual JsonOperationContext CreateOperationContext();
    public virtual void ModifyHeaders(HttpRequestMessage request);
    public virtual string ModifyUrl(string url);
}
public interface Raven.Server.Documents.Sharding.Operations.IShardedReadOperation`1 {
}
public interface Raven.Server.Documents.Sharding.Operations.IShardedReadOperation`2 {
    public string ExpectedEtag { get; }
    public abstract virtual string get_ExpectedEtag();
    public virtual string CombineCommandsEtag(Dictionary`2<int, ShardExecutionResult`1<TResult>> results);
    private sealed virtual override ShardedReadResult`1<TCombinedResult> Raven.Server.Documents.Sharding.Operations.IShardedOperation<TResult,Raven.Server.Documents.Sharding.Operations.ShardedReadResult<TCombinedResult>>.Combine(Dictionary`2<int, ShardExecutionResult`1<TResult>> results);
    public abstract virtual TCombinedResult CombineResults(Dictionary`2<int, ShardExecutionResult`1<TResult>> results);
    private sealed virtual override ShardedReadResult`1<TCombinedResult> Raven.Server.Documents.Sharding.Operations.IShardedOperation<TResult,Raven.Server.Documents.Sharding.Operations.ShardedReadResult<TCombinedResult>>.CombineCommands(Dictionary`2<int, ShardExecutionResult`1<TResult>> results);
}
public interface Raven.Server.Documents.Sharding.Operations.IShardedStreamableOperation {
    private sealed virtual override ShardedReadResult`1<CombinedStreamResult> Raven.Server.Documents.Sharding.Operations.IShardedOperation<Raven.Client.Documents.Commands.StreamResult,Raven.Server.Documents.Sharding.Operations.ShardedReadResult<Raven.Server.Documents.Sharding.Streaming.CombinedStreamResult>>.Combine(Dictionary`2<int, ShardExecutionResult`1<StreamResult>> results);
}
public class Raven.Server.Documents.Sharding.Operations.LastChangeVectorForCollectionCombinedResult : object {
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <LastChangeVectors>k__BackingField;
    public string Collection { get; public set; }
    public Dictionary`2<string, string> LastChangeVectors { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_LastChangeVectors();
    [CompilerGeneratedAttribute]
public void set_LastChangeVectors(Dictionary`2<string, string> value);
}
public class Raven.Server.Documents.Sharding.Operations.LastChangeVectorForCollectionResult : object {
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastChangeVector>k__BackingField;
    public string Collection { get; public set; }
    public string LastChangeVector { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public string get_LastChangeVector();
    [CompilerGeneratedAttribute]
public void set_LastChangeVector(string value);
}
public abstract class Raven.Server.Documents.Sharding.Operations.Queries.AbstractShardedQueryOperation`3 : object {
    private ShardedDatabaseRequestHandler _requestHandler;
    protected Dictionary`2<int, ShardedQueryCommand> QueryCommands;
    protected TransactionOperationContext Context;
    protected bool HadActiveMigrationsBeforeQueryStarted;
    protected long CombinedResultEtag;
    [CompilerGeneratedAttribute]
private string <ExpectedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <MissingDocumentIncludes>k__BackingField;
    public HttpRequest HttpRequest { get; }
    public string ExpectedEtag { get; }
    public HashSet`1<string> MissingDocumentIncludes { get; private set; }
    protected AbstractShardedQueryOperation`3(QueryMetadata metadata, Dictionary`2<int, ShardedQueryCommand> queryCommands, TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, string expectedEtag);
    public sealed virtual HttpRequest get_HttpRequest();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExpectedEtag();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_MissingDocumentIncludes();
    [CompilerGeneratedAttribute]
private void set_MissingDocumentIncludes(HashSet`1<string> value);
    private sealed virtual override RavenCommand`1<QueryResult> Raven.Server.Documents.Sharding.Operations.IShardedOperation<Raven.Client.Documents.Queries.QueryResult,Raven.Server.Documents.Sharding.Operations.ShardedReadResult<TCombinedResult>>.CreateCommandForShard(int shardNumber);
    public sealed virtual string CombineCommandsEtag(Dictionary`2<int, ShardExecutionResult`1<QueryResult>> commands);
    public abstract virtual TCombinedResult CombineResults(Dictionary`2<int, ShardExecutionResult`1<QueryResult>> results);
    protected static void CombineSingleShardResultProperties(QueryResult`2<List`1<TResult>, List`1<TIncludes>> combinedResult, QueryResult singleShardResult);
    protected void HandleDocumentIncludes(QueryResult cmdResult, QueryResult`2<List`1<TResult>, List`1<TIncludes>> result);
    public static void HandleDocumentIncludesInternal(BlittableJsonReaderObject includes, JsonOperationContext context, QueryResult`2<List`1<TResult>, List`1<TIncludes>> result, HashSet`1& missingDocumentIncludes);
    protected void CombineExplanations(QueryResult`2<TQueryResult, TQueryIncludes> result, ShardExecutionResult`1<QueryResult> shardResult);
    protected void CombineTimings(int shardNumber, ShardExecutionResult`1<QueryResult> shardResult);
}
public class Raven.Server.Documents.Sharding.Operations.Queries.ShardedFacetedQueryOperation : AbstractShardedQueryOperation`3<FacetedQueryResult, FacetResult, Document> {
    private Dictionary`2<string, FacetOptions> _facetOptions;
    public ShardedFacetedQueryOperation(IndexQueryServerSide query, Dictionary`2<string, FacetOptions> facetOptions, TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, Dictionary`2<int, ShardedQueryCommand> queryCommands, string expectedEtag);
    public virtual FacetedQueryResult CombineResults(Dictionary`2<int, ShardExecutionResult`1<QueryResult>> results);
}
public class Raven.Server.Documents.Sharding.Operations.Queries.ShardedIndexEntriesQueryOperation : AbstractShardedQueryOperation`3<ShardedIndexEntriesQueryResult, BlittableJsonReaderObject, BlittableJsonReaderObject> {
    private IndexQueryServerSide _query;
    private IComparer`1<BlittableJsonReaderObject> _sortingComparer;
    public bool FromStudio { get; }
    public ShardedIndexEntriesQueryOperation(IndexQueryServerSide query, TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, Dictionary`2<int, ShardedQueryCommand> queryCommands, IComparer`1<BlittableJsonReaderObject> sortingComparer, string expectedEtag);
    public bool get_FromStudio();
    public virtual ShardedIndexEntriesQueryResult CombineResults(Dictionary`2<int, ShardExecutionResult`1<QueryResult>> results);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.Queries.ShardedIndexEntriesQueryOperation/<<CombineResults>g__GetEnumerator|5_0>d")]
[CompilerGeneratedAttribute]
private IEnumerator`1<BlittableJsonReaderObject> <CombineResults>g__GetEnumerator|5_0(BlittableJsonReaderArray array, int shardNumber);
}
public class Raven.Server.Documents.Sharding.Operations.Queries.ShardedQueryOperation : AbstractShardedQueryOperation`3<ShardedQueryResult, BlittableJsonReaderObject, BlittableJsonReaderObject> {
    private IndexQueryServerSide _query;
    private bool _isDistinctQuery;
    private IComparer`1<BlittableJsonReaderObject> _sortingComparer;
    private HashSet`1<int> _alreadySeenProjections;
    private HashSet`1<string> _timeSeriesFieldNames;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <MissingCounterIncludes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<TimeSeriesRange>> <MissingTimeSeriesIncludes>k__BackingField;
    public bool FromStudio { get; }
    public HashSet`1<string> MissingCounterIncludes { get; private set; }
    public Dictionary`2<string, List`1<TimeSeriesRange>> MissingTimeSeriesIncludes { get; public set; }
    public ShardedQueryOperation(IndexQueryServerSide query, bool isProjectionFromMapReduceIndex, TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, Dictionary`2<int, ShardedQueryCommand> queryCommands, IComparer`1<BlittableJsonReaderObject> sortingComparer, string expectedEtag);
    public bool get_FromStudio();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_MissingCounterIncludes();
    [CompilerGeneratedAttribute]
private void set_MissingCounterIncludes(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<TimeSeriesRange>> get_MissingTimeSeriesIncludes();
    [CompilerGeneratedAttribute]
public void set_MissingTimeSeriesIncludes(Dictionary`2<string, List`1<TimeSeriesRange>> value);
    public virtual ShardedQueryResult CombineResults(Dictionary`2<int, ShardExecutionResult`1<QueryResult>> results);
    private bool CanIncludeResult(BlittableJsonReaderObject item);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.Queries.ShardedQueryOperation/<<CombineResults>g__GetEnumerator|16_0>d")]
[CompilerGeneratedAttribute]
private IEnumerator`1<BlittableJsonReaderObject> <CombineResults>g__GetEnumerator|16_0(BlittableJsonReaderArray array, int shardNumber);
}
public class Raven.Server.Documents.Sharding.Operations.Queries.ShardedSuggestionQueryOperation : AbstractShardedQueryOperation`3<SuggestionQueryResult, SuggestionResult, Document> {
    private Dictionary`2<string, SuggestionField> _fieldsWithOptions;
    private BlittableJsonReaderObject _queryParameters;
    public ShardedSuggestionQueryOperation(IndexQueryServerSide query, Dictionary`2<string, SuggestionField> fieldsWithOptions, BlittableJsonReaderObject queryParameters, TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, Dictionary`2<int, ShardedQueryCommand> queryCommands, string expectedEtag);
    public virtual SuggestionQueryResult CombineResults(Dictionary`2<int, ShardExecutionResult`1<QueryResult>> results);
    [CompilerGeneratedAttribute]
internal static void <CombineResults>g__AddPopularity|3_0(BlittableJsonReaderObject popularityObject, CombinedSuggestions aggregatedSuggestion, SuggestionResult suggestionResult, <>c__DisplayClass3_0& );
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Operations.ShardedBatchOperation : ValueType {
    private HttpContext _httpContext;
    private JsonOperationContext _resultContext;
    private Dictionary`2<int, ShardedSingleNodeBatchCommand> _commandsPerShard;
    private ShardedBatchCommand _command;
    public HttpRequest HttpRequest { get; }
    public ShardedBatchOperation(HttpContext httpContext, JsonOperationContext resultContext, Dictionary`2<int, ShardedSingleNodeBatchCommand> commandsPerShard, ShardedBatchCommand command);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual DynamicJsonArray Combine(Dictionary`2<int, ShardExecutionResult`1<BlittableJsonReaderObject>> results);
    public sealed virtual RavenCommand`1<BlittableJsonReaderObject> CreateCommandForShard(int shardNumber);
}
public class Raven.Server.Documents.Sharding.Operations.ShardedDatabaseMultiOperation : AbstractShardedMultiOperation {
    public ShardedDatabaseMultiOperation(long id, ShardedDatabaseContext context, Action`1<IOperationProgress> onProgress);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.ShardedDatabaseMultiOperation/<KillAsync>d__1")]
public virtual ValueTask KillAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.ShardedDatabaseMultiOperation/<ExecuteCommandForShard>d__2`1")]
public virtual ValueTask`1<TResult> ExecuteCommandForShard(RavenCommand`1<TResult> command, int shardNumber, CancellationToken token);
    public virtual Operation CreateOperationInstance(ShardedDatabaseIdentifier key, long operationId);
}
[IsReadOnlyAttribute]
internal class Raven.Server.Documents.Sharding.Operations.ShardedGetCollectionFieldsOperation : ValueType {
    private JsonOperationContext _context;
    private HttpContext _httpContext;
    private string _collection;
    private string _prefix;
    [CompilerGeneratedAttribute]
private string <ExpectedEtag>k__BackingField;
    public HttpRequest HttpRequest { get; }
    public string ExpectedEtag { get; }
    public ShardedGetCollectionFieldsOperation(JsonOperationContext context, HttpContext httpContext, string collection, string prefix, string etag);
    public sealed virtual HttpRequest get_HttpRequest();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExpectedEtag();
    public sealed virtual Dictionary`2<LazyStringValue, FieldType> CombineResults(Dictionary`2<int, ShardExecutionResult`1<BlittableJsonReaderObject>> results);
    public sealed virtual RavenCommand`1<BlittableJsonReaderObject> CreateCommandForShard(int shardNumber);
}
[IsReadOnlyAttribute]
internal class Raven.Server.Documents.Sharding.Operations.ShardedGetRevisionsByChangeVectorsOperation : ValueType {
    private HttpContext _httpContext;
    private String[] _changeVectors;
    private bool _metadataOnly;
    private JsonOperationContext _context;
    [CompilerGeneratedAttribute]
private string <ExpectedEtag>k__BackingField;
    public HttpRequest HttpRequest { get; }
    public string ExpectedEtag { get; }
    public ShardedGetRevisionsByChangeVectorsOperation(HttpContext httpContext, String[] changeVectors, bool metadataOnly, JsonOperationContext context, string etag);
    public sealed virtual HttpRequest get_HttpRequest();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExpectedEtag();
    public sealed virtual BlittableJsonReaderObject[] CombineResults(Dictionary`2<int, ShardExecutionResult`1<BlittableArrayResult>> results);
    public sealed virtual RavenCommand`1<BlittableArrayResult> CreateCommandForShard(int shardNumber);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Operations.ShardedLastChangeVectorForCollectionOperation : ValueType {
    private string _collection;
    private string _database;
    [CompilerGeneratedAttribute]
private HttpRequest <HttpRequest>k__BackingField;
    public HttpRequest HttpRequest { get; }
    public ShardedLastChangeVectorForCollectionOperation(HttpRequest request, string collection, string database);
    [CompilerGeneratedAttribute]
public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual LastChangeVectorForCollectionCombinedResult Combine(Dictionary`2<int, ShardExecutionResult`1<LastChangeVectorForCollectionResult>> results);
    public sealed virtual RavenCommand`1<LastChangeVectorForCollectionResult> CreateCommandForShard(int shardNumber);
}
public class Raven.Server.Documents.Sharding.Operations.ShardedOperation : AbstractOperation {
    [JsonDeserializationIgnoreAttribute]
public ShardedDatabaseMultiOperation Operation;
}
public class Raven.Server.Documents.Sharding.Operations.ShardedReadResult`1 : object {
    public T Result;
    public int StatusCode;
    public string CombinedEtag;
}
public class Raven.Server.Documents.Sharding.Operations.ShardedServerMultiOperation : AbstractShardedMultiOperation {
    public ShardedServerMultiOperation(long id, ShardedDatabaseContext context, Action`1<IOperationProgress> onProgress);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.ShardedServerMultiOperation/<ExecuteCommandForShard>d__1`1")]
public virtual ValueTask`1<TResult> ExecuteCommandForShard(RavenCommand`1<TResult> command, int shardNumber, CancellationToken token);
    public virtual Operation CreateOperationInstance(ShardedDatabaseIdentifier key, long operationId);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Operations.ShardedServerMultiOperation/<KillAsync>d__3")]
public virtual ValueTask KillAsync(CancellationToken token);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Operations.ShardedSubscriptionTryoutOperation : ValueType {
    private HttpContext _httpContext;
    private TransactionOperationContext _context;
    private SubscriptionTryout _tryout;
    private int _pageSize;
    private Nullable`1<int> _timeLimitInSec;
    public HttpRequest HttpRequest { get; }
    internal ShardedSubscriptionTryoutOperation(HttpContext httpContext, TransactionOperationContext context, SubscriptionTryout tryout, int pageSize, Nullable`1<int> timeLimitInSec);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual GetDocumentsResult Combine(Dictionary`2<int, ShardExecutionResult`1<GetDocumentsResult>> results);
    public sealed virtual RavenCommand`1<GetDocumentsResult> CreateCommandForShard(int shardNumber);
}
internal class Raven.Server.Documents.Sharding.Operations.ShardedTimeSeriesOperation : object {
    [CompilerGeneratedAttribute]
private HttpRequest <_request>k__BackingField;
    private Dictionary`2<int, GetMultipleTimeSeriesRangesCommand> _commandsPerShard;
    public HttpRequest _request { get; }
    public HttpRequest HttpRequest { get; }
    public ShardedTimeSeriesOperation(HttpRequest request, Dictionary`2<int, GetMultipleTimeSeriesRangesCommand> commandsPerShard);
    [CompilerGeneratedAttribute]
public HttpRequest get__request();
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual Response Combine(Dictionary`2<int, ShardExecutionResult`1<Response>> results);
    private sealed virtual override RavenCommand`1<Response> Raven.Server.Documents.Sharding.Operations.IShardedOperation<Raven.Client.Documents.Operations.TimeSeries.GetMultipleTimeSeriesRangesCommand.Response,Raven.Client.Documents.Operations.TimeSeries.GetMultipleTimeSeriesRangesCommand.Response>.CreateCommandForShard(int shardNumber);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Operations.WaitForIndexNotificationOnServerOperation : ValueType {
    private long _index;
    public HttpRequest HttpRequest { get; }
    public WaitForIndexNotificationOnServerOperation(long index);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual RavenCommand`1<object> CreateCommandForShard(int shardNumber);
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.Operations.WaitForIndexNotificationOperation : ValueType {
    private List`1<long> _indexes;
    public HttpRequest HttpRequest { get; }
    public WaitForIndexNotificationOperation(List`1<long> indexes);
    public WaitForIndexNotificationOperation(long index);
    public sealed virtual void ModifyHeaders(HttpRequestMessage request);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual object Combine(Dictionary`2<int, ShardExecutionResult`1<object>> results);
    public sealed virtual RavenCommand`1<object> CreateCommandForShard(int shardNumber);
}
public abstract class Raven.Server.Documents.Sharding.Queries.AbstractShardedQueryProcessor`3 : object {
    private static string LimitToken;
    private Dictionary`2<int, BlittableJsonReaderObject> _queryTemplates;
    private Dictionary`2<int, TCommand> _commands;
    private bool _indexEntriesOnly;
    private bool _ignoreLimit;
    private string _raftUniqueRequestId;
    private HashSet`1<int> _filteredShardIndexes;
    protected TransactionOperationContext Context;
    protected ShardedDatabaseRequestHandler RequestHandler;
    protected IndexQueryServerSide Query;
    protected CancellationToken Token;
    protected bool IsAutoMapReduceQuery;
    protected IndexType IndexType;
    protected IndexSourceType IndexSourceType;
    protected IndexDefinitionBaseServerSide indexDefinition;
    protected Nullable`1<long> ExistingResultEtag;
    protected bool MetadataOnly;
    protected bool IsProjectionFromMapReduceIndex { get; }
    protected AbstractShardedQueryProcessor`3(TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, IndexQueryServerSide query, bool metadataOnly, bool indexEntriesOnly, bool ignoreLimit, Nullable`1<long> existingResultEtag, CancellationToken token);
    private void HandleShardsFiltering(TransactionOperationContext context, object filter);
    private void GetShardNumbersForFiltering(TransactionOperationContext context, BlittableJsonReaderArray array);
    public abstract virtual Task`1<TCombinedResult> ExecuteShardedOperations(QueryTimingsScope scope);
    protected Int32[] GetShardNumbers(Dictionary`2<int, TCommand> commands);
    protected virtual QueryType<TCommand, TResult, TCombinedResult> GetQueryType();
    protected bool get_IsProjectionFromMapReduceIndex();
    public virtual ValueTask InitializeAsync();
    private Dictionary`2<int, TCommand> CreateQueryCommands(Dictionary`2<int, BlittableJsonReaderObject> preProcessedQueries, QueryTimingsScope scope);
    public Dictionary`2<int, TCommand> GetOperationCommands(QueryTimingsScope scope);
    protected abstract virtual TCommand CreateCommand(int shardNumber, BlittableJsonReaderObject query, QueryTimingsScope scope);
    protected ShardedQueryCommand CreateShardedQueryCommand(int shardNumber, BlittableJsonReaderObject query, QueryTimingsScope scope);
    protected virtual void AssertQueryExecution();
    private void AssertOrdering();
    private BlittableJsonReaderObject RewriteQueryIfNeeded(BlittableJsonReaderObject queryTemplate);
    private QueryChanges<TCommand, TResult, TCombinedResult> DetectChangesForQueryRewrite(IndexQueryServerSide indexQuery, List`1& groupByFields);
    private List`1<string> GetGroupByFields();
    private Dictionary`2<int, BlittableJsonReaderObject> GenerateLoadByIdQueries(IEnumerable`1<Slice> ids);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.AbstractShardedQueryProcessor`3/<HandleMissingDocumentIncludesAsync>d__36`2")]
protected ValueTask HandleMissingDocumentIncludesAsync(TransactionOperationContext context, HttpRequest request, ShardedDatabaseContext databaseContext, HashSet`1<string> missingIncludes, QueryResult`2<List`1<T>, List`1<TIncludes>> result, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.AbstractShardedQueryProcessor`3/<HandleMissingDocumentIncludesAsync>d__37`2")]
public static ValueTask HandleMissingDocumentIncludesAsync(JsonOperationContext context, HttpRequest request, ShardedDatabaseContext databaseContext, HashSet`1<string> missingIncludes, QueryResult`2<List`1<T>, List`1<TIncludes>> result, HashSet`1<string> missingIds, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.AbstractShardedQueryProcessor`3/<HandleMissingDocumentIncludesInternalAsync>d__38`2")]
private static Task HandleMissingDocumentIncludesInternalAsync(JsonOperationContext context, HttpRequest request, ShardedDatabaseContext databaseContext, QueryResult`2<List`1<T>, List`1<TIncludes>> result, HashSet`1<string> missingIds, bool metadataOnly, Dictionary`2<int, IdsByShard`1<string>> missingIncludeIdsByShard, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.AbstractShardedQueryProcessor`3/<WaitForRaftIndexIfNeededAsync>d__39")]
protected Task WaitForRaftIndexIfNeededAsync(Nullable`1<long> autoIndexCreationRaftCommandIndex, QueryTimingsScope scope);
    protected IComparer`1<BlittableJsonReaderObject> GetComparer(IndexQueryServerSide query);
    [CompilerGeneratedAttribute]
internal static void <RewriteQueryIfNeeded>g__RemoveLimitAndOffset|32_0(<>c__DisplayClass32_0& );
    [CompilerGeneratedAttribute]
internal static string <GenerateLoadByIdQueries>g__GetParameterName|35_2(ValueExpression valueExpression);
}
public class Raven.Server.Documents.Sharding.Queries.Facets.ShardedFacetedQueryProcessor : AbstractShardedQueryProcessor`3<ShardedQueryCommand, QueryResult, FacetedQueryResult> {
    private Dictionary`2<string, FacetOptions> _optionsByFacet;
    public ShardedFacetedQueryProcessor(TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, IndexQueryServerSide query, Nullable`1<long> existingResultEtag, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.Facets.ShardedFacetedQueryProcessor/<InitializeAsync>d__2")]
public virtual ValueTask InitializeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.Facets.ShardedFacetedQueryProcessor/<ExecuteShardedOperations>d__3")]
public virtual Task`1<FacetedQueryResult> ExecuteShardedOperations(QueryTimingsScope scope);
    protected virtual ShardedQueryCommand CreateCommand(int shardNumber, BlittableJsonReaderObject query, QueryTimingsScope scope);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.Facets.ShardedFacetedQueryProcessor/<<InitializeAsync>g__GetFacetSetupDocument|2_0>d")]
[CompilerGeneratedAttribute]
private Task`1<GetDocumentsResult> <InitializeAsync>g__GetFacetSetupDocument|2_0(FacetField facetField);
    [CompilerGeneratedAttribute]
private void <InitializeAsync>g__AddFacetOptions|2_1(string name, FacetOptions options);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
public class Raven.Server.Documents.Sharding.Queries.IndexEntries.ShardedIndexEntriesQueryProcessor : ShardedQueryProcessorBase`1<ShardedIndexEntriesQueryResult> {
    public ShardedIndexEntriesQueryProcessor(TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, IndexQueryServerSide query, Nullable`1<long> existingResultEtag, bool ignoreLimit, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.IndexEntries.ShardedIndexEntriesQueryProcessor/<ExecuteShardedOperations>d__1")]
public virtual Task`1<ShardedIndexEntriesQueryResult> ExecuteShardedOperations(QueryTimingsScope scope);
    protected virtual ShardedMapReduceQueryResultsMerger CreateMapReduceQueryResultsMerger(ShardedIndexEntriesQueryResult result);
    protected virtual ShardedQueryCommand CreateCommand(int shardNumber, BlittableJsonReaderObject query, QueryTimingsScope scope);
    protected virtual QueryType<ShardedQueryCommand, QueryResult, ShardedIndexEntriesQueryResult> GetQueryType();
}
public class Raven.Server.Documents.Sharding.Queries.IndexEntries.ShardedMapReduceIndexEntriesQueryResultsMerger : ShardedMapReduceQueryResultsMerger {
    private static ShardedAutoMapReduceIndexResultsAggregatorForIndexEntries Aggregator;
    private string _reduceKeyHash;
    public ShardedMapReduceIndexEntriesQueryResultsMerger(List`1<BlittableJsonReaderObject> currentResults, ShardedIndexesContext indexesContext, string indexName, bool isAutoMapReduceQuery, TransactionOperationContext context, CancellationToken token);
    private static ShardedMapReduceIndexEntriesQueryResultsMerger();
    internal virtual AggregationResult AggregateForAutoMapReduce(AutoMapReduceIndexDefinition indexDefinition);
    protected virtual List`1<BlittableJsonReaderObject> AggregateForStaticMapReduce(IndexInformationHolder index);
    protected virtual AggregatedAnonymousObjects CreateShardedAggregatedAnonymousObjects(List`1<object> results, IPropertyAccessor propertyAccessor, bool skipImplicitNullInOutput);
}
public class Raven.Server.Documents.Sharding.Queries.ShardedAutoMapReduceIndexResultsAggregator : AutoMapReduceIndexResultsAggregator {
    private static DynamicJsonValue DummyDynamicJsonValue;
    private static ShardedAutoMapReduceIndexResultsAggregator();
}
public class Raven.Server.Documents.Sharding.Queries.ShardedAutoMapReduceIndexResultsAggregatorForIndexEntries : AutoMapReduceIndexResultsAggregator {
    private string _reduceKeyHash;
    internal virtual void HandleProperty(AutoMapReduceIndexDefinition indexDefinition, string propertyName, BlittableJsonReaderObject json, Dictionary`2<string, PropertyResult> aggregatedResult);
    internal virtual DynamicJsonValue BuildResult(KeyValuePair`2<BlittableJsonReaderObject, Dictionary`2<string, PropertyResult>> aggregationResult);
    internal virtual PropertyResult HandleSumAndCount(object value);
}
public class Raven.Server.Documents.Sharding.Queries.ShardedMapReduceQueryResultsMerger : object {
    private static ShardedAutoMapReduceIndexResultsAggregator Aggregator;
    protected List`1<BlittableJsonReaderObject> CurrentResults;
    private ShardedIndexesContext _indexesContext;
    private string _indexName;
    private bool _isAutoMapReduceQuery;
    protected TransactionOperationContext Context;
    protected CancellationToken Token;
    public ShardedMapReduceQueryResultsMerger(List`1<BlittableJsonReaderObject> currentResults, ShardedIndexesContext indexesContext, string indexName, bool isAutoMapReduceQuery, TransactionOperationContext context, CancellationToken token);
    private static ShardedMapReduceQueryResultsMerger();
    public List`1<BlittableJsonReaderObject> Merge();
    protected virtual List`1<BlittableJsonReaderObject> AggregateForStaticMapReduce(IndexInformationHolder index);
    protected virtual AggregatedAnonymousObjects CreateShardedAggregatedAnonymousObjects(List`1<object> results, IPropertyAccessor propertyAccessor, bool skipImplicitNullInOutput);
    internal virtual AggregationResult AggregateForAutoMapReduce(AutoMapReduceIndexDefinition indexDefinition);
}
public class Raven.Server.Documents.Sharding.Queries.ShardedQueryFilter : AbstractQueryFilter {
    private ShardedQueryResult _result;
    protected Nullable`1<long> ScannedDocuments { get; }
    public ShardedQueryFilter(IndexQueryServerSide query, ShardedQueryResult shardedQueryResult, QueryTimingsScope queryTimings, ScriptRunnerCache scriptRunnerCache, JsonOperationContext context);
    protected virtual Nullable`1<long> get_ScannedDocuments();
    public FilterResult Apply(BlittableJsonReaderObject result);
    protected virtual ScriptRunnerResult GetScriptRunnerResult(object translatedDoc);
    protected virtual void IncrementSkippedResults();
    protected virtual void IncrementScannedDocuments();
}
public class Raven.Server.Documents.Sharding.Queries.ShardedQueryProcessor : ShardedQueryProcessorBase`1<ShardedQueryResult> {
    public ShardedQueryProcessor(TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, IndexQueryServerSide query, Nullable`1<long> existingResultEtag, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.ShardedQueryProcessor/<ExecuteShardedOperations>d__1")]
public virtual Task`1<ShardedQueryResult> ExecuteShardedOperations(QueryTimingsScope scope);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.ShardedQueryProcessor/<HandleMissingCounterIncludeAsync>d__2")]
public static ValueTask HandleMissingCounterIncludeAsync(TransactionOperationContext context, HttpRequest request, ShardedDatabaseContext databaseContext, HashSet`1<string> missingCounterIncludes, ShardedQueryResult result, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.ShardedQueryProcessor/<HandleMissingTimeSeriesIncludesAsync>d__3")]
public static ValueTask HandleMissingTimeSeriesIncludesAsync(TransactionOperationContext context, HttpRequest request, ShardedDatabaseContext databaseContext, Dictionary`2<string, List`1<TimeSeriesRange>> missingTimeSeriesIncludes, ShardedQueryResult result, CancellationToken token);
    private void FilterAfterMapReduce(ShardedQueryResult& result, QueryTimingsScope scope);
    private void ProjectAfterMapReduce(ShardedQueryResult& result, QueryTimingsScope scope);
    [CompilerGeneratedAttribute]
private void <ProjectAfterMapReduce>g__AddDocument|5_0(BlittableJsonReaderObject documentData, <>c__DisplayClass5_0& );
}
public abstract class Raven.Server.Documents.Sharding.Queries.ShardedQueryProcessorBase`1 : AbstractShardedQueryProcessor`3<ShardedQueryCommand, QueryResult, TCombinedResult> {
    protected ShardedQueryProcessorBase`1(TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, IndexQueryServerSide query, Nullable`1<long> existingResultEtag, bool metadataOnly, bool indexEntriesOnly, bool ignoreLimit, CancellationToken token);
    protected virtual ShardedQueryCommand CreateCommand(int shardNumber, BlittableJsonReaderObject query, QueryTimingsScope scope);
    protected void ApplyPaging(TCombinedResult& result, QueryTimingsScope scope);
    protected void ReduceResults(TCombinedResult& result, QueryTimingsScope scope);
    protected virtual ShardedMapReduceQueryResultsMerger CreateMapReduceQueryResultsMerger(TCombinedResult result);
    [CompilerGeneratedAttribute]
internal static QueryTimingsScope <ApplyPaging>g__GetPagingScope|2_0(<>c__DisplayClass2_0& );
}
public class Raven.Server.Documents.Sharding.Queries.ShardedQueryResultDocument : Document {
    public List`1<OrderByField> OrderByFields;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <ResultDataHash>k__BackingField;
    public Nullable`1<ulong> ResultDataHash { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<ulong> get_ResultDataHash();
    [CompilerGeneratedAttribute]
public void set_ResultDataHash(Nullable`1<ulong> value);
    public void AddStringOrderByField(string value);
    public void AddLongOrderByField(long value);
    public void AddDoubleOrderByField(double value);
    public static ShardedQueryResultDocument From(Document doc);
}
[ExtensionAttribute]
public static class Raven.Server.Documents.Sharding.Queries.ShardedQueryResultDocumentExtensions : object {
    [ExtensionAttribute]
public static ShardedQueryResultDocument EnsureDataHashInQueryResultMetadata(Document doc);
}
public class Raven.Server.Documents.Sharding.Queries.ShardedQueryRunner : AbstractQueryRunner {
}
internal class Raven.Server.Documents.Sharding.Queries.ShardedQueryStreamProcessor : AbstractShardedQueryProcessor`3<PostQueryStreamCommand, StreamResult, ShardedStreamQueryResult> {
    private string _debug;
    private bool _ignoreLimit;
    public ShardedQueryStreamProcessor(TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, IndexQueryServerSide query, string debug, bool ignoreLimit, CancellationToken token);
    protected virtual void AssertQueryExecution();
    public virtual Task`1<ShardedStreamQueryResult> ExecuteShardedOperations(QueryTimingsScope scope);
    protected virtual PostQueryStreamCommand CreateCommand(int shardNumber, BlittableJsonReaderObject query, QueryTimingsScope scope);
    [CompilerGeneratedAttribute]
private ValueTuple`2<JsonOperationContext, IDisposable> <ExecuteShardedOperations>b__4_0();
}
[ExtensionAttribute]
public static class Raven.Server.Documents.Sharding.Queries.ShardedSuggestionResultExtensions : object {
    [ExtensionAttribute]
internal static ShardedSuggestionResult AddPopularity(SuggestionResult result, SuggestWord suggestion);
}
public class Raven.Server.Documents.Sharding.Queries.Suggestions.ShardedSuggestionQueryProcessor : AbstractShardedQueryProcessor`3<ShardedQueryCommand, QueryResult, SuggestionQueryResult> {
    public ShardedSuggestionQueryProcessor(TransactionOperationContext context, ShardedDatabaseRequestHandler requestHandler, IndexQueryServerSide query, Nullable`1<long> existingResultEtag, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Queries.Suggestions.ShardedSuggestionQueryProcessor/<ExecuteShardedOperations>d__1")]
public virtual Task`1<SuggestionQueryResult> ExecuteShardedOperations(QueryTimingsScope scope);
    protected virtual ShardedQueryCommand CreateCommand(int shardNumber, BlittableJsonReaderObject query, QueryTimingsScope scope);
}
internal class Raven.Server.Documents.Sharding.Queries.Suggestions.ShardedSuggestionResult : SuggestionResult {
    public Popularity SuggestionsWithPopularity;
}
public class Raven.Server.Documents.Sharding.ReplicationBatch : object {
    public List`1<ReplicationBatchItem> Items;
    public Dictionary`2<Slice, AttachmentReplicationItem> AttachmentStreams;
    public TaskCompletionSource BatchSent;
    public string LastAcceptedChangeVector;
    public long LastEtagAccepted;
    public long LastSentEtagFromSource;
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Sharding.ShardedDatabaseContext : object {
    public ShardedDocumentsChanges Changes;
    public ShardedCluster Cluster;
    public ShardedCompareExchangeStorage CompareExchangeStorage;
    private CancellationTokenSource _databaseShutdown;
    public ServerStore ServerStore;
    private DatabaseRecord _record;
    public QueryMetadataCache QueryMetadataCache;
    private Logger _logger;
    public ShardExecutor ShardExecutor;
    public AllOrchestratorNodesExecutor AllOrchestratorNodesExecutor;
    [CompilerGeneratedAttribute]
private RavenConfiguration <Configuration>k__BackingField;
    public SystemTime Time;
    public RachisLogIndexNotifications RachisLogIndexNotifications;
    public ConcurrentSet`1<TcpConnectionOptions> RunningTcpConnections;
    public MetricCounters Metrics;
    private StateChange _orchestratorStateChange;
    private StateChange _urlUpdateStateChange;
    public ShardedIndexesContext Indexes;
    public ShardedDatabaseNotificationCenter NotificationCenter;
    public ShardedOngoingTasks OngoingTasks;
    public ShardedOperations Operations;
    public ShardedQueryRunner QueryRunner;
    public ShardedReplicationContext Replication;
    public ShardedSmugglerContext Smuggler;
    public ShardedStreaming Streaming;
    public ShardedSubscriptionsStorage SubscriptionsStorage;
    internal TestingStuff ForTestingPurposes;
    public CancellationToken DatabaseShutdown { get; }
    public DatabaseRecord DatabaseRecord { get; }
    public RavenConfiguration Configuration { get; internal set; }
    public string DatabaseName { get; }
    public char IdentityPartsSeparator { get; }
    public bool Encrypted { get; }
    public int ShardCount { get; }
    public Dictionary`2<int, DatabaseTopology> ShardsTopology { get; }
    public ShardedDatabaseContext(ServerStore serverStore, DatabaseRecord record);
    public CancellationToken get_DatabaseShutdown();
    public DatabaseRecord get_DatabaseRecord();
    [CompilerGeneratedAttribute]
public RavenConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
internal void set_Configuration(RavenConfiguration value);
    public IDisposable AllocateOperationContext(JsonOperationContext& context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.ShardedDatabaseContext/<UpdateDatabaseRecordAsync>d__29")]
public ValueTask UpdateDatabaseRecordAsync(DatabaseRecord record, long index, string type, ClusterDatabaseChangeType changeType);
    private Task OnDatabaseRecordChange(DatabaseRecord record, long index);
    private bool CheckForTopologyChangesAndRaiseNotification(DatabaseTopology topology, DatabaseTopology oldTopology);
    private Task OnUrlChange(DatabaseRecord record, long index);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.ShardedDatabaseContext/<UpdateUrlsAsync>d__33")]
public ValueTask UpdateUrlsAsync(long index);
    public string get_DatabaseName();
    public char get_IdentityPartsSeparator();
    public bool get_Encrypted();
    public int get_ShardCount();
    public Dictionary`2<int, DatabaseTopology> get_ShardsTopology();
    public ValueTuple`2<int, int> GetShardNumberAndBucketFor(TransactionOperationContext context, string id);
    public int GetShardNumberFor(TransactionOperationContext context, string id);
    public int RecalculateShardNumberFor(TransactionOperationContext context, string id);
    public int GetShardNumberFor(ByteStringContext allocator, string id);
    public int GetShardNumberFor(ByteStringContext allocator, LazyStringValue id);
    public int GetShardNumberFor(Slice id);
    public ValueTuple`2<int, int> GetShardNumberAndBucketForIdentity(TransactionOperationContext context, string id);
    public bool HasTopologyChanged(long etag);
    private void UpdateConfiguration(Dictionary`2<string, string> settings);
    public bool IsShutdownRequested();
    public sealed virtual void Dispose();
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
private void <Dispose>b__54_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__54_1();
    [CompilerGeneratedAttribute]
private void <Dispose>b__54_2();
    [CompilerGeneratedAttribute]
private void <Dispose>b__54_3();
    [CompilerGeneratedAttribute]
private void <Dispose>b__54_4();
    [CompilerGeneratedAttribute]
private void <Dispose>b__54_5();
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.Sharding.ShardedDatabaseIdentifier : ValueType {
    public string NodeTag;
    public int ShardNumber;
    public ShardedDatabaseIdentifier(string nodeTag, int shardNumber);
    public bool Equals(ShardedDatabaseIdentifier other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Server.Documents.Sharding.ShardedDocumentDatabase : DocumentDatabase {
    private Logger _logger;
    public int ShardNumber;
    public string ShardedDatabaseName;
    [CompilerGeneratedAttribute]
private string <ShardedDatabaseId>k__BackingField;
    public ShardedDocumentsStorage ShardedDocumentsStorage;
    [CompilerGeneratedAttribute]
private ShardedDocumentsMigrator <DocumentsMigrator>k__BackingField;
    public ShardingConfiguration ShardingConfiguration;
    private ConcurrentDictionary`2<long, Task> _confirmations;
    public string ShardedDatabaseId { get; private set; }
    public ShardedDocumentsMigrator DocumentsMigrator { get; private set; }
    private string ReshardingFailureNotificationKey { get; }
    public ShardedDocumentDatabase(string name, RavenConfiguration configuration, ServerStore serverStore, Action`2<LogMode, string> addToInitLog);
    [CompilerGeneratedAttribute]
public string get_ShardedDatabaseId();
    [CompilerGeneratedAttribute]
private void set_ShardedDatabaseId(string value);
    [CompilerGeneratedAttribute]
public ShardedDocumentsMigrator get_DocumentsMigrator();
    [CompilerGeneratedAttribute]
private void set_DocumentsMigrator(ShardedDocumentsMigrator value);
    protected virtual Byte[] ReadSecretKey(TransactionOperationContext context);
    protected virtual void InitializeCompareExchangeStorage();
    protected virtual void InitializeAndStartDocumentsMigration();
    protected virtual DocumentsStorage CreateDocumentsStorage(Action`2<LogMode, string> addToInitLog);
    protected virtual IndexStore CreateIndexStore(ServerStore serverStore);
    protected virtual ReplicationLoader CreateReplicationLoader();
    [PreserveBaseOverridesAttribute]
protected virtual override ShardSubscriptionStorage CreateSubscriptionStorage(ServerStore serverStore);
    internal virtual void SetIds(DatabaseTopology topology, string shardedDatabaseId);
    protected virtual void OnDatabaseRecordChanged(DatabaseRecord record);
    public void HandleReshardingChanges();
    protected virtual ClusterTransactionBatchCollector CollectCommandsBatch(ClusterOperationContext context, long lastCompletedClusterTransactionIndex, int take);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.ShardedDocumentDatabase/<DeleteBucketAsync>d__27")]
public Task DeleteBucketAsync(int bucket, long migrationIndex, long confirmationIndex, string uptoChangeVector);
    private string get_ReshardingFailureNotificationKey();
    private void RaiseNotificationOnDeleteBucketFailure(int bucket, Exception exception);
    private void DismissNotificationOnDeleteBucketSuccessIfNeeded();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.ShardedDocumentDatabase/<WaitForOrchestratorConfirmationAsync>d__32")]
private Task WaitForOrchestratorConfirmationAsync(long confirmationIndex);
    public static ShardedDocumentDatabase CastToShardedDocumentDatabase(DocumentDatabase database);
    [CompilerGeneratedAttribute]
private Task <HandleReshardingChanges>b__24_0(Task __);
}
public class Raven.Server.Documents.Sharding.ShardedDocumentPutAction : DocumentPutAction {
    public ShardedDocumentPutAction(ShardedDocumentsStorage documentsStorage, ShardedDocumentDatabase documentDatabase);
    protected virtual void CalculateSuffixForIdentityPartsSeparator(string id, Char*& idSuffixPtr, Int32& idSuffixLength, Int32& idLength);
    protected virtual void WriteSuffixForIdentityPartsSeparator(Char*& valueWritePosition, Char* idSuffixPtr, int idSuffixLength);
}
public class Raven.Server.Documents.Sharding.ShardedDocumentsStorage : DocumentsStorage {
    public static Slice BucketStatsSlice;
    private BucketStatsHolder _bucketStats;
    private ShardedDocumentDatabase _documentDatabase;
    [CompilerGeneratedAttribute]
private Action`1<IPagerLevelTransactionState> <OnFailure>k__BackingField;
    private static long MaxDocumentsToDeleteInBucket;
    public Action`1<IPagerLevelTransactionState> OnFailure { get; }
    private static ShardedDocumentsStorage();
    public ShardedDocumentsStorage(ShardedDocumentDatabase documentDatabase, Action`2<LogMode, string> addToInitLog);
    [CompilerGeneratedAttribute]
public Action`1<IPagerLevelTransactionState> get_OnFailure();
    protected virtual DocumentPutAction CreateDocumentPutAction();
    protected virtual void SetDocumentsStorageSchemas();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.ShardedDocumentsStorage/<GetDocumentsByBucketFrom>d__10")]
public IEnumerable`1<Document> GetDocumentsByBucketFrom(DocumentsOperationContext context, int bucket, long etag, long skip, long take, DocumentFields fields);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.ShardedDocumentsStorage/<GetBucketStatistics>d__11")]
public static IEnumerable`1<BucketStats> GetBucketStatistics(DocumentsOperationContext context, int fromBucket, int toBucket);
    public static BucketStats GetBucketStatisticsFor(DocumentsOperationContext context, int bucket);
    private static BucketStats ValueReaderToBucketStats(int bucket, ValueReader& valueReader);
    private static int GetBucketNumberFromBucketStatsKey(Slice key);
    [StorageIndexEntryKeyGeneratorAttribute]
internal static Scope<ByteStringMemoryCache> GenerateBucketAndEtagIndexKeyForDocuments(Transaction tx, TableValueReader& tvr, Slice& slice);
    [StorageIndexEntryKeyGeneratorAttribute]
internal static Scope<ByteStringMemoryCache> GenerateBucketAndEtagIndexKeyForTombstones(Transaction tx, TableValueReader& tvr, Slice& slice);
    internal static Scope<ByteStringMemoryCache> GenerateBucketAndEtagIndexKey(Transaction tx, int idIndex, int etagIndex, TableValueReader& tvr, Slice& slice);
    internal static Scope<ByteStringMemoryCache> ExtractIdFromKeyAndGenerateBucketAndEtagIndexKey(Transaction tx, int keyIndex, int etagIndex, TableValueReader& tvr, Slice& slice);
    private static Scope<ByteStringMemoryCache> GenerateBucketAndEtagSlice(Transaction tx, Byte* idPtr, int idSize, long etag, Slice& slice);
    internal static void UpdateBucketStatsForDocument(Transaction tx, Slice key, TableValueReader& oldValue, TableValueReader& newValue);
    internal static void UpdateBucketStatsForTombstones(Transaction tx, Slice key, TableValueReader& oldValue, TableValueReader& newValue);
    internal static void UpdateBucketStatsInternal(Transaction tx, Slice key, TableValueReader& value, int changeVectorIndex, long sizeChange, int numOfDocsChanged);
    internal static void UpdateBucketStatsInternal(Transaction tx, Slice key, long sizeChange, int numOfDocsChanged);
    public ChangeVector GetMergedChangeVectorInBucket(DocumentsOperationContext context, int bucket);
    public bool HaveMoreDocumentsInBucketAfter(int bucket, long after, String& merged);
    public IEnumerable`1<ReplicationBatchItem> GetTombstonesByBucketFrom(DocumentsOperationContext context, int bucket, long etag);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.ShardedDocumentsStorage/<RetrieveTombstonesByBucketFrom>d__27")]
public IEnumerable`1<Tombstone> RetrieveTombstonesByBucketFrom(DocumentsOperationContext context, int bucket, long etag);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.ShardedDocumentsStorage/<GetItemsByBucket>d__28")]
public static IEnumerable`1<SeekResult> GetItemsByBucket(ByteStringContext allocator, Table table, DynamicKeyIndexDef dynamicIndex, int bucket, long etag, long skip, long take);
    public DeleteBucketResult DeleteBucket(DocumentsOperationContext context, int bucket, ChangeVector upTo);
    private void MarkTombstonesAsArtificial(DocumentsOperationContext context, int bucket, ChangeVector upTo);
    private bool HasDocumentExtensionWithGreaterChangeVector(DocumentsOperationContext context, string documentId, ChangeVector upTo);
    public static InternalScope<ByteStringMemoryCache> GetBucketByteString(ByteStringContext allocator, int bucket, ByteString& buffer);
    public static InternalScope<ByteStringMemoryCache> GetBucketAndEtagByteString(ByteStringContext allocator, int bucket, long etag, ByteString& buffer);
    public virtual void ValidateId(DocumentsOperationContext context, Slice lowerId, DocumentChangeTypes type, DocumentFlags documentFlags);
}
public static class Raven.Server.Documents.Sharding.ShardLocator : object {
    public static Dictionary`2<int, IdsByShard`1<string>> GetDocumentIdsByShards(TransactionOperationContext context, ShardedDatabaseContext databaseContext, IEnumerable`1<ReadOnlyMemory`1<char>> ids);
    public static Dictionary`2<int, IdsByShard`1<string>> GetDocumentIdsByShards(TransactionOperationContext context, ShardedDatabaseContext databaseContext, IEnumerable`1<string> ids);
    public static Dictionary`2<int, IdsByShard`1<Slice>> GetDocumentIdsByShards(TransactionOperationContext context, ShardedDatabaseContext databaseContext, IEnumerable`1<Slice> ids);
    public static Dictionary`2<int, IdsByShard`1<string>> GetDocumentIdsByShards(ShardedDatabaseContext databaseContext, IEnumerable`1<string> ids);
    private static Dictionary`2<int, IdsByShard`1<T>> GetDocumentIdsByShardsGeneric(TransactionOperationContext context, ShardedDatabaseContext databaseContext, IEnumerable`1<T> ids);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Sharding.ShardLocator/<ConvertToStringEnumerable>d__6")]
private static IEnumerable`1<string> ConvertToStringEnumerable(IEnumerable`1<ReadOnlyMemory`1<char>> items);
}
public class Raven.Server.Documents.Sharding.ShardReplicationNode : ExternalReplication {
    public int ShardNumber;
    public ShardReplicationNode(string database, string connectionStringName, int shardNumber);
}
public class Raven.Server.Documents.Sharding.Smuggler.ShardedDatabaseDestination : DatabaseDestination {
    public ShardedDatabaseDestination(ShardedDocumentDatabase database, CancellationToken token);
    protected virtual ICompareExchangeActions CreateCompareExchangeActions(string databaseName, JsonOperationContext context, Nullable`1<BackupKind> backupKind);
}
public class Raven.Server.Documents.Sharding.Smuggler.ShardedDatabaseSmugglerFactory : AbstractDatabaseSmugglerFactory {
    private ShardedDocumentDatabase _database;
    public ShardedDatabaseSmugglerFactory(ShardedDocumentDatabase database);
    public virtual DatabaseDestination CreateDestination(CancellationToken token);
    public virtual DatabaseDestination CreateDestinationForSnapshotRestore(Dictionary`2<string, SubscriptionState> subscriptions, CancellationToken token);
    public virtual DatabaseSource CreateSource(long startDocumentEtag, long startRaftIndex, Logger logger);
    public virtual SmugglerBase CreateForRestore(DatabaseRecord databaseRecord, ISmugglerSource source, ISmugglerDestination destination, JsonOperationContext context, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
    public virtual SmugglerBase Create(ISmugglerSource source, ISmugglerDestination destination, JsonOperationContext context, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
}
public class Raven.Server.Documents.Sharding.Streaming.CombinedReadContinuationState : object {
    private ShardedDatabaseContext _databaseContext;
    private CombinedStreamResult _combinedStream;
    public Dictionary`2<int, ReadContinuationState> States;
    public CancellationToken CancellationToken;
    public CombinedReadContinuationState(ShardedDatabaseContext databaseContext, CombinedStreamResult combinedStream);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Streaming.CombinedReadContinuationState/<InitializeAsync>d__5")]
public ValueTask InitializeAsync(CancellationToken token);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Sharding.Streaming.CombinedStreamResult : object {
    public Dictionary`2<int, ShardExecutionResult`1<StreamResult>> Results;
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Streaming.CombinedStreamResult/<InitializeAsync>d__1")]
public ValueTask`1<CombinedReadContinuationState> InitializeAsync(ShardedDatabaseContext databaseContext, CancellationToken token);
}
public class Raven.Server.Documents.Sharding.Streaming.Comparers.DocumentByLastModifiedDescComparer : Comparer`1<Document> {
    public static DocumentByLastModifiedDescComparer Instance;
    private static DocumentByLastModifiedDescComparer();
    public virtual int Compare(Document x, Document y);
}
public class Raven.Server.Documents.Sharding.Streaming.Comparers.StreamDocumentByLastModifiedComparer : Comparer`1<ShardStreamItem`1<Document>> {
    public static StreamDocumentByLastModifiedComparer Instance;
    private static StreamDocumentByLastModifiedComparer();
    public virtual int Compare(ShardStreamItem`1<Document> x, ShardStreamItem`1<Document> y);
}
public class Raven.Server.Documents.Sharding.Streaming.ReadContinuationState : object {
    private StreamResult _response;
    private CancellationToken _token;
    private JsonOperationContext _inputContext;
    private JsonParserState _state;
    private UnmanagedJsonParser _parser;
    private MemoryBuffer _buffer;
    private ReturnBuffer _returnBuffer;
    private PeepingTomStream _peepingTomStream;
    private JsonOperationContext _builderContext;
    private IDisposable _builderReturnContext;
    private IDisposable _inputReturnContext;
    private BlittableJsonDocumentBuilder _builder;
    private int _maxCachedLimit;
    public JsonParserToken CurrentTokenType { get; }
    public long ReadLong { get; }
    public ReadContinuationState(JsonContextPool pool, StreamResult response, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Streaming.ReadContinuationState/<InitializeAsync>d__14")]
public ValueTask InitializeAsync();
    public string ReadString();
    public Task`1<bool> ReadAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Streaming.ReadContinuationState/<ReadJsonArrayAsync>d__17")]
public ValueTask`1<BlittableJsonReaderArray> ReadJsonArrayAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Streaming.ReadContinuationState/<ReadObjectAsync>d__18")]
public ValueTask`1<BlittableJsonReaderObject> ReadObjectAsync();
    public JsonParserToken get_CurrentTokenType();
    public long get_ReadLong();
    public void ThrowInvalidJson();
    public bool TryRenewCacheIfNeeded(int limit);
    public sealed virtual void Dispose();
}
public static class Raven.Server.Documents.Sharding.Streaming.ShardResultConverter : object {
    public static Document BlittableToDocumentConverter(BlittableJsonReaderObject json);
    public static List`1<string> BlittableToStringListConverter(BlittableJsonReaderArray json);
}
internal class Raven.Server.Documents.Sharding.Streaming.ShardStreamExposerHolder`1 : object {
    [CompilerGeneratedAttribute]
private T <ContentExposer>k__BackingField;
    [CompilerGeneratedAttribute]
private IDisposable <ContextReturn>k__BackingField;
    public T ContentExposer { get; public set; }
    public IDisposable ContextReturn { get; public set; }
    [CompilerGeneratedAttribute]
public T get_ContentExposer();
    [CompilerGeneratedAttribute]
public void set_ContentExposer(T value);
    [CompilerGeneratedAttribute]
public IDisposable get_ContextReturn();
    [CompilerGeneratedAttribute]
public void set_ContextReturn(IDisposable value);
    public sealed virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
private void <DisposeAsync>b__8_0();
}
public class Raven.Server.Documents.Sharding.Streaming.ShardStreamItem`1 : object {
    public T Item;
    public int ShardNumber;
}
public class Raven.Server.Documents.Sharding.Streaming.YieldShardStreamResults : object {
    private ReadContinuationState _readingState;
    private string _arrayPropertyName;
    private bool _initialized;
    private int _processed;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Current>k__BackingField;
    public BlittableJsonReaderObject Current { get; private set; }
    public YieldShardStreamResults(ReadContinuationState readingState, string arrayPropertyName);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Streaming.YieldShardStreamResults/<MoveNextAsync>d__5")]
public sealed virtual ValueTask`1<bool> MoveNextAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Streaming.YieldShardStreamResults/<StartReadArray>d__6")]
public ValueTask StartReadArray();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Streaming.YieldShardStreamResults/<InitializeAsync>d__7")]
public Task InitializeAsync();
    public void Reset();
    [CompilerGeneratedAttribute]
public sealed virtual BlittableJsonReaderObject get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(BlittableJsonReaderObject value);
    private void AssertInitialized();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Streaming.YieldShardStreamResults/<DisposeAsync>d__14")]
public sealed virtual ValueTask DisposeAsync();
}
public class Raven.Server.Documents.Sharding.Subscriptions.OrchestratedSubscriptionConnection : SubscriptionConnectionBase`1<OrchestratorIncludesCommandImpl> {
    private SubscriptionConnectionsStateOrchestrator _state;
    private ShardedDatabaseContext _databaseContext;
    private OrchestratedSubscriptionProcessor _processor;
    private IDisposable _tokenRegisterDisposable;
    private HashSet`1<string> _dbIdsToRemove;
    public OrchestratedSubscriptionConnection(ServerStore serverStore, ShardedSubscriptionsStorage subscriptions, TcpConnectionOptions tcpConnection, IDisposable tcpConnectionDisposable, MemoryBuffer buffer);
    public SubscriptionConnectionsStateOrchestrator GetOrchestratedSubscriptionConnectionState();
    public virtual void FinishProcessing();
    protected virtual StatusMessageDetails<OrchestratorIncludesCommandImpl> GetStatusMessageDetails();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.OrchestratedSubscriptionConnection/<OnClientAckAsync>d__9")]
protected virtual Task OnClientAckAsync(string clientReplyChangeVector);
    protected virtual void GatherIncludesForDocument(OrchestratorIncludesCommandImpl includeDocuments, Document document);
    public virtual SubscriptionConnectionInfo CreateConnectionInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.OrchestratedSubscriptionConnection/<WaitForChangedDocsAsync>d__12")]
protected virtual Task`1<bool> WaitForChangedDocsAsync(AbstractSubscriptionConnectionsState state);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.OrchestratedSubscriptionConnection/<NotifyShardAboutBatchCompletionAsync>d__13")]
private Task NotifyShardAboutBatchCompletionAsync(string orchestratorCv);
    public virtual Task SendNoopAckAsync(bool force);
    protected virtual bool FoundAboutMoreDocs();
    protected virtual SubscriptionConnectionInUse<OrchestratorIncludesCommandImpl> MarkInUse();
    protected virtual void AfterProcessorCreation();
    protected virtual void RaiseNotificationForBatchEnd(string name, SubscriptionBatchStatsAggregator last);
    protected virtual Task`1<SubscriptionBatchStatus> TryRecordBatchAndUpdateStatusAsync(IChangeVectorOperationContext context, SubscriptionBatchResult result);
    protected virtual void AssertSupportedFeatures();
    protected virtual void AssertCloseWhenNoDocsLeft();
    public virtual ISubscriptionProcessor`1<OrchestratorIncludesCommandImpl> CreateProcessor(SubscriptionConnectionBase`1<OrchestratorIncludesCommandImpl> connection);
    protected virtual void OnError(Exception e);
    protected virtual void DisposeInternal();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
    [CompilerGeneratedAttribute]
private SubscriptionConnectionsStateOrchestrator <GetOrchestratedSubscriptionConnectionState>b__6_0(long subId);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<bool> <>n__0(AbstractSubscriptionConnectionsState state);
}
public class Raven.Server.Documents.Sharding.Subscriptions.ShardedDocumentsDatabaseSubscriptionProcessor : DocumentsDatabaseSubscriptionProcessor {
    private ShardedDocumentDatabase _database;
    private ShardingConfiguration _sharding;
    private ByteStringContext _allocator;
    public HashSet`1<string> Skipped;
    public ShardedDocumentsDatabaseSubscriptionProcessor(ServerStore server, ShardedDocumentDatabase database, SubscriptionConnection connection);
    protected virtual SubscriptionFetcher`1<Document> CreateFetcher();
    protected virtual ConflictStatus GetConflictStatus(string changeVector);
    protected virtual bool CanContinueBatch(SubscriptionBatchItemStatus batchItemStatus, SubscriptionBatchStatsScope batchScope, int numberOfDocs, Stopwatch sendingCurrentBatchStopwatch);
    protected virtual SubscriptionBatchStatus SetBatchStatus(SubscriptionBatchResult result);
    protected virtual void HandleBatchItem(SubscriptionBatchStatsScope batchScope, SubscriptionBatchItem batchItem, SubscriptionBatchResult result, Document item);
    protected virtual string SetLastChangeVectorInThisBatch(IChangeVectorOperationContext context, string currentLast, SubscriptionBatchItem batchItem);
    protected virtual SubscriptionBatchItem ShouldSend(Document item, String& reason);
    public static bool IsUnderActiveMigration(string id, ShardingConfiguration sharding, ByteStringContext allocator, int shardNumber, FetchingOrigin fetchingFrom, String& reason, Boolean& isActiveMigration);
    public virtual void Dispose();
    protected virtual bool CheckIfNewerInResendList(DocumentsOperationContext context, string id, string cvInStorage, string cvInResendList);
    protected virtual bool ShouldFetchFromResend(DocumentsOperationContext context, string id, Document item, string currentChangeVector, String& reason);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.ShardedDocumentsDatabaseSubscriptionProcessor/<TryRecordBatchAsync>d__16")]
public virtual Task`1<long> TryRecordBatchAsync(string lastChangeVectorSentInThisBatch);
    public virtual Task AcknowledgeBatchAsync(long batchId, string changeVector);
    [PreserveBaseOverridesAttribute]
protected virtual override ShardIncludesCommandImpl CreateIncludeCommands();
}
public class Raven.Server.Documents.Sharding.Subscriptions.ShardedRevisionsDatabaseSubscriptionProcessor : RevisionsDatabaseSubscriptionProcessor {
    private ShardedDocumentDatabase _database;
    private ShardingConfiguration _sharding;
    private ByteStringContext _allocator;
    public ShardedRevisionsDatabaseSubscriptionProcessor(ServerStore server, ShardedDocumentDatabase database, SubscriptionConnection connection);
    protected virtual SubscriptionFetcher`1<ValueTuple`2<Document, Document>> CreateFetcher();
    protected virtual SubscriptionBatchItem ShouldSend(ValueTuple`2<Document, Document> item, String& reason);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Sharding.Subscriptions.ShardedSubscriptionBatch : SubscriptionBatchBase`1<BlittableJsonReaderObject> {
    public TaskCompletionSource SendBatchToClientTcs;
    public TaskCompletionSource ConfirmFromShardSubscriptionConnectionTcs;
    public string ShardName;
    private ShardedDatabaseContext _databaseContext;
    public IDisposable ReturnContext;
    public JsonOperationContext Context;
    private ShardedQueryResult _result;
    private HashSet`1<string> _missingIds;
    public ShardedSubscriptionBatch(RequestExecutor requestExecutor, string dbName, Logger logger, ShardedDatabaseContext databaseContext);
    public void SetCancel();
    public void SetException(Exception e);
    protected virtual void EnsureDocumentId(BlittableJsonReaderObject item, string id);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.ShardedSubscriptionBatch/<InitializeAsync>d__10")]
internal virtual ValueTask InitializeAsync(BatchFromServer batch);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.ShardedSubscriptionBatch/<InitializeDocumentIncludesAsync>d__11")]
internal ValueTask InitializeDocumentIncludesAsync(BatchFromServer batchFromServer);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.ShardedSubscriptionBatch/<TryGatherMissingDocumentIncludesAsync>d__14")]
private ValueTask TryGatherMissingDocumentIncludesAsync(List`1<BlittableJsonReaderObject> list);
    public void CloneIncludes(ClusterOperationContext context, OrchestratorIncludesCommandImpl includes);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0(BatchFromServer batch);
}
public class Raven.Server.Documents.Sharding.Subscriptions.ShardedSubscriptionWorker : AbstractSubscriptionWorker`2<ShardedSubscriptionBatch, BlittableJsonReaderObject> {
    private int _shardNumber;
    private RequestExecutor _shardRequestExecutor;
    private SubscriptionConnectionsStateOrchestrator _state;
    private bool _closedDueNoDocsLeft;
    private ShardedDatabaseContext _databaseContext;
    public Task SubscriptionTask { get; }
    public ShardedSubscriptionWorker(SubscriptionWorkerOptions options, string dbName, RequestExecutor re, SubscriptionConnectionsStateOrchestrator state);
    public Task get_SubscriptionTask();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.ShardedSubscriptionWorker/<PrepareBatchAsync>d__8")]
internal virtual Task`1<BatchFromServer> PrepareBatchAsync(JsonContextPool contextPool, Stream tcpStreamCopy, MemoryBuffer buffer, ShardedSubscriptionBatch batch, Task notifiedSubscriber);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.ShardedSubscriptionWorker/<SendAckAsync>d__9")]
protected virtual Task SendAckAsync(ShardedSubscriptionBatch batch, Stream stream, JsonOperationContext context, CancellationToken token);
    protected virtual Task TrySetRedirectNode(RequestExecutor reqEx, IReadOnlyList`1<ServerNode> curTopology);
    protected virtual RequestExecutor GetRequestExecutor();
    protected virtual void SetLocalRequestExecutor(string url, X509Certificate2 cert);
    protected virtual ShardedSubscriptionBatch CreateEmptyBatch();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.ShardedSubscriptionWorker/<TryPublishBatchAsync>d__14")]
public Task TryPublishBatchAsync(ShardedSubscriptionBatch batch);
    protected virtual ValueTuple`2<bool, ServerNode> CheckIfShouldReconnectWorker(Exception ex, Action assertLastConnectionFailure, Action`1<Exception> onUnexpectedSubscriptionError, bool throwOnRedirectNodeNotFound);
    protected virtual ValueTuple`2<bool, ServerNode> HandleSubscriptionClosedException(SubscriptionClosedException sce);
    protected virtual ValueTuple`2<bool, ServerNode> HandleShouldNotTryToReconnect();
    protected virtual ValueTuple`2<bool, ServerNode> HandleAggregateException();
    protected virtual ValueTuple`2<bool, ServerNode> HandleSubscriptionChangeVectorUpdateConcurrencyException(SubscriptionChangeVectorUpdateConcurrencyException subscriptionChangeVectorUpdateConcurrencyException);
    protected virtual void HandleSubscriberError(Exception ex);
    protected virtual TimeSpan GetTimeToWaitBeforeConnectionRetry();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.ShardedSubscriptionWorker/<TrySetRedirectNodeOnConnectToServerAsync>d__22")]
protected virtual Task TrySetRedirectNodeOnConnectToServerAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.ShardedSubscriptionWorker/<TryGetRequestedNode>d__23")]
private Task`1<ServerNode> TryGetRequestedNode(RequestExecutor re, string node);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<BatchFromServer> <>n__0(JsonContextPool contextPool, Stream tcpStreamCopy, MemoryBuffer buffer, ShardedSubscriptionBatch batch, Task notifiedSubscriber);
}
public class Raven.Server.Documents.Sharding.Subscriptions.SubscriptionConnectionsStateOrchestrator : AbstractSubscriptionConnectionsState`2<OrchestratedSubscriptionConnection, OrchestratorIncludesCommandImpl> {
    internal ShardedDatabaseContext _databaseContext;
    private Dictionary`2<string, ShardedSubscriptionWorker> _shardWorkers;
    private TaskCompletionSource _initialConnection;
    private SubscriptionWorkerOptions _options;
    public BlockingCollection`1<ShardedSubscriptionBatch> Batches;
    public int ClosedDueToNoDocs;
    private ConcurrentQueue`1<ShardedSubscriptionWorkerInfo> _recentShardedWorkers;
    public Dictionary`2<string, ShardedSubscriptionWorker> ShardWorkers { get; }
    public bool SubscriptionClosedDueNoDocs { get; }
    public IEnumerable`1<ShardedSubscriptionWorkerInfo> RecentShardedWorkers { get; }
    public SubscriptionConnectionsStateOrchestrator(ServerStore server, ShardedDatabaseContext databaseContext, long subscriptionId);
    public Dictionary`2<string, ShardedSubscriptionWorker> get_ShardWorkers();
    public bool get_SubscriptionClosedDueNoDocs();
    public IEnumerable`1<ShardedSubscriptionWorkerInfo> get_RecentShardedWorkers();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.SubscriptionConnectionsStateOrchestrator/<SubscribeAsync>d__14")]
public virtual Task`1<ValueTuple`2<IDisposable, long>> SubscribeAsync(OrchestratedSubscriptionConnection connection, Stopwatch registerConnectionDuration);
    private void StartShardSubscriptionWorkers(OrchestratedSubscriptionConnection connection);
    private ShardedSubscriptionWorker CreateShardedWorkerHolder(string shard, RequestExecutor re, Nullable`1<DateTime> lastErrorDateTime);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.SubscriptionConnectionsStateOrchestrator/<UpdateClientConnectionTime>d__17")]
public virtual Task UpdateClientConnectionTime();
    protected virtual void SetLastChangeVectorSent(OrchestratedSubscriptionConnection connection);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.SubscriptionConnectionsStateOrchestrator/<InitializeAsync>d__19")]
public virtual Task InitializeAsync(OrchestratedSubscriptionConnection connection, bool afterSubscribe);
    protected virtual UpdateSubscriptionClientConnectionTime GetUpdateSubscriptionClientConnectionTime();
    public virtual Task WaitForIndexNotificationAsync(long index);
    public virtual void ReleaseConcurrentConnectionLock(OrchestratedSubscriptionConnection connection);
    public virtual Task TakeConcurrentConnectionLockAsync(OrchestratedSubscriptionConnection connection);
    public virtual void DropSubscription(SubscriptionException e);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.SubscriptionConnectionsStateOrchestrator/<HandleConnectionExceptionAsync>d__25")]
public virtual Task HandleConnectionExceptionAsync(OrchestratedSubscriptionConnection connection, Exception e);
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Sharding.Subscriptions.SubscriptionConnectionsStateOrchestrator/<DisposeWorkersAsync>d__27")]
public ValueTask DisposeWorkersAsync(bool waitForSubscriptionTask);
    private void AddToRecentShardedWorkers(KeyValuePair`2<string, ShardedSubscriptionWorker> w);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ValueTuple`2<IDisposable, long>> <>n__0(OrchestratedSubscriptionConnection connection, Stopwatch registerConnectionDuration);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(OrchestratedSubscriptionConnection connection, bool afterSubscribe);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__2(OrchestratedSubscriptionConnection connection, Exception e);
}
public abstract class Raven.Server.Documents.Smuggler.AbstractDatabaseSmugglerFactory : object {
    public abstract virtual DatabaseDestination CreateDestination(CancellationToken token);
    public abstract virtual DatabaseDestination CreateDestinationForSnapshotRestore(Dictionary`2<string, SubscriptionState> subscriptions, CancellationToken token);
    public abstract virtual DatabaseSource CreateSource(long startDocumentEtag, long startRaftIndex, Logger logger);
    public abstract virtual SmugglerBase CreateForRestore(DatabaseRecord databaseRecord, ISmugglerSource source, ISmugglerDestination destination, JsonOperationContext context, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
    public abstract virtual SmugglerBase Create(ISmugglerSource source, ISmugglerDestination destination, JsonOperationContext context, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
}
public class Raven.Server.Documents.Smuggler.DatabaseSmugglerFactory : AbstractDatabaseSmugglerFactory {
    private DocumentDatabase _database;
    public DatabaseSmugglerFactory(DocumentDatabase database);
    public virtual DatabaseDestination CreateDestination(CancellationToken token);
    public virtual DatabaseDestination CreateDestinationForSnapshotRestore(Dictionary`2<string, SubscriptionState> subscriptions, CancellationToken token);
    public virtual DatabaseSource CreateSource(long startDocumentEtag, long startRaftIndex, Logger logger);
    public virtual SmugglerBase CreateForRestore(DatabaseRecord databaseRecord, ISmugglerSource source, ISmugglerDestination destination, JsonOperationContext context, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
    public virtual SmugglerBase Create(ISmugglerSource source, ISmugglerDestination destination, JsonOperationContext context, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
}
public class Raven.Server.Documents.SpatialResult : ValueType {
    public double Distance;
    public double Latitude;
    public double Longitude;
    public static SpatialResult Invalid;
    private static SpatialResult();
    public static Nullable`1<SpatialResult> op_Explicit(Nullable`1<SpatialResult> coraxSpatialResult);
    public DynamicJsonValue ToJson();
}
internal class Raven.Server.Documents.StartRecordingDetails : RecordingDetails {
    private static string DetailsType;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    [CompilerGeneratedAttribute]
public string get_Version();
}
public class Raven.Server.Documents.StreamsTempFile : object {
    private string _tempFile;
    private bool _encrypted;
    internal TempFileStream _file;
    internal bool _reading;
    private InnerStream _previousInstance;
    public long Generation;
    public StreamsTempFile(string tempFile, StorageEnvironment environment);
    public StreamsTempFile(string tempFile, bool encrypted);
    public Stream StartNewStream();
    public IDisposable Scope();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Scope>b__9_0();
}
public class Raven.Server.Documents.Studio.FeedbackForm : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private FeedbackProduct <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private FeedbackUser <User>k__BackingField;
    public string Message { get; public set; }
    public FeedbackProduct Product { get; public set; }
    public FeedbackUser User { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public FeedbackProduct get_Product();
    [CompilerGeneratedAttribute]
public void set_Product(FeedbackProduct value);
    [CompilerGeneratedAttribute]
public FeedbackUser get_User();
    [CompilerGeneratedAttribute]
public void set_User(FeedbackUser value);
}
public class Raven.Server.Documents.Studio.FooterStatistics : object {
    [CompilerGeneratedAttribute]
private long <CountOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <StaleIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfStaleIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfIndexingErrors>k__BackingField;
    public long CountOfDocuments { get; public set; }
    public long CountOfIndexes { get; public set; }
    public String[] StaleIndexes { get; public set; }
    public long CountOfStaleIndexes { get; public set; }
    public long CountOfIndexingErrors { get; public set; }
    [CompilerGeneratedAttribute]
public long get_CountOfDocuments();
    [CompilerGeneratedAttribute]
public void set_CountOfDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfIndexes();
    [CompilerGeneratedAttribute]
public void set_CountOfIndexes(long value);
    [CompilerGeneratedAttribute]
public String[] get_StaleIndexes();
    [CompilerGeneratedAttribute]
public void set_StaleIndexes(String[] value);
    [CompilerGeneratedAttribute]
public long get_CountOfStaleIndexes();
    [CompilerGeneratedAttribute]
public void set_CountOfStaleIndexes(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfIndexingErrors();
    [CompilerGeneratedAttribute]
public void set_CountOfIndexingErrors(long value);
    public void CombineWith(FooterStatistics stats);
}
public abstract class Raven.Server.Documents.Subscriptions.AbstractSubscriptionConnectionsState : object {
    private AsyncManualResetEvent _waitForMoreDocuments;
    public CancellationTokenSource CancellationTokenSource;
    protected string _subscriptionName;
    public string Query;
    public string LastChangeVectorSent;
    protected ConcurrentSet`1<SubscriptionConnectionInfo> _pendingConnections;
    protected ConcurrentQueue`1<SubscriptionConnectionInfo> _recentConnections;
    protected ConcurrentQueue`1<SubscriptionConnectionInfo> _rejectedConnections;
    public string SubscriptionName { get; }
    public IEnumerable`1<SubscriptionConnectionInfo> RecentConnections { get; }
    public IEnumerable`1<SubscriptionConnectionInfo> RecentRejectedConnections { get; }
    public IEnumerable`1<SubscriptionConnectionInfo> PendingConnections { get; }
    protected AbstractSubscriptionConnectionsState(CancellationToken token);
    public string get_SubscriptionName();
    public IEnumerable`1<SubscriptionConnectionInfo> get_RecentConnections();
    public IEnumerable`1<SubscriptionConnectionInfo> get_RecentRejectedConnections();
    public IEnumerable`1<SubscriptionConnectionInfo> get_PendingConnections();
    public abstract virtual bool IsSubscriptionActive();
    public void NotifyHasMoreDocs();
    public Task`1<bool> WaitForMoreDocs();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.AbstractSubscriptionConnectionsState/<GetResendItems>d__20")]
public static IEnumerable`1<ResendItem> GetResendItems(ClusterOperationContext context, string database, long id);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.AbstractSubscriptionConnectionsState/<GetDocumentsFromResend>d__21")]
public static IEnumerable`1<DocumentRecord> GetDocumentsFromResend(ClusterOperationContext context, string database, long subscriptionId, HashSet`1<long> activeBatches);
    public static long GetNumberOfResendDocuments(ServerStore store, string database, SubscriptionType type, long id);
    public static InternalScope<ByteStringMemoryCache> GetDatabaseAndSubscriptionKeyPrefix(ClusterOperationContext context, string database, long subscriptionId, SubscriptionType type, ByteString& prefix);
    public static InternalScope<ByteStringMemoryCache> GetDatabaseAndSubscriptionAndDocumentKey(ClusterOperationContext context, string database, long subscriptionId, string documentId, ByteString& key);
    public static InternalScope<ByteStringMemoryCache> GetDatabaseAndSubscriptionAndRevisionKey(ClusterOperationContext context, string database, long subscriptionId, string documentId, string currentChangeVector, ByteString& key);
    public static InternalScope<ByteStringMemoryCache> GetDatabaseAndSubscriptionPrefix(ClusterOperationContext context, string database, long subscriptionId, ByteString& prefix);
    public static InternalScope<ByteStringMemoryCache> GetSubscriptionStateKey(ClusterOperationContext context, string database, long subscriptionId, string pk, SubscriptionType type, ByteString& key);
    private static void PopulatePrefix(long subscriptionId, SubscriptionType type, ByteString& prefix, Slice& dbName, Int32& position);
    public abstract virtual void Dispose();
}
public abstract class Raven.Server.Documents.Subscriptions.AbstractSubscriptionConnectionsState`2 : AbstractSubscriptionConnectionsState {
    protected ServerStore _server;
    protected string _databaseName;
    private long _subscriptionId;
    protected SubscriptionState _subscriptionState;
    protected ConcurrentSet`1<TSubscriptionConnection> _connections;
    private int _maxConcurrentConnections;
    private SemaphoreSlim _subscriptionActivelyWorkingLock;
    private MultipleUseFlag _addingSingleConnection;
    public long SubscriptionId { get; }
    public SubscriptionState SubscriptionState { get; }
    public bool IsConcurrent { get; }
    protected AbstractSubscriptionConnectionsState`2(ServerStore server, string databaseName, long subscriptionId, CancellationToken token);
    public long get_SubscriptionId();
    public SubscriptionState get_SubscriptionState();
    public bool get_IsConcurrent();
    public abstract virtual Task UpdateClientConnectionTime();
    protected abstract virtual void SetLastChangeVectorSent(TSubscriptionConnection connection);
    public abstract virtual Task WaitForIndexNotificationAsync(long index);
    public abstract virtual void ReleaseConcurrentConnectionLock(TSubscriptionConnection connection);
    public abstract virtual Task TakeConcurrentConnectionLockAsync(TSubscriptionConnection connection);
    public abstract virtual void DropSubscription(SubscriptionException e);
    public virtual Task InitializeAsync(TSubscriptionConnection connection, bool afterSubscribe);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.AbstractSubscriptionConnectionsState`2/<SubscribeAsync>d__21")]
public virtual Task`1<ValueTuple`2<IDisposable, long>> SubscribeAsync(TSubscriptionConnection connection, Stopwatch registerConnectionDuration);
    public void TryRemovePendingConnectionInfo(SubscriptionConnectionInfo info);
    public SubscriptionConnectionInfo SubscriptionPendingConnectionInfo(TSubscriptionConnection connection);
    public SubscriptionConnectionsDetails GetSubscriptionConnectionsDetails();
    public IEnumerable`1<DocumentRecord> GetDocumentsFromResend(ClusterOperationContext context, HashSet`1<long> activeBatches);
    public long GetNumberOfResendDocuments(SubscriptionType type);
    protected virtual UpdateSubscriptionClientConnectionTime GetUpdateSubscriptionClientConnectionTime();
    public virtual bool IsSubscriptionActive();
    public Task`1<bool> WaitForSubscriptionActiveLock(int millisecondsTimeout);
    public void ReleaseSubscriptionActiveLock();
    public DisposeOnce`1<SingleAttempt> RegisterSubscriptionConnection(TSubscriptionConnection incomingConnection);
    private bool TryRegisterFirstConnection(TSubscriptionConnection incomingConnection);
    protected virtual void ValidateTakeOver(TSubscriptionConnection currentConnection);
    private void RegisterSingleConnection(TSubscriptionConnection incomingConnection);
    private void RegisterOneConnection(TSubscriptionConnection incomingConnection);
    private bool TryAddConnection(TSubscriptionConnection connection);
    public void RegisterRejectedConnection(TSubscriptionConnection connection, SubscriptionException exception);
    private void CancelSingleConnection(TSubscriptionConnection connection, SubscriptionException ex);
    public void DropSingleConnection(TSubscriptionConnection connection, SubscriptionException ex);
    public SubscriptionConnectionInfo MostRecentEndedConnection();
    public List`1<TSubscriptionConnection> GetConnections();
    public string GetConnectionsAsString();
    public virtual string ToString();
    public void EndConnections();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.AbstractSubscriptionConnectionsState`2/<HandleConnectionExceptionAsync>d__46")]
public virtual Task HandleConnectionExceptionAsync(TSubscriptionConnection connection, Exception e);
    public virtual void Dispose();
}
public abstract class Raven.Server.Documents.Subscriptions.AbstractSubscriptionStorage : object {
    protected ServerStore _serverStore;
    protected string _databaseName;
    protected SemaphoreSlim _concurrentConnectionsSemiSemaphore;
    protected Logger _logger;
    private TimeSpan _waitForClusterStabilizationTimeout;
    public bool DisableSubscriptionTasks { get; }
    protected AbstractSubscriptionStorage(ServerStore serverStore, int maxNumberOfConcurrentConnections);
    protected abstract virtual string GetNodeFromState(SubscriptionState taskStatus);
    protected abstract virtual DatabaseTopology GetTopology(ClusterOperationContext context);
    public abstract virtual bool DropSingleSubscriptionConnection(long subscriptionId, string workerId, SubscriptionException ex);
    public abstract virtual SubscriptionState GetSubscriptionWithDataByIdFromServerStore(ClusterOperationContext context, long id, bool history, bool running);
    public abstract virtual SubscriptionState GetSubscriptionWithDataByNameFromServerStore(ClusterOperationContext context, string name, bool history, bool running);
    public abstract virtual IEnumerable`1<SubscriptionState> GetAllSubscriptions(ClusterOperationContext context, bool history, int start, int take);
    public abstract virtual bool get_DisableSubscriptionTasks();
    public bool ShouldWaitForClusterStabilization();
    public string GetSubscriptionResponsibleNode(ClusterOperationContext context, SubscriptionState taskStatus);
    internal string GetSubscriptionResponsibleNode(ClusterOperationContext context, RachisState currentState, SubscriptionState taskStatus);
    public static string GetSubscriptionResponsibleNodeForProgress(RawDatabaseRecord record, string shardName, SubscriptionState taskStatus, bool hasHighlyAvailableTasks);
    public static string GetSubscriptionResponsibleNodeForConnection(RawDatabaseRecord record, SubscriptionState taskStatus, bool hasHighlyAvailableTasks);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.AbstractSubscriptionStorage/<GetAllSubscriptionsFromServerStore>d__19")]
public IEnumerable`1<SubscriptionState> GetAllSubscriptionsFromServerStore(ClusterOperationContext context, int start, int take);
    public SubscriptionState GetSubscriptionById(ClusterOperationContext context, long subscriptionId);
    public abstract virtual ArchivedDataProcessingBehavior GetDefaultArchivedDataProcessingBehavior();
    public SubscriptionState GetSubscriptionByName(ClusterOperationContext context, string taskName);
    public long GetAllSubscriptionsCount();
    public string GetSubscriptionNameById(ClusterOperationContext serverStoreContext, long id);
    public bool TryEnterSubscriptionsSemaphore();
    public void ReleaseSubscriptionsSemaphore();
}
public abstract class Raven.Server.Documents.Subscriptions.AbstractSubscriptionStorage`1 : AbstractSubscriptionStorage {
    protected ConcurrentDictionary`2<long, TState> _subscriptions;
    public ConcurrentDictionary`2<long, TState> Subscriptions { get; }
    protected AbstractSubscriptionStorage`1(ServerStore serverStore, int maxNumberOfConcurrentConnections);
    public ConcurrentDictionary`2<long, TState> get_Subscriptions();
    protected abstract virtual void DropSubscriptionConnections(TState state, SubscriptionException ex);
    protected abstract virtual void SetConnectionException(TState state, SubscriptionException ex);
    protected abstract virtual bool SubscriptionChangeVectorHasChanges(TState state, SubscriptionState taskStatus);
    public bool DropSubscriptionConnections(long subscriptionId, SubscriptionException ex);
    private bool DeleteAndSetException(long subscriptionId, SubscriptionException ex);
    public SubscriptionState GetActiveSubscription(ClusterOperationContext context, Nullable`1<long> id, string name);
    public int GetAllRunningSubscriptionsCount();
    public virtual void HandleDatabaseRecordChange();
    public TState GetSubscriptionConnectionsState(ClusterOperationContext context, string subscriptionName);
    public ValueTuple`2<OngoingTaskConnectionStatus, string> GetSubscriptionConnectionStatusAndResponsibleNode(ClusterOperationContext context, long subscriptionId, SubscriptionState state);
    public bool TryGetRunningSubscriptionConnectionsState(long subscriptionId, TState& connections);
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    protected static void SetSubscriptionHistory(AbstractSubscriptionConnectionsState subscriptionConnectionsState, SubscriptionDataBase<TState> subscriptionData);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.AbstractSubscriptionStorage`1/<GetAllRunningSubscriptionsInternal>d__17")]
public IEnumerable`1<ValueTuple`2<SubscriptionState, TState>> GetAllRunningSubscriptionsInternal(ClusterOperationContext context, bool history, int start, int take);
    protected SubscriptionState GetSubscriptionConnectionsStateAndCheckRunningIfNeeded(SubscriptionState state, bool running, TState& connectionsState);
    public sealed virtual void LowMemoryOver();
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Subscriptions.DocumentSubscriptionFetcher : SubscriptionFetcher`1<Document> {
    public DocumentSubscriptionFetcher(DocumentDatabase database, SubscriptionConnectionsState subscriptionConnectionsState, string collection);
    protected virtual IEnumerator`1<Document> FetchByEtag();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.DocumentSubscriptionFetcher/<FetchFromResend>d__2")]
protected virtual IEnumerator`1<Document> FetchFromResend();
}
public class Raven.Server.Documents.Subscriptions.DummySubscriptionConnectionsState : SubscriptionConnectionsState {
    public DummySubscriptionConnectionsState(string name, DocumentsStorage storage, SubscriptionState state);
    public virtual Task InitializeAsync(SubscriptionConnection connection, bool afterSubscribe);
}
public interface Raven.Server.Documents.Subscriptions.ISubscriptionBinder {
    public abstract virtual Task Run(TcpConnectionOptions tcpConnectionOptions, IDisposable subscriptionConnectionInProgress);
}
public interface Raven.Server.Documents.Subscriptions.ISubscriptionConnection {
    public static long NonExistentBatch;
    public static StringSegment TypeSegment;
    public static TimeSpan HeartbeatTimeout;
    public static int WaitForChangedDocumentsTimeoutInMs;
    public string LastSentChangeVectorInThisConnection { get; public set; }
    public SubscriptionWorkerOptions Options { get; }
    public TcpConnectionOptions TcpConnection { get; }
    public SubscriptionState SubscriptionState { get; public set; }
    public ParsedSubscription Subscription { get; }
    public CancellationTokenSource CancellationTokenSource { get; }
    public Task SubscriptionConnectionTask { get; public set; }
    public long SubscriptionId { get; }
    public SupportedFeatures SupportedFeatures { get; }
    public long LastModifiedIndex { get; }
    private static ISubscriptionConnection();
    public abstract virtual string get_LastSentChangeVectorInThisConnection();
    public abstract virtual void set_LastSentChangeVectorInThisConnection(string value);
    public abstract virtual SubscriptionWorkerOptions get_Options();
    public abstract virtual TcpConnectionOptions get_TcpConnection();
    public abstract virtual SubscriptionState get_SubscriptionState();
    public abstract virtual void set_SubscriptionState(SubscriptionState value);
    public abstract virtual ParsedSubscription get_Subscription();
    public abstract virtual CancellationTokenSource get_CancellationTokenSource();
    public abstract virtual Task get_SubscriptionConnectionTask();
    public abstract virtual void set_SubscriptionConnectionTask(Task value);
    public abstract virtual long get_SubscriptionId();
    public abstract virtual SupportedFeatures get_SupportedFeatures();
    internal abstract virtual Task SendHeartBeatAsync(string reason);
    public abstract virtual long get_LastModifiedIndex();
}
public class Raven.Server.Documents.Subscriptions.LiveSubscriptionPerformanceCollector : DatabaseAwareLivePerformanceCollector`1<SubscriptionTaskPerformanceStats> {
    private ConcurrentDictionary`2<string, SubscriptionAndPerformanceConnectionStatsList> _perSubscriptionConnectionStats;
    private ConcurrentDictionary`2<string, SubscriptionAndPerformanceBatchStatsList> _perSubscriptionBatchStats;
    public LiveSubscriptionPerformanceCollector(DocumentDatabase database);
    private IEnumerable`1<SubscriptionTaskPerformanceStats> PrepareInitialPerformanceStats();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.LiveSubscriptionPerformanceCollector/<StartCollectingStats>d__4")]
protected virtual Task StartCollectingStats();
    protected virtual List`1<SubscriptionTaskPerformanceStats> PreparePerformanceStats();
    private void OnEndConnection(SubscriptionConnection connection);
    private void OnAddSubscriptionTask(string subscriptionName);
    private void OnRemoveSubscriptionTask(string subscriptionName);
    private void OnEndBatch(string subscriptionName, SubscriptionBatchStatsAggregator batchAggregator);
    protected virtual void WriteStats(List`1<SubscriptionTaskPerformanceStats> stats, AsyncBlittableJsonTextWriter writer, JsonOperationContext context);
}
public abstract class Raven.Server.Documents.Subscriptions.Processor.AbstractSubscriptionProcessor`2 : object {
    protected ServerStore Server;
    protected ISubscriptionConnection Connection;
    protected EndPoint RemoteEndpoint;
    protected SubscriptionState SubscriptionState;
    protected SubscriptionWorkerOptions Options;
    protected string Collection;
    protected Logger Logger;
    protected ClusterOperationContext ClusterContext;
    protected TIncludesCommand IncludesCmd;
    protected int BatchSize { get; }
    protected AbstractSubscriptionProcessor`2(ServerStore server, ISubscriptionConnection connection, string databaseName);
    protected int get_BatchSize();
    public virtual void InitializeProcessor();
    protected virtual bool CanContinueBatch(SubscriptionBatchItemStatus batchItemStatus, SubscriptionBatchStatsScope batchScope, int numberOfDocs, Stopwatch sendingCurrentBatchStopwatch);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.Processor.AbstractSubscriptionProcessor`2/<SendHeartbeatIfNeededAsync>d__12")]
protected virtual ValueTask SendHeartbeatIfNeededAsync(Stopwatch sendingCurrentBatchStopwatch);
    protected virtual SubscriptionBatchStatus SetBatchStatus(SubscriptionBatchResult result);
    public abstract virtual Task`1<SubscriptionBatchResult> GetBatchAsync(SubscriptionBatchStatsScope batchScope, Stopwatch sendingCurrentBatchStopwatch);
    protected abstract virtual string SetLastChangeVectorInThisBatch(IChangeVectorOperationContext context, string currentLast, SubscriptionBatchItem batchItem);
    public abstract virtual Task`1<long> TryRecordBatchAsync(string lastChangeVectorSentInThisBatch);
    public abstract virtual Task AcknowledgeBatchAsync(long batchId, string changeVector);
    public virtual IDisposable InitializeForNewBatch(ClusterOperationContext clusterContext, TIncludesCommand& includesCommands);
    protected abstract virtual TIncludesCommand CreateIncludeCommands();
    protected abstract virtual ConflictStatus GetConflictStatus(string changeVector);
    protected abstract virtual void HandleBatchItem(SubscriptionBatchStatsScope batchScope, SubscriptionBatchItem batchItem, SubscriptionBatchResult result, TItem item);
    protected abstract virtual SubscriptionBatchItem GetBatchItem(TItem item);
    public virtual void Dispose();
}
public abstract class Raven.Server.Documents.Subscriptions.Processor.DatabaseSubscriptionProcessor`1 : DatabaseSubscriptionProcessorBase`1<T> {
    protected SubscriptionFetcher`1<T> Fetcher;
    protected DatabaseSubscriptionProcessor`1(ServerStore server, DocumentDatabase database, SubscriptionConnection connection);
    public virtual IDisposable InitializeForNewBatch(ClusterOperationContext clusterContext, DatabaseIncludesCommandImpl& includesCommands);
    protected virtual ConflictStatus GetConflictStatus(string changeVector);
    protected virtual bool CanContinueBatch(SubscriptionBatchItemStatus batchItemStatus, SubscriptionBatchStatsScope batchScope, int numberOfDocs, Stopwatch sendingCurrentBatchStopwatch);
    protected virtual string SetLastChangeVectorInThisBatch(IChangeVectorOperationContext context, string currentLast, SubscriptionBatchItem batchItem);
    protected virtual SubscriptionBatchItem GetBatchItem(T item);
    protected abstract virtual SubscriptionFetcher`1<T> CreateFetcher();
    protected abstract virtual SubscriptionBatchItem ShouldSend(T item, String& reason);
}
public abstract class Raven.Server.Documents.Subscriptions.Processor.DatabaseSubscriptionProcessorBase`1 : AbstractSubscriptionProcessor`2<DatabaseIncludesCommandImpl, TItem> {
    protected long MaximumAllowedMemory;
    protected DocumentDatabase Database;
    protected DocumentsOperationContext DocsContext;
    protected SubscriptionConnectionsState SubscriptionConnectionsState;
    protected HashSet`1<long> Active;
    [CompilerGeneratedAttribute]
private SubscriptionPatchDocument <Patch>k__BackingField;
    protected SingleRun Run;
    private Nullable`1<ReturnRun> _returnRun;
    public SubscriptionPatchDocument Patch { get; public set; }
    protected DatabaseSubscriptionProcessorBase`1(ServerStore server, DocumentDatabase database, SubscriptionConnection connection);
    [CompilerGeneratedAttribute]
public sealed virtual SubscriptionPatchDocument get_Patch();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Patch(SubscriptionPatchDocument value);
    public virtual void InitializeProcessor();
    public virtual IDisposable InitializeForNewBatch(ClusterOperationContext clusterContext, DatabaseIncludesCommandImpl& includesCommands);
    protected virtual DatabaseIncludesCommandImpl CreateIncludeCommands();
    internal static DatabaseIncludesCommandImpl CreateIncludeCommandsInternal(DocumentDatabase database, DocumentsOperationContext context, ISubscriptionConnection connection, ParsedSubscription subscription);
    public static bool TryCreateIncludesCommand(DocumentDatabase database, DocumentsOperationContext context, ISubscriptionConnection connection, ParsedSubscription subscription, IncludeCountersCommand& includeCounters, IncludeDocumentsCommand& includeDocuments, IncludeTimeSeriesCommand& includeTimeSeries);
    protected void InitializeScript();
    public abstract virtual long GetLastItemEtag(DocumentsOperationContext context, string collection);
    public virtual void Dispose();
}
public class Raven.Server.Documents.Subscriptions.Processor.DocumentsDatabaseSubscriptionProcessor : DatabaseSubscriptionProcessor`1<Document> {
    private CancellationToken _token;
    public List`1<string> ItemsToRemoveFromResend;
    public List`1<DocumentRecord> BatchItems;
    public DocumentsDatabaseSubscriptionProcessor(ServerStore server, DocumentDatabase database, SubscriptionConnection connection);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.Processor.DocumentsDatabaseSubscriptionProcessor/<GetBatchAsync>d__4")]
public virtual Task`1<SubscriptionBatchResult> GetBatchAsync(SubscriptionBatchStatsScope batchScope, Stopwatch sendingCurrentBatchStopwatch);
    protected virtual void HandleBatchItem(SubscriptionBatchStatsScope batchScope, SubscriptionBatchItem batchItem, SubscriptionBatchResult result, Document item);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.Processor.DocumentsDatabaseSubscriptionProcessor/<TryRecordBatchAsync>d__6")]
public virtual Task`1<long> TryRecordBatchAsync(string lastChangeVectorSentInThisBatch);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.Processor.DocumentsDatabaseSubscriptionProcessor/<AcknowledgeBatchAsync>d__7")]
public virtual Task AcknowledgeBatchAsync(long batchId, string changeVector);
    public virtual long GetLastItemEtag(DocumentsOperationContext context, string collection);
    protected virtual SubscriptionFetcher`1<Document> CreateFetcher();
    protected virtual SubscriptionBatchItem ShouldSend(Document item, String& reason);
    protected virtual bool ShouldFetchFromResend(DocumentsOperationContext context, string id, Document item, string currentChangeVector, String& reason);
    protected virtual bool CheckIfNewerInResendList(DocumentsOperationContext context, string id, string cvInStorage, string cvInResendList);
    private bool ShouldAddToResendTable(DocumentsOperationContext context, DocumentOrTombstone item, string currentChangeVector);
}
public interface Raven.Server.Documents.Subscriptions.Processor.IDatabaseSubscriptionProcessor {
    public SubscriptionPatchDocument Patch { get; public set; }
    public abstract virtual SubscriptionPatchDocument get_Patch();
    public abstract virtual void set_Patch(SubscriptionPatchDocument value);
    public abstract virtual long GetLastItemEtag(DocumentsOperationContext context, string collection);
}
public interface Raven.Server.Documents.Subscriptions.Processor.IEtagSettable {
    public abstract virtual void SetStartEtag(long etag);
}
public interface Raven.Server.Documents.Subscriptions.Processor.ISubscriptionProcessor`1 {
    public abstract virtual IDisposable InitializeForNewBatch(ClusterOperationContext clusterContext, TIncludesCommand& includesCommands);
    public abstract virtual Task`1<SubscriptionBatchResult> GetBatchAsync(SubscriptionBatchStatsScope batchScope, Stopwatch sendingCurrentBatchStopwatch);
    public abstract virtual Task`1<long> TryRecordBatchAsync(string lastChangeVectorSentInThisBatch);
    public abstract virtual Task AcknowledgeBatchAsync(long currentBatchId, string clientReplyChangeVector);
}
public class Raven.Server.Documents.Subscriptions.Processor.OrchestratedSubscriptionProcessor : AbstractSubscriptionProcessor`2<OrchestratorIncludesCommandImpl, Item<BlittableJsonReaderObject>> {
    private ShardedDatabaseContext _databaseContext;
    private SubscriptionConnectionsStateOrchestrator _state;
    private CancellationToken _token;
    public ShardedSubscriptionBatch CurrentBatch;
    private OrchestratorIncludesCommandImpl _includes;
    public OrchestratedSubscriptionProcessor(ServerStore server, ShardedDatabaseContext databaseContext, OrchestratedSubscriptionConnection connection);
    public virtual void InitializeProcessor();
    public virtual Task`1<long> TryRecordBatchAsync(string lastChangeVectorSentInThisBatch);
    public virtual Task AcknowledgeBatchAsync(long batchId, string changeVector);
    protected virtual string SetLastChangeVectorInThisBatch(IChangeVectorOperationContext context, string currentLast, SubscriptionBatchItem batchItem);
    protected virtual OrchestratorIncludesCommandImpl CreateIncludeCommands();
    protected virtual ConflictStatus GetConflictStatus(string changeVector);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.Processor.OrchestratedSubscriptionProcessor/<GetBatchAsync>d__12")]
public virtual Task`1<SubscriptionBatchResult> GetBatchAsync(SubscriptionBatchStatsScope batchScope, Stopwatch sendingCurrentBatchStopwatch);
    protected virtual void HandleBatchItem(SubscriptionBatchStatsScope batchScope, SubscriptionBatchItem batchItem, SubscriptionBatchResult result, Item<BlittableJsonReaderObject> item);
    protected virtual SubscriptionBatchItem GetBatchItem(Item<BlittableJsonReaderObject> item);
}
[TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Raven.Server.Documents.Subscriptions.Processor.RevisionsDatabaseSubscriptionProcessor : DatabaseSubscriptionProcessor`1<ValueTuple`2<Document, Document>> {
    private CancellationToken _token;
    public List`1<RevisionRecord> BatchItems;
    public RevisionsDatabaseSubscriptionProcessor(ServerStore server, DocumentDatabase database, SubscriptionConnection connection);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.Processor.RevisionsDatabaseSubscriptionProcessor/<GetBatchAsync>d__3")]
public virtual Task`1<SubscriptionBatchResult> GetBatchAsync(SubscriptionBatchStatsScope batchScope, Stopwatch sendingCurrentBatchStopwatch);
    protected virtual void HandleBatchItem(SubscriptionBatchStatsScope batchScope, SubscriptionBatchItem batchItem, SubscriptionBatchResult result, ValueTuple`2<Document, Document> item);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.Processor.RevisionsDatabaseSubscriptionProcessor/<TryRecordBatchAsync>d__5")]
public virtual Task`1<long> TryRecordBatchAsync(string lastChangeVectorSentInThisBatch);
    public virtual Task AcknowledgeBatchAsync(long batchId, string changeVector);
    public virtual long GetLastItemEtag(DocumentsOperationContext context, string collection);
    protected virtual SubscriptionFetcher`1<ValueTuple`2<Document, Document>> CreateFetcher();
    protected virtual SubscriptionBatchItem ShouldSend(ValueTuple`2<Document, Document> item, String& reason);
}
public class Raven.Server.Documents.Subscriptions.Processor.SubscriptionBatchItem : object {
    public Document Document;
    public Exception Exception;
    public SubscriptionBatchItemStatus Status;
    public FetchingOrigin FetchingFrom;
}
public enum Raven.Server.Documents.Subscriptions.Processor.SubscriptionBatchItemStatus : Enum {
    public int value__;
    public static SubscriptionBatchItemStatus Send;
    public static SubscriptionBatchItemStatus Skip;
    public static SubscriptionBatchItemStatus ActiveMigration;
    public static SubscriptionBatchItemStatus Exception;
}
public class Raven.Server.Documents.Subscriptions.Processor.SubscriptionBatchResult : object {
    public string LastChangeVectorSentInThisBatch;
    public List`1<SubscriptionBatchItem> CurrentBatch;
    public SubscriptionBatchStatus Status;
}
public enum Raven.Server.Documents.Subscriptions.Processor.SubscriptionBatchStatus : Enum {
    public int value__;
    public static SubscriptionBatchStatus EmptyBatch;
    public static SubscriptionBatchStatus DocumentsSent;
    public static SubscriptionBatchStatus ActiveMigration;
}
public class Raven.Server.Documents.Subscriptions.Processor.TestDocumentsDatabaseSubscriptionProcessor : DocumentsDatabaseSubscriptionProcessor {
    private ParsedSubscription _subscription;
    private TimeSpan _timeLimit;
    private int _pageSize;
    public TestDocumentsDatabaseSubscriptionProcessor(ServerStore server, DocumentDatabase database, SubscriptionState state, ParsedSubscription subscription, SubscriptionWorkerOptions options, EndPoint endpoint, TimeSpan timeLimit, int pageSize);
    protected virtual void HandleBatchItem(SubscriptionBatchStatsScope batchScope, SubscriptionBatchItem batchItem, SubscriptionBatchResult result, Document item);
    protected virtual bool CanContinueBatch(SubscriptionBatchItemStatus batchItemStatus, SubscriptionBatchStatsScope batchScope, int numberOfDocs, Stopwatch sendingCurrentBatchStopwatch);
    protected virtual DatabaseIncludesCommandImpl CreateIncludeCommands();
    public virtual void InitializeProcessor();
    public sealed virtual void SetStartEtag(long etag);
    public virtual Task`1<long> TryRecordBatchAsync(string lastChangeVectorSentInThisBatch);
    public virtual Task AcknowledgeBatchAsync(long batchId, string changeVector);
    protected virtual ValueTask SendHeartbeatIfNeededAsync(Stopwatch sendingCurrentBatchStopwatch);
}
public class Raven.Server.Documents.Subscriptions.Processor.TestRevisionsDatabaseSubscriptionProcessor : RevisionsDatabaseSubscriptionProcessor {
    private ParsedSubscription _subscription;
    private TimeSpan _timeLimit;
    private int _pageSize;
    public TestRevisionsDatabaseSubscriptionProcessor(ServerStore server, DocumentDatabase database, SubscriptionState state, ParsedSubscription subscription, SubscriptionWorkerOptions options, EndPoint endpoint, TimeSpan timeLimit, int pageSize);
    protected virtual void HandleBatchItem(SubscriptionBatchStatsScope batchScope, SubscriptionBatchItem batchItem, SubscriptionBatchResult result, ValueTuple`2<Document, Document> item);
    protected virtual bool CanContinueBatch(SubscriptionBatchItemStatus batchItemStatus, SubscriptionBatchStatsScope batchScope, int numberOfDocs, Stopwatch sendingCurrentBatchStopwatch);
    public virtual void InitializeProcessor();
    protected virtual DatabaseIncludesCommandImpl CreateIncludeCommands();
    public sealed virtual void SetStartEtag(long etag);
    public virtual Task`1<long> TryRecordBatchAsync(string lastChangeVectorSentInThisBatch);
    public virtual Task AcknowledgeBatchAsync(long batchId, string changeVector);
    protected virtual ValueTask SendHeartbeatIfNeededAsync(Stopwatch sendingCurrentBatchStopwatch);
}
public class Raven.Server.Documents.Subscriptions.ResendItem : object {
    public string Id;
    public long Batch;
    public string ChangeVector;
    public SubscriptionType Type;
    public sealed virtual DynamicJsonValue ToJson();
}
[TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Raven.Server.Documents.Subscriptions.RevisionSubscriptionFetcher : SubscriptionFetcher`1<ValueTuple`2<Document, Document>> {
    public RevisionSubscriptionFetcher(DocumentDatabase database, SubscriptionConnectionsState subscriptionConnectionsState, string collection);
    protected virtual IEnumerator`1<ValueTuple`2<Document, Document>> FetchByEtag();
    protected virtual IEnumerator`1<ValueTuple`2<Document, Document>> FetchFromResend();
}
public class Raven.Server.Documents.Subscriptions.Sharding.ShardDocumentSubscriptionFetcher : DocumentSubscriptionFetcher {
    public ShardDocumentSubscriptionFetcher(DocumentDatabase database, SubscriptionConnectionsState subscriptionConnectionsState, string collection);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.Sharding.ShardDocumentSubscriptionFetcher/<FetchFromResend>d__1")]
protected virtual IEnumerator`1<Document> FetchFromResend();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerator`1<Document> <>n__0();
}
public class Raven.Server.Documents.Subscriptions.Sharding.ShardSubscriptionStorage : SubscriptionStorage {
    private string _shardName;
    private int _shardNumber;
    public ShardSubscriptionStorage(ShardedDocumentDatabase db, ServerStore serverStore, string name);
    public virtual void HandleDatabaseRecordChange();
    protected virtual DatabaseTopology GetTopology(ClusterOperationContext context);
    protected virtual string GetNodeFromState(SubscriptionState taskStatus);
    protected virtual bool SubscriptionChangeVectorHasChanges(SubscriptionConnectionsState state, SubscriptionState taskStatus);
    internal virtual void CleanupSubscriptions();
}
public class Raven.Server.Documents.Subscriptions.Sharding.SubscriptionConnectionsStateForShard : SubscriptionConnectionsState {
    public ShardedDocumentDatabase ShardedDocumentDatabase;
    public SubscriptionConnectionsStateForShard(string databaseName, long subscriptionId, SubscriptionStorage storage);
    protected virtual void SetLastChangeVectorSent(SubscriptionConnection connection);
    public virtual Task UpdateClientConnectionTime();
    protected virtual AcknowledgeSubscriptionBatchCommand GetAcknowledgeSubscriptionBatchCommand(string changeVector, long batchId, List`1<DocumentRecord> docsToResend);
    protected virtual void ValidateTakeOver(SubscriptionConnection currentConnection);
    protected virtual Task`1<ValueTuple`2<long, object>> RecordBatchInternal(RecordBatchSubscriptionDocumentsCommand command);
    public bool HasDocumentFromResend();
}
public class Raven.Server.Documents.Subscriptions.Stats.SubscriptionBatchPerformanceOperation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionBatchPerformanceOperation[] <Operations>k__BackingField;
    public string Name { get; public set; }
    public double DurationInMs { get; }
    public SubscriptionBatchPerformanceOperation[] Operations { get; public set; }
    public SubscriptionBatchPerformanceOperation(TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public SubscriptionBatchPerformanceOperation[] get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(SubscriptionBatchPerformanceOperation[] value);
}
public class Raven.Server.Documents.Subscriptions.Stats.SubscriptionBatchPerformanceStats : object {
    [CompilerGeneratedAttribute]
private long <BatchId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeOfDocumentsInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfIncludedDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeOfIncludedDocumentsInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfIncludedCounters>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeOfIncludedCountersInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfIncludedTimeSeriesEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeOfIncludedTimeSeriesInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionBatchPerformanceOperation <Details>k__BackingField;
    public long BatchId { get; public set; }
    public long ConnectionId { get; public set; }
    public long NumberOfDocuments { get; public set; }
    public long SizeOfDocumentsInBytes { get; public set; }
    public long NumberOfIncludedDocuments { get; public set; }
    public long SizeOfIncludedDocumentsInBytes { get; public set; }
    public long NumberOfIncludedCounters { get; public set; }
    public long SizeOfIncludedCountersInBytes { get; public set; }
    public long NumberOfIncludedTimeSeriesEntries { get; public set; }
    public long SizeOfIncludedTimeSeriesInBytes { get; public set; }
    public DateTime Started { get; public set; }
    public Nullable`1<DateTime> Completed { get; public set; }
    public string Exception { get; public set; }
    public double DurationInMs { get; }
    public SubscriptionBatchPerformanceOperation Details { get; public set; }
    public SubscriptionBatchPerformanceStats(TimeSpan duration);
    [CompilerGeneratedAttribute]
public long get_BatchId();
    [CompilerGeneratedAttribute]
public void set_BatchId(long value);
    [CompilerGeneratedAttribute]
public long get_ConnectionId();
    [CompilerGeneratedAttribute]
public void set_ConnectionId(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfDocuments();
    [CompilerGeneratedAttribute]
public void set_NumberOfDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_SizeOfDocumentsInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeOfDocumentsInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfIncludedDocuments();
    [CompilerGeneratedAttribute]
public void set_NumberOfIncludedDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_SizeOfIncludedDocumentsInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeOfIncludedDocumentsInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfIncludedCounters();
    [CompilerGeneratedAttribute]
public void set_NumberOfIncludedCounters(long value);
    [CompilerGeneratedAttribute]
public long get_SizeOfIncludedCountersInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeOfIncludedCountersInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfIncludedTimeSeriesEntries();
    [CompilerGeneratedAttribute]
public void set_NumberOfIncludedTimeSeriesEntries(long value);
    [CompilerGeneratedAttribute]
public long get_SizeOfIncludedTimeSeriesInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeOfIncludedTimeSeriesInBytes(long value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public SubscriptionBatchPerformanceOperation get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(SubscriptionBatchPerformanceOperation value);
}
public class Raven.Server.Documents.Subscriptions.Stats.SubscriptionBatchRunStats : object {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BatchId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeOfDocumentsInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfIncludedDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeOfIncludedDocumentsInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfIncludedCounters>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeOfIncludedCountersInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfIncludedTimeSeriesEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeOfIncludedTimeSeriesInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    public long TaskId { get; public set; }
    public string TaskName { get; public set; }
    public long ConnectionId { get; public set; }
    public long BatchId { get; public set; }
    public long NumberOfDocuments { get; public set; }
    public long SizeOfDocumentsInBytes { get; public set; }
    public long NumberOfIncludedDocuments { get; public set; }
    public long SizeOfIncludedDocumentsInBytes { get; public set; }
    public long NumberOfIncludedCounters { get; public set; }
    public long SizeOfIncludedCountersInBytes { get; public set; }
    public long NumberOfIncludedTimeSeriesEntries { get; public set; }
    public long SizeOfIncludedTimeSeriesInBytes { get; public set; }
    public string Exception { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
public void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public long get_ConnectionId();
    [CompilerGeneratedAttribute]
public void set_ConnectionId(long value);
    [CompilerGeneratedAttribute]
public long get_BatchId();
    [CompilerGeneratedAttribute]
public void set_BatchId(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfDocuments();
    [CompilerGeneratedAttribute]
public void set_NumberOfDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_SizeOfDocumentsInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeOfDocumentsInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfIncludedDocuments();
    [CompilerGeneratedAttribute]
public void set_NumberOfIncludedDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_SizeOfIncludedDocumentsInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeOfIncludedDocumentsInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfIncludedCounters();
    [CompilerGeneratedAttribute]
public void set_NumberOfIncludedCounters(long value);
    [CompilerGeneratedAttribute]
public long get_SizeOfIncludedCountersInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeOfIncludedCountersInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfIncludedTimeSeriesEntries();
    [CompilerGeneratedAttribute]
public void set_NumberOfIncludedTimeSeriesEntries(long value);
    [CompilerGeneratedAttribute]
public long get_SizeOfIncludedTimeSeriesInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeOfIncludedTimeSeriesInBytes(long value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
}
public class Raven.Server.Documents.Subscriptions.Stats.SubscriptionBatchStatsAggregator : StatsAggregator`2<SubscriptionBatchRunStats, SubscriptionBatchStatsScope> {
    private SubscriptionBatchPerformanceStats modreq(System.Runtime.CompilerServices.IsVolatile) _batchPerformanceStats;
    public SubscriptionBatchStatsAggregator(int id, SubscriptionBatchStatsAggregator lastStats);
    public virtual SubscriptionBatchStatsScope CreateScope();
    public SubscriptionBatchPerformanceStats ToBatchPerformanceStats();
    private SubscriptionBatchPerformanceStats CreateBatchPerformanceStats(bool completed);
    public SubscriptionBatchPerformanceStats ToBatchPerformanceLiveStatsWithDetails();
}
public class Raven.Server.Documents.Subscriptions.Stats.SubscriptionBatchStatsScope : StatsScope`2<SubscriptionBatchRunStats, SubscriptionBatchStatsScope> {
    private SubscriptionBatchRunStats _stats;
    public SubscriptionBatchStatsScope(SubscriptionBatchRunStats stats, bool start);
    protected virtual SubscriptionBatchStatsScope OpenNewScope(SubscriptionBatchRunStats stats, bool start);
    public void RecordBatchInfo(long taskId, string taskName, long connectionId, long batchId);
    public void RecordDocumentInfo(long documentSize);
    public void RecordIncludedDocumentsInfo(long includedDocumentsCount, long includedDocumentsSize);
    public void RecordIncludedCountersInfo(long includedCountersCount, long includedCountersSize);
    public void RecordIncludedTimeSeriesInfo(long includedTimeSeriesEntriesCount, long includedTimeSeriesSize);
    public void RecordException(string exceptionMsg);
    public SubscriptionBatchPerformanceOperation ToPerformanceOperation(string name);
    public long GetBatchSize();
}
public class Raven.Server.Documents.Subscriptions.Stats.SubscriptionConnectionPerformanceOperation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionConnectionPerformanceOperation[] <Operations>k__BackingField;
    public string Name { get; public set; }
    public double DurationInMs { get; }
    public SubscriptionConnectionPerformanceOperation[] Operations { get; public set; }
    public SubscriptionConnectionPerformanceOperation(TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public SubscriptionConnectionPerformanceOperation[] get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(SubscriptionConnectionPerformanceOperation[] value);
}
public class Raven.Server.Documents.Subscriptions.Stats.SubscriptionConnectionPerformanceStats : object {
    [CompilerGeneratedAttribute]
private long <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientUri>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionOpeningStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BatchCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalBatchSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SubscriptionError> <ErrorType>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DurationInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionConnectionPerformanceOperation <Details>k__BackingField;
    public long ConnectionId { get; public set; }
    public string WorkerId { get; public set; }
    public string ClientUri { get; public set; }
    public SubscriptionOpeningStrategy Strategy { get; public set; }
    public long BatchCount { get; public set; }
    public long TotalBatchSizeInBytes { get; public set; }
    public string Exception { get; public set; }
    public Nullable`1<SubscriptionError> ErrorType { get; public set; }
    public DateTime Started { get; public set; }
    public Nullable`1<DateTime> Completed { get; public set; }
    public double DurationInMs { get; }
    public SubscriptionConnectionPerformanceOperation Details { get; public set; }
    public SubscriptionConnectionPerformanceStats(TimeSpan duration);
    [CompilerGeneratedAttribute]
public long get_ConnectionId();
    [CompilerGeneratedAttribute]
public void set_ConnectionId(long value);
    [CompilerGeneratedAttribute]
public string get_WorkerId();
    [CompilerGeneratedAttribute]
public void set_WorkerId(string value);
    [CompilerGeneratedAttribute]
public string get_ClientUri();
    [CompilerGeneratedAttribute]
public void set_ClientUri(string value);
    [CompilerGeneratedAttribute]
public SubscriptionOpeningStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(SubscriptionOpeningStrategy value);
    [CompilerGeneratedAttribute]
public long get_BatchCount();
    [CompilerGeneratedAttribute]
public void set_BatchCount(long value);
    [CompilerGeneratedAttribute]
public long get_TotalBatchSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_TotalBatchSizeInBytes(long value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<SubscriptionError> get_ErrorType();
    [CompilerGeneratedAttribute]
public void set_ErrorType(Nullable`1<SubscriptionError> value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public double get_DurationInMs();
    [CompilerGeneratedAttribute]
public SubscriptionConnectionPerformanceOperation get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(SubscriptionConnectionPerformanceOperation value);
}
public class Raven.Server.Documents.Subscriptions.Stats.SubscriptionConnectionRunStats : object {
    [CompilerGeneratedAttribute]
private string <WorkerId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientUri>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionOpeningStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SubscriptionError> <ErrorType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BatchCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalBatchSizeInBytes>k__BackingField;
    public string WorkerId { get; public set; }
    public long TaskId { get; public set; }
    public string TaskName { get; public set; }
    public string ClientUri { get; public set; }
    public SubscriptionOpeningStrategy Strategy { get; public set; }
    public string Exception { get; public set; }
    public Nullable`1<SubscriptionError> ErrorType { get; public set; }
    public long BatchCount { get; public set; }
    public long TotalBatchSizeInBytes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_WorkerId();
    [CompilerGeneratedAttribute]
public void set_WorkerId(string value);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
public void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public string get_ClientUri();
    [CompilerGeneratedAttribute]
public void set_ClientUri(string value);
    [CompilerGeneratedAttribute]
public SubscriptionOpeningStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(SubscriptionOpeningStrategy value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<SubscriptionError> get_ErrorType();
    [CompilerGeneratedAttribute]
public void set_ErrorType(Nullable`1<SubscriptionError> value);
    [CompilerGeneratedAttribute]
public long get_BatchCount();
    [CompilerGeneratedAttribute]
public void set_BatchCount(long value);
    [CompilerGeneratedAttribute]
public long get_TotalBatchSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_TotalBatchSizeInBytes(long value);
}
public class Raven.Server.Documents.Subscriptions.Stats.SubscriptionConnectionStatsAggregator : StatsAggregator`2<SubscriptionConnectionRunStats, SubscriptionConnectionStatsScope> {
    private SubscriptionConnectionPerformanceStats modreq(System.Runtime.CompilerServices.IsVolatile) _connectionPerformanceStats;
    public SubscriptionConnectionStatsAggregator(int connectionId, SubscriptionConnectionStatsAggregator lastStats);
    public virtual SubscriptionConnectionStatsScope CreateScope();
    public SubscriptionConnectionPerformanceStats ToConnectionPerformanceStats();
    private SubscriptionConnectionPerformanceStats CreateConnectionPerformanceStats(bool completed);
    public SubscriptionConnectionPerformanceStats ToConnectionPerformanceLiveStatsWithDetails();
}
public class Raven.Server.Documents.Subscriptions.Stats.SubscriptionConnectionStatsScope : StatsScope`2<SubscriptionConnectionRunStats, SubscriptionConnectionStatsScope> {
    private SubscriptionConnectionRunStats _stats;
    public SubscriptionConnectionStatsScope(SubscriptionConnectionRunStats stats, bool start);
    protected virtual SubscriptionConnectionStatsScope OpenNewScope(SubscriptionConnectionRunStats stats, bool start);
    public void RecordConnectionInfo(SubscriptionState subscriptionState, string clientUri, SubscriptionOpeningStrategy strategy, string workerId);
    public void RecordException(SubscriptionError errorType, string exception);
    public void RecordBatchCompleted(long batchSize);
    public SubscriptionConnectionPerformanceOperation ToPerformanceOperation(string name);
}
public static class Raven.Server.Documents.Subscriptions.SubscriptionBinder : object {
    public static ISubscriptionBinder CreateSubscriptionBinder(ServerStore server, DatabaseSearchResult databaseResult, TcpConnectionOptions tcpConnectionOptions, MemoryBuffer buffer, IDisposable onDispose, ISubscriptionConnection& connection);
}
public class Raven.Server.Documents.Subscriptions.SubscriptionBinder`3 : object {
    private AbstractSubscriptionStorage`1<TState> _storage;
    private Lazy`1<TState> _state;
    private TConnection _connection;
    private TState _subscriptionConnectionsState { get; }
    public SubscriptionBinder`3(AbstractSubscriptionStorage`1<TState> storage, Lazy`1<TState> state, TConnection connection);
    private TState get__subscriptionConnectionsState();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionBinder`3/<Run>d__6")]
public sealed virtual Task Run(TcpConnectionOptions tcpConnectionOptions, IDisposable subscriptionConnectionInProgress);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionBinder`3/<AddPendingConnectionUnderLockAsync>d__7")]
private Task`1<IDisposable> AddPendingConnectionUnderLockAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionBinder`3/<NotifyClientAboutSuccessAsync>d__8")]
private Task NotifyClientAboutSuccessAsync(long registerConnectionDurationInTicks);
}
public abstract class Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1 : object {
    private static Byte[] Heartbeat;
    private static int MaxBufferCapacityInBytes;
    private static StringSegment DataSegment;
    private static StringSegment ExceptionSegment;
    protected AbstractSubscriptionStorage _subscriptions;
    protected ServerStore ServerStore;
    private IDisposable _tcpConnectionDisposable;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ValueTuple`2<IDisposable, MemoryBuffer> _copiedBuffer;
    internal SubscriptionWorkerOptions _options;
    internal Logger _logger;
    [CompilerGeneratedAttribute]
private string <LastSentChangeVectorInThisConnection>k__BackingField;
    public ConcurrentQueue`1<string> RecentSubscriptionStatuses;
    public SubscriptionException ConnectionException;
    [CompilerGeneratedAttribute]
private long <SubscriptionId>k__BackingField;
    public string DatabaseName;
    [CompilerGeneratedAttribute]
private TcpConnectionOptions <TcpConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationTokenSource <CancellationTokenSource>k__BackingField;
    public string ClientUri;
    [CompilerGeneratedAttribute]
private SubscriptionState <SubscriptionState>k__BackingField;
    [CompilerGeneratedAttribute]
private ParsedSubscription <Subscription>k__BackingField;
    [CompilerGeneratedAttribute]
private SupportedFeatures <SupportedFeatures>k__BackingField;
    public SubscriptionStatsCollector Stats;
    [CompilerGeneratedAttribute]
private Task <SubscriptionConnectionTask>k__BackingField;
    private MemoryStream _buffer;
    private DisposeOnce`1<SingleAttempt> _disposeOnce;
    protected ISubscriptionProcessor`1<TIncludesCommand> Processor;
    private TestingStuff<TIncludesCommand> _forTestingPurposes;
    internal Task`1<SubscriptionConnectionClientMessage> _lastReplyFromClientTask;
    public string LastSentChangeVectorInThisConnection { get; public set; }
    public SubscriptionWorkerOptions Options { get; }
    public long SubscriptionId { get; public set; }
    public TcpConnectionOptions TcpConnection { get; }
    public CancellationTokenSource CancellationTokenSource { get; }
    public SubscriptionOpeningStrategy Strategy { get; }
    public long LastModifiedIndex { get; }
    public string WorkerId { get; }
    public SubscriptionState SubscriptionState { get; public set; }
    public ParsedSubscription Subscription { get; private set; }
    public SupportedFeatures SupportedFeatures { get; }
    public Task SubscriptionConnectionTask { get; public set; }
    protected SubscriptionConnectionBase`1(AbstractSubscriptionStorage subscriptions, TcpConnectionOptions tcpConnection, ServerStore serverStore, MemoryBuffer memoryBuffer, IDisposable tcpConnectionDisposable, string database, CancellationToken token);
    private static SubscriptionConnectionBase`1();
    [CompilerGeneratedAttribute]
public sealed virtual string get_LastSentChangeVectorInThisConnection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastSentChangeVectorInThisConnection(string value);
    public sealed virtual SubscriptionWorkerOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual long get_SubscriptionId();
    [CompilerGeneratedAttribute]
public void set_SubscriptionId(long value);
    [CompilerGeneratedAttribute]
public sealed virtual TcpConnectionOptions get_TcpConnection();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationTokenSource get_CancellationTokenSource();
    public SubscriptionOpeningStrategy get_Strategy();
    public sealed virtual long get_LastModifiedIndex();
    public string get_WorkerId();
    [CompilerGeneratedAttribute]
public sealed virtual SubscriptionState get_SubscriptionState();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SubscriptionState(SubscriptionState value);
    [CompilerGeneratedAttribute]
public sealed virtual ParsedSubscription get_Subscription();
    [CompilerGeneratedAttribute]
private void set_Subscription(ParsedSubscription value);
    [CompilerGeneratedAttribute]
public sealed virtual SupportedFeatures get_SupportedFeatures();
    [CompilerGeneratedAttribute]
public sealed virtual Task get_SubscriptionConnectionTask();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SubscriptionConnectionTask(Task value);
    internal TestingStuff<TIncludesCommand> ForTestingPurposesOnly();
    private static string ExtractDatabaseNameForLogging(TcpConnectionOptions tcpConnection);
    public abstract virtual ISubscriptionProcessor`1<TIncludesCommand> CreateProcessor(SubscriptionConnectionBase`1<TIncludesCommand> connection);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<ProcessSubscriptionAsync>d__62`2")]
public Task ProcessSubscriptionAsync(TState state);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<HandleBatchStatusAsync>d__63`2")]
internal virtual Task HandleBatchStatusAsync(TState state, SubscriptionBatchStatus status, Stopwatch sendingCurrentBatchStopwatch, SubscriptionConnectionInUse<TIncludesCommand> markInUse, SubscriptionBatchStatsScope batchScope);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<CancelSubscriptionAndThrowAsync>d__64")]
internal Task CancelSubscriptionAndThrowAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<LogBatchStatusAndUpdateStatsAsync>d__65")]
protected Task LogBatchStatusAndUpdateStatsAsync(Stopwatch sendingCurrentBatchStopwatch, string logMessage);
    protected virtual void OnError(Exception e);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<TrySendingBatchToClientAsync>d__67`2")]
private Task`1<SubscriptionBatchStatus> TrySendingBatchToClientAsync(TState state, Stopwatch sendingCurrentBatchStopwatch, SubscriptionBatchStatsScope batchScope, SubscriptionBatchStatsAggregator batchStatsAggregator);
    private void WriteDocument(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, SubscriptionBatchItem result, TIncludesCommand includeCommand);
    protected abstract virtual void GatherIncludesForDocument(TIncludesCommand includeDocuments, Document document);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<ReportExceptionAsync>d__70")]
public Task ReportExceptionAsync(SubscriptionError error, Exception e);
    public abstract virtual SubscriptionConnectionInfo CreateConnectionInfo();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<WaitForChangedDocsAsync>d__72")]
protected virtual Task`1<bool> WaitForChangedDocsAsync(AbstractSubscriptionConnectionsState state);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<GetReplyFromClientAsync>d__73")]
internal Task`1<SubscriptionConnectionClientMessage> GetReplyFromClientAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<InitAsync>d__74")]
public Task InitAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<RefreshAsync>d__75")]
public Task RefreshAsync(Nullable`1<long> registerConnectionDurationInTicks);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<AssertSubscriptionConnectionDetails>d__76")]
public Task`1<SubscriptionState> AssertSubscriptionConnectionDetails(Nullable`1<long> registerConnectionDurationInTicks);
    protected virtual RawDatabaseRecord GetRecord(ClusterOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<AssertSubscriptionConnectionDetails>d__78")]
private Task`1<SubscriptionState> AssertSubscriptionConnectionDetails(long id, string name, Nullable`1<long> registerConnectionDurationInTicks, CancellationToken token);
    public void RecordConnectionInfo();
    protected virtual void AssertSupportedFeatures();
    protected virtual void AssertCloseWhenNoDocsLeft();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<LogExceptionAndReportToClientAsync>d__82")]
protected Task LogExceptionAndReportToClientAsync(Exception e);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<ReportExceptionToClientAsync>d__83")]
protected Task ReportExceptionToClientAsync(Exception ex, int recursionDepth);
    public string CreateStatusMessage(ConnectionStatus status, string info);
    public virtual void FinishProcessing();
    public void AddToStatusDescription(string message);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<ParseSubscriptionOptionsAsync>d__88")]
public virtual Task ParseSubscriptionOptionsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<WriteJsonAsync>d__89")]
private Task WriteJsonAsync(DynamicJsonValue value);
    public Task SendAcceptMessageAsync();
    protected virtual DynamicJsonValue AcceptMessage();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<SendHeartBeatIfNeededAsync>d__92")]
internal Task SendHeartBeatIfNeededAsync(Stopwatch sp, string reason);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<SendHeartBeatAsync>d__93")]
public sealed virtual Task SendHeartBeatAsync(string reason);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<WaitForClientAck>d__94")]
private Task WaitForClientAck();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<SendConfirmAsync>d__95")]
protected Task SendConfirmAsync(DateTime time);
    protected abstract virtual StatusMessageDetails<TIncludesCommand> GetStatusMessageDetails();
    protected abstract virtual Task OnClientAckAsync(string clientReplyChangeVector);
    public abstract virtual Task SendNoopAckAsync(bool force);
    protected abstract virtual bool FoundAboutMoreDocs();
    protected abstract virtual SubscriptionConnectionInUse<TIncludesCommand> MarkInUse();
    protected abstract virtual void AfterProcessorCreation();
    protected abstract virtual void RaiseNotificationForBatchEnd(string name, SubscriptionBatchStatsAggregator last);
    protected abstract virtual Task`1<SubscriptionBatchStatus> TryRecordBatchAndUpdateStatusAsync(IChangeVectorOperationContext context, SubscriptionBatchResult result);
    internal static void WriteEndOfBatch(AsyncBlittableJsonTextWriter writer);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<FlushDocsToClientAsync>d__105")]
internal static Task FlushDocsToClientAsync(long subscriptionId, AsyncBlittableJsonTextWriter writer, MemoryStream buffer, TcpConnectionOptions tcpConnection, SubscriptionConnectionMetrics metrics, Logger logger, int flushedDocs, bool endOfBatch, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionBase`1/<FlushBufferToNetworkAsync>d__106")]
internal static Task FlushBufferToNetworkAsync(MemoryStream buffer, TcpConnectionOptions tcpConnection, CancellationToken token);
    protected virtual void DisposeInternal();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static void <AssertSubscriptionConnectionDetails>g__FillNodesAvailabilityReportForState|78_0(SubscriptionState subscription, DatabaseTopology topology, Dictionary`2<string, string> databaseTopologyAvailabilityExplanation, List`1<string> stateGroup, string stateName);
}
public class Raven.Server.Documents.Subscriptions.SubscriptionConnectionInfo : object {
    [CompilerGeneratedAttribute]
private string <ClientUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LatestChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionOpeningStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Date>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionException <ConnectionException>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <RecentSubscriptionStatuses>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicJsonValue <TcpConnectionStats>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionConnectionStatsAggregator <LastConnectionStats>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SubscriptionBatchStatsAggregator> <LastBatchesStats>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ArchivedDataProcessingBehavior> <ArchivedDataProcessingBehavior>k__BackingField;
    public string ClientUri { get; public set; }
    public string Query { get; public set; }
    public string LatestChangeVector { get; public set; }
    public SubscriptionOpeningStrategy Strategy { get; public set; }
    public DateTime Date { get; public set; }
    public SubscriptionException ConnectionException { get; public set; }
    public List`1<string> RecentSubscriptionStatuses { get; public set; }
    public DynamicJsonValue TcpConnectionStats { get; public set; }
    public SubscriptionConnectionStatsAggregator LastConnectionStats { get; public set; }
    public List`1<SubscriptionBatchStatsAggregator> LastBatchesStats { get; public set; }
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientUri();
    [CompilerGeneratedAttribute]
public void set_ClientUri(string value);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public string get_LatestChangeVector();
    [CompilerGeneratedAttribute]
public void set_LatestChangeVector(string value);
    [CompilerGeneratedAttribute]
public SubscriptionOpeningStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(SubscriptionOpeningStrategy value);
    [CompilerGeneratedAttribute]
public DateTime get_Date();
    [CompilerGeneratedAttribute]
public void set_Date(DateTime value);
    [CompilerGeneratedAttribute]
public SubscriptionException get_ConnectionException();
    [CompilerGeneratedAttribute]
public void set_ConnectionException(SubscriptionException value);
    [CompilerGeneratedAttribute]
public List`1<string> get_RecentSubscriptionStatuses();
    [CompilerGeneratedAttribute]
public void set_RecentSubscriptionStatuses(List`1<string> value);
    [CompilerGeneratedAttribute]
public DynamicJsonValue get_TcpConnectionStats();
    [CompilerGeneratedAttribute]
public void set_TcpConnectionStats(DynamicJsonValue value);
    [CompilerGeneratedAttribute]
public SubscriptionConnectionStatsAggregator get_LastConnectionStats();
    [CompilerGeneratedAttribute]
public void set_LastConnectionStats(SubscriptionConnectionStatsAggregator value);
    [CompilerGeneratedAttribute]
public List`1<SubscriptionBatchStatsAggregator> get_LastBatchesStats();
    [CompilerGeneratedAttribute]
public void set_LastBatchesStats(List`1<SubscriptionBatchStatsAggregator> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ArchivedDataProcessingBehavior> get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(Nullable`1<ArchivedDataProcessingBehavior> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.Subscriptions.SubscriptionConnectionMetrics : object {
    public DateTime ConnectedAt;
    public DateTime LastMessageSentAt;
    public DateTime LastAckReceivedAt;
    internal MeterMetric DocsRate;
    public MeterMetric BytesRate;
    public MeterMetric AckRate;
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState : AbstractSubscriptionConnectionsState`2<SubscriptionConnection, DatabaseIncludesCommandImpl> {
    private SubscriptionStorage _subscriptionStorage;
    private IDisposable _disposableNotificationsRegistration;
    private SemaphoreSlim _subscriptionConnectingLock;
    private long _lastNoopAckTicks;
    private Task _lastNoopAckTask;
    public DocumentDatabase DocumentDatabase { get; }
    public Task GetSubscriptionInUseAwaiter { get; }
    public SubscriptionConnectionsState(string databaseName, long subscriptionId, SubscriptionStorage storage);
    public DocumentDatabase get_DocumentDatabase();
    public Task get_GetSubscriptionInUseAwaiter();
    public virtual void DropSubscription(SubscriptionException e);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState/<UpdateClientConnectionTime>d__9")]
public virtual Task UpdateClientConnectionTime();
    public virtual Task WaitForIndexNotificationAsync(long index);
    public virtual long GetLastEtagSent();
    public IDisposable RegisterForNotificationOnNewDocuments(SubscriptionConnection connection);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState/<InitializeAsync>d__13")]
public virtual Task InitializeAsync(SubscriptionConnection connection, bool afterSubscribe);
    public virtual void ReleaseConcurrentConnectionLock(SubscriptionConnection connection);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState/<TakeConcurrentConnectionLockAsync>d__15")]
public virtual Task TakeConcurrentConnectionLockAsync(SubscriptionConnection connection);
    private void RefreshFeatures(SubscriptionConnection connection);
    protected virtual void SetLastChangeVectorSent(SubscriptionConnection connection);
    public HashSet`1<long> GetActiveBatches();
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState/<AcknowledgeBatchAsync>d__19")]
public Task AcknowledgeBatchAsync(string changeVector, long batchId, List`1<DocumentRecord> addDocumentsToResend, Action`1<AcknowledgeSubscriptionBatchCommand> modifyCommand);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState/<GetRevisionsFromResendInternal>d__20")]
public IEnumerable`1<RevisionRecord> GetRevisionsFromResendInternal(ClusterOperationContext context, HashSet`1<long> activeBatches);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState/<GetRevisionsFromResend>d__21")]
public IEnumerable`1<ValueTuple`2<Document, Document>> GetRevisionsFromResend(DocumentDatabase database, ClusterOperationContext clusterContext, DocumentsOperationContext docsContext, HashSet`1<long> activeBatches);
    public bool IsDocumentInActiveBatch(ClusterOperationContext context, string documentId, HashSet`1<long> activeBatches);
    public bool IsRevisionInActiveBatch(ClusterOperationContext context, Document current, HashSet`1<long> activeBatches);
    protected virtual AcknowledgeSubscriptionBatchCommand GetAcknowledgeSubscriptionBatchCommand(string changeVector, long batchId, List`1<DocumentRecord> docsToResend);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState/<NoopAcknowledgeSubscriptionAsync>d__25")]
private Task NoopAcknowledgeSubscriptionAsync(bool force);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState/<RecordBatchRevisions>d__26")]
public Task`1<ValueTuple`2<long, object>> RecordBatchRevisions(List`1<RevisionRecord> list, string lastRecordedChangeVector);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState/<TryRecordBatchDocumentsAsync>d__27")]
public Task`1<ValueTuple`2<long, object>> TryRecordBatchDocumentsAsync(List`1<DocumentRecord> list, List`1<string> deleted, string lastRecordedChangeVector);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionConnectionsState/<RecordBatchInternal>d__28")]
protected virtual Task`1<ValueTuple`2<long, object>> RecordBatchInternal(RecordBatchSubscriptionDocumentsCommand command);
    public virtual void Dispose();
    public static SubscriptionConnectionsState CreateDummyState(DocumentsStorage storage, SubscriptionState state);
    public Task SendNoopAck(bool force);
    [CompilerGeneratedAttribute]
private bool <InitializeAsync>b__13_0(SubscriptionConnection c);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(SubscriptionConnection connection, bool afterSubscribe);
}
public abstract class Raven.Server.Documents.Subscriptions.SubscriptionFetcher : object {
    protected DocumentDatabase Database;
    protected SubscriptionConnectionsState SubscriptionConnectionsState;
    protected string Collection;
    protected ClusterOperationContext ClusterContext;
    protected DocumentsOperationContext DocsContext;
    protected HashSet`1<long> Active;
    protected internal long StartEtag;
    protected bool DocSent;
    public FetchingOrigin FetchingFrom;
    protected SubscriptionFetcher(DocumentDatabase database, SubscriptionConnectionsState subscriptionConnectionsState, string collection);
    public virtual void Initialize(ClusterOperationContext clusterContext, DocumentsOperationContext docsContext, HashSet`1<long> active);
    public void MarkDocumentSent();
}
public abstract class Raven.Server.Documents.Subscriptions.SubscriptionFetcher`1 : SubscriptionFetcher {
    protected Logger Logger;
    protected SubscriptionFetcher`1(DocumentDatabase database, SubscriptionConnectionsState subscriptionConnectionsState, string collection);
    protected abstract virtual IEnumerator`1<T> FetchByEtag();
    protected abstract virtual IEnumerator`1<T> FetchFromResend();
    [IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionFetcher`1/<GetEnumerator>d__4")]
public IEnumerable`1<T> GetEnumerator();
}
public class Raven.Server.Documents.Subscriptions.SubscriptionPatchDocument : Key {
    public string Script;
    public String[] DeclaredFunctions;
    public SubscriptionPatchDocument(string script, String[] declaredFunctions);
    public bool MatchCriteria(SingleRun run, DocumentsOperationContext context, object document, IResultModifier modifier, BlittableJsonReaderObject& transformResult);
    public virtual void GenerateScript(ScriptRunner runner);
    public virtual bool Equals(object obj);
    public bool Equals(SubscriptionPatchDocument other);
    public virtual int GetHashCode();
}
public class Raven.Server.Documents.Subscriptions.SubscriptionStatsCollector : object {
    public SubscriptionConnectionMetrics Metrics;
    public int ConnectionStatsIdForConnection;
    private static int _connectionStatsId;
    private static int _batchStatsId;
    private SubscriptionConnectionStatsScope _connectionScope;
    private SubscriptionConnectionStatsScope _pendingConnectionScope;
    private SubscriptionConnectionStatsScope _activeConnectionScope;
    private SubscriptionConnectionStatsAggregator _lastConnectionStats;
    private SubscriptionBatchStatsAggregator _lastBatchStats;
    private ConcurrentQueue`1<SubscriptionBatchStatsAggregator> _lastBatchesStats;
    public SubscriptionConnectionStatsScope ConnectionScope { get; }
    public SubscriptionConnectionStatsScope PendingConnectionScope { get; }
    public SubscriptionConnectionStatsScope ActiveConnectionScope { get; }
    public SubscriptionConnectionStatsAggregator LastConnectionStats { get; }
    public SubscriptionBatchStatsAggregator GetBatchPerformanceStats { get; }
    public List`1<SubscriptionBatchStatsAggregator> GetBatchesPerformanceStats { get; }
    public SubscriptionConnectionStatsScope get_ConnectionScope();
    public SubscriptionConnectionStatsScope get_PendingConnectionScope();
    public SubscriptionConnectionStatsScope get_ActiveConnectionScope();
    public SubscriptionConnectionStatsAggregator get_LastConnectionStats();
    public SubscriptionBatchStatsAggregator get_GetBatchPerformanceStats();
    public List`1<SubscriptionBatchStatsAggregator> get_GetBatchesPerformanceStats();
    public void Initialize();
    public void CreateActiveConnectionScope();
    public SubscriptionBatchStatsAggregator CreateInProgressBatchStats();
    public SubscriptionBatchStatsAggregator UpdateBatchPerformanceStats(long batchSize, bool anyDocumentsSent);
    private void AddBatchPerformanceStatsToBatchesHistory(SubscriptionBatchStatsAggregator batchStats);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.Subscriptions.SubscriptionStorage : AbstractSubscriptionStorage`1<SubscriptionConnectionsState> {
    internal DocumentDatabase _db;
    [CompilerGeneratedAttribute]
private Action`1<string> OnAddTask;
    [CompilerGeneratedAttribute]
private Action`1<string> OnRemoveTask;
    [CompilerGeneratedAttribute]
private Action`1<SubscriptionConnection> OnEndConnection;
    [CompilerGeneratedAttribute]
private Action`2<string, SubscriptionBatchStatsAggregator> OnEndBatch;
    public bool DisableSubscriptionTasks { get; }
    public SubscriptionStorage(DocumentDatabase db, ServerStore serverStore, string name);
    [CompilerGeneratedAttribute]
public void add_OnAddTask(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_OnAddTask(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void add_OnRemoveTask(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_OnRemoveTask(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void add_OnEndConnection(Action`1<SubscriptionConnection> value);
    [CompilerGeneratedAttribute]
public void remove_OnEndConnection(Action`1<SubscriptionConnection> value);
    [CompilerGeneratedAttribute]
public void add_OnEndBatch(Action`2<string, SubscriptionBatchStatsAggregator> value);
    [CompilerGeneratedAttribute]
public void remove_OnEndBatch(Action`2<string, SubscriptionBatchStatsAggregator> value);
    protected virtual void DropSubscriptionConnections(SubscriptionConnectionsState state, SubscriptionException ex);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionStorage/<PutSubscription>d__15")]
public Task`1<ValueTuple`2<long, long>> PutSubscription(SubscriptionCreationOptions options, string raftRequestId, Nullable`1<long> subscriptionId, Nullable`1<bool> disabled, string mentor);
    public SubscriptionState GetSubscriptionFromServerStore(string name);
    public string GetResponsibleNode(ClusterOperationContext context, string name);
    [AsyncStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionStorage/<DeleteSubscriptionInternal>d__18")]
public static Task DeleteSubscriptionInternal(ServerStore serverStore, string databaseName, string name, string raftRequestId, Logger logger);
    public string GetLastDocumentChangeVectorForSubscription(DocumentsOperationContext context, string collection);
    protected virtual void SetConnectionException(SubscriptionConnectionsState state, SubscriptionException ex);
    protected virtual string GetNodeFromState(SubscriptionState taskStatus);
    protected virtual DatabaseTopology GetTopology(ClusterOperationContext context);
    protected virtual bool SubscriptionChangeVectorHasChanges(SubscriptionConnectionsState state, SubscriptionState taskStatus);
    public virtual bool DropSingleSubscriptionConnection(long subscriptionId, string workerId, SubscriptionException ex);
    public virtual bool get_DisableSubscriptionTasks();
    public virtual ArchivedDataProcessingBehavior GetDefaultArchivedDataProcessingBehavior();
    [PreserveBaseOverridesAttribute]
[IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionStorage/<GetAllSubscriptions>d__28")]
public virtual override IEnumerable`1<SubscriptionGeneralDataAndStats> GetAllSubscriptions(ClusterOperationContext context, bool history, int start, int take);
    public SubscriptionConnectionsState GetSubscriptionStateById(long id);
    [IteratorStateMachineAttribute("Raven.Server.Documents.Subscriptions.SubscriptionStorage/<GetAllRunningSubscriptions>d__30")]
public IEnumerable`1<SubscriptionGeneralDataAndStats> GetAllRunningSubscriptions(ClusterOperationContext context, bool history, int start, int take);
    public int GetNumberOfRunningSubscriptions();
    [PreserveBaseOverridesAttribute]
public virtual override SubscriptionGeneralDataAndStats GetSubscriptionWithDataByNameFromServerStore(ClusterOperationContext context, string name, bool history, bool running);
    [PreserveBaseOverridesAttribute]
public virtual override SubscriptionGeneralDataAndStats GetSubscriptionWithDataByIdFromServerStore(ClusterOperationContext context, long id, bool history, bool running);
    public long GetRunningCount();
    private SubscriptionGeneralDataAndStats GetSubscriptionInternal(SubscriptionState state, bool history, bool running);
    private static SubscriptionGeneralDataAndStats PopulateSubscriptionData(SubscriptionState state, bool history, SubscriptionConnectionsState concurrentSubscription);
    internal virtual void CleanupSubscriptions();
    public void RaiseNotificationForTaskAdded(string subscriptionName);
    public void RaiseNotificationForTaskRemoved(string subscriptionName);
    public void RaiseNotificationForConnectionEnded(SubscriptionConnection connection);
    public void RaiseNotificationForBatchEnded(string subscriptionName, SubscriptionBatchStatsAggregator batchAggregator);
}
public class Raven.Server.Documents.Subscriptions.SubscriptionTaskPerformanceStats : object {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionConnectionPerformanceStats[] <ConnectionPerformance>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionBatchPerformanceStats[] <BatchPerformance>k__BackingField;
    public long TaskId { get; public set; }
    public string TaskName { get; public set; }
    public SubscriptionConnectionPerformanceStats[] ConnectionPerformance { get; public set; }
    public SubscriptionBatchPerformanceStats[] BatchPerformance { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
public void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public SubscriptionConnectionPerformanceStats[] get_ConnectionPerformance();
    [CompilerGeneratedAttribute]
public void set_ConnectionPerformance(SubscriptionConnectionPerformanceStats[] value);
    [CompilerGeneratedAttribute]
public SubscriptionBatchPerformanceStats[] get_BatchPerformance();
    [CompilerGeneratedAttribute]
public void set_BatchPerformance(SubscriptionBatchPerformanceStats[] value);
}
public enum Raven.Server.Documents.TableType : Enum {
    public byte value__;
    public static TableType None;
    public static TableType Documents;
    public static TableType Revisions;
    public static TableType Conflicts;
    public static TableType LegacyCounter;
    public static TableType Counters;
    public static TableType TimeSeries;
}
public class Raven.Server.Documents.TcpHandlers.SubscriptionConnection : SubscriptionConnectionBase`1<DatabaseIncludesCommandImpl> {
    private static ParserOptions DefaultParserOptions;
    private DocumentDatabase _database;
    public long CurrentBatchId;
    protected SubscriptionConnectionsState State;
    public SubscriptionConnection(ServerStore serverStore, TcpConnectionOptions tcpConnection, IDisposable tcpConnectionDisposable, MemoryBuffer bufferToCopy, string database);
    private static SubscriptionConnection();
    public SubscriptionConnectionsState GetSubscriptionConnectionState();
    private SubscriptionPatchDocument SetupFilterAndProjectionScript();
    protected virtual void DisposeInternal();
    public static ParsedSubscription ParseSubscriptionQuery(string query);
    [AsyncStateMachineAttribute("Raven.Server.Documents.TcpHandlers.SubscriptionConnection/<OnClientAckAsync>d__10")]
protected virtual Task OnClientAckAsync(string clientReplyChangeVector);
    public virtual Task SendNoopAckAsync(bool force);
    protected virtual bool FoundAboutMoreDocs();
    protected virtual SubscriptionConnectionInUse<DatabaseIncludesCommandImpl> MarkInUse();
    protected virtual void AfterProcessorCreation();
    protected virtual void RaiseNotificationForBatchEnd(string name, SubscriptionBatchStatsAggregator last);
    [AsyncStateMachineAttribute("Raven.Server.Documents.TcpHandlers.SubscriptionConnection/<TryRecordBatchAndUpdateStatusAsync>d__16")]
protected virtual Task`1<SubscriptionBatchStatus> TryRecordBatchAndUpdateStatusAsync(IChangeVectorOperationContext context, SubscriptionBatchResult result);
    protected virtual StatusMessageDetails<DatabaseIncludesCommandImpl> GetDefault();
    public virtual ISubscriptionProcessor`1<DatabaseIncludesCommandImpl> CreateProcessor(SubscriptionConnectionBase`1<DatabaseIncludesCommandImpl> connection);
    protected virtual void GatherIncludesForDocument(DatabaseIncludesCommandImpl includeDocuments, Document document);
    public virtual SubscriptionConnectionInfo CreateConnectionInfo();
    protected virtual StatusMessageDetails<DatabaseIncludesCommandImpl> GetStatusMessageDetails();
    [CompilerGeneratedAttribute]
private SubscriptionConnectionsState <GetSubscriptionConnectionState>b__5_0(long subId);
    [CompilerGeneratedAttribute]
internal static string <ParseSubscriptionQuery>g__ExtractPathFromExpression|9_0(QueryExpression expression, Query q);
}
public class Raven.Server.Documents.TcpHandlers.SubscriptionConnectionDetails : object {
    [CompilerGeneratedAttribute]
private string <ClientUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SubscriptionOpeningStrategy> <Strategy>k__BackingField;
    public string ClientUri { get; public set; }
    public string WorkerId { get; public set; }
    public Nullable`1<SubscriptionOpeningStrategy> Strategy { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientUri();
    [CompilerGeneratedAttribute]
public void set_ClientUri(string value);
    [CompilerGeneratedAttribute]
public string get_WorkerId();
    [CompilerGeneratedAttribute]
public void set_WorkerId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<SubscriptionOpeningStrategy> get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(Nullable`1<SubscriptionOpeningStrategy> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Documents.TcpHandlers.SubscriptionConnectionForShard : SubscriptionConnection {
    public string ShardName;
    private ShardedDocumentDatabase _shardedDatabase;
    private HashSet`1<string> _dbIdsToRemove;
    private SubscriptionConnectionsStateForShard _state;
    private ShardedDocumentsDatabaseSubscriptionProcessor _processor;
    public SubscriptionConnectionForShard(ServerStore serverStore, TcpConnectionOptions tcpConnection, IDisposable tcpConnectionDisposable, MemoryBuffer bufferToCopy, string database);
    protected virtual StatusMessageDetails<DatabaseIncludesCommandImpl> GetDefault();
    protected virtual DynamicJsonValue AcceptMessage();
    protected virtual RawDatabaseRecord GetRecord(ClusterOperationContext context);
    public virtual ISubscriptionProcessor`1<DatabaseIncludesCommandImpl> CreateProcessor(SubscriptionConnectionBase`1<DatabaseIncludesCommandImpl> connection);
    [AsyncStateMachineAttribute("Raven.Server.Documents.TcpHandlers.SubscriptionConnectionForShard/<TryRecordBatchAndUpdateStatusAsync>d__10")]
protected virtual Task`1<SubscriptionBatchStatus> TryRecordBatchAndUpdateStatusAsync(IChangeVectorOperationContext context, SubscriptionBatchResult result);
    protected virtual bool FoundAboutMoreDocs();
    public SubscriptionConnectionsState GetSubscriptionConnectionStateForShard();
    [AsyncStateMachineAttribute("Raven.Server.Documents.TcpHandlers.SubscriptionConnectionForShard/<HandleBatchStatusAsync>d__13`2")]
internal virtual Task HandleBatchStatusAsync(TState state, SubscriptionBatchStatus status, Stopwatch sendingCurrentBatchStopwatch, SubscriptionConnectionInUse<DatabaseIncludesCommandImpl> markInUse, SubscriptionBatchStatsScope batchScope);
    [AsyncStateMachineAttribute("Raven.Server.Documents.TcpHandlers.SubscriptionConnectionForShard/<WaitForDocsMigrationAsync>d__14")]
private Task`1<bool> WaitForDocsMigrationAsync(AbstractSubscriptionConnectionsState state, Task pendingReply);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<SubscriptionBatchStatus> <>n__0(IChangeVectorOperationContext context, SubscriptionBatchResult result);
    [CompilerGeneratedAttribute]
private SubscriptionConnectionsState <GetSubscriptionConnectionStateForShard>b__12_0(long subId);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(TState state, SubscriptionBatchStatus status, Stopwatch sendingCurrentBatchStopwatch, SubscriptionConnectionInUse<DatabaseIncludesCommandImpl> markInUse, SubscriptionBatchStatsScope batchScope);
}
public class Raven.Server.Documents.TcpHandlers.SubscriptionConnectionsDetails : object {
    public List`1<SubscriptionConnectionDetails> Results;
    public SubscriptionMode SubscriptionMode;
    public DynamicJsonValue ToJson();
}
public enum Raven.Server.Documents.TcpHandlers.SubscriptionError : Enum {
    public int value__;
    public static SubscriptionError ConnectionRejected;
    public static SubscriptionError Error;
}
public class Raven.Server.Documents.TcpHandlers.SubscriptionOperationScope : object {
    public static string ConnectionPending;
    public static string ConnectionActive;
    public static string BatchSendDocuments;
    public static string BatchWaitForAcknowledge;
}
public class Raven.Server.Documents.TcpHandlers.TcpConnectionOptions : object {
    private static long _sequence;
    private MeterMetric _bytesReceivedMetric;
    private MeterMetric _bytesSentMetric;
    private DateTime _connectedAt;
    public long LastEtagSent;
    public long LastEtagReceived;
    private bool _isDisposed;
    public DocumentDatabase DocumentDatabase;
    public ShardedDatabaseContext DatabaseContext;
    public OperationTypes Operation;
    public Stream Stream;
    public TcpClient TcpClient;
    public int ProtocolVersion;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    public JsonContextPool ContextPool;
    private SemaphoreSlim _running;
    private string _debugTag;
    public X509Certificate2 Certificate;
    public long Id { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(long value);
    public virtual string ToString();
    public IDisposable ConnectionProcessingInProgress(string debugTag);
    public sealed virtual void Dispose();
    public void RegisterBytesSent(long bytesAmount);
    public void RegisterBytesReceived(long bytesAmount);
    public bool CheckMatch(Nullable`1<long> minSecondsDuration, Nullable`1<long> maxSecondsDuration, string ip, Nullable`1<OperationTypes> operationType);
    public DynamicJsonValue GetConnectionStats();
    [CompilerGeneratedAttribute]
private void <ConnectionProcessingInProgress>b__23_0();
    [CompilerGeneratedAttribute]
internal static void <Dispose>g__SafelyDispose|24_0(IDisposable toDispose);
}
public class Raven.Server.Documents.TimeSeries.BitsBuffer : ValueType {
    private Byte* _buffer;
    public int Size;
    public BitsBufferHeader* Header;
    public Byte* Buffer { get; }
    public int NumberOfBits { get; }
    public int NumberOfBytes { get; }
    private int UncompressedBitsInBytes { get; }
    public bool IsCompressed { get; }
    public BitsBuffer(Byte* buffer, int size);
    public Byte* get_Buffer();
    public int get_NumberOfBits();
    public int get_NumberOfBytes();
    private int get_UncompressedBitsInBytes();
    public bool get_IsCompressed();
    public bool EnsureAdditionalBits(ByteStringContext allocator, int numberOfBits);
    public bool TryCompressBuffer(ByteStringContext allocator, int requiredBytes);
    public bool HasEnoughBits(int bitsPosition, int numberOfBits);
    private ushort BitsAvailableInLastByte();
    public int FindTheFirstZeroBit(Int32& bitsPosition, int limit);
    public ulong ReadValue(Int32& bitsPosition, int bitsToRead);
    public void SetBits(int bitsPosition, ulong value, int bitsInValue);
    public void AddValue(ulong value, int bitsInValue);
    private void WriteBits(ulong value, int bitsInValue, int lastByteIndex, ushort bitsAvailable);
    internal bool AddBits(ByteStringContext allocator, BitsBuffer tempBitsBuffer);
    internal InternalScope<ByteStringMemoryCache> Uncompress(ByteStringContext allocator, BitsBuffer& bitsBuffer);
}
public class Raven.Server.Documents.TimeSeries.BitsBufferHeader : ValueType {
    public int UncompressedBitsPosition;
    public ushort CompressedSize;
    public ushort UncompressedSize;
}
[ExtensionAttribute]
public static class Raven.Server.Documents.TimeSeries.EnumExtensions : object {
    [ExtensionAttribute]
public static bool Contain(TimeSeriesSegmentEntryFields current, TimeSeriesSegmentEntryFields flag);
}
public interface Raven.Server.Documents.TimeSeries.ITimeSeriesReader {
    public bool IsRaw { get; }
    public abstract virtual IEnumerable`1<ValueTuple`2<IEnumerable`1<SingleResult>, SegmentResult>> SegmentsOrValues();
    public abstract virtual IEnumerable`1<SingleResult> AllValues(bool includeDead);
    public abstract virtual bool get_IsRaw();
}
public class Raven.Server.Documents.TimeSeries.NanValueException : Exception {
    public NanValueException(string message);
    public NanValueException(string message, Exception innerException);
}
public class Raven.Server.Documents.TimeSeries.SegmentHeader : ValueType {
    public int PreviousTimestamp;
    public int PreviousDelta;
    public ushort NumberOfEntries;
    public ushort SizeOfTags;
    public byte PreviousTagIndex;
    public byte NumberOfValues;
    public SegmentVersion Version;
    [FixedBufferAttribute("System.Byte", "1")]
public <Reserved>e__FixedBuffer Reserved;
}
public class Raven.Server.Documents.TimeSeries.SegmentResult : object {
    public DateTime Start;
    public DateTime End;
    public TimeSeriesValuesSegment Summary;
    public string ChangeVector;
    private TimeSeriesReader _reader;
    public IEnumerable`1<SingleResult> Values { get; }
    public SegmentResult(TimeSeriesReader reader);
    public IEnumerable`1<SingleResult> get_Values();
}
public class Raven.Server.Documents.TimeSeries.SegmentVersion : ValueType {
    public Version Number;
    public bool ContainsDuplicates { get; }
    public bool ContainsLastValueDuplicate { get; }
    private SegmentVersion(Version number);
    public static SegmentVersion Create();
    public bool get_ContainsDuplicates();
    public void SetLastValueDuplicate();
    public void ClearLastValueDuplicate();
    public bool get_ContainsLastValueDuplicate();
}
internal class Raven.Server.Documents.TimeSeries.SeriesSummary : object {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Max>k__BackingField;
    public int Count { get; public set; }
    public Double[] Min { get; public set; }
    public Double[] Max { get; public set; }
    public SeriesSummary(int numberOfValues);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public Double[] get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(Double[] value);
    [CompilerGeneratedAttribute]
public Double[] get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(Double[] value);
}
public class Raven.Server.Documents.TimeSeries.SingleResult : object {
    public DateTime Timestamp;
    public Memory`1<double> Values;
    public LazyStringValue Tag;
    public ulong Status;
    public SingleResultType Type;
    public DynamicJsonValue ToTimeSeriesEntryJson(double scale);
    public void CopyTo(SingleResult dest);
}
public enum Raven.Server.Documents.TimeSeries.SingleResultType : Enum {
    public int value__;
    public static SingleResultType Raw;
    public static SingleResultType RolledUp;
}
public class Raven.Server.Documents.TimeSeries.StatefulTimestampValue : ValueType {
    public long RawFirst;
    public long PreviousValue;
    public long RawMax;
    public long RawMin;
    public long RawSum;
    public int Count;
    public byte LeadingZeroes;
    public byte TrailingZeroes;
    [FixedBufferAttribute("System.Byte", "2")]
public <Reserved>e__FixedBuffer Reserved;
    public double First { get; public set; }
    public double Last { get; }
    public double Max { get; public set; }
    public double Min { get; public set; }
    public double Sum { get; public set; }
    public double get_First();
    public void set_First(double value);
    public double get_Last();
    public double get_Max();
    public void set_Max(double value);
    public double get_Min();
    public void set_Min(double value);
    public double get_Sum();
    public void set_Sum(double value);
}
public class Raven.Server.Documents.TimeSeries.StatefulTimestampValueSpan : ValueType {
    private StatefulTimestampValue* Pointer;
    private int Length;
    public Span`1<StatefulTimestampValue> Span { get; }
    public int NumberOfEntries { get; }
    public StatefulTimestampValueSpan(StatefulTimestampValue* pointer, int length);
    public Span`1<StatefulTimestampValue> get_Span();
    public int get_NumberOfEntries();
}
public class Raven.Server.Documents.TimeSeries.TimeSeriesMultiReader : object {
    private DocumentsOperationContext _context;
    private TimeSeriesReader _reader;
    private string _docId;
    private string _source;
    private string _collection;
    private Nullable`1<TimeSpan> _offset;
    private TimeValue _groupBy;
    private CancellationToken _token;
    private DateTime _from;
    private DateTime _to;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Stack`1<ValueTuple`2<DateTime, string>> _timeseriesStack;
    public bool IsRaw { get; }
    public TimeSeriesReader Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public TimeSeriesMultiReader(DocumentsOperationContext context, string documentId, string source, string collection, DateTime from, DateTime to, Nullable`1<TimeSpan> offset, TimeValue groupBy, CancellationToken token);
    public sealed virtual bool get_IsRaw();
    private void Initialize();
    private void AlignStartPoints(ValueTuple`2<DateTime, string> current);
    private bool TryGetConfig(TimeSeriesCollectionConfiguration& config);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesMultiReader/<SegmentsOrValues>d__17")]
public sealed virtual IEnumerable`1<ValueTuple`2<IEnumerable`1<SingleResult>, SegmentResult>> SegmentsOrValues();
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesMultiReader/<AllValues>d__18")]
public sealed virtual IEnumerable`1<SingleResult> AllValues(bool includeDead);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual TimeSeriesReader get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <Initialize>g__TryFitCurrentPolicy|14_0(<>c__DisplayClass14_0& , <>c__DisplayClass14_1& );
}
public class Raven.Server.Documents.TimeSeries.TimeSeriesPolicyRunner : BackgroundWorkBase {
    private DocumentDatabase _database;
    [CompilerGeneratedAttribute]
private TimeSeriesConfiguration <Configuration>k__BackingField;
    private TimeSpan _checkFrequency;
    public TimeSeriesConfiguration Configuration { get; }
    public TimeSeriesPolicyRunner(DocumentDatabase database, TimeSeriesConfiguration configuration);
    [CompilerGeneratedAttribute]
public TimeSeriesConfiguration get_Configuration();
    public static TimeSeriesPolicyRunner LoadConfigurations(DocumentDatabase database, DatabaseRecord dbRecord, TimeSeriesPolicyRunner policyRunner);
    [AsyncStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesPolicyRunner/<DoWork>d__7")]
protected virtual Task DoWork();
    public void MarkSegmentForPolicy(DocumentsOperationContext context, TimeSeriesSliceHolder slicerHolder, DateTime timestamp, string changeVector, int numberOfEntries);
    public void MarkForPolicy(DocumentsOperationContext context, TimeSeriesSliceHolder slicerHolder, DateTime timestamp, ulong status);
    private bool ShouldMarkForPolicy(DocumentsOperationContext context, TimeSeriesSliceHolder slicerHolder, DateTime timestamp, ulong status, TimeSeriesPolicy& nextPolicy);
    [AsyncStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesPolicyRunner/<HandleChanges>d__11")]
internal Task HandleChanges();
    [AsyncStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesPolicyRunner/<AddNewPolicy>d__12")]
private Task AddNewPolicy(CollectionName collectionName, TimeSeriesPolicy prev, TimeSeriesPolicy policy);
    [AsyncStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesPolicyRunner/<RunRollups>d__13")]
internal Task`1<long> RunRollups(bool propagateException, List`1<string> explanations);
    [AsyncStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesPolicyRunner/<DoRetention>d__14")]
internal Task DoRetention(bool propagateException);
    [AsyncStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesPolicyRunner/<ApplyRetention>d__15")]
private Task ApplyRetention(DocumentsOperationContext context, TimeSeriesCollectionConfiguration config, CollectionName collectionName, TimeSeriesPolicy policy, DateTime now);
    private static bool RequiredForNextPolicy(DocumentsOperationContext context, TimeSeriesCollectionConfiguration config, TimeSeriesPolicy policy, Slice item, DateTime to);
    [CompilerGeneratedAttribute]
internal static bool <HandleChanges>g__SkipExisting|11_0(string name, <>c__DisplayClass11_1& );
}
public class Raven.Server.Documents.TimeSeries.TimeSeriesReader : object {
    private DocumentsOperationContext _context;
    private string _documentId;
    private string _name;
    internal DateTime _from;
    internal DateTime _to;
    private Table _table;
    internal TableValueReader _tvr;
    private Double[] _values;
    private TimestampState[] _states;
    private LazyStringValue _tag;
    private TimeSeriesValuesSegment _currentSegment;
    private Nullable`1<TimeSpan> _offset;
    private DetailedSingleResult _details;
    private CancellationToken _token;
    [CompilerGeneratedAttribute]
private bool <IsRaw>k__BackingField;
    public bool IsRaw { get; }
    public DetailedSingleResult GetDetails { get; }
    public TimeSeriesReader(DocumentsOperationContext context, string documentId, string name, DateTime from, DateTime to, Nullable`1<TimeSpan> offset, CancellationToken token);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRaw();
    public void IncludeDetails();
    public DetailedSingleResult get_GetDetails();
    internal bool Init();
    public SingleResult First();
    public SingleResult Last(Nullable`1<DateTime> to);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesReader/<GetSegmentsSummary>d__24")]
internal IEnumerable`1<SegmentSummary> GetSegmentsSummary();
    internal SeriesSummary GetSummary();
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesReader/<SegmentsOrValues>d__26")]
public sealed virtual IEnumerable`1<ValueTuple`2<IEnumerable`1<SingleResult>, SegmentResult>> SegmentsOrValues();
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesReader/<AllValues>d__27")]
public sealed virtual IEnumerable`1<SingleResult> AllValues(bool includeDead);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesReader/<YieldSegmentMergeDuplicates>d__28")]
public IEnumerable`1<SingleResult> YieldSegmentMergeDuplicates(DateTime baseline, bool includeDead);
    private static void ResetAggregation(Double[] aggregated);
    private void Aggregate(Double[] aggregated, SingleResult result);
    public IEnumerable`1<SingleResult> YieldSegment(DateTime baseline, bool includeDead);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesReader/<YieldSegmentRaw>d__33")]
public IEnumerable`1<SingleResult> YieldSegmentRaw(DateTime baseline, bool includeDead);
    public DateTime NextSegmentBaseline();
    internal bool NextSegment(Int64& baselineMilliseconds);
    private void InitializeSegment(Int64& baselineMilliseconds, TimeSeriesValuesSegment& readOnlySegment);
    private long ReadBaseline();
    public DateTime ReadBaselineAsDateTime();
    internal string GetCurrentSegmentChangeVector();
    internal ValueTuple`3<long, string, DateTime> GetSegmentInfo();
    internal static ValueTuple`2<DateTime, DateTime> AddOffsetIfNeeded(Nullable`1<TimeSpan> offset, DateTime from, DateTime to);
    private static DateTime AddOffset(TimeSpan offset, DateTime date);
}
public class Raven.Server.Documents.TimeSeries.TimeSeriesRollups : object {
    private DocumentDatabase _database;
    private static TableSchema RollupSchema;
    public static Slice TimeSeriesRollupTable;
    private static Slice RollupKey;
    private static Slice NextRollupIndex;
    private Logger _logger;
    private static AggregationType[] Aggregations;
    private static TimeSeriesRollups();
    public TimeSeriesRollups(DocumentDatabase database);
    public void MarkForPolicy(DocumentsOperationContext context, TimeSeriesSliceHolder slicerHolder, TimeSeriesPolicy nextPolicy, DateTime timestamp);
    public void MarkSegmentForPolicy(DocumentsOperationContext context, TimeSeriesSliceHolder slicerHolder, TimeSeriesPolicy nextPolicy, DateTime timestamp, string changeVector);
    public bool HasPendingRollupFrom(DocumentsOperationContext context, Slice key, DateTime time);
    internal void PrepareRollups(DocumentsOperationContext context, DateTime currentTime, long take, long start, List`1<RollupState> states, Stopwatch& duration);
    public static void SplitKey(Slice key, String& docId, String& name);
    public void DeleteByPrimaryKeyPrefix(DocumentsOperationContext context, Slice prefix);
    public static List`1<SingleResult> GetAggregatedValues(TimeSeriesReader reader, RangeGroup rangeSpec, AggregationMode mode);
    public static long NextRollup(DateTime time, TimeSeriesPolicy nextPolicy);
    [CompilerGeneratedAttribute]
internal static void <GetAggregatedValues>g__MaybeMoveToNextRange|22_0(DateTime ts, <>c__DisplayClass22_0& );
    [CompilerGeneratedAttribute]
internal static void <GetAggregatedValues>g__AggregateIndividualItems|22_1(IEnumerable`1<SingleResult> items, <>c__DisplayClass22_0& );
}
public class Raven.Server.Documents.TimeSeries.TimeSeriesSegmentEntry : object {
    public LazyStringValue Key;
    public LazyStringValue LuceneKey;
    public LazyStringValue DocId;
    public LazyStringValue Name;
    public string ChangeVector;
    public TimeSeriesValuesSegment Segment;
    public int SegmentSize;
    public LazyStringValue Collection;
    public DateTime Start;
    public long Etag;
    public sealed virtual void Dispose();
}
[FlagsAttribute]
public enum Raven.Server.Documents.TimeSeries.TimeSeriesSegmentEntryFields : Enum {
    public int value__;
    public static TimeSeriesSegmentEntryFields Default;
    public static TimeSeriesSegmentEntryFields Key;
    public static TimeSeriesSegmentEntryFields DocIdNameAndStart;
    public static TimeSeriesSegmentEntryFields LuceneKey;
    public static TimeSeriesSegmentEntryFields ChangeVector;
    public static TimeSeriesSegmentEntryFields Segment;
    public static TimeSeriesSegmentEntryFields Collection;
    public static TimeSeriesSegmentEntryFields ForIndexing;
    public static TimeSeriesSegmentEntryFields ForEtl;
    public static TimeSeriesSegmentEntryFields ForSmuggler;
    public static TimeSeriesSegmentEntryFields All;
}
[IsReadOnlyAttribute]
public class Raven.Server.Documents.TimeSeries.TimeSeriesSegmentSummary : ValueType {
    public IReadOnlyList`1<double> Min;
    public IReadOnlyList`1<double> Max;
    public IReadOnlyList`1<double> Sum;
    public int Count;
    public TimeSeriesSegmentSummary(TimeSeriesValuesSegment segment);
}
public class Raven.Server.Documents.TimeSeries.TimeSeriesSliceHolder : object {
    private DocumentsOperationContext _context;
    public string DocId;
    public string Name;
    public string Collection;
    private Dictionary`2<LazyStringValue, Slice> _cachedTags;
    private List`1<InternalScope<ByteStringMemoryCache>> _internalScopesToDispose;
    private List`1<ExternalScope<ByteStringMemoryCache>> _externalScopesToDispose;
    public ByteString SegmentBuffer;
    public ByteString TimeSeriesKeyBuffer;
    public Slice TimeSeriesKeySlice;
    public Slice TimeSeriesPrefixSlice;
    public Slice LowerTimeSeriesName;
    public Slice DocumentKeyPrefix;
    public Slice StatsKey;
    public Slice CollectionSlice;
    public Slice NameSlice;
    public DateTime CurrentBaseline;
    public TimeSeriesSliceHolder(DocumentsOperationContext context, string documentId, string name, string collection);
    public TimeSeriesSliceHolder WithBaseline(DateTime time);
    public void CreateSegmentBuffer();
    public TimeSeriesSliceHolder WithChangeVectorHash(long hash);
    public void Initialize();
    public void SetBaselineToKey(DateTime time);
    public Slice PolicyNameWithSeparator(Slice slice, int offset, int length);
    public Span`1<byte> TagAsSpan(LazyStringValue tag);
    public sealed virtual void Dispose();
    private static ExternalScope<ByteStringMemoryCache> CreateTimeSeriesKeySlice(DocumentsOperationContext context, ByteString buffer, Slice timeSeriesPrefixSlice, DateTime timestamp, Slice& timeSeriesKeySlice);
    private static ExternalScope<ByteStringMemoryCache> CreateTimeSeriesKeyPrefixSlice(DocumentsOperationContext context, ByteString buffer, Slice documentIdPrefix, Slice timeSeriesName, Slice& timeSeriesPrefixSlice);
}
public class Raven.Server.Documents.TimeSeries.TimeSeriesStats : object {
    private TimeSeriesStorage _timeSeriesStorage;
    private static Slice RawPolicySlice;
    private static Slice TimeSeriesStatsKey;
    private static Slice PolicyIndex;
    private static Slice StartTimeIndex;
    private static TableSchema TimeSeriesStatsSchema;
    private static TimeSeriesStats();
    public TimeSeriesStats(TimeSeriesStorage timeSeriesStorage, Transaction tx);
    private Table GetOrCreateTable(Transaction tx, CollectionName collection);
    public void UpdateCountOfExistingStats(DocumentsOperationContext context, TimeSeriesSliceHolder slicer, CollectionName collection, long count);
    public void UpdateDates(DocumentsOperationContext context, TimeSeriesSliceHolder slicer, CollectionName collection, DateTime start, DateTime end);
    private static IDisposable ReadStats(DocumentsOperationContext context, Table table, TimeSeriesSliceHolder slicer, Int64& count, DateTime& start, DateTime& end, Slice& name);
    public long UpdateStats(DocumentsOperationContext context, TimeSeriesSliceHolder slicer, CollectionName collection, TimeSeriesValuesSegment segment, DateTime baseline, int modifiedEntries);
    private static DateTime GetLastLiveTimestamp(DocumentsOperationContext context, TimeSeriesValuesSegment segment, DateTime baseline);
    public ValueTuple`3<long, DateTime, DateTime> GetStats(DocumentsOperationContext context, string docId, string name);
    public string GetTimeSeriesNameOriginalCasing(DocumentsOperationContext context, string docId, string name);
    public ValueTuple`3<long, DateTime, DateTime> GetStats(DocumentsOperationContext context, TimeSeriesSliceHolder slicer);
    public ValueTuple`3<long, DateTime, DateTime> GetStats(DocumentsOperationContext context, Slice statsKey);
    public ValueTuple`3<long, DateTime, DateTime> GetStats(TableValueReader& tvr);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStats/<GetTimeSeriesNamesForDocumentOriginalCasing>d__20")]
public IEnumerable`1<string> GetTimeSeriesNamesForDocumentOriginalCasing(DocumentsOperationContext context, string docId);
    public LazyStringValue GetTimeSeriesNameOriginalCasing(DocumentsOperationContext context, Slice key);
    public void UpdateTimeSeriesName(DocumentsOperationContext context, CollectionName collection, TimeSeriesSliceHolder slicer);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStats/<GetTimeSeriesNameByPolicy>d__23")]
public IEnumerable`1<Slice> GetTimeSeriesNameByPolicy(DocumentsOperationContext context, CollectionName collection, string policy, long skip, int take);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStats/<GetTimeSeriesByPolicyFromStartDate>d__24")]
public IEnumerable`1<Slice> GetTimeSeriesByPolicyFromStartDate(DocumentsOperationContext context, CollectionName collection, string policy, DateTime start, long take);
    private static InternalScope<ByteStringMemoryCache> CombinePolicyNameAndTicks(DocumentsOperationContext context, string policy, long ticks, Slice& key, Slice& policyNameSlice);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStats/<GetAllPolicies>d__26")]
public IEnumerable`1<Slice> GetAllPolicies(DocumentsOperationContext context, CollectionName collection);
    public bool DeleteStats(DocumentsOperationContext context, CollectionName collection, Slice key);
    public bool DeleteByPrimaryKeyPrefix(DocumentsOperationContext context, CollectionName collection, Slice key);
    private Slice GetPolicy(TimeSeriesSliceHolder slicer);
    internal long GetNumberOfEntries(DocumentsOperationContext context);
    public static IDisposable ExtractStatsKeyFromStorageKey(DocumentsOperationContext context, Slice storageKey, Slice& statsKey);
    [CompilerGeneratedAttribute]
private void <UpdateStats>g__HandleLiveSegment|13_0(<>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
private bool <UpdateStats>g__TryHandleDeadSegment|13_1(<>c__DisplayClass13_0& );
}
public class Raven.Server.Documents.TimeSeries.TimeSeriesStorage : object {
    public static int MaxSegmentSize;
    public TimeSeriesStats Stats;
    public TimeSeriesRollups Rollups;
    internal TableSchema TimeSeriesSchema;
    internal TableSchema DeleteRangesSchema;
    private DocumentDatabase _documentDatabase;
    private DocumentsStorage _documentsStorage;
    private HashSet`1<string> _tableCreated;
    private Logger _logger;
    private Dictionary`2<string, String[]> _incrementalPrefixByDbId;
    private static Byte[] TimedCounterPrefixBuffer;
    private static Byte[] IncrementPrefixBuffer;
    private static string TimedCounterPrefix;
    private static string IncrementPrefix;
    private static string DecrementPrefix;
    [ThreadStaticAttribute]
private static Double[] _tempHolder;
    private static AppendOptions DefaultAppendOptions;
    private static StandardFormat FormatD18;
    public TimeSeriesStorage(DocumentDatabase documentDatabase, Transaction tx, TableSchema timeSeriesSchema, TableSchema deleteRangesSchema);
    private static TimeSeriesStorage();
    public long PurgeSegmentsAndDeletedRanges(DocumentsOperationContext context, string collection, long upto, long numberOfEntriesToDelete);
    private long PurgeDeletedRanged(Int64& upto, DocumentsOperationContext context, CollectionName collectionName, long numberOfEntriesToDelete);
    private long PurgeSegments(long upto, DocumentsOperationContext context, CollectionName collectionName, long numberOfEntriesToDelete);
    public long GetNumberOfTimeSeriesDeletedRanges(DocumentsOperationContext context);
    public long GetNumberOfTimeSeriesPendingDeletionSegments(DocumentsOperationContext context);
    private ChangeVector InsertDeletedRange(DocumentsOperationContext context, DeletionRangeRequest deletionRangeRequest, ChangeVector remoteChangeVector);
    public string DeleteTimestampRange(DocumentsOperationContext context, DeletionRangeRequest deletionRangeRequest, ChangeVector remoteChangeVector, bool updateMetadata);
    private Nullable`1<DateTime> BaselineOfNextSegment(Slice key, Slice prefix, Table table, DateTime baseline);
    private static DateTime GetBaseline(TableValueReader reader);
    public static DateTime GetBaseline(Byte* key, int keySize);
    public static void RemoveTimeSeriesNameFromMetadata(DocumentsOperationContext ctx, string docId, string tsName);
    private static TimeSeriesValuesSegment TableValueToSegment(TableValueReader& segmentValueReader, DateTime& baseline);
    public static DateTime EnsureMillisecondsPrecision(DateTime dt);
    public void DeleteAllTimeSeriesForDocument(DocumentsOperationContext context, string documentId, CollectionName collection, DocumentFlags flags);
    public TimeSeriesReader GetReader(DocumentsOperationContext context, string documentId, string name, DateTime from, DateTime to, Nullable`1<TimeSpan> offset);
    public bool TryAppendEntireSegment(DocumentsOperationContext context, TimeSeriesReplicationItem item, string docId, LazyStringValue name, ChangeVector changeVector, DateTime baseline);
    private bool TryAppendEntireSegment(DocumentsOperationContext context, Slice key, string documentId, string name, CollectionName collectionName, ChangeVector changeVector, TimeSeriesValuesSegment segment, DateTime baseline);
    public bool TryAppendEntireSegmentFromSmuggler(DocumentsOperationContext context, Slice key, CollectionName collectionName, TimeSeriesItem item);
    private bool TryPutSegmentDirectly(DocumentsOperationContext context, Slice key, string documentId, string name, CollectionName collectionName, ChangeVector changeVector, TimeSeriesValuesSegment segment, DateTime baseline);
    private bool AppendEntireSegment(DocumentsOperationContext context, Slice key, string documentId, string name, CollectionName collectionName, ChangeVector changeVector, TimeSeriesValuesSegment segment, DateTime baseline);
    public bool EnsureNoOverlap(DocumentsOperationContext context, Slice key, CollectionName collectionName, TimeSeriesValuesSegment segment, DateTime baseline);
    public bool IsOverlapping(DocumentsOperationContext context, Slice key, CollectionName collectionName, TimeSeriesValuesSegment segment, DateTime baseline, bool canUpdateExistingSegment);
    public string AppendTimestamp(DocumentsOperationContext context, string documentId, string collection, string name, IEnumerable`1<AppendOperation> toAppend, ChangeVector changeVectorFromReplication);
    public string IncrementTimestamp(DocumentsOperationContext context, string documentId, string collection, string name, IEnumerable`1<IncrementOperation> toIncrement, AppendOptions options);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStorage/<RareMixedPositiveAndNegativeValues>d__44")]
private IEnumerable`1<SingleResult> RareMixedPositiveAndNegativeValues(DocumentsOperationContext context, IncrementOperation element, int valuesLength, SingleResult holder);
    private static void ValidateTimestamp(DateTime prevTimestamp, DateTime elementTimestamp);
    private LazyStringValue TryGetTimedCounterTag(JsonOperationContext context, string dbId, bool positive);
    public string AppendTimestamp(DocumentsOperationContext context, string documentId, string collection, string name, IEnumerable`1<SingleResult> toAppend, AppendOptions options);
    private static void VerifyLegalName(string name);
    private bool ValueTooFar(TimeSeriesSegmentHolder segmentHolder, SingleResult current);
    private static bool EnsureNumberOfValues(int segmentNumberOfValues, SingleResult& current);
    private bool TryAppendToCurrentSegment(DocumentsOperationContext context, TimeSeriesSegmentHolder segmentHolder, IEnumerator`1<SingleResult> appendEnumerator, SingleResult current, Boolean& newValueFetched);
    private bool SplitSegment(DocumentsOperationContext context, TimeSeriesSegmentHolder timeSeriesSegment, IEnumerator`1<SingleResult> reader, SingleResult current);
    private static CompareResult Compare(DateTime localTime, Span`1<double> localValues, Span`1<byte> localTag, ulong localStatus, SingleResult remote, Nullable`1<DateTime> nextSegmentBaseline, TimeSeriesSegmentHolder holder);
    private static bool EitherOneIsMarkedAsDead(ulong localStatus, SingleResult remote, CompareResult& compareResult);
    private static CompareResult SelectLargestValue(Span`1<double> localValues, SingleResult remote, bool isIncrement);
    private static CompareResult SelectSmallerValue(Span`1<double> localValues, SingleResult remote);
    private static void ValuesAddition(SingleResult& current, Span`1<double> localValues);
    public void ReplaceTimeSeriesNameInMetadata(DocumentsOperationContext ctx, string docId, string oldName, string newName);
    public void AddTimeSeriesNameToMetadata(DocumentsOperationContext ctx, string docId, string tsName, NonPersistentDocumentFlags nonPersistentFlags);
    public string GetOriginalName(DocumentsOperationContext ctx, string docId, string tsName);
    private string GetOriginalNameInternal(DocumentsOperationContext context, string docId, string lowerName);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStorage/<GetSegmentsFrom>d__67")]
public IEnumerable`1<TimeSeriesReplicationItem> GetSegmentsFrom(DocumentsOperationContext context, long etag);
    internal TimeSeriesReplicationItem CreateTimeSeriesSegmentItem(DocumentsOperationContext context, TableValueReader& reader);
    internal LazyStringValue GetTimeSeriesNameOriginalCasing(DocumentsOperationContext context, string documentId, string name);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStorage/<GetDeletedRangesFrom>d__70")]
public IEnumerable`1<TimeSeriesDeletedRangeItem> GetDeletedRangesFrom(DocumentsOperationContext context, long etag);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStorage/<GetDeletedRangesFrom>d__71")]
public IEnumerable`1<TimeSeriesDeletedRangeItem> GetDeletedRangesFrom(DocumentsOperationContext context, string collection, long fromEtag);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStorage/<GetDeletedRangesForDoc>d__72")]
public IEnumerable`1<TimeSeriesDeletedRangeItem> GetDeletedRangesForDoc(DocumentsOperationContext context, string docId);
    private static ChangeVector ExtractDeletedRangeChangeVector(DocumentsOperationContext context, TableValueReader& reader);
    private static TimeSeriesDeletedRangeItem CreateDeletedRangeItem(DocumentsOperationContext context, TableValueReader& reader);
    public TimeSeriesSegmentEntry GetTimeSeries(DocumentsOperationContext context, Slice key, TimeSeriesSegmentEntryFields fields);
    public TimeSeriesSegmentEntry GetTimeSeries(DocumentsOperationContext context, long etag, TimeSeriesSegmentEntryFields fields);
    public IEnumerable`1<TimeSeriesSegmentEntry> GetTimeSeriesFrom(DocumentsOperationContext context, long etag, long take, TimeSeriesSegmentEntryFields fields);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStorage/<GetTimeSeries>d__78")]
private IEnumerable`1<TimeSeriesSegmentEntry> GetTimeSeries(DocumentsOperationContext context, long fromEtag, long toEtag, long take, TimeSeriesSegmentEntryFields fields);
    public IEnumerable`1<TimeSeriesSegmentEntry> GetTimeSeriesFrom(DocumentsOperationContext context, string collection, long etag, long take, TimeSeriesSegmentEntryFields fields);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStorage/<GetTimeSeriesFrom>d__80")]
private IEnumerable`1<TimeSeriesSegmentEntry> GetTimeSeriesFrom(DocumentsOperationContext context, string collection, long fromEtag, long toEtag, long take, TimeSeriesSegmentEntryFields fields);
    internal static TimeSeriesSegmentEntry CreateTimeSeriesItem(JsonOperationContext context, TableValueReader& reader, TimeSeriesSegmentEntryFields fields);
    internal IEnumerable`1<SegmentSummary> GetSegmentsSummary(DocumentsOperationContext context, string documentId, string name, DateTime from, DateTime to);
    internal SeriesSummary GetSeriesSummary(DocumentsOperationContext context, string documentId, string name);
    private static void ValidateSegment(TimeSeriesValuesSegment segment);
    public long GetNumberOfTimeSeriesSegments(DocumentsOperationContext context);
    public static void AssertNoNanValue(SingleResult toAppend);
    private Table GetOrCreateTimeSeriesTable(Transaction tx, CollectionName collection);
    private Table GetOrCreateDeleteRangesTable(Transaction tx, CollectionName collection);
    private Table GetOrCreateTable(Transaction tx, TableSchema tableSchema, CollectionName collection, CollectionTableType type);
    public DynamicJsonArray GetTimeSeriesNamesForDocument(DocumentsOperationContext context, string docId);
    public long GetLastTimeSeriesEtag(DocumentsOperationContext context);
    public long GetLastTimeSeriesEtag(DocumentsOperationContext context, string collection);
    private static void MarkSegmentAsPendingDeletion(DocumentsOperationContext context, string collection, long etag);
    public long GetNumberOfTimeSeriesSegmentsToProcess(DocumentsOperationContext context, string collection, Int64& afterEtag, Int64& totalCount, Stopwatch overallDuration);
    public long GetNumberOfTimeSeriesDeletedRangesToProcess(DocumentsOperationContext context, string collection, Int64& afterEtag, Int64& totalCount, Stopwatch overallDuration);
    [ConditionalAttribute("DEBUG")]
private static void EnsureStatsAndDataIntegrity(DocumentsOperationContext context, string docId, string name, TimeSeriesValuesSegment segment, CollectionName collectionName, DateTime baseline);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStorage/<GetSegmentsByBucketFrom>d__98")]
public IEnumerable`1<TimeSeriesReplicationItem> GetSegmentsByBucketFrom(DocumentsOperationContext context, int bucket, long etag);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesStorage/<GetDeletedRangesByBucketFrom>d__99")]
public IEnumerable`1<TimeSeriesDeletedRangeItem> GetDeletedRangesByBucketFrom(DocumentsOperationContext context, int bucket, long etag);
    [StorageIndexEntryKeyGeneratorAttribute]
internal static Scope<ByteStringMemoryCache> GenerateBucketAndEtagIndexKeyForTimeSeries(Transaction tx, TableValueReader& tvr, Slice& slice);
    [StorageIndexEntryKeyGeneratorAttribute]
internal static Scope<ByteStringMemoryCache> GenerateBucketAndEtagIndexKeyForDeletedRanges(Transaction tx, TableValueReader& tvr, Slice& slice);
    internal static void UpdateBucketStatsForDeletedRanges(Transaction tx, Slice key, TableValueReader& oldValue, TableValueReader& newValue);
    internal static void UpdateBucketStatsForTimeSeries(Transaction tx, Slice key, TableValueReader& oldValue, TableValueReader& newValue);
    [CompilerGeneratedAttribute]
private bool <DeleteTimestampRange>g__TryDeleteRange|17_0(Nullable`1& next, <>c__DisplayClass17_0& , <>c__DisplayClass17_1& , <>c__DisplayClass17_2& );
    [CompilerGeneratedAttribute]
private bool <EnsureNoOverlap>g__IsOverlapWithHigherSegment|31_0(Slice prefix, <>c__DisplayClass31_0& );
    [CompilerGeneratedAttribute]
private bool <EnsureNoOverlap>g__IsOverlapWithLowerSegment|31_1(Slice prefix, <>c__DisplayClass31_0& );
    [CompilerGeneratedAttribute]
private bool <IsOverlapping>g__IsOverlapWithHigherSegment|32_0(Slice prefix, <>c__DisplayClass32_0& );
    [CompilerGeneratedAttribute]
private bool <IsOverlapping>g__IsOverlapWithLowerSegment|32_1(Slice prefix, <>c__DisplayClass32_0& );
    [CompilerGeneratedAttribute]
internal static TimeSeriesSegmentEntry <CreateTimeSeriesItem>g__CreateTimeSeriesItemPartial|81_0(JsonOperationContext context, TableValueReader& reader, TimeSeriesSegmentEntryFields fields);
    [CompilerGeneratedAttribute]
internal static LazyStringValue <CreateTimeSeriesItem>g__ToLuceneKey|81_1(JsonOperationContext context, LazyStringValue documentId, LazyStringValue name, DateTime baseline);
}
public class Raven.Server.Documents.TimeSeries.TimeSeriesValuesSegment : ValueType {
    public static int BitsForFirstTimestamp;
    public static int LeadingZerosLengthBits;
    public static int BlockSizeAdjustment;
    public static int DefaultDelta;
    public static int MaxLeadingZerosLength;
    public static int BlockSizeLengthBits;
    private Byte* _buffer;
    private int _capacity;
    private bool _recomputeRequired;
    public static ulong Live;
    public static ulong Dead;
    public static int MaxNumberOfValues;
    public bool RecomputeRequired { get; }
    private SegmentHeader* Header { get; }
    public Byte* Ptr { get; }
    public StatefulTimestampValueSpan SegmentValues { get; }
    public ulong Hash { get; }
    public int NumberOfBytes { get; }
    public int Capacity { get; }
    public int NumberOfValues { get; }
    public int NumberOfEntries { get; }
    public SegmentVersion Version { get; }
    public int NumberOfLiveEntries { get; }
    public TimeSeriesValuesSegment(Byte* buffer, int capacity);
    public bool get_RecomputeRequired();
    private SegmentHeader* get_Header();
    public Byte* get_Ptr();
    public StatefulTimestampValueSpan get_SegmentValues();
    public ulong get_Hash();
    public DateTime GetLastTimestamp(DateTime baseline);
    public int get_NumberOfBytes();
    private int GetNumberOfBytes(SegmentHeader* header);
    public int get_Capacity();
    public void CopyTo(Byte* dest);
    public AllocatedMemoryData Clone(JsonOperationContext context, TimeSeriesValuesSegment& segment);
    public TimeSeriesSegmentSummary GetSummary();
    private void InvalidCapacity();
    private static int GetDataStart(SegmentHeader* header);
    public int get_NumberOfValues();
    public int get_NumberOfEntries();
    public SegmentVersion get_Version();
    public int get_NumberOfLiveEntries();
    public void Initialize(int numberOfValues);
    public bool Append(ByteStringContext allocator, int deltaFromStart, double val, Span`1<byte> tag, ulong status);
    public static void AssertValueStatus(ulong status);
    public bool Append(ByteStringContext allocator, int deltaFromStart, Span`1<double> vals, Span`1<byte> tag, ulong status, Span`1<double> aggregated);
    private static void UpdateSegmentVersionIfNeeded(SegmentHeader* tempHeader, int deltaFromStart);
    public int FindPreviousTag(Span`1<byte> tag, SegmentHeader* tempHeader);
    public bool InsertTag(Span`1<byte> tag, SegmentHeader* tempHeader, int numberOfBytes);
    [DoesNotReturnAttribute]
private static void ThrowInvalidTagLength();
    [DoesNotReturnAttribute]
private static void ThrowInvalidDelta();
    [DoesNotReturnAttribute]
private static void ThrowInvalidFirstDelta();
    [DoesNotReturnAttribute]
private static void ThrowInvalidNewDelta();
    public BitsBuffer GetBitsBuffer(SegmentHeader* header);
    private static void AddTimestamp(int deltaFromStart, BitsBuffer& bitsBuffer, SegmentHeader* tempHeader);
    private static void AddValue(StatefulTimestampValue& prev, BitsBuffer& bitsBuffer, double dblVal, ulong status, Nullable`1<double> aggregated);
    public Enumerator GetEnumerator(ByteStringContext allocator);
    public void Append(ByteStringContext context, ReadTimestampState readState, Span`1<double> aggregated);
    public TimeSeriesValuesSegment Recompute(ByteStringContext context);
    private static void InitialAggregate(Span`1<double> aggregated, ReadTimestampState prev);
    public static LazyStringValue SetTimestampTag(JsonOperationContext context, TagPointer tagPointer);
    public IEnumerable`1<SingleResult> YieldAllValues(DocumentsOperationContext context, DateTime baseline, bool includeDead);
    [IteratorStateMachineAttribute("Raven.Server.Documents.TimeSeries.TimeSeriesValuesSegment/<YieldAllValues>d__63")]
public IEnumerable`1<SingleResult> YieldAllValues(JsonOperationContext context, ByteStringContext allocator, DateTime baseline, bool includeDead);
    public static void ParseTimeSeriesKey(Byte* ptr, int size, JsonOperationContext context, LazyStringValue& docId, LazyStringValue& name);
    public static void ParseTimeSeriesKey(Byte* ptr, int size, JsonOperationContext context, LazyStringValue& docId, LazyStringValue& name, DateTime& baseLine);
    public static void ParseTimeSeriesKey(Slice key, JsonOperationContext context, LazyStringValue& docId, LazyStringValue& name);
    public static void ParseTimeSeriesKey(Slice key, JsonOperationContext context, LazyStringValue& docId, LazyStringValue& name, DateTime& baseLine);
    private static bool IsValid(ulong status, long value);
    [DoesNotReturnAttribute]
private void ThrowInvalidNumberOfValues(Span`1<double> vals);
    [DoesNotReturnAttribute]
private void ThrowInvalidCapacityLength();
    [DoesNotReturnAttribute]
private static void ThrowValuesOutOfRange(int numberOfValues);
    public bool InvalidLastValue();
}
public class Raven.Server.Documents.TimeSeries.TimestampEncodingDetails : ValueType {
    public int BitsForValue;
    public int ControlValue;
    public int ControlValueBitLength;
    public long MaxValueForEncoding;
    public static TimestampEncodingDetails[] Encodings;
    public static int MaxControlBitLength { get; }
    public TimestampEncodingDetails(int bitsForValue, int controlValue, int controlValueBitLength);
    private static TimestampEncodingDetails();
    public static int get_MaxControlBitLength();
}
public class Raven.Server.Documents.TimeSeries.TimestampState : ValueType {
    public byte LeadingZeroes;
    public byte TrailingZeroes;
    public long LastValidValue;
}
public enum Raven.Server.Documents.TimeSeries.Version : Enum {
    public byte value__;
    public static Version V50000;
    public static Version V50001;
    public static Version Baseline;
    public static Version Duplicates;
    public static Version LastDuplicate;
}
public class Raven.Server.Documents.TimeSeriesStream : object {
    public IEnumerable`1<DynamicJsonValue> TimeSeries;
    public string Key;
}
public class Raven.Server.Documents.Tombstone : object {
    public long StorageId;
    public TombstoneType Type;
    public LazyStringValue LowerId;
    public long Etag;
    public long DeletedEtag;
    public short TransactionMarker;
    public LazyStringValue Collection;
    public DocumentFlags Flags;
    public string ChangeVector;
    public DateTime LastModified;
    public DynamicJsonValue ToJson();
    public static Tombstone FromJson(JsonOperationContext ctx, BlittableJsonReaderObject json);
    public Tombstone CloneInternal(JsonOperationContext context);
    public sealed virtual void Dispose();
}
public class Raven.Server.Documents.TombstoneCleaner : BackgroundWorkBase {
    private TombstoneType[] _tombstoneTypes;
    private SemaphoreSlim _subscriptionsLocker;
    private DocumentDatabase _documentDatabase;
    private int _numberOfTombstonesToDeleteInBatch;
    private HashSet`1<ITombstoneAware> _subscriptions;
    private Nullable`1<long> _maxTombstoneEtagToDelete;
    public TombstoneCleaner(DocumentDatabase documentDatabase);
    public void Subscribe(ITombstoneAware subscription);
    public void Unsubscribe(ITombstoneAware subscription);
    public IDisposable PreventTombstoneCleaningUpToEtag(long maxTombstoneToDelete);
    [AsyncStateMachineAttribute("Raven.Server.Documents.TombstoneCleaner/<DoWork>d__10")]
protected virtual Task DoWork();
    [AsyncStateMachineAttribute("Raven.Server.Documents.TombstoneCleaner/<ExecuteCleanup>d__11")]
internal Task`1<long> ExecuteCleanup(Nullable`1<long> numberOfTombstonesToDeleteInBatch);
    private void RaiseBlockingTombstonesNotificationIfNecessary(TombstonesState tombstoneCollections);
    private void FillDetailsSet(List`1<BlockingTombstoneDetails> detailsSet, Dictionary`2<TombstoneDeletionBlockageSource, HashSet`1<string>> disabledSubscribers, IDictionary`2<string, long> tombstonesCountsPerCollection, IDictionary`2<string, long> tombstonesSizePerCollection, DocumentsOperationContext context);
    private static long GetTombstoneDataForCollection(IDictionary`2<string, long> dataPerCollection, string collectionName, DocumentsOperationContext context, Func`3<DocumentsOperationContext, string, long> retrieveDataFunc);
    private void UpdateNotifications(List`1<BlockingTombstoneDetails> detailsSet);
    internal TombstonesState GetState(bool addInfoForDebug);
    [CompilerGeneratedAttribute]
private void <PreventTombstoneCleaningUpToEtag>b__9_0();
    [CompilerGeneratedAttribute]
internal static State <GetState>g__GetStateInternal|16_0(Dictionary`2<string, StateHolder> results, string collection, TombstoneType type);
}
public abstract class Raven.Server.Documents.TransactionMerger.AbstractTransactionOperationsMerger`2 : object {
    private string _resourceName;
    private JsonContextPoolBase`1<TOperationContext> _contextPool;
    private RavenConfiguration _configuration;
    private SystemTime _time;
    private CancellationToken _shutdown;
    private bool _runTransactions;
    private ConcurrentQueue`1<MergedTransactionCommand`2<TOperationContext, TTransaction>> _operations;
    private CountdownEvent _concurrentOperations;
    private ConcurrentQueue`1<List`1<MergedTransactionCommand`2<TOperationContext, TTransaction>>> _opsBuffers;
    private ManualResetEventSlim _waitHandle;
    private ExceptionDispatchInfo _edi;
    private Logger _log;
    private LongRunningWork _txLongRunningOperation;
    private double _maxTimeToWaitForPreviousTxInMs;
    private long _maxTxSizeInBytes;
    private double _maxTimeToWaitForPreviousTxBeforeRejectingInMs;
    private bool _isEncrypted;
    private bool _is32Bits;
    private bool _initialized;
    public DatabasePerformanceMetrics GeneralWaitPerformanceMetrics;
    public DatabasePerformanceMetrics TransactionPerformanceMetrics;
    private bool _alreadyListeningToPreviousOperationEnd;
    private DateTime _lastHighDirtyMemCheck;
    private TimeSetting _timeToCheckHighDirtyMemory;
    private RecordingTx<TOperationContext, TTransaction> _recording;
    public int NumberOfQueuedOperations { get; }
    private string TransactionMergerThreadName { get; }
    public bool RecordingEnabled { get; }
    protected AbstractTransactionOperationsMerger`2(string resourceName, RavenConfiguration configuration, SystemTime time, CancellationToken shutdown);
    public void Initialize(JsonContextPoolBase`1<TOperationContext> contextPool, bool isEncrypted, bool is32Bits);
    internal abstract virtual TTransaction BeginAsyncCommitAndStartNewTransaction(TTransaction previousTransaction, TOperationContext currentContext);
    public int get_NumberOfQueuedOperations();
    private string get_TransactionMergerThreadName();
    public void Start();
    [AsyncStateMachineAttribute("Raven.Server.Documents.TransactionMerger.AbstractTransactionOperationsMerger`2/<Enqueue>d__29")]
public Task Enqueue(MergedTransactionCommand`2<TOperationContext, TTransaction> cmd);
    public void EnqueueSync(MergedTransactionCommand`2<TOperationContext, TTransaction> cmd);
    [DoesNotReturnAttribute]
private static void ThrowTxMergerWasDisposed();
    private void MergeOperationThreadProc();
    private List`1<MergedTransactionCommand`2<TOperationContext, TTransaction>> GetBufferForPendingOps();
    private void DoCommandsNotification(object cmds);
    private void DoCommandNotification(object op);
    private static void DoCommandNotification(MergedTransactionCommand`2<TOperationContext, TTransaction> cmd);
    private void MergeTransactionsOnce();
    private void NotifyHighDirtyMemoryFailure(List`1<MergedTransactionCommand`2<TOperationContext, TTransaction>> pendingOps, HighDirtyMemoryException exception);
    internal abstract virtual void UpdateGlobalReplicationInfoBeforeCommit(TOperationContext context);
    private void NotifyTransactionFailureAndRerunIndependently(List`1<MergedTransactionCommand`2<TOperationContext, TTransaction>> pendingOps, Exception e);
    private void MergeTransactionsWithAsyncCommit(TOperationContext& previous, IDisposable& returnPreviousContext, List`1<MergedTransactionCommand`2<TOperationContext, TTransaction>> previousPendingOps);
    private void CompletePreviousTransaction(TOperationContext context, RavenTransaction previous, List`1& previousPendingOps, bool throwOnError);
    private PendingOperations<TOperationContext, TTransaction> ExecutePendingOperationsInTransaction(List`1<MergedTransactionCommand`2<TOperationContext, TTransaction>> executedOps, TOperationContext context, Task previousOperation, DurationMeasurement& meter);
    protected abstract virtual void UpdateLastAccessTime(DateTime time);
    private void UnlikelyRejectOperations(IAsyncResult previousOperation, Stopwatch sp, LowLevelTransaction llt, long modifiedSize);
    private bool TryGetNextOperation(Task previousOperation, MergedTransactionCommand`2& op, DurationMeasurement& meter);
    private bool UnlikelyWaitForNextOperationOrPreviousTransactionComplete(Task previousOperation, MergedTransactionCommand`2& op, DurationMeasurement& meter);
    private PendingOperations<TOperationContext, TTransaction> GetPendingOperationsStatus(TOperationContext context, bool forceCompletion);
    private void NotifyOnThreadPool(MergedTransactionCommand`2<TOperationContext, TTransaction> command);
    private void NotifyOnThreadPool(List`1<MergedTransactionCommand`2<TOperationContext, TTransaction>> commands);
    private void RunEachOperationIndependently(List`1<MergedTransactionCommand`2<TOperationContext, TTransaction>> pendingOps);
    public virtual void Dispose();
    public void StartRecording(string filePath, Action stopAction);
    public bool get_RecordingEnabled();
    public void StopRecording();
    [CompilerGeneratedAttribute]
private void <Start>b__28_0(object _);
    [CompilerGeneratedAttribute]
private void <MergeOperationThreadProc>g__ClearQueueWithException|32_0(Exception e);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <UnlikelyWaitForNextOperationOrPreviousTransactionComplete>b__49_0(Task _);
}
internal class Raven.Server.Documents.TransactionMerger.Commands.AdoptOrphanedRevisionsCommand : RevisionsScanningOperationCommand`1<AdoptOrphanedRevisionsResult> {
    public AdoptOrphanedRevisionsCommand(RevisionsStorage revisionsStorage, List`1<string> ids, AdoptOrphanedRevisionsResult result, OperationCancelToken token);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    public virtual IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> ToDto(DocumentsOperationContext context);
}
public class Raven.Server.Documents.TransactionMerger.Commands.DeleteDocumentCommand : DocumentMergedTransactionCommand {
    private string _id;
    private string _expectedChangeVector;
    private DocumentDatabase _database;
    public Nullable`1<DeleteOperationResult> DeleteResult;
    public DeleteDocumentCommand(string id, string changeVector, DocumentDatabase database);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    [PreserveBaseOverridesAttribute]
public virtual override IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, DocumentMergedTransactionCommand> ToDto(DocumentsOperationContext context);
}
public class Raven.Server.Documents.TransactionMerger.Commands.DeleteDocumentCommandDto : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    public string Id { get; public set; }
    public string ChangeVector { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    public sealed virtual DeleteDocumentCommand ToCommand(DocumentsOperationContext context, DocumentDatabase database);
}
public class Raven.Server.Documents.TransactionMerger.Commands.DeleteDocumentsCommand : MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> {
    private List`1<string> _ids;
    private DocumentDatabase _database;
    public DeleteDocumentsCommand(List`1<string> ids, DocumentDatabase database);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    public virtual IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> ToDto(DocumentsOperationContext context);
}
public abstract class Raven.Server.Documents.TransactionMerger.Commands.DocumentMergedTransactionCommand : MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> {
}
internal class Raven.Server.Documents.TransactionMerger.Commands.EnforceRevisionConfigurationCommand : RevisionsScanningOperationCommand`1<EnforceConfigurationResult> {
    private bool _includeForceCreatedRevisionsOnDeleteInCaseOfNoConfiguration;
    public EnforceRevisionConfigurationCommand(RevisionsStorage revisionsStorage, List`1<string> ids, EnforceConfigurationResult result, bool includeForceCreated, OperationCancelToken token);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    public virtual IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> ToDto(DocumentsOperationContext context);
}
public interface Raven.Server.Documents.TransactionMerger.Commands.IRecordableCommand`2 {
    public abstract virtual IReplayableCommandDto`3<TOperationContext, TTransaction, MergedTransactionCommand`2<TOperationContext, TTransaction>> ToDto(TOperationContext context);
}
public interface Raven.Server.Documents.TransactionMerger.Commands.IReplayableCommandDto`3 {
    public abstract virtual TCommand ToCommand(TOperationContext context, DocumentDatabase database);
}
public class Raven.Server.Documents.TransactionMerger.Commands.JsonPatchCommand : MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> {
    private string _id;
    private List`1<Command> _commands;
    public JsonPatchResult _patchResult;
    private bool _returnDocument;
    private JsonOperationContext _externalContext;
    public JsonPatchCommand(string id, List`1<Command> commands, bool returnDocument, JsonOperationContext externalContext);
    protected virtual long ExecuteCmd(DocumentsOperationContext context);
    public string HandleReply(DynamicJsonArray reply, HashSet`1<string> modifiedCollections, DocumentDatabase database);
    public static List`1<Command> Parse(BlittableJsonReaderObject blittable);
    private static string EscapePathMember(string member);
    public virtual IReplayableCommandDto`3<DocumentsOperationContext, DocumentsTransaction, MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction>> ToDto(DocumentsOperationContext context);
}
public abstract class Raven.Server.Documents.TransactionMerger.Commands.MergedTransactionCommand`2 : object {
    public bool UpdateAccessTime;
    [JsonIgnoreAttribute]
public TaskCompletionSource`1<object> TaskCompletionSource;
    public Exception Exception;
    public bool RetryOnError;
    protected abstract virtual long ExecuteCmd(TOperationContext context);
    internal long ExecuteDirectly(TOperationContext context);
    public virtual long Execute(TOperationContext context, RecordingState<TOperationContext, TTransaction> recordingState);
    public abstract virtual IReplayableCommandDto`3<TOperationContext, TTransaction, MergedTransactionCommand`2<TOperationContext, TTransaction>> ToDto(TOperationContext context);
}
internal abstract class Raven.Server.Documents.TransactionMerger.Commands.RevisionsScanningOperationCommand`1 : MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> {
    public bool MoreWork;
    protected RevisionsStorage _revisionsStorage;
    protected List`1<string> _ids;
    protected OperationCancelToken _token;
    protected TOperationResult _result;
    public RevisionsScanningOperationCommand`1(RevisionsStorage revisionsStorage, List`1<string> ids, TOperationResult result, OperationCancelToken token);
}
public class Raven.Server.Documents.TransactionMerger.DocumentsTransactionOperationsMerger : AbstractTransactionOperationsMerger`2<DocumentsOperationContext, DocumentsTransaction> {
    private DocumentDatabase _database;
    public DocumentsTransactionOperationsMerger(DocumentDatabase database);
    internal virtual DocumentsTransaction BeginAsyncCommitAndStartNewTransaction(DocumentsTransaction previousTransaction, DocumentsOperationContext currentContext);
    internal virtual void UpdateGlobalReplicationInfoBeforeCommit(DocumentsOperationContext context);
    protected virtual void UpdateLastAccessTime(DateTime time);
}
internal enum Raven.Server.Documents.TxInstruction : Enum {
    public int value__;
    public static TxInstruction BeginTx;
    public static TxInstruction Commit;
    public static TxInstruction Rollback;
    public static TxInstruction DisposeTx;
    public static TxInstruction BeginAsyncCommitAndStartNewTransaction;
    public static TxInstruction EndAsyncCommit;
    public static TxInstruction DisposePrevTx;
}
public abstract class Raven.Server.EventListener.AbstractEventListener : EventListener {
    private EventSource _eventSourceDotNet;
    protected void EnableEvents(DotNetEventType dotNetEventType);
    protected void DisableEvents();
    protected virtual void OnEventSourceCreated(EventSource eventSource);
    public virtual void Dispose();
}
public abstract class Raven.Server.EventListener.AbstractEventsHandler`1 : object {
    [CompilerGeneratedAttribute]
private HashSet`1<EventType> <EventTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MinimumDurationInMs>k__BackingField;
    protected HashSet`1<EventType> EventTypes { get; protected set; }
    protected long MinimumDurationInMs { get; protected set; }
    protected HashSet`1<EventType> DefaultEventTypes { get; }
    protected Action`1<TEvent> OnEvent { get; }
    [CompilerGeneratedAttribute]
protected HashSet`1<EventType> get_EventTypes();
    [CompilerGeneratedAttribute]
protected void set_EventTypes(HashSet`1<EventType> value);
    [CompilerGeneratedAttribute]
protected long get_MinimumDurationInMs();
    [CompilerGeneratedAttribute]
protected void set_MinimumDurationInMs(long value);
    protected abstract virtual HashSet`1<EventType> get_DefaultEventTypes();
    protected abstract virtual Action`1<TEvent> get_OnEvent();
    public abstract virtual bool HandleEvent(EventWrittenEventArgs eventData);
    public sealed virtual void Update(HashSet`1<EventType> eventTypes, long minimumDurationInMs);
}
public class Raven.Server.EventListener.AllocationsEventListener : AbstractEventListener {
    private Dictionary`2<string, AllocationInfo> _allocations;
    private AllocationsHandler _handler;
    public IReadOnlyCollection`1<AllocationInfo> Allocations { get; }
    public IReadOnlyCollection`1<AllocationInfo> get_Allocations();
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(AllocationInfo e);
}
public class Raven.Server.EventListener.AllocationsHandler : AbstractEventsHandler`1<AllocationInfo> {
    [CompilerGeneratedAttribute]
private Action`1<AllocationInfo> <OnEvent>k__BackingField;
    protected HashSet`1<EventType> DefaultEventTypes { get; }
    protected Action`1<AllocationInfo> OnEvent { get; }
    public AllocationsHandler(Action`1<AllocationInfo> onEvent, HashSet`1<EventType> eventTypes, long minimumDurationInMs);
    protected virtual HashSet`1<EventType> get_DefaultEventTypes();
    [CompilerGeneratedAttribute]
protected virtual Action`1<AllocationInfo> get_OnEvent();
    public virtual bool HandleEvent(EventWrittenEventArgs eventData);
}
public class Raven.Server.EventListener.ContentionEventsHandler : AbstractEventsHandler`1<ContentionEvent> {
    [CompilerGeneratedAttribute]
private Action`1<ContentionEvent> <OnEvent>k__BackingField;
    private Dictionary`2<Guid, DateTime> _contentionStarts;
    protected HashSet`1<EventType> DefaultEventTypes { get; }
    protected Action`1<ContentionEvent> OnEvent { get; }
    public ContentionEventsHandler(Action`1<ContentionEvent> onEvent, HashSet`1<EventType> eventTypes, long minimumDurationInMs);
    protected virtual HashSet`1<EventType> get_DefaultEventTypes();
    [CompilerGeneratedAttribute]
protected virtual Action`1<ContentionEvent> get_OnEvent();
    public virtual bool HandleEvent(EventWrittenEventArgs eventData);
}
public class Raven.Server.EventListener.ContentionEventsListener : AbstractEventListener {
    private ContentionEventsHandler _handler;
    private List`1<ContentionEvent> _events;
    public IReadOnlyCollection`1<ContentionEvent> Events { get; }
    public IReadOnlyCollection`1<ContentionEvent> get_Events();
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(ContentionEvent e);
}
public abstract class Raven.Server.EventListener.Event : object {
    [CompilerGeneratedAttribute]
private EventType <Type>k__BackingField;
    public EventType Type { get; }
    protected Event(EventType type);
    [CompilerGeneratedAttribute]
public EventType get_Type();
    public virtual DynamicJsonValue ToJson();
    public virtual string ToString();
}
public class Raven.Server.EventListener.EventComparerByDuration : object {
    public sealed virtual int Compare(IDurationEvent x, IDurationEvent y);
}
public class Raven.Server.EventListener.EventListener : object {
}
public enum Raven.Server.EventListener.EventListenerMode : Enum {
    public int value__;
    public static EventListenerMode None;
    public static EventListenerMode Off;
    public static EventListenerMode ToLogFile;
}
public class Raven.Server.EventListener.EventListenerToLog : object {
    public static Logger Logger;
    private SemaphoreSlim _sm;
    private EventsListener _listener;
    private EventListenerConfiguration _configuration;
    public static HashSet`1<EventType> GcEvents;
    public static HashSet`1<EventType> AllocationEvents;
    public static HashSet`1<EventType> ContentionEvents;
    public static HashSet`1<EventType> ThreadEvents;
    private static HashSet`1<EventType> AllEvents;
    public static EventListenerToLog Instance;
    public bool LogToFile { get; }
    private static EventListenerToLog();
    public bool get_LogToFile();
    public void UpdateConfiguration(EventListenerConfiguration configuration);
    public sealed virtual DynamicJsonValue ToJson();
    [CompilerGeneratedAttribute]
private void <UpdateConfiguration>b__13_0(Event e);
}
public class Raven.Server.EventListener.EventsListener : AbstractEventListener {
    private List`1<IEventsHandler> _handlers;
    private Dictionary`2<string, IEventsHandler> _handlerByEventName;
    private DotNetEventType _dotNetEventType;
    private Dictionary`2<string, AllocationInfo> _allocations;
    private StringBuilder _sb;
    private Stopwatch _stopwatchSinceLastAllocation;
    private long _allocationsLoggingIntervalInMs;
    private int _allocationsLoggingCount;
    private InternalEvent _internalEvent;
    public EventsListener(HashSet`1<EventType> eventTypes, long minimumDurationInMs, long allocationsLoggingIntervalInMs, int allocationsLoggingCount, Action`1<Event> onEvent);
    private Action`1<AllocationInfo> OnAllocationEvent(Action`1<Event> onEvent);
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
    public void Update(HashSet`1<EventType> eventTypes, long minimumDurationInMs, long allocationsLoggingIntervalInMs, int allocationsLoggingCount);
    private static DotNetEventType GetDotNetEventTypes(HashSet`1<EventType> eventTypes);
}
public enum Raven.Server.EventListener.EventType : Enum {
    public int value__;
    public static EventType GC;
    public static EventType GCSuspend;
    public static EventType GCRestart;
    public static EventType GCFinalizers;
    public static EventType GCJoin;
    public static EventType GCHeapStats;
    public static EventType Allocations;
    public static EventType Contention;
    public static EventType ThreadPoolWorkerThreadStart;
    public static EventType ThreadPoolWorkerThreadWait;
    public static EventType ThreadPoolWorkerThreadStop;
    public static EventType ThreadPoolMinMaxThreads;
    public static EventType ThreadPoolWorkerThreadAdjustment;
    public static EventType ThreadPoolWorkerThreadAdjustmentSample;
    public static EventType ThreadPoolWorkerThreadAdjustmentStats;
    public static EventType ThreadCreating;
    public static EventType ThreadCreated;
    public static EventType ThreadRunning;
    public static EventType GCCreateConcurrentThread_V1;
}
public class Raven.Server.EventListener.GcEventsHandler : AbstractEventsHandler`1<GCEventBase> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<long, ValueTuple`3<DateTime, UInt32, UInt32>> _timeGcStartByIndex;
    private EventWrittenEventArgs _suspendData;
    private Nullable`1<DateTime> _timeGcRestartStart;
    private Nullable`1<DateTime> _timeGcFinalizersStart;
    [CompilerGeneratedAttribute]
private Action`1<GCEventBase> <OnEvent>k__BackingField;
    protected HashSet`1<EventType> DefaultEventTypes { get; }
    protected Action`1<GCEventBase> OnEvent { get; }
    public GcEventsHandler(Action`1<GCEventBase> onEvent, HashSet`1<EventType> eventTypes, long minimumDurationInMs);
    protected virtual HashSet`1<EventType> get_DefaultEventTypes();
    [CompilerGeneratedAttribute]
protected virtual Action`1<GCEventBase> get_OnEvent();
    public virtual bool HandleEvent(EventWrittenEventArgs eventData);
}
public class Raven.Server.EventListener.GcEventsListener : AbstractEventListener {
    private List`1<GCEventBase> _events;
    private GcEventsHandler _handler;
    private HashSet`1<EventType> _eventsToLog;
    public IReadOnlyCollection`1<GCEventBase> Events { get; }
    public IReadOnlyCollection`1<GCEventBase> get_Events();
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(GCEventBase e);
}
public interface Raven.Server.EventListener.IDurationEvent {
    public double DurationInMs { get; }
    public abstract virtual double get_DurationInMs();
}
public interface Raven.Server.EventListener.IEventsHandler {
    public abstract virtual bool HandleEvent(EventWrittenEventArgs eventData);
    public abstract virtual void Update(HashSet`1<EventType> eventTypes, long minimumDurationInMs);
}
public class Raven.Server.EventListener.ThreadsHandler : AbstractEventsHandler`1<ThreadEvent> {
    [CompilerGeneratedAttribute]
private Action`1<ThreadEvent> <OnEvent>k__BackingField;
    private ThreadPoolWorkerThreadWaitEvent _lastThreadPoolWorkerThreadWaitEvent;
    protected HashSet`1<EventType> DefaultEventTypes { get; }
    protected Action`1<ThreadEvent> OnEvent { get; }
    public ThreadsHandler(Action`1<ThreadEvent> onEvent, HashSet`1<EventType> eventTypes, long minimumDurationInMs);
    protected virtual HashSet`1<EventType> get_DefaultEventTypes();
    [CompilerGeneratedAttribute]
protected virtual Action`1<ThreadEvent> get_OnEvent();
    public virtual bool HandleEvent(EventWrittenEventArgs eventData);
}
public class Raven.Server.Exceptions.CriticalIndexingException : Exception {
    public CriticalIndexingException(Exception e);
    public CriticalIndexingException(string message, Exception e);
}
public class Raven.Server.Exceptions.ETL.ElasticSearch.ElasticSearchLoadException : Exception {
    public ElasticSearchLoadException(string message);
    public ElasticSearchLoadException(string message, Exception inner);
}
public class Raven.Server.Exceptions.ETL.QueueEtl.QueueLoadException : Exception {
    public QueueLoadException(string message);
    public QueueLoadException(string message, Exception inner);
}
public class Raven.Server.Exceptions.FeaturesAvailabilityException : Exception {
    public FeaturesAvailabilityException(string message);
    public FeaturesAvailabilityException(string message, Exception inner);
    [DoesNotReturnAttribute]
public static void Throw(Feature feature);
    [DoesNotReturnAttribute]
public static void Throw(string message);
}
public class Raven.Server.Exceptions.IndexAnalyzerException : Exception {
    public IndexAnalyzerException(Exception e);
    public IndexAnalyzerException(string message);
    public IndexAnalyzerException(string message, Exception innerException);
}
public class Raven.Server.Exceptions.IndexCorruptionException : Exception {
    public IndexCorruptionException(Exception e);
}
public class Raven.Server.Exceptions.IndexOpenException : Exception {
    public IndexOpenException(string message);
    public IndexOpenException(string message, Exception e);
}
public class Raven.Server.Exceptions.IndexWriteException : Exception {
    public IndexWriteException(Exception e);
    public IndexWriteException(string message);
    public IndexWriteException(string message, Exception innerException);
}
public class Raven.Server.Exceptions.IndexWriterCreationException : CriticalIndexingException {
    [CompilerGeneratedAttribute]
private string <Field>k__BackingField;
    public string Field { get; }
    public IndexWriterCreationException(Exception e);
    public IndexWriterCreationException(Exception e, string field);
    [CompilerGeneratedAttribute]
public string get_Field();
}
public class Raven.Server.Exceptions.InvalidCommandTypeException : Exception {
    public InvalidCommandTypeException(string msg);
}
public class Raven.Server.Exceptions.JitHitInternalLimitsOnIndexingFunction : CriticalIndexingException {
    internal static string ErrorMessage;
    public JitHitInternalLimitsOnIndexingFunction(InvalidProgramException e);
}
internal class Raven.Server.Exceptions.MissingAttachmentException : Exception {
    public MissingAttachmentException(string message);
    public MissingAttachmentException(string message, Exception innerException);
}
public class Raven.Server.Exceptions.PeriodicBackup.StorageException : Exception {
    [CompilerGeneratedAttribute]
private HttpResponseMessage <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseString>k__BackingField;
    public HttpResponseMessage Response { get; }
    public HttpStatusCode StatusCode { get; }
    public string ResponseString { get; private set; }
    private StorageException(HttpResponseMessage response, string message);
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_Response();
    public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public string get_ResponseString();
    [CompilerGeneratedAttribute]
private void set_ResponseString(string value);
    public static StorageException FromResponseMessage(HttpResponseMessage response);
}
public class Raven.Server.Exceptions.PersistConfigurationException : RavenException {
    public PersistConfigurationException(string message, Exception exception);
}
public class Raven.Server.Exceptions.RaftIndexWaitAggregateException : AggregateException {
    public RaftIndexWaitAggregateException(long raftCommandIndex, IEnumerable`1<Exception> innerExceptions);
    private static string CreateMessage(long raftCommandIndex, IEnumerable`1<Exception> innerExceptions);
}
public class Raven.Server.Exceptions.SerializationNestedLevelTooDeepException : Exception {
    public SerializationNestedLevelTooDeepException(string message);
}
[ExtensionAttribute]
public static class Raven.Server.Extensions.ClusterTopologyExtensions : object {
    [ExtensionAttribute]
public static void ReplaceCurrentNodeUrlWithClientRequestedNodeUrlIfNecessary(ClusterTopology topology, ServerStore serverStore, HttpContext httpContext);
}
[ExtensionAttribute]
public static class Raven.Server.Extensions.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TVal GetOrAdd(IDictionary`2<TKey, TVal> self, TKey key);
    [ExtensionAttribute]
public static TVal GetOrDefault(IDictionary`2<TKey, TVal> self, TKey key);
    public static bool ContentEquals(IDictionary`2<TKey, TValue> x, IDictionary`2<TKey, TValue> y);
    public static bool KeysEqual(IDictionary`2<TKey, TValue> dict1, IDictionary`2<TKey, TValue> dict2);
}
[ExtensionAttribute]
public static class Raven.Server.Extensions.ExpressionExtensions : object {
    [ExtensionAttribute]
public static void ThrowIfInvalidMethodInvocationInWhere(QueryExpression where, BlittableJsonReaderObject parameters, string queryText, string whereCollectionName);
    [DoesNotReturnAttribute]
private static void ThrowInvalidMethod(BlittableJsonReaderObject parameters, MethodExpression me, string queryText, string whereCollectionName);
    [ExtensionAttribute]
public static MemberInfo ToProperty(LambdaExpression expr);
    [ExtensionAttribute]
public static string ToPropertyPath(LambdaExpression expr, char propertySeparator, char collectionSeparator);
    [ExtensionAttribute]
public static string ToPropertyPath(Expression expression, char propertySeparator, char collectionSeparator);
}
[ExtensionAttribute]
internal static class Raven.Server.Extensions.FrozenDictionaryExtensions : object {
    [ExtensionAttribute]
public static FrozenDictionary`2<TKey, TValue> ToFrozenDictionaryWithSameComparer(Dictionary`2<TKey, TValue> source);
    [ExtensionAttribute]
public static FrozenDictionary`2<TKey, TValue> ToFrozenDictionaryWithSameComparer(ConcurrentDictionary`2<TKey, TValue> source);
}
[ExtensionAttribute]
public static class Raven.Server.Extensions.HttpExtensions : object {
    [ExtensionAttribute]
public static HttpRequestMessage WithConventions(HttpRequestMessage request, DocumentConventions conventions);
    [ExtensionAttribute]
public static HttpClient WithConventions(HttpClient httpClient, DocumentConventions conventions);
    [ExtensionAttribute]
public static RavenHttpClient WithConventions(RavenHttpClient httpClient, DocumentConventions conventions);
    [ExtensionAttribute]
public static ClientWebSocket WithConventions(ClientWebSocket clientWebSocket, DocumentConventions conventions);
    [ExtensionAttribute]
public static string GetFullUrl(HttpRequest request);
    public static string ExtractNodeUrlFromRequest(HttpRequest request);
    [ExtensionAttribute]
public static string GetClientRequestedNodeUrl(HttpRequest request);
    [ExtensionAttribute]
public static bool IsFromStudio(HttpRequest request);
    [ExtensionAttribute]
public static bool IsFromOrchestrator(HttpRequest request);
    [ExtensionAttribute]
public static bool IsFromClientApi(HttpRequest request);
    private static Nullable`1<bool> GetBoolFromHeaders(HttpRequest request, string name);
}
[ExtensionAttribute]
public static class Raven.Server.Extensions.JintExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<KeyValuePair`2<string, JsValue>> GetOwnPropertiesWithoutLength(JsArray array);
    [ExtensionAttribute]
public static IDisposable ChangeMaxStatements(Engine engine, int value);
    [ExtensionAttribute]
public static IDisposable DisableMaxStatements(Engine engine);
    [ExtensionAttribute]
public static void ExecuteWithReset(Engine engine, string source);
    [ExtensionAttribute]
public static string TryGetFieldFromSimpleLambdaExpression(IFunction function);
    private static MemberExpression GetMemberExpression(IFunction function);
}
[ExtensionAttribute]
public static class Raven.Server.Extensions.JsonSerializationExtensions : object {
    [ExtensionAttribute]
public static DynamicJsonValue ToJson(IndexHistoryEntry entry);
    [ExtensionAttribute]
public static DynamicJsonValue ToJson(IndexDefinition definition);
}
public static class Raven.Server.Extensions.MemoryExtensions : object {
    public static void SetWorkingSet(Process process, double ramInGb, Logger logger);
    private static bool WriteValue(string path, string str, Logger logger);
    public static void EmptyWorkingSet(Logger logger);
    internal static bool SetProcessWorkingSetSizeEx(IntPtr pProcess, long dwMinimumWorkingSetSize, long dwMaximumWorkingSetSize, QuotaLimit flags);
}
[ExtensionAttribute]
public static class Raven.Server.Extensions.RequestExecutorExtensions : object {
    [ExtensionAttribute]
public static void ExecuteWithCancellationToken(RequestExecutor requestExecutor, RavenCommand`1<TResult> command, JsonOperationContext context, CancellationToken token);
}
[ExtensionAttribute]
public static class Raven.Server.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static bool IsIdentifier(StringSegment token);
    [ExtensionAttribute]
public static string NormalizeLineEnding(string script);
    [ExtensionAttribute]
public static string ToUpperFirstLetter(string self);
    [ExtensionAttribute]
public static bool IsUpperLettersOnly(string nodeTag);
}
public class Raven.Server.Https.ExternalCertificateValidator : object {
    private RavenServer _server;
    private Logger _logger;
    private ConcurrentDictionary`2<Key, Task`1<CachedValue>> _externalCertificateValidationCallbackCache;
    public ExternalCertificateValidator(RavenServer server, Logger logger);
    public void Initialize();
    public void ClearCache();
    private CachedValue CheckExternalCertificateValidation(string senderHostname, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, Logger log);
    public bool ExternalCertificateValidationCallback(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, Logger log);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private bool <Initialize>b__4_0(object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors errors);
    [CompilerGeneratedAttribute]
internal static string <CheckExternalCertificateValidation>g__GetStdError|6_0(<>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static string <CheckExternalCertificateValidation>g__GetStdOut|6_1(<>c__DisplayClass6_0& );
}
public class Raven.Server.Https.HttpsConnectionMiddleware : object {
    private RavenServer _server;
    public CipherSuitesPolicy CipherSuitesPolicy;
    private static string ServerAuthenticationOid;
    private X509Certificate2 _originalServerCertificate;
    public HttpsConnectionMiddleware(RavenServer server, KestrelServerOptions options, X509Certificate2 originalServerCertificate);
    [AsyncStateMachineAttribute("Raven.Server.Https.HttpsConnectionMiddleware/<OnConnectionAsync>d__5")]
public Task OnConnectionAsync(ConnectionContext context, Func`1<Task> next);
    internal static X509Certificate2 ConvertToX509Certificate2(X509Certificate certificate);
    public static void EnsureCertificateIsAllowedForServerAuth(X509Certificate2 certificate);
}
public class Raven.Server.Indexing.IndexOutputFilesSummary : object {
    [CompilerGeneratedAttribute]
private long <TotalWritten>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasVoronWriteErrors>k__BackingField;
    public long TotalWritten { get; private set; }
    public bool HasVoronWriteErrors { get; private set; }
    [CompilerGeneratedAttribute]
public long get_TotalWritten();
    [CompilerGeneratedAttribute]
private void set_TotalWritten(long value);
    [CompilerGeneratedAttribute]
public bool get_HasVoronWriteErrors();
    [CompilerGeneratedAttribute]
private void set_HasVoronWriteErrors(bool value);
    public void Increment(long value);
    public void Reset();
    public void SetWriteError();
}
public class Raven.Server.Indexing.IndexTransactionCache : object {
    public Dictionary`2<string, DirectoryFiles> DirectoriesByName;
    public Dictionary`2<string, CollectionEtags> Collections;
}
public class Raven.Server.Indexing.LuceneCleaner : object {
    private AsyncReaderWriterLock _runningQueryLock;
    private static Logger Logger;
    private static LuceneCleaner();
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    public IDisposable EnterRunningQueryReadLock();
}
public class Raven.Server.Indexing.LuceneVoronDirectory : Directory {
    private StorageEnvironment _environment;
    private TempFileCache _tempFileCache;
    private string _name;
    private IndexOutputFilesSummary _indexOutputFilesSummary;
    private LuceneIndexInputType _indexInputType;
    public string Name { get; }
    public long FilesAllocations { get; }
    public string TempFullPath { get; }
    public LuceneVoronDirectory(Transaction tx, StorageEnvironment environment, TempFileCache tempFileCache, LuceneIndexInputType indexInputType);
    private static LuceneVoronDirectory();
    public LuceneVoronDirectory(Transaction tx, StorageEnvironment environment, TempFileCache tempFileCache, string name, LuceneIndexInputType indexInputType);
    public string get_Name();
    public long get_FilesAllocations();
    public string get_TempFullPath();
    public virtual bool FileExists(string name, IState s);
    public virtual String[] ListAll(IState s);
    public virtual long FileModified(string name, IState s);
    public virtual void TouchFile(string name, IState s);
    public virtual long FileLength(string name, IState s);
    public virtual void DeleteFile(string name, IState s);
    public virtual IndexInput OpenInput(string name, IState s);
    public virtual IndexOutput CreateOutput(string name, IState s);
    public IDisposable SetTransaction(Transaction tx, IState& state);
    public void ResetAllocations();
}
internal class Raven.Server.Indexing.MmapStream : Stream {
    private Byte* _ptr;
    private long _len;
    private long _pos;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public MmapStream(Byte* ptr, long len);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public void Set(Byte* buffer, int size);
}
public class Raven.Server.Indexing.TempFileCache : object {
    private StorageEnvironmentOptions _options;
    private ConcurrentQueue`1<TempFileStream> _files;
    private ConcurrentQueue`1<MemoryStream> _ms;
    private static long MaxFileSizeToKeepInBytes;
    internal static int MaxFilesToKeepInCache;
    private int _memoryStreamCapacity;
    internal static string FilePrefix;
    public int FilesCount { get; }
    public string FullPath { get; }
    public TempFileCache(StorageEnvironmentOptions options);
    public int get_FilesCount();
    public string get_FullPath();
    public void SetMemoryStreamCapacity(int capacity);
    public MemoryStream RentMemoryStream();
    public void ReturnMemoryStream(MemoryStream stream);
    public Stream RentFileStream();
    public static string GetTempFileName(StorageEnvironmentOptions options);
    public void ReturnFileStream(Stream stream);
    public sealed virtual void Dispose();
    private static void DisposeFile(TempFileStream file);
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
}
public class Raven.Server.Indexing.TempFileStream : Stream {
    public FileStream InnerStream;
    private long _length;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public TempFileStream(FileStream inner);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public void ResetLength();
}
public class Raven.Server.Indexing.VoronBufferedInput : BufferedIndexInput {
    private CancellationTokenSource _cts;
    private static int DefaultBufferSize;
    private LuceneVoronDirectory _directory;
    private string _name;
    private string _tree;
    private VoronStream _stream;
    private bool _isDisposed;
    private bool _isOriginal;
    public VoronBufferedInput(LuceneVoronDirectory directory, string name, Transaction transaction, string tree);
    public virtual long ReadVLong(IState state);
    private long ReadVLongUnlikely(IState state);
    public virtual int ReadVInt(IState state);
    private int ReadVIntUnlikely(IState state);
    public virtual string ToString();
    public virtual void SetBufferSize(int newSize);
    public virtual object Clone(IState s);
    protected virtual void Dispose(bool disposing);
    public virtual long Length(IState s);
    public virtual void ReadInternal(Byte[] b, int offset, int length, IState s);
    public virtual void SeekInternal(long pos, IState s);
    protected virtual void NewBuffer(int bufferSize);
    private void ThrowIfDisposed(VoronState state);
    [DoesNotReturnAttribute]
private static void ThrowTransactionDisposed();
    [DoesNotReturnAttribute]
private static void ThrowDisposed();
    [DoesNotReturnAttribute]
private static void ThrowCancelled();
    [DoesNotReturnAttribute]
private static void ThrowStateNullException();
    [DoesNotReturnAttribute]
private void ThrowInvalidSeekPosition(long pos);
}
public class Raven.Server.Indexing.VoronIndexInput : IndexInput {
    private CancellationTokenSource _cts;
    private LuceneVoronDirectory _directory;
    private string _name;
    private string _tree;
    private VoronStream _stream;
    private bool _isOriginal;
    public VoronIndexInput(LuceneVoronDirectory directory, string name, Transaction transaction, string tree);
    public virtual string ToString();
    internal static VoronStream OpenVoronStream(Transaction transaction, LuceneVoronDirectory directory, string name, string tree);
    public virtual object Clone(IState s);
    public virtual byte ReadByte(IState s);
    public virtual void ReadBytes(Byte[] buffer, int offset, int len, IState s);
    public virtual void Seek(long pos, IState s);
    protected virtual void Dispose(bool disposing);
    public virtual long Length(IState s);
    public virtual long FilePointer(IState s);
    private void ThrowIfDisposed(VoronState state);
    [DoesNotReturnAttribute]
private static void ThrowTransactionDisposed();
    [DoesNotReturnAttribute]
private static void ThrowDisposed();
    [DoesNotReturnAttribute]
private static void ThrowCancelled();
    [DoesNotReturnAttribute]
private static void ThrowStateNullException();
    [DoesNotReturnAttribute]
private void ThrowEndOfStreamException();
    [DoesNotReturnAttribute]
private void ThrowInvalidSeekPosition(long pos);
}
public class Raven.Server.Indexing.VoronIndexOutput : BufferedIndexOutput {
    private static Logger Logger;
    private TempFileCache _fileCache;
    private string _name;
    private string _tree;
    private Transaction _tx;
    private Stream _file;
    private MemoryStream _ms;
    private IndexOutputFilesSummary _indexOutputFilesSummary;
    private Stream StreamToUse { get; }
    public long Length { get; }
    public VoronIndexOutput(TempFileCache fileCache, string name, Transaction tx, string tree, IndexOutputFilesSummary indexOutputFilesSummary);
    private static VoronIndexOutput();
    private Stream get_StreamToUse();
    public virtual void FlushBuffer(Byte[] b, int offset, int len);
    public virtual void Seek(long pos);
    public virtual long get_Length();
    public virtual void SetLength(long length);
    protected virtual void Dispose(bool disposing);
    private void ConvertMemoryStreamToFileStream();
    private void CopyFileStream();
}
public class Raven.Server.Indexing.VoronState : object {
    public Transaction Transaction;
    public VoronState(Transaction transaction);
}
public class Raven.Server.Integrations.PostgreSQL.Commands.EditPostgreSqlConfigurationCommand : UpdateDatabaseCommand {
    public PostgreSqlConfiguration Configuration;
    public EditPostgreSqlConfigurationCommand(PostgreSqlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public static class Raven.Server.Integrations.PostgreSQL.CsvToPg : object {
    public static PgTable Convert(string fileName, Dictionary`2<string, PgColumn> columns);
    private static void HandleColumns(String[] fields, IReadOnlyDictionary`2<string, PgColumn> columns, PgTable& pgTable);
}
public class Raven.Server.Integrations.PostgreSQL.Exceptions.PgErrorException : Exception {
    public string ErrorCode;
    public PgErrorException(string errorCode, string errorMessage);
}
public class Raven.Server.Integrations.PostgreSQL.Exceptions.PgFatalException : Exception {
    public string ErrorCode;
    public PgFatalException(string errorCode, string errorMessage);
}
public class Raven.Server.Integrations.PostgreSQL.Exceptions.PgTerminateReceivedException : Exception {
}
public class Raven.Server.Integrations.PostgreSQL.Handlers.PostgreSqlIntegrationHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Handlers.PostgreSqlIntegrationHandler/<GetServerStatus>d__0")]
[RavenActionAttribute("/databases/*/admin/integrations/postgresql/server/status", "GET", "2", "False", "False", "True", "0")]
public Task GetServerStatus();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Handlers.PostgreSqlIntegrationHandler/<GetUsernamesList>d__1")]
[RavenActionAttribute("/databases/*/admin/integrations/postgresql/users", "GET", "2", "False", "False", "True", "0")]
public Task GetUsernamesList();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Handlers.PostgreSqlIntegrationHandler/<AddUser>d__2")]
[RavenActionAttribute("/databases/*/admin/integrations/postgresql/user", "PUT", "2", "False", "False", "True", "0")]
public Task AddUser();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Handlers.PostgreSqlIntegrationHandler/<DeleteUser>d__3")]
[RavenActionAttribute("/databases/*/admin/integrations/postgresql/user", "DELETE", "2", "False", "False", "True", "0")]
public Task DeleteUser();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Handlers.PostgreSqlIntegrationHandler/<PostPostgreSqlConfiguration>d__4")]
[RavenActionAttribute("/databases/*/admin/integrations/postgresql/config", "POST", "2", "False", "False", "True", "0")]
public Task PostPostgreSqlConfiguration();
}
public class Raven.Server.Integrations.PostgreSQL.Handlers.PostgreSqlServerStatus : object {
    [CompilerGeneratedAttribute]
private bool <Active>k__BackingField;
    public bool Active { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Active();
    [CompilerGeneratedAttribute]
public void set_Active(bool value);
}
public class Raven.Server.Integrations.PostgreSQL.Handlers.PostgreSqlUsername : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    public string Username { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Handlers.PostgreSqlUsernames : object {
    [CompilerGeneratedAttribute]
private List`1<PostgreSqlUsername> <Users>k__BackingField;
    public List`1<PostgreSqlUsername> Users { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<PostgreSqlUsername> get_Users();
    [CompilerGeneratedAttribute]
public void set_Users(List`1<PostgreSqlUsername> value);
}
internal abstract class Raven.Server.Integrations.PostgreSQL.Handlers.Processors.AbstractPostgreSqlIntegrationHandlerProcessor`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractPostgreSqlIntegrationHandlerProcessor`2(TRequestHandler requestHandler);
    public static void AssertCanUsePostgreSqlIntegration(TRequestHandler requestHandler);
}
internal abstract class Raven.Server.Integrations.PostgreSQL.Handlers.Processors.AbstractPostgreSqlIntegrationHandlerProcessorForAddUser`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<PostgreSqlConfiguration, TRequestHandler, TOperationContext> {
    protected AbstractPostgreSqlIntegrationHandlerProcessorForAddUser`2(TRequestHandler requestHandler);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, PostgreSqlConfiguration configuration, string raftRequestId);
    protected virtual ValueTask AssertCanExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Handlers.Processors.AbstractPostgreSqlIntegrationHandlerProcessorForAddUser`2/<GetConfigurationAsync>d__3")]
protected virtual ValueTask`1<PostgreSqlConfiguration> GetConfigurationAsync(TransactionOperationContext context, AsyncBlittableJsonTextWriter writer);
}
internal abstract class Raven.Server.Integrations.PostgreSQL.Handlers.Processors.AbstractPostgreSqlIntegrationHandlerProcessorForDeleteUser`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<PostgreSqlConfiguration, TRequestHandler, TOperationContext> {
    protected AbstractPostgreSqlIntegrationHandlerProcessorForDeleteUser`2(TRequestHandler requestHandler);
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, PostgreSqlConfiguration configuration, string raftRequestId);
    protected virtual ValueTask AssertCanExecuteAsync();
    protected virtual ValueTask`1<PostgreSqlConfiguration> GetConfigurationAsync(TransactionOperationContext context, AsyncBlittableJsonTextWriter writer);
}
internal abstract class Raven.Server.Integrations.PostgreSQL.Handlers.Processors.AbstractPostgreSqlIntegrationHandlerProcessorForGetUsernamesList`2 : AbstractPostgreSqlIntegrationHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractPostgreSqlIntegrationHandlerProcessorForGetUsernamesList`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Handlers.Processors.AbstractPostgreSqlIntegrationHandlerProcessorForGetUsernamesList`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Integrations.PostgreSQL.Handlers.Processors.AbstractPostgreSqlIntegrationHandlerProcessorForPostPostgreSqlConfiguration`2 : AbstractHandlerProcessorForUpdateDatabaseConfiguration`3<BlittableJsonReaderObject, TRequestHandler, TOperationContext> {
    protected AbstractPostgreSqlIntegrationHandlerProcessorForPostPostgreSqlConfiguration`2(TRequestHandler requestHandler);
    protected virtual ValueTask AssertCanExecuteAsync();
    protected virtual Task`1<ValueTuple`2<long, object>> OnUpdateConfiguration(TransactionOperationContext context, BlittableJsonReaderObject configuration, string raftRequestId);
}
internal class Raven.Server.Integrations.PostgreSQL.Handlers.Processors.PostgreSqlIntegrationHandlerProcessorForAddUser : AbstractPostgreSqlIntegrationHandlerProcessorForAddUser`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public PostgreSqlIntegrationHandlerProcessorForAddUser(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Integrations.PostgreSQL.Handlers.Processors.PostgreSqlIntegrationHandlerProcessorForDeleteUser : AbstractPostgreSqlIntegrationHandlerProcessorForDeleteUser`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public PostgreSqlIntegrationHandlerProcessorForDeleteUser(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Integrations.PostgreSQL.Handlers.Processors.PostgreSqlIntegrationHandlerProcessorForGetServerStatus`2 : AbstractPostgreSqlIntegrationHandlerProcessor`2<TRequestHandler, TOperationContext> {
    public PostgreSqlIntegrationHandlerProcessorForGetServerStatus`2(TRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Handlers.Processors.PostgreSqlIntegrationHandlerProcessorForGetServerStatus`2/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Integrations.PostgreSQL.Handlers.Processors.PostgreSqlIntegrationHandlerProcessorForGetUsernamesList : AbstractPostgreSqlIntegrationHandlerProcessorForGetUsernamesList`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public PostgreSqlIntegrationHandlerProcessorForGetUsernamesList(DatabaseRequestHandler requestHandler);
}
internal class Raven.Server.Integrations.PostgreSQL.Handlers.Processors.PostgreSqlIntegrationHandlerProcessorForPostPostgreSqlConfiguration : AbstractPostgreSqlIntegrationHandlerProcessorForPostPostgreSqlConfiguration`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public PostgreSqlIntegrationHandlerProcessorForPostPostgreSqlConfiguration(DatabaseRequestHandler requestHandler);
}
public class Raven.Server.Integrations.PostgreSQL.HardcodedQuery : PgQuery {
    private PgTable _result;
    public HardcodedQuery(string queryString, Int32[] parametersDataTypes, PgTable result);
    public static bool TryParse(string queryText, Int32[] parametersDataTypes, PgSession session, HardcodedQuery& hardcodedQuery);
    public virtual Task`1<ICollection`1<PgColumn>> Init(bool allowMultipleStatements);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.HardcodedQuery/<Execute>d__4")]
public virtual Task Execute(MessageBuilder builder, PipeWriter writer, CancellationToken token);
    public virtual void Dispose();
}
public class Raven.Server.Integrations.PostgreSQL.Messages.Bind : ExtendedProtocolMessage {
    public string PortalName;
    public string StatementName;
    public Int16[] ParameterFormatCodes;
    public List`1<Byte[]> Parameters;
    public Int16[] ResultColumnFormatCodes;
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Bind/<InitMessage>d__5")]
protected virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Bind/<HandleMessage>d__6")]
protected virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public class Raven.Server.Integrations.PostgreSQL.Messages.Cancel : object {
    public int ProcessId;
    public int SessionId;
}
public class Raven.Server.Integrations.PostgreSQL.Messages.Close : ExtendedProtocolMessage {
    public PgObjectType PgObjectType;
    public string ObjectName;
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Close/<InitMessage>d__2")]
protected virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Close/<HandleMessage>d__3")]
protected virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public class Raven.Server.Integrations.PostgreSQL.Messages.Describe : ExtendedProtocolMessage {
    public PgObjectType PgObjectType;
    public string ObjectName;
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Describe/<InitMessage>d__2")]
protected virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Describe/<HandleMessage>d__3")]
protected virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public class Raven.Server.Integrations.PostgreSQL.Messages.Execute : ExtendedProtocolMessage {
    public string PortalName;
    public int MaxRows;
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Execute/<InitMessage>d__2")]
protected virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Execute/<HandleMessage>d__3")]
protected virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public abstract class Raven.Server.Integrations.PostgreSQL.Messages.ExtendedProtocolMessage : Message {
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.ExtendedProtocolMessage/<Handle>d__0")]
public virtual Task Handle(PgTransaction transaction, MessageBuilder messageBuilder, PipeReader reader, PipeWriter writer, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.ExtendedProtocolMessage/<HandleError>d__1")]
public virtual Task HandleError(PgErrorException e, PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(PgTransaction transaction, MessageBuilder messageBuilder, PipeReader reader, PipeWriter writer, CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(PgErrorException e, PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public class Raven.Server.Integrations.PostgreSQL.Messages.Flush : Message {
    protected virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Flush/<HandleMessage>d__1")]
protected virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public interface Raven.Server.Integrations.PostgreSQL.Messages.IInitialMessage {
}
public abstract class Raven.Server.Integrations.PostgreSQL.Messages.Message : object {
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Message/<Init>d__0")]
public Task Init(MessageReader messageReader, PipeReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Message/<Handle>d__1")]
public virtual Task Handle(PgTransaction transaction, MessageBuilder messageBuilder, PipeReader reader, PipeWriter writer, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Message/<HandleError>d__2")]
public virtual Task HandleError(PgErrorException e, PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
    protected abstract virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
    protected abstract virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public class Raven.Server.Integrations.PostgreSQL.Messages.MessageBuilder : object {
    private IMemoryOwner`1<byte> _bufferOwner;
    private Memory`1<byte> Buffer { get; }
    private Memory`1<byte> get_Buffer();
    public ReadOnlyMemory`1<byte> ReadyForQuery(TransactionState transactionState);
    public ReadOnlyMemory`1<byte> EmptyQueryResponse();
    public ReadOnlyMemory`1<byte> AuthenticationOk();
    public ReadOnlyMemory`1<byte> AuthenticationCleartextPassword();
    public ReadOnlyMemory`1<byte> ErrorResponse(string severity, string errorCode, string errorMessage, string description);
    public ReadOnlyMemory`1<byte> BackendKeyData(int processId, int sessionId);
    public ReadOnlyMemory`1<byte> ParameterStatusMessages(Dictionary`2<string, string> status);
    private void ParameterStatus(string key, string value, Int32& pos);
    public ReadOnlyMemory`1<byte> ParseComplete();
    public ReadOnlyMemory`1<byte> BindComplete();
    public ReadOnlyMemory`1<byte> CloseComplete();
    public ReadOnlyMemory`1<byte> CommandComplete(string tag);
    public ReadOnlyMemory`1<byte> DataRow(Span`1<Nullable`1<ReadOnlyMemory`1<byte>>> columns);
    public ReadOnlyMemory`1<byte> RowDescription(ICollection`1<PgColumn> columns);
    public ReadOnlyMemory`1<byte> NoData();
    public ReadOnlyMemory`1<byte> ParameterDescription(IReadOnlyList`1<int> parametersDataTypeObjectIds);
    public ReadOnlyMemory`1<byte> SSLResponse(bool acceptSSL);
    private bool ConvertToShort(int value, Int16& outVal);
    private void WriteBytes(ReadOnlyMemory`1<byte> value, Int32& pos);
    private void WriteNullTerminatedString(string value, Int32& pos);
    private void WriteInt32(int value, Int32& pos);
    private void WriteInt16(short value, Int32& pos);
    private void WriteByte(byte value, Int32& pos);
    private void VerifyBufferSize(int pos, int addedSize);
    public sealed virtual void Dispose();
}
public class Raven.Server.Integrations.PostgreSQL.Messages.MessageReader : object {
    private List`1<Byte[]> _rentedBuffers;
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<ReadInitialMessage>d__1")]
public Task`1<IInitialMessage> ReadInitialMessage(PipeReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<StartupMessage>d__2")]
private Task`1<StartupMessage> StartupMessage(int version, int msgLen, PipeReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<Cancel>d__3")]
private Task`1<Cancel> Cancel(int msgLen, PipeReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<GetUninitializedMessage>d__4")]
public Task`1<Message> GetUninitializedMessage(PipeReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<ReadNullTerminatedString>d__5")]
public Task`1<ValueTuple`2<string, int>> ReadNullTerminatedString(PipeReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<ReadMinimumOf>d__6")]
private Task`1<ReadResult> ReadMinimumOf(PipeReader reader, int minSizeRequired, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<ReadBytesAsync>d__7")]
public Task`1<Byte[]> ReadBytesAsync(PipeReader reader, int length, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<ReadInt32Async>d__8")]
public Task`1<int> ReadInt32Async(PipeReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<ReadInt16Async>d__9")]
public Task`1<short> ReadInt16Async(PipeReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<ReadByteAsync>d__10")]
public Task`1<byte> ReadByteAsync(PipeReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.MessageReader/<SkipBytesAsync>d__11")]
public Task SkipBytesAsync(PipeReader reader, int length, CancellationToken token);
    private void SkipBytes(ReadOnlySequence`1<byte> readBuffer, PipeReader reader, int length);
    private Byte[] ReadBytes(ReadOnlySequence`1<byte> readBuffer, PipeReader reader, int length);
    private int ReadInt32(ReadOnlySequence`1<byte> readBuffer, PipeReader reader);
    private short ReadInt16(ReadOnlySequence`1<byte> readBuffer, PipeReader reader);
    private byte ReadByte(ReadOnlySequence`1<byte> readBuffer, PipeReader reader);
    public sealed virtual void Dispose();
}
public enum Raven.Server.Integrations.PostgreSQL.Messages.MessageType : Enum {
    public byte value__;
    public static MessageType Parse;
    public static MessageType Bind;
    public static MessageType Describe;
    public static MessageType Execute;
    public static MessageType Sync;
    public static MessageType Terminate;
    public static MessageType Query;
    public static MessageType Close;
    public static MessageType Flush;
    public static MessageType PasswordMessage;
    public static MessageType ParameterStatus;
    public static MessageType BackendKeyData;
    public static MessageType AuthenticationOk;
    public static MessageType AuthenticationCleartextPassword;
    public static MessageType ReadyForQuery;
    public static MessageType ErrorResponse;
    public static MessageType ParseComplete;
    public static MessageType BindComplete;
    public static MessageType CloseComplete;
    public static MessageType ParameterDescription;
    public static MessageType RowDescription;
    public static MessageType NoData;
    public static MessageType DataRow;
    public static MessageType CommandComplete;
    public static MessageType EmptyQueryResponse;
}
public class Raven.Server.Integrations.PostgreSQL.Messages.Parse : ExtendedProtocolMessage {
    public string StatementName;
    public string Query;
    public Int32[] ParametersDataTypes;
    private static Regex ParamRegex;
    private static Parse();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Parse/<InitMessage>d__4")]
protected virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Parse/<HandleMessage>d__5")]
protected virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public class Raven.Server.Integrations.PostgreSQL.Messages.PasswordMessage : Message {
    public string Password;
    private static string ErrorSeverity;
    private static string InvalidRoleSpecification;
    private static string InvalidPasswordErrorCode;
    private string PasswordAuthFailedErrorMessage(string username);
    private string RoleDoesNotExistErrorMessage(string username);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.PasswordMessage/<HandleMessage>d__6")]
protected virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.PasswordMessage/<InitMessage>d__7")]
protected virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
}
public class Raven.Server.Integrations.PostgreSQL.Messages.PgColumn : object {
    public string Name;
    public int TableObjectId;
    public short ColumnIndex;
    public PgType PgType;
    public PgFormat FormatCode;
    public PgColumn(string name, short columnIndex, PgType pgType, PgFormat formatCode, int tableOid);
}
public class Raven.Server.Integrations.PostgreSQL.Messages.PgDataRow : object {
    public Memory`1<Nullable`1<ReadOnlyMemory`1<byte>>> ColumnData;
    public PgDataRow(Memory`1<Nullable`1<ReadOnlyMemory`1<byte>>> columnData);
}
public enum Raven.Server.Integrations.PostgreSQL.Messages.PgErrorField : Enum {
    public byte value__;
    public static PgErrorField Severity;
    public static PgErrorField SeverityNotLocalized;
    public static PgErrorField SqlState;
    public static PgErrorField Message;
    public static PgErrorField Description;
    public static PgErrorField Hint;
    public static PgErrorField Position;
    public static PgErrorField PositionInternal;
    public static PgErrorField QueryInternal;
    public static PgErrorField Where;
    public static PgErrorField SchemaName;
    public static PgErrorField TableName;
    public static PgErrorField ColumnName;
    public static PgErrorField DataTypeName;
    public static PgErrorField ConstraintName;
    public static PgErrorField FileName;
    public static PgErrorField Line;
    public static PgErrorField Routine;
}
public enum Raven.Server.Integrations.PostgreSQL.Messages.PgFormat : Enum {
    public short value__;
    public static PgFormat Text;
    public static PgFormat Binary;
}
public enum Raven.Server.Integrations.PostgreSQL.Messages.PgObjectType : Enum {
    public byte value__;
    public static PgObjectType PreparedStatement;
    public static PgObjectType Portal;
}
public class Raven.Server.Integrations.PostgreSQL.Messages.PgSeverity : object {
    public static string Error;
    public static string Fatal;
    public static string Panic;
    public static string Warning;
    public static string Notice;
    public static string Debug;
    public static string Info;
    public static string Log;
}
public class Raven.Server.Integrations.PostgreSQL.Messages.PgTable : object {
    public List`1<PgColumn> Columns;
    public List`1<PgDataRow> Data;
}
public class Raven.Server.Integrations.PostgreSQL.Messages.Query : Message {
    public string QueryString;
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Query/<InitMessage>d__1")]
protected virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Query/<HandleMessage>d__2")]
protected virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Query/<HandleError>d__3")]
public virtual Task HandleError(PgErrorException e, PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(PgErrorException e, PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public class Raven.Server.Integrations.PostgreSQL.Messages.SSLRequest : object {
}
public class Raven.Server.Integrations.PostgreSQL.Messages.StartupMessage : object {
    public ProtocolVersion ProtocolVersion;
    public Dictionary`2<string, string> ClientOptions;
}
public class Raven.Server.Integrations.PostgreSQL.Messages.Sync : ExtendedProtocolMessage {
    protected virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Messages.Sync/<HandleMessage>d__1")]
protected virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public class Raven.Server.Integrations.PostgreSQL.Messages.Terminate : Message {
    protected virtual Task`1<int> InitMessage(MessageReader messageReader, PipeReader reader, int msgLen, CancellationToken token);
    protected virtual Task HandleMessage(PgTransaction transaction, MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
}
public static class Raven.Server.Integrations.PostgreSQL.Npgsql.NpgsqlConfig : object {
    public static string VersionQuery;
    public static PgTable VersionResponse;
    public static string VersionCurrentSettingQuery;
    public static PgTable VersionCurrentSettingResponse;
    public static string CurrentSettingQuery;
    public static PgTable CurrentSettingResponse;
    public static string Npgsql5TypesQuery;
    public static PgTable Npgsql5TypesResponse;
    public static string Npgsql5EnumTypesQuery;
    public static PgTable Npgsql5EnumTypesResponse;
    public static string Npgsql5CompositeTypesQuery;
    public static PgTable Npgsql5CompositeTypesResponse;
    public static string EnumTypesQuery;
    public static PgTable EnumTypesResponse;
    public static string CompositeTypesQuery;
    public static PgTable CompositeTypesResponse;
    public static string Npgsql4TypesQuery;
    public static PgTable Npgsql4TypesResponse;
    public static string Npgsql4_1_2TypesQuery;
    public static PgTable Npgsql4_1_2TypesResponse;
    public static string Npgsql4_0_3TypesQuery;
    public static PgTable Npgsql4_0_3TypesResponse;
    public static string TypesQuery;
    public static PgTable TypesResponse;
    public static string Npgsql4_0_0TypesQuery;
    public static PgTable Npgsql4_0_0TypesResponse;
    public static string Npgsql4_0_0CompositeTypesQuery;
    public static PgTable Npgsql4_0_0CompositeTypesResponse;
    public static string Npgsql3TypesQuery;
    public static PgTable Npgsql3TypesResponse;
    private static NpgsqlConfig();
}
public static class Raven.Server.Integrations.PostgreSQL.PgConfig : object {
    public static Dictionary`2<string, string> ParameterStatusList;
    private static PgConfig();
}
public static class Raven.Server.Integrations.PostgreSQL.PgErrorCodes : object {
    public static string SuccessfulCompletion;
    public static string Warning;
    public static string DynamicResultSetsReturnedWarning;
    public static string ImplicitZeroBitPaddingWarning;
    public static string NullValueEliminatedInSetFunctionWarning;
    public static string PrivilegeNotGrantedWarning;
    public static string PrivilegeNotRevokedWarning;
    public static string StringDataRightTruncationWarning;
    public static string DeprecatedFeatureWarning;
    public static string NoData;
    public static string NoAdditionalDynamicResultSetsReturned;
    public static string SqlStatementNotYetComplete;
    public static string ConnectionException;
    public static string ConnectionDoesNotExist;
    public static string ConnectionFailure;
    public static string SqlClientUnableToEstablishSqlConnection;
    public static string SqlServerRejectedEstablishmentOfSqlConnection;
    public static string TransactionResolutionUnknown;
    public static string ProtocolViolation;
    public static string TriggeredActionException;
    public static string FeatureNotSupported;
    public static string InvalidTransactionInitiation;
    public static string LocatorException;
    public static string InvalidLocatorSpecification;
    public static string InvalidGrantor;
    public static string InvalidGrantOperation;
    public static string InvalidRoleSpecification;
    public static string DiagnosticsException;
    public static string StackedDiagnosticsAccessedWithoutActiveHandler;
    public static string CaseNotFound;
    public static string CardinalityViolation;
    public static string DataException;
    public static string ArraySubscriptError;
    public static string CharacterNotInRepertoire;
    public static string DatetimeFieldOverflow;
    public static string DivisionByZero;
    public static string ErrorInAssignment;
    public static string EscapeCharacterConflict;
    public static string IndicatorOverflow;
    public static string IntervalFieldOverflow;
    public static string InvalidArgumentForLogarithm;
    public static string InvalidArgumentForNtileFunction;
    public static string InvalidArgumentForNthValueFunction;
    public static string InvalidArgumentForPowerFunction;
    public static string InvalidArgumentForWidthBucketFunction;
    public static string InvalidCharacterValueForCast;
    public static string InvalidDatetimeFormat;
    public static string InvalidEscapeCharacter;
    public static string InvalidEscapeOctet;
    public static string InvalidEscapeSequence;
    public static string NonstandardUseOfEscapeCharacter;
    public static string InvalidIndicatorParameterValue;
    public static string InvalidParameterValue;
    public static string InvalidRegularExpression;
    public static string InvalidRowCountInLimitClause;
    public static string InvalidRowCountInResultOffsetClause;
    public static string InvalidTablesampleArgument;
    public static string InvalidTablesampleRepeat;
    public static string InvalidTimeZoneDisplacementValue;
    public static string InvalidUseOfEscapeCharacter;
    public static string MostSpecificTypeMismatch;
    public static string NullValueNotAllowed;
    public static string NullValueNoIndicatorParameter;
    public static string NumericValueOutOfRange;
    public static string StringDataLengthMismatch;
    public static string StringDataRightTruncation;
    public static string SubstringError;
    public static string TrimError;
    public static string UnterminatedCString;
    public static string ZeroLengthCharacterString;
    public static string FloatingPointException;
    public static string InvalidTextRepresentation;
    public static string InvalidBinaryRepresentation;
    public static string BadCopyFileFormat;
    public static string UntranslatableCharacter;
    public static string NotAnXmlDocument;
    public static string InvalidXmlDocument;
    public static string InvalidXmlContent;
    public static string InvalidXmlComment;
    public static string InvalidXmlProcessingInstruction;
    public static string IntegrityConstraintViolation;
    public static string RestrictViolation;
    public static string NotNullViolation;
    public static string ForeignKeyViolation;
    public static string UniqueViolation;
    public static string CheckViolation;
    public static string ExclusionViolation;
    public static string InvalidCursorState;
    public static string InvalidTransactionState;
    public static string ActiveSqlTransaction;
    public static string BranchTransactionAlreadyActive;
    public static string HeldCursorRequiresSameIsolationLevel;
    public static string InappropriateAccessModeForBranchTransaction;
    public static string InappropriateIsolationLevelForBranchTransaction;
    public static string NoActiveSqlTransactionForBranchTransaction;
    public static string ReadOnlySqlTransaction;
    public static string SchemaAndDataStatementMixingNotSupported;
    public static string NoActiveSqlTransaction;
    public static string InFailedSqlTransaction;
    public static string InvalidSqlStatementName;
    public static string TriggeredDataChangeViolation;
    public static string InvalidAuthorizationSpecification;
    public static string InvalidPassword;
    public static string DependentPrivilegeDescriptorsStillExist;
    public static string DependentObjectsStillExist;
    public static string InvalidTransactionTermination;
    public static string SqlRoutineException;
    public static string FunctionExecutedNoReturnStatementSqlRoutineException;
    public static string ModifyingSqlDataNotPermittedSqlRoutineException;
    public static string ProhibitedSqlStatementAttemptedSqlRoutineException;
    public static string ReadingSqlDataNotPermittedSqlRoutineException;
    public static string InvalidCursorName;
    public static string ExternalRoutineException;
    public static string ContainingSqlNotPermittedExternalRoutineException;
    public static string ModifyingSqlDataNotPermittedExternalRoutineException;
    public static string ProhibitedSqlStatementAttemptedExternalRoutineException;
    public static string ReadingSqlDataNotPermittedExternalRoutineException;
    public static string ExternalRoutineInvocationException;
    public static string InvalidSqlstateReturnedExternalRoutineInvocationException;
    public static string NullValueNotAllowedExternalRoutineInvocationException;
    public static string TriggerProtocolViolatedExternalRoutineInvocationException;
    public static string SrfProtocolViolatedExternalRoutineInvocationException;
    public static string EventTriggerProtocolViolatedExternalRoutineInvocationException;
    public static string SavepointException;
    public static string InvalidSavepointSpecification;
    public static string InvalidCatalogName;
    public static string InvalidSchemaName;
    public static string TransactionRollback;
    public static string TransactionIntegrityConstraintViolation;
    public static string SerializationFailure;
    public static string StatementCompletionUnknown;
    public static string DeadlockDetected;
    public static string SyntaxErrorOrAccessRuleViolation;
    public static string SyntaxError;
    public static string InsufficientPrivilege;
    public static string CannotCoerce;
    public static string GroupingError;
    public static string WindowingError;
    public static string InvalidRecursion;
    public static string InvalidForeignKey;
    public static string InvalidName;
    public static string NameTooLong;
    public static string ReservedName;
    public static string DatatypeMismatch;
    public static string IndeterminateDatatype;
    public static string CollationMismatch;
    public static string IndeterminateCollation;
    public static string WrongObjectType;
    public static string UndefinedColumn;
    public static string UndefinedFunction;
    public static string UndefinedTable;
    public static string UndefinedParameter;
    public static string UndefinedObject;
    public static string DuplicateColumn;
    public static string DuplicateCursor;
    public static string DuplicateDatabase;
    public static string DuplicateFunction;
    public static string DuplicatePreparedStatement;
    public static string DuplicateSchema;
    public static string DuplicateTable;
    public static string DuplicateAlias;
    public static string DuplicateObject;
    public static string AmbiguousColumn;
    public static string AmbiguousFunction;
    public static string AmbiguousParameter;
    public static string AmbiguousAlias;
    public static string InvalidColumnReference;
    public static string InvalidColumnDefinition;
    public static string InvalidCursorDefinition;
    public static string InvalidDatabaseDefinition;
    public static string InvalidFunctionDefinition;
    public static string InvalidPreparedStatementDefinition;
    public static string InvalidSchemaDefinition;
    public static string InvalidTableDefinition;
    public static string InvalidObjectDefinition;
    public static string WithCheckOptionViolation;
    public static string InsufficientResources;
    public static string DiskFull;
    public static string OutOfMemory;
    public static string TooManyConnections;
    public static string ConfigurationLimitExceeded;
    public static string ProgramLimitExceeded;
    public static string StatementTooComplex;
    public static string TooManyColumns;
    public static string TooManyArguments;
    public static string ObjectNotInPrerequisiteState;
    public static string ObjectInUse;
    public static string CantChangeRuntimeParam;
    public static string LockNotAvailable;
    public static string OperatorIntervention;
    public static string QueryCanceled;
    public static string AdminShutdown;
    public static string CrashShutdown;
    public static string CannotConnectNow;
    public static string DatabaseDropped;
    public static string SystemError;
    public static string IoError;
    public static string UndefinedFile;
    public static string DuplicateFile;
    public static string SnapshotFailure;
    public static string ConfigFileError;
    public static string LockFileExists;
    public static string FdwError;
    public static string FdwColumnNameNotFound;
    public static string FdwDynamicParameterValueNeeded;
    public static string FdwFunctionSequenceError;
    public static string FdwInconsistentDescriptorInformation;
    public static string FdwInvalidAttributeValue;
    public static string FdwInvalidColumnName;
    public static string FdwInvalidColumnNumber;
    public static string FdwInvalidDataType;
    public static string FdwInvalidDataTypeDescriptors;
    public static string FdwInvalidDescriptorFieldIdentifier;
    public static string FdwInvalidHandle;
    public static string FdwInvalidOptionIndex;
    public static string FdwInvalidOptionName;
    public static string FdwInvalidStringLengthOrBufferLength;
    public static string FdwInvalidStringFormat;
    public static string FdwInvalidUseOfNullPointer;
    public static string FdwTooManyHandles;
    public static string FdwOutOfMemory;
    public static string FdwNoSchemas;
    public static string FdwOptionNameNotFound;
    public static string FdwReplyHandle;
    public static string FdwSchemaNotFound;
    public static string FdwTableNotFound;
    public static string FdwUnableToCreateExecution;
    public static string FdwUnableToCreateReply;
    public static string FdwUnableToEstablishConnection;
    public static string PlpgsqlError;
    public static string RaiseException;
    public static string NoDataFound;
    public static string TooManyRows;
    public static string AssertFailure;
    public static string InternalError;
    public static string DataCorrupted;
    public static string IndexCorrupted;
}
public abstract class Raven.Server.Integrations.PostgreSQL.PgQuery : object {
    private static Logger _log;
    protected string QueryString;
    public Int32[] ParametersDataTypes;
    protected bool IsEmptyQuery;
    public Dictionary`2<string, object> Parameters;
    protected Dictionary`2<string, PgColumn> Columns;
    private Int16[] _resultColumnFormatCodes;
    [CompilerGeneratedAttribute]
private bool <IsNamedStatement>k__BackingField;
    public bool IsNamedStatement { get; public set; }
    protected PgQuery(string queryString, Int32[] parametersDataTypes);
    private static PgQuery();
    [CompilerGeneratedAttribute]
public bool get_IsNamedStatement();
    [CompilerGeneratedAttribute]
public void set_IsNamedStatement(bool value);
    public static PgQuery CreateInstance(string queryText, Int32[] parametersDataTypes, DocumentDatabase documentDatabase, PgSession session);
    protected PgFormat GetDefaultResultsFormat();
    public abstract virtual Task`1<ICollection`1<PgColumn>> Init(bool allowMultipleStatements);
    public abstract virtual Task Execute(MessageBuilder builder, PipeWriter writer, CancellationToken token);
    public abstract virtual void Dispose();
    public virtual void Bind(ICollection`1<Byte[]> parameters, Int16[] parameterFormatCodes, Int16[] resultColumnFormatCodes);
}
public class Raven.Server.Integrations.PostgreSQL.PgServer : object {
    private Logger _logger;
    private RavenServer _server;
    private ConcurrentDictionary`2<TcpClient, Task> _connections;
    private CancellationTokenSource _cts;
    private SemaphoreSlim _locker;
    private ConcurrentQueue`1<TcpListener> _listeners;
    private int _processId;
    private int _port;
    private int _sessionIdentifier;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private bool <Active>k__BackingField;
    public bool Active { get; private set; }
    public PgServer(RavenServer server);
    [CompilerGeneratedAttribute]
public bool get_Active();
    [CompilerGeneratedAttribute]
private void set_Active(bool value);
    public void Execute();
    private void HandleServerActivation();
    private void Start();
    private void Stop();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.PgServer/<HandleConnection>d__19")]
public Task HandleConnection(TcpClient client);
    public sealed virtual void Dispose();
    private void ListenToConnections(TcpListener tcpListener);
    internal int GetListenerPort();
    private void Dispose(bool disposing);
}
public class Raven.Server.Integrations.PostgreSQL.PgSession : object {
    private static Logger Logger;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, PgQuery> <NamedStatements>k__BackingField;
    private TcpClient _client;
    private CertificateHolder _serverCertificateHolder;
    private int _identifier;
    private int _processId;
    private DatabasesLandlord _databasesLandlord;
    private CancellationToken _token;
    private Dictionary`2<string, string> _clientOptions;
    internal ConcurrentDictionary`2<string, PgQuery> NamedStatements { get; private set; }
    public PgSession(TcpClient client, CertificateHolder serverCertificateHolder, int identifier, int processId, DatabasesLandlord databasesLandlord, CancellationToken token);
    private static PgSession();
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<string, PgQuery> get_NamedStatements();
    [CompilerGeneratedAttribute]
private void set_NamedStatements(ConcurrentDictionary`2<string, PgQuery> value);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.PgSession/<HandleInitialMessage>d__13")]
private Task`1<Stream> HandleInitialMessage(Stream stream, MessageBuilder messageBuilder);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.PgSession/<Run>d__14")]
public Task Run();
    private string GetSourceConnectionDetails(string userName);
}
public class Raven.Server.Integrations.PostgreSQL.PgTransaction : object {
    [CompilerGeneratedAttribute]
private TransactionState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentDatabase <DocumentDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageReader <MessageReader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    internal PgQuery _currentQuery;
    [CompilerGeneratedAttribute]
private PgSession <Session>k__BackingField;
    public TransactionState State { get; private set; }
    public DocumentDatabase DocumentDatabase { get; }
    public MessageReader MessageReader { get; private set; }
    public string Username { get; private set; }
    internal PgSession Session { get; internal set; }
    public PgTransaction(DocumentDatabase documentDatabase, MessageReader messageReader, string username, PgSession session);
    [CompilerGeneratedAttribute]
public TransactionState get_State();
    [CompilerGeneratedAttribute]
private void set_State(TransactionState value);
    [CompilerGeneratedAttribute]
public DocumentDatabase get_DocumentDatabase();
    [CompilerGeneratedAttribute]
public MessageReader get_MessageReader();
    [CompilerGeneratedAttribute]
private void set_MessageReader(MessageReader value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
private void set_Username(string value);
    [CompilerGeneratedAttribute]
internal PgSession get_Session();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Session(PgSession value);
    public void Init(string cleanQueryText, Int32[] parametersDataTypes);
    public void Bind(ICollection`1<Byte[]> parameters, Int16[] parameterFormatCodes, Int16[] resultColumnFormatCodes, string statementName);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.PgTransaction/<Describe>d__23")]
public Task`1<ValueTuple`2<ICollection`1<PgColumn>, Int32[]>> Describe();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.PgTransaction/<Execute>d__24")]
public Task Execute(MessageBuilder messageBuilder, PipeWriter writer, CancellationToken token);
    public void Fail();
    public void Close();
    public void Sync();
    public sealed virtual void Dispose();
}
public class Raven.Server.Integrations.PostgreSQL.PowerBI.PowerBIAllCollectionsQuery : PowerBIRqlQuery {
    private static string TableQuery;
    public PowerBIAllCollectionsQuery(string queryText, Int32[] parametersDataTypes, DocumentDatabase documentDatabase);
    private static PowerBIAllCollectionsQuery();
    public static bool TryParse(string queryText, Int32[] parametersDataTypes, DocumentDatabase documentDatabase, PgQuery& pgQuery);
    public virtual Task`1<ICollection`1<PgColumn>> Init(bool allowMultipleStatements);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.PowerBI.PowerBIAllCollectionsQuery/<Execute>d__4")]
public virtual Task Execute(MessageBuilder builder, PipeWriter writer, CancellationToken token);
}
public static class Raven.Server.Integrations.PostgreSQL.PowerBI.PowerBIConfig : object {
    public static string TableSchemaQuery;
    public static string TableSchemaSecondaryQuery;
    public static string ConstraintsQuery;
    public static string CharacterSetsQuery;
    public static PgTable TableSchemaResponse;
    public static PgTable TableSchemaSecondaryResponse;
    public static PgTable ConstraintsResponse;
    public static PgTable CharacterSetsResponse;
    private static PowerBIConfig();
}
public static class Raven.Server.Integrations.PostgreSQL.PowerBI.PowerBIFetchQuery : object {
    private static Regex FetchSqlRegex;
    private static Regex WhereColumnRegex;
    private static Regex WhereOperatorRegex;
    private static Dictionary`2<string, string> OperatorMap;
    private static Regex TimestampConditionRegex;
    private static PowerBIFetchQuery();
    public static bool TryParse(string queryText, Int32[] parametersDataTypes, DocumentDatabase documentDatabase, PgQuery& pgQuery);
    private static Dictionary`2<string, ReplaceColumnValue> GetReplaceValues(List`1<Match> matches);
    private static QueryExpression GetSqlWhereConditions(List`1<Match> matches, Nullable`1<StringSegment> alias);
    private static bool TryGetMatches(string queryText, List`1& outMatches, Query& rql);
    private static Dictionary`2<string, ReplaceColumnValue> GetReplaces(Match match, Dictionary`2& replaces);
    private static bool IsRql(string queryText, Query& query);
}
public class Raven.Server.Integrations.PostgreSQL.PowerBI.PowerBIPreviewQuery : PowerBIRqlQuery {
    private List`1<PgDataRow> _results;
    private static Regex SqlRegex;
    public PowerBIPreviewQuery(DocumentDatabase documentDatabase, string tableName);
    private static PowerBIPreviewQuery();
    public static bool TryParse(string queryText, DocumentDatabase documentDatabase, PgQuery& pgQuery);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.PowerBI.PowerBIPreviewQuery/<Execute>d__4")]
public virtual Task Execute(MessageBuilder builder, PipeWriter writer, CancellationToken token);
    public virtual void Bind(ICollection`1<Byte[]> parameters, Int16[] parameterFormatCodes, Int16[] resultColumnFormatCodes);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.PowerBI.PowerBIPreviewQuery/<Init>d__6")]
public virtual Task`1<ICollection`1<PgColumn>> Init(bool allowMultipleStatements);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ICollection`1<PgColumn>> <>n__0(bool allowMultipleStatements);
}
public static class Raven.Server.Integrations.PostgreSQL.PowerBI.PowerBIQuery : object {
    public static bool TryParse(string queryText, Int32[] parametersDataTypes, DocumentDatabase documentDatabase, PgQuery& pgQuery);
}
public class Raven.Server.Integrations.PostgreSQL.PowerBI.PowerBIRqlQuery : RqlQuery {
    private Dictionary`2<string, ReplaceColumnValue> _replaces;
    public PowerBIRqlQuery(string queryString, Int32[] parametersDataTypes, DocumentDatabase documentDatabase, Dictionary`2<string, ReplaceColumnValue> replaces, Nullable`1<int> limit);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.PowerBI.PowerBIRqlQuery/<GenerateSchema>d__2")]
protected virtual Task`1<ICollection`1<PgColumn>> GenerateSchema();
    protected virtual void HandleSpecialColumnsIfNeeded(string columnName, PropertyDetails property, object value, Nullable`1[]& row);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ICollection`1<PgColumn>> <>n__0();
}
public class Raven.Server.Integrations.PostgreSQL.PowerBI.ReplaceColumnValue : object {
    [CompilerGeneratedAttribute]
private string <DstColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SrcColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <NewValue>k__BackingField;
    public string DstColumnName { get; public set; }
    public string SrcColumnName { get; public set; }
    public object OldValue { get; public set; }
    public object NewValue { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DstColumnName();
    [CompilerGeneratedAttribute]
public void set_DstColumnName(string value);
    [CompilerGeneratedAttribute]
public string get_SrcColumnName();
    [CompilerGeneratedAttribute]
public void set_SrcColumnName(string value);
    [CompilerGeneratedAttribute]
public object get_OldValue();
    [CompilerGeneratedAttribute]
public void set_OldValue(object value);
    [CompilerGeneratedAttribute]
public object get_NewValue();
    [CompilerGeneratedAttribute]
public void set_NewValue(object value);
}
public enum Raven.Server.Integrations.PostgreSQL.ProtocolVersion : Enum {
    public int value__;
    public static ProtocolVersion Version3;
    public static ProtocolVersion TlsConnection;
    public static ProtocolVersion CancelMessage;
}
public class Raven.Server.Integrations.PostgreSQL.RqlQuery : PgQuery {
    protected DocumentDatabase DocumentDatabase;
    private QueryOperationContext _queryOperationContext;
    private List`1<Document> _result;
    private Nullable`1<int> _limit;
    private bool _queryWasRun;
    private static Logger Logger;
    public RqlQuery(string queryString, Int32[] parametersDataTypes, DocumentDatabase documentDatabase, Nullable`1<int> limit);
    private static RqlQuery();
    protected virtual override void Finalize();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.RqlQuery/<Init>d__8")]
public virtual Task`1<ICollection`1<PgColumn>> Init(bool allowMultipleStatements);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.RqlQuery/<RunRqlQuery>d__9")]
public Task`1<List`1<Document>> RunRqlQuery(string forcedQueryToRun);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.RqlQuery/<GenerateSchema>d__10")]
protected virtual Task`1<ICollection`1<PgColumn>> GenerateSchema();
    public static bool TryParse(string queryText, Int32[] parametersDataTypes, DocumentDatabase documentDatabase, RqlQuery& rqlQuery);
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.RqlQuery/<Execute>d__12")]
public virtual Task Execute(MessageBuilder builder, PipeWriter writer, CancellationToken token);
    protected virtual void HandleSpecialColumnsIfNeeded(string columnName, PropertyDetails property, object value, Nullable`1[]& row);
    protected Nullable`1<ReadOnlyMemory`1<byte>> GetValueByType(PropertyDetails propertyDetails, object value, PgColumn pgColumn);
    public void ReleaseQueryResources();
    public virtual void Dispose();
}
public class Raven.Server.Integrations.PostgreSQL.Sharding.Handlers.ShardedPostgreSqlIntegrationHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Sharding.Handlers.ShardedPostgreSqlIntegrationHandler/<GetServerStatus>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/integrations/postgresql/server/status", "GET")]
public Task GetServerStatus();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Sharding.Handlers.ShardedPostgreSqlIntegrationHandler/<GetUsernamesList>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/integrations/postgresql/users", "GET")]
public Task GetUsernamesList();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Sharding.Handlers.ShardedPostgreSqlIntegrationHandler/<AddUser>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/integrations/postgresql/user", "PUT")]
public Task AddUser();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Sharding.Handlers.ShardedPostgreSqlIntegrationHandler/<DeleteUser>d__3")]
[RavenShardedActionAttribute("/databases/*/admin/integrations/postgresql/user", "DELETE")]
public Task DeleteUser();
    [AsyncStateMachineAttribute("Raven.Server.Integrations.PostgreSQL.Sharding.Handlers.ShardedPostgreSqlIntegrationHandler/<PostPostgreSqlConfiguration>d__4")]
[RavenShardedActionAttribute("/databases/*/admin/integrations/postgresql/config", "POST")]
public Task PostPostgreSqlConfiguration();
}
[ExtensionAttribute]
public static class Raven.Server.Integrations.PostgreSQL.StringExtensions : object {
    [ExtensionAttribute]
public static string Replace(string input, Regex regex, string groupName, string replacement);
    private static string ReplaceNamedGroup(string input, string groupName, string replacement, Match m);
    [ExtensionAttribute]
public static string NormalizeLineEndings(string input);
}
public enum Raven.Server.Integrations.PostgreSQL.TransactionState : Enum {
    public byte value__;
    public static TransactionState Idle;
    public static TransactionState InTransaction;
    public static TransactionState Failed;
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgBit : PgType {
    public static PgBit Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgBit();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgBool : PgType {
    public static PgBool Default;
    public static Byte[] TrueBuffer;
    public static Byte[] FalseBuffer;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgBool();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgBytea : PgType {
    public static PgBytea Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgBytea();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgChar : PgType {
    public static PgChar Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgChar();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgFloat4 : PgType {
    public static PgFloat4 Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgFloat4();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgFloat8 : PgType {
    public static PgFloat8 Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgFloat8();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgInt2 : PgType {
    public static PgInt2 Default;
    [CompilerGeneratedAttribute]
private int <TypeModifier>k__BackingField;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgInt2();
    public virtual int get_Oid();
    public virtual short get_Size();
    [CompilerGeneratedAttribute]
public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgInt4 : PgType {
    public static PgInt4 Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgInt4();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgInt8 : PgType {
    public static PgInt8 Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgInt8();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgInterval : PgType {
    public static PgInterval Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgInterval();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
    private static object GetTimeSpan(Byte[] buffer);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgJson : PgType {
    public static PgJson Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgJson();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgName : PgType {
    public static PgName Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgName();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgOid : PgType {
    public static PgOid Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgOid();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgText : PgType {
    public static PgText Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgText();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgTimestamp : PgType {
    public static PgTimestamp Default;
    public static long OffsetTicks;
    public static int TicksMultiplier;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgTimestamp();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
    private static DateTime GetDateTime(long timestamp);
    private static long GetTimestamp(DateTime timestamp);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgTimestampTz : PgType {
    public static PgTimestampTz Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgTimestampTz();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
    private static DateTime GetDateTime(long timestamp);
    private static long GetTimestampTz(DateTimeOffset timestamp);
}
public abstract class Raven.Server.Integrations.PostgreSQL.Types.PgType : object {
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    public abstract virtual int get_Oid();
    public abstract virtual short get_Size();
    public abstract virtual int get_TypeModifier();
    public abstract virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public abstract virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public abstract virtual object FromString(string value);
    public static PgType Parse(int dataType);
    public static PgType Parse(string dataType);
    protected Byte[] Utf8GetBytes(object value);
    protected string Utf8GetString(Byte[] buffer);
}
public static class Raven.Server.Integrations.PostgreSQL.Types.PgTypeOIDs : object {
    public static int Int8;
    public static int Float8;
    public static int Int4;
    public static int Numeric;
    public static int Float4;
    public static int Int2;
    public static int Money;
    public static int Bool;
    public static int Box;
    public static int Circle;
    public static int Line;
    public static int LSeg;
    public static int Path;
    public static int Point;
    public static int Polygon;
    public static int BPChar;
    public static int Text;
    public static int Varchar;
    public static int Name;
    public static int Char;
    public static int Bytea;
    public static int Date;
    public static int Time;
    public static int Timestamp;
    public static int TimestampTz;
    public static int Interval;
    public static int TimeTz;
    public static int Inet;
    public static int Cidr;
    public static int Macaddr;
    public static int Macaddr8;
    public static int Bit;
    public static int Varbit;
    public static int TsVector;
    public static int TsQuery;
    public static int Regconfig;
    public static int Uuid;
    public static int Xml;
    public static int Json;
    public static int Jsonb;
    public static int JsonPath;
    public static int Refcursor;
    public static int Oidvector;
    public static int Int2vector;
    public static int Oid;
    public static int Xid;
    public static int Cid;
    public static int Regtype;
    public static int Tid;
    public static int Unknown;
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgUnknown : PgType {
    public static PgUnknown Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgUnknown();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
public class Raven.Server.Integrations.PostgreSQL.Types.PgVarchar : PgType {
    public static PgVarchar Default;
    public int Oid { get; }
    public short Size { get; }
    public int TypeModifier { get; }
    private static PgVarchar();
    public virtual int get_Oid();
    public virtual short get_Size();
    public virtual int get_TypeModifier();
    public virtual ReadOnlyMemory`1<byte> ToBytes(object value, PgFormat formatCode);
    public virtual object FromBytes(Byte[] buffer, PgFormat formatCode);
    public virtual object FromString(string value);
}
[ExtensionAttribute]
internal static class Raven.Server.Json.BlittableJsonTextWriterExtensions : object {
    internal static StringSegment MetadataKeySegment;
    private static BlittableJsonTextWriterExtensions();
    [ExtensionAttribute]
public static void WritePerformanceStats(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, IEnumerable`1<IndexPerformanceStats> stats);
    [ExtensionAttribute]
public static void WriteSubscriptionTaskPerformanceStats(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, IEnumerable`1<SubscriptionTaskPerformanceStats> stats);
    [ExtensionAttribute]
public static void WriteEtlTaskPerformanceStats(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, IEnumerable`1<EtlTaskPerformanceStats> stats);
    [ExtensionAttribute]
public static void WriteQueueSinkTaskPerformanceStats(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, IEnumerable`1<QueueSinkTaskPerformanceStats> stats);
    [ExtensionAttribute]
public static void WriteEtlTaskProgress(TWriter writer, JsonOperationContext context, IEnumerable`1<EtlTaskProgress> progress);
    [ExtensionAttribute]
public static void WriteExplanation(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, Explanation explanation);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteSuggestionQueryResultAsync>d__6")]
[ExtensionAttribute]
public static Task`1<ValueTuple`2<long, long>> WriteSuggestionQueryResultAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, SuggestionQueryResult result, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteFacetedQueryResultAsync>d__7")]
[ExtensionAttribute]
public static Task`1<long> WriteFacetedQueryResultAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, FacetedQueryResult result, CancellationToken token);
    [ExtensionAttribute]
private static void WriteSpatialPropertyResult(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, SpatialProperty result);
    [ExtensionAttribute]
private static void WriteSpatialShapeResult(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, SpatialShapeBase result);
    [ExtensionAttribute]
private static void WriteSpatialPointResult(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, Coordinates result);
    [ExtensionAttribute]
private static void WritePoint(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, Coordinates result);
    [ExtensionAttribute]
private static void WriteSuggestionResult(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, SuggestionResult result);
    [ExtensionAttribute]
private static void WriteFacetResult(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, FacetResult result);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteIndexEntriesQueryResultAsync>d__14")]
[ExtensionAttribute]
public static Task WriteIndexEntriesQueryResultAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, IndexEntriesQueryResult result, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteDocumentQueryResultAsync>d__15`1")]
[ExtensionAttribute]
public static Task`1<ValueTuple`2<long, long>> WriteDocumentQueryResultAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, QueryResultServerSide`1<T> result, bool metadataOnly, Action`1<AsyncBlittableJsonTextWriter> writeAdditionalData, CancellationToken token);
    [ExtensionAttribute]
public static void WritePutIndexResponse(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, IEnumerable`1<PutIndexResult> createdIndexes);
    [ExtensionAttribute]
public static void WriteIncludedCounterNames(AbstractBlittableJsonTextWriter writer, Dictionary`2<string, String[]> includedCounterNames);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteQueryResultAsync>d__18`2")]
[ExtensionAttribute]
private static Task`1<ValueTuple`2<long, long>> WriteQueryResultAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, QueryResultBase`2<TResult, TInclude> result, bool metadataOnly, bool partial, CancellationToken token);
    [ExtensionAttribute]
private static void WriteQueryTimings(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, QueryTimings queryTimings, bool attachQueryPlan);
    [ExtensionAttribute]
public static void WriteTermsQueryResult(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, TermsQueryResultServerSide queryResult);
    [ExtensionAttribute]
private static void WriteIndexingPerformanceStats(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, IndexingPerformanceStats stats);
    [ExtensionAttribute]
private static void WriteEtlPerformanceStats(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, EtlPerformanceStats stats);
    [ExtensionAttribute]
private static void WriteQueueSinkPerformanceStats(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, QueueSinkPerformanceStats stats);
    [ExtensionAttribute]
public static void WriteSubscriptionBatchPerformanceStats(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, SubscriptionBatchPerformanceStats batchStats);
    [ExtensionAttribute]
public static void WriteSubscriptionConnectionPerformanceStats(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, SubscriptionConnectionPerformanceStats connectionStats);
    [ExtensionAttribute]
public static void WriteIndexQuery(TWriter writer, JsonOperationContext context, IIndexQuery query);
    [ExtensionAttribute]
private static void WriteIndexQuery(TWriter writer, JsonOperationContext context, IndexQueryServerSide query);
    [ExtensionAttribute]
public static void WriteDetailedDatabaseStatistics(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, DetailedDatabaseStatistics statistics);
    [ExtensionAttribute]
public static void WriteEssentialDatabaseStatistics(TWriter writer, JsonOperationContext context, EssentialDatabaseStatistics statistics);
    [ExtensionAttribute]
public static void WriteDatabaseStatistics(TWriter writer, JsonOperationContext context, DatabaseStatistics statistics);
    [ExtensionAttribute]
private static void WriteDatabaseStatisticsInternal(TWriter writer, DatabaseStatistics statistics);
    [ExtensionAttribute]
private static void WriteEssentialDatabaseStatisticsInternal(TWriter writer, AbstractDatabaseStatistics`1<TIndexInformation> statistics);
    [ExtensionAttribute]
public static void WriteIndexDefinition(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, IndexDefinition indexDefinition, Nullable`1<long> indexVersion);
    [ExtensionAttribute]
public static void WriteIndexProgress(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, IndexProgress progress);
    [ExtensionAttribute]
public static void WriteIndexesStats(TWriter writer, JsonOperationContext context, IndexStats[] indexesStats);
    [ExtensionAttribute]
public static void WriteIndexErrorCounts(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, IEnumerable`1<IndexErrorsCount> indexErrorCounts);
    [ExtensionAttribute]
public static void WriteIndexErrors(TWriter writer, JsonOperationContext context, IEnumerable`1<IndexErrors> indexErrors);
    [ExtensionAttribute]
private static void WriteIndexFieldOptions(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, IndexFieldOptions options, bool removeAnalyzers);
    [ExtensionAttribute]
public static Task`1<ValueTuple`2<long, long>> WriteDocumentsAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, IEnumerable`1<Document> documents, bool metadataOnly, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteDocumentsAsync>d__40")]
[ExtensionAttribute]
public static Task`1<ValueTuple`2<long, long>> WriteDocumentsAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, IEnumerator`1<Document> documents, bool metadataOnly, CancellationToken token);
    [ExtensionAttribute]
public static void WriteContinuationToken(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, ContinuationToken continuation);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteDocumentsAsync>d__42")]
[ExtensionAttribute]
public static Task`1<ValueTuple`2<long, long>> WriteDocumentsAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, IAsyncEnumerable`1<Document> documents, bool metadataOnly, CancellationToken token);
    [ExtensionAttribute]
public static void WriteDocument(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, Document document, bool metadataOnly, Func`2<LazyStringValue, bool> filterMetadataProperty);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteIncludesAsync>d__44")]
[ExtensionAttribute]
public static ValueTask`1<ValueTuple`2<long, long>> WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, IEnumerable`1<Document> includes, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteIncludesAsync>d__45")]
[ExtensionAttribute]
public static ValueTask`1<ValueTuple`2<long, long>> WriteIncludesAsync(AsyncBlittableJsonTextWriter writer, IEnumerable`1<BlittableJsonReaderObject> includes, CancellationToken token);
    private static void WriteConflict(AbstractBlittableJsonTextWriter writer, ConflictDocument conflict);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteObjectsAsync>d__47")]
[ExtensionAttribute]
public static Task`1<ValueTuple`2<long, long>> WriteObjectsAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, IEnumerable`1<BlittableJsonReaderObject> objects, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteObjectsAsync>d__48")]
[ExtensionAttribute]
public static Task`1<ValueTuple`2<long, long>> WriteObjectsAsync(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, IAsyncEnumerable`1<BlittableJsonReaderObject> objects, CancellationToken token);
    [ExtensionAttribute]
public static void WriteCounters(AbstractBlittableJsonTextWriter writer, Dictionary`2<string, List`1<CounterDetail>> counters);
    [ExtensionAttribute]
private static void WriteCountersForDocument(AbstractBlittableJsonTextWriter writer, List`1<CounterDetail> counters);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteCountersForDocumentAsync>d__51")]
[ExtensionAttribute]
public static Task WriteCountersForDocumentAsync(AsyncBlittableJsonTextWriter writer, List`1<CounterDetail> counters, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Json.BlittableJsonTextWriterExtensions/<WriteCompareExchangeValuesAsync>d__52")]
[ExtensionAttribute]
public static Task WriteCompareExchangeValuesAsync(AsyncBlittableJsonTextWriter writer, Dictionary`2<string, CompareExchangeValue`1<BlittableJsonReaderObject>> compareExchangeValues, CancellationToken token);
    [ExtensionAttribute]
private static void WriteDocumentMetadata(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, Document document, Func`2<LazyStringValue, bool> filterMetadataProperty);
    [ExtensionAttribute]
public static void WriteMetadata(AbstractBlittableJsonTextWriter writer, Document document, BlittableJsonReaderObject metadata, Func`2<LazyStringValue, bool> filterMetadataProperty);
    [ExtensionAttribute]
private static void WriteDocumentInternal(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, Document document, Func`2<LazyStringValue, bool> filterMetadataProperty);
    [ExtensionAttribute]
private static void WriteDocumentProperties(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, Document document, Func`2<LazyStringValue, bool> filterMetadataProperty);
    [ExtensionAttribute]
public static void WriteDocumentPropertiesWithoutMetadata(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, Document document);
    [ExtensionAttribute]
public static void WriteOperationIdAndNodeTag(AbstractBlittableJsonTextWriter writer, JsonOperationContext context, long operationId, string nodeTag);
    [ExtensionAttribute]
public static void WriteArrayOfResultsAndCount(AbstractBlittableJsonTextWriter writer, IEnumerable`1<string> results);
    [ExtensionAttribute]
public static void WriteReduceTrees(AbstractBlittableJsonTextWriter writer, IEnumerable`1<ReduceTree> trees);
    [ExtensionAttribute]
private static void WriteTreePagesRecursively(AbstractBlittableJsonTextWriter writer, IEnumerable`1<ReduceTreePage> pages);
    public static DynamicJsonValue GetOrCreateMetadata(DynamicJsonValue result);
    public static void MergeMetadata(DynamicJsonValue result, DynamicJsonValue metadata);
    [ExtensionAttribute]
public static void WriteNextOperationIdAndNodeTag(AbstractBlittableJsonTextWriter writer, long operationId, string nodeTag);
    [CompilerGeneratedAttribute]
internal static void <WriteEssentialDatabaseStatisticsInternal>g__WriteIndexInformation|32_0(TWriter w, IndexInformation index);
    [CompilerGeneratedAttribute]
internal static void <WriteEssentialDatabaseStatisticsInternal>g__WriteBasicIndexInformation|32_1(TWriter w, EssentialIndexInformation index);
    [CompilerGeneratedAttribute]
internal static void <WriteEssentialDatabaseStatisticsInternal>g__WriteBasicIndexInformationInternal|32_2(TWriter w, TIndexInformation index);
}
public class Raven.Server.Json.BlittableJsonTraverser : object {
    public static BlittableJsonTraverser Default;
    public static Char[] DefaultFlatMapReduceSeparators;
    public static BlittableJsonTraverser FlatMapReduceResults;
    private static char PropertySeparator;
    private static char CollectionSeparatorStartBracket;
    private static char CollectionSeparatorEndBracket;
    private static string ValuesProperty;
    public static Char[] CollectionAndPropertySeparators;
    public static Char[] PropertySeparators;
    private Char[] _separators;
    public bool SupportTimeOnlyDateOnly;
    private BlittableJsonTraverser(Char[] nonDefaultSeparators, bool supportTimeOnlyDateOnly);
    private static BlittableJsonTraverser();
    internal static BlittableJsonTraverser CreateInstanceForIndexing(Char[] nonDefaultSeparators, bool supportTimeOnlyDateOnly);
    public object Read(BlittableJsonReaderObject docReader, StringSegment path);
    public bool TryRead(BlittableJsonReaderObject docReader, StringSegment path, Object& result, StringSegment& leftPath);
    private CollectionSeparatorType GetCollectionSeparatorType(StringSegment path, int propertySegmentLength);
    private StringSegment GetNextToken(StringSegment path, Int32& consumed);
    private bool ReadNestedObjects(BlittableJsonReaderObject nested, StringSegment path, Object& result, StringSegment& leftPath);
    [IteratorStateMachineAttribute("Raven.Server.Json.BlittableJsonTraverser/<ReadArray>d__19")]
private IEnumerable`1<object> ReadArray(BlittableJsonReaderArray array, StringSegment pathSegment);
    [CompilerGeneratedAttribute]
internal static int <GetNextToken>g__SkipQuote|17_0(char ch, int i, <>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
internal static void <ReadNestedObjects>g__AddItemToResults|18_0(object i, <>c__DisplayClass18_0& );
}
public static class Raven.Server.Json.BlittableJsonTraverserHelper : object {
    private static string LastModifiedPath;
    public static bool TryRead(BlittableJsonTraverser blittableJsonTraverser, Document document, StringSegment path, Object& value);
    public static bool TryRead(BlittableJsonTraverser blittableJsonTraverser, BlittableJsonReaderObject document, StringSegment path, Object& value);
    public static bool TryReadComputedProperties(BlittableJsonTraverser blittableJsonTraverser, StringSegment leftPath, Object& value);
    [IteratorStateMachineAttribute("Raven.Server.Json.BlittableJsonTraverserHelper/<ReadNestedComputed>d__4")]
private static IEnumerable`1<object> ReadNestedComputed(BlittableJsonTraverser blittableJsonTraverser, IEnumerable items, StringSegment leftPath);
}
public static class Raven.Server.Json.BlittableNumber : object {
    public static NumberParseResult Parse(object value, Double& doubleResult, Int64& longResult);
}
internal class Raven.Server.Json.Converters.BlittableJsonConverter : RavenTypeJsonConverter`1<BlittableJsonReaderObject> {
    public static BlittableJsonConverter Instance;
    private static BlittableJsonConverter();
    protected virtual void WriteJson(BlittableJsonWriter writer, BlittableJsonReaderObject value, JsonSerializer serializer);
    internal virtual BlittableJsonReaderObject ReadJson(BlittableJsonReader blittableReader);
}
internal class Raven.Server.Json.Converters.BlittableJsonReaderArrayConverter : RavenTypeJsonConverter`1<BlittableJsonReaderArray> {
    public static BlittableJsonReaderArrayConverter Instance;
    private static BlittableJsonReaderArrayConverter();
    protected virtual void WriteJson(BlittableJsonWriter writer, BlittableJsonReaderArray value, JsonSerializer serializer);
    internal virtual BlittableJsonReaderArray ReadJson(BlittableJsonReader blittableReader);
}
internal class Raven.Server.Json.Converters.CounterOperationConverter : RavenTypeJsonConverter`1<CounterOperation> {
    public static CounterOperationConverter Instance;
    private static CounterOperationConverter();
    protected virtual void WriteJson(BlittableJsonWriter writer, CounterOperation value, JsonSerializer serializer);
    internal virtual CounterOperation ReadJson(BlittableJsonReader blittableReader);
}
internal class Raven.Server.Json.Converters.LazyStringValueJsonConverter : RavenTypeJsonConverter`1<LazyStringValue> {
    public static LazyStringValueJsonConverter Instance;
    private static LazyStringValueJsonConverter();
    protected virtual void WriteJson(BlittableJsonWriter writer, LazyStringValue value, JsonSerializer serializer);
    internal virtual LazyStringValue ReadJson(BlittableJsonReader reader);
}
internal abstract class Raven.Server.Json.Converters.RavenTypeJsonConverter`1 : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    protected abstract virtual void WriteJson(BlittableJsonWriter writer, T value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    internal abstract virtual T ReadJson(BlittableJsonReader blittableReader);
    public virtual bool CanConvert(Type objectType);
}
internal class Raven.Server.Json.Converters.SliceJsonConverter : RavenTypeJsonConverter`1<Slice> {
    public static SliceJsonConverter Instance;
    private static SliceJsonConverter();
    protected virtual void WriteJson(BlittableJsonWriter writer, Slice value, JsonSerializer serializer);
    internal virtual Slice ReadJson(BlittableJsonReader reader);
}
internal class Raven.Server.Json.Converters.StreamConverter : RavenTypeJsonConverter`1<Stream> {
    public static StreamConverter Instance;
    private static StreamConverter();
    protected virtual void WriteJson(BlittableJsonWriter writer, Stream value, JsonSerializer serializer);
    internal virtual Stream ReadJson(BlittableJsonReader blittableReader);
}
internal class Raven.Server.Json.JsonDeserializationServer : JsonDeserializationBase {
    public static Func`2<BlittableJsonReaderObject, Parameters> StartTransactionsRecordingOperationParameters;
    public static Func`2<BlittableJsonReaderObject, NodeDebugInfoRequestHeader> NodeDebugInfoRequestHeader;
    public static Func`2<BlittableJsonReaderObject, DatabaseStatusReport> DatabaseStatusReport;
    public static Func`2<BlittableJsonReaderObject, MaintenanceReport> MaintenanceReport;
    public static Func`2<BlittableJsonReaderObject, DatabaseSmugglerOptionsServerSide> DatabaseSmugglerOptions;
    public static Func`2<BlittableJsonReaderObject, ReplicationMessageReply> ReplicationMessageReply;
    public static Func`2<BlittableJsonReaderObject, TcpConnectionHeaderResponse> TcpConnectionHeaderResponse;
    public static Func`2<BlittableJsonReaderObject, ReplicationLatestEtagRequest> ReplicationLatestEtagRequest;
    public static Func`2<BlittableJsonReaderObject, ReplicationInitialRequest> ReplicationInitialRequest;
    public static Func`2<BlittableJsonReaderObject, ReplicationActiveConnectionsPreview> ReplicationActiveConnectionsPreview;
    public static Func`2<BlittableJsonReaderObject, ReplicationOutgoingReconnectionQueuePreview> ReplicationOutgoingReconnectionQueuePreview;
    public static Func`2<BlittableJsonReaderObject, ReplicationOutgoingsFailurePreview> ReplicationOutgoingsFailurePreview;
    public static Func`2<BlittableJsonReaderObject, ReplicationIncomingLastActivityTimePreview> ReplicationIncomingLastActivityTimePreview;
    public static Func`2<BlittableJsonReaderObject, ReplicationIncomingRejectionInfoPreview> ReplicationIncomingRejectionInfoPreview;
    public static Func`2<BlittableJsonReaderObject, IncomingConnectionInfo> ReplicationIncomingConnectionInfo;
    public static Func`2<BlittableJsonReaderObject, SubscriptionConnectionClientMessage> SubscriptionConnectionClientMessage;
    public static Func`2<BlittableJsonReaderObject, SubscriptionWorkerOptions> SubscriptionConnectionOptions;
    public static Func`2<BlittableJsonReaderObject, SubscriptionBatchesState> SubscriptionBatchesState;
    public static Func`2<BlittableJsonReaderObject, ConflictSolver> ConflictSolver;
    public static Func`2<BlittableJsonReaderObject, MergeResult> ConflictSolverMergeResult;
    public static Func`2<BlittableJsonReaderObject, ScriptResolver> ScriptResolver;
    public static Func`2<BlittableJsonReaderObject, TestSqlEtlScript> TestSqlEtlScript;
    public static Func`2<BlittableJsonReaderObject, TestRavenEtlScript> TestRavenEtlScript;
    public static Func`2<BlittableJsonReaderObject, TestOlapEtlScript> TestOlapEtlScript;
    public static Func`2<BlittableJsonReaderObject, TestElasticSearchEtlScript> TestElasticSearchEtlScript;
    public static Func`2<BlittableJsonReaderObject, TestQueueEtlScript> TestQueueEtlScript;
    public static Func`2<BlittableJsonReaderObject, TestQueueSinkScript> TestQueueSinkScript;
    public static Func`2<BlittableJsonReaderObject, SubscriptionCreationOptions> SubscriptionCreationParams;
    public static Func`2<BlittableJsonReaderObject, SubscriptionUpdateOptions> SubscriptionUpdateOptions;
    public static Func`2<BlittableJsonReaderObject, SubscriptionTryout> SubscriptionTryout;
    public static Func`2<BlittableJsonReaderObject, RevisionsConfiguration> RevisionsConfiguration;
    public static Func`2<BlittableJsonReaderObject, RevisionsCollectionConfiguration> RevisionsCollectionConfiguration;
    public static Func`2<BlittableJsonReaderObject, ExpirationConfiguration> ExpirationConfiguration;
    public static Func`2<BlittableJsonReaderObject, TimeSeriesConfiguration> TimeSeriesConfiguration;
    public static Func`2<BlittableJsonReaderObject, DocumentsCompressionConfiguration> DocumentsCompressionConfiguration;
    public static Func`2<BlittableJsonReaderObject, IndexDefinition> IndexDefinition;
    public static Func`2<BlittableJsonReaderObject, TimeSeriesIndexDefinition> TimeSeriesIndexDefinition;
    public static Func`2<BlittableJsonReaderObject, SegmentsSummary> SegmentsSummary;
    public static Func`2<BlittableJsonReaderObject, SorterDefinition> SorterDefinition;
    public static Func`2<BlittableJsonReaderObject, PostgreSqlUser> PostgreSqlUser;
    public static Func`2<BlittableJsonReaderObject, AnalyzerDefinition> AnalyzerDefinition;
    public static Func`2<BlittableJsonReaderObject, AutoIndexDefinition> AutoIndexDefinition;
    internal static Func`2<BlittableJsonReaderObject, LegacyIndexDefinition> LegacyIndexDefinition;
    public static Func`2<BlittableJsonReaderObject, FacetSetup> FacetSetup;
    public static Func`2<BlittableJsonReaderObject, VersionInfo> LatestVersionCheckVersionInfo;
    public static Func`2<BlittableJsonReaderObject, License> License;
    public static Func`2<BlittableJsonReaderObject, SetupSettings> SetupSettings;
    public static Func`2<BlittableJsonReaderObject, LicenseInfo> LicenseInfo;
    public static Func`2<BlittableJsonReaderObject, LicenseLimits> LicenseLimits;
    public static Func`2<BlittableJsonReaderObject, LeasedLicense> LeasedLicense;
    public static Func`2<BlittableJsonReaderObject, RevertRevisionsRequest> RevertRevisions;
    public static Func`2<BlittableJsonReaderObject, RevertDocumentsToRevisionsRequest> RevertDocumentToRevision;
    public static Func`2<BlittableJsonReaderObject, LicenseSupportInfo> LicenseSupportInfo;
    public static Func`2<BlittableJsonReaderObject, UserRegistrationInfo> UserRegistrationInfo;
    public static Func`2<BlittableJsonReaderObject, FeedbackForm> FeedbackForm;
    public static Func`2<BlittableJsonReaderObject, CertificateDefinition> CertificateDefinition;
    public static Func`2<BlittableJsonReaderObject, UserDomainsWithIps> UserDomainsWithIps;
    public static Func`2<BlittableJsonReaderObject, SetupInfo> SetupInfo;
    public static Func`2<BlittableJsonReaderObject, ContinueSetupInfo> ContinueSetupInfo;
    public static Func`2<BlittableJsonReaderObject, UnsecuredSetupInfo> UnsecuredSetupInfo;
    public static Func`2<BlittableJsonReaderObject, SourceSqlDatabase> SourceSqlDatabase;
    public static Func`2<BlittableJsonReaderObject, RestoreSettings> RestoreSettings;
    public static Func`2<BlittableJsonReaderObject, CompactSettings> CompactSettings;
    public static Func`2<BlittableJsonReaderObject, ClientConfiguration> ClientConfiguration;
    public static Func`2<BlittableJsonReaderObject, StudioConfiguration> StudioConfiguration;
    internal static Func`2<BlittableJsonReaderObject, FooterStatistics> FooterStatistics;
    public static Func`2<BlittableJsonReaderObject, ServerWideStudioConfiguration> ServerWideStudioConfiguration;
    public static Func`2<BlittableJsonReaderObject, IndexQueryServerSide> IndexQuery;
    public static Func`2<BlittableJsonReaderObject, SingleDatabaseMigrationConfiguration> SingleDatabaseMigrationConfiguration;
    public static Func`2<BlittableJsonReaderObject, DatabasesMigrationConfiguration> DatabasesMigrationConfiguration;
    public static Func`2<BlittableJsonReaderObject, OfflineMigrationConfiguration> OfflineMigrationConfiguration;
    public static Func`2<BlittableJsonReaderObject, MigrationConfiguration> MigrationConfiguration;
    public static Func`2<BlittableJsonReaderObject, LastEtagsInfo> OperationState;
    public static Func`2<BlittableJsonReaderObject, ImportInfo> ImportInfo;
    public static Func`2<BlittableJsonReaderObject, MoreLikeThisOptions> MoreLikeThisOptions;
    public static Func`2<BlittableJsonReaderObject, FacetOptions> FacetOptions;
    public static Func`2<BlittableJsonReaderObject, ExtendedDatabaseInfo> DatabaseInfo;
    public static Func`2<BlittableJsonReaderObject, ClusterTopologyChanged> ClusterTopologyChanged;
    public static Func`2<BlittableJsonReaderObject, ClusterTransactionDataCommand> ClusterTransactionDataCommand;
    public static Func`2<BlittableJsonReaderObject, ClusterTransactionOptions> ClusterTransactionOptions;
    public static Func`2<BlittableJsonReaderObject, NodeConnectionTestResult> NodeConnectionTestResult;
    public static Func`2<BlittableJsonReaderObject, SingleNodeDataDirectoryResult> SingleNodeDataDirectoryResult;
    public static Func`2<BlittableJsonReaderObject, CpuCredits> CpuCredits;
    public static Func`2<BlittableJsonReaderObject, CpuCreditsResponse> CpuCreditsResponse;
    public static Func`2<BlittableJsonReaderObject, LocalSettings> LocalSettings;
    public static Func`2<BlittableJsonReaderObject, S3Settings> S3Settings;
    public static Func`2<BlittableJsonReaderObject, GlacierSettings> GlacierSettings;
    public static Func`2<BlittableJsonReaderObject, AzureSettings> AzureSettings;
    public static Func`2<BlittableJsonReaderObject, GoogleCloudSettings> GoogleCloudSettings;
    public static Func`2<BlittableJsonReaderObject, FtpSettings> FtpSettings;
    public static Func`2<BlittableJsonReaderObject, ServerStatistics> ServerStatistics;
    public static Func`2<BlittableJsonReaderObject, CsvImportOptions> CsvImportOptions;
    public static Func`2<BlittableJsonReaderObject, BuildNumber> BuildNumber;
    public static Func`2<BlittableJsonReaderObject, LegacySourceReplicationInformation> LegacySourceReplicationInformation;
    public static Func`2<BlittableJsonReaderObject, BackupConfiguration> BackupConfiguration;
    public static Func`2<BlittableJsonReaderObject, PeriodicBackupConfiguration> GetPeriodicBackupConfiguration;
    public static Func`2<BlittableJsonReaderObject, TestIndexParameters> TestIndexParameters;
    internal static Func`2<BlittableJsonReaderObject, AutoSpatialOptions> AutoSpatialOptions;
    public static Func`2<BlittableJsonReaderObject, BlockingTombstoneDetails> BlockingTombstoneDetails;
    public static Func`2<BlittableJsonReaderObject, WaitForIndexNotificationRequest> WaitForIndexNotificationRequest;
    public static Func`2<BlittableJsonReaderObject, IndexErrorsCount> IndexErrorsCount;
    public static Func`2<BlittableJsonReaderObject, LastChangeVectorForCollectionResult> LastChangeVectorForCollectionResult;
    public static Func`2<BlittableJsonReaderObject, ResolvedRevisions> ResolvedRevisions;
    public static Func`2<BlittableJsonReaderObject, GetConflictsPreviewResult> GetConflictResults;
    public static Func`2<BlittableJsonReaderObject, TermsQueryResultServerSide> TermsQueryResult;
    internal static Func`2<BlittableJsonReaderObject, EtlTaskProgressResponse> EtlTaskProgressResponse;
    internal static Func`2<BlittableJsonReaderObject, PeriodicBackupTimersResponse> GetPeriodicBackupTimersCommandResponse;
    internal static Func`2<BlittableJsonReaderObject, NotificationCenterDatabaseStats> NotificationCenterDatabaseStats;
    internal static Func`2<BlittableJsonReaderObject, DatabasesInfo> DatabasesInfo;
    internal static Func`2<BlittableJsonReaderObject, StudioDatabasesState> StudioDatabasesState;
    internal static Func`2<BlittableJsonReaderObject, BucketsResults> BucketsResults;
    internal static Func`2<BlittableJsonReaderObject, BucketInfo> BucketInfo;
    internal static Func`2<BlittableJsonReaderObject, Response> CleanupTombstonesResponse;
    internal static Func`2<BlittableJsonReaderObject, Response> GetTombstonesStateResponse;
    internal static Func`2<BlittableJsonReaderObject, SubscriptionConnectionsDetails> SubscriptionConnectionsDetails;
    internal static Func`2<BlittableJsonReaderObject, UpgradeInfoResponse> UpgradeInfoResponse;
    internal static Func`2<BlittableJsonReaderObject, EventListenerConfiguration> EventListenerConfiguration;
    private static JsonDeserializationServer();
}
public static class Raven.Server.Json.JsonDeserializationValidator : object {
    [ConditionalAttribute("DEBUG")]
public static void Validate();
}
public class Raven.Server.Json.LazyStringReader : object {
    internal static int MinLengthForLazyStringStreamReader;
    private MmapStream _mmapStream;
    private LazyStringStreamReader _reader;
    public TextReader GetTextReaderFor(LazyStringValue value);
    public TextReader GetTextReader(Byte* buffer, int len);
    public static string GetStringFor(LazyStringValue value);
    public sealed virtual void Dispose();
}
public enum Raven.Server.Json.NumberParseResult : Enum {
    public int value__;
    public static NumberParseResult Double;
    public static NumberParseResult Long;
}
[ExtensionAttribute]
internal static class Raven.Server.Json.Sync.BlittableJsonTextWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteIndexDefinition(BlittableJsonTextWriter writer, JsonOperationContext context, IndexDefinition indexDefinition, bool removeAnalyzers);
    [ExtensionAttribute]
private static void WriteIndexFieldOptions(BlittableJsonTextWriter writer, JsonOperationContext context, IndexFieldOptions options, bool removeAnalyzers);
    [ExtensionAttribute]
public static void WriteDocument(BlittableJsonTextWriter writer, JsonOperationContext context, Document document, bool metadataOnly, Func`2<LazyStringValue, bool> filterMetadataProperty);
    [ExtensionAttribute]
internal static void WriteDocumentInternal(BlittableJsonTextWriter writer, JsonOperationContext context, Document document, Func`2<LazyStringValue, bool> filterMetadataProperty);
    [ExtensionAttribute]
private static void WriteDocumentProperties(BlittableJsonTextWriter writer, JsonOperationContext context, Document document, Func`2<LazyStringValue, bool> filterMetadataProperty);
    [ExtensionAttribute]
private static void WriteDocumentMetadata(BlittableJsonTextWriter writer, JsonOperationContext context, Document document, Func`2<LazyStringValue, bool> filterMetadataProperty);
    private static void WriteMetadata(BlittableJsonTextWriter writer, Document document, BlittableJsonReaderObject metadata, Func`2<LazyStringValue, bool> filterMetadataProperty);
}
public static class Raven.Server.Json.TableValueReaderUtil : object {
    public static ReleaseMemory CloneTableValueReader(DocumentsOperationContext context, TableValueHolder read);
}
public class Raven.Server.Monitoring.MetricsProvider : object {
    private RavenServer _server;
    private ServerStore _serverStore;
    public MetricsProvider(RavenServer server);
    public ServerMetrics CollectServerMetrics();
    private ConfigurationMetrics GetConfigMetrics();
    private BackupMetrics GetBackupMetrics();
    private NetworkMetrics GetNetworkMetrics();
    private CpuMetrics GetCpuMetrics();
    private MemoryMetrics GetMemoryMetrics();
    private LicenseMetrics GetLicenseMetrics();
    private DiskMetrics GetDiskMetrics();
    private CertificateMetrics GetCertificateMetrics();
    private ClusterMetrics GetClusterMetrics();
    private AllDatabasesMetrics GetAllDatabasesMetrics();
    public DatabaseMetrics CollectDatabaseMetrics(DocumentDatabase database);
    private DatabaseCounts GetDatabaseCounts(DocumentDatabase database);
    private DatabaseIndexesMetrics GetDatabaseIndexesMetrics(DocumentDatabase database);
    private DatabaseStorageMetrics GetDatabaseStorageMetrics(DocumentDatabase database);
    private DatabaseStatistics GetDatabaseStatistics(DocumentDatabase database);
    public IndexMetrics CollectIndexMetrics(Index index);
}
public static class Raven.Server.Monitoring.OpenTelemetry.Constants : object {
}
public interface Raven.Server.Monitoring.OpenTelemetry.IMetricInstrument`1 {
    public abstract virtual TInstrumentValue GetCurrentMeasurement();
}
public interface Raven.Server.Monitoring.OpenTelemetry.ITaggedMetricInstrument`1 {
}
public abstract class Raven.Server.Monitoring.OpenTelemetry.MetricsBase : object {
    private static FrozenDictionary`2<string, string> DescriptionMapping;
    protected OpenTelemetryConfiguration Configuration;
    protected MetricsBase(OpenTelemetryConfiguration configuration);
    private static MetricsBase();
    [UnsafeAccessorAttribute("1")]
private static ObjectIdentifier GetOidFromObservableValue(ScalarObject oids);
    protected void CreateObservableGaugeWithTags(string name, Func`1<TObservable> observeValueFactory, Lazy`1<Meter> meter, string overridenDescription);
    protected void CreateObservableGauge(string name, Func`1<TObservable> observeValueFactory, Lazy`1<Meter> meter);
    protected void CreateObservableUpDownCounter(string name, Func`1<TObservable> observeValueFactory, Lazy`1<Meter> meter);
    private static string GetDescription(T value);
    [ConditionalAttribute("DEBUG")]
private static void RegisterInstrumentForDocumentation(string name, ScalarObject scalarObject, InstrumentType instrumentType, string overridenDescription);
}
public class Raven.Server.Monitoring.OpenTelemetry.MetricsManager : object {
    private RavenServer _server;
    private SemaphoreSlim _locker;
    private ServerMetrics _serverMetrics;
    private bool _metricsActivated;
    public MetricsManager(RavenServer server);
    private void OnLicenseChanged();
    public void Execute();
    private void RegisterServerMeters();
}
public class Raven.Server.Monitoring.OpenTelemetry.ServerMetrics : MetricsBase {
    private static Lazy`1<Meter> GeneralMeter;
    private static Lazy`1<Meter> RequestsMeter;
    private static Lazy`1<Meter> StorageMeter;
    private static Lazy`1<Meter> GcMeter;
    private static Lazy`1<Meter> ResourcesMeter;
    private static Lazy`1<Meter> TotalDatabasesMeter;
    private static Lazy`1<Meter> CpuCreditsMeter;
    private RavenServer _server;
    private ServerStore ServerStore { get; }
    public ServerMetrics(RavenServer server);
    private static ServerMetrics();
    private ServerStore get_ServerStore();
    private void RegisterGeneralMeter();
    private void RegisterRequestsInstruments();
    private void RegisterCpuCreditsInstruments();
    private void RegisterServerHardwareInstruments();
    private void RegisterTotalDatabaseInstruments();
    private void RegisterStorageInstruments();
    private void RegisterGc(GCKind gcKind);
    [CompilerGeneratedAttribute]
private ClusterNodeState <RegisterGeneralMeter>b__11_0();
    [CompilerGeneratedAttribute]
private ClusterTerm <RegisterGeneralMeter>b__11_1();
    [CompilerGeneratedAttribute]
private ClusterIndex <RegisterGeneralMeter>b__11_2();
    [CompilerGeneratedAttribute]
private ServerCertificateExpirationLeft <RegisterGeneralMeter>b__11_3();
    [CompilerGeneratedAttribute]
private ServerLicenseType <RegisterGeneralMeter>b__11_4();
    [CompilerGeneratedAttribute]
private ServerLicenseExpirationLeft <RegisterGeneralMeter>b__11_5();
    [CompilerGeneratedAttribute]
private ServerLicenseUtilizedCpuCores <RegisterGeneralMeter>b__11_6();
    [CompilerGeneratedAttribute]
private ServerLicenseMaxCpuCores <RegisterGeneralMeter>b__11_7();
    [CompilerGeneratedAttribute]
private CpuCreditsBase <RegisterCpuCreditsInstruments>b__13_0();
    [CompilerGeneratedAttribute]
private CpuCreditsMax <RegisterCpuCreditsInstruments>b__13_1();
    [CompilerGeneratedAttribute]
private CpuCreditsRemaining <RegisterCpuCreditsInstruments>b__13_2();
    [CompilerGeneratedAttribute]
private CpuCreditsCurrentConsumption <RegisterCpuCreditsInstruments>b__13_3();
    [CompilerGeneratedAttribute]
private CpuCreditsBackgroundTasksAlertRaised <RegisterCpuCreditsInstruments>b__13_4();
    [CompilerGeneratedAttribute]
private CpuCreditsFailoverAlertRaised <RegisterCpuCreditsInstruments>b__13_5();
    [CompilerGeneratedAttribute]
private CpuCreditsAlertRaised <RegisterCpuCreditsInstruments>b__13_6();
    [CompilerGeneratedAttribute]
private ProcessCpu <RegisterServerHardwareInstruments>b__14_0();
    [CompilerGeneratedAttribute]
private MachineCpu <RegisterServerHardwareInstruments>b__14_1();
    [CompilerGeneratedAttribute]
private IoWait <RegisterServerHardwareInstruments>b__14_2();
    [CompilerGeneratedAttribute]
private ServerTotalMemory <RegisterServerHardwareInstruments>b__14_4();
    [CompilerGeneratedAttribute]
private ServerTotalSwapSize <RegisterServerHardwareInstruments>b__14_5();
    [CompilerGeneratedAttribute]
private ServerTotalSwapUsage <RegisterServerHardwareInstruments>b__14_6();
    [CompilerGeneratedAttribute]
private ServerWorkingSetSwapUsage <RegisterServerHardwareInstruments>b__14_8();
    [CompilerGeneratedAttribute]
private ServerAvailableMemoryForProcessing <RegisterServerHardwareInstruments>b__14_13();
    [CompilerGeneratedAttribute]
private DatabaseLoadedCount <RegisterTotalDatabaseInstruments>b__15_0();
    [CompilerGeneratedAttribute]
private DatabaseTotalCount <RegisterTotalDatabaseInstruments>b__15_1();
    [CompilerGeneratedAttribute]
private DatabaseDisabledCount <RegisterTotalDatabaseInstruments>b__15_2();
    [CompilerGeneratedAttribute]
private DatabaseEncryptedCount <RegisterTotalDatabaseInstruments>b__15_3();
    [CompilerGeneratedAttribute]
private DatabaseFaultedCount <RegisterTotalDatabaseInstruments>b__15_4();
    [CompilerGeneratedAttribute]
private DatabaseNodeCount <RegisterTotalDatabaseInstruments>b__15_5();
    [CompilerGeneratedAttribute]
private TotalDatabaseNumberOfIndexes <RegisterTotalDatabaseInstruments>b__15_6();
    [CompilerGeneratedAttribute]
private TotalDatabaseCountOfStaleIndexes <RegisterTotalDatabaseInstruments>b__15_7();
    [CompilerGeneratedAttribute]
private TotalDatabaseNumberOfErrorIndexes <RegisterTotalDatabaseInstruments>b__15_8();
    [CompilerGeneratedAttribute]
private TotalDatabaseNumberOfFaultyIndexes <RegisterTotalDatabaseInstruments>b__15_9();
    [CompilerGeneratedAttribute]
private TotalDatabaseNumberOfIndexes <RegisterTotalDatabaseInstruments>b__15_10();
    [CompilerGeneratedAttribute]
private TotalDatabaseMapIndexIndexedPerSecond <RegisterTotalDatabaseInstruments>b__15_11();
    [CompilerGeneratedAttribute]
private TotalDatabaseMapReduceIndexMappedPerSecond <RegisterTotalDatabaseInstruments>b__15_12();
    [CompilerGeneratedAttribute]
private TotalDatabaseMapReduceIndexReducedPerSecond <RegisterTotalDatabaseInstruments>b__15_13();
    [CompilerGeneratedAttribute]
private TotalDatabaseWritesPerSecond <RegisterTotalDatabaseInstruments>b__15_14();
    [CompilerGeneratedAttribute]
private TotalDatabaseDataWrittenPerSecond <RegisterTotalDatabaseInstruments>b__15_15();
    [CompilerGeneratedAttribute]
private ServerStorageUsedSize <RegisterStorageInstruments>b__16_0();
    [CompilerGeneratedAttribute]
private ServerStorageTotalSize <RegisterStorageInstruments>b__16_1();
    [CompilerGeneratedAttribute]
private ServerStorageDiskRemainingSpace <RegisterStorageInstruments>b__16_2();
    [CompilerGeneratedAttribute]
private ServerStorageDiskRemainingSpacePercentage <RegisterStorageInstruments>b__16_3();
    [CompilerGeneratedAttribute]
private ServerStorageDiskIosReadOperations <RegisterStorageInstruments>b__16_4();
    [CompilerGeneratedAttribute]
private ServerStorageDiskIosWriteOperations <RegisterStorageInstruments>b__16_5();
    [CompilerGeneratedAttribute]
private ServerStorageDiskReadThroughput <RegisterStorageInstruments>b__16_6();
    [CompilerGeneratedAttribute]
private ServerStorageDiskWriteThroughput <RegisterStorageInstruments>b__16_7();
    [CompilerGeneratedAttribute]
private ServerStorageDiskQueueLength <RegisterStorageInstruments>b__16_8();
}
public class Raven.Server.Monitoring.ServerLimitsMonitor : object {
    private static string Source;
    private static TimeSpan CheckFrequency;
    private static float MaxMapCountPercentThreshold;
    private static int MaxMapCountNumberThreshold;
    private static float MaxThreadsThreshold;
    private static int MaxThreadsNumberThreshold;
    private ServerStore _serverStore;
    private ServerNotificationCenter _notificationCenter;
    private NotificationsStorage _notificationsStorage;
    private Logger _logger;
    private List`1<ServerLimitInfo> _alerts;
    private object _runLock;
    private Timer _timer;
    public ServerLimitsMonitor(ServerStore serverStore, ServerNotificationCenter notificationCenter, NotificationsStorage notificationsStorage);
    private static ServerLimitsMonitor();
    internal void Run(object state);
    private string GetAlertsString();
    private void AddAlertIfNeeded(long current, long max, float percentThreshold, int numberThreshold, string limit, string name);
    public sealed virtual void Dispose();
}
public class Raven.Server.Monitoring.Snmp.Objects.Cluster.ClusterId : ScalarObjectBase`1<OctetString> {
    private ServerStore _store;
    public ClusterId(ServerStore store);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Cluster.ClusterIndex : ScalarObjectBase`1<Integer32> {
    private ServerStore _store;
    private long Value { get; }
    public ClusterIndex(ServerStore store);
    private long get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Cluster.ClusterNodeState : ScalarObjectBase`1<OctetString> {
    private ServerStore _store;
    public ClusterNodeState(ServerStore store);
    protected virtual OctetString GetData();
    public sealed virtual byte GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Cluster.ClusterNodeTag : ScalarObjectBase`1<OctetString> {
    private ServerStore _store;
    public ClusterNodeTag(ServerStore store);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Cluster.ClusterTerm : ScalarObjectBase`1<Integer32> {
    private ServerStore _store;
    public ClusterTerm(ServerStore store);
    protected virtual Integer32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public abstract class Raven.Server.Monitoring.Snmp.Objects.Database.ActiveOngoingTasksBase : DatabaseBase`1<Integer32> {
    protected ActiveOngoingTasksBase(ServerStore serverStore, string dots);
    [IteratorStateMachineAttribute("Raven.Server.Monitoring.Snmp.Objects.Database.ActiveOngoingTasksBase/<GetDatabases>d__1")]
protected virtual IEnumerable`1<RawDatabaseRecord> GetDatabases(TransactionOperationContext context);
    protected abstract virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    protected virtual Integer32 GetData();
    protected static int GetNumberOfActiveElasticSearchEtls(RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    protected static int GetNumberOfActiveExternalReplications(RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    protected static int GetNumberOfActiveOlapEtls(RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    protected static int GetNumberOfActivePeriodicBackups(RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    protected static int GetNumberOfActiveQueueEtls(RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    protected static int GetNumberOfActiveRavenEtls(RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    protected static int GetNumberOfActiveSinkPullReplications(RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    protected static int GetNumberOfActiveSqlEtls(RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    protected static int GetNumberOfActiveQueueSinks(RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    protected static int GetNumberOfActiveSubscriptions(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
    private static int CountTasks(RachisState rachisState, string nodeTag, DatabaseTopology databaseTopology, IEnumerable`1<IDatabaseTask> tasks);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<RawDatabaseRecord> <>n__0(TransactionOperationContext context);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseAlerts : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseAlerts(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseAverageRequestTime : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseAverageRequestTime(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public abstract class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseBase`1 : ScalarObjectBase`1<TData> {
    protected ServerStore ServerStore;
    protected DatabaseBase`1(ServerStore serverStore, string dots);
    [IteratorStateMachineAttribute("Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseBase`1/<GetDatabases>d__2")]
protected virtual IEnumerable`1<RawDatabaseRecord> GetDatabases(TransactionOperationContext context);
    [IteratorStateMachineAttribute("Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseBase`1/<GetLoadedDatabases>d__3")]
protected IEnumerable`1<DocumentDatabase> GetLoadedDatabases();
    protected static int GetCountSafely(DocumentDatabase database, Func`2<DocumentDatabase, int> getCount);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseCountOfAttachments : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCountOfAttachments(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static long GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseCountOfDocuments : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCountOfDocuments(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static long GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseCountOfIndexes : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCountOfIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseCountOfRevisionDocuments : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCountOfRevisionDocuments(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static long GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseCountOfStaleIndexes : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCountOfStaleIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseCountOfUniqueAttachments : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCountOfUniqueAttachments(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static long GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseDataWrittenPerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseDataWrittenPerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseDisabledCount : DatabaseBase`1<Integer32> {
    public DatabaseDisabledCount(ServerStore serverStore);
    protected virtual Integer32 GetData();
    private int GetCount();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseDocPutsPerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseDocPutsPerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseDocumentsStorageAllocatedSize : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseDocumentsStorageAllocatedSize(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseDocumentsStorageUsedSize : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseDocumentsStorageUsedSize(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseEncryptedCount : DatabaseBase`1<Integer32> {
    public DatabaseEncryptedCount(ServerStore serverStore);
    protected virtual Integer32 GetData();
    private int GetCount();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseFaultedCount : DatabaseBase`1<Integer32> {
    public DatabaseFaultedCount(ServerStore serverStore);
    protected virtual Integer32 GetData();
    private int GetCount();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseId : DatabaseScalarObjectBase`1<OctetString> {
    private OctetString _id;
    public DatabaseId(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexErrors : DatabaseIndexScalarObjectBase`1<Integer32> {
    public DatabaseIndexErrors(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexExists : DatabaseIndexScalarObjectBase`1<OctetString> {
    public ISnmpData Data { get; }
    public DatabaseIndexExists(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    public virtual ISnmpData get_Data();
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexingErrors : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseIndexingErrors(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexIsInvalid : DatabaseIndexScalarObjectBase`1<OctetString> {
    public DatabaseIndexIsInvalid(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexLastIndexingTime : DatabaseIndexScalarObjectBase`1<OctetString> {
    public DatabaseIndexLastIndexingTime(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexLastQueryTime : DatabaseIndexScalarObjectBase`1<OctetString> {
    public DatabaseIndexLastQueryTime(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexLockMode : DatabaseIndexScalarObjectBase`1<OctetString> {
    public DatabaseIndexLockMode(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexMapsPerSec : DatabaseIndexScalarObjectBase`1<Gauge32> {
    public DatabaseIndexMapsPerSec(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexName : DatabaseIndexScalarObjectBase`1<OctetString> {
    private OctetString _name;
    public DatabaseIndexName(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexPriority : DatabaseIndexScalarObjectBase`1<OctetString> {
    public DatabaseIndexPriority(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexReducesPerSec : DatabaseIndexScalarObjectBase`1<Gauge32> {
    public DatabaseIndexReducesPerSec(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexState : DatabaseIndexScalarObjectBase`1<OctetString> {
    public DatabaseIndexState(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexStatus : DatabaseIndexScalarObjectBase`1<OctetString> {
    public DatabaseIndexStatus(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexStorageAllocatedSize : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseIndexStorageAllocatedSize(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexStorageUsedSize : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseIndexStorageUsedSize(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexTimeSinceLastIndexing : DatabaseIndexScalarObjectBase`1<TimeTicks> {
    public DatabaseIndexTimeSinceLastIndexing(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual TimeTicks GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexTimeSinceLastQuery : DatabaseIndexScalarObjectBase`1<TimeTicks> {
    public DatabaseIndexTimeSinceLastQuery(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual TimeTicks GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseIndexType : DatabaseIndexScalarObjectBase`1<OctetString> {
    public DatabaseIndexType(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseLoaded : DatabaseScalarObjectBase`1<OctetString> {
    private string _databaseName;
    public ISnmpData Data { get; }
    public DatabaseLoaded(string databaseName, DatabasesLandlord landlord, int index);
    public virtual ISnmpData get_Data();
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseLoadedCount : ScalarObjectBase`1<Integer32> {
    private DatabasesLandlord _landlord;
    public DatabaseLoadedCount(DatabasesLandlord landlord);
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseMapIndexIndexedPerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseMapIndexIndexedPerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseMapReduceIndexMappedPerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseMapReduceIndexMappedPerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseMapReduceIndexReducedPerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseMapReduceIndexReducedPerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseName : DatabaseScalarObjectBase`1<OctetString> {
    private OctetString _name;
    public DatabaseName(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseNodeCount : DatabaseBase`1<Integer32> {
    public DatabaseNodeCount(ServerStore serverStore);
    protected virtual Integer32 GetData();
    private int GetCount();
    public sealed virtual int GetCurrentMeasurement();
    [CompilerGeneratedAttribute]
private bool <GetCount>b__2_0(RawDatabaseRecord x);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseNumberOfAutoIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfAutoIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseNumberOfDisabledIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfDisabledIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseNumberOfErrorIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfErrorIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
    internal static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseNumberOfFaultyIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfFaultyIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
    internal static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseNumberOfIdleIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfIdleIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseNumberOfIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseNumberOfStaticIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfStaticIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseOldestBackup : ScalarObjectBase`1<TimeTicks> {
    private ServerStore _serverStore;
    public DatabaseOldestBackup(ServerStore serverStore);
    protected virtual TimeTicks GetData();
    private static TimeSpan GetTimeSinceOldestBackup(ServerStore serverStore);
    internal static TimeSpan GetTimeSinceOldestBackupInternal(List`1<string> databaseNames, Func`2<string, Nullable`1<DateTime>> getLastBackup, SystemTime systemTime);
    private static Nullable`1<DateTime> GetLastBackup(ClusterOperationContext context, ServerStore serverStore, string databaseName);
    [CompilerGeneratedAttribute]
internal static DateTime <GetLastBackup>g__LastBackupDate|5_0(Nullable`1<DateTime> fullBackup, Nullable`1<DateTime> incrementalBackup);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabasePerformanceHints : DatabaseScalarObjectBase`1<Integer32> {
    public DatabasePerformanceHints(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseRehabs : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseRehabs(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseRequestsCount : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseRequestsCount(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseRequestsPerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseRequestsPerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseStorageDiskIosReadOperations : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseStorageDiskIosReadOperations(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseStorageDiskIosWriteOperations : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseStorageDiskIosWriteOperations(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseStorageDiskQueueLength : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseStorageDiskQueueLength(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseStorageDiskReadThroughput : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseStorageDiskReadThroughput(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseStorageDiskRemainingSpace : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseStorageDiskRemainingSpace(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseStorageDiskWriteThroughput : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseStorageDiskWriteThroughput(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseTotalCount : DatabaseBase`1<Integer32> {
    public DatabaseTotalCount(ServerStore serverStore);
    protected virtual Integer32 GetData();
    private int GetCount();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseTotalStorageSize : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseTotalStorageSize(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
internal class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseUpTime : DatabaseScalarObjectBase`1<TimeTicks> {
    public DatabaseUpTime(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual TimeTicks GetData(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.DatabaseWritesPerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseWritesPerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public abstract class Raven.Server.Monitoring.Snmp.Objects.Database.OngoingTasksBase : DatabaseBase`1<Integer32> {
    protected OngoingTasksBase(ServerStore serverStore, string dots);
    [IteratorStateMachineAttribute("Raven.Server.Monitoring.Snmp.Objects.Database.OngoingTasksBase/<GetDatabases>d__1")]
protected virtual IEnumerable`1<RawDatabaseRecord> GetDatabases(TransactionOperationContext context);
    protected abstract virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
    protected virtual Integer32 GetData();
    protected internal static int GetNumberOfElasticSearchEtls(RawDatabaseRecord database);
    protected internal static int GetNumberOfExternalReplications(RawDatabaseRecord database);
    protected internal static int GetNumberOfOlapEtls(RawDatabaseRecord database);
    protected internal static int GetNumberOfPeriodicBackups(RawDatabaseRecord database);
    protected internal static int GetNumberOfQueueEtls(RawDatabaseRecord database);
    protected internal static int GetNumberOfRavenEtls(RawDatabaseRecord database);
    protected internal static int GetNumberOfSinkPullReplications(RawDatabaseRecord database);
    protected internal static int GetNumberOfSqlEtls(RawDatabaseRecord database);
    protected internal static int GetNumberOfSubscriptions(TransactionOperationContext context, RawDatabaseRecord database);
    protected internal static int GetNumberOfQueueSinks(RawDatabaseRecord database);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<RawDatabaseRecord> <>n__0(TransactionOperationContext context);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.ServerStorageDiskIosReadOperations : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private ServerStore <store>P;
    private Nullable`1<int> Value { get; }
    public ServerStorageDiskIosReadOperations(ServerStore store);
    private Nullable`1<int> get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.ServerStorageDiskIosWriteOperations : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private ServerStore <store>P;
    private Nullable`1<int> Value { get; }
    public ServerStorageDiskIosWriteOperations(ServerStore store);
    private Nullable`1<int> get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.ServerStorageDiskQueueLength : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private ServerStore <store>P;
    private Nullable`1<long> Value { get; }
    public ServerStorageDiskQueueLength(ServerStore store);
    private Nullable`1<long> get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.ServerStorageDiskReadThroughput : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private ServerStore <store>P;
    private Nullable`1<long> Value { get; }
    public ServerStorageDiskReadThroughput(ServerStore store);
    private Nullable`1<long> get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.ServerStorageDiskWriteThroughput : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private ServerStore <store>P;
    private Nullable`1<long> Value { get; }
    public ServerStorageDiskWriteThroughput(ServerStore store);
    private Nullable`1<long> get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalDatabaseCountOfStaleIndexes : DatabaseBase`1<Gauge32> {
    private int Value { get; }
    public TotalDatabaseCountOfStaleIndexes(ServerStore serverStore);
    private int get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalDatabaseDataWrittenPerSecond : DatabaseBase`1<Gauge32> {
    private int Value { get; }
    public TotalDatabaseDataWrittenPerSecond(ServerStore serverStore);
    private int get_Value();
    protected virtual Gauge32 GetData();
    private static int GetCount(DocumentDatabase database);
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalDatabaseMapIndexIndexedPerSecond : DatabaseBase`1<Gauge32> {
    private int Value { get; }
    public TotalDatabaseMapIndexIndexedPerSecond(ServerStore serverStore);
    private int get_Value();
    protected virtual Gauge32 GetData();
    private static int GetCount(DocumentDatabase database);
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalDatabaseMapReduceIndexMappedPerSecond : DatabaseBase`1<Gauge32> {
    private int Value { get; }
    public TotalDatabaseMapReduceIndexMappedPerSecond(ServerStore serverStore);
    private int get_Value();
    protected virtual Gauge32 GetData();
    private static int GetCount(DocumentDatabase database);
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalDatabaseMapReduceIndexReducedPerSecond : DatabaseBase`1<Gauge32> {
    private int Value { get; }
    public TotalDatabaseMapReduceIndexReducedPerSecond(ServerStore serverStore);
    private int get_Value();
    protected virtual Gauge32 GetData();
    private static int GetCount(DocumentDatabase database);
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalDatabaseNumberOfErrorIndexes : DatabaseBase`1<Integer32> {
    private int Value { get; }
    public TotalDatabaseNumberOfErrorIndexes(ServerStore serverStore);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalDatabaseNumberOfFaultyIndexes : DatabaseBase`1<Integer32> {
    private int Value { get; }
    public TotalDatabaseNumberOfFaultyIndexes(ServerStore serverStore);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalDatabaseNumberOfIndexes : DatabaseBase`1<Integer32> {
    private int Value { get; }
    public TotalDatabaseNumberOfIndexes(ServerStore serverStore);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalDatabaseWritesPerSecond : DatabaseBase`1<Gauge32> {
    private int Value { get; }
    public TotalDatabaseWritesPerSecond(ServerStore serverStore);
    private int get_Value();
    public sealed virtual int GetCurrentMeasurement();
    protected virtual Gauge32 GetData();
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActiveBackupTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActiveBackupTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActiveElasticSearchEtlTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActiveElasticSearchEtlTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActiveExternalReplicationTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActiveExternalReplicationTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActiveOlapEtlTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActiveOlapEtlTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActiveOngoingTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActiveOngoingTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActivePullReplicationAsSinkTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActivePullReplicationAsSinkTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActiveQueueEtlTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActiveQueueEtlTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActiveQueueSinkTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActiveQueueSinkTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActiveRavenEtlTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActiveRavenEtlTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActiveSqlEtlTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActiveSqlEtlTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfActiveSubscriptionTasks : ActiveOngoingTasksBase {
    public TotalNumberOfActiveSubscriptionTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RachisState rachisState, string nodeTag, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfBackupTasks : OngoingTasksBase {
    public TotalNumberOfBackupTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfElasticSearchEtlTasks : OngoingTasksBase {
    public TotalNumberOfElasticSearchEtlTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfExternalReplicationTasks : OngoingTasksBase {
    public TotalNumberOfExternalReplicationTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfOlapEtlTasks : OngoingTasksBase {
    public TotalNumberOfOlapEtlTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfOngoingTasks : OngoingTasksBase {
    public TotalNumberOfOngoingTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfPullReplicationAsSinkTasks : OngoingTasksBase {
    public TotalNumberOfPullReplicationAsSinkTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfQueueEtlTasks : OngoingTasksBase {
    public TotalNumberOfQueueEtlTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfQueueSinkTasks : OngoingTasksBase {
    public TotalNumberOfQueueSinkTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfRavenEtlTasks : OngoingTasksBase {
    public TotalNumberOfRavenEtlTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfSqlEtlTasks : OngoingTasksBase {
    public TotalNumberOfSqlEtlTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public class Raven.Server.Monitoring.Snmp.Objects.Database.TotalNumberOfSubscriptionTasks : OngoingTasksBase {
    public TotalNumberOfSubscriptionTasks(ServerStore serverStore);
    protected virtual int GetCount(TransactionOperationContext context, RawDatabaseRecord database);
}
public abstract class Raven.Server.Monitoring.Snmp.Objects.DatabaseIndexScalarObjectBase`1 : DatabaseScalarObjectBase`1<TData> {
    protected string IndexName;
    public ISnmpData Data { get; }
    protected DatabaseIndexScalarObjectBase`1(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex, string dots);
    public virtual ISnmpData get_Data();
    protected Index GetIndex(DocumentDatabase database);
    protected bool TryGetIndex(Index& index);
}
public abstract class Raven.Server.Monitoring.Snmp.Objects.DatabaseScalarObjectBase`1 : ScalarObjectBase`1<TData> {
    protected string DatabaseName;
    protected DatabasesLandlord Landlord;
    protected DatabaseScalarObjectBase`1(string databaseName, DatabasesLandlord landlord, string dots, int index);
    protected abstract virtual TData GetData(DocumentDatabase database);
    protected virtual TData GetData();
    protected bool TryGetDatabase(DocumentDatabase& database);
    protected DocumentDatabase GetDatabase();
}
public abstract class Raven.Server.Monitoring.Snmp.Objects.ScalarObjectBase`1 : ScalarObject {
    private static NoSuchInstance NoSuchInstance;
    public ISnmpData Data { get; public set; }
    protected ScalarObjectBase`1(string dots, bool appendRoot);
    protected ScalarObjectBase`1(string dots, int index, bool appendRoot);
    private static ScalarObjectBase`1();
    protected abstract virtual TData GetData();
    public virtual ISnmpData get_Data();
    public virtual void set_Data(ISnmpData value);
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.CertificateExpiredCount : ScalarObjectBase`1<Integer32> {
    private ServerStore _store;
    private int Value { get; }
    public CertificateExpiredCount(ServerStore store);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.CertificateExpiringCount : ScalarObjectBase`1<Integer32> {
    private ServerStore _store;
    private int Value { get; }
    public CertificateExpiringCount(ServerStore store);
    private int get_Value();
    protected virtual Integer32 GetData();
    [IteratorStateMachineAttribute("Raven.Server.Monitoring.Snmp.Objects.Server.CertificateExpiringCount/<GetAllCertificateExpirationDates>d__5")]
public static IEnumerable`1<DateTime> GetAllCertificateExpirationDates(ServerStore store);
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.CpuCreditsAlertRaised : ScalarObjectBase`1<OctetString> {
    private CpuCreditsState _state;
    private bool Value { get; }
    public CpuCreditsAlertRaised(CpuCreditsState state);
    private bool get_Value();
    protected virtual OctetString GetData();
    public sealed virtual byte GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.CpuCreditsBackgroundTasksAlertRaised : ScalarObjectBase`1<OctetString> {
    private CpuCreditsState _state;
    private bool Value { get; }
    public CpuCreditsBackgroundTasksAlertRaised(CpuCreditsState state);
    private bool get_Value();
    protected virtual OctetString GetData();
    public sealed virtual byte GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.CpuCreditsBase : ScalarObjectBase`1<Integer32> {
    [CompilerGeneratedAttribute]
private CpuCreditsState <state>P;
    private int Value { get; }
    public CpuCreditsBase(CpuCreditsState state);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.CpuCreditsCurrentConsumption : ScalarObjectBase`1<OctetString> {
    [CompilerGeneratedAttribute]
private CpuCreditsState <state>P;
    public CpuCreditsCurrentConsumption(CpuCreditsState state);
    protected virtual OctetString GetData();
    public sealed virtual double GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.CpuCreditsFailoverAlertRaised : ScalarObjectBase`1<OctetString> {
    private CpuCreditsState _state;
    private bool Value { get; }
    public CpuCreditsFailoverAlertRaised(CpuCreditsState state);
    private bool get_Value();
    protected virtual OctetString GetData();
    public sealed virtual byte GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.CpuCreditsMax : ScalarObjectBase`1<Integer32> {
    [CompilerGeneratedAttribute]
private CpuCreditsState <state>P;
    private int Value { get; }
    public CpuCreditsMax(CpuCreditsState state);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.CpuCreditsRemaining : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private CpuCreditsState <state>P;
    private int Value { get; }
    public CpuCreditsRemaining(CpuCreditsState state);
    private int get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.FeatureAnyExperimental : ScalarObjectBase`1<OctetString> {
    private ServerStore _serverStore;
    public FeatureAnyExperimental(ServerStore serverStore);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.IoWait : ScalarObjectBase`1<Gauge32> {
    private MetricCacher _metricCacher;
    private ICpuUsageCalculator _calculator;
    private Nullable`1<int> Value { get; }
    public IoWait(MetricCacher metricCacher, ICpuUsageCalculator calculator);
    private Nullable`1<int> get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.MachineAssignedProcessorCount : ScalarObjectBase`1<Integer32> {
    private int Value { get; }
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.MachineCpu : ScalarObjectBase`1<Gauge32> {
    private ICpuUsageCalculator _calculator;
    private MetricCacher _metricCacher;
    private int Value { get; }
    public MachineCpu(MetricCacher metricCacher, ICpuUsageCalculator calculator);
    private int get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.MachineProcessorCount : ScalarObjectBase`1<Integer32> {
    private int Value { get; }
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.MonitorLockContentionCount : ScalarObjectBase`1<Integer32> {
    protected virtual Integer32 GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ProcessCpu : ScalarObjectBase`1<Gauge32> {
    private MetricCacher _metricCacher;
    private ICpuUsageCalculator _calculator;
    private int Value { get; }
    public ProcessCpu(MetricCacher metricCacher, ICpuUsageCalculator calculator);
    private int get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerAvailableMemoryForProcessing : ScalarObjectBase`1<Gauge32> {
    private MetricCacher _metricCacher;
    private long Value { get; }
    public ServerAvailableMemoryForProcessing(MetricCacher metricCacher);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerBackupsCurrent : ScalarObjectBase`1<Integer32> {
    private ServerStore _serverStore;
    private int Value { get; }
    public ServerBackupsCurrent(ServerStore serverStore);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerBackupsMax : ScalarObjectBase`1<Integer32> {
    private ServerStore _serverStore;
    private int Value { get; }
    public ServerBackupsMax(ServerStore serverStore);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerCertificateExpiration : ScalarObjectBase`1<OctetString> {
    private ServerStore _store;
    public ServerCertificateExpiration(ServerStore store);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerCertificateExpirationLeft : ScalarObjectBase`1<TimeTicks> {
    private ServerStore _store;
    public ServerCertificateExpirationLeft(ServerStore store);
    protected virtual TimeTicks GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerConcurrentRequests : ScalarObjectBase`1<Integer32> {
    [CompilerGeneratedAttribute]
private MetricCounters <metrics>P;
    private int Value { get; }
    public ServerConcurrentRequests(MetricCounters metrics);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerDirtyMemory : ScalarObjectBase`1<Gauge32> {
    private long Value { get; }
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerEncryptionBuffersMemoryInPool : ScalarObjectBase`1<Gauge32> {
    private long Value { get; }
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerEncryptionBuffersMemoryInUse : ScalarObjectBase`1<Gauge32> {
    private long Value { get; }
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerFullVersion : ScalarObjectBase`1<OctetString> {
    private OctetString _buildVersion;
    protected virtual OctetString GetData();
}
public abstract class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcBase`1 : ScalarObjectBase`1<TData> {
    private MetricCacher _metricCacher;
    private string _cacheKey;
    protected KeyValuePair`2<string, object> MeasurementTag;
    protected ServerGcBase`1(MetricCacher metricCacher, GCKind gcKind, string dots);
    private static string GetCacheKey(GCKind gcKind);
    protected GCMemoryInfo GetGCMemoryInfo();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcCompacted : ServerGcBase`1<OctetString> {
    private bool Value { get; }
    public ISnmpData Data { get; }
    public ServerGcCompacted(MetricCacher metricCacher, GCKind gcKind);
    private bool get_Value();
    public virtual ISnmpData get_Data();
    protected virtual OctetString GetData();
    public sealed virtual Measurement`1<byte> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcConcurrent : ServerGcBase`1<OctetString> {
    private bool Value { get; }
    public ISnmpData Data { get; }
    public ServerGcConcurrent(MetricCacher metricCacher, GCKind gcKind);
    private bool get_Value();
    public virtual ISnmpData get_Data();
    protected virtual OctetString GetData();
    public sealed virtual Measurement`1<byte> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcFinalizationPendingCount : ServerGcBase`1<Gauge32> {
    private long Value { get; }
    public ServerGcFinalizationPendingCount(MetricCacher metricCacher, GCKind gcKind);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcFragmented : ServerGcBase`1<Gauge32> {
    private long Value { get; }
    public ServerGcFragmented(MetricCacher metricCacher, GCKind gcKind);
    protected virtual Gauge32 GetData();
    private long get_Value();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcGeneration : ServerGcBase`1<Integer32> {
    private int Value { get; }
    public ServerGcGeneration(MetricCacher metricCacher, GCKind gcKind);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual Measurement`1<int> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcHeapSize : ServerGcBase`1<Gauge32> {
    private long Value { get; }
    public ServerGcHeapSize(MetricCacher metricCacher, GCKind gcKind);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcHighMemoryLoadThreshold : ServerGcBase`1<Gauge32> {
    private long Value { get; }
    public ServerGcHighMemoryLoadThreshold(MetricCacher metricCacher, GCKind gcKind);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcIndex : ServerGcBase`1<Integer32> {
    private int Value { get; }
    public ServerGcIndex(MetricCacher metricCacher, GCKind gcKind);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual Measurement`1<int> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcLohSize : ServerGcBase`1<Gauge32> {
    private long Value { get; }
    public ServerGcLohSize(MetricCacher metricCacher, GCKind gcKind);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcMemoryLoad : ServerGcBase`1<Gauge32> {
    private long Value { get; }
    public ServerGcMemoryLoad(MetricCacher metricCacher, GCKind gcKind);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcPauseDurations1 : ServerGcPauseDurationsBase {
    public ServerGcPauseDurations1(MetricCacher metricCacher, GCKind gcKind);
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcPauseDurations2 : ServerGcPauseDurationsBase {
    public ServerGcPauseDurations2(MetricCacher metricCacher, GCKind gcKind);
}
public abstract class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcPauseDurationsBase : ServerGcBase`1<TimeTicks> {
    private int _pauseDurationsIndex;
    protected ServerGcPauseDurationsBase(MetricCacher metricCacher, GCKind gcKind, string dots, int pauseDurationsIndex);
    protected virtual TimeTicks GetData();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcPauseTimePercentage : ServerGcBase`1<Gauge32> {
    private int Value { get; }
    public ServerGcPauseTimePercentage(MetricCacher metricCacher, GCKind gcKind);
    private int get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual Measurement`1<int> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcPinnedObjectsCount : ServerGcBase`1<Gauge32> {
    private long Value { get; }
    public ServerGcPinnedObjectsCount(MetricCacher metricCacher, GCKind gcKind);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcPromoted : ServerGcBase`1<Gauge32> {
    private long Value { get; }
    public ServerGcPromoted(MetricCacher metricCacher, GCKind gcKind);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcTotalAvailableMemory : ServerGcBase`1<Gauge32> {
    private long Value { get; }
    public ServerGcTotalAvailableMemory(MetricCacher metricCacher, GCKind gcKind);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerGcTotalCommitted : ServerGcBase`1<Gauge32> {
    private long Value { get; }
    public ServerGcTotalCommitted(MetricCacher metricCacher, GCKind gcKind);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual Measurement`1<long> GetCurrentMeasurement();
}
internal class Raven.Server.Monitoring.Snmp.Objects.Server.ServerLastAuthorizedNonClusterAdminRequestTime : ScalarObjectBase`1<TimeTicks> {
    private ServerStatistics _statistics;
    public ServerLastAuthorizedNonClusterAdminRequestTime(ServerStatistics statistics);
    protected virtual TimeTicks GetData();
}
internal class Raven.Server.Monitoring.Snmp.Objects.Server.ServerLastRequestTime : ScalarObjectBase`1<TimeTicks> {
    private ServerStatistics _statistics;
    public ServerLastRequestTime(ServerStatistics statistics);
    protected virtual TimeTicks GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerLicenseExpiration : ScalarObjectBase`1<OctetString> {
    private ServerStore _store;
    public ServerLicenseExpiration(ServerStore store);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerLicenseExpirationLeft : ScalarObjectBase`1<TimeTicks> {
    private ServerStore _store;
    private Nullable`1<TimeSpan> Value { get; }
    public ServerLicenseExpirationLeft(ServerStore store);
    private Nullable`1<TimeSpan> get_Value();
    protected virtual TimeTicks GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerLicenseMaxCpuCores : ScalarObjectBase`1<Integer32> {
    private ServerStore _store;
    private int Value { get; }
    public ServerLicenseMaxCpuCores(ServerStore store);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerLicenseType : ScalarObjectBase`1<OctetString> {
    private ServerStore _store;
    public ServerLicenseType(ServerStore store);
    protected virtual OctetString GetData();
    public sealed virtual short GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerLicenseUtilizedCpuCores : ScalarObjectBase`1<Integer32> {
    private ServerStore _store;
    private int Value { get; }
    public ServerLicenseUtilizedCpuCores(ServerStore store);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public static class Raven.Server.Monitoring.Snmp.Objects.Server.ServerLimits : object {
    public static void Register(ObjectStore store, MetricCacher metricCacher);
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerLowMemoryFlag : ScalarObjectBase`1<OctetString> {
    protected virtual OctetString GetData();
    public sealed virtual byte GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerManagedMemory : ScalarObjectBase`1<Gauge32> {
    private long Value { get; }
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public static class Raven.Server.Monitoring.Snmp.Objects.Server.ServerMemInfo : object {
    public static void Register(ObjectStore store, MetricCacher metricCacher);
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerPid : ScalarObjectBase`1<Integer32> {
    private Integer32 _pid;
    protected virtual Integer32 GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerPublicTcpUrl : ScalarObjectBase`1<OctetString> {
    private OctetString _url;
    public ServerPublicTcpUrl(RavenConfiguration configuration);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerPublicUrl : ScalarObjectBase`1<OctetString> {
    private OctetString _url;
    public ServerPublicUrl(RavenConfiguration configuration);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerRequestAverageDuration : ScalarObjectBase`1<Gauge32> {
    private MetricCounters _metrics;
    private int Value { get; }
    public ServerRequestAverageDuration(MetricCounters metrics);
    private int get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerRequestsPerSecond : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private MetricCounters <metrics>P;
    [CompilerGeneratedAttribute]
private RequestRateType <requestRateType>P;
    private int Value { get; }
    public ServerRequestsPerSecond(MetricCounters metrics, RequestRateType requestRateType);
    private int get_Value();
    public sealed virtual Measurement`1<int> GetCurrentMeasurement();
    protected virtual Gauge32 GetData();
    private static string GetOid(RequestRateType requestRateType);
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerStorageDiskRemainingSpace : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private ServerStore <store>P;
    private Nullable`1<long> Value { get; }
    public ServerStorageDiskRemainingSpace(ServerStore store);
    private Nullable`1<long> get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerStorageDiskRemainingSpacePercentage : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private ServerStore <store>P;
    public Nullable`1<int> Value { get; }
    public ServerStorageDiskRemainingSpacePercentage(ServerStore store);
    public Nullable`1<int> get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerStorageTotalSize : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private ServerStore <store>P;
    private long Value { get; }
    public ServerStorageTotalSize(ServerStore store);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerStorageUsedSize : ScalarObjectBase`1<Gauge32> {
    [CompilerGeneratedAttribute]
private ServerStore <store>P;
    private long Value { get; }
    public ServerStorageUsedSize(ServerStore store);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerTcpUrl : ScalarObjectBase`1<OctetString> {
    private OctetString _url;
    public ServerTcpUrl(RavenConfiguration configuration);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerTotalMemory : ScalarObjectBase`1<Gauge32> {
    private MetricCacher _metricCacher;
    private long Value { get; }
    public ServerTotalMemory(MetricCacher metricCacher);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerTotalRequests : ScalarObjectBase`1<Integer32> {
    [CompilerGeneratedAttribute]
private MetricCounters <metrics>P;
    private int Value { get; }
    public ServerTotalRequests(MetricCounters metrics);
    private int get_Value();
    protected virtual Integer32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerTotalSwapSize : ScalarObjectBase`1<Gauge32> {
    private MetricCacher _metricCacher;
    private long Value { get; }
    public ServerTotalSwapSize(MetricCacher metricCacher);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerTotalSwapUsage : ScalarObjectBase`1<Gauge32> {
    private MetricCacher _metricCacher;
    private long Value { get; }
    public ServerTotalSwapUsage(MetricCacher metricCacher);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerUnmanagedMemory : ScalarObjectBase`1<Gauge32> {
    private long Value { get; }
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
internal class Raven.Server.Monitoring.Snmp.Objects.Server.ServerUpTime : ScalarObjectBase`1<TimeTicks> {
    private ServerStatistics _statistics;
    public ServerUpTime(ServerStatistics statistics);
    protected virtual TimeTicks GetData();
    public sealed virtual long GetCurrentMeasurement();
}
internal class Raven.Server.Monitoring.Snmp.Objects.Server.ServerUpTimeGlobal : ScalarObjectBase`1<TimeTicks> {
    private ServerStatistics _statistics;
    public ServerUpTimeGlobal(ServerStatistics statistics);
    protected virtual TimeTicks GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerUrl : ScalarObjectBase`1<OctetString> {
    private OctetString _url;
    public ServerUrl(RavenConfiguration configuration);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerVersion : ScalarObjectBase`1<OctetString> {
    private OctetString _productVersion;
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ServerWorkingSetSwapUsage : ScalarObjectBase`1<Gauge32> {
    private MetricCacher _metricCacher;
    private long Value { get; }
    public ServerWorkingSetSwapUsage(MetricCacher metricCacher);
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.TcpActiveConnections : ScalarObjectBase`1<Gauge32> {
    private long Value { get; }
    private long get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual long GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ThreadPoolAvailableCompletionPortThreads : ScalarObjectBase`1<Gauge32> {
    private int Value { get; }
    private int get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.ThreadPoolAvailableWorkerThreads : ScalarObjectBase`1<Gauge32> {
    private int Value { get; }
    private int get_Value();
    protected virtual Gauge32 GetData();
    public sealed virtual int GetCurrentMeasurement();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.WellKnownAdminCertificates : ScalarObjectBase`1<OctetString> {
    private OctetString _wellKnownAdminCertificates;
    public WellKnownAdminCertificates(ServerStore store);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Objects.Server.WellKnownAdminIssuers : ScalarObjectBase`1<OctetString> {
    private OctetString _wellKnownAdminCertificates;
    public WellKnownAdminIssuers(ServerStore store);
    protected virtual OctetString GetData();
}
public class Raven.Server.Monitoring.Snmp.Providers.BouncyCastleAESPrivacyProvider : BouncyCastleAESPrivacyProviderBase {
    public BouncyCastleAESPrivacyProvider(OctetString phrase, IAuthenticationProvider auth);
    public virtual string ToString();
}
public abstract class Raven.Server.Monitoring.Snmp.Providers.BouncyCastleAESPrivacyProviderBase : object {
    private SaltGenerator _salt;
    private OctetString _phrase;
    [CompilerGeneratedAttribute]
private IAuthenticationProvider <AuthenticationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private OctetString <EngineId>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<OctetString> <EngineIds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyBytes>k__BackingField;
    public IAuthenticationProvider AuthenticationProvider { get; }
    [ObsoleteAttribute("Use EngineIds instead.")]
public OctetString EngineId { get; public set; }
    public ICollection`1<OctetString> EngineIds { get; public set; }
    private static int PrivacyParametersLength { get; }
    private int MinimumKeyLength { get; }
    public int MaximumKeyLength { get; }
    public OctetString Salt { get; }
    public int KeyBytes { get; }
    protected BouncyCastleAESPrivacyProviderBase(int keyBytes, OctetString phrase, IAuthenticationProvider auth);
    [CompilerGeneratedAttribute]
public sealed virtual IAuthenticationProvider get_AuthenticationProvider();
    [CompilerGeneratedAttribute]
public sealed virtual OctetString get_EngineId();
    [CompilerGeneratedAttribute]
public void set_EngineId(OctetString value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<OctetString> get_EngineIds();
    [CompilerGeneratedAttribute]
public void set_EngineIds(ICollection`1<OctetString> value);
    internal Byte[] Encrypt(Byte[] unencryptedData, Byte[] key, int engineBoots, int engineTime, Byte[] privacyParameters);
    internal Byte[] Decrypt(Byte[] encryptedData, Byte[] key, int engineBoots, int engineTime, Byte[] privacyParameters);
    private static int get_PrivacyParametersLength();
    private int get_MinimumKeyLength();
    public int get_MaximumKeyLength();
    public sealed virtual ISnmpData Decrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual ISnmpData Encrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual OctetString get_Salt();
    [CompilerGeneratedAttribute]
public int get_KeyBytes();
    public sealed virtual Byte[] PasswordToKey(Byte[] secret, Byte[] engineId);
    public Byte[] ExtendShortKey(Byte[] shortKey, Byte[] password, Byte[] engineID, IAuthenticationProvider authProtocol);
}
public class Raven.Server.Monitoring.Snmp.Providers.BouncyCastleDESPrivacyProvider : object {
    private SaltGenerator _salt;
    private OctetString _phrase;
    [CompilerGeneratedAttribute]
private IAuthenticationProvider <AuthenticationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private OctetString <EngineId>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<OctetString> <EngineIds>k__BackingField;
    public IAuthenticationProvider AuthenticationProvider { get; private set; }
    [ObsoleteAttribute("Use EngineIds instead.")]
public OctetString EngineId { get; public set; }
    public ICollection`1<OctetString> EngineIds { get; public set; }
    public static int PrivacyParametersLength { get; }
    public static int MinimumKeyLength { get; }
    public static int MaximumKeyLength { get; }
    public OctetString Salt { get; }
    public BouncyCastleDESPrivacyProvider(OctetString phrase, IAuthenticationProvider auth);
    [CompilerGeneratedAttribute]
public sealed virtual IAuthenticationProvider get_AuthenticationProvider();
    [CompilerGeneratedAttribute]
private void set_AuthenticationProvider(IAuthenticationProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual OctetString get_EngineId();
    [CompilerGeneratedAttribute]
public void set_EngineId(OctetString value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<OctetString> get_EngineIds();
    [CompilerGeneratedAttribute]
public void set_EngineIds(ICollection`1<OctetString> value);
    public static Byte[] Encrypt(Byte[] unencryptedData, Byte[] key, Byte[] privacyParameters);
    public static Byte[] Decrypt(Byte[] encryptedData, Byte[] key, Byte[] privacyParameters);
    private static Byte[] GetIV(IList`1<byte> privacyKey, IList`1<byte> salt);
    private static Byte[] GetKey(Byte[] privacyPassword);
    public static int get_PrivacyParametersLength();
    public static int get_MinimumKeyLength();
    public static int get_MaximumKeyLength();
    public sealed virtual ISnmpData Decrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual ISnmpData Encrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual OctetString get_Salt();
    public sealed virtual Byte[] PasswordToKey(Byte[] secret, Byte[] engineId);
    public virtual string ToString();
}
public enum Raven.Server.Monitoring.Snmp.SnmpAuthenticationProtocol : Enum {
    public int value__;
    public static SnmpAuthenticationProtocol SHA1;
    public static SnmpAuthenticationProtocol MD5;
}
public class Raven.Server.Monitoring.Snmp.SnmpDatabase : object {
    private Dictionary`2<string, int> _loadedIndexes;
    private DatabasesLandlord _databaseLandlord;
    private ObjectStore _objectStore;
    private string _databaseName;
    private int _databaseIndex;
    private SemaphoreSlim _locker;
    private bool _attached;
    public SnmpDatabase(DatabasesLandlord databaseLandlord, ObjectStore objectStore, string databaseName, int databaseIndex);
    private void Initialize();
    private void Attach(bool force);
    private void AddIndexIfNecessary(IndexChange change);
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpDatabase/<AddIndexesFromDatabase>d__11")]
private Task AddIndexesFromDatabase(DocumentDatabase database);
    private void LoadIndex(string indexName, int index);
    internal static Dictionary`2<string, long> GetIndexMapping(TransactionOperationContext context, ServerStore serverStore, string databaseName);
}
[AttributeUsageAttribute("256")]
public class Raven.Server.Monitoring.Snmp.SnmpDataTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SnmpType <TypeCode>k__BackingField;
    public SnmpType TypeCode { get; }
    public SnmpDataTypeAttribute(SnmpType type);
    [CompilerGeneratedAttribute]
public SnmpType get_TypeCode();
}
[AttributeUsageAttribute("256")]
public class Raven.Server.Monitoring.Snmp.SnmpEnumIndexAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public SnmpEnumIndexAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
}
public class Raven.Server.Monitoring.Snmp.SnmpHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpHandler/<Get>d__0")]
[RavenActionAttribute("/monitoring/snmp", "GET", "1", "False", "False", "True", "0")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpHandler/<GetBulk>d__1")]
[RavenActionAttribute("/monitoring/snmp/bulk", "GET", "1", "False", "False", "True", "0")]
public Task GetBulk();
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpHandler/<PostBulk>d__2")]
[RavenActionAttribute("/monitoring/snmp/bulk", "POST", "1", "False", "False", "True", "0")]
public Task PostBulk();
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpHandler/<GetOids>d__3")]
[RavenActionAttribute("/monitoring/snmp/oids", "GET", "1", "False", "False", "True", "0")]
public Task GetOids();
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpHandler/<GetMib>d__4")]
[RavenActionAttribute("/monitoring/snmp/mib", "GET", "1", "False", "False", "True", "0")]
public Task GetMib();
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpHandler/<BulkInternal>d__5")]
private ValueTask BulkInternal(String[] oids, JsonOperationContext context);
    private void AssertSnmp();
}
[AttributeUsageAttribute("384")]
public class Raven.Server.Monitoring.Snmp.SnmpIndexAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; }
    public SnmpIndexAttribute(int index);
    [CompilerGeneratedAttribute]
public int get_Index();
}
public class Raven.Server.Monitoring.Snmp.SnmpMibWriter : object {
    private HashSet`1<string> _seenObjects;
    private bool _includeServer;
    private bool _includeCluster;
    private bool _includeDatabases;
    private StreamWriter _writer;
    public SnmpMibWriter(Stream stream, bool includeServer, bool includeCluster, bool includeDatabases);
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpMibWriter/<WriteAsync>d__6")]
public Task WriteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpMibWriter/<WriteSyntaxAsync>d__7")]
private Task WriteSyntaxAsync(SnmpType typeCode);
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpMibWriter/<WriteModuleAsync>d__8")]
private Task WriteModuleAsync(DateTime now);
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpMibWriter/<WriteImportsAsync>d__9")]
private Task WriteImportsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpMibWriter/<WriteObjectIdentifierAsync>d__10")]
private Task WriteObjectIdentifierAsync(string objectName, string parentObjectName, string oid);
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpMibWriter/<WriteObjectAsync>d__11")]
public Task WriteObjectAsync(string objectName, string parentObjectName, SnmpType typeCode, string description, string oid);
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpMibWriter/<WriteTabsAsync>d__12")]
private Task WriteTabsAsync(int numberOfTabs);
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpMibWriter/<DisposeAsync>d__13")]
public sealed virtual ValueTask DisposeAsync();
}
public class Raven.Server.Monitoring.Snmp.SnmpOids : object {
    public static string Root;
    public static Dictionary`2<string, string> CreateMapping();
    private static ValueTuple`4<string, string, Type, Nullable`1<SnmpType>> GetFieldValue(FieldInfo field);
    private static DynamicJsonValue CreateJsonItem(string oid, string description);
}
public enum Raven.Server.Monitoring.Snmp.SnmpPrivacyProtocol : Enum {
    public int value__;
    public static SnmpPrivacyProtocol None;
    public static SnmpPrivacyProtocol DES;
    public static SnmpPrivacyProtocol AES;
}
public static class Raven.Server.Monitoring.Snmp.SnmpValuesHelper : object {
    public static TimeTicks TimeTicksMax;
    public static TimeTicks TimeTicksZero;
    public static TimeSpan TimeSpanSnmpMax;
    private static SnmpValuesHelper();
    public static TimeTicks TimeSpanToTimeTicks(TimeSpan timeSpan);
}
public enum Raven.Server.Monitoring.Snmp.SnmpVersion : Enum {
    public int value__;
    public static SnmpVersion V2C;
    public static SnmpVersion V3;
}
public class Raven.Server.Monitoring.Snmp.SnmpWatcher : object {
    private ConcurrentDictionary`2<string, SnmpDatabase> _loadedDatabases;
    private SemaphoreSlim _locker;
    private static Logger Logger;
    private RavenServer _server;
    private ObjectStore _objectStore;
    private SnmpEngine _snmpEngine;
    public SnmpWatcher(RavenServer server);
    private static SnmpWatcher();
    private void OnLicenseChanged();
    public void Execute();
    public ISnmpData GetData(string oid);
    private void AddDatabaseIfNecessary(string databaseName);
    private static SnmpEngine CreateSnmpEngine(RavenServer server, ObjectStore objectStore);
    private static Func`4<Int32[], int, int, bool> GetIsInTime(MonitoringConfiguration monitoringConfiguration);
    private static ValueTuple`2<HashSet`1<SnmpVersion>, string> GetVersions(RavenServer server);
    private static ComposedMembershipProvider CreateMembershipProvider(RavenServer server, HashSet`1<SnmpVersion> versions);
    private static ObjectStore CreateStore(RavenServer server);
    [AsyncStateMachineAttribute("Raven.Server.Monitoring.Snmp.SnmpWatcher/<AddDatabases>d__16")]
private Task AddDatabases();
    private void LoadDatabase(string databaseName, long databaseIndex);
    private static void StartEngine(SnmpEngine engine, RavenServer server);
    internal static Dictionary`2<string, long> GetMapping(ServerStore serverStore, TransactionOperationContext context);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static IPrivacyProvider <CreateSnmpEngine>g__CreatePrivacyProvider|11_1(string authenticationUser, SnmpAuthenticationProtocol authenticationProtocol, string authenticationPassword, SnmpPrivacyProtocol privacyProtocol, string privacyPassword);
    [CompilerGeneratedAttribute]
internal static void <CreateStore>g__AddGc|15_0(GCKind gcKind, <>c__DisplayClass15_0& );
}
public abstract class Raven.Server.NotificationCenter.AbstractDatabaseNotificationCenter : AbstractNotificationCenter {
    public string Database;
    public Paging Paging;
    public ConflictRevisionsExceeded ConflictRevisionsExceeded;
    public TombstoneNotifications TombstoneNotifications;
    public Indexing Indexing;
    public RequestLatency RequestLatency;
    public EtlNotifications EtlNotifications;
    public QueueSinkNotifications QueueSinkNotifications;
    public SlowWriteNotifications SlowWrites;
    [CompilerGeneratedAttribute]
private PostponedNotificationsSender <PostponedNotificationSender>k__BackingField;
    protected PostponedNotificationsSender PostponedNotificationSender { get; }
    protected AbstractDatabaseNotificationCenter(ServerStore serverStore, string database, RavenConfiguration configuration, CancellationToken shutdown);
    protected AbstractDatabaseNotificationCenter(NotificationsStorage notificationsStorage, string database, RavenConfiguration configuration, CancellationToken shutdown);
    [CompilerGeneratedAttribute]
protected virtual PostponedNotificationsSender get_PostponedNotificationSender();
    public virtual void Dispose();
}
public abstract class Raven.Server.NotificationCenter.AbstractNotificationCenter : NotificationsBase {
    private Logger _logger;
    public NotificationsStorage Storage;
    private TaskCompletionSource`1<AbstractNotificationCenter> _initializeTaskSource;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public OutOfMemoryNotifications OutOfMemory;
    public NotificationCenterOptions Options;
    private RavenConfiguration _configuration;
    public Task`1<AbstractNotificationCenter> InitializeTask { get; }
    public bool IsInitialized { get; public set; }
    protected PostponedNotificationsSender PostponedNotificationSender { get; }
    protected AbstractNotificationCenter(NotificationsStorage storage, RavenConfiguration configuration, Logger logger);
    public Task`1<AbstractNotificationCenter> get_InitializeTask();
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
public void set_IsInitialized(bool value);
    protected abstract virtual PostponedNotificationsSender get_PostponedNotificationSender();
    public virtual void Initialize();
    public void Add(Notification notification, Nullable`1<DateTime> postponeUntil, bool updateExisting);
    public IDisposable GetStored(IEnumerable`1& actions, bool postponed);
    public string GetStoredMessage(string id);
    public long GetAlertCount();
    public long GetPerformanceHintCount();
    public void Dismiss(string id, RavenTransaction existingTransaction, bool sendNotificationEvenIfDoesntExist);
    public bool Exists(string id);
    public string GetDatabaseFor(string id);
    public void Postpone(string id, DateTime until);
    [IteratorStateMachineAttribute("Raven.Server.NotificationCenter.AbstractNotificationCenter/<<GetStored>g__Filter|17_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<NotificationTableValue> <GetStored>g__Filter|17_0(IEnumerable`1<NotificationTableValue> actions);
}
public abstract class Raven.Server.NotificationCenter.BackgroundWork.AbstractDatabaseStatsSender : BackgroundWorkBase {
    private string _databaseName;
    private AbstractDatabaseNotificationCenter _notificationCenter;
    private NotificationCenterDatabaseStats _latest;
    protected AbstractDatabaseStatsSender(string databaseName, AbstractDatabaseNotificationCenter notificationCenter, CancellationToken shutdown);
    protected abstract virtual ValueTask`1<NotificationCenterDatabaseStats> GetStatsAsync();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.BackgroundWork.AbstractDatabaseStatsSender/<DoWork>d__5")]
protected virtual Task DoWork();
    private List`1<ModifiedCollection> ExtractModifiedCollections(NotificationCenterDatabaseStats current);
}
public class Raven.Server.NotificationCenter.BackgroundWork.DatabaseStatsSender : AbstractDatabaseStatsSender {
    private DocumentDatabase _database;
    public DatabaseStatsSender(DocumentDatabase database, AbstractDatabaseNotificationCenter notificationCenter);
    protected virtual ValueTask`1<NotificationCenterDatabaseStats> GetStatsAsync();
    public static NotificationCenterDatabaseStats GetStats(DocumentDatabase database);
}
public class Raven.Server.NotificationCenter.BackgroundWork.NotificationCenterDatabaseStats : object {
    public long CountOfConflicts;
    public long CountOfDocuments;
    public long LastEtag;
    public int CountOfIndexes;
    public int CountOfStaleIndexes;
    public String[] StaleIndexes;
    public long CountOfIndexingErrors;
    public string GlobalChangeVector;
    public Nullable`1<DateTime> LastIndexingErrorTime;
    public Dictionary`2<string, ModifiedCollection> Collections;
    public bool Equals(NotificationCenterDatabaseStats other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void CombineWith(NotificationCenterDatabaseStats stats, IChangeVectorOperationContext context);
}
public class Raven.Server.NotificationCenter.BackgroundWork.PostponedNotificationsSender : BackgroundWorkBase {
    private NotificationsStorage _notificationsStorage;
    private ConcurrentSet`1<ConnectedWatcher> _watchers;
    private AsyncManualResetEvent _event;
    public PostponedNotificationsSender(string resourceName, NotificationsStorage notificationsStorage, ConcurrentSet`1<ConnectedWatcher> watchers, CancellationToken shutdown);
    protected virtual void InitializeWork();
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.BackgroundWork.PostponedNotificationsSender/<DoWork>d__6")]
protected virtual Task DoWork();
    private Queue`1<PostponedNotification> GetPostponedNotifications(int take, DateTime cutoff);
    public void Set();
}
public class Raven.Server.NotificationCenter.BlockingTombstoneDetails : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private TombstoneDeletionBlockerType <BlockerType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BlockerTaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfTombstones>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeOfTombstonesInBytes>k__BackingField;
    public string Source { get; public set; }
    public TombstoneDeletionBlockerType BlockerType { get; public set; }
    public long BlockerTaskId { get; public set; }
    public string Collection { get; public set; }
    public long NumberOfTombstones { get; public set; }
    public long SizeOfTombstonesInBytes { get; public set; }
    public string SizeOfTombstonesHumane { get; }
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public TombstoneDeletionBlockerType get_BlockerType();
    [CompilerGeneratedAttribute]
public void set_BlockerType(TombstoneDeletionBlockerType value);
    [CompilerGeneratedAttribute]
public long get_BlockerTaskId();
    [CompilerGeneratedAttribute]
public void set_BlockerTaskId(long value);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public long get_NumberOfTombstones();
    [CompilerGeneratedAttribute]
public void set_NumberOfTombstones(long value);
    [CompilerGeneratedAttribute]
public long get_SizeOfTombstonesInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeOfTombstonesInBytes(long value);
    public string get_SizeOfTombstonesHumane();
}
internal class Raven.Server.NotificationCenter.Commands.DismissNotificationCommand : RavenCommand {
    private string _id;
    private bool _forever;
    public DismissNotificationCommand(string id, bool forever, string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
internal class Raven.Server.NotificationCenter.Commands.PostponeNotificationCommand : RavenCommand {
    private string _id;
    private long _timeInSec;
    public PostponeNotificationCommand(string id, long timeInSec, string nodeTag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
public class Raven.Server.NotificationCenter.ConflictRevisionsExceeded : object {
    private static string ConflictRevisionExceededMaxId;
    private AbstractDatabaseNotificationCenter _notificationCenter;
    private object _locker;
    public static long QueueMaxSize;
    private ConcurrentQueue`1<ConflictInfo> _queue;
    private Timer _timer;
    private Logger _logger;
    public ConflictRevisionsExceeded(AbstractDatabaseNotificationCenter notificationCenter);
    private static ConflictRevisionsExceeded();
    public void Add(ConflictInfo info);
    private void Update(object state);
    private AlertRaised GetConflictRevisionsPerformanceAlert();
    public void Dispose();
}
public class Raven.Server.NotificationCenter.ConnectedWatcher : object {
    private AsyncQueue`1<DynamicJsonValue> _notificationsQueue;
    private int _maxNotificationsQueueSize;
    public IWebsocketWriter Writer;
    public CanAccessDatabase Filter;
    public ConnectedWatcher(AsyncQueue`1<DynamicJsonValue> notificationsQueue, int maxNotificationsQueueSize, IWebsocketWriter writer, CanAccessDatabase filter);
    public void Enqueue(DynamicJsonValue json);
}
public class Raven.Server.NotificationCenter.DatabaseNotificationCenter : AbstractDatabaseNotificationCenter {
    private DocumentDatabase _database;
    public DatabaseNotificationCenter(DocumentDatabase database);
    public virtual void Initialize();
}
public class Raven.Server.NotificationCenter.EtlNotifications : object {
    private AbstractDatabaseNotificationCenter _notificationCenter;
    public EtlNotifications(AbstractDatabaseNotificationCenter notificationCenter);
    public AlertRaised AddTransformationErrors(string processTag, string processName, Queue`1<EtlErrorInfo> errors, string preMessage);
    public AlertRaised AddLoadErrors(string processTag, string processName, Queue`1<EtlErrorInfo> errors, string preMessage);
    public void AddSlowSqlWarnings(string processTag, string processName, Queue`1<SlowSqlStatementInfo> slowSqls);
    private AlertRaised AddErrorAlert(Queue`1<EtlErrorInfo> errors, EtlErrorsDetails details, AlertRaised alert);
    private AlertRaised GetOrCreateAlert(string processTag, string processName, AlertType etlAlertType, string message, T& details);
    public AlertRaised GetAlert(string processTag, string processName, AlertType etlAlertType);
    private PerformanceHint GetOrCreatePerformanceHint(string processTag, string processName, PerformanceHintType etlHintType, string message, T& details);
    private static T GetDetails(NotificationTableValue ntv);
}
public class Raven.Server.NotificationCenter.Handlers.ClusterDashboardConnection`1 : NotificationCenterWebSocketWriter`1<TOperationContext> {
    private static int WelcomeMessageId;
    private static Logger Logger;
    private CanAccessDatabase _canAccessDatabase;
    private ClusterDashboardNotifications _clusterDashboardNotifications;
    private JsonOperationContext _readContext;
    private IDisposable _returnReadContext;
    private ConcurrentDictionary`2<int, AbstractClusterDashboardNotificationSender> _activeNotificationSenders;
    private Task _receiveTask;
    public ClusterDashboardConnection`1(WebSocket webSocket, CanAccessDatabase canAccessDatabase, ClusterDashboardNotifications clusterDashboardNotifications, JsonContextPoolBase`1<TOperationContext> contextPool, CancellationToken resourceShutdown);
    private static ClusterDashboardConnection`1();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ClusterDashboardConnection`1/<Handle>d__9")]
public Task Handle();
    private DynamicJsonValue CreateInitialMessage();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ClusterDashboardConnection`1/<ListenForCommands>d__11")]
private Task ListenForCommands();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ClusterDashboardConnection`1/<HandleCommand>d__12")]
private Task HandleCommand(BlittableJsonReaderObject reader);
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ClusterDashboardConnection`1/<WatchCommand>d__13")]
private Task WatchCommand(int widgetId, ClusterDashboardNotificationType type, BlittableJsonReaderObject configuration);
    private void UnwatchCommand(int widgetId);
    public virtual void Dispose();
}
public class Raven.Server.NotificationCenter.Handlers.ClusterDashboardHandler : ServerNotificationHandlerBase {
    private static Logger Logger;
    private static ClusterDashboardHandler();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ClusterDashboardHandler/<Watch>d__1")]
[RavenActionAttribute("/cluster-dashboard/watch", "GET", "3", "1", "False", "False", "True", "0")]
public Task Watch();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ClusterDashboardHandler/<RemoteWatch>d__2")]
[RavenActionAttribute("/admin/cluster-dashboard/remote/watch", "GET", "0", "False", "False", "True", "0")]
public Task RemoteWatch();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ClusterDashboardHandler/<SendNotifications>d__3")]
private Task SendNotifications(CanAccessDatabase canAccessDatabase, WebSocket webSocket);
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ClusterDashboardHandler/<HandleException>d__4")]
private Task HandleException(Exception ex, WebSocket webSocket);
}
public class Raven.Server.NotificationCenter.Handlers.DatabaseNotificationCenterHandler : DatabaseRequestHandler {
    private static short SupportedFilterFlags;
    private static DatabaseNotificationCenterHandler();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.DatabaseNotificationCenterHandler/<GetNotifications>d__2")]
[RavenActionAttribute("/databases/*/notifications", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetNotifications();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.DatabaseNotificationCenterHandler/<Watch>d__3")]
[RavenActionAttribute("/databases/*/notification-center/watch", "GET", "3", "1", "False", "False", "True", "0")]
public Task Watch();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.DatabaseNotificationCenterHandler/<Dismiss>d__4")]
[RavenActionAttribute("/databases/*/notification-center/dismiss", "POST", "3", "2", "False", "False", "True", "0")]
public Task Dismiss();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.DatabaseNotificationCenterHandler/<Postpone>d__5")]
[RavenActionAttribute("/databases/*/notification-center/postpone", "POST", "3", "2", "False", "False", "True", "0")]
public Task Postpone();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.DatabaseNotificationCenterHandler/<Stats>d__6")]
[RavenActionAttribute("/databases/*/notification-center/stats", "GET", "3", "1", "False", "False", "True", "0")]
public Task Stats();
    [CompilerGeneratedAttribute]
internal static bool <GetNotifications>g__ShouldIncludeNotification|2_0(NotificationType& notificationType, <>c__DisplayClass2_0& );
}
internal abstract class Raven.Server.NotificationCenter.Handlers.Processors.AbstractDatabaseNotificationCenterHandlerProcessorForDismiss`2 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDatabaseNotificationCenterHandlerProcessorForDismiss`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<object> CreateCommandForNode(string nodeTag);
    protected abstract virtual AbstractDatabaseNotificationCenter GetNotificationCenter();
    protected string GetNotificationId();
    protected bool GetForever();
    protected virtual ValueTask HandleCurrentNodeAsync();
}
internal abstract class Raven.Server.NotificationCenter.Handlers.Processors.AbstractDatabaseNotificationCenterHandlerProcessorForPostpone`2 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDatabaseNotificationCenterHandlerProcessorForPostpone`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<object> CreateCommandForNode(string nodeTag);
    protected abstract virtual AbstractDatabaseNotificationCenter GetNotificationCenter();
    protected string GetNotificationId();
    protected long GetTimeInSec();
    protected virtual ValueTask HandleCurrentNodeAsync();
}
internal abstract class Raven.Server.NotificationCenter.Handlers.Processors.AbstractDatabaseNotificationCenterHandlerProcessorForWatch`3 : AbstractHandlerWebSocketProxyProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractDatabaseNotificationCenterHandlerProcessorForWatch`3(TRequestHandler requestHandler);
    protected abstract virtual AbstractDatabaseNotificationCenter GetNotificationCenter();
    protected abstract virtual AbstractOperations`1<TOperation> GetOperations();
    protected virtual string GetRemoteEndpointUrl(string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.Processors.AbstractDatabaseNotificationCenterHandlerProcessorForWatch`3/<HandleCurrentNodeAsync>d__4")]
protected virtual ValueTask HandleCurrentNodeAsync(WebSocket webSocket, OperationCancelToken token);
}
internal class Raven.Server.NotificationCenter.Handlers.Processors.DatabaseNotificationCenterHandlerProcessorForDismiss : AbstractDatabaseNotificationCenterHandlerProcessorForDismiss`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public DatabaseNotificationCenterHandlerProcessorForDismiss(DatabaseRequestHandler requestHandler);
    protected virtual AbstractDatabaseNotificationCenter GetNotificationCenter();
    protected virtual bool get_SupportsCurrentNode();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.NotificationCenter.Handlers.Processors.DatabaseNotificationCenterHandlerProcessorForPostpone : AbstractDatabaseNotificationCenterHandlerProcessorForPostpone`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public DatabaseNotificationCenterHandlerProcessorForPostpone(DatabaseRequestHandler requestHandler);
    protected virtual AbstractDatabaseNotificationCenter GetNotificationCenter();
    protected virtual bool get_SupportsCurrentNode();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.NotificationCenter.Handlers.Processors.DatabaseNotificationCenterHandlerProcessorForStats : AbstractDatabaseHandlerProcessor`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public DatabaseNotificationCenterHandlerProcessorForStats(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.Processors.DatabaseNotificationCenterHandlerProcessorForStats/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.NotificationCenter.Handlers.Processors.DatabaseNotificationCenterHandlerProcessorForWatch : AbstractDatabaseNotificationCenterHandlerProcessorForWatch`3<DatabaseRequestHandler, DocumentsOperationContext, Operation> {
    protected bool SupportsCurrentNode { get; }
    public DatabaseNotificationCenterHandlerProcessorForWatch(DatabaseRequestHandler requestHandler);
    protected virtual AbstractDatabaseNotificationCenter GetNotificationCenter();
    protected virtual AbstractOperations`1<Operation> GetOperations();
    protected virtual bool get_SupportsCurrentNode();
}
public class Raven.Server.NotificationCenter.Handlers.ProxyWebSocketConnection : object {
    private static Logger Logger;
    private CancellationTokenSource _cts;
    private Uri _remoteWebSocketUri;
    private ClientWebSocket _remoteWebSocket;
    private WebSocket _localWebSocket;
    private string _nodeUrl;
    private IMemoryContextPool _contextPool;
    private Task _localToRemote;
    private Task _remoteToLocal;
    private HttpClient _httpClient;
    public ProxyWebSocketConnection(WebSocket localWebSocket, string nodeUrl, string websocketEndpoint, IMemoryContextPool contextPool, CancellationToken token);
    private static ProxyWebSocketConnection();
    public Task Establish(X509Certificate2 certificate);
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ProxyWebSocketConnection/<RelayData>d__12")]
public Task RelayData();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ProxyWebSocketConnection/<ForwardLocalToRemote>d__13")]
private Task ForwardLocalToRemote();
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ProxyWebSocketConnection/<ForwardRemoteToLocal>d__14")]
private Task ForwardRemoteToLocal();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <ForwardRemoteToLocal>g__IsSocketClosed|14_0(Exception ex);
}
public class Raven.Server.NotificationCenter.Handlers.ServerNotificationCenterHandler : ServerNotificationHandlerBase {
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ServerNotificationCenterHandler/<Get>d__0")]
[RavenActionAttribute("/server/notification-center/watch", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
    [RavenActionAttribute("/server/notification-center/dismiss", "POST", "3", "2", "False", "False", "True", "0")]
public Task DismissPost();
    [RavenActionAttribute("/server/notification-center/postpone", "POST", "3", "2", "False", "False", "True", "0")]
public Task PostponePost();
}
public abstract class Raven.Server.NotificationCenter.Handlers.ServerNotificationHandlerBase : ServerRequestHandler {
    protected CanAccessDatabase GetDatabaseAccessValidationFunc(AuthenticateConnection authenticationStatus);
    [DoesNotReturnAttribute]
private static void ThrowInvalidFeatureStatus(AuthenticationStatus status);
}
public class Raven.Server.NotificationCenter.Handlers.ThreadsInfoHandler : ServerNotificationHandlerBase {
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.Handlers.ThreadsInfoHandler/<GetThreadsInfo>d__0")]
[RavenActionAttribute("/threads-info/watch", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetThreadsInfo();
}
public class Raven.Server.NotificationCenter.Indexing : object {
    private static string Source;
    private static string HighOutputsRate;
    private static string ReferencesLoad;
    private AbstractDatabaseNotificationCenter _notificationCenter;
    private DateTime _warningUpdateTime;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentQueue`1<ValueTuple`2<string, WarningDetails>> _warningIndexOutputsPerDocumentQueue;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentQueue`1<ValueTuple`2<string, WarningDetails>> _warningReferenceDocumentLoadsQueue;
    private MismatchedReferencesLoadWarning _mismatchedReferencesLoadWarning;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentQueue`1<ValueTuple`2<string, string>> _warningComplexFieldAutoIndexing;
    private HashSet`1<string> _cpuExhaustionWarningIndexNames;
    private bool _isCpuExhaustionWarningAdded;
    private Timer _indexingTimer;
    private Logger _logger;
    private object _locker;
    internal TimeSpan MinUpdateInterval;
    public Indexing(AbstractDatabaseNotificationCenter notificationCenter);
    private static Indexing();
    public void AddWarning(string indexName, WarningDetails indexOutputsWarning);
    public void AddWarning(string indexName, WarningDetails referenceLoadsWarning);
    public void AddComplexFieldWarning(string indexName, string fieldName);
    public void ProcessComplexFields();
    public void AddWarning(MismatchedReferencesLoadWarning mismatchedReferenceLoadWarningDetails);
    public void AddIndexNameToCpuCreditsExhaustionWarning(string indexName);
    public void RemoveIndexNameFromCpuCreditsExhaustionWarning(string indexName);
    public void ProcessCpuCreditsExhaustion();
    private bool CanAdd(DateTime& now);
    private void EnsureTimer();
    internal void UpdateIndexing(object state);
    private PerformanceHint GetIndexOutputPerDocumentPerformanceHint();
    private PerformanceHint GetReferenceLoadsPerformanceHint();
    private AlertRaised GetMismatchedReferencesAlert();
    private AlertRaised GetComplexFieldAlert(ComplexFieldsWarning complexFieldsWarning);
    private AlertRaised GetCpuCreditsExhaustionAlert(CpuCreditsExhaustionWarning cpuCreditsExhaustionWarning);
    public sealed virtual void Dispose();
}
public interface Raven.Server.NotificationCenter.INotificationCenterWebSocketWriter {
}
public interface Raven.Server.NotificationCenter.IWebsocketWriter {
    public abstract virtual Task WriteToWebSocket(TNotification notification);
}
public class Raven.Server.NotificationCenter.NotificationCenterOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <DatabaseStatsThrottle>k__BackingField;
    public TimeSpan DatabaseStatsThrottle { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_DatabaseStatsThrottle();
    [CompilerGeneratedAttribute]
public void set_DatabaseStatsThrottle(TimeSpan value);
}
public class Raven.Server.NotificationCenter.NotificationCenterWebSocketWriter`1 : object {
    protected WebSocket _webSocket;
    private NotificationsBase _notificationsBase;
    private JsonOperationContext _context;
    protected CancellationToken _resourceShutdown;
    private MemoryStream _ms;
    public Action AfterTrackActionsRegistration;
    private IDisposable _returnContext;
    public NotificationCenterWebSocketWriter`1(WebSocket webSocket, NotificationsBase notificationsBase, JsonContextPoolBase`1<TOperationContext> contextPool, CancellationToken resourceShutdown);
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.NotificationCenterWebSocketWriter`1/<WriteNotifications>d__8")]
public Task WriteNotifications(CanAccessDatabase shouldWriteByDb, Task taskHandlingReceiveOfData);
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.NotificationCenterWebSocketWriter`1/<WriteToWebSocket>d__9`1")]
public sealed virtual Task WriteToWebSocket(TNotification notification);
    [AsyncStateMachineAttribute("Raven.Server.NotificationCenter.NotificationCenterWebSocketWriter`1/<SendHeartbeat>d__10")]
private Task SendHeartbeat();
    [DoesNotReturnAttribute]
private static void ThrowNotSupportedType(TNotification notification);
    public virtual void Dispose();
}
public class Raven.Server.NotificationCenter.Notifications.AlertRaised : Notification {
    [CompilerGeneratedAttribute]
private AlertType <AlertType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private INotificationDetails <Details>k__BackingField;
    public AlertType AlertType { get; private set; }
    public string Key { get; private set; }
    public string Id { get; }
    public INotificationDetails Details { get; private set; }
    private AlertRaised(string database, Nullable`1<DateTime> createdAt);
    [CompilerGeneratedAttribute]
public AlertType get_AlertType();
    [CompilerGeneratedAttribute]
private void set_AlertType(AlertType value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    public virtual string get_Id();
    [CompilerGeneratedAttribute]
public INotificationDetails get_Details();
    [CompilerGeneratedAttribute]
private void set_Details(INotificationDetails value);
    public virtual DynamicJsonValue ToJson();
    public static AlertRaised FromJson(string key, BlittableJsonReaderObject json, INotificationDetails details);
    public static AlertRaised Create(string database, string title, string msg, AlertType type, NotificationSeverity severity, string key, INotificationDetails details);
    public static string GetKey(AlertType alertType, string key);
}
public enum Raven.Server.NotificationCenter.Notifications.AlertType : Enum {
    public int value__;
    public static AlertType Etl_Error;
    public static AlertType Etl_Warning;
    public static AlertType Etl_TransformationError;
    public static AlertType Etl_LoadError;
    public static AlertType QueueSink_Error;
    public static AlertType QueueSink_Warning;
    public static AlertType QueueSink_ScriptError;
    public static AlertType QueueSink_ConsumeError;
    public static AlertType QueueSink_ConsumerCreationError;
    public static AlertType SqlEtl_ConnectionError;
    public static AlertType SqlEtl_ProviderError;
    public static AlertType Etl_InvalidScript;
    public static AlertType PeriodicBackup;
    public static AlertType Replication;
    public static AlertType Server_NewVersionAvailable;
    public static AlertType LicenseManager_InitializationError;
    public static AlertType LicenseManager_LeaseLicenseSuccess;
    public static AlertType LicenseManager_LeaseLicenseError;
    public static AlertType LicenseManager_LicenseUpdateMessage;
    public static AlertType LicenseManager_HighlyAvailableTasks;
    public static AlertType LicenseManager_LicenseLimit;
    public static AlertType LicenseManager_AGPL3;
    public static AlertType Certificates_Expiration;
    public static AlertType Certificates_DeveloperLetsEncryptRenewal;
    public static AlertType Certificates_EntireClusterReplaceSuccess;
    public static AlertType Certificates_ReplaceSuccess;
    public static AlertType Certificates_ReplaceError;
    public static AlertType Certificates_ReplacePending;
    public static AlertType IndexStore_IndexCouldNotBeOpened;
    public static AlertType WarnIndexOutputsPerDocument;
    public static AlertType ErrorSavingReduceOutputDocuments;
    public static AlertType CatastrophicDatabaseFailure;
    public static AlertType RecoverableVoronFailure;
    public static AlertType NonDurableFileSystem;
    public static AlertType RecoveryError;
    public static AlertType RestoreError;
    public static AlertType DeletionError;
    public static AlertType ClusterTopologyWarning;
    public static AlertType DatabaseTopologyWarning;
    public static AlertType SwappingHddInsteadOfSsd;
    public static AlertType RevisionsConfigurationNotValid;
    public static AlertType ArchivalConfigurationNotValid;
    public static AlertType ReplicationMissingAttachments;
    public static AlertType ClusterTransactionFailure;
    public static AlertType OutOfMemoryException;
    public static AlertType LowDiskSpace;
    public static AlertType UnexpectedIndexingThreadError;
    public static AlertType Indexing_UnexpectedIndexingThreadError;
    public static AlertType Indexing_CouldNotGetStats;
    public static AlertType Indexing_CoraxComplexItem;
    public static AlertType CpuUsageExtensionPointError;
    public static AlertType TcpListenerError;
    public static AlertType Throttling_CpuCreditsBalance;
    public static AlertType IntegrityErrorOfAlreadySyncedData;
    public static AlertType ConcurrentDatabaseLoadTimeout;
    public static AlertType HighClientCreationRate;
    public static AlertType RollupExceedNumberOfValues;
    public static AlertType LowSwapSize;
    public static AlertType UnrecoverableClusterError;
    public static AlertType MicrosoftLogsConfigurationLoadError;
    public static AlertType MismatchedReferenceLoad;
    public static AlertType BlockingTombstones;
    public static AlertType ServerLimits;
    public static AlertType ConflictRevisionsExceeded;
    public static AlertType SqlConnectionString_DeprecatedFactoryReplaced;
}
public class Raven.Server.NotificationCenter.Notifications.DatabaseStatsChanged : Notification {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfStaleIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfIndexingErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastIndexingErrorTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GlobalChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ModifiedCollection> <ModifiedCollections>k__BackingField;
    public string Id { get; }
    public long CountOfDocuments { get; private set; }
    public long CountOfConflicts { get; private set; }
    public long CountOfIndexes { get; private set; }
    public long CountOfStaleIndexes { get; private set; }
    public long CountOfIndexingErrors { get; private set; }
    public Nullable`1<DateTime> LastIndexingErrorTime { get; private set; }
    public string GlobalChangeVector { get; private set; }
    public long LastEtag { get; private set; }
    public List`1<ModifiedCollection> ModifiedCollections { get; private set; }
    private DatabaseStatsChanged(string database);
    [CompilerGeneratedAttribute]
public virtual string get_Id();
    [CompilerGeneratedAttribute]
public long get_CountOfDocuments();
    [CompilerGeneratedAttribute]
private void set_CountOfDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfConflicts();
    [CompilerGeneratedAttribute]
private void set_CountOfConflicts(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfIndexes();
    [CompilerGeneratedAttribute]
private void set_CountOfIndexes(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfStaleIndexes();
    [CompilerGeneratedAttribute]
private void set_CountOfStaleIndexes(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfIndexingErrors();
    [CompilerGeneratedAttribute]
private void set_CountOfIndexingErrors(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastIndexingErrorTime();
    [CompilerGeneratedAttribute]
private void set_LastIndexingErrorTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_GlobalChangeVector();
    [CompilerGeneratedAttribute]
private void set_GlobalChangeVector(string value);
    [CompilerGeneratedAttribute]
public long get_LastEtag();
    [CompilerGeneratedAttribute]
private void set_LastEtag(long value);
    [CompilerGeneratedAttribute]
public List`1<ModifiedCollection> get_ModifiedCollections();
    [CompilerGeneratedAttribute]
private void set_ModifiedCollections(List`1<ModifiedCollection> value);
    public virtual DynamicJsonValue ToJson();
    public static DatabaseStatsChanged Create(string database, long countOfConflicts, long countOfDocs, int countOfIndexes, int countOfStaleIndexes, string globalChangeVector, long lastEtag, long countOfIndexingErrors, Nullable`1<DateTime> lastIndexingErrorTime, List`1<ModifiedCollection> modifiedCollections);
}
public class Raven.Server.NotificationCenter.Notifications.Details.ComplexFieldsWarning : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <Fields>k__BackingField;
    public Dictionary`2<string, List`1<string>> Fields { get; public set; }
    public ComplexFieldsWarning(ConcurrentQueue`1<ValueTuple`2<string, string>> complexFields);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_Fields();
    [CompilerGeneratedAttribute]
public void set_Fields(Dictionary`2<string, List`1<string>> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.ConflictPerformanceDetails : object {
    [CompilerGeneratedAttribute]
private Queue`1<ActionDetails> <Details>k__BackingField;
    public Queue`1<ActionDetails> Details { get; public set; }
    [CompilerGeneratedAttribute]
public Queue`1<ActionDetails> get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(Queue`1<ActionDetails> value);
    public sealed virtual DynamicJsonValue ToJson();
    public void Update(ConflictInfo info);
}
public class Raven.Server.NotificationCenter.Notifications.Details.CpuCreditsExhaustionWarning : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <IndexNames>k__BackingField;
    public HashSet`1<string> IndexNames { get; public set; }
    public CpuCreditsExhaustionWarning(HashSet`1<string> indexNames);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_IndexNames();
    [CompilerGeneratedAttribute]
public void set_IndexNames(HashSet`1<string> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.EtlErrorInfo : object {
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Date>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public string DocumentId { get; public set; }
    public DateTime Date { get; public set; }
    public string Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Date();
    [CompilerGeneratedAttribute]
public void set_Date(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.EtlErrorsDetails : object {
    public static int MaxNumberOfErrors;
    [CompilerGeneratedAttribute]
private Queue`1<EtlErrorInfo> <Errors>k__BackingField;
    public Queue`1<EtlErrorInfo> Errors { get; public set; }
    [CompilerGeneratedAttribute]
public Queue`1<EtlErrorInfo> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(Queue`1<EtlErrorInfo> value);
    public void Add(EtlErrorInfo error);
    public void Update(Queue`1<EtlErrorInfo> errors);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.ExceptionDetails : object {
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    public string Exception { get; public set; }
    public ExceptionDetails(Exception e);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.HugeDocumentInfo : ValueType {
    public long Size;
    public DateTime Date;
    public string Id;
    public HugeDocumentInfo(long size, string id);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.HugeDocumentsDetails : object {
    private static int SizeLimit;
    private static double CleanupFactor;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, HugeDocumentInfo> <HugeDocuments>k__BackingField;
    public ConcurrentDictionary`2<string, HugeDocumentInfo> HugeDocuments { get; public set; }
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, HugeDocumentInfo> get_HugeDocuments();
    [CompilerGeneratedAttribute]
public void set_HugeDocuments(ConcurrentDictionary`2<string, HugeDocumentInfo> value);
    public void Update(string id, int size);
    private void EnforceLimits();
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.IndexingReferenceLoadWarning : object {
    internal static int MaxNumberOfDetailsPerIndex;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, WarningDetails> <Warnings>k__BackingField;
    public Dictionary`2<string, WarningDetails> Warnings { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, WarningDetails> get_Warnings();
    public void Update(string indexName, WarningDetails warning);
    public sealed virtual DynamicJsonValue ToJson();
}
public interface Raven.Server.NotificationCenter.Notifications.Details.INotificationDetails {
    public abstract virtual DynamicJsonValue ToJson();
}
internal class Raven.Server.NotificationCenter.Notifications.Details.LicenseLimitWarning : object {
    [CompilerGeneratedAttribute]
private LimitType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public LimitType Type { get; public set; }
    public string Message { get; public set; }
    private LicenseLimitWarning(LicenseLimitException licenseLimit);
    [CompilerGeneratedAttribute]
public LimitType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(LimitType value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public sealed virtual DynamicJsonValue ToJson();
    public static void AddLicenseLimitNotification(ServerNotificationCenter notificationCenter, LicenseLimitException licenseLimit);
    public static void DismissLicenseLimitNotification(ServerNotificationCenter notificationCenter, LimitType type);
}
public class Raven.Server.NotificationCenter.Notifications.Details.MessageDetails : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.MismatchedReferencesLoadWarning : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<WarningDetails>> <Warnings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    public Dictionary`2<string, List`1<WarningDetails>> Warnings { get; public set; }
    public string IndexName { get; public set; }
    public MismatchedReferencesLoadWarning(string indexName, Dictionary`2<string, Dictionary`2<string, LoadFailure>> mismatchedReferences);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<WarningDetails>> get_Warnings();
    [CompilerGeneratedAttribute]
public void set_Warnings(Dictionary`2<string, List`1<WarningDetails>> value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.NewVersionAvailableDetails : object {
    [CompilerGeneratedAttribute]
private VersionInfo <VersionInfo>k__BackingField;
    public VersionInfo VersionInfo { get; }
    public NewVersionAvailableDetails(VersionInfo versionInfo);
    [CompilerGeneratedAttribute]
public VersionInfo get_VersionInfo();
    public sealed virtual DynamicJsonValue ToJson();
}
public enum Raven.Server.NotificationCenter.Notifications.Details.PagingOperationType : Enum {
    public int value__;
    public static PagingOperationType Documents;
    public static PagingOperationType Queries;
    public static PagingOperationType Revisions;
    public static PagingOperationType CompareExchange;
}
internal class Raven.Server.NotificationCenter.Notifications.Details.PagingPerformanceDetails : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Queue`1<ActionDetails>> <Actions>k__BackingField;
    public Dictionary`2<string, Queue`1<ActionDetails>> Actions { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Queue`1<ActionDetails>> get_Actions();
    [CompilerGeneratedAttribute]
public void set_Actions(Dictionary`2<string, Queue`1<ActionDetails>> value);
    public sealed virtual DynamicJsonValue ToJson();
    public void Update(PagingInformation pagingInfo);
}
public class Raven.Server.NotificationCenter.Notifications.Details.QueueSinkErrorInfo : object {
    [CompilerGeneratedAttribute]
private DateTime <Date>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public DateTime Date { get; public set; }
    public string Error { get; public set; }
    public QueueSinkErrorInfo(string error);
    [CompilerGeneratedAttribute]
public DateTime get_Date();
    [CompilerGeneratedAttribute]
public void set_Date(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.QueueSinkErrorsDetails : object {
    public static int MaxNumberOfErrors;
    [CompilerGeneratedAttribute]
private Queue`1<QueueSinkErrorInfo> <Errors>k__BackingField;
    public Queue`1<QueueSinkErrorInfo> Errors { get; public set; }
    [CompilerGeneratedAttribute]
public Queue`1<QueueSinkErrorInfo> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(Queue`1<QueueSinkErrorInfo> value);
    public void Add(QueueSinkErrorInfo error);
    public void Update(Queue`1<QueueSinkErrorInfo> errors);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.RequestLatencyDetail : object {
    private static int RequestLatencyDetailLimit;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, ConcurrentQueue`1<RequestLatencyInfo>> <RequestLatencies>k__BackingField;
    public ConcurrentDictionary`2<string, ConcurrentQueue`1<RequestLatencyInfo>> RequestLatencies { get; public set; }
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, ConcurrentQueue`1<RequestLatencyInfo>> get_RequestLatencies();
    [CompilerGeneratedAttribute]
public void set_RequestLatencies(ConcurrentDictionary`2<string, ConcurrentQueue`1<RequestLatencyInfo>> value);
    public void Update(long duration, string action, string query);
    private static void EnforceLimitOfQueueLength(ConcurrentQueue`1<RequestLatencyInfo> hintQueue);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.RequestLatencyInfo : ValueType {
    public long Duration;
    public DateTime Date;
    public string Action;
    public string Query;
    public RequestLatencyInfo(long duration, string action, string query);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.ServerLimitsDetails : object {
    public static int MaxNumberOfLimits;
    [CompilerGeneratedAttribute]
private LinkedList`1<ServerLimitInfo> <Limits>k__BackingField;
    public LinkedList`1<ServerLimitInfo> Limits { get; public set; }
    [CompilerGeneratedAttribute]
public LinkedList`1<ServerLimitInfo> get_Limits();
    [CompilerGeneratedAttribute]
public void set_Limits(LinkedList`1<ServerLimitInfo> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.SlowIoDetails : object {
    public static int MaxNumberOfWrites;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SlowWriteInfo> <Writes>k__BackingField;
    public Dictionary`2<string, SlowWriteInfo> Writes { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SlowWriteInfo> get_Writes();
    [CompilerGeneratedAttribute]
public void set_Writes(Dictionary`2<string, SlowWriteInfo> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.SlowSqlDetails : object {
    public static int MaxNumberOfStatements;
    [CompilerGeneratedAttribute]
private Queue`1<SlowSqlStatementInfo> <Statements>k__BackingField;
    public Queue`1<SlowSqlStatementInfo> Statements { get; public set; }
    [CompilerGeneratedAttribute]
public Queue`1<SlowSqlStatementInfo> get_Statements();
    [CompilerGeneratedAttribute]
public void set_Statements(Queue`1<SlowSqlStatementInfo> value);
    public void Add(SlowSqlStatementInfo slowSql);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.SlowSqlStatementInfo : object {
    [CompilerGeneratedAttribute]
private long <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Date>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Statement>k__BackingField;
    public long Duration { get; public set; }
    public DateTime Date { get; public set; }
    public string Statement { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(long value);
    [CompilerGeneratedAttribute]
public DateTime get_Date();
    [CompilerGeneratedAttribute]
public void set_Date(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Statement();
    [CompilerGeneratedAttribute]
public void set_Statement(string value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.NotificationCenter.Notifications.Details.WarnIndexOutputsPerDocument : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Queue`1<WarningDetails>> <Warnings>k__BackingField;
    public Dictionary`2<string, Queue`1<WarningDetails>> Warnings { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Queue`1<WarningDetails>> get_Warnings();
    [CompilerGeneratedAttribute]
public void set_Warnings(Dictionary`2<string, Queue`1<WarningDetails>> value);
    public void Update(string indexName, WarningDetails warning);
    public sealed virtual DynamicJsonValue ToJson();
}
public abstract class Raven.Server.NotificationCenter.Notifications.Notification : object {
    public static string ServerWide;
    public static string AllDatabases;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private NotificationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPersistent>k__BackingField;
    [CompilerGeneratedAttribute]
private NotificationSeverity <Severity>k__BackingField;
    public string Id { get; }
    public DateTime CreatedAt { get; private set; }
    public NotificationType Type { get; }
    public string Database { get; }
    public string Title { get; protected set; }
    public string Message { get; protected set; }
    public bool IsPersistent { get; protected set; }
    public NotificationSeverity Severity { get; protected set; }
    protected Notification(NotificationType type, string database, Nullable`1<DateTime> createdAt);
    public abstract virtual string get_Id();
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
private void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public NotificationType get_Type();
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
protected void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
protected void set_Message(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPersistent();
    [CompilerGeneratedAttribute]
protected void set_IsPersistent(bool value);
    [CompilerGeneratedAttribute]
public NotificationSeverity get_Severity();
    [CompilerGeneratedAttribute]
protected void set_Severity(NotificationSeverity value);
    public void RefreshCreatedAt();
    public virtual DynamicJsonValue ToJson();
}
public enum Raven.Server.NotificationCenter.Notifications.NotificationSeverity : Enum {
    public int value__;
    public static NotificationSeverity None;
    public static NotificationSeverity Info;
    public static NotificationSeverity Warning;
    public static NotificationSeverity Success;
    public static NotificationSeverity Error;
}
public enum Raven.Server.NotificationCenter.Notifications.NotificationType : Enum {
    public int value__;
    public static NotificationType None;
    public static NotificationType AlertRaised;
    public static NotificationType OperationChanged;
    public static NotificationType DatabaseChanged;
    public static NotificationType NotificationUpdated;
    public static NotificationType RecentError;
    public static NotificationType PerformanceHint;
    public static NotificationType DatabaseStatsChanged;
    public static NotificationType ClusterTopologyChanged;
}
public class Raven.Server.NotificationCenter.Notifications.NotificationUpdated : Notification {
    [CompilerGeneratedAttribute]
private string <NotificationId>k__BackingField;
    [CompilerGeneratedAttribute]
private NotificationUpdateType <UpdateType>k__BackingField;
    public string Id { get; }
    public string NotificationId { get; private set; }
    public NotificationUpdateType UpdateType { get; private set; }
    public virtual string get_Id();
    [CompilerGeneratedAttribute]
public string get_NotificationId();
    [CompilerGeneratedAttribute]
private void set_NotificationId(string value);
    [CompilerGeneratedAttribute]
public NotificationUpdateType get_UpdateType();
    [CompilerGeneratedAttribute]
private void set_UpdateType(NotificationUpdateType value);
    public virtual DynamicJsonValue ToJson();
    public static NotificationUpdated Create(string id, NotificationUpdateType type);
}
public enum Raven.Server.NotificationCenter.Notifications.NotificationUpdateType : Enum {
    public int value__;
    public static NotificationUpdateType Postponed;
    public static NotificationUpdateType Dismissed;
}
public class Raven.Server.NotificationCenter.Notifications.OperationChanged : Notification {
    [CompilerGeneratedAttribute]
private long <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperationDetailedDescription <DetailedDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Killable>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationType <TaskType>k__BackingField;
    public string Id { get; }
    public long OperationId { get; private set; }
    public OperationState State { get; private set; }
    public IOperationDetailedDescription DetailedDescription { get; private set; }
    public bool Killable { get; private set; }
    public DateTime StartTime { get; private set; }
    public Nullable`1<DateTime> EndTime { get; private set; }
    public OperationType TaskType { get; private set; }
    private OperationChanged(string database);
    public virtual string get_Id();
    [CompilerGeneratedAttribute]
public long get_OperationId();
    [CompilerGeneratedAttribute]
private void set_OperationId(long value);
    [CompilerGeneratedAttribute]
public OperationState get_State();
    [CompilerGeneratedAttribute]
private void set_State(OperationState value);
    [CompilerGeneratedAttribute]
public IOperationDetailedDescription get_DetailedDescription();
    [CompilerGeneratedAttribute]
private void set_DetailedDescription(IOperationDetailedDescription value);
    [CompilerGeneratedAttribute]
public bool get_Killable();
    [CompilerGeneratedAttribute]
private void set_Killable(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_EndTime();
    [CompilerGeneratedAttribute]
private void set_EndTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public OperationType get_TaskType();
    [CompilerGeneratedAttribute]
private void set_TaskType(OperationType value);
    public virtual DynamicJsonValue ToJson();
    public static OperationChanged Create(string database, long id, OperationDescription description, OperationState state, bool killable);
}
public class Raven.Server.NotificationCenter.Notifications.PerformanceHint : Notification {
    [CompilerGeneratedAttribute]
private PerformanceHintType <HintType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private INotificationDetails <Details>k__BackingField;
    public PerformanceHintType HintType { get; private set; }
    public string Source { get; private set; }
    public string Id { get; }
    public INotificationDetails Details { get; private set; }
    private PerformanceHint(string database);
    [CompilerGeneratedAttribute]
public PerformanceHintType get_HintType();
    [CompilerGeneratedAttribute]
private void set_HintType(PerformanceHintType value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    public virtual string get_Id();
    [CompilerGeneratedAttribute]
public INotificationDetails get_Details();
    [CompilerGeneratedAttribute]
private void set_Details(INotificationDetails value);
    public virtual DynamicJsonValue ToJson();
    public static PerformanceHint Create(string database, string title, string msg, PerformanceHintType type, NotificationSeverity notificationSeverity, string source, INotificationDetails details);
    public static string GetKey(PerformanceHintType type, string source);
}
public enum Raven.Server.NotificationCenter.Notifications.PerformanceHintType : Enum {
    public int value__;
    public static PerformanceHintType None;
    public static PerformanceHintType Indexing;
    public static PerformanceHintType Replication;
    public static PerformanceHintType Paging;
    public static PerformanceHintType RequestLatency;
    public static PerformanceHintType UnusedCapacity;
    public static PerformanceHintType SlowIO;
    public static PerformanceHintType SqlEtl_SlowSql;
    public static PerformanceHintType HugeDocuments;
    public static PerformanceHintType Indexing_References;
}
public class Raven.Server.NotificationCenter.Notifications.Server.ClusterTopologyChanged : Notification {
    [CompilerGeneratedAttribute]
private ClusterTopology <Topology>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, NodeStatus> <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Leader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private RachisState <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DetailsPerNode> <NodeLicenseDetails>k__BackingField;
    public string Id { get; }
    public ClusterTopology Topology { get; private set; }
    public Dictionary`2<string, NodeStatus> Status { get; private set; }
    public string Leader { get; private set; }
    public string NodeTag { get; public set; }
    public long CurrentTerm { get; private set; }
    public RachisState CurrentState { get; public set; }
    public Dictionary`2<string, DetailsPerNode> NodeLicenseDetails { get; private set; }
    public virtual string get_Id();
    [CompilerGeneratedAttribute]
public ClusterTopology get_Topology();
    [CompilerGeneratedAttribute]
private void set_Topology(ClusterTopology value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, NodeStatus> get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(Dictionary`2<string, NodeStatus> value);
    [CompilerGeneratedAttribute]
public string get_Leader();
    [CompilerGeneratedAttribute]
private void set_Leader(string value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public long get_CurrentTerm();
    [CompilerGeneratedAttribute]
private void set_CurrentTerm(long value);
    [CompilerGeneratedAttribute]
public RachisState get_CurrentState();
    [CompilerGeneratedAttribute]
public void set_CurrentState(RachisState value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DetailsPerNode> get_NodeLicenseDetails();
    [CompilerGeneratedAttribute]
private void set_NodeLicenseDetails(Dictionary`2<string, DetailsPerNode> value);
    public virtual DynamicJsonValue ToJson();
    public static ClusterTopologyChanged Create(ClusterTopology clusterTopology, string leaderTag, string nodeTag, long term, RachisState state, Dictionary`2<string, NodeStatus> status, Dictionary`2<string, DetailsPerNode> nodeLicenseDetails);
}
public class Raven.Server.NotificationCenter.Notifications.Server.DatabaseChanged : Notification {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseChangeType <ChangeType>k__BackingField;
    public string Id { get; }
    public string DatabaseName { get; private set; }
    public DatabaseChangeType ChangeType { get; private set; }
    private DatabaseChanged(string database);
    public virtual string get_Id();
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
private void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public DatabaseChangeType get_ChangeType();
    [CompilerGeneratedAttribute]
private void set_ChangeType(DatabaseChangeType value);
    public virtual DynamicJsonValue ToJson();
    public static DatabaseChanged Create(string databaseName, DatabaseChangeType change);
}
public enum Raven.Server.NotificationCenter.Notifications.Server.DatabaseChangeType : Enum {
    public int value__;
    public static DatabaseChangeType Load;
    public static DatabaseChangeType Put;
    public static DatabaseChangeType Update;
    public static DatabaseChangeType Delete;
    public static DatabaseChangeType RemoveNode;
}
public abstract class Raven.Server.NotificationCenter.NotificationsBase : object {
    private object _watchersLock;
    [CompilerGeneratedAttribute]
private ConcurrentSet`1<ConnectedWatcher> <Watchers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BackgroundWorkBase> <BackgroundWorkers>k__BackingField;
    private State _state;
    protected ConcurrentSet`1<ConnectedWatcher> Watchers { get; }
    protected List`1<BackgroundWorkBase> BackgroundWorkers { get; }
    public Task WaitForAnyWebSocketClient { get; }
    public Task WaitForRemoveAllWebSocketClients { get; }
    [CompilerGeneratedAttribute]
protected ConcurrentSet`1<ConnectedWatcher> get_Watchers();
    [CompilerGeneratedAttribute]
protected List`1<BackgroundWorkBase> get_BackgroundWorkers();
    public Task get_WaitForAnyWebSocketClient();
    public Task get_WaitForRemoveAllWebSocketClients();
    public IDisposable TrackActions(AsyncQueue`1<DynamicJsonValue> notificationsQueue, IWebsocketWriter webSocketWriter, CanAccessDatabase shouldWriteByDb);
    private void StartBackgroundWorkers();
    private void StopBackgroundWorkers();
    public virtual void Dispose();
}
public class Raven.Server.NotificationCenter.NotificationsStorage : object {
    private string _tableName;
    private Logger Logger;
    private StorageEnvironment _environment;
    private TransactionContextPool _contextPool;
    private long _postponeDateNotSpecified;
    public NotificationsStorage(string resourceName);
    public void Initialize(StorageEnvironment environment, TransactionContextPool contextPool);
    public bool Store(Notification notification, Nullable`1<DateTime> postponeUntil, bool updateExisting);
    internal void Store(LazyStringValue id, DateTime createdAt, Nullable`1<DateTime> postponedUntil, BlittableJsonReaderObject action, RavenTransaction tx);
    public IDisposable ReadActionsOrderedByCreationDate(IEnumerable`1& actions);
    public IDisposable Read(string id, NotificationTableValue& value);
    [IteratorStateMachineAttribute("Raven.Server.NotificationCenter.NotificationsStorage/<ReadActionsByCreatedAtIndex>d__11")]
private IEnumerable`1<NotificationTableValue> ReadActionsByCreatedAtIndex(TransactionOperationContext context);
    public IDisposable ReadPostponedActions(IEnumerable`1& actions, DateTime cutoff);
    [IteratorStateMachineAttribute("Raven.Server.NotificationCenter.NotificationsStorage/<ReadPostponedActionsByPostponedUntilIndex>d__13")]
private IEnumerable`1<NotificationTableValue> ReadPostponedActionsByPostponedUntilIndex(TransactionOperationContext context, DateTime cutoff);
    private NotificationTableValue Get(string id, JsonOperationContext context, RavenTransaction tx);
    public bool Delete(string id, RavenTransaction existingTransaction);
    public bool Exists(string id);
    public long GetAlertCount();
    public long GetPerformanceHintCount();
    private long GetNotificationCount(string notificationType);
    private NotificationTableValue Read(JsonOperationContext context, TableValueReader& reader);
    public string GetDatabaseFor(string id);
    public void ChangePostponeDate(string id, Nullable`1<DateTime> postponeUntil);
    private void Cleanup();
    private static string GetTableName(string resourceName);
    private void RemoveNewVersionAvailableAlertIfNecessary();
    [DoesNotReturnAttribute]
private static void ThrowCouldNotFindNotificationType(NotificationTableValue action);
    public NotificationsStorage GetStorageFor(string database);
    public void DeleteStorageFor(string database);
    public void DeleteStorageFor(TransactionOperationContext`1<T> ctx, string database);
    [CompilerGeneratedAttribute]
private bool <Delete>g__DeleteFromTable|15_0(RavenTransaction tx, <>c__DisplayClass15_0& );
}
public class Raven.Server.NotificationCenter.NotificationTableValue : object {
    public BlittableJsonReaderObject Json;
    public DateTime CreatedAt;
    public Nullable`1<DateTime> PostponedUntil;
    public sealed virtual void Dispose();
}
public class Raven.Server.NotificationCenter.OutOfMemoryNotifications : object {
    private TimeSpan _updateFrequency;
    private ConditionalWeakTable`2<StorageEnvironment, ConcurrentDictionary`2<Type, NotificationTime>> _notificationsMetadataTable;
    private AbstractNotificationCenter _notificationsCenter;
    public OutOfMemoryNotifications(AbstractNotificationCenter notificationsCenter);
    public void Add(StorageEnvironment environment, Exception exception);
    private static MessageDetails OutOfMemoryDetails(Exception exception);
}
public class Raven.Server.NotificationCenter.Paging : object {
    private static string PagingDocumentsId;
    private static string PagingQueriesId;
    private static string PagingRevisionsId;
    private static string PagingCompareExchangeId;
    private AbstractDatabaseNotificationCenter _notificationCenter;
    private object _locker;
    private ConcurrentQueue`1<PagingInformation> _pagingQueue;
    private DateTime[] _pagingUpdates;
    private Timer _pagingTimer;
    private Logger _logger;
    internal TestingStuff ForTestingPurposes;
    public Paging(AbstractDatabaseNotificationCenter notificationCenter);
    private static Paging();
    public void Add(PagingOperationType operation, string action, string details, long numberOfResults, long pageSize, long duration, long totalDocumentsSizeInBytes);
    private void UpdatePaging(object state);
    internal bool UpdatePagingInternal(object state, String& reasonOfNotUpdating);
    private PerformanceHint GetPagingPerformanceHint(string id, PagingOperationType type);
    internal TestingStuff ForTestingPurposesOnly();
    public sealed virtual void Dispose();
}
public class Raven.Server.NotificationCenter.QueueSinkNotifications : object {
    private AbstractDatabaseNotificationCenter _notificationCenter;
    public QueueSinkNotifications(AbstractDatabaseNotificationCenter notificationCenter);
    public AlertRaised AddScriptErrors(string processTag, string processName, Queue`1<QueueSinkErrorInfo> errors, string preMessage);
    public AlertRaised AddConsumeErrors(string processTag, string processName, Queue`1<QueueSinkErrorInfo> errors, string preMessage);
    private AlertRaised AddErrorAlert(Queue`1<QueueSinkErrorInfo> errors, QueueSinkErrorsDetails details, AlertRaised alert);
    private AlertRaised GetOrCreateAlert(string processTag, string processName, AlertType alertType, string message, T& details);
    public T GetAlert(string processTag, string processName, AlertType alertType);
    private T GetDetails(NotificationTableValue ntv);
}
public class Raven.Server.NotificationCenter.RequestLatency : object {
    private static string QueryRequestLatenciesId;
    private object _locker;
    private Logger _logger;
    private AbstractDatabaseNotificationCenter _notificationCenter;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _needsSync;
    private PerformanceHint _performanceHint;
    private RequestLatencyDetail _details;
    private Timer _timer;
    public RequestLatency(AbstractDatabaseNotificationCenter notificationCenter);
    private static RequestLatency();
    public void AddHint(long duration, string action, string query);
    internal void UpdateRequestLatency(object state);
    public RequestLatencyDetail GetRequestLatencyDetails();
    private PerformanceHint GetOrCreatePerformanceLatencies(RequestLatencyDetail& details);
    public sealed virtual void Dispose();
}
public class Raven.Server.NotificationCenter.RequestTimeTracker : object {
    private HttpContext _context;
    private Logger _logger;
    private AbstractDatabaseNotificationCenter _notificationCenter;
    private RavenConfiguration _configuration;
    private string _source;
    private bool _doPerformanceHintIfTooLong;
    private Stopwatch _sw;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <QueryParameters>k__BackingField;
    public string Query { get; public set; }
    public BlittableJsonReaderObject QueryParameters { get; public set; }
    public RequestTimeTracker(HttpContext context, Logger logger, AbstractDatabaseNotificationCenter notificationCenter, RavenConfiguration configuration, string source, bool doPerformanceHintIfTooLong);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_QueryParameters();
    [CompilerGeneratedAttribute]
public void set_QueryParameters(BlittableJsonReaderObject value);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__8_0(object state);
}
public class Raven.Server.NotificationCenter.ServerNotificationCenter : AbstractNotificationCenter {
    [CompilerGeneratedAttribute]
private PostponedNotificationsSender <PostponedNotificationSender>k__BackingField;
    protected PostponedNotificationsSender PostponedNotificationSender { get; }
    public ServerNotificationCenter(ServerStore serverStore, NotificationsStorage storage);
    [CompilerGeneratedAttribute]
protected virtual PostponedNotificationsSender get_PostponedNotificationSender();
}
public class Raven.Server.NotificationCenter.SlowWriteNotifications : object {
    internal TimeSpan UpdateFrequency;
    private AbstractDatabaseNotificationCenter _notificationCenter;
    private Timer _timer;
    private bool _updateNotificationInStorageRequired;
    private object _pagerCreationLock;
    private ConcurrentDictionary`2<string, SlowWriteInfo> _slowWrites;
    private Logger _logger;
    private bool _shouldUpdateStorageKeys;
    public SlowWriteNotifications(AbstractDatabaseNotificationCenter notificationCenter);
    public void Add(IoChange ioChange);
    internal void UpdateNotificationInStorage(object state);
    internal SlowIoDetails GetSlowIoDetails();
    private PerformanceHint GetOrCreateSlowIoPerformanceHint(SlowIoDetails& details);
    private void UpdateStorageKeysIfNeeded(SlowIoDetails details);
    public sealed virtual void Dispose();
}
public class Raven.Server.NotificationCenter.TombstoneDeletionBlockageSource : object {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private TombstoneDeletionBlockerType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public long TaskId { get; }
    public TombstoneDeletionBlockerType Type { get; }
    public string Name { get; }
    public TombstoneDeletionBlockageSource(TombstoneDeletionBlockerType blockerType, string name, long taskId);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public TombstoneDeletionBlockerType get_Type();
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual bool Equals(TombstoneDeletionBlockageSource other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Server.NotificationCenter.TombstoneNotifications : object {
    private AbstractDatabaseNotificationCenter _notificationCenter;
    public TombstoneNotifications(AbstractDatabaseNotificationCenter notificationCenter);
    public void Add(List`1<BlockingTombstoneDetails> blockingTombstones);
    public List`1<BlockingTombstoneDetails> GetNotificationDetails(string id);
}
public class Raven.Server.Platform.Posix.LimitsInfo : object {
    [CompilerGeneratedAttribute]
private long <MapCountMax>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MapCountCurrent>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ThreadsMax>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ThreadsCurrent>k__BackingField;
    public static ConcurrentDictionary`2<string, PropertyInfo> AllProperties;
    public static LimitsInfo Invalid;
    public static LimitsInfo Current;
    [SnmpIndexAttribute("1")]
[DescriptionAttribute("Value of the '/proc/sys/vm/max_map_count' parameter")]
public long MapCountMax { get; public set; }
    [SnmpIndexAttribute("2")]
[DescriptionAttribute("Number of current map files in '/proc/self/maps'")]
public long MapCountCurrent { get; public set; }
    [SnmpIndexAttribute("3")]
[DescriptionAttribute("Value of the '/proc/sys/kernel/threads-max' parameter")]
public long ThreadsMax { get; public set; }
    [SnmpIndexAttribute("4")]
[DescriptionAttribute("Number of current threads")]
public long ThreadsCurrent { get; public set; }
    private static LimitsInfo();
    [CompilerGeneratedAttribute]
public long get_MapCountMax();
    [CompilerGeneratedAttribute]
public void set_MapCountMax(long value);
    [CompilerGeneratedAttribute]
public long get_MapCountCurrent();
    [CompilerGeneratedAttribute]
public void set_MapCountCurrent(long value);
    [CompilerGeneratedAttribute]
public long get_ThreadsMax();
    [CompilerGeneratedAttribute]
public void set_ThreadsMax(long value);
    [CompilerGeneratedAttribute]
public long get_ThreadsCurrent();
    [CompilerGeneratedAttribute]
public void set_ThreadsCurrent(long value);
    public void SetValues();
    public void Set(string name, long value);
    private static string NormalizePropertyName(MemberInfo memberInfo);
    [CompilerGeneratedAttribute]
internal static int <.cctor>g__GetPropertySnmpIndex|19_0(MemberInfo memberInfo);
}
public static class Raven.Server.Platform.Posix.LimitsReader : object {
    public static string MaxMapCountFilePath;
    public static string CurrentMapCountFilePath;
    public static string ThreadsMaxFilePath;
    public static string ThreadsCurrentFilePath;
    private static SemaphoreSlim _lock;
    private static LimitsReader();
    public static Task`1<LimitsInfo> ReadCurrentLimitsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Platform.Posix.LimitsReader/<ReadCurrentLimitsForWindowsAsync>d__6")]
private static Task`1<LimitsInfo> ReadCurrentLimitsForWindowsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Platform.Posix.LimitsReader/<ReadCurrentLimitsForLinuxAsync>d__7")]
private static Task`1<LimitsInfo> ReadCurrentLimitsForLinuxAsync();
    public static LimitsInfo ReadMaxLimits();
    private static long GetMaxValueForLimit(string limit);
    private static long GetMaxThreadsCount();
    private static long GetMaxMapCount();
    private static long GetCurrentThreadsCount();
    [AsyncStateMachineAttribute("Raven.Server.Platform.Posix.LimitsReader/<GetCurrentMapCountAsync>d__13")]
private static Task`1<long> GetCurrentMapCountAsync();
    [AsyncStateMachineAttribute("Raven.Server.Platform.Posix.LimitsReader/<GetEolCountAsync>d__14")]
private static Task`1<long> GetEolCountAsync(Stream stream);
    private static bool TryReadLine(ReadOnlySequence`1& buffer);
}
public class Raven.Server.Platform.Posix.MemInfo : object {
    public static Dictionary`2<string, PropertyInfo> AllProperties;
    public static MemInfo Invalid;
    [CompilerGeneratedAttribute]
private Size <MemTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MemFree>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Buffers>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Cached>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SwapCached>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Active>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Inactive>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Active_anon>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Inactive_anon>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Active_file>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Inactive_file>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Unevictable>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Mlocked>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SwapTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SwapFree>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Dirty>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Writeback>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <AnonPages>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Mapped>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Shmem>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Slab>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SReclaimable>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SUnreclaim>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <KernelStack>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <PageTables>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <NFS_Unstable>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Bounce>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <WritebackTmp>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <CommitLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Committed_AS>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <VmallocTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <VmallocUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <VmallocChunk>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <HardwareCorrupted>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <AnonHugePages>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <HugePages_Total>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <HugePages_Free>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <HugePages_Rsvd>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <HugePages_Surp>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Hugepagesize>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <DirectMap4k>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <DirectMap4M>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MemAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <KReclaimable>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Percpu>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <ShmemHugePages>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <ShmemPmdMapped>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <FileHugePages>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <FilePmdMapped>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Hugetlb>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <DirectMap2M>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <DirectMap1G>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <CmaTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <CmaFree>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Zswap>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Zswapped>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <SecPageTables>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <Unaccepted>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Size> <Other>k__BackingField;
    [SnmpIndexAttribute("1")]
public Size MemTotal { get; public set; }
    [SnmpIndexAttribute("2")]
public Size MemFree { get; public set; }
    [SnmpIndexAttribute("3")]
public Size Buffers { get; public set; }
    [SnmpIndexAttribute("4")]
public Size Cached { get; public set; }
    [SnmpIndexAttribute("5")]
public Size SwapCached { get; public set; }
    [SnmpIndexAttribute("6")]
public Size Active { get; public set; }
    [SnmpIndexAttribute("7")]
public Size Inactive { get; public set; }
    [SnmpIndexAttribute("8")]
[DisplayNameAttribute("Active(anon)")]
public Size Active_anon { get; public set; }
    [SnmpIndexAttribute("9")]
[DisplayNameAttribute("Inactive(anon)")]
public Size Inactive_anon { get; public set; }
    [SnmpIndexAttribute("10")]
[DisplayNameAttribute("Active(file)")]
public Size Active_file { get; public set; }
    [SnmpIndexAttribute("11")]
[DisplayNameAttribute("Inactive(file)")]
public Size Inactive_file { get; public set; }
    [SnmpIndexAttribute("12")]
public Size Unevictable { get; public set; }
    [SnmpIndexAttribute("13")]
public Size Mlocked { get; public set; }
    [SnmpIndexAttribute("14")]
public Size SwapTotal { get; public set; }
    [SnmpIndexAttribute("15")]
public Size SwapFree { get; public set; }
    [SnmpIndexAttribute("16")]
public Size Dirty { get; public set; }
    [SnmpIndexAttribute("17")]
public Size Writeback { get; public set; }
    [SnmpIndexAttribute("18")]
public Size AnonPages { get; public set; }
    [SnmpIndexAttribute("19")]
public Size Mapped { get; public set; }
    [SnmpIndexAttribute("20")]
public Size Shmem { get; public set; }
    [SnmpIndexAttribute("21")]
public Size Slab { get; public set; }
    [SnmpIndexAttribute("22")]
public Size SReclaimable { get; public set; }
    [SnmpIndexAttribute("23")]
public Size SUnreclaim { get; public set; }
    [SnmpIndexAttribute("24")]
public Size KernelStack { get; public set; }
    [SnmpIndexAttribute("25")]
public Size PageTables { get; public set; }
    [SnmpIndexAttribute("26")]
public Size NFS_Unstable { get; public set; }
    [SnmpIndexAttribute("27")]
public Size Bounce { get; public set; }
    [SnmpIndexAttribute("28")]
public Size WritebackTmp { get; public set; }
    [SnmpIndexAttribute("29")]
public Size CommitLimit { get; public set; }
    [SnmpIndexAttribute("30")]
public Size Committed_AS { get; public set; }
    [SnmpIndexAttribute("31")]
public Size VmallocTotal { get; public set; }
    [SnmpIndexAttribute("32")]
public Size VmallocUsed { get; public set; }
    [SnmpIndexAttribute("33")]
public Size VmallocChunk { get; public set; }
    [SnmpIndexAttribute("34")]
public Size HardwareCorrupted { get; public set; }
    [SnmpIndexAttribute("35")]
public Size AnonHugePages { get; public set; }
    [SnmpIndexAttribute("36")]
public Size HugePages_Total { get; public set; }
    [SnmpIndexAttribute("37")]
public Size HugePages_Free { get; public set; }
    [SnmpIndexAttribute("38")]
public Size HugePages_Rsvd { get; public set; }
    [SnmpIndexAttribute("39")]
public Size HugePages_Surp { get; public set; }
    [SnmpIndexAttribute("40")]
public Size Hugepagesize { get; public set; }
    [SnmpIndexAttribute("41")]
public Size DirectMap4k { get; public set; }
    [SnmpIndexAttribute("42")]
public Size DirectMap4M { get; public set; }
    [SnmpIndexAttribute("43")]
public Size MemAvailable { get; public set; }
    [SnmpIndexAttribute("44")]
public Size KReclaimable { get; public set; }
    [SnmpIndexAttribute("45")]
public Size Percpu { get; public set; }
    [SnmpIndexAttribute("46")]
public Size ShmemHugePages { get; public set; }
    [SnmpIndexAttribute("47")]
public Size ShmemPmdMapped { get; public set; }
    [SnmpIndexAttribute("48")]
public Size FileHugePages { get; public set; }
    [SnmpIndexAttribute("49")]
public Size FilePmdMapped { get; public set; }
    [SnmpIndexAttribute("50")]
public Size Hugetlb { get; public set; }
    [SnmpIndexAttribute("51")]
public Size DirectMap2M { get; public set; }
    [SnmpIndexAttribute("52")]
public Size DirectMap1G { get; public set; }
    [SnmpIndexAttribute("53")]
public Size CmaTotal { get; public set; }
    [SnmpIndexAttribute("54")]
public Size CmaFree { get; public set; }
    [SnmpIndexAttribute("55")]
public Size Zswap { get; public set; }
    [SnmpIndexAttribute("56")]
public Size Zswapped { get; public set; }
    [SnmpIndexAttribute("57")]
public Size SecPageTables { get; public set; }
    [SnmpIndexAttribute("58")]
public Size Unaccepted { get; public set; }
    public Dictionary`2<string, Size> Other { get; public set; }
    private static MemInfo();
    [CompilerGeneratedAttribute]
public Size get_MemTotal();
    [CompilerGeneratedAttribute]
public void set_MemTotal(Size value);
    [CompilerGeneratedAttribute]
public Size get_MemFree();
    [CompilerGeneratedAttribute]
public void set_MemFree(Size value);
    [CompilerGeneratedAttribute]
public Size get_Buffers();
    [CompilerGeneratedAttribute]
public void set_Buffers(Size value);
    [CompilerGeneratedAttribute]
public Size get_Cached();
    [CompilerGeneratedAttribute]
public void set_Cached(Size value);
    [CompilerGeneratedAttribute]
public Size get_SwapCached();
    [CompilerGeneratedAttribute]
public void set_SwapCached(Size value);
    [CompilerGeneratedAttribute]
public Size get_Active();
    [CompilerGeneratedAttribute]
public void set_Active(Size value);
    [CompilerGeneratedAttribute]
public Size get_Inactive();
    [CompilerGeneratedAttribute]
public void set_Inactive(Size value);
    [CompilerGeneratedAttribute]
public Size get_Active_anon();
    [CompilerGeneratedAttribute]
public void set_Active_anon(Size value);
    [CompilerGeneratedAttribute]
public Size get_Inactive_anon();
    [CompilerGeneratedAttribute]
public void set_Inactive_anon(Size value);
    [CompilerGeneratedAttribute]
public Size get_Active_file();
    [CompilerGeneratedAttribute]
public void set_Active_file(Size value);
    [CompilerGeneratedAttribute]
public Size get_Inactive_file();
    [CompilerGeneratedAttribute]
public void set_Inactive_file(Size value);
    [CompilerGeneratedAttribute]
public Size get_Unevictable();
    [CompilerGeneratedAttribute]
public void set_Unevictable(Size value);
    [CompilerGeneratedAttribute]
public Size get_Mlocked();
    [CompilerGeneratedAttribute]
public void set_Mlocked(Size value);
    [CompilerGeneratedAttribute]
public Size get_SwapTotal();
    [CompilerGeneratedAttribute]
public void set_SwapTotal(Size value);
    [CompilerGeneratedAttribute]
public Size get_SwapFree();
    [CompilerGeneratedAttribute]
public void set_SwapFree(Size value);
    [CompilerGeneratedAttribute]
public Size get_Dirty();
    [CompilerGeneratedAttribute]
public void set_Dirty(Size value);
    [CompilerGeneratedAttribute]
public Size get_Writeback();
    [CompilerGeneratedAttribute]
public void set_Writeback(Size value);
    [CompilerGeneratedAttribute]
public Size get_AnonPages();
    [CompilerGeneratedAttribute]
public void set_AnonPages(Size value);
    [CompilerGeneratedAttribute]
public Size get_Mapped();
    [CompilerGeneratedAttribute]
public void set_Mapped(Size value);
    [CompilerGeneratedAttribute]
public Size get_Shmem();
    [CompilerGeneratedAttribute]
public void set_Shmem(Size value);
    [CompilerGeneratedAttribute]
public Size get_Slab();
    [CompilerGeneratedAttribute]
public void set_Slab(Size value);
    [CompilerGeneratedAttribute]
public Size get_SReclaimable();
    [CompilerGeneratedAttribute]
public void set_SReclaimable(Size value);
    [CompilerGeneratedAttribute]
public Size get_SUnreclaim();
    [CompilerGeneratedAttribute]
public void set_SUnreclaim(Size value);
    [CompilerGeneratedAttribute]
public Size get_KernelStack();
    [CompilerGeneratedAttribute]
public void set_KernelStack(Size value);
    [CompilerGeneratedAttribute]
public Size get_PageTables();
    [CompilerGeneratedAttribute]
public void set_PageTables(Size value);
    [CompilerGeneratedAttribute]
public Size get_NFS_Unstable();
    [CompilerGeneratedAttribute]
public void set_NFS_Unstable(Size value);
    [CompilerGeneratedAttribute]
public Size get_Bounce();
    [CompilerGeneratedAttribute]
public void set_Bounce(Size value);
    [CompilerGeneratedAttribute]
public Size get_WritebackTmp();
    [CompilerGeneratedAttribute]
public void set_WritebackTmp(Size value);
    [CompilerGeneratedAttribute]
public Size get_CommitLimit();
    [CompilerGeneratedAttribute]
public void set_CommitLimit(Size value);
    [CompilerGeneratedAttribute]
public Size get_Committed_AS();
    [CompilerGeneratedAttribute]
public void set_Committed_AS(Size value);
    [CompilerGeneratedAttribute]
public Size get_VmallocTotal();
    [CompilerGeneratedAttribute]
public void set_VmallocTotal(Size value);
    [CompilerGeneratedAttribute]
public Size get_VmallocUsed();
    [CompilerGeneratedAttribute]
public void set_VmallocUsed(Size value);
    [CompilerGeneratedAttribute]
public Size get_VmallocChunk();
    [CompilerGeneratedAttribute]
public void set_VmallocChunk(Size value);
    [CompilerGeneratedAttribute]
public Size get_HardwareCorrupted();
    [CompilerGeneratedAttribute]
public void set_HardwareCorrupted(Size value);
    [CompilerGeneratedAttribute]
public Size get_AnonHugePages();
    [CompilerGeneratedAttribute]
public void set_AnonHugePages(Size value);
    [CompilerGeneratedAttribute]
public Size get_HugePages_Total();
    [CompilerGeneratedAttribute]
public void set_HugePages_Total(Size value);
    [CompilerGeneratedAttribute]
public Size get_HugePages_Free();
    [CompilerGeneratedAttribute]
public void set_HugePages_Free(Size value);
    [CompilerGeneratedAttribute]
public Size get_HugePages_Rsvd();
    [CompilerGeneratedAttribute]
public void set_HugePages_Rsvd(Size value);
    [CompilerGeneratedAttribute]
public Size get_HugePages_Surp();
    [CompilerGeneratedAttribute]
public void set_HugePages_Surp(Size value);
    [CompilerGeneratedAttribute]
public Size get_Hugepagesize();
    [CompilerGeneratedAttribute]
public void set_Hugepagesize(Size value);
    [CompilerGeneratedAttribute]
public Size get_DirectMap4k();
    [CompilerGeneratedAttribute]
public void set_DirectMap4k(Size value);
    [CompilerGeneratedAttribute]
public Size get_DirectMap4M();
    [CompilerGeneratedAttribute]
public void set_DirectMap4M(Size value);
    [CompilerGeneratedAttribute]
public Size get_MemAvailable();
    [CompilerGeneratedAttribute]
public void set_MemAvailable(Size value);
    [CompilerGeneratedAttribute]
public Size get_KReclaimable();
    [CompilerGeneratedAttribute]
public void set_KReclaimable(Size value);
    [CompilerGeneratedAttribute]
public Size get_Percpu();
    [CompilerGeneratedAttribute]
public void set_Percpu(Size value);
    [CompilerGeneratedAttribute]
public Size get_ShmemHugePages();
    [CompilerGeneratedAttribute]
public void set_ShmemHugePages(Size value);
    [CompilerGeneratedAttribute]
public Size get_ShmemPmdMapped();
    [CompilerGeneratedAttribute]
public void set_ShmemPmdMapped(Size value);
    [CompilerGeneratedAttribute]
public Size get_FileHugePages();
    [CompilerGeneratedAttribute]
public void set_FileHugePages(Size value);
    [CompilerGeneratedAttribute]
public Size get_FilePmdMapped();
    [CompilerGeneratedAttribute]
public void set_FilePmdMapped(Size value);
    [CompilerGeneratedAttribute]
public Size get_Hugetlb();
    [CompilerGeneratedAttribute]
public void set_Hugetlb(Size value);
    [CompilerGeneratedAttribute]
public Size get_DirectMap2M();
    [CompilerGeneratedAttribute]
public void set_DirectMap2M(Size value);
    [CompilerGeneratedAttribute]
public Size get_DirectMap1G();
    [CompilerGeneratedAttribute]
public void set_DirectMap1G(Size value);
    [CompilerGeneratedAttribute]
public Size get_CmaTotal();
    [CompilerGeneratedAttribute]
public void set_CmaTotal(Size value);
    [CompilerGeneratedAttribute]
public Size get_CmaFree();
    [CompilerGeneratedAttribute]
public void set_CmaFree(Size value);
    [CompilerGeneratedAttribute]
public Size get_Zswap();
    [CompilerGeneratedAttribute]
public void set_Zswap(Size value);
    [CompilerGeneratedAttribute]
public Size get_Zswapped();
    [CompilerGeneratedAttribute]
public void set_Zswapped(Size value);
    [CompilerGeneratedAttribute]
public Size get_SecPageTables();
    [CompilerGeneratedAttribute]
public void set_SecPageTables(Size value);
    [CompilerGeneratedAttribute]
public Size get_Unaccepted();
    [CompilerGeneratedAttribute]
public void set_Unaccepted(Size value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Size> get_Other();
    [CompilerGeneratedAttribute]
public void set_Other(Dictionary`2<string, Size> value);
    public void Set(string name, long value, SizeUnit unit);
    [CompilerGeneratedAttribute]
internal static string <.cctor>g__NormalizePropertyName|2_0(MemberInfo memberInfo);
    [CompilerGeneratedAttribute]
internal static int <.cctor>g__GetPropertySnmpIndex|2_1(MemberInfo memberInfo);
}
public static class Raven.Server.Platform.Posix.MemInfoReader : object {
    internal static string MemInfoFileName;
    private static Char[] Separators;
    private static MemInfoReader();
    public static MemInfo Read();
    public static MemInfo Read(Stream stream);
}
public class Raven.Server.Program : object {
    private static Logger Logger;
    public static ManualResetEvent ShutdownServerMre;
    public static ManualResetEvent RestartServerMre;
    public static ManualResetEvent ShutdownCompleteMre;
    public static Action RestartServer;
    public static bool IsRunningNonInteractive;
    private static Program();
    public static int Main(String[] args);
    private static void UseOnlyInvariantCultureInRavenDB();
    private static void SetCurrentDirectoryToServerPath();
    private static void InitializeThreadPoolThreads(RavenConfiguration configuration);
    public static bool RunAsNonInteractive();
    private static bool RunInteractive(RavenServer server);
    public static void WriteServerStatsAndWaitForEsc(RavenServer server);
    public static void WriteThreadsInfoAndWaitForEsc(RavenServer server, int maxTopThreads, int updateIntervalInMs, double cpuUsageThreshold);
}
public enum Raven.Server.Rachis.AmbassadorStatus : Enum {
    public int value__;
    public static AmbassadorStatus None;
    public static AmbassadorStatus Started;
    public static AmbassadorStatus Connected;
    public static AmbassadorStatus FailedToConnect;
    public static AmbassadorStatus Disconnected;
    public static AmbassadorStatus Closed;
    public static AmbassadorStatus Error;
}
public class Raven.Server.Rachis.AppendEntries : object {
    [CompilerGeneratedAttribute]
private long <Term>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PrevLogIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PrevLogTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LeaderCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TruncateLogBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EntriesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceElections>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TimeAsLeader>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendingThread>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinCommandVersion>k__BackingField;
    public long Term { get; public set; }
    public long PrevLogIndex { get; public set; }
    public long PrevLogTerm { get; public set; }
    public long LeaderCommit { get; public set; }
    public long TruncateLogBefore { get; public set; }
    public int EntriesCount { get; public set; }
    public bool ForceElections { get; public set; }
    public long TimeAsLeader { get; public set; }
    public int SendingThread { get; public set; }
    public int MinCommandVersion { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Term();
    [CompilerGeneratedAttribute]
public void set_Term(long value);
    [CompilerGeneratedAttribute]
public long get_PrevLogIndex();
    [CompilerGeneratedAttribute]
public void set_PrevLogIndex(long value);
    [CompilerGeneratedAttribute]
public long get_PrevLogTerm();
    [CompilerGeneratedAttribute]
public void set_PrevLogTerm(long value);
    [CompilerGeneratedAttribute]
public long get_LeaderCommit();
    [CompilerGeneratedAttribute]
public void set_LeaderCommit(long value);
    [CompilerGeneratedAttribute]
public long get_TruncateLogBefore();
    [CompilerGeneratedAttribute]
public void set_TruncateLogBefore(long value);
    [CompilerGeneratedAttribute]
public int get_EntriesCount();
    [CompilerGeneratedAttribute]
public void set_EntriesCount(int value);
    [CompilerGeneratedAttribute]
public bool get_ForceElections();
    [CompilerGeneratedAttribute]
public void set_ForceElections(bool value);
    [CompilerGeneratedAttribute]
public long get_TimeAsLeader();
    [CompilerGeneratedAttribute]
public void set_TimeAsLeader(long value);
    [CompilerGeneratedAttribute]
public int get_SendingThread();
    [CompilerGeneratedAttribute]
public void set_SendingThread(int value);
    [CompilerGeneratedAttribute]
public int get_MinCommandVersion();
    [CompilerGeneratedAttribute]
public void set_MinCommandVersion(int value);
}
public class Raven.Server.Rachis.AppendEntriesResponse : object {
    [CompilerGeneratedAttribute]
private long <LastLogIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastCommitIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pending>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public long LastLogIndex { get; public set; }
    public long LastCommitIndex { get; public set; }
    public long CurrentTerm { get; public set; }
    public bool Success { get; public set; }
    public bool Pending { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public long get_LastLogIndex();
    [CompilerGeneratedAttribute]
public void set_LastLogIndex(long value);
    [CompilerGeneratedAttribute]
public long get_LastCommitIndex();
    [CompilerGeneratedAttribute]
public void set_LastCommitIndex(long value);
    [CompilerGeneratedAttribute]
public long get_CurrentTerm();
    [CompilerGeneratedAttribute]
public void set_CurrentTerm(long value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public bool get_Pending();
    [CompilerGeneratedAttribute]
public void set_Pending(bool value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public virtual string ToString();
    public bool Equals(AppendEntriesResponse aer);
}
public class Raven.Server.Rachis.AsyncWaiter`1 : object {
    protected ConcurrentDictionary`2<string, TaskCompletionSource`1<T>> _results;
    public RemoveTask<T> CreateTask(String& id);
    public TaskCompletionSource`1<T> Get(string id);
    public void TrySetResult(string id, T result);
    public void TrySetException(string id, Exception e);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.AsyncWaiter`1/<WaitForResults>d__6")]
public Task`1<T> WaitForResults(string id, CancellationToken token);
}
public class Raven.Server.Rachis.BlittableResultWriter : object {
    private SingleUseFlag _invalid;
    private Func`2<object, object> _writeResultFunc;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    public object Result { get; private set; }
    public BlittableResultWriter(Func`2<object, object> writeResultFunc);
    [CompilerGeneratedAttribute]
private void set_Result(object value);
    [CompilerGeneratedAttribute]
public object get_Result();
    public void CopyResult(object result);
    public void InvalidateWriter();
    public sealed virtual void Dispose();
}
public class Raven.Server.Rachis.Candidate : object {
    private TaskCompletionSource`1<object> _stateChange;
    private RachisConsensus _engine;
    private List`1<CandidateAmbassador> _voters;
    private ManualResetEvent _peersWaiting;
    private LongRunningWork _longRunningWork;
    [CompilerGeneratedAttribute]
private long <RunRealElectionAtTerm>k__BackingField;
    private MultipleUseFlag _running;
    public ElectionResult modreq(System.Runtime.CompilerServices.IsVolatile) ElectionResult;
    [CompilerGeneratedAttribute]
private long <ElectionTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsForcedElection>k__BackingField;
    public RachisConsensus Engine { get; }
    public List`1<CandidateAmbassador> Voters { get; }
    public long RunRealElectionAtTerm { get; internal set; }
    public bool Running { get; }
    public RaftDebugView ToDebugView { get; }
    public long ElectionTerm { get; internal set; }
    public bool IsForcedElection { get; public set; }
    public Candidate(RachisConsensus engine);
    public RachisConsensus get_Engine();
    public List`1<CandidateAmbassador> get_Voters();
    [CompilerGeneratedAttribute]
public long get_RunRealElectionAtTerm();
    [CompilerGeneratedAttribute]
internal void set_RunRealElectionAtTerm(long value);
    public bool get_Running();
    public RaftDebugView get_ToDebugView();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public long get_ElectionTerm();
    [CompilerGeneratedAttribute]
internal void set_ElectionTerm(long value);
    private void Run(object obj);
    private void MoveCandidateToPassive(string message);
    private bool StillHavePeers(List`1<CandidateAmbassador> ambassadorsToRemove);
    private void CastVoteForSelf(long electionTerm, string reason, bool setStateChange);
    [CompilerGeneratedAttribute]
public bool get_IsForcedElection();
    [CompilerGeneratedAttribute]
public void set_IsForcedElection(bool value);
    public Dictionary`2<string, NodeStatus> GetStatus();
    private void StateChange();
    public void WaitForChangeInState();
    public void Start();
    public sealed virtual void Dispose();
}
public class Raven.Server.Rachis.CandidateAmbassador : object {
    private RachisConsensus _engine;
    private Candidate _candidate;
    private string _tag;
    private string _url;
    private string _statusMessage;
    public AmbassadorStatus Status;
    private LongRunningWork _candidateAmbassadorLongRunningWork;
    private MultipleUseFlag _running;
    [CompilerGeneratedAttribute]
private long <TrialElectionWonAtTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RealElectionWonAtTerm>k__BackingField;
    public Int32 modreq(System.Runtime.CompilerServices.IsVolatile) ClusterCommandsVersion;
    private RemoteConnection _connection;
    private RemoteConnection _publishedConnection;
    public Exception LastException;
    [CompilerGeneratedAttribute]
private bool <NotInTopology>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TopologyMismatch>k__BackingField;
    public string StatusMessage { get; public set; }
    public long TrialElectionWonAtTerm { get; public set; }
    public long RealElectionWonAtTerm { get; public set; }
    public string Tag { get; }
    public RemoteConnection Connection { get; }
    public bool NotInTopology { get; private set; }
    public bool TopologyMismatch { get; private set; }
    public CandidateAmbassador(RachisConsensus engine, Candidate candidate, string tag, string url);
    public string get_StatusMessage();
    public void set_StatusMessage(string value);
    [CompilerGeneratedAttribute]
public long get_TrialElectionWonAtTerm();
    [CompilerGeneratedAttribute]
public void set_TrialElectionWonAtTerm(long value);
    [CompilerGeneratedAttribute]
public long get_RealElectionWonAtTerm();
    [CompilerGeneratedAttribute]
public void set_RealElectionWonAtTerm(long value);
    public string get_Tag();
    public RemoteConnection get_Connection();
    public NodeStatus GetStatus();
    public void Start();
    public sealed virtual void Dispose();
    private void DisposeConnectionIfNeeded();
    private void Run(object o);
    private bool WaitForConnection(Task`1<RachisConnection> connectTask);
    public bool TryGetPublishedConnection(RemoteConnection& connection);
    private void NotifyAboutAmbassadorClosing(RemoteConnection connection, long currentElectionTerm, Exception e);
    public static void SendElectionResult(RachisConsensus engine, RemoteConnection connection, long currentElectionTerm, ElectionResult result);
    [CompilerGeneratedAttribute]
public bool get_NotInTopology();
    [CompilerGeneratedAttribute]
private void set_NotInTopology(bool value);
    [CompilerGeneratedAttribute]
public bool get_TopologyMismatch();
    [CompilerGeneratedAttribute]
private void set_TopologyMismatch(bool value);
}
public class Raven.Server.Rachis.CandidateDebugView : RaftDebugView {
    public string ElectionReason;
    public List`1<PeerConnection> ConnectionToPeers;
    public string Role { get; }
    public CandidateDebugView(Candidate candidate);
    public virtual string get_Role();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Rachis.ClusterTransactionWaiter : AsyncWaiter`1<HashSet`1<string>> {
    public RemoveTask<HashSet`1<string>> CreateTask(string id, TaskCompletionSource`1& tcs);
}
public class Raven.Server.Rachis.Commands.CandidateCastVoteInTermCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private Candidate _candidate;
    private RachisConsensus _engine;
    private long _electionTerm;
    private string _reason;
    public CandidateCastVoteInTermCommand(Candidate candidate, RachisConsensus engine, long electionTerm, string reason);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
    [CompilerGeneratedAttribute]
private void <ExecuteCmd>b__5_0(LowLevelTransaction tx);
}
public class Raven.Server.Rachis.Commands.CastVoteInTermCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private long _term;
    private string _reason;
    public CastVoteInTermCommand(RachisConsensus engine, long term, string reason);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public class Raven.Server.Rachis.Commands.DeleteTopologyCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    public DeleteTopologyCommand(RachisConsensus engine);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public class Raven.Server.Rachis.Commands.ElectorCastVoteInTermCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private RequestVote _requestVote;
    public ElectorCastVoteInTermCommand(RachisConsensus engine, RequestVote requestVote);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
internal class Raven.Server.Rachis.Commands.ElectorCastVoteInTermWithShouldGrantVoteCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private RequestVote _requestVote;
    private long _lastLogIndex;
    [CompilerGeneratedAttribute]
private HandleVoteResult <VoteResult>k__BackingField;
    public HandleVoteResult VoteResult { get; private set; }
    public ElectorCastVoteInTermWithShouldGrantVoteCommand(RachisConsensus engine, RequestVote requestVote, long lastLogIndex);
    [CompilerGeneratedAttribute]
public HandleVoteResult get_VoteResult();
    [CompilerGeneratedAttribute]
private void set_VoteResult(HandleVoteResult value);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    private HandleVoteResult ShouldGrantVote(ClusterOperationContext context, long lastIndex, RequestVote rv);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public class Raven.Server.Rachis.Commands.FollowerApplyCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private long _term;
    private List`1<RachisEntry> _entries;
    private AppendEntries _appendEntries;
    private Stopwatch _sw;
    [CompilerGeneratedAttribute]
private long <LastTruncate>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemovedFromTopology>k__BackingField;
    public long LastTruncate { get; private set; }
    public long LastCommit { get; private set; }
    public bool RemovedFromTopology { get; private set; }
    public FollowerApplyCommand(RachisConsensus engine, long term, List`1<RachisEntry> entries, AppendEntries appendEntries, Stopwatch sw);
    [CompilerGeneratedAttribute]
public long get_LastTruncate();
    [CompilerGeneratedAttribute]
private void set_LastTruncate(long value);
    [CompilerGeneratedAttribute]
public long get_LastCommit();
    [CompilerGeneratedAttribute]
private void set_LastCommit(long value);
    [CompilerGeneratedAttribute]
public bool get_RemovedFromTopology();
    [CompilerGeneratedAttribute]
private void set_RemovedFromTopology(bool value);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public class Raven.Server.Rachis.Commands.FollowerReadAndCommitSnapshotCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private Follower _follower;
    private InstallSnapshot _snapshot;
    private CancellationToken _token;
    [CompilerGeneratedAttribute]
private Task <OnFullSnapshotInstalledTask>k__BackingField;
    public Task OnFullSnapshotInstalledTask { get; private set; }
    public FollowerReadAndCommitSnapshotCommand(RachisConsensus engine, Follower follower, InstallSnapshot snapshot, CancellationToken token);
    [CompilerGeneratedAttribute]
public Task get_OnFullSnapshotInstalledTask();
    [CompilerGeneratedAttribute]
private void set_OnFullSnapshotInstalledTask(Task value);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    private bool InstallSnapshot(ClusterOperationContext context, CancellationToken token);
    private bool ReadSnapshot(SnapshotReader reader, ClusterOperationContext context, Transaction txw, bool dryRun, CancellationToken token);
    private void ReadInstallSnapshotAndIgnoreContent(CancellationToken token);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
    [CompilerGeneratedAttribute]
private void <ExecuteCmd>b__9_0(IPagerLevelTransactionState t);
}
public class Raven.Server.Rachis.Commands.HardResetToNewClusterCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private string _tag;
    private string _topologyId;
    [CompilerGeneratedAttribute]
private bool <Committed>k__BackingField;
    public bool Committed { get; private set; }
    public HardResetToNewClusterCommand(RachisConsensus engine, string tag, string topologyId);
    [CompilerGeneratedAttribute]
public bool get_Committed();
    [CompilerGeneratedAttribute]
private void set_Committed(bool value);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
    [CompilerGeneratedAttribute]
private void <ExecuteCmd>b__8_0(IPagerLevelTransactionState tx);
}
public class Raven.Server.Rachis.Commands.HardResetToPassiveCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private string _tag;
    private string _topologyId;
    public HardResetToPassiveCommand(RachisConsensus engine, string tag, string topologyId);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public class Raven.Server.Rachis.Commands.LeaderApplyCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private long _lastCommit;
    private long _maxIndexOnQuorum;
    private Leader _leader;
    [CompilerGeneratedAttribute]
private long <LastAppliedCommit>k__BackingField;
    public long LastAppliedCommit { get; private set; }
    public LeaderApplyCommand(Leader leader, RachisConsensus engine, long lastCommit, long maxIndexOnQuorum);
    [CompilerGeneratedAttribute]
public long get_LastAppliedCommit();
    [CompilerGeneratedAttribute]
private void set_LastAppliedCommit(long value);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public class Raven.Server.Rachis.Commands.LowestIndexUpdateCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private long _lowestIndexInEntireCluster;
    public LowestIndexUpdateCommand(RachisConsensus engine, long lowestIndexInEntireCluster);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public class Raven.Server.Rachis.Commands.RemoveEntryFromRaftLogCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private long _index;
    private string _tag;
    private RachisLogHistory _logHistory;
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    public bool Succeeded { get; private set; }
    public RemoveEntryFromRaftLogCommand(string tag, long index, RachisLogHistory logHistory);
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
private void set_Succeeded(bool value);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    private bool RemoveEntryFromRaftLogInTx(ClusterOperationContext context, long index);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public class Raven.Server.Rachis.Commands.SetNewStateCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private RachisState _rachisState;
    private IDisposable _parent;
    private long _expectedTerm;
    private string _stateChangedReason;
    private Action _beforeStateChangedEvent;
    private bool _disposeAsync;
    public SetNewStateCommand(RachisConsensus engine, RachisState rachisState, IDisposable parent, long expectedTerm, string stateChangedReason, Action beforeStateChangedEvent, bool disposeAsync);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public class Raven.Server.Rachis.Commands.SwitchToSingleLeaderCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    public SwitchToSingleLeaderCommand(RachisConsensus engine);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public class Raven.Server.Rachis.Commands.UpdateNodeTagCommand : MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction> {
    private RachisConsensus _engine;
    private string _tag;
    private RachisHello _initialMessage;
    public UpdateNodeTagCommand(RachisConsensus engine, string tag, RachisHello initialMessage);
    protected virtual long ExecuteCmd(ClusterOperationContext context);
    public virtual IReplayableCommandDto`3<ClusterOperationContext, ClusterTransaction, MergedTransactionCommand`2<ClusterOperationContext, ClusterTransaction>> ToDto(ClusterOperationContext context);
}
public enum Raven.Server.Rachis.ElectionResult : Enum {
    public int value__;
    public static ElectionResult InProgress;
    public static ElectionResult Won;
    public static ElectionResult Lost;
}
public class Raven.Server.Rachis.Elector : object {
    private RachisConsensus _engine;
    private RemoteConnection _connection;
    private LongRunningWork _electorLongRunningWork;
    private bool _electionWon;
    public Elector(RachisConsensus engine, RemoteConnection connection);
    public void Run();
    public virtual string ToString();
    private void HandleVoteRequest(object obj);
    private static bool IsExpectedException(Exception e);
    public sealed virtual void Dispose();
}
public class Raven.Server.Rachis.Follower : object {
    private static int _uniqueId;
    private RachisConsensus _engine;
    private long _term;
    private RemoteConnection _connection;
    private LongRunningWork _followerLongRunningWork;
    private string _debugName;
    private RachisLogRecorder _debugRecorder;
    public FollowerPhase Phase;
    public RachisConsensus Engine { get; }
    public RemoteConnection Connection { get; }
    public RachisLogRecorder DebugRecorder { get; }
    public RaftDebugView ToDebugView { get; }
    public Follower(RachisConsensus engine, long term, RemoteConnection remoteConnection);
    public RachisConsensus get_Engine();
    public RemoteConnection get_Connection();
    public RachisLogRecorder get_DebugRecorder();
    public RaftDebugView get_ToDebugView();
    public virtual string ToString();
    private void FollowerSteadyState();
    [AsyncStateMachineAttribute("Raven.Server.Rachis.Follower/<Concurrent_SendAppendEntriesPendingToLeaderAsync>d__19")]
private Task Concurrent_SendAppendEntriesPendingToLeaderAsync(CancellationTokenSource cts, long currentTerm, long lastLogIndex);
    private ValueTuple`4<bool, long, long, long> ApplyLeaderStateToLocalState(Stopwatch sp, List`1<RachisEntry> entries, AppendEntries appendEntries);
    public static ValueTuple`2<bool, LogLengthNegotiation> CheckIfValidLeader(RachisConsensus engine, RemoteConnection connection);
    private void NegotiateWithLeader(ClusterOperationContext context, LogLengthNegotiation negotiation);
    private void KeepAliveAndExecuteAction(Func`1<Task> func, CancellationTokenSource cts, string debug);
    private void WaitForTaskCompletion(Task task, string debug);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.Follower/<ReadAndCommitSnapshotAsync>d__25")]
private Task`1<Task> ReadAndCommitSnapshotAsync(InstallSnapshot snapshot, CancellationToken token);
    private void MaybeNotifyLeaderThatWeAreStillAlive(JsonOperationContext context, Stopwatch sp);
    private bool NegotiateMatchEntryWithLeaderAndApplyEntries(ClusterOperationContext context, RemoteConnection connection, LogLengthNegotiation negotiation);
    private bool HandleDivergenceAtFirstLeaderEntry(ClusterOperationContext context, LogLengthNegotiation negotiation, Int64& lastCommittedIndex);
    private bool CanHandleLogDivergence(ClusterOperationContext context, LogLengthNegotiation negotiation, Int64& midpointIndex, Int64& midpointTerm, Int64& minIndex, Int64& maxIndex);
    private void RequestAllEntries(ClusterOperationContext context, RemoteConnection connection, string message);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.Follower/<AcceptConnectionAsync>d__31")]
public Task AcceptConnectionAsync(LogLengthNegotiation negotiation);
    private void Run(object obj);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <AcceptConnectionAsync>b__31_0();
}
public class Raven.Server.Rachis.FollowerAmbassador : object {
    private RachisConsensus _engine;
    private Leader _leader;
    private ManualResetEvent _wakeLeader;
    private string _tag;
    private string _url;
    private string _statusMessage;
    public AmbassadorStatus Status;
    private long _followerMatchIndex;
    private long _followerLastCommitIndex;
    private long _lastReplyFromFollower;
    private long _lastSendToFollower;
    private string _lastSentMsg;
    private LongRunningWork _followerAmbassadorLongRunningOperation;
    private RemoteConnection _connection;
    private MultipleUseFlag _running;
    private long _term;
    private static int _uniqueId;
    [CompilerGeneratedAttribute]
private bool <ForceElectionsNow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FollowerCommandsVersion>k__BackingField;
    private string _debugName;
    private RachisLogRecorder _debugRecorder;
    public string StatusMessage { get; public set; }
    public RemoteConnection Connection { get; }
    public string Tag { get; }
    public string ThreadStatus { get; }
    public long FollowerMatchIndex { get; }
    public long FollowerLastCommitIndex { get; }
    public DateTime LastReplyFromFollower { get; }
    public DateTime LastSendToFollower { get; }
    public string LastSendMsg { get; }
    public bool ForceElectionsNow { get; public set; }
    public string Url { get; }
    public int FollowerCommandsVersion { get; public set; }
    public FollowerAmbassador(RachisConsensus engine, Leader leader, ManualResetEvent wakeLeader, string tag, string url, RemoteConnection connection);
    public string get_StatusMessage();
    public void set_StatusMessage(string value);
    public RemoteConnection get_Connection();
    public string get_Tag();
    public string get_ThreadStatus();
    public long get_FollowerMatchIndex();
    public long get_FollowerLastCommitIndex();
    public DateTime get_LastReplyFromFollower();
    public DateTime get_LastSendToFollower();
    public string get_LastSendMsg();
    [CompilerGeneratedAttribute]
public bool get_ForceElectionsNow();
    [CompilerGeneratedAttribute]
public void set_ForceElectionsNow(bool value);
    public string get_Url();
    [CompilerGeneratedAttribute]
public int get_FollowerCommandsVersion();
    [CompilerGeneratedAttribute]
public void set_FollowerCommandsVersion(int value);
    private void UpdateLastSend(string msg);
    private void UpdateLastMatchFromFollower(long newVal);
    private void UpdateLastMatchFromFollower(AppendEntriesResponse response);
    private void UpdateFollowerTicks();
    public void UpdateLeaderWake(ManualResetEvent wakeLeader);
    private void Run(object o);
    private bool WaitForConnection(Task`1<RachisConnection> connectTask);
    private void NotifyOnException(Boolean& hadConnectionFailure, string message, Exception e);
    private bool IsGracefulError(Exception e);
    private void SendSnapshot(Stream stream);
    private void WriteSnapshotToFile(ClusterOperationContext context, Stream dest);
    private void CalculateTotalSize(Int64& items, Int64& totalSizeInBytes, long sizeToIncrease);
    internal static BlittableJsonReaderObject BuildRachisEntryToSend(TransactionOperationContext`1<TTransaction> context, TableValueHolder value);
    private long InitialNegotiationWithFollower();
    private static int GetFollowerVersion(LogLengthNegotiationResponse llr);
    private void SendHello(ClusterOperationContext context, ClusterTopology clusterTopology);
    public void Start();
    public virtual string ToString();
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <WriteSnapshotToFile>b__59_0(object _);
}
public class Raven.Server.Rachis.FollowerDebugView : RaftDebugView {
    public PeerConnection ConnectionToLeader;
    public List`1<RachisDebugMessage> RecentMessages;
    public FollowerPhase Phase;
    public string Role { get; }
    public FollowerDebugView(Follower follower);
    public virtual string get_Role();
    public virtual DynamicJsonValue ToJson();
}
public enum Raven.Server.Rachis.InitialMessageType : Enum {
    public int value__;
    public static InitialMessageType RequestVote;
    public static InitialMessageType AppendEntries;
}
public class Raven.Server.Rachis.InstallSnapshot : object {
    [CompilerGeneratedAttribute]
private long <LastIncludedIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastIncludedTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Topology>k__BackingField;
    public long LastIncludedIndex { get; public set; }
    public long LastIncludedTerm { get; public set; }
    public BlittableJsonReaderObject Topology { get; public set; }
    [CompilerGeneratedAttribute]
public long get_LastIncludedIndex();
    [CompilerGeneratedAttribute]
public void set_LastIncludedIndex(long value);
    [CompilerGeneratedAttribute]
public long get_LastIncludedTerm();
    [CompilerGeneratedAttribute]
public void set_LastIncludedTerm(long value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Topology();
    [CompilerGeneratedAttribute]
public void set_Topology(BlittableJsonReaderObject value);
}
public class Raven.Server.Rachis.InstallSnapshotResponse : object {
    [CompilerGeneratedAttribute]
private bool <Done>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastLogIndex>k__BackingField;
    public bool Done { get; public set; }
    public long CurrentTerm { get; public set; }
    public long LastLogIndex { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Done();
    [CompilerGeneratedAttribute]
public void set_Done(bool value);
    [CompilerGeneratedAttribute]
public long get_CurrentTerm();
    [CompilerGeneratedAttribute]
public void set_CurrentTerm(long value);
    [CompilerGeneratedAttribute]
public long get_LastLogIndex();
    [CompilerGeneratedAttribute]
public void set_LastLogIndex(long value);
}
internal class Raven.Server.Rachis.Json.Sync.RachisBlittableJsonTextWriter : AbstractBlittableJsonTextWriter {
    private Action _afterFlush;
    public RachisBlittableJsonTextWriter(JsonOperationContext context, Stream stream, Action afterFlush);
    public sealed virtual void Dispose();
    public void Flush();
    protected virtual bool FlushInternal();
}
internal class Raven.Server.Rachis.JsonDeserializationRachis`1 : JsonDeserializationBase {
    public static Func`2<BlittableJsonReaderObject, T> Deserialize;
    private static JsonDeserializationRachis`1();
}
public class Raven.Server.Rachis.Leader : object {
    private TaskCompletionSource`1<object> _topologyModification;
    private RachisConsensus _engine;
    private string _threadName;
    private TaskCompletionSource`1<object> _newEntriesArrived;
    private TaskCompletionSource`1<object> _errorOccurred;
    private ConcurrentDictionary`2<long, CommandState> _entries;
    private MultipleUseFlag _hasNewTopology;
    private ManualResetEvent _newEntry;
    private ManualResetEvent _voterResponded;
    private ManualResetEvent _promotableUpdated;
    private ManualResetEvent _shutdownRequested;
    private ManualResetEvent _noop;
    private long _lowestIndexInEntireCluster;
    private ConcurrentDictionary`2<string, FollowerAmbassador> _voters;
    private ConcurrentDictionary`2<string, FollowerAmbassador> _promotables;
    private ConcurrentDictionary`2<string, FollowerAmbassador> _nonVoters;
    public ConcurrentDictionary`2<string, int> PeersVersion;
    private LongRunningWork _leaderLongRunningWork;
    private int _previousPeersWereDisposed;
    public long Term;
    private MultipleUseFlag _running;
    private int _steppedDown;
    private long _lastCommit;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<FollowerAmbassador, TimeSpan>> _timeoutsForVoters;
    private SortedList`2<long, int> _nodesPerIndex;
    private Stopwatch _leadership;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ConcurrentQueue`1<ValueTuple`2<string, AlertRaised>> ErrorsList;
    private DisposeLock _disposerLock;
    public RachisConsensus Engine { get; }
    public Dictionary`2<string, FollowerAmbassador> CurrentPeers { get; }
    public Dictionary`2<string, FollowerAmbassador> CurrentVoters { get; }
    public long LowestIndexInEntireCluster { get; public set; }
    public bool Running { get; }
    public RaftDebugView ToDebugView { get; }
    private int VotersMajority { get; }
    public long LeaderShipDuration { get; }
    public Leader(RachisConsensus engine, long term);
    public RachisConsensus get_Engine();
    public Dictionary`2<string, FollowerAmbassador> get_CurrentPeers();
    public Dictionary`2<string, FollowerAmbassador> get_CurrentVoters();
    public long get_LowestIndexInEntireCluster();
    public void set_LowestIndexInEntireCluster(long value);
    public bool get_Running();
    public RaftDebugView get_ToDebugView();
    public void Start(Dictionary`2<string, RemoteConnection> connections);
    public void StepDown(bool forceElection);
    public Dictionary`2<string, NodeStatus> GetStatus();
    private void RefreshAmbassadors(ClusterTopology clusterTopology, Dictionary`2<string, RemoteConnection> connections);
    private void Run(object obj);
    private void LogAndNotifyLeaderRunExceptions(Exception e);
    private void VoteOfNoConfidence();
    private void OnVoterConfirmation();
    private void EnsureThatWeHaveLeadership(int majority);
    private int get_VotersMajority();
    public long get_LeaderShipDuration();
    protected long GetLowestIndexInEntireCluster(Int64& lastTruncated);
    protected long GetMaxIndexOnQuorum(int minSize);
    private void CheckPromotables();
    [AsyncStateMachineAttribute("Raven.Server.Rachis.Leader/<PutAsync>d__59")]
public Task`1<ValueTuple`2<long, object>> PutAsync(CommandBase command, TimeSpan timeout);
    public void NotifyAboutException(string node, string title, string message, Exception e);
    public sealed virtual void Dispose();
    public Task WaitForNewEntries();
    public bool TryModifyTopology(string nodeTag, string nodeUrl, TopologyModification modification, Task& task, bool validateNotInTopology);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.Leader/<TryModifyTopologyAsync>d__67")]
public Task`1<ValueTuple`2<bool, Task>> TryModifyTopologyAsync(string nodeTag, string nodeUrl, TopologyModification modification, bool validateNotInTopology);
    public virtual string ToString();
    public void SetStateOf(long index, Action`1<TaskCompletionSource`1<ValueTuple`2<long, object>>> onNotify);
    public void SetExceptionOf(long index, Exception e);
    public void SetStateOf(long index, object result);
    [ConditionalAttribute("DEBUG")]
private void ValidateUsableReturnType(object result);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Raven.Server.Rachis.Leader/<<Run>b__43_0>d")]
[CompilerGeneratedAttribute]
private Task <Run>b__43_0();
    [CompilerGeneratedAttribute]
private void <OnVoterConfirmation>b__47_0(IPagerLevelTransactionState _);
}
public class Raven.Server.Rachis.LeaderDebugView : RaftDebugView {
    public string ElectionReason;
    public List`1<PeerConnection> ConnectionToPeers;
    public string Role { get; }
    public LeaderDebugView(Leader leader);
    public virtual string get_Role();
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Rachis.LogLengthNegotiation : object {
    [CompilerGeneratedAttribute]
private long <PrevLogIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PrevLogTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Term>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Truncated>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendingThread>k__BackingField;
    public long PrevLogIndex { get; public set; }
    public long PrevLogTerm { get; public set; }
    public long Term { get; public set; }
    public bool Truncated { get; public set; }
    public int SendingThread { get; public set; }
    [CompilerGeneratedAttribute]
public long get_PrevLogIndex();
    [CompilerGeneratedAttribute]
public void set_PrevLogIndex(long value);
    [CompilerGeneratedAttribute]
public long get_PrevLogTerm();
    [CompilerGeneratedAttribute]
public void set_PrevLogTerm(long value);
    [CompilerGeneratedAttribute]
public long get_Term();
    [CompilerGeneratedAttribute]
public void set_Term(long value);
    [CompilerGeneratedAttribute]
public bool get_Truncated();
    [CompilerGeneratedAttribute]
public void set_Truncated(bool value);
    [CompilerGeneratedAttribute]
public int get_SendingThread();
    [CompilerGeneratedAttribute]
public void set_SendingThread(int value);
}
public class Raven.Server.Rachis.LogLengthNegotiationResponse : object {
    [CompilerGeneratedAttribute]
private ResponseStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastLogIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MinIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MidpointIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MidpointTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CommandsVersion>k__BackingField;
    public ResponseStatus Status { get; public set; }
    public string Message { get; public set; }
    public long CurrentTerm { get; public set; }
    public long LastLogIndex { get; public set; }
    public long MaxIndex { get; public set; }
    public long MinIndex { get; public set; }
    public long MidpointIndex { get; public set; }
    public long MidpointTerm { get; public set; }
    public Nullable`1<int> CommandsVersion { get; public set; }
    [CompilerGeneratedAttribute]
public ResponseStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(ResponseStatus value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public long get_CurrentTerm();
    [CompilerGeneratedAttribute]
public void set_CurrentTerm(long value);
    [CompilerGeneratedAttribute]
public long get_LastLogIndex();
    [CompilerGeneratedAttribute]
public void set_LastLogIndex(long value);
    [CompilerGeneratedAttribute]
public long get_MaxIndex();
    [CompilerGeneratedAttribute]
public void set_MaxIndex(long value);
    [CompilerGeneratedAttribute]
public long get_MinIndex();
    [CompilerGeneratedAttribute]
public void set_MinIndex(long value);
    [CompilerGeneratedAttribute]
public long get_MidpointIndex();
    [CompilerGeneratedAttribute]
public void set_MidpointIndex(long value);
    [CompilerGeneratedAttribute]
public long get_MidpointTerm();
    [CompilerGeneratedAttribute]
public void set_MidpointTerm(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CommandsVersion();
    [CompilerGeneratedAttribute]
public void set_CommandsVersion(Nullable`1<int> value);
}
public class Raven.Server.Rachis.LogSummary : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastCommitedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastAppendedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CommitIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastTruncatedIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastTruncatedTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FirstEntryIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastLogEntryIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<RachisDebugLogEntry> <Logs>k__BackingField;
    public Nullable`1<DateTime> LastCommitedTime { get; public set; }
    public Nullable`1<DateTime> LastAppendedTime { get; public set; }
    public long CommitIndex { get; public set; }
    public long LastTruncatedIndex { get; public set; }
    public long LastTruncatedTerm { get; public set; }
    public long FirstEntryIndex { get; public set; }
    public long LastLogEntryIndex { get; public set; }
    public IEnumerable`1<RachisDebugLogEntry> Logs { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastCommitedTime();
    [CompilerGeneratedAttribute]
public void set_LastCommitedTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastAppendedTime();
    [CompilerGeneratedAttribute]
public void set_LastAppendedTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public long get_CommitIndex();
    [CompilerGeneratedAttribute]
public void set_CommitIndex(long value);
    [CompilerGeneratedAttribute]
public long get_LastTruncatedIndex();
    [CompilerGeneratedAttribute]
public void set_LastTruncatedIndex(long value);
    [CompilerGeneratedAttribute]
public long get_LastTruncatedTerm();
    [CompilerGeneratedAttribute]
public void set_LastTruncatedTerm(long value);
    [CompilerGeneratedAttribute]
public long get_FirstEntryIndex();
    [CompilerGeneratedAttribute]
public void set_FirstEntryIndex(long value);
    [CompilerGeneratedAttribute]
public long get_LastLogEntryIndex();
    [CompilerGeneratedAttribute]
public void set_LastLogEntryIndex(long value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<RachisDebugLogEntry> get_Logs();
    [CompilerGeneratedAttribute]
public void set_Logs(IEnumerable`1<RachisDebugLogEntry> value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Rachis.NotLeadingException : Exception {
    public NotLeadingException(string message);
    public NotLeadingException(string message, Exception inner);
}
public class Raven.Server.Rachis.ParentStateChangedConcurrencyException : RachisConcurrencyException {
    public ParentStateChangedConcurrencyException(string message);
    public ParentStateChangedConcurrencyException(string message, Exception innerException);
    public static void Throw(string msg);
}
public class Raven.Server.Rachis.PassiveDebugView : RaftDebugView {
    public string Role { get; }
    public PassiveDebugView(RachisConsensus engine);
    public virtual string get_Role();
}
public class Raven.Server.Rachis.PutRaftCommand : RavenCommand`1<PutRaftCommandResult> {
    private DocumentConventions _conventions;
    private BlittableJsonReaderObject _command;
    private bool _reachedLeader;
    private string _source;
    private string _commandType;
    [CompilerGeneratedAttribute]
private string <RaftUniqueRequestId>k__BackingField;
    private static Func`2<BlittableJsonReaderObject, PutRaftCommandResult> PutRaftCommandResultFunc;
    public bool IsReadRequest { get; }
    public string RaftUniqueRequestId { get; }
    public PutRaftCommand(DocumentConventions conventions, BlittableJsonReaderObject command, string source, string commandType);
    private static PutRaftCommand();
    public virtual bool get_IsReadRequest();
    public bool HasReachLeader();
    public virtual void OnResponseFailure(HttpResponseMessage response);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RaftUniqueRequestId();
}
public class Raven.Server.Rachis.RachisApplyException : RachisException {
    public RachisApplyException(string message);
    public RachisApplyException(string message, Exception innerException);
    [DoesNotReturnAttribute]
public static void Throw(string msg);
}
public class Raven.Server.Rachis.RachisConcurrencyException : RachisException {
    public RachisConcurrencyException(string message);
    public RachisConcurrencyException(string message, Exception innerException);
    [DoesNotReturnAttribute]
public static void Throw(string msg);
}
public class Raven.Server.Rachis.RachisConnection : object {
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <Disconnect>k__BackingField;
    [CompilerGeneratedAttribute]
private SupportedFeatures <SupportedFeatures>k__BackingField;
    public Stream Stream { get; public set; }
    public Action Disconnect { get; public set; }
    public SupportedFeatures SupportedFeatures { get; public set; }
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
    [CompilerGeneratedAttribute]
public Action get_Disconnect();
    [CompilerGeneratedAttribute]
public void set_Disconnect(Action value);
    [CompilerGeneratedAttribute]
public SupportedFeatures get_SupportedFeatures();
    [CompilerGeneratedAttribute]
public void set_SupportedFeatures(SupportedFeatures value);
}
public abstract class Raven.Server.Rachis.RachisConsensus : object {
    public static string InitialTag;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClusterTopology> TopologyChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<StateTransition> StateChanged;
    [CompilerGeneratedAttribute]
private EventHandler LeaderElected;
    public Action`1<ClusterOperationContext> SwitchToSingleLeaderAction;
    public Action`2<ClusterOperationContext, RachisMergedCommand> BeforeAppendToRaftLog;
    private string _tag;
    private string _clusterId;
    [CompilerGeneratedAttribute]
private ClusterContextPool <ContextPool>k__BackingField;
    [CompilerGeneratedAttribute]
private ClusterTransactionOperationsMerger <TxMerger>k__BackingField;
    private StorageEnvironment _persistentState;
    internal Logger Log;
    private ConcurrentQueue`1<Elector> _electors;
    private List`1<IDisposable> _disposables;
    [CompilerGeneratedAttribute]
private long <CurrentTerm>k__BackingField;
    public string Url;
    private static Slice GlobalStateSlice;
    private static Slice CurrentTermSlice;
    private static Slice VotedForSlice;
    private static Slice LastCommitSlice;
    private static Slice LastTruncatedSlice;
    private static Slice TopologySlice;
    private static Slice TagSlice;
    private static Slice PreviousTagSlice;
    private static Slice SnapshotRequestSlice;
    internal static Slice EntriesSlice;
    internal static TableSchema LogsTable;
    public RachisLogHistory LogHistory;
    [CompilerGeneratedAttribute]
private TimeoutEvent <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximalVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxSizeOfSingleRaftCommandInBytes>k__BackingField;
    private Leader _currentLeader;
    private TaskCompletionSource`1<object> _topologyChanged;
    private TaskCompletionSource`1<object> _stateChanged;
    private TaskCompletionSource`1<object> _commitIndexChanged;
    private ManualResetEventSlim _disposeEvent;
    private Random _rand;
    private string _lastStateChangeReason;
    [CompilerGeneratedAttribute]
private Candidate <Candidate>k__BackingField;
    [CompilerGeneratedAttribute]
private Follower <Follower>k__BackingField;
    internal TestingStuff ForTestingPurposes;
    public StateTransition LastState;
    [CompilerGeneratedAttribute]
private ConcurrentQueue`1<StateTransition> <PrevStates>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler OnDispose;
    private string _leaderTag;
    internal AsyncManualResetEvent _leadershipTimeChanged;
    private int _heartbeatWaitersCounter;
    private long _leaderTime;
    private TimeSpan _operationTimeout;
    private TimeSpan _electionTimeout;
    private TimeSpan _tcpConnectionTimeout;
    private DateTime _lastStateChangeTime;
    private string _clusterIdBase64Id;
    public ClusterCommandsVersionManager CommandsVersionManager;
    public CipherSuitesPolicy CipherSuitesPolicy;
    private RachisState modreq(System.Runtime.CompilerServices.IsVolatile) _currentState;
    [CompilerGeneratedAttribute]
private bool <RequestSnapshot>k__BackingField;
    public RachisDebug InMemoryDebug;
    public Nullable`1<DateTime> LastCommitted;
    public Nullable`1<DateTime> LastAppended;
    internal RachisVersionValidation Validator { get; }
    public RachisState CurrentState { get; private set; }
    public string LastStateChangeReason { get; private set; }
    public DateTime LastStateChangeTime { get; }
    public ClusterContextPool ContextPool { get; private set; }
    public ClusterTransactionOperationsMerger TxMerger { get; private set; }
    public long CurrentTerm { get; private set; }
    public string Tag { get; }
    public string ClusterId { get; }
    public string ClusterBase64Id { get; }
    public TimeSpan ElectionTimeout { get; private set; }
    public TimeSpan TcpConnectionTimeout { get; private set; }
    public TimeoutEvent Timeout { get; private set; }
    public TimeSpan OperationTimeout { get; private set; }
    public Nullable`1<int> MaximalVersion { get; public set; }
    public Nullable`1<long> MaxSizeOfSingleRaftCommandInBytes { get; public set; }
    public Leader CurrentLeader { get; }
    public Candidate Candidate { get; public set; }
    public Follower Follower { get; public set; }
    public ConcurrentQueue`1<StateTransition> PrevStates { get; public set; }
    public bool IsDisposed { get; }
    public string LeaderTag { get; internal set; }
    public bool IsEncrypted { get; }
    public X509Certificate2 ClusterCertificate { get; }
    public ServerStore ServerStore { get; }
    public bool RequestSnapshot { get; private set; }
    private static RachisConsensus();
    protected RachisConsensus(CipherSuitesPolicy cipherSuitesPolicy, Nullable`1<int> seed);
    internal abstract virtual RachisStateMachine GetStateMachine();
    internal abstract virtual RachisVersionValidation get_Validator();
    public RachisState get_CurrentState();
    private void set_CurrentState(RachisState value);
    public string get_LastStateChangeReason();
    private void set_LastStateChangeReason(string value);
    public DateTime get_LastStateChangeTime();
    [CompilerGeneratedAttribute]
public void add_TopologyChanged(EventHandler`1<ClusterTopology> value);
    [CompilerGeneratedAttribute]
public void remove_TopologyChanged(EventHandler`1<ClusterTopology> value);
    [CompilerGeneratedAttribute]
public void add_StateChanged(EventHandler`1<StateTransition> value);
    [CompilerGeneratedAttribute]
public void remove_StateChanged(EventHandler`1<StateTransition> value);
    [CompilerGeneratedAttribute]
public void add_LeaderElected(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LeaderElected(EventHandler value);
    [CompilerGeneratedAttribute]
public ClusterContextPool get_ContextPool();
    [CompilerGeneratedAttribute]
private void set_ContextPool(ClusterContextPool value);
    [CompilerGeneratedAttribute]
public ClusterTransactionOperationsMerger get_TxMerger();
    [CompilerGeneratedAttribute]
private void set_TxMerger(ClusterTransactionOperationsMerger value);
    [CompilerGeneratedAttribute]
public long get_CurrentTerm();
    [CompilerGeneratedAttribute]
private void set_CurrentTerm(long value);
    public string get_Tag();
    public string get_ClusterId();
    public string get_ClusterBase64Id();
    public TimeSpan get_ElectionTimeout();
    private void set_ElectionTimeout(TimeSpan value);
    public TimeSpan get_TcpConnectionTimeout();
    private void set_TcpConnectionTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeoutEvent get_Timeout();
    [CompilerGeneratedAttribute]
private void set_Timeout(TimeoutEvent value);
    public TimeSpan get_OperationTimeout();
    private void set_OperationTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximalVersion();
    [CompilerGeneratedAttribute]
public void set_MaximalVersion(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxSizeOfSingleRaftCommandInBytes();
    [CompilerGeneratedAttribute]
public void set_MaxSizeOfSingleRaftCommandInBytes(Nullable`1<long> value);
    public Leader get_CurrentLeader();
    [CompilerGeneratedAttribute]
public Candidate get_Candidate();
    [CompilerGeneratedAttribute]
public void set_Candidate(Candidate value);
    [CompilerGeneratedAttribute]
public Follower get_Follower();
    [CompilerGeneratedAttribute]
public void set_Follower(Follower value);
    public abstract virtual void Notify(Notification notification);
    public void RandomizeTimeout(bool extend);
    public void Initialize(StorageEnvironment env, RavenConfiguration configuration, ClusterChanges changes, string myUrl, SystemTime time, Int64& clusterTopologyEtag, CancellationToken shutdown);
    private long ReadTerm(ClusterOperationContext context);
    public string ReadNodeTag(ClusterOperationContext context);
    public static string ReadNodeTag(TransactionOperationContext context);
    public string ReadPreviousNodeTag(ClusterOperationContext context);
    internal void SwitchToSingleLeader(ClusterOperationContext context);
    public bool ContainsCommandId(string guid);
    protected abstract virtual void InitializeState(ClusterOperationContext context, ClusterChanges changes);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<WaitForState>d__110")]
public Task`1<bool> WaitForState(RachisState rachisState, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<WaitForLeaderChange>d__111")]
public Task WaitForLeaderChange(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<WaitForLeaderChange>d__112")]
public Task`1<string> WaitForLeaderChange(string leader, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<WaitForLeaveState>d__113")]
public Task`1<bool> WaitForLeaveState(RachisState rachisState, CancellationToken cts);
    public Task GetTopologyChanged();
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<WaitForTopology>d__115")]
public Task WaitForTopology(TopologyModification modification, string nodeTag, CancellationToken token);
    public void SetNewState(RachisState rachisState, IDisposable disposable, long expectedTerm, string stateChangedReason, Action beforeStateChangedEvent, bool asyncDispose);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<SetNewStateAsync>d__118")]
public Task SetNewStateAsync(RachisState rachisState, IDisposable disposable, long expectedTerm, string stateChangedReason, Action beforeStateChangedEvent, bool asyncDispose);
    public void SetNewStateImmediately(RachisState rachisState, IDisposable disposable, long expectedTerm, string stateChangedReason, Action beforeStateChangedEvent, bool asyncDispose);
    internal TestingStuff ForTestingPurposesOnly();
    internal void SetNewStateInTx(ClusterOperationContext context, RachisState rachisState, IDisposable parent, long expectedTerm, string stateChangedReason, Action beforeStateChangedEvent, bool disposeAsync);
    private void ParallelDispose(List`1<IDisposable> toDispose);
    [CompilerGeneratedAttribute]
public ConcurrentQueue`1<StateTransition> get_PrevStates();
    [CompilerGeneratedAttribute]
public void set_PrevStates(ConcurrentQueue`1<StateTransition> value);
    public bool TakeOffice();
    public void AppendElector(Elector elector);
    public void AppendStateDisposable(IDisposable parentState, IDisposable disposeOnStateChange);
    public void RemoveAndDispose(IDisposable parentState, IDisposable disposable);
    public void SwitchToLeaderState(long electionTerm, int version, string reason, Dictionary`2<string, RemoteConnection> connections);
    public Task`1<ValueTuple`2<long, object>> PutToLeaderAsync(CommandBase cmd);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<SendToLeaderAsync>d__137")]
public Task`1<ValueTuple`2<long, object>> SendToLeaderAsync(CommandBase cmd, CancellationToken token);
    private static void ThrowInvalidEngineState(CommandBase cmd);
    private void ThrowTimeoutException(CommandBase cmd, Exception requestException);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<SendToNodeAsync>d__140")]
private Task`1<ValueTuple`2<long, object>> SendToNodeAsync(JsonOperationContext context, string engineLeaderTag, CommandBase cmd, Reference`1<bool> reachedLeader, CancellationToken token);
    public void SwitchToCandidateStateOnTimeout();
    public void SwitchToCandidateState(string reason, bool forced);
    private void DeleteTopology(ClusterOperationContext context);
    public ClusterTopology GetTopology(TransactionOperationContext`1<TTransaction> context);
    public static ClusterTopology GetClusterTopology(TransactionOperationContext`1<TTransaction> context);
    public BlittableJsonReaderObject GetTopologyRaw(ClusterOperationContext context);
    internal BlittableJsonReaderObject SetTopology(ClusterOperationContext context, ClusterTopology topology);
    internal static BlittableJsonReaderObject SetTopology(RachisConsensus engine, ClusterOperationContext context, ClusterTopology clusterTopology);
    public void NotifyTopologyChange(bool propagateError);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<AcceptNewConnectionAsync>d__150")]
public Task AcceptNewConnectionAsync(RemoteConnection remoteConnection, EndPoint remoteEndpoint, Action`1<RachisHello> sayHello);
    private void ValidateCompatibility(RachisHello initialMessage, ClusterTopology clusterTopology);
    private void ValidateElectionTimeout(RachisHello initialMessage);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<RemoveEntryFromRaftLogAsync>d__153")]
public Task`1<bool> RemoveEntryFromRaftLogAsync(long index);
    public long InsertToLeaderLog(ClusterOperationContext context, long term, BlittableJsonReaderObject cmd, RachisEntryFlags flags);
    [DoesNotReturnAttribute]
private void ThrowTooLargeRaftCommand(BlittableJsonReaderObject cmd);
    public void ClearLogEntriesAndSetLastTruncate(ClusterOperationContext context, long index, long term);
    public void TruncateLogBefore(ClusterOperationContext context, long upto);
    public ValueTuple`2<BlittableJsonReaderObject, long> AppendToLog(ClusterOperationContext context, List`1<RachisEntry> entries);
    [DoesNotReturnAttribute]
private void ThrowFatalError(RachisEntry firstEntry, Nullable`1<long> myTermForTheIndex, long lastCommitIndex, long lastCommitTerm);
    internal static void GetLastTruncated(TransactionOperationContext`1<TTransaction> context, Int64& lastTruncatedIndex, Int64& lastTruncatedTerm);
    public BlittableJsonReaderObject GetEntry(ClusterOperationContext context, long index, RachisEntryFlags& flags);
    public long GetLastCommitIndex(TransactionOperationContext`1<TTransaction> context);
    public void GetLastCommitIndex(ClusterOperationContext context, Int64& index, Int64& term);
    public void GetLastCommitIndex(Int64& index, Int64& term);
    public void SetLastCommitIndex(ClusterOperationContext context, long index, long term);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<WaitForCommitIndexChange>d__166")]
public Task WaitForCommitIndexChange(CommitIndexModification modification, long value, Nullable`1<TimeSpan> timeout, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<WaitForCommitChangeOrThrowTimeoutException>d__167")]
private static Task WaitForCommitChangeOrThrowTimeoutException(Task timeoutTask, Task task);
    [DoesNotReturnAttribute]
private static void ThrowTimeoutException();
    public ValueTuple`2<long, long> GetLogEntriesRange(ClusterOperationContext context);
    public long GetFirstEntryIndex(ClusterOperationContext context);
    public long GetLastEntryIndex(ClusterOperationContext context);
    public long GetTermForKnownExisting(ClusterOperationContext context, long index);
    public Nullable`1<long> GetTermFor(ClusterOperationContext context, long index);
    public void FoundAboutHigherTerm(long term, string reason);
    public void ValidateTerm(long term);
    public void CastVoteInTerm(ClusterOperationContext context, long term, string votedFor, string reason);
    public ValueTuple`2<string, long> GetWhoGotMyVoteIn(ClusterOperationContext context, long term);
    [CompilerGeneratedAttribute]
public void add_OnDispose(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnDispose(EventHandler value);
    public bool get_IsDisposed();
    public virtual void Dispose();
    public abstract virtual Task`1<RachisConnection> ConnectToPeer(string url, string tag, X509Certificate2 certificate);
    public bool Bootstrap(string selfUrl, string nodeTag);
    public string HardResetToNewCluster(string nodeTag);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<HardResetToNewClusterAsync>d__187")]
public Task`1<string> HardResetToNewClusterAsync(string nodeTag);
    public Task HardResetToPassiveAsync(string topologyId);
    public static void ValidateNodeTag(string nodeTag);
    [DoesNotReturnAttribute]
public static void ThrowInvalidNodeTag(string nodeTag, string reason);
    public Task AddToClusterAsync(string url, string nodeTag, bool validateNotInTopology, bool asWatcher);
    public Task RemoveFromClusterAsync(string nodeTag);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<ModifyTopologyAsync>d__193")]
public Task ModifyTopologyAsync(string nodeTag, string nodeUrl, TopologyModification modification, bool validateNotInTopology);
    public string get_LeaderTag();
    internal void set_LeaderTag(string value);
    public string GetLeaderTag(bool safe);
    public bool get_IsEncrypted();
    public abstract virtual X509Certificate2 get_ClusterCertificate();
    public abstract virtual ServerStore get_ServerStore();
    public abstract virtual bool ShouldSnapshot(Slice slice, RootObjectType type);
    public abstract virtual long Apply(ClusterOperationContext context, long uptoInclusive, Leader leader, Stopwatch duration);
    public abstract virtual Task AfterSnapshotInstalledAsync(long lastIncludedIndex, Task onFullSnapshotInstalledTask, CancellationToken token);
    public abstract virtual Task OnSnapshotInstalled(ClusterOperationContext context, long lastIncludedIndex, CancellationToken token);
    public void InvokeBeforeAppendToRaftLog(ClusterOperationContext context, RachisMergedCommand cmd);
    [AsyncStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<WaitForHeartbeat>d__212")]
public Task WaitForHeartbeat();
    private void SetClusterBase(string str);
    public void ReportLeaderTime(long leaderTime);
    public DynamicJsonArray GetClusterErrorsFromLeader();
    public void UpdateNodeTag(ClusterOperationContext context, string newTag);
    [CompilerGeneratedAttribute]
public bool get_RequestSnapshot();
    [CompilerGeneratedAttribute]
private void set_RequestSnapshot(bool value);
    public void SetSnapshotRequest(TransactionOperationContext`1<TTransaction> context, bool request);
    public bool GetSnapshotRequest(TransactionOperationContext`1<TTransaction> context);
    public void LeaderElectToLeaderChanged();
    public void ClearAppendedEntriesAfter(ClusterOperationContext context, long index);
    public static bool IsExpectedException(Exception e);
    internal static void DisconnectAction(Task`1<RachisConnection> connectionTask);
    public RaftDebugView DebugView();
    public LogSummary GetLogDetails(ClusterOperationContext context, int start, int take, bool detailed);
    [IteratorStateMachineAttribute("Raven.Server.Rachis.RachisConsensus/<GetLogEntries>d__242")]
public IEnumerable`1<RachisDebugLogEntry> GetLogEntries(ClusterOperationContext context, long first, int start, int take, bool detailed);
    [CompilerGeneratedAttribute]
private void <ParallelDispose>b__125_0(IDisposable d);
    [CompilerGeneratedAttribute]
internal static void <AcceptNewConnectionAsync>g__DisposeRemoteConnection|150_0(RemoteConnection remoteConnection);
    [CompilerGeneratedAttribute]
private void <SetLastCommitIndex>b__165_0(IPagerLevelTransactionState _);
}
public class Raven.Server.Rachis.RachisConsensus`1 : RachisConsensus {
    private ServerStore _serverStore;
    public TStateMachine StateMachine;
    internal RachisVersionValidation Validator { get; }
    public X509Certificate2 ClusterCertificate { get; }
    public ServerStore ServerStore { get; }
    public RachisConsensus`1(ServerStore serverStore, Nullable`1<int> seed);
    internal virtual RachisStateMachine GetStateMachine();
    internal virtual RachisVersionValidation get_Validator();
    public virtual void Notify(Notification notification);
    protected virtual void InitializeState(ClusterOperationContext context, ClusterChanges changes);
    public virtual void Dispose();
    public virtual long Apply(ClusterOperationContext context, long uptoInclusive, Leader leader, Stopwatch duration);
    public void EnsureNodeRemovalOnDeletion(ClusterOperationContext context, long term, string nodeTag);
    public virtual X509Certificate2 get_ClusterCertificate();
    public virtual ServerStore get_ServerStore();
    public virtual bool ShouldSnapshot(Slice slice, RootObjectType type);
    public virtual Task AfterSnapshotInstalledAsync(long lastIncludedIndex, Task onFullSnapshotInstalledTask, CancellationToken token);
    public virtual Task OnSnapshotInstalled(ClusterOperationContext context, long lastIncludedIndex, CancellationToken token);
    public virtual Task`1<RachisConnection> ConnectToPeer(string url, string tag, X509Certificate2 certificate);
}
public class Raven.Server.Rachis.RachisDebugMessage : object {
    public DateTime At;
    public string Message;
    public long MsFromCycleStart;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Rachis.RachisEntry : object {
    [CompilerGeneratedAttribute]
private long <Term>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <Entry>k__BackingField;
    [CompilerGeneratedAttribute]
private RachisEntryFlags <Flags>k__BackingField;
    public long Term { get; public set; }
    public long Index { get; public set; }
    public BlittableJsonReaderObject Entry { get; public set; }
    public RachisEntryFlags Flags { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Term();
    [CompilerGeneratedAttribute]
public void set_Term(long value);
    [CompilerGeneratedAttribute]
public long get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(long value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_Entry();
    [CompilerGeneratedAttribute]
public void set_Entry(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public RachisEntryFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(RachisEntryFlags value);
    public virtual string ToString();
}
[FlagsAttribute]
public enum Raven.Server.Rachis.RachisEntryFlags : Enum {
    public int value__;
    public static RachisEntryFlags Invalid;
    public static RachisEntryFlags Noop;
    public static RachisEntryFlags Topology;
    public static RachisEntryFlags StateMachineCommand;
}
public abstract class Raven.Server.Rachis.RachisException : Exception {
    protected RachisException(string message);
    protected RachisException(string message, Exception innerException);
}
public class Raven.Server.Rachis.RachisHello : object {
    public string TopologyId;
    public string DebugSourceIdentifier;
    public string DebugDestinationIdentifier;
    public InitialMessageType InitialMessageType;
    public string DestinationUrl;
    public string SourceUrl;
    public int SendingThread;
    public int ElectionTimeout;
    public int ServerBuildVersion;
}
public class Raven.Server.Rachis.RachisInvalidOperationException : RachisException {
    public RachisInvalidOperationException(string message);
    public RachisInvalidOperationException(string message, Exception innerException);
    [DoesNotReturnAttribute]
public static void Throw(string msg);
}
public class Raven.Server.Rachis.RachisLogHistory : object {
    internal static Slice LogHistorySlice;
    private static Slice LogHistoryIndexSlice;
    private static Slice LogHistoryDateTimeSlice;
    private static TableSchema LogHistoryTable;
    private int _logHistoryMaxEntries;
    private Logger _log;
    private long _lastTicks;
    private static RachisLogHistory();
    private long GetUniqueTicks(Transaction transaction);
    public void Initialize(RavenTransaction tx, RavenConfiguration configuration, Logger log);
    public static string GetUniqueRequestIdFromCommand(BlittableJsonReaderObject command);
    public static Nullable`1<DateTime> GetDateTimeByGuid(ClusterOperationContext context, string guid);
    public static string GetTypeFromCommand(BlittableJsonReaderObject cmd);
    public void InsertHistoryLog(ClusterOperationContext context, long index, long term, BlittableJsonReaderObject cmd);
    public void UpdateHistoryLog(ClusterOperationContext context, long index, long term, BlittableJsonReaderObject cmd, object result, Exception exception);
    public void UpdateHistoryLogPreservingGuidAndStatus(ClusterOperationContext context, long index, long term, BlittableJsonReaderObject cmd);
    private void UpdateInternal(ClusterOperationContext context, BlittableJsonReaderObject cmd, string guid, string type, long index, long term, HistoryStatus status, object result, Exception exception);
    public void CancelHistoryEntriesFrom(ClusterOperationContext context, long from, long term, string msg);
    public string GetHistoryLogsAsString(ClusterOperationContext context);
    [IteratorStateMachineAttribute("Raven.Server.Rachis.RachisLogHistory/<GetHistoryLogs>d__22")]
public IEnumerable`1<DynamicJsonValue> GetHistoryLogs(ClusterOperationContext context);
    public List`1<DynamicJsonValue> GetLogByIndex(ClusterOperationContext context, long index);
    private static DynamicJsonValue ReadHistoryLog(ClusterOperationContext context, TableValueHolder entryHolder);
    private static long ReadCommittedTerm(TableValueHolder entryHolder);
    private static HistoryStatus ReadState(TableValueHolder entryHolder);
    private static string ReadType(TableValueHolder entryHolder);
    private static long ReadTerm(TableValueHolder entryHolder);
    private static long ReadIndex(TableValueHolder entryHolder);
    private static string ReadGuid(TableValueHolder entryHolder);
    public bool ContainsCommandId(ClusterOperationContext context, string guid);
    public bool HasHistoryLog(ClusterOperationContext context, string uniqueRequestId, Int64& index, Object& result, Exception& exception);
    public bool TryGetResultByGuid(ClusterOperationContext context, string guid, T& result);
}
public class Raven.Server.Rachis.RachisLogRecorder : object {
    private ConcurrentQueue`1<RachisTimings> _queue;
    private Stopwatch _sp;
    private RachisTimings _current;
    public ConcurrentBag`1<RachisDebugMessage> Timings { get; }
    public RachisLogRecorder(ConcurrentQueue`1<RachisTimings> queue);
    public ConcurrentBag`1<RachisDebugMessage> get_Timings();
    public void Start();
    public void Record(string message);
}
public abstract class Raven.Server.Rachis.RachisStateMachine : object {
    internal static bool EnableDebugLongCommit;
    protected ClusterContextPool ContextPoolForReadOnlyOperations;
    protected RachisConsensus _parent;
    public RachisVersionValidation Validator;
    [CompilerGeneratedAttribute]
private ClusterChanges <Changes>k__BackingField;
    public ClusterTransactionWaiter ClusterTransactionWaiter;
    public ClusterChanges Changes { get; private set; }
    [CompilerGeneratedAttribute]
public ClusterChanges get_Changes();
    [CompilerGeneratedAttribute]
private void set_Changes(ClusterChanges value);
    public virtual void Initialize(RachisConsensus parent, ClusterOperationContext context, ClusterChanges changes);
    public long Apply(ClusterOperationContext context, long uptoInclusive, Leader leader, ServerStore serverStore, Stopwatch duration);
    protected abstract virtual void Apply(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index, Leader leader, ServerStore serverStore);
    public virtual void EnsureNodeRemovalOnDeletion(ClusterOperationContext context, long term, string nodeTag);
    public virtual void Dispose();
    protected abstract virtual RachisVersionValidation InitializeValidator();
    public abstract virtual bool ShouldSnapshot(Slice slice, RootObjectType type);
    public abstract virtual Task`1<RachisConnection> ConnectToPeerAsync(string url, string tag, X509Certificate2 certificate, CancellationToken token);
    public virtual Task AfterSnapshotInstalledAsync(long lastIncludedIndex, Task onFullSnapshotInstalledTask, CancellationToken token);
    public virtual Task OnSnapshotInstalledAsync(ClusterOperationContext context, long lastIncludedIndex, CancellationToken token);
}
public class Raven.Server.Rachis.RachisTimings : object {
    public ConcurrentBag`1<RachisDebugMessage> Timings;
}
public class Raven.Server.Rachis.RachisTopologyChangeException : RachisException {
    public RachisTopologyChangeException(string message);
    public RachisTopologyChangeException(string message, Exception innerException);
    [DoesNotReturnAttribute]
public static void Throw(string msg);
}
public abstract class Raven.Server.Rachis.RachisVersionValidation : object {
    protected ClusterCommandsVersionManager CommandsVersionManager;
    protected RachisVersionValidation(ClusterCommandsVersionManager commandsVersionManager);
    public abstract virtual void AssertPutCommandToLeader(CommandBase cmd);
    public abstract virtual void AssertEntryBeforeSendToFollower(BlittableJsonReaderObject entry, int version, string follower);
}
public abstract class Raven.Server.Rachis.RaftDebugView : object {
    private RachisConsensus _engine;
    public long Term;
    public RaftCommandsVersion CommandsVersion;
    public DateTime Since;
    public LogSummary Log;
    public string Role { get; }
    protected RaftDebugView(RachisConsensus engine);
    public abstract virtual string get_Role();
    public void PopulateLogs(ClusterOperationContext context, int start, int take, bool detailed);
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Rachis.Remote.RemoteConnection : object {
    private string _destTag;
    private string _src;
    private Stream _stream;
    private SupportedFeatures _features;
    private MemoryBuffer _buffer;
    private JsonOperationContext _context;
    private IDisposable _releaseBuffer;
    private Logger _log;
    private Action _disconnect;
    private DisposeLock _disposerLock;
    private DisposeOnce`1<SingleAttempt> _disposeOnce;
    private RemoteConnectionInfo _info;
    private static int _connectionNumber;
    public static ConcurrentSet`1<RemoteConnectionInfo> RemoteConnectionsList;
    public string Source { get; }
    public Stream Stream { get; }
    public string Dest { get; }
    public SupportedFeatures Features { get; }
    public RemoteConnectionInfo Info { get; }
    public RemoteConnection(string src, long term, Stream stream, SupportedFeatures features, Action disconnect, string caller);
    public RemoteConnection(string dest, string src, long term, Stream stream, SupportedFeatures features, Action disconnect, string caller);
    private static RemoteConnection();
    public string get_Source();
    public Stream get_Stream();
    public string get_Dest();
    public SupportedFeatures get_Features();
    public RemoteConnectionInfo get_Info();
    public void Send(JsonOperationContext context, RachisHello helloMsg);
    private void Send(JsonOperationContext context, DynamicJsonValue msg);
    private void Send(JsonOperationContext context, BlittableJsonReaderObject msg, Action afterFlush);
    public void Send(JsonOperationContext context, RequestVoteResponse rvr);
    public void Send(JsonOperationContext context, LogLengthNegotiation lln);
    public void Send(JsonOperationContext context, LogLengthNegotiationResponse lln);
    public void Send(JsonOperationContext context, RequestVote rv);
    public void Send(JsonOperationContext context, Action updateFollowerTicks, AppendEntries ae, List`1<BlittableJsonReaderObject> items);
    public void Send(JsonOperationContext context, InstallSnapshot installSnapshot);
    public void Send(JsonOperationContext context, InstallSnapshotResponse installSnapshotResponse);
    public void Send(JsonOperationContext context, Exception e);
    internal int Read(Byte[] buffer, int offset, int count);
    private int ReadFromBuffer(Byte[] buffer, int offset, int count);
    public SnapshotReader CreateReader(RachisLogRecorder debugRecorder);
    public SnapshotReader CreateReaderToStream(RachisLogRecorder debugRecorder, Stream stream);
    public T Read(JsonOperationContext context);
    public InstallSnapshot ReadInstallSnapshot(JsonOperationContext context);
    public RachisEntry ReadRachisEntry(JsonOperationContext context);
    public void Send(JsonOperationContext context, AppendEntriesResponse aer, bool shouldLog);
    public sealed virtual void Dispose();
    private void DisposeInternal();
    public RachisHello InitFollower(JsonOperationContext context);
    public virtual string ToString();
    private void RegisterConnection(string dest, long term, string caller);
    private static void ValidateMessage(string expectedType, BlittableJsonReaderObject json);
    [DoesNotReturnAttribute]
private static void ThrowUnexpectedMessage(string type, string expectedType, BlittableJsonReaderObject json);
}
public class Raven.Server.Rachis.Remote.RemoteSnapshotReader : SnapshotReader {
    private RemoteConnection _parent;
    public RemoteSnapshotReader(RachisLogRecorder logger, RemoteConnection parent);
    protected virtual int InternalRead(int offset, int count);
}
public class Raven.Server.Rachis.Remote.RemoteToStreamSnapshotReader : RemoteSnapshotReader {
    private Stream _stream;
    public RemoteToStreamSnapshotReader(RachisLogRecorder logger, RemoteConnection parent, Stream stream);
    public virtual void ReadExactly(int size);
}
public abstract class Raven.Server.Rachis.Remote.SnapshotReader : object {
    private RachisLogRecorder _logger;
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    private UInt32 _readAttempts;
    private long _totalBytes;
    public Byte[] Buffer { get; private set; }
    public Size ReadSize { get; }
    protected SnapshotReader(RachisLogRecorder logger);
    [CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
private void set_Buffer(Byte[] value);
    public int ReadInt32();
    public long ReadInt64();
    public Size get_ReadSize();
    public virtual void ReadExactly(int size);
    protected abstract virtual int InternalRead(int offset, int count);
    public sealed virtual void Dispose();
}
public class Raven.Server.Rachis.Remote.StreamSnapshotReader : SnapshotReader {
    private Stream _stream;
    public StreamSnapshotReader(RachisLogRecorder logger, Stream stream);
    protected virtual int InternalRead(int offset, int count);
}
public class Raven.Server.Rachis.RequestVote : object {
    [CompilerGeneratedAttribute]
private int <SendingThread>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Term>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastLogIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastLogTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTrialElection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsForcedElection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ElectionResult <ElectionResult>k__BackingField;
    public int SendingThread { get; public set; }
    public long Term { get; public set; }
    public long LastLogIndex { get; public set; }
    public long LastLogTerm { get; public set; }
    public bool IsTrialElection { get; public set; }
    public bool IsForcedElection { get; public set; }
    public string Source { get; public set; }
    public ElectionResult ElectionResult { get; public set; }
    [CompilerGeneratedAttribute]
public int get_SendingThread();
    [CompilerGeneratedAttribute]
public void set_SendingThread(int value);
    [CompilerGeneratedAttribute]
public long get_Term();
    [CompilerGeneratedAttribute]
public void set_Term(long value);
    [CompilerGeneratedAttribute]
public long get_LastLogIndex();
    [CompilerGeneratedAttribute]
public void set_LastLogIndex(long value);
    [CompilerGeneratedAttribute]
public long get_LastLogTerm();
    [CompilerGeneratedAttribute]
public void set_LastLogTerm(long value);
    [CompilerGeneratedAttribute]
public bool get_IsTrialElection();
    [CompilerGeneratedAttribute]
public void set_IsTrialElection(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsForcedElection();
    [CompilerGeneratedAttribute]
public void set_IsForcedElection(bool value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public ElectionResult get_ElectionResult();
    [CompilerGeneratedAttribute]
public void set_ElectionResult(ElectionResult value);
}
public class Raven.Server.Rachis.RequestVoteResponse : object {
    [CompilerGeneratedAttribute]
private long <Term>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VoteGranted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotInTopology>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ClusterCommandsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public long Term { get; public set; }
    public bool VoteGranted { get; public set; }
    public bool NotInTopology { get; public set; }
    public Nullable`1<int> ClusterCommandsVersion { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Term();
    [CompilerGeneratedAttribute]
public void set_Term(long value);
    [CompilerGeneratedAttribute]
public bool get_VoteGranted();
    [CompilerGeneratedAttribute]
public void set_VoteGranted(bool value);
    [CompilerGeneratedAttribute]
public bool get_NotInTopology();
    [CompilerGeneratedAttribute]
public void set_NotInTopology(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ClusterCommandsVersion();
    [CompilerGeneratedAttribute]
public void set_ClusterCommandsVersion(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
public class Raven.Server.Rachis.TermValidationException : RachisConcurrencyException {
    public TermValidationException(string message);
    public TermValidationException(string message, Exception innerException);
    [DoesNotReturnAttribute]
public static void Throw(string msg);
}
public class Raven.Server.Rachis.TimeoutEvent : object {
    public bool Disable;
    private ManualResetEventSlim _timeoutEventSlim;
    private Timer _timer;
    private long _lastDeferredTicks;
    private Action _timeoutHappened;
    private string _currentLeader;
    public int TimeoutPeriod;
    private bool _singleShot;
    private Logger _logger;
    private MultipleUseFlag _flag;
    private int _inProgress;
    public TimeoutEvent(int timeoutPeriod, string name, bool singleShot);
    public TimeoutEvent(TimeSpan timeoutPeriod, string name, bool singleShot);
    public void Start(Action onTimeout);
    private void Callback(object state);
    private void DisableTimeoutInternal();
    public void DisableTimeout();
    public void ExecuteTimeoutBehavior();
    public void Defer(string leader);
    public bool ExpiredLastDeferral(double maxInMs, String& leader);
    public sealed virtual void Dispose();
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
}
public class Raven.Server.Rachis.TopologyMismatchException : Exception {
    public TopologyMismatchException(string message);
    public TopologyMismatchException(string message, Exception inner);
}
public class Raven.Server.RavenServer : object {
    private static Logger Logger;
    private Logger _authAuditLog;
    internal TestingStuff _forTestingPurposes;
    public RavenConfiguration Configuration;
    public Timer ServerMaintenanceTimer;
    public SystemTime Time;
    public ServerStore ServerStore;
    private IWebHost _webHost;
    private IWebHost _redirectingWebHost;
    private Logger _tcpLogger;
    private bool _openTelemetryInitialized;
    private ExternalCertificateValidator _externalCertificateValidator;
    internal JsonContextPool _tcpContextPool;
    public TwoFactor TwoFactor;
    [CompilerGeneratedAttribute]
private Action AfterDisposal;
    public ServerStatistics Statistics;
    [CompilerGeneratedAttribute]
private EventHandler ServerCertificateChanged;
    public ICpuUsageCalculator CpuUsageCalculator;
    public IDiskStatsGetter DiskStatsGetter;
    internal bool ThrowOnLicenseActivationFailure;
    internal bool AllowEncryptedDatabasesOverHttp;
    internal Action`1<StorageEnvironment> BeforeSchemaUpgrade;
    internal Action`1<StorageEnvironment> AfterDatabaseCreation;
    internal string DebugTag;
    internal DocumentConventions Conventions;
    public CpuCreditsState CpuCreditsBalance;
    private Task _currentRefreshTask;
    [CompilerGeneratedAttribute]
private string <WebUrl>k__BackingField;
    internal CertificateHolder Certificate;
    internal X509Certificate2[] WellKnownIssuers;
    internal String[] WellKnownIssuersThumbprints;
    private ClusterMaintenanceWorker _clusterMaintenanceWorker;
    public ScriptRunnerCache AdminScripts;
    private TcpListenerStatus _tcpListenerStatus;
    public SnmpWatcher SnmpWatcher;
    public MetricsManager MetricsManager;
    public PgServer PostgresServer;
    private Timer _refreshClusterCertificate;
    private HttpsConnectionMiddleware _httpsConnectionMiddleware;
    private LongRunningWork _cpuCreditsMonitoring;
    public ServerMetricCacher MetricCacher;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<IPAddress[], int> <ListenEndpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestRouter <Router>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricCounters <Metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedPipeServerStream <AdminConsolePipe>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedPipeServerStream <LogStreamPipe>k__BackingField;
    internal static bool SkipCertificateDispose;
    internal CipherSuitesPolicy CipherSuitesPolicy { get; }
    public Task RefreshTask { get; }
    public string WebUrl { get; private set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<IPAddress[], int> ListenEndpoints { get; private set; }
    public RequestRouter Router { get; private set; }
    public MetricCounters Metrics { get; }
    public bool Disposed { get; private set; }
    internal NamedPipeServerStream AdminConsolePipe { get; internal set; }
    internal NamedPipeServerStream LogStreamPipe { get; internal set; }
    private static RavenServer();
    public RavenServer(RavenConfiguration configuration, DocumentConventions conventions);
    [CompilerGeneratedAttribute]
public void add_AfterDisposal(Action value);
    [CompilerGeneratedAttribute]
public void remove_AfterDisposal(Action value);
    [CompilerGeneratedAttribute]
public void add_ServerCertificateChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ServerCertificateChanged(EventHandler value);
    internal CipherSuitesPolicy get_CipherSuitesPolicy();
    public TcpListenerStatus GetTcpServerStatus();
    public void Initialize();
    private void StartOpenTelemetry();
    private void ConfigureOpenTelemetry(IServiceCollection services);
    public T GetService();
    private void UpdateCertificateExpirationAlert();
    private void OnServerCertificateChanged(object sender, EventArgs e);
    public void ForceSyncCpuCredits();
    private void StartMonitoringCpuCredits();
    internal double UpdateCpuCreditsFromExec();
    private CpuCreditsResponse GetCpuCreditsFromExec();
    private void RedirectsHttpTrafficToHttps();
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<AssertServerCanContactItselfWhenAuthIsOn>d__48")]
private Task AssertServerCanContactItselfWhenAuthIsOn(X509Certificate2 certificateCertificate);
    private bool CertificateCallback(object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors errors);
    public Task get_RefreshTask();
    public void RefreshClusterCertificateTimerCallback(object state);
    public bool RefreshClusterCertificate(object state, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<DoActualCertificateRefresh>d__55")]
private Task DoActualCertificateRefresh(CertificateHolder currentCertificate, string raftRequestId, bool forceRenew);
    private Byte[] RefreshViaExecutable();
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<RefreshViaLetsEncrypt>d__57")]
private Task`1<Byte[]> RefreshViaLetsEncrypt(CertificateHolder currentCertificate, bool forceRenew);
    public ValueTuple`2<bool, DateTime> CalculateRenewalDate(CertificateHolder currentCertificate, bool forceRenew);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<StartCertificateReplicationAsync>d__59")]
public Task StartCertificateReplicationAsync(Byte[] certBytes, bool replaceImmediately, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<RenewLetsEncryptCertificate>d__60")]
private Task`1<Byte[]> RenewLetsEncryptCertificate(CertificateHolder existing);
    private ValueTuple`2<IPAddress[], int> GetServerAddressesAndPort();
    private string GetWebUrl(string kestrelUrl);
    private CertificateHolder LoadCertificateAtStartup();
    private CertificateHolder LoadCertificate();
    private Task ListenToPipes();
    internal AuthenticateConnection AuthenticateConnectionCertificate(X509Certificate2 certificate, object connectionInfo);
    private void MaybeAllowConnectionBasedOnPinningHash(X509Certificate2 certificate, TransactionOperationContext ctx, AuthenticateConnection& authenticationStatus, BlittableJsonReaderObject& cert, object connectionInfo);
    private static string GetRemoteAddress(object connectionInfo);
    [CompilerGeneratedAttribute]
public string get_WebUrl();
    [CompilerGeneratedAttribute]
private void set_WebUrl(string value);
    private void StartSnmp();
    private void StartPostgresServer();
    public TcpListenerStatus StartTcpListener(Action`1<TcpListener> listenToNewTcpConnection, Nullable`1<int> customPort);
    private void StartListeners(string host, int port, TcpListenerStatus status, Action`1<TcpListener> listenToNewTcpConnection);
    public IPAddress[] GetListenIpAddresses(string host);
    private void ListenToNewTcpConnection(TcpListener listener);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<DispatchTcpConnection>d__84")]
private Task DispatchTcpConnection(TcpConnectionHeaderMessage header, TcpConnectionOptions tcp, MemoryBuffer buffer, X509Certificate2 certificate);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<NegotiateOperationVersion>d__85")]
private Task`1<TcpConnectionHeaderMessage> NegotiateOperationVersion(Stream stream, MemoryBuffer buffer, TcpClient tcpClient, Logger tcpAuditLog, X509Certificate2 cert, TcpConnectionOptions tcp);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<AcceptTcpClientAsync>d__86")]
private Task`1<TcpClient> AcceptTcpClientAsync(TcpListener listener);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<RespondToTcpConnection>d__87")]
private static ValueTask RespondToTcpConnection(Stream stream, JsonOperationContext context, string error, TcpConnectionStatus status, int version, LicensedFeatures licensedFeatures);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<SendErrorIfPossible>d__88")]
private ValueTask SendErrorIfPossible(TcpConnectionOptions tcp, Exception e);
    [CompilerGeneratedAttribute]
public ValueTuple`2<IPAddress[], int> get_ListenEndpoints();
    [CompilerGeneratedAttribute]
private void set_ListenEndpoints(ValueTuple`2<IPAddress[], int> value);
    internal void SetCertificate(X509Certificate2 certificate, Byte[] rawBytes, string password);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<DispatchServerWideTcpConnection>d__104")]
private Task`1<bool> DispatchServerWideTcpConnection(TcpConnectionOptions tcp, TcpConnectionHeaderMessage header, MemoryBuffer buffer);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<DispatchDatabaseTcpConnection>d__105")]
private Task`1<bool> DispatchDatabaseTcpConnection(TcpConnectionOptions tcp, TcpConnectionHeaderMessage header, MemoryBuffer bufferToCopy, X509Certificate2 cert);
    private static void CreateSubscriptionConnection(ServerStore server, DatabaseSearchResult databaseResult, TcpConnectionOptions tcpConnectionOptions, MemoryBuffer buffer);
    [AsyncStateMachineAttribute("Raven.Server.RavenServer/<AuthenticateAsServerIfSslNeeded>d__107")]
internal Task`1<ValueTuple`2<Stream, X509Certificate2>> AuthenticateAsServerIfSslNeeded(Stream stream);
    private bool TryAuthorize(RavenConfiguration configuration, Stream stream, TcpConnectionHeaderMessage header, TcpClient tcpClient, String& msg, TcpConnectionStatus& statusResult);
    private void RegisterNewReplicationCertificateWithSamePublicKeyPinningHash(string remoteAddress, string database, string hub, DetailedReplicationHubAccess replicationHubAccess, X509Certificate2 certificate);
    private static bool ShouldUseDataCompression(TcpConnectionHeaderMessage header);
    [DoesNotReturnAttribute]
private static void ThrowDatabaseShutdown(string databaseName);
    [DoesNotReturnAttribute]
private static void ThrowTimeoutOnDatabaseLoad(TcpConnectionHeaderMessage header);
    private static void DispatchTcpMessageToTrafficWatch(EndPoint remoteEndPoint, TcpConnectionHeaderMessage header, X509Certificate2 certificate, Exception exception);
    [CompilerGeneratedAttribute]
public RequestRouter get_Router();
    [CompilerGeneratedAttribute]
private void set_Router(RequestRouter value);
    [CompilerGeneratedAttribute]
public MetricCounters get_Metrics();
    [CompilerGeneratedAttribute]
public bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    [CompilerGeneratedAttribute]
internal NamedPipeServerStream get_AdminConsolePipe();
    [CompilerGeneratedAttribute]
internal void set_AdminConsolePipe(NamedPipeServerStream value);
    [CompilerGeneratedAttribute]
internal NamedPipeServerStream get_LogStreamPipe();
    [CompilerGeneratedAttribute]
internal void set_LogStreamPipe(NamedPipeServerStream value);
    public sealed virtual void Dispose();
    private void CloseTcpListeners(List`1<TcpListener> listeners);
    public void OpenPipes();
    internal TestingStuff ForTestingPurposesOnly();
    public bool CertificateHasWellKnownIssuer(X509Certificate2 cert, String& issuer);
    private void ReadWellKnownIssuers();
    private void VerifyLicense(StorageEnvironment storageEnvironment);
    [CompilerGeneratedAttribute]
private void <Initialize>g__ConfigureKestrel|34_0(KestrelServerOptions options);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Initialize>b__34_2(ListenOptions listenOptions);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Initialize>b__34_3(ListenOptions listenOptions);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Initialize>b__34_1(IServiceCollection services);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Initialize>b__34_4(ResponseCompressionOptions options);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Initialize>b__34_5(ZstdCompressionProviderOptions options);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Initialize>b__34_6(GzipCompressionProviderOptions options);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Initialize>b__34_7(DeflateCompressionProviderOptions options);
    [CompilerGeneratedAttribute]
private void <Initialize>b__34_10(object _);
    [CompilerGeneratedAttribute]
private void <StartMonitoringCpuCredits>g__MaybeRaiseAlert|43_0(double threshold, double threadholdReleaseValue, MultipleUseFlag alertFlag, string alertMessage, int defaultTimeToAlert, AlertRaised& alert, Int32& remainingTimeToAlert);
    [CompilerGeneratedAttribute]
internal static string <GetCpuCreditsFromExec>g__GetStdError|46_0(<>c__DisplayClass46_0& );
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_1();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_2();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_3();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_4();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_5();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_6();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_7();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_8();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_9();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_10();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_11();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_12();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_13();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_14();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_15();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_16();
    [CompilerGeneratedAttribute]
private void <Dispose>b__134_17();
}
public class Raven.Server.RavenServerStartup : object {
    private RequestRouter _router;
    private RavenServer _server;
    private long _requestId;
    private Logger _logger;
    public static bool SkipHttpLogging;
    private static HashSet`1<string> RoutesAllowedInUnsafeMode;
    private static String[] UnsafeWarning;
    private static StringValues CacheControlHeaderValues;
    private static StringValues ContentTypeHeaderValue;
    internal static StringValues ServerVersionHeaderValue;
    private static RavenServerStartup();
    public void Configure(IApplicationBuilder app, ILoggerFactory loggerFactory);
    private bool IsServerRunningInASafeManner();
    [AsyncStateMachineAttribute("Raven.Server.RavenServerStartup/<UnsafeRequestHandler>d__8")]
private Task UnsafeRequestHandler(HttpContext context);
    public static bool IsHtmlAcceptable(HttpContext context);
    [AsyncStateMachineAttribute("Raven.Server.RavenServerStartup/<RequestHandler>d__14")]
private Task RequestHandler(HttpContext context);
    private static void CheckDatabaseShutdownAndThrowIfNeeded(RequestHandlerContext context, Exception& e);
    private static void CheckVersionAndWrapException(HttpContext context, Exception& e);
    private void LogTrafficWatch(HttpContext context, long elapsedMilliseconds, string database);
    private static void MaybeAddAdditionalExceptionData(DynamicJsonValue djv, Exception exception);
    private static void MaybeSetExceptionStatusCode(HttpContext httpContext, ServerStore serverStore, Exception exception);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private RequestDelegate <Configure>b__4_2(RequestDelegate _);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private RequestDelegate <Configure>b__4_3(RequestDelegate _);
    [CompilerGeneratedAttribute]
internal static bool <CheckVersionAndWrapException>g__HasInvalidCommandTypeException|16_0(Exception e);
}
public class Raven.Server.RedirectServerStartup : object {
    public void Configure(IApplicationBuilder app, ILoggerFactory loggerFactory);
    private Task RedirectRequestHandler(HttpContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private RequestDelegate <Configure>b__0_0(RequestDelegate _);
}
public enum Raven.Server.Routing.AuthorizationStatus : Enum {
    public int value__;
    public static AuthorizationStatus ClusterAdmin;
    public static AuthorizationStatus Operator;
    public static AuthorizationStatus DatabaseAdmin;
    public static AuthorizationStatus ValidUser;
    public static AuthorizationStatus UnauthenticatedClients;
    public static AuthorizationStatus RestrictedAccess;
}
public enum Raven.Server.Routing.CorsMode : Enum {
    public int value__;
    public static CorsMode None;
    public static CorsMode Cluster;
    public static CorsMode Public;
}
public enum Raven.Server.Routing.EndpointType : Enum {
    public int value__;
    public static EndpointType None;
    public static EndpointType Read;
    public static EndpointType Write;
}
public class Raven.Server.Routing.HandleRequest : MulticastDelegate {
    public HandleRequest(object object, IntPtr method);
    public virtual Task Invoke(RequestHandlerContext ctx);
    public virtual IAsyncResult BeginInvoke(RequestHandlerContext ctx, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
public class Raven.Server.Routing.RavenActionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsDebugInformationEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableOnCpuCreditsExhaustion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckForChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private CorsMode <CorsMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorizationStatus <RequiredAuthorization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipUsagesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipLastRequestTimeUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPosixSpecificEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<EndpointType> <EndpointType>k__BackingField;
    public bool IsDebugInformationEndpoint { get; public set; }
    public bool DisableOnCpuCreditsExhaustion { get; public set; }
    public bool CheckForChanges { get; public set; }
    public CorsMode CorsMode { get; public set; }
    public string Path { get; }
    public string Method { get; }
    public AuthorizationStatus RequiredAuthorization { get; public set; }
    public bool SkipUsagesCount { get; public set; }
    public bool SkipLastRequestTimeUpdate { get; public set; }
    public bool IsPosixSpecificEndpoint { get; public set; }
    public Nullable`1<EndpointType> EndpointType { get; }
    public RavenActionAttribute(string path, string method, AuthorizationStatus requireAuth, bool isDebugInformationEndpoint, bool isPosixSpecificEndpoint, bool checkForChanges, CorsMode corsMode);
    public RavenActionAttribute(string path, string method, AuthorizationStatus requireAuth, EndpointType endpointType, bool isDebugInformationEndpoint, bool isPosixSpecificEndpoint, bool checkForChanges, CorsMode corsMode);
    [CompilerGeneratedAttribute]
public bool get_IsDebugInformationEndpoint();
    [CompilerGeneratedAttribute]
public void set_IsDebugInformationEndpoint(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableOnCpuCreditsExhaustion();
    [CompilerGeneratedAttribute]
public void set_DisableOnCpuCreditsExhaustion(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckForChanges();
    [CompilerGeneratedAttribute]
public void set_CheckForChanges(bool value);
    [CompilerGeneratedAttribute]
public CorsMode get_CorsMode();
    [CompilerGeneratedAttribute]
public void set_CorsMode(CorsMode value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public AuthorizationStatus get_RequiredAuthorization();
    [CompilerGeneratedAttribute]
public void set_RequiredAuthorization(AuthorizationStatus value);
    [CompilerGeneratedAttribute]
public bool get_SkipUsagesCount();
    [CompilerGeneratedAttribute]
public void set_SkipUsagesCount(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipLastRequestTimeUpdate();
    [CompilerGeneratedAttribute]
public void set_SkipLastRequestTimeUpdate(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPosixSpecificEndpoint();
    [CompilerGeneratedAttribute]
public void set_IsPosixSpecificEndpoint(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<EndpointType> get_EndpointType();
}
public class Raven.Server.Routing.RavenShardedActionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    public string Path { get; }
    public string Method { get; }
    public RavenShardedActionAttribute(string path, string method);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Method();
}
public class Raven.Server.Routing.RequestRouter : object {
    public List`1<RouteInformation> AllRoutes;
    private static string BrowserCertificateMessage;
    public static TimeSpan LastRequestTimeUpdateFrequency;
    private RavenServer _ravenServer;
    private MetricCounters _serverMetrics;
    private Trie`1<RouteInformation> _trie;
    private DateTime _lastAuthorizedNonClusterAdminRequestTime;
    private DateTime _lastRequestTimeUpdated;
    public RequestRouter(Dictionary`2<string, RouteInformation> routes, RavenServer ravenServer);
    private static RequestRouter();
    public static void AssertClientVersion(HttpContext context, Exception innerException);
    public static bool CheckClientVersionAndWrapException(Version clientVersion, Exception& innerException);
    public static bool TryGetClientVersion(HttpContext context, Version& version);
    public RouteInformation GetRoute(string method, string path, RouteMatch& match);
    [AsyncStateMachineAttribute("Raven.Server.Routing.RequestRouter/<TryAuthorizeAsync>d__13")]
internal ValueTask`1<ValueTuple`3<bool, AuthenticationStatus, string>> TryAuthorizeAsync(RouteInformation route, HttpContext context, string databaseName);
    internal bool CanAccessRoute(RouteInformation route, HttpContext context, string databaseName, AuthenticateConnection feature);
    [AsyncStateMachineAttribute("Raven.Server.Routing.RequestRouter/<HandlePath>d__15")]
public ValueTask HandlePath(RequestHandlerContext reqCtx);
    [AsyncStateMachineAttribute("Raven.Server.Routing.RequestRouter/<DrainRequestAsync>d__16")]
private static ValueTask DrainRequestAsync(JsonOperationContext ctx, HttpContext context);
    [AsyncStateMachineAttribute("Raven.Server.Routing.RequestRouter/<RejectRequestBecauseOfCpuThresholdAsync>d__17")]
private static ValueTask RejectRequestBecauseOfCpuThresholdAsync(HttpContext context);
    [AsyncStateMachineAttribute("Raven.Server.Routing.RequestRouter/<UnlikelyFailAuthorizationAsync>d__18")]
public static ValueTask UnlikelyFailAuthorizationAsync(HttpContext context, string database, AuthenticateConnection feature, AuthorizationStatus authorizationStatus);
    private bool ShouldRetryToAuthenticateConnection(AuthenticateConnection authenticateConnection);
    [DoesNotReturnAttribute]
private static void ThrowUnknownAuthStatus(RouteInformation route);
    [DoesNotReturnAttribute]
private static void ThrowUnknownAuthStatus(AuthenticationStatus status);
}
public class Raven.Server.Routing.RouteInformation : object {
    public AuthorizationStatus AuthorizationStatus;
    public Nullable`1<EndpointType> EndpointType;
    public string Method;
    public string Path;
    public bool SkipUsagesCount;
    public bool SkipLastRequestTimeUpdate;
    public CorsMode CorsMode;
    public bool DisableOnCpuCreditsExhaustion;
    public bool CheckForChanges;
    private HandleRequest _request;
    private HandleRequest _shardedRequest;
    private RouteType _typeOfRoute;
    public bool IsDebugInformationEndpoint;
    public RouteType TypeOfRoute { get; }
    public RouteInformation(string method, string path, AuthorizationStatus authorizationStatus, Nullable`1<EndpointType> endpointType, bool skipUsagesCount, bool skipLastRequestTimeUpdate, CorsMode corsMode, bool isDebugInformationEndpoint, bool disableOnCpuCreditsExhaustion, bool checkForChanges);
    public RouteType get_TypeOfRoute();
    public void BuildSharded(MethodInfo shardedAction);
    public void Build(MethodInfo action);
    private static HandleRequest BuildInternal(MethodInfo action);
    public Task CreateDatabase(RequestHandlerContext context);
    [AsyncStateMachineAttribute("Raven.Server.Routing.RouteInformation/<UnlikelyWaitForDatabaseToUnload>d__21")]
private Task UnlikelyWaitForDatabaseToUnload(RequestHandlerContext context, DocumentDatabase database, DatabasesLandlord databasesLandlord, StringSegment databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Routing.RouteInformation/<UnlikelyWaitForDatabaseToLoad>d__22")]
private Task UnlikelyWaitForDatabaseToLoad(RequestHandlerContext context, Task`1<DocumentDatabase> database, DatabasesLandlord databasesLandlord, StringSegment databaseName);
    [DoesNotReturnAttribute]
private static void ThrowDatabaseUnloadTimeout(StringSegment databaseName, TimeSpan timeout);
    [DoesNotReturnAttribute]
private static void ThrowDatabaseLoadTimeout(StringSegment databaseName, TimeSpan timeout);
    [DoesNotReturnAttribute]
private static void ThrowDatabaseLoadTimeoutWithLog(StringSegment databaseName, TimeSpan timeout, string log);
    public Tuple`2<HandleRequest, Task`1<HandleRequest>> TryGetHandler(RequestHandlerContext context);
    [AsyncStateMachineAttribute("Raven.Server.Routing.RouteInformation/<WaitForDb>d__27")]
private Task`1<HandleRequest> WaitForDb(Task databaseLoading);
    public HandleRequest GetRequestHandler();
    public HandleRequest GetShardedRequestHandler();
    public virtual string ToString();
}
public class Raven.Server.Routing.RouteMatch : ValueType {
    public string Url;
    public string Method;
    public int CaptureStart;
    public int CaptureLength;
    public int MatchLength;
    public StringSegment GetCapture();
}
public class Raven.Server.Routing.RouteScanner : object {
    public static List`1<RouteInformation> DebugRoutes;
    public static Dictionary`2<string, RouteInformation> AllRoutes;
    private static RouteScanner();
    public static Dictionary`2<string, RouteInformation> Scan(Func`2<RavenActionAttribute, bool> predicate);
}
public class Raven.Server.Routing.Trie`1 : object {
    public string DebugKey;
    public string Key;
    public T Value;
    public int Mask;
    public Trie`1[] Children;
    public Trie`1[] FilteredChildren { get; }
    public Trie`1[] get_FilteredChildren();
    private Trie`1<T> GetNodeAt(char ch);
    public MatchResult<T> TryMatch(string method, string url);
    public virtual string ToString();
    public static Trie`1<T> Build(Dictionary`2<string, T> source);
    private void Optimize();
    private void OptimizeInternal(int size, Trie`1[] children);
    private static void EnsureRoutsAreOnlyUsingASCII(String[] sortedKeys);
    private static void Build(Trie`1<T> current, Dictionary`2<string, T> source, String[] sortedKeys, int matchStart, int start, int count);
    private static bool HandleStarRoute(Trie`1<T> current, Dictionary`2<string, T> source, String[] sortedKeys, int matchStart, int start, int count);
    private static void AddChild(Trie`1<T> current, Dictionary`2<string, T> source, String[] sortedKeys, int matchingIndex, int childStart, int childCount);
    private static bool CharEqualsAt(char x, char y);
}
public abstract class Raven.Server.ServerWide.AbstractRaftIndexNotifications`1 : object {
    protected ConcurrentQueue`1<ErrorHolder> Errors;
    private ConcurrentQueue`1<TNotification> _recentNotifications;
    public int RecentNotificationsMaxEntries;
    private int _numberOfErrors;
    private RaftIndexWaiter _raftIndexWaiter;
    public long LastModifiedIndex { get; }
    protected AbstractRaftIndexNotifications`1(CancellationToken token);
    public long get_LastModifiedIndex();
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.AbstractRaftIndexNotifications`1/<WaitForIndexNotification>d__9")]
public Task WaitForIndexNotification(long index, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.AbstractRaftIndexNotifications`1/<WaitForIndexNotification>d__10")]
public Task WaitForIndexNotification(long index, TimeSpan timeout);
    public abstract virtual Task`1<bool> WaitForTaskCompletion(long index, Lazy`1<Task> waitingTask);
    public virtual void NotifyListenersAbout(long index, Exception e);
    public void RecordNotification(TNotification notification);
    protected void ThrowCanceledException(long index, long lastModifiedIndex, bool isExecution);
    protected void ThrowApplyException(long index, Exception e);
    private void ThrowTimeoutException(TimeSpan value, long index, long lastModifiedIndex, bool isExecution);
    internal string PrintLastNotifications();
}
public class Raven.Server.ServerWide.BackgroundTasks.LatestVersionCheck : object {
    private static string ApiRavenDbNet;
    private static Logger Logger;
    public static LatestVersionCheck Instance;
    private SemaphoreSlim _locker;
    private VersionInfo _lastRetrievedVersionInfo;
    private AlertRaised _alert;
    private Timer _timer;
    private string _releaseChannel;
    private ConcurrentSet`1<WeakReference`1<ServerStore>> _serverStores;
    private static RavenHttpClient ApiRavenDbClient;
    private static LatestVersionCheck();
    public void Initialize(UpdatesConfiguration configuration);
    public void Check(ServerStore serverStore);
    public VersionInfo GetLastRetrievedVersionUpdatesInfo();
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.BackgroundTasks.LatestVersionCheck/<PerformAsync>d__14")]
public Task PerformAsync();
    private void AddAlertToNotificationCenter();
    private static NotificationSeverity DetermineSeverity(VersionInfo latestVersionInfo);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Raven.Server.ServerWide.BackgroundTasks.LatestVersionCheck/<<Initialize>b__11_0>d")]
[CompilerGeneratedAttribute]
private void <Initialize>b__11_0(object state);
}
public class Raven.Server.ServerWide.CertificateReplacement : object {
    public string Certificate;
    public string Thumbprint;
    public string OldThumbprint;
    public int Confirmations;
    public int Replaced;
    public bool ReplaceImmediately;
    public static string CertReplaceAlertTitle;
    public static string CertificateReplacementDoc;
}
public class Raven.Server.ServerWide.ClusterChanges : object {
    [CompilerGeneratedAttribute]
private Action`1<CompareExchangeChange> OnCompareExchangeChange;
    private DatabaseChangedDelegate[] _onDatabaseChanged;
    private ValueChangedDelegate[] _onValueChanged;
    [CompilerGeneratedAttribute]
public void add_OnCompareExchangeChange(Action`1<CompareExchangeChange> value);
    [CompilerGeneratedAttribute]
public void remove_OnCompareExchangeChange(Action`1<CompareExchangeChange> value);
    public void RaiseNotifications(CompareExchangeChange compareExchangeChange);
    public void add_DatabaseChanged(DatabaseChangedDelegate value);
    public void remove_DatabaseChanged(DatabaseChangedDelegate value);
    public void add_ValueChanged(ValueChangedDelegate value);
    public void remove_ValueChanged(ValueChangedDelegate value);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ClusterChanges/<OnDatabaseChanges>d__14")]
public Task OnDatabaseChanges(string databaseName, long index, string type, ClusterDatabaseChangeType changeType, object changeState);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ClusterChanges/<OnValueChanges>d__15")]
public Task OnValueChanges(long index, string type);
}
public class Raven.Server.ServerWide.ClusterCommandsVersionManager : object {
    public static int Base40CommandsVersion;
    public static int Base41CommandsVersion;
    public static int Base42CommandsVersion;
    public static int ClusterEngineVersion;
    public static int MyCommandsVersion;
    private int _currentClusterMinimalVersion;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClusterVersionChangeEventArgs> OnClusterVersionChange;
    private static Logger Log;
    public static IReadOnlyDictionary`2<string, int> ClusterCommandsVersions;
    public int CurrentClusterMinimalVersion { get; }
    private static ClusterCommandsVersionManager();
    public int get_CurrentClusterMinimalVersion();
    [CompilerGeneratedAttribute]
public void add_OnClusterVersionChange(EventHandler`1<ClusterVersionChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnClusterVersionChange(EventHandler`1<ClusterVersionChangeEventArgs> value);
    public bool CanPutCommand(string command);
    [DoesNotReturnAttribute]
private static void ThrowInvalidClusterVersion(int version);
    public void SetClusterVersion(int version);
    public int GetClusterMinimalVersion(List`1<int> versions, Nullable`1<int> maximalVersion);
}
public class Raven.Server.ServerWide.ClusterNodesVersionMismatchException : RavenException {
    public ClusterNodesVersionMismatchException(string message);
    public ClusterNodesVersionMismatchException(string message, Exception innerException);
}
public class Raven.Server.ServerWide.ClusterStateMachine : RachisStateMachine {
    private Logger _clusterAuditLog;
    private static string LocalNodeStateTreeName;
    private static StringSegment DatabaseName;
    public static TableSchema ItemsSchema;
    public static TableSchema CompareExchangeSchema;
    public static TableSchema CompareExchangeTombstoneSchema;
    public static TableSchema TransactionCommandsSchema;
    public static TableSchema IdentitiesSchema;
    public static TableSchema CertificatesSchema;
    public static TableSchema ReplicationCertificatesSchema;
    public static TableSchema SubscriptionStateSchema;
    public static Slice Items;
    public static Slice CompareExchange;
    public static Slice CompareExchangeTombstones;
    public static Slice Identities;
    public static Slice IdentitiesIndex;
    public static Slice TransactionCommands;
    public static Slice TransactionCommandsCountPerDatabase;
    public static Slice CompareExchangeIndex;
    public static Slice CompareExchangeTombstoneIndex;
    public static Slice CertificatesSlice;
    public static Slice CertificatesHashSlice;
    public static Slice ReplicationCertificatesSlice;
    public static Slice ReplicationCertificatesHashSlice;
    public static Slice SubscriptionState;
    public static Slice SubscriptionStateKeySlice;
    public static Slice SubscriptionStateByBatchIdSlice;
    public RachisLogIndexNotifications _rachisLogIndexNotifications;
    private static String[] DatabaseRecordTasks;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`3[] _snapshotEntries;
    public static string SnapshotInstalled;
    public SubscriptionsClusterStorage Subscriptions;
    private static int MinBuildVersion60000;
    private static int MinBuildVersion60102;
    private static int MinBuildVersion60105;
    private static List`1<string> _licenseLimitsCommandsForCreateDatabase;
    public long LastNotifiedIndex { get; }
    private static ClusterStateMachine();
    private void PutClientConfiguration(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, ServerStore serverStore);
    public long get_LastNotifiedIndex();
    public virtual void Dispose();
    protected virtual void Apply(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index, Leader leader, ServerStore serverStore);
    private void ExecutePutSubscriptionBatch(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index, string type, ServerStore serverStore);
    private static void SetIndexForBackup(ClusterOperationContext context, string databaseName, long index, string type);
    [ConditionalAttribute("DEBUG")]
private void ValidateGuid(BlittableJsonReaderObject cmd, string type);
    private void ExecuteCompareExchangeBatch(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index, string commandType);
    public static bool ExpectedException(Exception e);
    private void ClusterStateCleanUp(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index);
    private object ExecuteClusterTransaction(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index);
    private void UpdateDatabaseRecordId(ClusterOperationContext context, RawDatabaseRecord& rawRecord, long index, ClusterTransactionCommand clusterTransaction);
    private void ConfirmReceiptServerCertificate(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index, ServerStore serverStore);
    private void InstallUpdatedServerCertificate(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index, ServerStore serverStore);
    private void ConfirmServerCertificateReplaced(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index, ServerStore serverStore);
    private void RemoveNodeFromCluster(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index, Leader leader, ServerStore serverStore);
    private void ExecuteManyOnDispose(ClusterOperationContext context, long index, string type, List`1<Func`1<Task>> tasks);
    public void NotifyAndSetCompleted(long index);
    private void NotifyLeaderAboutError(long index, Leader leader, Exception e);
    private void NotifyLeaderAboutFatalError(long index, Leader leader, Exception e);
    private static bool ValidatePropertyExistence(BlittableJsonReaderObject cmd, string propertyTypeName, string propertyName, String& errorMessage);
    private void SetValueForTypedDatabaseCommand(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, Object& result, Action`2<Table, UpdateValueForDatabaseCommand> onBeforeCommandExecuted);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<WaitForIndexNotification>d__59")]
public Task WaitForIndexNotification(long index, Nullable`1<TimeSpan> timeout);
    private void RemoveNodeFromDatabase(ClusterOperationContext context, BlittableJsonReaderObject cmd, long index, Leader leader, ServerStore serverStore);
    private static void DeleteDatabaseRecord(ClusterOperationContext context, long index, Table items, Slice lowerKey, DatabaseRecord record, ServerStore serverStore);
    private static void CleanupDatabaseReplicationCertificate(ClusterOperationContext context, string databaseName);
    private static void CleanupDatabaseRelatedValues(ClusterOperationContext context, Table items, DatabaseRecord record, ServerStore serverStore);
    internal static void UpdateValue(long index, Table items, Slice lowerKey, Slice key, BlittableJsonReaderObject updated);
    internal static void UpdateValueForItemsTable(ClusterOperationContext context, long index, Slice lowerKey, Slice key, BlittableJsonReaderObject updated);
    internal static void UpdateCertificate(Table certificates, Slice key, Slice hash, BlittableJsonReaderObject updated);
    private List`1<string> AddDatabase(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, ServerStore serverStore);
    private BlittableJsonReaderObject UpdateDatabaseRecordIfNeeded(bool databaseExists, bool shouldSetClientConfigEtag, long index, AddDatabaseCommand addDatabaseCommand, BlittableJsonReaderObject newDatabaseRecord, ClusterOperationContext context);
    private void AddStampToAllRemotes(long index, ValueTuple`2[] remote);
    private void AddStampToRemote(long index, DatabaseTopology topology);
    private static bool IsExcluded(BlittableJsonReaderObject configurationBlittable, string databaseName);
    private static bool ShouldSetClientConfigEtag(BlittableJsonReaderObject newDatabaseRecord, BlittableJsonReaderObject oldDatabaseRecord);
    private static void SetDatabaseValues(Dictionary`2<string, BlittableJsonReaderObject> databaseValues, string databaseName, ClusterOperationContext context, long index, Table items);
    private void DeleteValue(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index);
    private void DeleteCertificate(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index);
    private void DeleteMultipleCertificates(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index);
    private static void DeleteDatabaseFromCertificatePermissions(ClusterOperationContext context, string database);
    public static void DeleteItem(TransactionOperationContext`1<TTransaction> context, string name);
    public void DeleteCertificate(TransactionOperationContext`1<TTransaction> context, string thumbprint);
    private void DeleteMultipleValues(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, Leader leader);
    private T UpdateValue(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, bool skipNotifyValueChanged);
    public string GetServerWideTaskNameByTaskId(TransactionOperationContext context, string key, long taskId);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetServerWideConfigurations>d__84")]
public IEnumerable`1<BlittableJsonReaderObject> GetServerWideConfigurations(TransactionOperationContext context, OngoingTaskType type, string name);
    private T PutValue(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index);
    internal static void PutValueDirectly(ClusterOperationContext context, string key, BlittableJsonReaderObject value, long index);
    private void PutCertificate(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, ServerStore serverStore);
    private void BulkPutReplicationCertificate(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, ServerStore serverStore);
    private void PutReplicationCertificate(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, ServerStore serverStore);
    private void PutRegisterReplicationHubAccessInternal(ClusterOperationContext context, RegisterReplicationHubAccessCommand command, Table certs);
    private void RemoveReplicationCertificate(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, ServerStore serverStore);
    private void DiscardLeftoverCertsWithSamePinningHash(ClusterOperationContext context, string hash, string type, long index);
    public virtual void EnsureNodeRemovalOnDeletion(ClusterOperationContext context, long term, string nodeTag);
    private void NotifyValueChanged(ClusterOperationContext context, string type, long index);
    private void NotifyDatabaseAboutChanged(ClusterOperationContext context, string databaseName, long index, string type, ClusterDatabaseChangeType change, object changeState);
    private void ExecuteAsyncTask(long index, Func`1<Task> task);
    private void UpdateDatabase(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, ServerStore serverStore);
    private void LogCommand(string type, long index, Exception exception, CommandBase commandBase);
    private void LogCommandInternal(string type, long index, Exception exception, CommandBase commandBase);
    private static void UpdateIndexForBackup(DatabaseRecord databaseRecord, string type, long index);
    public virtual bool ShouldSnapshot(Slice slice, RootObjectType type);
    public virtual void Initialize(RachisConsensus parent, ClusterOperationContext context, ClusterChanges changes);
    private void SwitchToSingleLeader(ClusterOperationContext context);
    private void UpdateLicenseOnSwitchingToSingleLeader(ClusterOperationContext context);
    private void ShrinkClusterTopology(ClusterOperationContext context, ClusterTopology clusterTopology, string newTag, long index);
    private void SqueezeDatabasesToSingleNodeCluster(ClusterOperationContext context, string oldTag, string newTag);
    public void PutLocalState(TransactionOperationContext context, string thumbprint, BlittableJsonReaderObject value, CertificateDefinition certificateDefinition);
    public void DeleteLocalState(TransactionOperationContext`1<TTransaction> context, string thumbprint);
    public void DeleteLocalState(TransactionOperationContext context, List`1<string> thumbprints);
    public BlittableJsonReaderObject GetLocalStateByThumbprint(TransactionOperationContext`1<TTransaction> context, string thumbprint);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetCertificateThumbprintsFromLocalState>d__113")]
public IEnumerable`1<string> GetCertificateThumbprintsFromLocalState(TransactionOperationContext context);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetAllCertificatesFromLocalState>d__114")]
public static IEnumerable`1<ValueTuple`2<string, BlittableJsonReaderObject>> GetAllCertificatesFromLocalState(TransactionOperationContext context);
    private static ValueTuple`2<string, BlittableJsonReaderObject> GetCertificate(TransactionOperationContext context, TreeIterator treeIterator);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetAllCertificatesFromCluster>d__116")]
public static IEnumerable`1<ValueTuple`2<string, BlittableJsonReaderObject>> GetAllCertificatesFromCluster(TransactionOperationContext context, long start, long take);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetCertificateThumbprintsFromCluster>d__117`1")]
public IEnumerable`1<string> GetCertificateThumbprintsFromCluster(TransactionOperationContext`1<TTransaction> context);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<ItemsStartingWith>d__118`1")]
public IEnumerable`1<ValueTuple`3<string, long, BlittableJsonReaderObject>> ItemsStartingWith(TransactionOperationContext`1<TTransaction> context, string prefix, long start, long take);
    public BlittableJsonReaderObject GetItem(TransactionOperationContext`1<TTransaction> context, string key);
    private void ExecuteCompareExchange(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, Object& result);
    private void OnTransactionDispose(ClusterOperationContext context, long index);
    public ValueTuple`2<long, BlittableJsonReaderObject> GetCompareExchangeValue(TransactionOperationContext`1<TRavenTransaction> context, Slice key);
    public static ValueTuple`2<long, BlittableJsonReaderObject> GetCompareExchangeValue(TransactionOperationContext`1<TTransaction> context, Slice key, Table items);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetCompareExchangeFromPrefix>d__124")]
[ObsoleteAttribute("This method should not be used directly. Use the one from 'AbstractCompareExchangeStorage'.")]
public IEnumerable`1<ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject>> GetCompareExchangeFromPrefix(ClusterOperationContext context, string dbName, long fromIndex, long take);
    [ObsoleteAttribute("This method should not be used directly. Use the one from 'AbstractCompareExchangeStorage'.")]
public long GetLastCompareExchangeIndexForDatabase(ClusterOperationContext context, string databaseName);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetCompareExchangeTombstonesByKey>d__126")]
[ObsoleteAttribute("This method should not be used directly. Use the one from 'AbstractCompareExchangeStorage'.")]
public IEnumerable`1<ValueTuple`2<CompareExchangeKey, long>> GetCompareExchangeTombstonesByKey(ClusterOperationContext context, string databaseName, long fromIndex, long take);
    private bool DeleteExpiredCompareExchange(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index);
    private void ClearCompareExchangeTombstones(ClusterOperationContext context, string type, BlittableJsonReaderObject cmd, long index, Boolean& result);
    private static bool DeleteCompareExchangeTombstonesUpToPrefix(ClusterOperationContext context, string dbName, long upToIndex, long take);
    internal static CompareExchangeKey ReadCompareExchangeKey(ClusterOperationContext context, TableValueReader reader, string dbPrefix);
    internal static BlittableJsonReaderObject ReadCompareExchangeValue(TransactionOperationContext`1<TTransaction> context, TableValueReader reader);
    public static long ReadCompareExchangeOrTombstoneIndex(TableValueReader reader);
    private static long ReadIdentitiesIndex(TableValueReader reader);
    public List`1<string> ItemKeysStartingWith(TransactionOperationContext context, string prefix, long start, long take);
    public List`1<string> GetDatabaseNames(TransactionOperationContext`1<TTransaction> context, long take);
    public List`1<DatabaseRecord> GetAllDatabases(TransactionOperationContext`1<TTransaction> context, long take);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetAllRawDatabases>d__137`1")]
public IEnumerable`1<RawDatabaseRecord> GetAllRawDatabases(TransactionOperationContext`1<TTransaction> context, long skip, long take);
    public static string GetCurrentItemKey(TableValueHolder result);
    private static ValueTuple`3<string, long, BlittableJsonReaderObject> GetCurrentItem(TransactionOperationContext`1<TTransaction> context, TableValueHolder result);
    public BlittableJsonReaderObject GetCertificateByThumbprint(TransactionOperationContext`1<TTransaction> context, string thumbprint);
    private static ValueTuple`2<string, BlittableJsonReaderObject> GetCertificate(TransactionOperationContext`1<TTransaction> context, TableValueHolder result);
    private static ValueTuple`2<string, BlittableJsonReaderObject> GetCertificate(TransactionOperationContext`1<TTransaction> context, Byte* ptr, int size, string key);
    private static CertificateDefinition GetCertificateDefinition(TransactionOperationContext`1<TTransaction> context, TableValueHolder result);
    public List`1<CertificateDefinition> GetCertificatesByPinningHashSortedByExpiration(ClusterOperationContext context, string hash);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetCertificatesByPinningHash>d__145`1")]
public IEnumerable`1<CertificateDefinition> GetCertificatesByPinningHash(TransactionOperationContext`1<TTransaction> context, string hash);
    public ShardingConfiguration ReadShardingConfiguration(string database);
    public ShardingConfiguration ReadShardingConfiguration(ClusterOperationContext context, string name);
    public DatabaseRecord ReadDatabase(TransactionOperationContext`1<TTransaction> context, string name);
    public RawDatabaseRecord ReadRawDatabaseRecord(TransactionOperationContext`1<TTransaction> context, string name, Int64& etag);
    private static BlittableJsonReaderObject BuildShardedDatabaseRecord(JsonOperationContext context, BlittableJsonReaderObject rawRecord, int shardNumber);
    public RawDatabaseRecord ReadRawDatabaseRecord(TransactionOperationContext`1<TTransaction> context, string name);
    public bool DatabaseExists(TransactionOperationContext`1<TTransaction> context, string name);
    public bool DatabaseExists(string name);
    public DatabaseRecord ReadDatabase(TransactionOperationContext`1<TTransaction> context, string name, Int64& etag);
    public DatabaseTopology ReadDatabaseTopology(TransactionOperationContext`1<TTransaction> context, string name);
    public DatabaseTopology ReadDatabaseTopologyForShard(TransactionOperationContext`1<TTransaction> context, string name, int shardNumber);
    public bool TryReadPullReplicationDefinition(string database, string definitionName, ClusterOperationContext context, PullReplicationDefinition& pullReplication);
    public TimeSeriesConfiguration ReadTimeSeriesConfiguration(string database);
    public PullReplicationDefinition ReadPullReplicationDefinition(string database, string definitionName, TransactionOperationContext`1<TRavenTranscation> context);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetIdentitiesFromPrefix>d__160")]
public IEnumerable`1<ValueTuple`3<string, long, long>> GetIdentitiesFromPrefix(ClusterOperationContext context, string dbName, long fromIndex, long take);
    private static long GetIdentityValue(TableValueReader reader);
    private static string GetIdentityKey(TableValueReader reader, string dbName);
    public long GetNumberOfIdentities(ClusterOperationContext context, string databaseName);
    public long GetNumberOfCompareExchange(ClusterOperationContext context, string databaseName);
    public long GetNumberOfCompareExchangeTombstones(ClusterOperationContext context, string databaseName);
    public bool HasCompareExchangeTombstones(TransactionOperationContext`1<TRavenTransaction> context, string databaseName);
    private static bool HasPrefixOf(Tree tree, string prefix, TransactionOperationContext`1<TRavenTransaction> context);
    private static long GetNumberOf(Tree tree, string prefix, ClusterOperationContext context);
    public BlittableJsonReaderObject Read(TransactionOperationContext`1<T> context, string name);
    public BlittableJsonReaderObject Read(TransactionOperationContext`1<T> context, string name, Int64& etag);
    public static BlittableJsonReaderObject ReadInternal(TransactionOperationContext`1<T> context, Int64& etag, Slice key);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<ReadValuesStartingWith>d__172`1")]
public static IEnumerable`1<ValueTuple`2<Slice, BlittableJsonReaderObject>> ReadValuesStartingWith(TransactionOperationContext`1<TTransaction> context, string startsWithKey, long skip);
    private static int GetDataAndEtagTupleFromReader(TransactionOperationContext`1<TTransaction> context, TableValueReader reader, BlittableJsonReaderObject& doc, Int64& etag);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<ClusterReadResponseAndGetVersion>d__174")]
private ValueTask`1<NegotiationResponse> ClusterReadResponseAndGetVersion(JsonOperationContext ctx, AsyncBlittableJsonTextWriter writer, Stream stream, string url);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<ConnectToPeerAsync>d__175")]
public virtual Task`1<RachisConnection> ConnectToPeerAsync(string url, string tag, X509Certificate2 certificate, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<NegotiateProtocolVersionAsyncForCluster>d__176")]
private Task`1<SupportedFeatures> NegotiateProtocolVersionAsyncForCluster(string url, TcpConnectionInfo info, Stream stream, JsonOperationContext ctx, string tag);
    private void ToggleDatabasesState(BlittableJsonReaderObject cmd, ClusterOperationContext context, string type, long index);
    private void UpdateResponsibleNodeForTasks(BlittableJsonReaderObject cmd, ClusterOperationContext context, string type, long index);
    private void UpdateDatabasesWithServerWideBackupConfiguration(ClusterOperationContext context, string type, ServerWideBackupConfiguration serverWideBackupConfiguration, long index);
    private static bool ShouldExcludeDatabase(ServerWideBackupConfiguration configuration, BlittableJsonReaderObject databaseRecord, string databaseName);
    private static bool IsServerWideBackupToEdit(BlittableJsonReaderObject databaseTask, string serverWideTaskName, HashSet`1<string> allServerWideTasksNames);
    private static bool IsServerWideExternalReplicationToEdit(BlittableJsonReaderObject databaseTask, string serverWideTaskName, HashSet`1<string> allServerWideTasksNames);
    private static bool IsServerWideTaskToEdit(BlittableJsonReaderObject databaseTask, string serverWideTaskName, string propName, string serverWidePrefix, HashSet`1<string> allServerWideTasksNames);
    private static HashSet`1<string> GetSeverWideBackupNames(ClusterOperationContext context);
    private void UpdateDatabasesWithExternalReplication(ClusterOperationContext context, string type, ServerWideExternalReplication serverWideExternalReplication, long index);
    private static HashSet`1<string> GetAllSeverWideExternalReplicationNames(ClusterOperationContext context);
    private void DeleteServerWideBackupConfigurationFromAllDatabases(DeleteConfiguration deleteConfiguration, ClusterOperationContext context, string type, long index);
    private void ToggleServerWideTaskState(BlittableJsonReaderObject cmd, Parameters parameters, ClusterOperationContext context, string type, long index);
    private static bool IsServerWideTaskWithName(BlittableJsonReaderObject blittable, string namePropertyName, string taskNameToFind);
    private void ApplyDatabaseRecordUpdates(List`1<ValueTuple`4<string, BlittableJsonReaderObject, string, object>> toUpdate, string type, long index, Table items, ClusterOperationContext context);
    public virtual Task OnSnapshotInstalledAsync(ClusterOperationContext context, long lastIncludedIndex, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<AfterSnapshotInstalledAsync>d__193")]
public virtual Task AfterSnapshotInstalledAsync(long lastIncludedIndex, Task onFullSnapshotInstalledTask, CancellationToken token);
    protected virtual RachisVersionValidation InitializeValidator();
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetReplicationHubCertificateByHub>d__195")]
public IEnumerable`1<BlittableJsonReaderObject> GetReplicationHubCertificateByHub(ClusterOperationContext context, string database, string hub, string filter, int start, int pageSize);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ClusterStateMachine/<GetReplicationHubCertificateForDatabase>d__196")]
public IEnumerable`1<ValueTuple`2<string, ReplicationHubAccess>> GetReplicationHubCertificateForDatabase(ClusterOperationContext context, string database);
    private string GetCertificateAsBase64(TableValueHolder val);
    private BlittableJsonReaderObject GetReplicationCertificateAccessObject(ClusterOperationContext context, TableValueReader& reader);
    public bool IsReplicationCertificate(ClusterOperationContext context, string database, string hub, X509Certificate2 userCert, DetailedReplicationHubAccess& access);
    public bool IsReplicationCertificateByPublicKeyPinningHash(ClusterOperationContext context, string database, string hub, X509Certificate2 userCert, SecurityConfiguration securityConfiguration, DetailedReplicationHubAccess& access);
    public static bool TryReadNodeTag(ServerStore serverStore, String& nodeTag);
    private void AssertLicenseLimits(string type, ServerStore serverStore, DatabaseRecord databaseRecord, Table items, ClusterOperationContext context);
    private void AssertLicense(ClusterOperationContext context, string type, BlittableJsonReaderObject bjro, ServerStore serverStore);
    private void AssertMultiNodeSharding(DatabaseRecord databaseRecord, LicenseStatus licenseStatus, ClusterOperationContext context);
    private void AssertStaticIndexesCount(DatabaseRecord databaseRecord, LicenseStatus licenseStatus, ClusterOperationContext context, Table items, string type);
    private void AssertAutoIndexesCount(DatabaseRecord databaseRecord, LicenseStatus licenseStatus, ClusterOperationContext context, Table items, string type);
    private void AssertRevisionConfiguration(DatabaseRecord databaseRecord, LicenseStatus licenseStatus, ClusterOperationContext context);
    private void AssertExpirationConfiguration(DatabaseRecord databaseRecord, LicenseStatus licenseStatus, ClusterOperationContext context);
    private void AssertRefreshFrequency(DatabaseRecord databaseRecord, LicenseStatus licenseStatus, ClusterOperationContext context);
    private void AssertSorters(DatabaseRecord databaseRecord, LicenseStatus licenseStatus, ClusterOperationContext context, Table items, string type);
    private void AssertAnalyzers(DatabaseRecord databaseRecord, LicenseStatus licenseStatus, ClusterOperationContext context, Table items, string type);
    private bool AssertPeriodicBackup(LicenseStatus licenseStatus, ClusterOperationContext context);
    private void AssertDatabaseClientConfiguration(DatabaseRecord databaseRecord, LicenseStatus licenseStatus, ClusterOperationContext context);
    private bool AssertClientConfiguration(LicenseStatus licenseStatus, ClusterOperationContext context);
    private void AssertDatabaseStudioConfiguration(DatabaseRecord databaseRecord, LicenseStatus licenseStatus, ClusterOperationContext context);
    private bool AssertServerWideStudioConfiguration(LicenseStatus licenseStatus, ClusterOperationContext context);
    private bool AssertQueueSink(LicenseStatus licenseStatus, ClusterOperationContext context);
    private bool AssertDataArchival(LicenseStatus licenseStatus, ClusterOperationContext context);
    private static long GetTotal(DatabaseRecordElementType resultType, string exceptDb, ClusterOperationContext context, Table items, string type);
    private void AssertSubscriptionsLicenseLimits(ServerStore serverStore, Table items, PutSubscriptionCommand putSubscriptionCommand, ClusterOperationContext context);
    private List`1<T> AssertSubscriptionsBatchLicenseLimits(ServerStore serverStore, Table items, BlittableJsonReaderArray subscriptionCommands, string type, ClusterOperationContext context);
    private bool AssertNumberOfSubscriptionsPerDatabaseLimits(ServerStore serverStore, Table items, ClusterOperationContext context, IReadOnlyDictionary`2<string, List`1<string>> subscriptionsNamesPerDatabase);
    private bool AssertNumberOfSubscriptionsPerClusterLimits(ServerStore serverStore, Table items, ClusterOperationContext context, IReadOnlyDictionary`2<string, List`1<string>> subscriptionsNamesPerDatabase);
    private bool AssertSubscriptionRevisionFeatureLimits(ServerStore serverStore, bool includeRevisions, ClusterOperationContext context);
    public static int GetSubscriptionsCountForDatabase(ByteStringContext allocator, Table items, string databaseName, List`1<string> subscriptionNamesToExclude);
    private bool CanAssertLicenseLimits(ClusterOperationContext context, int minBuildVersion);
    private static void AssertServerWideFor(ServerStore serverStore, LicenseAttribute attribute);
    private void AssertPeriodicBackupLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertPullReplicationAsSinkLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertPullReplicationAsHubLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertExternalReplicationLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertRavenEtlLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertSqlEtlLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertOlapEtlLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertQueueEtlLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertElasticSearchEtlLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertTimeSeriesConfigurationLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertDocumentsCompressionLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    private void AssertAdditionalAssembliesFromNuGetLicenseLimits(ServerStore serverStore, DatabaseRecord databaseRecord, ClusterOperationContext context);
    [CompilerGeneratedAttribute]
internal static void <RemoveNodeFromCluster>g__RemoveFromTopology|52_2(DatabaseTopology topology, <>c__DisplayClass52_1& );
    [CompilerGeneratedAttribute]
internal static void <AddDatabase>g__VerifyUnchangedTasks|68_0(BlittableJsonReaderObject dbDoc, <>c__DisplayClass68_0& , <>c__DisplayClass68_1& );
    [CompilerGeneratedAttribute]
internal static void <AddDatabase>g__VerifyIndexNames|68_1(BlittableJsonReaderObject dbDoc);
    [CompilerGeneratedAttribute]
internal static void <AddDatabase>g__VerifyCustomSorters|68_2(<>c__DisplayClass68_0& );
    [CompilerGeneratedAttribute]
internal static void <AddDatabase>g__VerifyUnchangedPrefixedSetting|68_3(BlittableJsonReaderObject dbDoc, <>c__DisplayClass68_0& , <>c__DisplayClass68_1& );
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecordIfNeeded>g__TopologyChanged|69_0(<>c__DisplayClass69_0& );
    [CompilerGeneratedAttribute]
private void <UpdateDatabaseRecordIfNeeded>g__UpdatePeriodicBackups|69_1(<>c__DisplayClass69_0& );
    [CompilerGeneratedAttribute]
private void <UpdateDatabaseRecordIfNeeded>g__UpdateExternalReplications|69_2(<>c__DisplayClass69_0& );
}
public class Raven.Server.ServerWide.ClusterTransactionResult : object {
    [CompilerGeneratedAttribute]
private DynamicJsonArray <GeneratedResult>k__BackingField;
    public DynamicJsonArray GeneratedResult { get; public set; }
    [CompilerGeneratedAttribute]
public DynamicJsonArray get_GeneratedResult();
    [CompilerGeneratedAttribute]
public void set_GeneratedResult(DynamicJsonArray value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.ServerWide.ClusterValidator : RachisVersionValidation {
    public ClusterValidator(ClusterCommandsVersionManager commandsVersionManager);
    public virtual void AssertPutCommandToLeader(CommandBase cmd);
    public virtual void AssertEntryBeforeSendToFollower(BlittableJsonReaderObject entry, int version, string follower);
}
public class Raven.Server.ServerWide.ClusterVersionChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <PreviousClusterVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentClusterVersion>k__BackingField;
    public int PreviousClusterVersion { get; }
    public int CurrentClusterVersion { get; }
    public ClusterVersionChangeEventArgs(int previousClusterVersion, int currentClusterVersion);
    [CompilerGeneratedAttribute]
public int get_PreviousClusterVersion();
    [CompilerGeneratedAttribute]
public int get_CurrentClusterVersion();
}
public class Raven.Server.ServerWide.Commands.AddDatabaseCommand : CommandBase {
    public string Name;
    public DatabaseRecord Record;
    public Dictionary`2<string, BlittableJsonReaderObject> DatabaseValues;
    public bool Encrypted;
    public bool IsRestore;
    public AddDatabaseCommand(string uniqueRequestId);
    public virtual object FromRemote(object remoteResult);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.AddOrUpdateCompareExchangeBatchCommand : CommandBase {
    public List`1<AddOrUpdateCompareExchangeCommand> Commands;
    public List`1<RemoveCompareExchangeCommand> RemoveCommands;
    public AddOrUpdateCompareExchangeBatchCommand(List`1<AddOrUpdateCompareExchangeCommand> addCommands, string uniqueRequestId);
    public AddOrUpdateCompareExchangeBatchCommand(List`1<RemoveCompareExchangeCommand> removeCommands, string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.AddOrUpdateCompareExchangeCommand : CompareExchangeCommandBase {
    private static UTF8Encoding Encoding;
    internal static int MaxNumberOfCompareExchangeKeyBytes;
    public Nullable`1<long> ExpirationTicks;
    [JsonDeserializationIgnoreAttribute]
public long CurrentTicks;
    public BlittableJsonReaderObject Value;
    public AddOrUpdateCompareExchangeCommand(string database, string key, BlittableJsonReaderObject value, long index, JsonOperationContext contextToReturnResult, string uniqueRequestId, bool fromBackup);
    private static AddOrUpdateCompareExchangeCommand();
    protected virtual CompareExchangeResult ExecuteInternal(ClusterOperationContext context, Table items, long index);
    private static void TryRemoveCompareExchangeTombstone(ClusterOperationContext context, Slice keySlice);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    [DoesNotReturnAttribute]
private static void ThrowCompareExchangeKeyTooBig(string str);
    protected virtual bool Validate(ClusterOperationContext context, Slice keySlice, Table items, Int64& currentIndex);
}
public class Raven.Server.ServerWide.Commands.Analyzers.DeleteAnalyzerCommand : UpdateDatabaseCommand {
    public string AnalyzerName;
    public DeleteAnalyzerCommand(string name, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Analyzers.DeleteServerWideAnalyzerCommand : DeleteValueCommand {
    public DeleteServerWideAnalyzerCommand(string name, string uniqueRequestId);
    public virtual void DeleteValue(ClusterOperationContext context);
    [CompilerGeneratedAttribute]
private void <DeleteValue>b__2_0(IPagerLevelTransactionState _);
}
public class Raven.Server.ServerWide.Commands.Analyzers.PutAnalyzersCommand : UpdateDatabaseCommand {
    public List`1<AnalyzerDefinition> Analyzers;
    public PutAnalyzersCommand(string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
internal class Raven.Server.ServerWide.Commands.Analyzers.PutServerWideAnalyzerCommand : PutValueCommand`1<AnalyzerDefinition> {
    public static string Prefix;
    public PutServerWideAnalyzerCommand(AnalyzerDefinition value, string uniqueRequestId);
    public virtual void UpdateValue(ClusterOperationContext context, long index);
    public virtual DynamicJsonValue ValueToJson();
    internal static string GetName(string name);
    public static string ExtractName(string name);
    [CompilerGeneratedAttribute]
private void <UpdateValue>b__3_0(IPagerLevelTransactionState _);
}
public class Raven.Server.ServerWide.Commands.BulkRegisterReplicationHubAccessCommand : CommandBase {
    public List`1<RegisterReplicationHubAccessCommand> Commands;
    public string Database;
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.CleanCompareExchangeTombstonesCommand : CommandBase {
    public string DatabaseName;
    public long MaxRaftIndex;
    public long Take;
    public CleanCompareExchangeTombstonesCommand(string databaseName, long maxRaftIndex, long take, string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.CleanUpClusterStateCommand : CommandBase {
    public Dictionary`2<string, long> ClusterTransactionsCleanup;
    public CleanUpClusterStateCommand(string uniqueRequestId);
    public Dictionary`2<string, long> Clean(ClusterOperationContext context, long index);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.ClusterTransactionCommand : CommandBase {
    public string DatabaseName;
    public string DatabaseRecordId;
    public string ClusterTransactionId;
    public long DatabaseCommandsCount;
    public long CommandCreationTicks;
    public List`1<ClusterTransactionDataCommand> ClusterCommands;
    public BlittableJsonReaderObject SerializedDatabaseCommands;
    [JsonDeserializationIgnoreAttribute]
public ClusterTransactionOptions Options;
    [JsonDeserializationIgnoreAttribute]
public List`1<ClusterTransactionDataCommand> DatabaseCommands;
    public bool FromBackup;
    public static byte Separator;
    public bool HasDocumentsInTransaction { get; }
    public ClusterTransactionCommand(string databaseName, char identityPartsSeparator, DatabaseTopology topology, ArraySegment`1<CommandData> commandParsedCommands, ClusterTransactionOptions options, string uniqueRequestId);
    public ClusterTransactionCommand(string databaseName, char identityPartsSeparator, DatabaseTopology topology, ArraySegment`1<ClusterTransactionDataCommand> commandParsedCommands, ClusterTransactionOptions options, string uniqueRequestId);
    public ClusterTransactionCommand(string databaseName, char identityPartsSeparator, ArraySegment`1<CommandData> commandParsedCommands, ClusterTransactionOptions options, string uniqueRequestId);
    public ClusterTransactionCommand(string databaseName, char identityPartsSeparator, ArraySegment`1<ClusterTransactionDataCommand> commandParsedCommands, ClusterTransactionOptions options, string uniqueRequestId);
    private ClusterTransactionCommand(string databaseName, DatabaseTopology topology, ClusterTransactionOptions options, string uniqueRequestId);
    [ConditionalAttribute("DEBUG")]
private static void AssertDatabaseName(string databaseName);
    internal static void ValidateCommands(ArraySegment`1<CommandData> parsedCommands, bool disableAtomicDocumentWrites);
    private static void ClusterCommandValidation(ClusterTransactionDataCommand command, char identityPartsSeparator);
    public List`1<ClusterTransactionErrorInfo> ExecuteCompareExchangeCommands(string clusterTransactionId, ClusterOperationContext context, long index, Table items);
    private static ClusterTransactionErrorInfo GenerateErrorInfo(ClusterTransactionDataCommand clusterCommand, long actualIndex, bool delete);
    private void EnsureAtomicDocumentWrites(string clusterTransactionId, ClusterOperationContext context, Table items, long index);
    private Nullable`1<long> GetCurrentIndex(ClusterOperationContext context, Table items, string key);
    private static DynamicJsonValue GetCommandResult(BlittableJsonReaderObject command, string id, Int64& initialCount, Nullable`1<bool> disableAtomicDocumentWrites, long index, string databaseTopologyIdBase64, string clusterTransactionId);
    public DynamicJsonArray SaveCommandsBatch(ClusterOperationContext context, RawDatabaseRecord rawRecord, long index);
    internal static long GetPrevCount(ClusterOperationContext context, Tree commandsCountPerDatabase, string databaseName);
    private void SaveCommandBatch(ClusterOperationContext context, long index, string databaseName, Tree commandsCountPerDatabase, Table items, BlittableJsonReaderObject commands, long commandsCount);
    public bool get_HasDocumentsInTransaction();
    public static SingleClusterDatabaseCommand ReadFirstClusterTransaction(ClusterOperationContext context, string database);
    public static bool DeleteCommands(TransactionOperationContext`1<TTransaction> context, string database, long upToCommandCount);
    public static InternalScope<ByteStringMemoryCache> GetPrefix(TransactionOperationContext`1<TTransaction> context, string database, Slice& prefixSlice, Nullable`1<long> prevCount);
    public static SingleClusterDatabaseCommand ReadSingleCommand(ClusterOperationContext context, string database, Nullable`1<long> fromCount);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.Commands.ClusterTransactionCommand/<ReadCommandsBatch>d__40`1")]
public static IEnumerable`1<SingleClusterDatabaseCommand> ReadCommandsBatch(TransactionOperationContext`1<TTransaction> context, string database, Nullable`1<long> fromCount, Nullable`1<long> lastCompletedClusterTransactionIndex, long take);
    private static SingleClusterDatabaseCommand ReadCommand(TransactionOperationContext`1<TTransaction> context, TableValueReader reader);
    public virtual object FromRemote(object remoteResult);
    internal static ClusterTransactionResult GetResults(BlittableJsonReaderObject bjro);
    private static DynamicJsonArray GetGeneratedResults(BlittableJsonReaderArray bjra);
    private static DynamicJsonValue ToDynamicJsonValue(BlittableJsonReaderObject bjro);
    private static List`1<ClusterTransactionErrorInfo> GetErrors(BlittableJsonReaderArray array);
    private static ClusterTransactionErrorInfo ToClusterTransactionErrorInfo(BlittableJsonReaderObject bjro);
    public virtual string AdditionalDebugInformation(Exception exception);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public abstract class Raven.Server.ServerWide.Commands.CommandBase : object {
    public static string Type;
    public Nullable`1<TimeSpan> Timeout;
    public Nullable`1<long> RaftCommandIndex;
    public string UniqueRequestId;
    public BlittableJsonReaderObject Raw;
    protected CommandBase(string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public static CommandBase CreateFrom(BlittableJsonReaderObject json);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
    protected void AssertClusterAdmin(bool isClusterAdmin);
    public virtual object FromRemote(object remoteResult);
    public virtual string AdditionalDebugInformation(Exception exception);
}
public abstract class Raven.Server.ServerWide.Commands.CompareExchangeCommandBase : CommandBase {
    public string Key;
    public string Database;
    private string _actualKey;
    public bool FromBackup;
    public long Index;
    [CompilerGeneratedAttribute]
private JsonOperationContext <ContextToWriteResult>k__BackingField;
    public static long InvalidIndexValue;
    protected string ActualKey { get; }
    [JsonDeserializationIgnoreAttribute]
public JsonOperationContext ContextToWriteResult { get; public set; }
    protected CompareExchangeCommandBase(string database, string key, long index, JsonOperationContext context, string uniqueRequestId, bool fromBackup);
    protected string get_ActualKey();
    [CompilerGeneratedAttribute]
public JsonOperationContext get_ContextToWriteResult();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ContextToWriteResult(JsonOperationContext value);
    protected abstract virtual CompareExchangeResult ExecuteInternal(ClusterOperationContext context, Table items, long index);
    public CompareExchangeResult Execute(ClusterOperationContext context, Table items, long index);
    public static void GetKeyAndPrefixIndexSlices(ByteStringContext allocator, string db, string key, long index, ValueTuple`2& finalKey, ValueTuple`2& finalIndex);
    public static InternalScope<ByteStringMemoryCache> GetPrefixIndexSlices(ByteStringContext allocator, string db, long index, ByteString& finalIndex);
    public static void GetDbPrefixAndLastSlices(ByteStringContext allocator, string db, ValueTuple`2& prefix, ValueTuple`2& last);
    public bool Validate(ClusterOperationContext context, Table items, Int64& currentIndex);
    protected abstract virtual bool Validate(ClusterOperationContext context, Slice keySlice, Table items, Int64& currentIndex);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public virtual object FromRemote(object remoteResult);
    private sealed virtual override object Raven.Server.ServerWide.Commands.IBlittableResultCommand.WriteResult(object result);
    protected bool TryGetExpires(BlittableJsonReaderObject value, Int64& ticks);
}
public class Raven.Server.ServerWide.Commands.ConfirmReceiptServerCertificateCommand : CommandBase {
    [CompilerGeneratedAttribute]
private string <Thumbprint>k__BackingField;
    public string Thumbprint { get; public set; }
    public ConfirmReceiptServerCertificateCommand(string thumbprint);
    [CompilerGeneratedAttribute]
public string get_Thumbprint();
    [CompilerGeneratedAttribute]
public void set_Thumbprint(string value);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.ConfirmServerCertificateReplacedCommand : CommandBase {
    [CompilerGeneratedAttribute]
private string <Thumbprint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldThumbprint>k__BackingField;
    public string Thumbprint { get; public set; }
    public string OldThumbprint { get; public set; }
    public ConfirmServerCertificateReplacedCommand(string thumbprint, string oldThumbprint);
    [CompilerGeneratedAttribute]
public string get_Thumbprint();
    [CompilerGeneratedAttribute]
public void set_Thumbprint(string value);
    [CompilerGeneratedAttribute]
public string get_OldThumbprint();
    [CompilerGeneratedAttribute]
public void set_OldThumbprint(string value);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public abstract class Raven.Server.ServerWide.Commands.ConnectionStrings.PutConnectionStringCommand`1 : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private T <ConnectionString>k__BackingField;
    public T ConnectionString { get; protected set; }
    protected PutConnectionStringCommand`1(T connectionString, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public T get_ConnectionString();
    [CompilerGeneratedAttribute]
protected void set_ConnectionString(T value);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.ConnectionStrings.PutElasticSearchConnectionStringCommand : PutConnectionStringCommand`1<ElasticSearchConnectionString> {
    public PutElasticSearchConnectionStringCommand(ElasticSearchConnectionString connectionString, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ConnectionStrings.PutOlapConnectionStringCommand : PutConnectionStringCommand`1<OlapConnectionString> {
    public PutOlapConnectionStringCommand(OlapConnectionString connectionString, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ConnectionStrings.PutQueueConnectionStringCommand : PutConnectionStringCommand`1<QueueConnectionString> {
    public PutQueueConnectionStringCommand(QueueConnectionString connectionString, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ConnectionStrings.PutRavenConnectionStringCommand : PutConnectionStringCommand`1<RavenConnectionString> {
    public PutRavenConnectionStringCommand(RavenConnectionString connectionString, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ConnectionStrings.PutSqlConnectionStringCommand : PutConnectionStringCommand`1<SqlConnectionString> {
    public PutSqlConnectionStringCommand(SqlConnectionString connectionString, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public abstract class Raven.Server.ServerWide.Commands.ConnectionStrings.RemoveConnectionStringCommand`1 : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    public string ConnectionStringName { get; protected set; }
    protected RemoveConnectionStringCommand`1(string connectionStringName, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
protected void set_ConnectionStringName(string value);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.ConnectionStrings.RemoveElasticSearchConnectionStringCommand : RemoveConnectionStringCommand`1<ElasticSearchConnectionString> {
    public RemoveElasticSearchConnectionStringCommand(string connectionStringName, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ConnectionStrings.RemoveOlapConnectionStringCommand : RemoveConnectionStringCommand`1<OlapConnectionString> {
    public RemoveOlapConnectionStringCommand(string connectionStringName, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ConnectionStrings.RemoveQueueConnectionStringCommand : RemoveConnectionStringCommand`1<QueueConnectionString> {
    public RemoveQueueConnectionStringCommand(string connectionStringName, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ConnectionStrings.RemoveRavenConnectionStringCommand : RemoveConnectionStringCommand`1<RavenConnectionString> {
    public RemoveRavenConnectionStringCommand(string connectionStringName, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ConnectionStrings.RemoveSqlConnectionStringCommand : RemoveConnectionStringCommand`1<SqlConnectionString> {
    public RemoveSqlConnectionStringCommand(string connectionStringName, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.DelayBackupCommand : UpdateValueForDatabaseCommand {
    public long TaskId;
    public DateTime DelayUntil;
    public DateTime OriginalBackupTime;
    public DelayBackupCommand(string databaseName, string uniqueRequestId);
    public virtual string GetItemId();
    public virtual void FillJson(DynamicJsonValue json);
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual object GetState();
}
public class Raven.Server.ServerWide.Commands.DeleteCertificateCollectionFromClusterCommand : DeleteMultipleValuesCommand {
    public DeleteCertificateCollectionFromClusterCommand(string requestId);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
    public virtual void AfterDelete(ServerStore store, ClusterOperationContext context);
}
public class Raven.Server.ServerWide.Commands.DeleteCertificateFromClusterCommand : DeleteValueCommand {
    public DeleteCertificateFromClusterCommand(string raftRequestId);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.DeleteDatabaseCommand : UpdateDatabaseCommand {
    public String[] ClusterNodes;
    public bool HardDelete;
    public String[] FromNodes;
    public bool UpdateReplicationFactor;
    public Nullable`1<int> ShardNumber;
    public DeleteDatabaseCommand(string databaseName, string uniqueRequestId);
    public virtual void Initialize(ServerStore serverStore, ClusterOperationContext context);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    private DatabaseTopology RemoveDatabaseFromAllNodes(DatabaseRecord record, DatabaseTopology topology, Nullable`1<int> shardNumber, DeletionInProgressStatus deletionInProgressStatus, long etag);
    private void RemoveDatabaseFromSingleNode(DatabaseRecord record, DatabaseTopology topology, string node, Nullable`1<int> shardNumber, DeletionInProgressStatus deletionInProgressStatus, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.DeleteExpiredCompareExchangeCommand : CommandBase {
    public long Ticks;
    public long Take;
    public DeleteExpiredCompareExchangeCommand(long ticks, long take, string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.DeleteMultipleValuesCommand : CommandBase {
    public List`1<string> Names;
    public DeleteMultipleValuesCommand(string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
    public virtual void AfterDelete(ServerStore store, ClusterOperationContext context);
}
public class Raven.Server.ServerWide.Commands.DeleteOngoingTaskCommand : UpdateDatabaseCommand {
    public long TaskId;
    public OngoingTaskType TaskType;
    private Nullable`1<long> _backupTaskIdToDelete;
    private string _hubNameToDelete;
    public DeleteOngoingTaskCommand(long taskId, OngoingTaskType taskType, string databaseName, string uniqueRequestId);
    public virtual void AfterDatabaseRecordUpdate(ClusterOperationContext ctx, Table items, Logger clusterAuditLog);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
    [CompilerGeneratedAttribute]
internal static void <AfterDatabaseRecordUpdate>g__Delete|6_0(string key, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__7_0(ExternalReplication x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__7_1(PullReplicationDefinition x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__7_2(PullReplicationAsSink x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__7_3(SqlEtlConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__7_4(RavenEtlConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__7_5(OlapEtlConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__7_6(ElasticSearchEtlConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__7_7(QueueEtlConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__7_8(QueueSinkConfiguration x);
}
public class Raven.Server.ServerWide.Commands.DeleteServerWideBackupConfigurationCommand : UpdateValueCommand`1<string> {
    [ObsoleteAttribute("This command is obsolete, please use `DeleteServerWideTaskCommand` instead", "True")]
public DeleteServerWideBackupConfigurationCommand(string configurationName, string uniqueRequestId);
    public virtual object ValueToJson();
    public virtual BlittableJsonReaderObject GetUpdatedValue(JsonOperationContext context, BlittableJsonReaderObject previousValue, long index);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.DeleteServerWideTaskCommand : UpdateValueCommand`1<DeleteConfiguration> {
    public DeleteServerWideTaskCommand(DeleteConfiguration configuration, string uniqueRequestId);
    public static string GetDatabaseRecordTaskName(DeleteConfiguration configuration);
    public virtual object ValueToJson();
    public virtual BlittableJsonReaderObject GetUpdatedValue(JsonOperationContext context, BlittableJsonReaderObject previousValue, long index);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.DeleteValueCommand : CommandBase {
    public string Name;
    public DeleteValueCommand(string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public virtual void DeleteValue(ClusterOperationContext context);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.EditDataArchivalCommand : UpdateDatabaseCommand {
    public DataArchivalConfiguration Configuration;
    public EditDataArchivalCommand(DataArchivalConfiguration configuration, string databaseName, string uniqueRequestId);
    public void UpdateDatabaseRecord(DatabaseRecord databaseRecord);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.EditDatabaseClientConfigurationCommand : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private ClientConfiguration <Configuration>k__BackingField;
    public ClientConfiguration Configuration { get; public set; }
    public EditDatabaseClientConfigurationCommand(ClientConfiguration configuration, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public ClientConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(ClientConfiguration value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.EditDocumentsCompressionCommand : UpdateDatabaseCommand {
    public DocumentsCompressionConfiguration Configuration;
    public EditDocumentsCompressionCommand(DocumentsCompressionConfiguration configuration, string databaseName, string uniqueRequestId);
    public void UpdateDatabaseRecord(DatabaseRecord databaseRecord);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.EditExpirationCommand : UpdateDatabaseCommand {
    public ExpirationConfiguration Configuration;
    public EditExpirationCommand(ExpirationConfiguration configuration, string databaseName, string uniqueRequestId);
    public void UpdateDatabaseRecord(DatabaseRecord databaseRecord);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.EditLockModeCommand : UpdateDatabaseCommand {
    public DatabaseLockMode LockMode;
    public EditLockModeCommand(string databaseName, DatabaseLockMode lockMode, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.EditRefreshCommand : UpdateDatabaseCommand {
    public RefreshConfiguration Configuration;
    public EditRefreshCommand(RefreshConfiguration configuration, string databaseName, string uniqueRequestId);
    public void UpdateDatabaseRecord(DatabaseRecord databaseRecord);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.EditRevisionsConfigurationCommand : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private RevisionsConfiguration <Configuration>k__BackingField;
    public RevisionsConfiguration Configuration { get; private set; }
    public EditRevisionsConfigurationCommand(RevisionsConfiguration configuration, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public RevisionsConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(RevisionsConfiguration value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.EditRevisionsForConflictsConfigurationCommand : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private RevisionsCollectionConfiguration <Configuration>k__BackingField;
    public RevisionsCollectionConfiguration Configuration { get; private set; }
    public EditRevisionsForConflictsConfigurationCommand(RevisionsCollectionConfiguration configuration, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public RevisionsCollectionConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(RevisionsCollectionConfiguration value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.EditTimeSeriesConfigurationCommand : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private TimeSeriesConfiguration <Configuration>k__BackingField;
    public TimeSeriesConfiguration Configuration { get; private set; }
    public EditTimeSeriesConfigurationCommand(TimeSeriesConfiguration configuration, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public TimeSeriesConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(TimeSeriesConfiguration value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.ETL.AddElasticSearchEtlCommand : AddEtlCommand`2<ElasticSearchEtlConfiguration, ElasticSearchConnectionString> {
    public AddElasticSearchEtlCommand(ElasticSearchEtlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public abstract class Raven.Server.ServerWide.Commands.ETL.AddEtlCommand`2 : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private T <Configuration>k__BackingField;
    public T Configuration { get; protected set; }
    protected AddEtlCommand`2(T configuration, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public T get_Configuration();
    [CompilerGeneratedAttribute]
protected void set_Configuration(T value);
    protected void Add(List`1& etls, DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.ETL.AddOlapEtlCommand : AddEtlCommand`2<OlapEtlConfiguration, OlapConnectionString> {
    public AddOlapEtlCommand(OlapEtlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ETL.AddQueueEtlCommand : AddEtlCommand`2<QueueEtlConfiguration, QueueConnectionString> {
    public AddQueueEtlCommand(QueueEtlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ETL.AddRavenEtlCommand : AddEtlCommand`2<RavenEtlConfiguration, RavenConnectionString> {
    public AddRavenEtlCommand(RavenEtlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ETL.AddSqlEtlCommand : AddEtlCommand`2<SqlEtlConfiguration, SqlConnectionString> {
    public AddSqlEtlCommand(SqlEtlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ETL.RemoveEtlProcessStateCommand : UpdateValueForDatabaseCommand {
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransformationName>k__BackingField;
    public string ConfigurationName { get; public set; }
    public string TransformationName { get; public set; }
    public RemoveEtlProcessStateCommand(string databaseName, string configurationName, string transformationName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public string get_TransformationName();
    [CompilerGeneratedAttribute]
public void set_TransformationName(string value);
    public virtual string GetItemId();
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.ETL.UpdateElasticSearchEtlCommand : UpdateEtlCommand`2<ElasticSearchEtlConfiguration, ElasticSearchConnectionString> {
    public UpdateElasticSearchEtlCommand(long taskId, ElasticSearchEtlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public abstract class Raven.Server.ServerWide.Commands.ETL.UpdateEtlCommand`2 : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private EtlType <EtlType>k__BackingField;
    public long TaskId { get; protected set; }
    public T Configuration { get; protected set; }
    public EtlType EtlType { get; protected set; }
    protected UpdateEtlCommand`2(long taskId, T configuration, EtlType type, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
protected void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public T get_Configuration();
    [CompilerGeneratedAttribute]
protected void set_Configuration(T value);
    [CompilerGeneratedAttribute]
public EtlType get_EtlType();
    [CompilerGeneratedAttribute]
protected void set_EtlType(EtlType value);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.ETL.UpdateEtlProcessStateCommand : UpdateValueForDatabaseCommand {
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransformationName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastProcessedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DbId>k__BackingField;
    public bool HasHighlyAvailableTasks;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <SkippedTimeSeriesDocs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastBatchTime>k__BackingField;
    public string ConfigurationName { get; public set; }
    public string TransformationName { get; public set; }
    public long LastProcessedEtag { get; public set; }
    public string ChangeVector { get; public set; }
    public string NodeTag { get; public set; }
    public string DbId { get; public set; }
    public HashSet`1<string> SkippedTimeSeriesDocs { get; public set; }
    public Nullable`1<DateTime> LastBatchTime { get; public set; }
    public UpdateEtlProcessStateCommand(string databaseName, string configurationName, string transformationName, long lastProcessedEtag, string changeVector, string nodeTag, bool hasHighlyAvailableTasks, string dbId, string uniqueRequestId, HashSet`1<string> skippedTimeSeriesDocs, Nullable`1<DateTime> lastBatchTime);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public string get_TransformationName();
    [CompilerGeneratedAttribute]
public void set_TransformationName(string value);
    [CompilerGeneratedAttribute]
public long get_LastProcessedEtag();
    [CompilerGeneratedAttribute]
public void set_LastProcessedEtag(long value);
    [CompilerGeneratedAttribute]
public string get_ChangeVector();
    [CompilerGeneratedAttribute]
public void set_ChangeVector(string value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public string get_DbId();
    [CompilerGeneratedAttribute]
public void set_DbId(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SkippedTimeSeriesDocs();
    [CompilerGeneratedAttribute]
public void set_SkippedTimeSeriesDocs(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastBatchTime();
    [CompilerGeneratedAttribute]
public void set_LastBatchTime(Nullable`1<DateTime> value);
    public virtual string GetItemId();
    private IDatabaseTask GetMatchingConfiguration(RawDatabaseRecord record);
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.ETL.UpdateOlapEtlCommand : UpdateEtlCommand`2<OlapEtlConfiguration, OlapConnectionString> {
    public UpdateOlapEtlCommand(long taskId, OlapEtlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ETL.UpdateQueueEtlCommand : UpdateEtlCommand`2<QueueEtlConfiguration, QueueConnectionString> {
    public UpdateQueueEtlCommand(long taskId, QueueEtlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ETL.UpdateRavenEtlCommand : UpdateEtlCommand`2<RavenEtlConfiguration, RavenConnectionString> {
    public UpdateRavenEtlCommand(long taskId, RavenEtlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.ETL.UpdateSqlEtlCommand : UpdateEtlCommand`2<SqlEtlConfiguration, SqlConnectionString> {
    public UpdateSqlEtlCommand(long taskId, SqlEtlConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.GetTcpInfoForReplicationCommand : GetTcpInfoCommand {
    private string _localNodeTag;
    public GetTcpInfoForReplicationCommand(string localNodeTag, string tag, string dbName);
    public GetTcpInfoForReplicationCommand(string localNodeTag, string tag, string dbName, string dbId, long etag);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
}
public interface Raven.Server.ServerWide.Commands.IBlittableResultCommand {
    unknown JsonOperationContext ContextToWriteResult {public set; }
    public abstract virtual void set_ContextToWriteResult(JsonOperationContext value);
    public abstract virtual object WriteResult(object result);
}
public class Raven.Server.ServerWide.Commands.IncrementClusterIdentitiesBatchCommand : UpdateValueForDatabaseCommand {
    public List`1<string> Identities;
    public IncrementClusterIdentitiesBatchCommand(string databaseName, List`1<string> identities, string uniqueRequestId);
    public virtual void Execute(ClusterOperationContext context, Table items, long index, RawDatabaseRecord record, RachisState state, Object& result);
    public virtual string GetItemId();
    public virtual void FillJson(DynamicJsonValue json);
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual object FromRemote(object remoteResult);
}
public class Raven.Server.ServerWide.Commands.IncrementClusterIdentityCommand : UpdateValueForDatabaseCommand {
    private string _itemId;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public string Prefix { get; public set; }
    public IncrementClusterIdentityCommand(string databaseName, string prefix, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    public virtual string GetItemId();
    public static string GetStorageKey(string databaseName, string prefix);
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void Execute(ClusterOperationContext context, Table items, long index, RawDatabaseRecord record, RachisState state, Object& result);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Indexes.DeleteIndexCommand : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    public string IndexName { get; public set; }
    public DeleteIndexCommand(string name, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Indexes.DeleteIndexHistoryCommand : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    public string IndexName { get; public set; }
    public DeleteIndexHistoryCommand(string indexName, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Indexes.PutAutoIndexCommand : UpdateDatabaseCommand {
    public DateTime CreatedAt;
    public AutoIndexDefinition Definition;
    public Nullable`1<IndexDeploymentMode> DefaultStaticDeploymentMode;
    public PutAutoIndexCommand(AutoIndexDefinition definition, string databaseName, string uniqueRequestId, IndexDeploymentMode mode, Nullable`1<DateTime> createdAt);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
    internal static PutAutoIndexCommand Create(AutoIndexDefinitionBaseServerSide definition, string databaseName, string raftRequestId, IndexDeploymentMode mode);
    internal static IndexType GetAutoIndexType(AutoIndexDefinitionBaseServerSide definition);
    internal static AutoIndexDefinition GetAutoIndexDefinition(AutoIndexDefinitionBaseServerSide definition, IndexType indexType);
    private static Dictionary`2<string, AutoIndexFieldOptions> CreateFields(Dictionary`2<string, AutoIndexField> fields);
}
public class Raven.Server.ServerWide.Commands.Indexes.PutIndexCommand : UpdateDatabaseCommand {
    public IndexDefinition Definition;
    public Nullable`1<IndexDeploymentMode> DefaultDeploymentMode;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RevisionsToKeep>k__BackingField;
    public DateTime CreatedAt { get; public set; }
    public string Source { get; public set; }
    public int RevisionsToKeep { get; public set; }
    public PutIndexCommand(IndexDefinition definition, string databaseName, string source, DateTime createdAt, string uniqueRequestId, int revisionsToKeep, IndexDeploymentMode deploymentMode);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public int get_RevisionsToKeep();
    [CompilerGeneratedAttribute]
public void set_RevisionsToKeep(int value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
    public virtual string AdditionalDebugInformation(Exception exception);
}
public class Raven.Server.ServerWide.Commands.Indexes.PutIndexesCommand : UpdateDatabaseCommand {
    public List`1<IndexDefinition> Static;
    public List`1<AutoIndexDefinition> Auto;
    public Nullable`1<IndexDeploymentMode> DefaultStaticDeploymentMode;
    public Nullable`1<IndexDeploymentMode> DefaultAutoDeploymentMode;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RevisionsToKeep>k__BackingField;
    public DateTime CreatedAt { get; public set; }
    public string Source { get; public set; }
    public int RevisionsToKeep { get; public set; }
    public PutIndexesCommand(string databaseName, string source, DateTime createdAt, string uniqueRequestId, int revisionsToKeep, IndexDeploymentMode autoDeploymentMode, IndexDeploymentMode staticDeploymentMode);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public int get_RevisionsToKeep();
    [CompilerGeneratedAttribute]
public void set_RevisionsToKeep(int value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Indexes.PutIndexHistoryCommand : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IndexHistoryEntry> <IndexHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RevisionsToKeep>k__BackingField;
    public string IndexName { get; public set; }
    public List`1<IndexHistoryEntry> IndexHistory { get; public set; }
    public int RevisionsToKeep { get; public set; }
    public PutIndexHistoryCommand(string indexName, List`1<IndexHistoryEntry> indexHistory, int revisionsToKeep, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public List`1<IndexHistoryEntry> get_IndexHistory();
    [CompilerGeneratedAttribute]
public void set_IndexHistory(List`1<IndexHistoryEntry> value);
    [CompilerGeneratedAttribute]
public int get_RevisionsToKeep();
    [CompilerGeneratedAttribute]
public void set_RevisionsToKeep(int value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Indexes.PutRollingIndexCommand : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FinishedNodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FinishedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompleteAll>k__BackingField;
    public string IndexName { get; public set; }
    public string FinishedNodeTag { get; public set; }
    public Nullable`1<DateTime> FinishedAt { get; public set; }
    public bool CompleteAll { get; public set; }
    public PutRollingIndexCommand(string databaseName, string indexName, string finishedNodeTag, Nullable`1<DateTime> finishedAt, string uniqueRequestId);
    public PutRollingIndexCommand(string databaseName, string indexName, Nullable`1<DateTime> finishedAt, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public string get_FinishedNodeTag();
    [CompilerGeneratedAttribute]
public void set_FinishedNodeTag(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_FinishedAt();
    [CompilerGeneratedAttribute]
public void set_FinishedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_CompleteAll();
    [CompilerGeneratedAttribute]
public void set_CompleteAll(bool value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    private void FinishOneNode(DatabaseRecord record, string finishedNodeTag, RollingIndex rollingIndex);
    private static void MaybeAddNewNodesToRollingDeployment(DatabaseRecord record, Dictionary`2<string, RollingIndexDeployment> rollingIndex);
    private string ChooseNextNode(DatabaseRecord record, Dictionary`2<string, RollingIndexDeployment> rollingIndex);
    public virtual void FillJson(DynamicJsonValue json);
    [CompilerGeneratedAttribute]
internal static bool <ChooseNextNode>g__IsNextNode|22_0(string node, <>c__DisplayClass22_0& );
}
public class Raven.Server.ServerWide.Commands.Indexes.SetIndexLockCommand : UpdateDatabaseCommand {
    public string IndexName;
    public IndexLockMode LockMode;
    public SetIndexLockCommand(string name, IndexLockMode mode, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Indexes.SetIndexPriorityCommand : UpdateDatabaseCommand {
    public string IndexName;
    public IndexPriority Priority;
    public SetIndexPriorityCommand(string name, IndexPriority priority, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Indexes.SetIndexStateCommand : UpdateDatabaseCommand {
    public string IndexName;
    public IndexState State;
    public SetIndexStateCommand(string name, IndexState state, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.InstallUpdatedServerCertificateCommand : CommandBase {
    [CompilerGeneratedAttribute]
private string <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplaceImmediately>k__BackingField;
    public string Certificate { get; public set; }
    public bool ReplaceImmediately { get; public set; }
    public InstallUpdatedServerCertificateCommand(string certificate, bool replaceImmediately, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public string get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(string value);
    [CompilerGeneratedAttribute]
public bool get_ReplaceImmediately();
    [CompilerGeneratedAttribute]
public void set_ReplaceImmediately(bool value);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.ModifyConflictSolverCommand : UpdateDatabaseCommand {
    public ConflictSolver Solver;
    public ModifyConflictSolverCommand(string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Monitoring.Snmp.UpdateSnmpDatabaseIndexesMappingCommand : UpdateValueForDatabaseCommand {
    private string _itemId;
    [CompilerGeneratedAttribute]
private List`1<string> <Indexes>k__BackingField;
    public List`1<string> Indexes { get; public set; }
    public UpdateSnmpDatabaseIndexesMappingCommand(string databaseName, List`1<string> indexes, string uniqueRequestId);
    public static string GetStorageKey(string databaseName);
    [CompilerGeneratedAttribute]
public List`1<string> get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(List`1<string> value);
    public virtual string GetItemId();
    public virtual void FillJson(DynamicJsonValue json);
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject previousValue);
    private static void AddIndexesIfNecessary(DynamicJsonValue djv, BlittableJsonReaderObject previousValue, List`1<string> indexes);
}
public class Raven.Server.ServerWide.Commands.Monitoring.Snmp.UpdateSnmpDatabasesMappingCommand : UpdateValueCommand`1<List`1<string>> {
    public UpdateSnmpDatabasesMappingCommand(List`1<string> databases, string uniqueRequestId);
    public virtual object ValueToJson();
    public virtual BlittableJsonReaderObject GetUpdatedValue(JsonOperationContext context, BlittableJsonReaderObject previousValue, long index);
    private static void AddDatabasesIfNecessary(DynamicJsonValue djv, BlittableJsonReaderObject previousValue, List`1<string> databases);
}
public class Raven.Server.ServerWide.Commands.PeriodicBackup.ResponsibleNodeInfo : object {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponsibleNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <NotSuitableForTaskSince>k__BackingField;
    public long TaskId { get; public set; }
    public string ResponsibleNode { get; public set; }
    public Nullable`1<DateTime> NotSuitableForTaskSince { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
public void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public string get_ResponsibleNode();
    [CompilerGeneratedAttribute]
public void set_ResponsibleNode(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_NotSuitableForTaskSince();
    [CompilerGeneratedAttribute]
public void set_NotSuitableForTaskSince(Nullable`1<DateTime> value);
    public static string GenerateItemName(string databaseName, long taskId);
    public static string GetPrefix(string databaseName);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.ServerWide.Commands.PeriodicBackup.UpdatePeriodicBackupCommand : UpdateDatabaseCommand {
    public PeriodicBackupConfiguration Configuration;
    private bool _shouldRemoveBackupStatus;
    public UpdatePeriodicBackupCommand(PeriodicBackupConfiguration configuration, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void AfterDatabaseRecordUpdate(ClusterOperationContext ctx, Table items, Logger clusterAuditLog);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.PeriodicBackup.UpdatePeriodicBackupStatusCommand : UpdateValueForDatabaseCommand {
    public PeriodicBackupStatus PeriodicBackupStatus;
    public UpdatePeriodicBackupStatusCommand(string databaseName, string uniqueRequestId);
    public virtual string GetItemId();
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.PeriodicBackup.UpdateResponsibleNodeForTasksCommand : UpdateValueCommand`1<Parameters> {
    public static int CommandVersion;
    public UpdateResponsibleNodeForTasksCommand(Parameters parameters, string uniqueRequestId);
    public virtual object ValueToJson();
    public virtual BlittableJsonReaderObject GetUpdatedValue(JsonOperationContext context, BlittableJsonReaderObject previousValue, long index);
}
public class Raven.Server.ServerWide.Commands.PromoteDatabaseNodeCommand : UpdateDatabaseCommand {
    public string NodeTag;
    public Nullable`1<int> ShardNumber;
    public PromoteDatabaseNodeCommand(string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.PublishedServerUrls : object {
    private static Func`2<BlittableJsonReaderObject, PublishedServerUrls> _converter;
    [JsonDeserializationStringDictionaryAttribute("5")]
public Dictionary`2<string, UrlInfo> Urls;
    private static PublishedServerUrls();
    public sealed virtual DynamicJsonValue ToJson();
    public static PublishedServerUrls Read(ClusterOperationContext context);
    public static void Clear(ClusterOperationContext context);
    public string SelectUrl(string requestedTag, ClusterTopology clusterTopology);
}
public class Raven.Server.ServerWide.Commands.PutCertificateCommand : PutValueCommand`1<CertificateDefinition> {
    public string PublicKeyPinningHash;
    public string TwoFactorAuthenticationKey;
    public PutCertificateCommand(string name, CertificateDefinition value, string uniqueRequestId);
    public static void ValidateCertificateDefinition(CertificateDefinition certificateDefinition);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public virtual DynamicJsonValue ValueToJson();
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.PutCertificateWithSamePinningHashCommand : PutCertificateCommand {
    public PutCertificateWithSamePinningHashCommand(string name, CertificateDefinition value, string uniqueRequestId);
    public virtual DynamicJsonValue ValueToJson();
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.PutClientConfigurationCommand : PutValueCommand`1<ClientConfiguration> {
    public PutClientConfigurationCommand(ClientConfiguration value, string uniqueRequestId);
    public virtual void UpdateValue(ClusterOperationContext context, long index);
    public virtual DynamicJsonValue ValueToJson();
}
public class Raven.Server.ServerWide.Commands.PutDatabaseClientConfigurationCommand : UpdateDatabaseCommand {
    public ClientConfiguration Configuration;
    public PutDatabaseClientConfigurationCommand(ClientConfiguration client, string databaseName, string uniqueRequestId);
    public virtual void FillJson(DynamicJsonValue json);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.PutDatabaseSettingsCommand : UpdateDatabaseCommand {
    public Dictionary`2<string, string> Configuration;
    public PutDatabaseSettingsCommand(Dictionary`2<string, string> settings, string databaseName, string uniqueRequestId);
    public virtual void FillJson(DynamicJsonValue json);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.PutDatabaseStudioConfigurationCommand : UpdateDatabaseCommand {
    public StudioConfiguration Configuration;
    public PutDatabaseStudioConfigurationCommand(StudioConfiguration studio, string databaseName, string uniqueRequestId);
    public virtual void FillJson(DynamicJsonValue json);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
}
public class Raven.Server.ServerWide.Commands.PutLicenseCommand : PutValueCommand`1<License> {
    public bool SkipLicenseAssertion;
    public PutLicenseCommand(string name, License license, string uniqueRequestId, bool fromApi);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public virtual DynamicJsonValue ValueToJson();
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.PutLicenseLimitsCommand : PutValueCommand`1<LicenseLimits> {
    public PutLicenseLimitsCommand(string name, LicenseLimits licenseLimits, string uniqueRequestId);
    public virtual DynamicJsonValue ValueToJson();
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.PutServerWideBackupConfigurationCommand : UpdateValueCommand`1<ServerWideBackupConfiguration> {
    public PutServerWideBackupConfigurationCommand(ServerWideBackupConfiguration configuration, string uniqueRequestId);
    public virtual object ValueToJson();
    public virtual BlittableJsonReaderObject GetUpdatedValue(JsonOperationContext context, BlittableJsonReaderObject previousValue, long index);
    private string GenerateTaskName(BlittableJsonReaderObject previousValue);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
    public static string GetTaskName(string backupConfigurationName);
    public static void UpdateTemplateForDatabase(PeriodicBackupConfiguration configuration, string databaseName, bool isDatabaseEncrypted);
    public static void UpdateSettingsForLocal(LocalSettings localSettings, string databaseName);
    public static void UpdateSettingsForS3(S3Settings s3Settings, string databaseName);
    public static void UpdateSettingsForGlacier(GlacierSettings glacierSettings, string databaseName);
    public static void UpdateSettingsForAzure(AzureSettings azureSettings, string databaseName);
    public static void UpdateSettingsForFtp(FtpSettings ftpSettings, string databaseName);
    public static void UpdateSettingsForGoogleCloud(GoogleCloudSettings googleCloudSettings, string databaseName);
    private static string GetUpdatedPath(string str, string databaseName, char separator);
}
public class Raven.Server.ServerWide.Commands.PutServerWideExternalReplicationCommand : UpdateValueCommand`1<ServerWideExternalReplication> {
    public PutServerWideExternalReplicationCommand(ServerWideExternalReplication configuration, string uniqueRequestId);
    public virtual object ValueToJson();
    public virtual BlittableJsonReaderObject GetUpdatedValue(JsonOperationContext context, BlittableJsonReaderObject previousValue, long index);
    private string GenerateTaskName(BlittableJsonReaderObject previousValue);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
    public static string GetTaskName(string serverWideName);
    public static string GetRavenConnectionStringName(string serverWideName);
    public static RavenConnectionString UpdateExternalReplicationTemplateForDatabase(ExternalReplication configuration, string databaseName, String[] topologyDiscoveryUrls);
}
public class Raven.Server.ServerWide.Commands.PutServerWideStudioConfigurationCommand : PutValueCommand`1<ServerWideStudioConfiguration> {
    public PutServerWideStudioConfigurationCommand(ServerWideStudioConfiguration value, string uniqueRequestId);
    public virtual DynamicJsonValue ValueToJson();
}
public abstract class Raven.Server.ServerWide.Commands.PutValueCommand`1 : CommandBase {
    public string Name;
    public T Value;
    protected PutValueCommand`1(string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public abstract virtual DynamicJsonValue ValueToJson();
    public virtual void UpdateValue(ClusterOperationContext context, long index);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.QueueSink.AddQueueSinkCommand : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private QueueSinkConfiguration <Configuration>k__BackingField;
    public QueueSinkConfiguration Configuration { get; protected set; }
    public AddQueueSinkCommand(QueueSinkConfiguration configuration, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public QueueSinkConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
protected void set_Configuration(QueueSinkConfiguration value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    private void Add(List`1& queueSinks, DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.QueueSink.RemoveQueueSinkProcessStateCommand : UpdateValueForDatabaseCommand {
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScriptName>k__BackingField;
    public string ConfigurationName { get; public set; }
    public string ScriptName { get; public set; }
    public RemoveQueueSinkProcessStateCommand(string databaseName, string configurationName, string scriptName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public string get_ScriptName();
    [CompilerGeneratedAttribute]
public void set_ScriptName(string value);
    public virtual string GetItemId();
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.QueueSink.UpdateQueueSinkCommand : UpdateDatabaseCommand {
    [CompilerGeneratedAttribute]
private long <TaskId>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueSinkConfiguration <Configuration>k__BackingField;
    public long TaskId { get; protected set; }
    public QueueSinkConfiguration Configuration { get; protected set; }
    public UpdateQueueSinkCommand(long taskId, QueueSinkConfiguration configuration, string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public long get_TaskId();
    [CompilerGeneratedAttribute]
protected void set_TaskId(long value);
    [CompilerGeneratedAttribute]
public QueueSinkConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
protected void set_Configuration(QueueSinkConfiguration value);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.QueueSink.UpdateQueueSinkProcessStateCommand : UpdateValueForDatabaseCommand {
    [CompilerGeneratedAttribute]
private QueueSinkProcessState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasHighlyAvailableTasks>k__BackingField;
    public QueueSinkProcessState State { get; public set; }
    public bool HasHighlyAvailableTasks { get; public set; }
    public UpdateQueueSinkProcessStateCommand(string databaseName, QueueSinkProcessState state, bool hasHighlyAvailableTasks, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public QueueSinkProcessState get_State();
    [CompilerGeneratedAttribute]
public void set_State(QueueSinkProcessState value);
    [CompilerGeneratedAttribute]
public bool get_HasHighlyAvailableTasks();
    [CompilerGeneratedAttribute]
public void set_HasHighlyAvailableTasks(bool value);
    public virtual string GetItemId();
    public virtual void FillJson(DynamicJsonValue json);
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    [CompilerGeneratedAttribute]
private bool <GetUpdatedValue>b__12_0(QueueSinkConfiguration x);
}
public class Raven.Server.ServerWide.Commands.RecheckStatusOfServerCertificateCommand : CommandBase {
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.RecheckStatusOfServerCertificateReplacementCommand : CommandBase {
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.RegisterReplicationHubAccessCommand : CommandBase {
    public string Database;
    public string HubName;
    public string CertificatePublicKeyHash;
    public string CertificateThumbprint;
    public string CertificateBase64;
    public String[] AllowedHubToSinkPaths;
    public String[] AllowedSinkToHubPaths;
    public string Name;
    public DateTime NotBefore;
    public DateTime NotAfter;
    public string Issuer;
    public string Subject;
    public bool RegisteringSamePublicKeyPinningHash;
    public RegisterReplicationHubAccessCommand(string databaseName, string hubName, ReplicationHubAccess access, X509Certificate2 certificate, string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public DynamicJsonValue PrepareForStorage();
}
public class Raven.Server.ServerWide.Commands.RemoveCompareExchangeCommand : CompareExchangeCommandBase {
    public RemoveCompareExchangeCommand(string database, string key, long index, JsonOperationContext contextToReturnResult, string uniqueRequestId, bool fromBackup);
    protected virtual CompareExchangeResult ExecuteInternal(ClusterOperationContext context, Table items, long index);
    private void WriteCompareExchangeTombstone(ClusterOperationContext context, long index);
    protected virtual bool Validate(ClusterOperationContext context, Slice keySlice, Table items, Int64& currentIndex);
}
public class Raven.Server.ServerWide.Commands.RemoveNodeFromClusterCommand : CommandBase {
    public string RemovedNode;
    public RemoveNodeFromClusterCommand(string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public virtual void VerifyCanExecuteCommand(ServerStore store, TransactionOperationContext context, bool isClusterAdmin);
}
public class Raven.Server.ServerWide.Commands.RemoveNodeFromDatabaseCommand : UpdateDatabaseCommand {
    public string NodeTag;
    public string DatabaseId;
    public RemoveNodeFromDatabaseCommand(string databaseName, string databaseId, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public string UpdateShardedDatabaseRecord(DatabaseRecord record, int shardNumber, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sharding.AddPrefixedShardingSettingCommand : UpdateDatabaseCommand {
    public PrefixedShardingSetting Setting;
    public AddPrefixedShardingSettingCommand(PrefixedShardingSetting setting, string database, string raftId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    private static int GetNextPrefixedBucketRangeStart(IEnumerable`1<PrefixedShardingSetting> prefixes);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sharding.CreateNewShardCommand : UpdateDatabaseCommand {
    public DatabaseTopology Topology;
    public DateTime At;
    public int ShardNumber;
    public CreateNewShardCommand(string databaseName, int shardNumber, DatabaseTopology shardTopology, DateTime at, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sharding.DeletePrefixedShardingSettingCommand : UpdateDatabaseCommand {
    public PrefixedShardingSetting Setting;
    public DeletePrefixedShardingSettingCommand(PrefixedShardingSetting setting, string database, string raftId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sharding.DestinationMigrationConfirmCommand : UpdateDatabaseCommand {
    public int Bucket;
    public long MigrationIndex;
    public string Node;
    public DestinationMigrationConfirmCommand(int bucket, long migrationIndex, string node, string database, string raftId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sharding.PutShardedSubscriptionCommand : PutSubscriptionCommand {
    public Dictionary`2<string, string> InitialChangeVectorPerShard;
    public PutShardedSubscriptionCommand(string databaseName, string query, string mentor, string uniqueRequestId);
    protected virtual void HandleChangeVectorOnUpdate(ClusterOperationContext context, SubscriptionState existingSubscriptionState, long subscriptionId);
    private bool CompareShardsChangeVectors(Dictionary`2<string, string> existingCVs);
    protected virtual void AssertValidChangeVector();
    protected virtual DynamicJsonValue CreateSubscriptionStateAsJson(long subscriptionId, long index);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sharding.ShardedUpdateExternalReplicationStateCommand : UpdateValueForDatabaseCommand {
    [CompilerGeneratedAttribute]
private ShardedExternalReplicationState <ReplicationState>k__BackingField;
    public ShardedExternalReplicationState ReplicationState { get; public set; }
    public ShardedUpdateExternalReplicationStateCommand(string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public ShardedExternalReplicationState get_ReplicationState();
    [CompilerGeneratedAttribute]
public void set_ReplicationState(ShardedExternalReplicationState value);
    public virtual string GetItemId();
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sharding.SourceMigrationCleanupCommand : UpdateDatabaseCommand {
    public int Bucket;
    public long MigrationIndex;
    public string Node;
    public SourceMigrationCleanupCommand(int bucket, long migrationIndex, string node, string database, string raftId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sharding.SourceMigrationSendCompletedCommand : UpdateDatabaseCommand {
    public int Bucket;
    public long MigrationIndex;
    public string LastSentChangeVector;
    public SourceMigrationSendCompletedCommand(int bucket, long migrationIndex, string lastSentChangeVector, string database, string raftId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sharding.StartBucketMigrationCommand : UpdateDatabaseCommand {
    public Nullable`1<int> SourceShard;
    public int DestinationShard;
    public int Bucket;
    public string Prefix;
    private ShardBucketMigration _migration;
    public StartBucketMigrationCommand(int bucket, Nullable`1<int> sourceShard, int destShard, string database, string prefix, string raftId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void AfterDatabaseRecordUpdate(ClusterOperationContext ctx, Table items, Logger clusterAuditLog);
    private void ProcessSubscriptionsForMigration(ClusterOperationContext context, ShardBucketMigration migration);
    private void AssertDestinationShardExists(ShardingConfiguration shardingConfiguration);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sharding.UpdatePrefixedShardingSettingCommand : UpdateDatabaseCommand {
    public PrefixedShardingSetting Setting;
    public UpdatePrefixedShardingSettingCommand(PrefixedShardingSetting setting, string database, string raftId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Sorters.DeleteServerWideSorterCommand : DeleteValueCommand {
    public DeleteServerWideSorterCommand(string name, string uniqueRequestId);
    public virtual void DeleteValue(ClusterOperationContext context);
    [CompilerGeneratedAttribute]
private void <DeleteValue>b__2_0(IPagerLevelTransactionState _);
}
public class Raven.Server.ServerWide.Commands.Sorters.DeleteSorterCommand : UpdateDatabaseCommand {
    public string SorterName;
    public DeleteSorterCommand(string name, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
internal class Raven.Server.ServerWide.Commands.Sorters.PutServerWideSorterCommand : PutValueCommand`1<SorterDefinition> {
    public static string Prefix;
    public PutServerWideSorterCommand(SorterDefinition value, string uniqueRequestId);
    public virtual void UpdateValue(ClusterOperationContext context, long index);
    public virtual DynamicJsonValue ValueToJson();
    internal static string GetName(string name);
    public static string ExtractName(string name);
    [CompilerGeneratedAttribute]
private void <UpdateValue>b__3_0(IPagerLevelTransactionState _);
}
public class Raven.Server.ServerWide.Commands.Sorters.PutSortersCommand : UpdateDatabaseCommand {
    public List`1<SorterDefinition> Sorters;
    public PutSortersCommand(string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Subscriptions.AcknowledgeSubscriptionBatchCommand : UpdateValueForDatabaseCommand {
    public string ChangeVector;
    public string LastKnownSubscriptionChangeVector;
    public long SubscriptionId;
    public string SubscriptionName;
    public string NodeTag;
    public bool HasHighlyAvailableTasks;
    public DateTime LastTimeServerMadeProgressWithDocuments;
    public Nullable`1<long> BatchId;
    public List`1<DocumentRecord> DocumentsToResend;
    public string ShardName;
    public long LastModifiedIndex;
    public static long SwappedNonExistentBatch;
    public AcknowledgeSubscriptionBatchCommand(string databaseName, string uniqueRequestId);
    private static AcknowledgeSubscriptionBatchCommand();
    public virtual string GetItemId();
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public void AssertSubscriptionState(RawDatabaseRecord record, SubscriptionState subscription, string subscriptionName);
    private bool IsLegacyCommand();
    public virtual void Execute(ClusterOperationContext context, Table items, long index, RawDatabaseRecord record, RachisState state, Object& result);
    private void ExecuteAcknowledgeSubscriptionBatch(ClusterOperationContext context, Table items, long index);
    public virtual void FillJson(DynamicJsonValue json);
    public virtual string AdditionalDebugInformation(Exception exception);
    [CompilerGeneratedAttribute]
private bool <ExecuteAcknowledgeSubscriptionBatch>b__18_0(TableValueHolder tvh);
}
public class Raven.Server.ServerWide.Commands.Subscriptions.DeleteSubscriptionCommand : UpdateValueForDatabaseCommand {
    public string SubscriptionName;
    public DeleteSubscriptionCommand(string databaseName, string subscriptionName, string uniqueRequestId);
    public virtual string GetItemId();
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void Execute(ClusterOperationContext context, Table items, long index, RawDatabaseRecord record, RachisState state, Object& result);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Subscriptions.DocumentRecord : SubscriptionRecord {
    public string DocumentId;
    public string ChangeVector;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.ServerWide.Commands.Subscriptions.PutShardedSubscriptionBatchCommand : PutSubscriptionBatchCommandBase`1<PutShardedSubscriptionCommand> {
    public PutShardedSubscriptionBatchCommand(List`1<PutShardedSubscriptionCommand> commands, string uniqueRequestId);
}
public class Raven.Server.ServerWide.Commands.Subscriptions.PutSubscriptionBatchCommand : PutSubscriptionBatchCommandBase`1<PutSubscriptionCommand> {
    public PutSubscriptionBatchCommand(List`1<PutSubscriptionCommand> commands, string uniqueRequestId);
}
public abstract class Raven.Server.ServerWide.Commands.Subscriptions.PutSubscriptionBatchCommandBase`1 : CommandBase {
    public List`1<T> Commands;
    protected PutSubscriptionBatchCommandBase`1(List`1<T> commands, string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.Subscriptions.PutSubscriptionCommand : UpdateValueForDatabaseCommand {
    public string Query;
    public string InitialChangeVector;
    public Nullable`1<long> SubscriptionId;
    public string SubscriptionName;
    public bool Disabled;
    public string MentorNode;
    public bool PinToMentorNode;
    public Nullable`1<ArchivedDataProcessingBehavior> ArchivedDataProcessingBehavior;
    public PutSubscriptionCommand(string databaseName, string query, string mentor, string uniqueRequestId);
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void Execute(ClusterOperationContext context, Table items, long index, RawDatabaseRecord record, RachisState state, Object& result);
    protected virtual DynamicJsonValue CreateSubscriptionStateAsJson(long subscriptionId, long index);
    protected virtual void HandleChangeVectorOnUpdate(ClusterOperationContext context, SubscriptionState existingSubscriptionState, long subscriptionId);
    protected void RemoveSubscriptionStateFromStorage(ClusterOperationContext context, long subscriptionId);
    public long FindFreeId(ClusterOperationContext context, long subscriptionId);
    protected virtual void AssertValidChangeVector();
    public virtual string GetItemId();
    public bool IncludesRevisions();
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Subscriptions.RecordBatchSubscriptionDocumentsCommand : UpdateValueForDatabaseCommand {
    public long SubscriptionId;
    public string SubscriptionName;
    public string CurrentChangeVector;
    public string PreviouslyRecordedChangeVector;
    public string NodeTag;
    public bool HasHighlyAvailableTasks;
    public List`1<DocumentRecord> Documents;
    public List`1<string> Deleted;
    public List`1<RevisionRecord> Revisions;
    public string ShardName;
    public RecordBatchSubscriptionDocumentsCommand(string databaseName, long subscriptionId, string subscriptionName, List`1<DocumentRecord> documents, string previouslyRecordedChangeVector, string currentChangeVector, string nodeTag, bool hasHighlyAvailableTasks, string uniqueRaftId);
    public RecordBatchSubscriptionDocumentsCommand(string databaseName, long subscriptionId, string subscriptionName, List`1<RevisionRecord> revisions, string previouslyRecordedChangeVector, string currentChangeVector, string nodeTag, bool hasHighlyAvailableTasks, string uniqueRaftId);
    public virtual object FromRemote(object remoteResult);
    public virtual void Execute(ClusterOperationContext context, Table items, long index, RawDatabaseRecord record, RachisState state, Object& result);
    private void WriteRevisionsToResendTable(ClusterOperationContext context, long index, Table subscriptionStateTable);
    private void WriteDeletesToResendTable(ClusterOperationContext context, List`1<string> deleted, Table subscriptionStateTable);
    private void WriteDocumentsToResendTable(ClusterOperationContext context, long index, List`1<DocumentRecord> documents, Table subscriptionStateTable);
    private bool IsAlreadyProcessedReshardedDocument(ClusterOperationContext context, RawShardingConfiguration configuration, SubscriptionShardingState subscriptionShardingState, string id, string changeVector);
    private bool IsBucketUnderActiveMigration(RawDatabaseRecord record, int bucket);
    private bool IsFromProperShard(ClusterOperationContext context, RawDatabaseRecord record, string id);
    private void CheckConcurrencyForBatchCv(SubscriptionState state, string subscriptionName);
    public virtual string GetItemId();
    public virtual void FillJson(DynamicJsonValue json);
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
}
public class Raven.Server.ServerWide.Commands.Subscriptions.RevisionRecord : SubscriptionRecord {
    public string DocumentId;
    public string Previous;
    public string Current;
    public sealed virtual DynamicJsonValue ToJson();
}
public abstract class Raven.Server.ServerWide.Commands.Subscriptions.SubscriptionRecord : object {
}
public enum Raven.Server.ServerWide.Commands.Subscriptions.SubscriptionType : Enum {
    public byte value__;
    public static SubscriptionType None;
    public static SubscriptionType Document;
    public static SubscriptionType Revision;
}
public class Raven.Server.ServerWide.Commands.Subscriptions.ToggleSubscriptionStateCommand : UpdateValueForDatabaseCommand {
    public string SubscriptionName;
    public bool Disable;
    public ToggleSubscriptionStateCommand(string subscriptionName, bool disable, string databaseName, string uniqueRequestId);
    public virtual string GetItemId();
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void Execute(ClusterOperationContext context, Table items, long index, RawDatabaseRecord record, RachisState state, Object& result);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.Subscriptions.UpdateSubscriptionClientConnectionTime : UpdateValueForDatabaseCommand {
    public string SubscriptionName;
    public string NodeTag;
    public bool HasHighlyAvailableTasks;
    public DateTime LastClientConnectionTime;
    public UpdateSubscriptionClientConnectionTime(string databaseName, string uniqueRequestId);
    public virtual string GetItemId();
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.ToggleDatabasesStateCommand : UpdateValueCommand`1<Parameters> {
    public ToggleDatabasesStateCommand(Parameters parameters, string uniqueRequestId);
    public virtual object ValueToJson();
    public virtual BlittableJsonReaderObject GetUpdatedValue(JsonOperationContext context, BlittableJsonReaderObject previousValue, long index);
}
public class Raven.Server.ServerWide.Commands.ToggleServerWideTaskStateCommand : UpdateValueCommand`1<Parameters> {
    public ToggleServerWideTaskStateCommand(Parameters configuration, string uniqueRequestId);
    public virtual object ValueToJson();
    public virtual BlittableJsonReaderObject GetUpdatedValue(JsonOperationContext context, BlittableJsonReaderObject previousValue, long index);
    private string GetDisabledPropertyName();
}
public class Raven.Server.ServerWide.Commands.ToggleTaskStateCommand : UpdateDatabaseCommand {
    public long TaskId;
    public OngoingTaskType TaskType;
    public bool Disable;
    public ToggleTaskStateCommand(long taskId, OngoingTaskType type, bool disable, string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__5_1(ExternalReplication x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__5_2(PeriodicBackupConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__5_3(SqlEtlConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__5_4(OlapEtlConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__5_5(RavenEtlConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__5_6(ElasticSearchEtlConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__5_7(QueueEtlConfiguration x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__5_8(PullReplicationDefinition x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__5_9(PullReplicationAsSink x);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__5_10(QueueSinkConfiguration x);
    [CompilerGeneratedAttribute]
private void <UpdateDatabaseRecord>g__ThrowIfServerWideTask|5_0(string name, string prefix, string typeName);
}
public class Raven.Server.ServerWide.Commands.UnregisterReplicationHubAccessCommand : CommandBase {
    public string Database;
    public string HubName;
    public string CertificateThumbprint;
    public UnregisterReplicationHubAccessCommand(string databaseName, string hubName, string certThumbprint, string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.UpdateClusterIdentityCommand : UpdateValueForDatabaseCommand {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, long> <Identities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Force>k__BackingField;
    public Dictionary`2<string, long> Identities { get; public set; }
    public bool Force { get; public set; }
    public UpdateClusterIdentityCommand(string databaseName, Dictionary`2<string, long> identities, bool force, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, long> get_Identities();
    [CompilerGeneratedAttribute]
public void set_Identities(Dictionary`2<string, long> value);
    [CompilerGeneratedAttribute]
public bool get_Force();
    [CompilerGeneratedAttribute]
public void set_Force(bool value);
    public virtual string GetItemId();
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void Execute(ClusterOperationContext context, Table items, long index, RawDatabaseRecord record, RachisState state, Object& result);
    public virtual object FromRemote(object remoteResult);
    public virtual void FillJson(DynamicJsonValue json);
}
public abstract class Raven.Server.ServerWide.Commands.UpdateDatabaseCommand : CommandBase {
    public string DatabaseName;
    public bool ErrorOnDatabaseDoesNotExists;
    protected UpdateDatabaseCommand(string databaseName, string uniqueRequestId);
    public abstract virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void AfterDatabaseRecordUpdate(ClusterOperationContext ctx, Table items, Logger clusterAuditLog);
    protected static void SetLeaderStampForTopology(DatabaseTopology topology, long etag);
    public abstract virtual void FillJson(DynamicJsonValue json);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public virtual void Initialize(ServerStore serverStore, ClusterOperationContext context);
    public static void EnsureTaskNameIsNotUsed(DatabaseRecord record, string name);
}
public class Raven.Server.ServerWide.Commands.UpdateExternalReplicationCommand : UpdateDatabaseCommand {
    public ExternalReplication Watcher;
    public UpdateExternalReplicationCommand(string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__3_0(ExternalReplication x);
}
public class Raven.Server.ServerWide.Commands.UpdateExternalReplicationStateCommand : UpdateValueForDatabaseCommand {
    [CompilerGeneratedAttribute]
private ExternalReplicationState <ExternalReplicationState>k__BackingField;
    public ExternalReplicationState ExternalReplicationState { get; public set; }
    public UpdateExternalReplicationStateCommand(string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public ExternalReplicationState get_ExternalReplicationState();
    [CompilerGeneratedAttribute]
public void set_ExternalReplicationState(ExternalReplicationState value);
    public virtual string GetItemId();
    protected virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.UpdateLicenseLimitsCommand : UpdateValueCommand`1<NodeLicenseLimits> {
    public static int NodeInfoUpdate;
    public UpdateLicenseLimitsCommand(string name, NodeLicenseLimits nodeLicenseLimits, string uniqueRaftId);
    private static UpdateLicenseLimitsCommand();
    public virtual object ValueToJson();
    public virtual BlittableJsonReaderObject GetUpdatedValue(JsonOperationContext context, BlittableJsonReaderObject previousValue, long index);
    private void RemoveNotInClusterNodes(LicenseLimits licenseLimits);
    private void UpdateNodeDetails(LicenseLimits licenseLimits);
    private void ReBalanceCores(LicenseLimits licenseLimits);
}
public class Raven.Server.ServerWide.Commands.UpdatePullReplicationAsHubCommand : UpdateDatabaseCommand {
    public PullReplicationDefinition Definition;
    public UpdatePullReplicationAsHubCommand(string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.UpdatePullReplicationAsSinkCommand : UpdateDatabaseCommand {
    public PullReplicationAsSink PullReplicationAsSink;
    public Nullable`1<bool> UseServerCertificate;
    public UpdatePullReplicationAsSinkCommand(string databaseName, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
    [CompilerGeneratedAttribute]
private bool <UpdateDatabaseRecord>b__4_0(PullReplicationAsSink x);
}
public class Raven.Server.ServerWide.Commands.UpdateServerPublishedUrlsCommand : CommandBase {
    public static string ClusterUrlsKey;
    public string NodeTag;
    public string PublicUrl;
    public string PrivateUrl;
    public UpdateServerPublishedUrlsCommand(string nodeTag, string publicUrl, string privateUrl, string raftId);
    public void Update(ClusterOperationContext context, long index);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
}
public class Raven.Server.ServerWide.Commands.UpdateTopologyCommand : UpdateDatabaseCommand {
    public DatabaseTopology Topology;
    public DateTime At;
    public Nullable`1<int> ShardNumber;
    public UpdateTopologyCommand(string databaseName, DateTime at, string uniqueRequestId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public class Raven.Server.ServerWide.Commands.UpdateUnusedDatabaseIdsCommand : UpdateDatabaseCommand {
    public HashSet`1<string> UnusedDatabaseIds;
    public UpdateUnusedDatabaseIdsCommand(string database, HashSet`1<string> list, string raftId);
    public virtual void UpdateDatabaseRecord(DatabaseRecord record, long etag);
    public virtual void FillJson(DynamicJsonValue json);
}
public abstract class Raven.Server.ServerWide.Commands.UpdateValueCommand`1 : CommandBase {
    public string Name;
    public T Value;
    protected UpdateValueCommand`1(string uniqueRequestId);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public abstract virtual object ValueToJson();
    public abstract virtual BlittableJsonReaderObject GetUpdatedValue(JsonOperationContext context, BlittableJsonReaderObject previousValue, long index);
}
public abstract class Raven.Server.ServerWide.Commands.UpdateValueForDatabaseCommand : CommandBase {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    public string DatabaseName { get; public set; }
    protected UpdateValueForDatabaseCommand(string databaseName, string uniqueRequestId);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    public abstract virtual string GetItemId();
    public abstract virtual void FillJson(DynamicJsonValue json);
    protected abstract virtual UpdatedValue GetUpdatedValue(long index, RawDatabaseRecord record, ClusterOperationContext context, BlittableJsonReaderObject existingValue);
    public virtual void Execute(ClusterOperationContext context, Table items, long index, RawDatabaseRecord record, RachisState state, Object& result);
    public virtual object GetState();
    public static long GetValue(TableValueReader tvr);
    public static void UpdateTableRow(long index, Table identitiesItems, long value, Slice keySlice, Slice prefixIndexSlice);
    public virtual DynamicJsonValue ToJson(JsonOperationContext context);
    public static string GetDatabaseNameFromJson(BlittableJsonReaderObject cmd);
    public static Func`1<string> GetLastResponsibleNode(bool hasHighlyAvailableTasks, DatabaseTopology topology, string nodeTag);
}
public class Raven.Server.ServerWide.Commands.UrlInfo : object {
    public string PublicUrl;
    public string PrivateUrl;
    public long Index;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.ServerWide.CompareExchangeChange : object {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    public string Database { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
}
public class Raven.Server.ServerWide.CompareExchangeExpirationStorage : object {
    public static Slice CompareExchangeByExpiration;
    private static CompareExchangeExpirationStorage();
    public static void Put(ClusterOperationContext context, Slice keySlice, long ticks);
    public static bool HasExpired(ClusterOperationContext context, long currentTicks);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.CompareExchangeExpirationStorage/<GetExpiredValues>d__4")]
internal static IEnumerable`1<ValueTuple`3<Slice, long, Slice>> GetExpiredValues(ClusterOperationContext context, long currentTicks);
    public static bool TryGetExpires(BlittableJsonReaderObject value, Int64& ticks);
    public static bool DeleteExpiredCompareExchange(ClusterOperationContext context, Table items, long ticks, long take);
    private static void CleanExpired(ClusterOperationContext context, Dictionary`2<Slice, List`1<Slice>> expired);
}
public class Raven.Server.ServerWide.CompareExchangeKey : ValueType {
    public LazyStringValue StorageKey;
    private string _key;
    private static char _separator;
    private int _prefixLength;
    public string Key { get; }
    public CompareExchangeKey(string key);
    public CompareExchangeKey(LazyStringValue storageKey, string key);
    public CompareExchangeKey(LazyStringValue storageKey, int prefixLength);
    public string get_Key();
    public static string GetStorageKey(string database, string key);
}
public class Raven.Server.ServerWide.Context.ClusterContextPool : JsonContextPoolBase`1<ClusterOperationContext> {
    private ClusterChanges _changes;
    private StorageEnvironment _storageEnvironment;
    public ClusterContextPool(ClusterChanges changes, StorageEnvironment storageEnvironment, Nullable`1<Size> maxContextSizeToKeepInMb);
    protected virtual ClusterOperationContext CreateContext();
    public virtual void Dispose();
    private sealed virtual override IDisposable Raven.Server.ServerWide.Context.ITransactionContextPool<Raven.Server.ServerWide.Context.ClusterOperationContext>.AllocateOperationContext(ClusterOperationContext& context);
    private sealed virtual override IDisposable Raven.Server.ServerWide.Context.IMemoryContextPool.AllocateOperationContext(JsonOperationContext& context);
}
public class Raven.Server.ServerWide.Context.ClusterOperationContext : TransactionOperationContext`1<ClusterTransaction> {
    private ClusterChanges _changes;
    public ClusterOperationContext(ClusterChanges changes, StorageEnvironment environment, int initialSize, int longLivedSize, int maxNumberOfAllocatedStringValues, SharedMultipleUseFlag lowMemoryFlag);
    protected virtual ClusterTransaction CloneReadTransaction(ClusterTransaction previous);
    protected virtual ClusterTransaction CreateReadTransaction();
    protected virtual ClusterTransaction CreateWriteTransaction(Nullable`1<TimeSpan> timeout);
}
public class Raven.Server.ServerWide.Context.ClusterTransaction : RavenTransaction {
    private List`1<CompareExchangeChange> _compareExchangeNotifications;
    private ClusterChanges _clusterChanges;
    public ClusterTransaction(Transaction transaction, ClusterChanges clusterChanges);
    public ClusterTransaction BeginAsyncCommitAndStartNewTransaction(ClusterOperationContext context);
    public void AddAfterCommitNotification(CompareExchangeChange change);
    protected virtual bool ShouldRaiseNotifications();
    protected virtual void RaiseNotifications();
}
public class Raven.Server.ServerWide.Context.DocumentsContextPool : JsonContextPoolBase`1<DocumentsOperationContext> {
    private DocumentDatabase _database;
    public DocumentsContextPool(DocumentDatabase database);
    protected virtual DocumentsOperationContext CreateContext();
    public virtual void Dispose();
    private sealed virtual override IDisposable Raven.Server.ServerWide.Context.IDocumentsContextPool.AllocateOperationContext(DocumentsOperationContext& context);
    private sealed virtual override IDisposable Raven.Server.ServerWide.Context.IMemoryContextPool.AllocateOperationContext(JsonOperationContext& context);
}
public class Raven.Server.ServerWide.Context.DocumentsOperationContext : TransactionOperationContext`1<DocumentsTransaction> {
    private DocumentDatabase _documentDatabase;
    private ChangeVector _lastDatabaseChangeVector;
    internal Dictionary`2<string, long> LastReplicationEtagFrom;
    private bool _skipChangeVectorValidation;
    internal HashSet`1<string> DbIdsToIgnore;
    internal ChangeVector LastDatabaseChangeVector { get; internal set; }
    internal bool SkipChangeVectorValidation { get; internal set; }
    public bool CanContinueTransaction { get; }
    public DocumentDatabase DocumentDatabase { get; }
    public DocumentsOperationContext(DocumentDatabase documentDatabase, int initialSize, int longLivedSize, int maxNumberOfAllocatedStringValues, SharedMultipleUseFlag lowMemoryFlag);
    internal ChangeVector get_LastDatabaseChangeVector();
    internal void set_LastDatabaseChangeVector(ChangeVector value);
    internal bool get_SkipChangeVectorValidation();
    internal void set_SkipChangeVectorValidation(bool value);
    public bool get_CanContinueTransaction();
    protected internal virtual void Reset(bool forceResetLongLivedAllocator);
    public static DocumentsOperationContext ShortTermSingleUse(DocumentDatabase documentDatabase);
    protected virtual DocumentsTransaction CloneReadTransaction(DocumentsTransaction previous);
    protected virtual DocumentsTransaction CreateReadTransaction();
    protected virtual DocumentsTransaction CreateWriteTransaction(Nullable`1<TimeSpan> timeout);
    public DocumentDatabase get_DocumentDatabase();
    public bool ShouldRenewTransactionsToAllowFlushing();
}
public class Raven.Server.ServerWide.Context.DocumentTransactionCache : object {
    public long LastDocumentEtag;
    public long LastTombstoneEtag;
    public long LastCounterEtag;
    public long LastTimeSeriesEtag;
    public long LastConflictEtag;
    public long LastRevisionsEtag;
    public long LastAttachmentsEtag;
    public long LastEtag;
    public Dictionary`2<string, CollectionCache> LastEtagsByCollection;
}
public interface Raven.Server.ServerWide.Context.IChangeVectorOperationContext {
    public abstract virtual ChangeVector GetChangeVector(string changeVector, bool throwOnRecursion);
    public abstract virtual ChangeVector GetChangeVector(string version, string order);
}
public interface Raven.Server.ServerWide.Context.IDocumentsContextPool {
    public abstract virtual IDisposable AllocateOperationContext(DocumentsOperationContext& context);
}
public interface Raven.Server.ServerWide.Context.IMemoryContextPool {
    public abstract virtual IDisposable AllocateOperationContext(JsonOperationContext& context);
}
public interface Raven.Server.ServerWide.Context.ITransactionContextPool`1 {
    public abstract virtual IDisposable AllocateOperationContext(TOperationContext& context);
}
public class Raven.Server.ServerWide.Context.TransactionContextPool : JsonContextPoolBase`1<TransactionOperationContext> {
    private StorageEnvironment _storageEnvironment;
    public TransactionContextPool(StorageEnvironment storageEnvironment, Nullable`1<Size> maxContextSizeToKeepInMb);
    protected virtual TransactionOperationContext CreateContext();
    public virtual void Dispose();
    private sealed virtual override IDisposable Raven.Server.ServerWide.Context.ITransactionContextPool<Raven.Server.ServerWide.Context.TransactionOperationContext>.AllocateOperationContext(TransactionOperationContext& context);
    private sealed virtual override IDisposable Raven.Server.ServerWide.Context.IMemoryContextPool.AllocateOperationContext(JsonOperationContext& context);
}
public class Raven.Server.ServerWide.Context.TransactionOperationContext : TransactionOperationContext`1<RavenTransaction> {
    public bool IgnoreStalenessDueToReduceOutputsToDelete;
    public TransactionOperationContext(StorageEnvironment environment, int initialSize, int longLivedSize, int maxNumberOfAllocatedStringValues, SharedMultipleUseFlag lowMemoryFlag);
    protected virtual RavenTransaction CloneReadTransaction(RavenTransaction previous);
    protected virtual RavenTransaction CreateReadTransaction();
    protected virtual RavenTransaction CreateWriteTransaction(Nullable`1<TimeSpan> timeout);
}
public abstract class Raven.Server.ServerWide.Context.TransactionOperationContext`1 : JsonOperationContext {
    internal static short DefaultTransactionMarker;
    public ByteStringContext Allocator;
    public TransactionPersistentContext PersistentContext;
    public TTransaction Transaction;
    private int _maxOfAllocatedChangeVectors;
    private int _numberOfAllocatedChangeVectors;
    private FastList`1<ChangeVector> _allocatedChangeVectors;
    public StorageEnvironment Environment;
    public short TransactionMarkerOffset;
    protected short CurrentTxMarker;
    public long AllocatedMemory { get; }
    public long UsedMemory { get; }
    public bool HasTransaction { get; }
    protected TransactionOperationContext`1(StorageEnvironment environment, int initialSize, int longLivedSize, int maxNumberOfAllocatedStringValues, SharedMultipleUseFlag lowMemoryFlag);
    public TTransaction OpenReadTransaction();
    public TTransaction CloneReadTransaction();
    protected abstract virtual TTransaction CloneReadTransaction(TTransaction previous);
    public virtual long get_AllocatedMemory();
    public virtual long get_UsedMemory();
    public bool get_HasTransaction();
    public short GetTransactionMarker();
    [DoesNotReturnAttribute]
private static void ThrowWriteTransactionMustBeOpen();
    [DoesNotReturnAttribute]
private static void ThrowReadTransactionMustBeOpen();
    protected abstract virtual TTransaction CreateReadTransaction();
    protected abstract virtual TTransaction CreateWriteTransaction(Nullable`1<TimeSpan> timeout);
    public TTransaction OpenWriteTransaction(Nullable`1<TimeSpan> timeout);
    [DoesNotReturnAttribute]
private static void ThrowTransactionAlreadyOpened();
    public void CloseTransaction();
    public virtual void Dispose();
    protected internal virtual void Renew();
    protected internal virtual void Reset(bool forceResetLongLivedAllocator);
    public ChangeVector GetChangeVector(string changeVector);
    public ChangeVector GetEmptyChangeVector();
    public sealed virtual ChangeVector GetChangeVector(string changeVector, bool throwOnRecursion);
    public sealed virtual ChangeVector GetChangeVector(string version, string order);
}
public static class Raven.Server.ServerWide.DebugInfoPackageUtils : object {
    public static IReadOnlyList`1<RouteInformation> Routes;
    private static DebugInfoPackageUtils();
    public static string GetOutputPathFromRouteInformation(RouteInformation route, string prefix, string extension);
    public static string GetOutputPathFromRouteInformation(string path, string prefix, string extension);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.DebugInfoPackageUtils/<GetAuthorizedRoutes>d__3")]
public static IEnumerable`1<RouteInformation> GetAuthorizedRoutes(RavenServer server, HttpContext httpContext, string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.DebugInfoPackageUtils/<WriteExceptionAsZipEntryAsync>d__4")]
public static Task WriteExceptionAsZipEntryAsync(Exception e, ZipArchive archive, string entryName);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.DebugInfoPackageUtils/<WriteDebugInfoTimesAsZipEntryAsync>d__5")]
public static Task WriteDebugInfoTimesAsZipEntryAsync(Dictionary`2<string, TimeSpan> debugInfoTimeSpans, ZipArchive archive, string prefix);
}
public class Raven.Server.ServerWide.ErrorHolder : object {
    public long Index;
    public ExceptionDispatchInfo Exception;
}
internal class Raven.Server.ServerWide.JsonDeserializationCluster : JsonDeserializationBase {
    public static Func`2<BlittableJsonReaderObject, DetailedReplicationHubAccess> DetailedReplicationHubAccess;
    public static Func`2<BlittableJsonReaderObject, UpdateClusterIdentityCommand> UpdateClusterIdentityCommand;
    public static Func`2<BlittableJsonReaderObject, IncrementClusterIdentityCommand> IncrementClusterIdentityCommand;
    public static Func`2<BlittableJsonReaderObject, IncrementClusterIdentitiesBatchCommand> IncrementClusterIdentitiesBatchCommand;
    public static Func`2<BlittableJsonReaderObject, DeleteValueCommand> DeleteValueCommand;
    public static Func`2<BlittableJsonReaderObject, DeleteMultipleValuesCommand> DeleteMultipleValuesCommand;
    public static Func`2<BlittableJsonReaderObject, AddDatabaseCommand> AddDatabaseCommand;
    public static Func`2<BlittableJsonReaderObject, DatabaseRecord> DatabaseRecord;
    public static Func`2<BlittableJsonReaderObject, DatabaseTopology> DatabaseTopology;
    public static Func`2<BlittableJsonReaderObject, ShardBucketRange> ShardRangeAssignment;
    public static Func`2<BlittableJsonReaderObject, RemoveNodeFromDatabaseCommand> RemoveNodeFromDatabaseCommand;
    public static Func`2<BlittableJsonReaderObject, RemoveNodeFromClusterCommand> RemoveNodeFromClusterCommand;
    public static Func`2<BlittableJsonReaderObject, ExpirationConfiguration> ExpirationConfiguration;
    public static Func`2<BlittableJsonReaderObject, RefreshConfiguration> RefreshConfiguration;
    public static Func`2<BlittableJsonReaderObject, DataArchivalConfiguration> DataArchivalConfiguration;
    public static Func`2<BlittableJsonReaderObject, StudioConfiguration> StudioConfiguration;
    public static Func`2<BlittableJsonReaderObject, PeriodicBackupConfiguration> PeriodicBackupConfiguration;
    public static Func`2<BlittableJsonReaderObject, ServerWideBackupConfiguration> ServerWideBackupConfiguration;
    public static Func`2<BlittableJsonReaderObject, PrefixedShardingSetting> PrefixedShardingSetting;
    public static Func`2<BlittableJsonReaderObject, ServerWideExternalReplication> ServerWideExternalReplication;
    public static Func`2<BlittableJsonReaderObject, ExternalReplicationState> ExternalReplicationState;
    public static Func`2<BlittableJsonReaderObject, ShardedExternalReplicationState> ShardedExternalReplicationState;
    public static Func`2<BlittableJsonReaderObject, RestoreBackupConfiguration> RestoreBackupConfiguration;
    public static Func`2<BlittableJsonReaderObject, RestoreFromS3Configuration> RestoreS3BackupConfiguration;
    public static Func`2<BlittableJsonReaderObject, RestoreFromAzureConfiguration> RestoreAzureBackupConfiguration;
    public static Func`2<BlittableJsonReaderObject, RestoreFromGoogleCloudConfiguration> RestoreGoogleCloudBackupConfiguration;
    public static Func`2<BlittableJsonReaderObject, TimeSeriesConfiguration> TimeSeriesConfiguration;
    public static Func`2<BlittableJsonReaderObject, TimeSeriesCollectionConfiguration> TimeSeriesCollectionConfiguration;
    public static Func`2<BlittableJsonReaderObject, TimeSeriesPolicy> TimeSeriesPolicy;
    public static Func`2<BlittableJsonReaderObject, RevisionsConfiguration> RevisionsConfiguration;
    public static Func`2<BlittableJsonReaderObject, DocumentsCompressionConfiguration> DocumentsCompressionConfiguration;
    public static Func`2<BlittableJsonReaderObject, RevisionsCollectionConfiguration> RevisionsCollectionConfiguration;
    public static Func`2<BlittableJsonReaderObject, PullReplicationAsSink> PullReplicationAsSink;
    public static Func`2<BlittableJsonReaderObject, ExternalReplication> ExternalReplication;
    public static Func`2<BlittableJsonReaderObject, ConflictSolver> ConflictSolverConfig;
    public static Func`2<BlittableJsonReaderObject, RavenEtlConfiguration> RavenEtlConfiguration;
    public static Func`2<BlittableJsonReaderObject, SqlEtlConfiguration> SqlEtlConfiguration;
    public static Func`2<BlittableJsonReaderObject, OlapEtlConfiguration> OlapEtlConfiguration;
    public static Func`2<BlittableJsonReaderObject, ElasticSearchEtlConfiguration> ElasticSearchEtlConfiguration;
    public static Func`2<BlittableJsonReaderObject, QueueEtlConfiguration> QueueEtlConfiguration;
    public static Func`2<BlittableJsonReaderObject, CompareExchangeResult> CompareExchangeResult;
    public static Func`2<BlittableJsonReaderObject, AdminJsScript> AdminJsScript;
    public static Func`2<BlittableJsonReaderObject, RavenConnectionString> RavenConnectionString;
    public static Func`2<BlittableJsonReaderObject, SqlConnectionString> SqlConnectionString;
    public static Func`2<BlittableJsonReaderObject, OlapConnectionString> OlapConnectionString;
    public static Func`2<BlittableJsonReaderObject, ElasticSearchConnectionString> ElasticSearchConnectionString;
    public static Func`2<BlittableJsonReaderObject, QueueConnectionString> QueueConnectionString;
    public static Func`2<BlittableJsonReaderObject, QueueSinkConfiguration> QueueSinkConfiguration;
    public static Func`2<BlittableJsonReaderObject, ClientConfiguration> ClientConfiguration;
    public static Func`2<BlittableJsonReaderObject, InstallUpdatedServerCertificateCommand> InstallUpdatedServerCertificateCommand;
    public static Func`2<BlittableJsonReaderObject, ConfirmReceiptServerCertificateCommand> ConfirmReceiptServerCertificateCommand;
    public static Func`2<BlittableJsonReaderObject, RecheckStatusOfServerCertificateCommand> RecheckStatusOfServerCertificateCommand;
    public static Func`2<BlittableJsonReaderObject, ConfirmServerCertificateReplacedCommand> ConfirmServerCertificateReplacedCommand;
    public static Func`2<BlittableJsonReaderObject, RecheckStatusOfServerCertificateReplacementCommand> RecheckStatusOfServerCertificateReplacementCommand;
    public static Func`2<BlittableJsonReaderObject, IndexHistoryEntry> IndexHistoryEntry;
    public static Func`2<BlittableJsonReaderObject, IndexDefinition> IndexDefinition;
    public static Func`2<BlittableJsonReaderObject, AutoIndexDefinition> AutoIndexDefinition;
    public static Func`2<BlittableJsonReaderObject, RollingIndex> RollingIndexes;
    public static Func`2<BlittableJsonReaderObject, SorterDefinition> SorterDefinition;
    public static Func`2<BlittableJsonReaderObject, PostgreSqlConfiguration> PostgreSqlConfiguration;
    public static Func`2<BlittableJsonReaderObject, ShardBucketMigration> BucketMigration;
    public static Func`2<BlittableJsonReaderObject, OrchestratorConfiguration> OrchestratorConfiguration;
    public static Func`2<BlittableJsonReaderObject, ShardingConfiguration> ShardingConfiguration;
    public static Dictionary`2<string, Func`2<BlittableJsonReaderObject, CommandBase>> Commands;
    private static JsonDeserializationCluster();
}
public class Raven.Server.ServerWide.LocalEndpointClient : object {
    private RavenServer _server;
    public static string DebugPackage;
    public LocalEndpointClient(RavenServer server);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.LocalEndpointClient/<InvokeAsync>d__3")]
public Task`1<HttpResponse> InvokeAsync(RouteInformation route, Dictionary`2<string, StringValues> parameters, CancellationToken cancellationToken);
    private static void UpdateRouteMatchWithDatabaseName(RequestHandlerContext requestContext, StringValues values);
    [DoesNotReturnAttribute]
private static void ThrowInvalidDatabasesParameter(StringValues databaseName, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowHttpRequestException(RouteInformation route, int statusCode);
}
public class Raven.Server.ServerWide.Maintenance.ClusterMaintenanceConnection : object {
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private TcpClient <TcpClient>k__BackingField;
    [CompilerGeneratedAttribute]
private SupportedFeatures <SupportedFeatures>k__BackingField;
    public Stream Stream { get; public set; }
    public TcpClient TcpClient { get; public set; }
    public SupportedFeatures SupportedFeatures { get; public set; }
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
    [CompilerGeneratedAttribute]
public TcpClient get_TcpClient();
    [CompilerGeneratedAttribute]
public void set_TcpClient(TcpClient value);
    [CompilerGeneratedAttribute]
public SupportedFeatures get_SupportedFeatures();
    [CompilerGeneratedAttribute]
public void set_SupportedFeatures(SupportedFeatures value);
}
public class Raven.Server.ServerWide.Maintenance.ClusterMaintenanceSupervisor : object {
    private string _leaderClusterTag;
    private long _term;
    private bool _isDisposed;
    private ConcurrentDictionary`2<string, ClusterNode> _clusterNodes;
    private CancellationTokenSource _cts;
    private JsonContextPool _contextPool;
    internal ClusterConfiguration Config;
    private ServerStore _server;
    internal TestingStuff ForTestingPurposes;
    internal ServerStore ServerStore { get; }
    public ClusterMaintenanceSupervisor(ServerStore server, string leaderClusterTag, long term);
    internal ServerStore get_ServerStore();
    internal TestingStuff ForTestingPurposesOnly();
    public void AddToCluster(string clusterTag, string url);
    public Dictionary`2<string, ClusterNodeStatusReport> GetStats();
    public void RemoveFromCluster(string clusterTag);
    public sealed virtual void Dispose();
}
public class Raven.Server.ServerWide.Maintenance.ClusterMaintenanceWorker : object {
    private TcpConnectionOptions _tcp;
    private ServerStore _server;
    private CancellationToken _token;
    private CancellationTokenSource _cts;
    private Logger _logger;
    private string _name;
    public long CurrentTerm;
    public TimeSpan WorkerSamplePeriod;
    private LongRunningWork _collectingTask;
    public SupportedFeatures SupportedFeatures;
    private float _temporaryDirtyMemoryAllowedPercentage;
    private long _term;
    private string _leader;
    public ClusterMaintenanceWorker(TcpConnectionOptions tcp, CancellationToken externalToken, ServerStore serverStore, string leader, long term);
    public void Start();
    public void CollectDatabasesStatusReport();
    private void HeartbeatVersion41200(JsonOperationContext ctx, Dictionary`2<string, DatabaseStatusReport> nodeReport);
    private void HeartbeatVersion42000(ClusterOperationContext ctx, MaintenanceReport report);
    private Dictionary`2<string, DatabaseStatusReport> CollectDatabaseInformation(ClusterOperationContext ctx, Dictionary`2<string, DatabaseStatusReport> prevReport);
    private void FillClusterTransactionInfo(ClusterOperationContext ctx, DocumentDatabase dbInstance, DatabaseStatusReport report);
    private static void FillIndexInfo(Index index, QueryOperationContext context, DateTime now, DatabaseStatusReport report);
    private static Nullable`1<TimeSpan> GetLastQueryInfo(Index index, DateTime now);
    private static void FillDocumentsInfo(DatabaseStatusReport prevDatabaseReport, DocumentDatabase dbInstance, DatabaseStatusReport report, DocumentsOperationContext context, DocumentsStorage documentsStorage);
    private static void FillReplicationInfo(DocumentDatabase dbInstance, DatabaseStatusReport report);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Start>b__14_0(object _);
}
public class Raven.Server.ServerWide.Maintenance.ClusterNodeStatusReport : object {
    public Dictionary`2<string, DatabaseStatusReport> Report;
    public ServerReport ServerReport;
    public Dictionary`2<string, DateTime> LastGoodDatabaseStatus;
    public ReportStatus Status;
    public Exception Error;
    public DateTime UpdateDateTime;
    public DateTime LastSuccessfulUpdateDateTime;
    public ClusterNodeStatusReport(ServerReport serverReport, Dictionary`2<string, DatabaseStatusReport> report, ReportStatus reportStatus, Exception error, DateTime updateDateTime, ClusterNodeStatusReport lastSuccessfulReport);
    private void SetLastDbGoodTime(ClusterNodeStatusReport lastSuccessfulReport, string dbName);
    public sealed virtual DynamicJsonValue ToJson();
}
internal class Raven.Server.ServerWide.Maintenance.ClusterObserver : object {
    private Dictionary`2<long, ChosenNodeReason> _lastChosenNodeReasonPerTask;
    private LongRunningWork _observe;
    private DatabaseTopologyUpdater _databaseTopologyUpdater;
    private OrchestratorTopologyUpdater _orchestratorTopologyUpdater;
    private CancellationTokenSource _cts;
    private ClusterMaintenanceSupervisor _maintenance;
    private string _nodeTag;
    private RachisConsensus`1<ClusterStateMachine> _engine;
    private ClusterContextPool _contextPool;
    private ObserverLogger _observerLogger;
    private TimeSpan _supervisorSamplePeriod;
    private ServerStore _server;
    private TimeSpan _stabilizationTime;
    private long _stabilizationTimeMs;
    public SystemTime Time;
    public bool Suspended;
    private long _iteration;
    private long _term;
    private long _lastIndexCleanupTimeInTicks;
    internal long _lastTombstonesCleanupTimeInTicks;
    internal long _lastExpiredCompareExchangeCleanupTimeInTicks;
    private bool _hasMoreTombstones;
    private ServerNotificationCenter NotificationCenter { get; }
    internal ClusterMaintenanceSupervisor Maintenance { get; }
    public ClusterObserver(ServerStore server, ClusterMaintenanceSupervisor maintenance, RachisConsensus`1<ClusterStateMachine> engine, long term, ClusterContextPool contextPool, CancellationToken token);
    private List`1<ResponsibleNodeInfo> GetResponsibleNodesForBackupTasks(Leader currentLeader, RawDatabaseRecord rawRecord, string databaseName, DatabaseTopology topology, long observerIteration, ClusterOperationContext context);
    private ResponsibleNodeInfo GetResponsibleNodeInfo(string databaseName, PeriodicBackupConfiguration configuration, DatabaseTopology topology, long observerIteration, TimeSpan moveToNewResponsibleNodeGracePeriod, ClusterOperationContext context);
    private ResponsibleNodeForBackup GetResponsibleNodeForBackup(string databaseName, PeriodicBackupConfiguration configuration, DatabaseTopology topology, TimeSpan moveToNewResponsibleNodeGracePeriod, ClusterOperationContext context, string currentResponsibleNode);
    private void AddToDecisionLog(ResponsibleNodeForBackup nodeForBackup, long taskId, string database, long observerIteration);
    private ServerNotificationCenter get_NotificationCenter();
    internal ClusterMaintenanceSupervisor get_Maintenance();
    public ValueTuple`2<ClusterObserverLogEntry[], long> ReadDecisionsForDatabase();
    public void Run(CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.Maintenance.ClusterObserver/<AnalyzeLatestStats>d__33")]
private Task AnalyzeLatestStats(Dictionary`2<string, ClusterNodeStatusReport> newStats, Dictionary`2<string, ClusterNodeStatusReport> prevStats);
    private void UpdateReshardingStatus(ClusterOperationContext context, RawDatabaseRecord rawRecord, Dictionary`2<string, ClusterNodeStatusReport> newStats, List`1& confirmCommands);
    private bool SkipAnalyzingDatabaseGroup(DatabaseObservationState state, Leader currentLeader, DateTime now);
    private static string GetCommandId(Dictionary`2<string, long> dic);
    internal List`1<ValueTuple`2<UpdateDatabaseCommand, string>> GetUnusedAutoIndexes(MergedDatabaseObservationState mergedStates);
    internal CleanCompareExchangeTombstonesCommand GetCompareExchangeTombstonesToCleanup(string databaseName, MergedDatabaseObservationState mergedState, ClusterOperationContext context, CompareExchangeTombstonesCleanupState& cleanupState);
    private CompareExchangeTombstonesCleanupState GetMaxCompareExchangeTombstonesEtagToDelete(TransactionOperationContext`1<TRavenTransaction> context, string databaseName, MergedDatabaseObservationState mergedState, Int64& maxEtag);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.Maintenance.ClusterObserver/<RemoveExpiredCompareExchange>d__41")]
private Task`1<bool> RemoveExpiredCompareExchange(long nowTicks);
    private Nullable`1<long> CleanUpDatabaseValues(DatabaseObservationState state);
    private static bool AllDatabaseNodesHasReport(DatabaseObservationState state);
    private Task`1<ValueTuple`2<long, object>> UpdateTopology(UpdateTopologyCommand cmd);
    private Task`1<ValueTuple`2<long, object>> Delete(DeleteDatabaseCommand cmd);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__23_0(object _);
    [CompilerGeneratedAttribute]
private long <AnalyzeLatestStats>b__33_0(KeyValuePair`2<int, DatabaseObservationState> s);
}
public class Raven.Server.ServerWide.Maintenance.ClusterObserverDecisions : object {
    [CompilerGeneratedAttribute]
private string <LeaderNode>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Term>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Suspended>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Iteration>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ClusterObserverLogEntry> <ObserverLog>k__BackingField;
    public string LeaderNode { get; public set; }
    public long Term { get; public set; }
    public bool Suspended { get; public set; }
    public long Iteration { get; public set; }
    public List`1<ClusterObserverLogEntry> ObserverLog { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LeaderNode();
    [CompilerGeneratedAttribute]
public void set_LeaderNode(string value);
    [CompilerGeneratedAttribute]
public long get_Term();
    [CompilerGeneratedAttribute]
public void set_Term(long value);
    [CompilerGeneratedAttribute]
public bool get_Suspended();
    [CompilerGeneratedAttribute]
public void set_Suspended(bool value);
    [CompilerGeneratedAttribute]
public long get_Iteration();
    [CompilerGeneratedAttribute]
public void set_Iteration(long value);
    [CompilerGeneratedAttribute]
public List`1<ClusterObserverLogEntry> get_ObserverLog();
    [CompilerGeneratedAttribute]
public void set_ObserverLog(List`1<ClusterObserverLogEntry> value);
}
public class Raven.Server.ServerWide.Maintenance.ClusterObserverLogEntry : object {
    [CompilerGeneratedAttribute]
private DateTime <Date>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Iteration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public DateTime Date { get; public set; }
    public long Iteration { get; public set; }
    public string Database { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_Date();
    [CompilerGeneratedAttribute]
public void set_Date(DateTime value);
    [CompilerGeneratedAttribute]
public long get_Iteration();
    [CompilerGeneratedAttribute]
public void set_Iteration(long value);
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public virtual string ToString();
    public sealed virtual DynamicJsonValue ToJson();
}
[FlagsAttribute]
public enum Raven.Server.ServerWide.Maintenance.DatabaseStatus : Enum {
    public int value__;
    public static DatabaseStatus None;
    public static DatabaseStatus Loaded;
    public static DatabaseStatus Loading;
    public static DatabaseStatus Faulted;
    public static DatabaseStatus Unloaded;
    public static DatabaseStatus Shutdown;
    public static DatabaseStatus NoChange;
}
public class Raven.Server.ServerWide.Maintenance.DatabaseStatusReport : object {
    public string Name;
    public string NodeName;
    public string DatabaseChangeVector;
    public Dictionary`2<string, ObservedIndexStatus> LastIndexStats;
    public Dictionary`2<string, long> LastSentEtag;
    public Dictionary`2<int, BucketReport> ReportPerBucket;
    [CompilerGeneratedAttribute]
private long <LastCompareExchangeIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastClusterWideTransactionRaftIndex>k__BackingField;
    public long LastEtag;
    public long LastTombstoneEtag;
    public long NumberOfConflicts;
    public long NumberOfDocuments;
    public long LastCompletedClusterTransaction;
    public DatabaseStatus Status;
    public string Error;
    public Nullable`1<TimeSpan> UpTime;
    public long LastTransactionId;
    public long EnvironmentsHash;
    public long LastCompareExchangeIndex { get; public set; }
    public long LastClusterWideTransactionRaftIndex { get; public set; }
    [CompilerGeneratedAttribute]
public long get_LastCompareExchangeIndex();
    [CompilerGeneratedAttribute]
public void set_LastCompareExchangeIndex(long value);
    [CompilerGeneratedAttribute]
public long get_LastClusterWideTransactionRaftIndex();
    [CompilerGeneratedAttribute]
public void set_LastClusterWideTransactionRaftIndex(long value);
    public sealed virtual DynamicJsonValue ToJson();
}
internal class Raven.Server.ServerWide.Maintenance.DatabaseTopologyUpdater : object {
    private ServerStore _server;
    protected RachisConsensus`1<ClusterStateMachine> _engine;
    private bool _hardDeleteOnReplacement;
    private DateTime _observerStartTime;
    protected ObserverLogger _logger;
    private long _moveToRehabTimeMs;
    private long _maxChangeVectorDistance;
    private long _rotateGraceTimeMs;
    private TimeSpan _breakdownTimeout;
    private TimeSpan _supervisorSamplePeriod;
    private static string ThingsToCheck;
    public DatabaseTopologyUpdater(ServerStore server, RachisConsensus`1<ClusterStateMachine> engine, ClusterConfiguration clusterConfiguration, DateTime clusterObserverStartTime, ObserverLogger logger);
    public string Update(ClusterOperationContext context, DatabaseObservationState state, List`1& deletions);
    protected virtual ValueTuple`2<bool, string> TryPromote(ClusterOperationContext context, DatabaseObservationState state, string promotable, ClusterNodeStatusReport _);
    private bool CheckMembersDistance(DatabaseObservationState state, String& reason);
    private bool ShouldGiveMoreTimeBeforeMovingToRehab(DateTime lastSuccessfulUpdate, Nullable`1<TimeSpan> databaseUpTime);
    private bool ShouldGiveMoreTimeBeforeRotating(DateTime lastSuccessfulUpdate, Nullable`1<TimeSpan> databaseUpTime);
    private bool ShouldGiveMoreGrace(DateTime lastSuccessfulUpdate, Nullable`1<TimeSpan> databaseUpTime, long graceMs);
    private int GetNumberOfRespondingNodes(DatabaseObservationState state);
    private bool TryMoveToRehab(string dbName, DatabaseTopology topology, Dictionary`2<string, ClusterNodeStatusReport> current, string member, long iteration);
    private DatabasePromotionStatus GetStatus(ClusterNodeStatusReport nodeStats);
    private void MoveNodeToRehab(DatabaseTopology topology, string member, string reason, DatabasePromotionStatus promotionStatus);
    protected bool TryGetMentorNode(string dbName, DatabaseTopology topology, ClusterTopology clusterTopology, string promotable, String& mentorNode);
    private ValueTuple`2<bool, string> TryPromote(ClusterOperationContext context, DatabaseObservationState state, string mentorNode, string promotable);
    protected virtual void RemoveOtherNodesIfNeeded(DatabaseObservationState state, List`1& deletions);
    private static List`1<string> GetPendingDeleteNodes(DatabaseObservationState state);
    private DatabaseHealth FailedDatabaseInstanceOrNode(string node, DatabaseObservationState state, ClusterNodeStatusReport& nodeStats);
    private DatabaseHealth CheckNodeHealth(string node, ClusterTopology clusterTopology, Dictionary`2<string, ClusterNodeStatusReport> current, ClusterNodeStatusReport& nodeStats);
    private bool TryFindFitNode(string badNode, DatabaseObservationState state, DatabaseTopology topology, ClusterTopology clusterTopology, Dictionary`2<string, ClusterNodeStatusReport> current, string database, String& bestNode);
    private string FindMostUpToDateNode(List`1<string> nodes, string database, Dictionary`2<string, ClusterNodeStatusReport> current);
    private static bool CheckIndexProgress(long lastPrevEtag, Dictionary`2<string, ObservedIndexStatus> previous, Dictionary`2<string, ObservedIndexStatus> current, Dictionary`2<string, ObservedIndexStatus> mentor, String& reason);
    private void RaiseNoLivingNodesAlert(string alertMsg, string dbName, long iteration);
    private void RaiseNodeNotFoundAlert(string alertMsg, string node, long iteration);
}
public class Raven.Server.ServerWide.Maintenance.MaintenanceReport : object {
    public ServerReport ServerReport;
    public Dictionary`2<string, DatabaseStatusReport> DatabasesReport;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.ServerWide.Maintenance.ObserverLogger : object {
    private Logger _logger;
    private BlockingCollection`1<ClusterObserverLogEntry> _decisionsLog;
    private Dictionary`2<string, long> _lastLogs;
    public BlockingCollection`1<ClusterObserverLogEntry> DecisionsLog { get; }
    public ObserverLogger(string nodeTag);
    public BlockingCollection`1<ClusterObserverLogEntry> get_DecisionsLog();
    public void Log(string message, long iteration, Exception e, string database);
    public void AddToDecisionLog(string database, string updateReason, long iteration, Exception e);
    public void AddToDecisionLog(string database, string updateReason, long iteration);
}
public class Raven.Server.ServerWide.Maintenance.ServerReport : object {
    public Nullable`1<bool> OutOfCpuCredits;
    public Nullable`1<bool> EarlyOutOfMemory;
    public Nullable`1<bool> HighDirtyMemory;
    public Nullable`1<long> LastCommittedIndex;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.ServerWide.Maintenance.Sharding.BucketReport : object {
    public long Size;
    public long NumberOfDocuments;
    public DateTime LastAccess;
    public string LastChangeVector;
    public sealed virtual DynamicJsonValue ToJson();
}
public static class Raven.Server.ServerWide.Maintenance.Sharding.BucketsMigrator : object {
    public static bool NeedBalanceForDatabase(DatabaseRecord record, Dictionary`2<int, ShardReport> shards, MigrationPolicy policy, MoveStrategy moveStrategy, ShardMigrationResult& result);
    public static bool EdgeMove(DatabaseRecord record, Dictionary`2<int, ShardReport> shards, MigrationPolicy policy, ShardMigrationResult& result);
    public static bool NaiveMove(DatabaseRecord record, Dictionary`2<int, ShardReport> shards, MigrationPolicy policy, ShardMigrationResult& result);
    [CompilerGeneratedAttribute]
internal static void <EdgeMove>g__CheckBucket|2_0(int bucket, int neighborShard, <>c__DisplayClass2_0& , <>c__DisplayClass2_1& );
}
public class Raven.Server.ServerWide.Maintenance.Sharding.MigrationPolicy : object {
    public static MigrationPolicy Default;
    public static MigrationPolicy Min;
    public Nullable`1<double> PercentageThreshold;
    public Nullable`1<long> SizeThreshold;
    private static MigrationPolicy();
}
internal class Raven.Server.ServerWide.Maintenance.Sharding.OrchestratorTopologyUpdater : DatabaseTopologyUpdater {
    public OrchestratorTopologyUpdater(ServerStore server, RachisConsensus`1<ClusterStateMachine> engine, ClusterConfiguration clusterConfiguration, DateTime clusterObserverStartTime, ObserverLogger logger);
    protected virtual ValueTuple`2<bool, string> TryPromote(ClusterOperationContext context, DatabaseObservationState state, string promotable, ClusterNodeStatusReport nodeStats);
    protected virtual void RemoveOtherNodesIfNeeded(DatabaseObservationState state, List`1& deletions);
}
public class Raven.Server.ServerWide.Maintenance.Sharding.ShardMigrationResult : object {
    public string Database;
    public string RaftId;
    public int SourceShard;
    public int DestinationShard;
    public int Bucket;
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Raven.Server.ServerWide.Maintenance.Sharding.ShardNumber : ValueType {
    private int _value;
    public ShardNumber(int value);
    public static ShardNumber op_Implicit(int value);
    public static int op_Implicit(ShardNumber value);
    public virtual string ToString();
}
public class Raven.Server.ServerWide.Maintenance.Sharding.ShardReport : object {
    public ShardNumber Shard;
    public Dictionary`2<int, BucketReport> ReportPerBucket;
    public long TotalSize { get; }
    public long get_TotalSize();
}
public class Raven.Server.ServerWide.Memory.MemoryUsageGuard : object {
    public static bool TryIncreasingMemoryUsageForThread(ThreadStats threadStats, Size& currentMaximumAllowedMemory, Size currentlyInUse, bool isRunningOn32Bits, ServerMetricCacher metricCacher, Logger logger, ProcessMemoryUsage& currentUsage);
    public static bool CanIncreaseMemoryUsageForThread();
    private static ProcessMemoryUsage GetProcessMemoryUsage(MemoryInfoResult memoryInfo);
    private static Size GetTotalCurrentlyAllocatedForProcessing();
}
public class Raven.Server.ServerWide.Memory.ProcessMemoryUsage : object {
    public long WorkingSet;
    public long PrivateMemory;
    public ProcessMemoryUsage(long workingSet, long privateMemory);
}
public class Raven.Server.ServerWide.OperationCancelToken : object {
    public static OperationCancelToken None;
    private CancellationTokenSource _cts;
    private bool _disposed;
    private Stopwatch _sw;
    private TimeSpan _cancelAfter;
    public CancellationToken Token;
    public OperationCancelToken(TimeSpan cancelAfter, CancellationToken token);
    public OperationCancelToken(TimeSpan cancelAfter, CancellationToken token1, CancellationToken token2);
    public OperationCancelToken(TimeSpan cancelAfter, CancellationToken token1, CancellationToken token2, CancellationToken token3);
    public OperationCancelToken(CancellationToken token);
    public OperationCancelToken(CancellationToken token1, CancellationToken token2);
    public OperationCancelToken(CancellationToken token1, CancellationToken token2, CancellationToken token3);
    private static OperationCancelToken();
    public void ThrowIfCancellationRequested();
    public void Delay();
    public void Cancel();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void DisposeInternal();
    private static void ValidateCancelAfter(TimeSpan cancelAfter);
}
public class Raven.Server.ServerWide.RachisLogIndexNotifications : AbstractRaftIndexNotifications`1<RecentLogIndexNotification> {
    public Logger Log;
    private ConcurrentDictionary`2<long, TaskCompletionSource`1<object>> _tasksDictionary;
    private SingleUseFlag _isDisposed;
    public RachisLogIndexNotifications(CancellationToken token);
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.RachisLogIndexNotifications/<WaitForTaskCompletion>d__5")]
public virtual Task`1<bool> WaitForTaskCompletion(long index, Lazy`1<Task> waitingTask);
    private void SetTaskCompleted(long index, Exception e);
    public virtual void NotifyListenersAbout(long index, Exception e);
    public void AddTask(long index);
    [CompilerGeneratedAttribute]
private void <SetTaskCompleted>g__LogFailureToSetTaskResult|6_0(<>c__DisplayClass6_0& );
}
public class Raven.Server.ServerWide.RaftIndexNotification : object {
    public long Index;
    public Exception Exception;
    public virtual string ToString();
}
public class Raven.Server.ServerWide.RavenTransaction : object {
    private static Logger Logger;
    public Transaction InnerTransaction;
    public bool Disposed;
    public RavenTransaction(Transaction transaction);
    private static RavenTransaction();
    public virtual void BeforeCommit();
    public void Commit();
    public void EndAsyncCommit();
    public virtual void Dispose();
    protected virtual void RaiseNotifications();
    protected virtual bool ShouldRaiseNotifications();
    [DoesNotReturnAttribute]
protected static void ThrowInvalidTransactionUsage();
    protected virtual void AfterCommit();
}
public class Raven.Server.ServerWide.RawDatabaseRecord : object {
    private BlittableJsonReaderObject _record;
    private JsonOperationContext _context;
    private DatabaseRecord _materializedRecord;
    private Nullable`1<bool> _isDisabled;
    private Nullable`1<bool> _isEncrypted;
    private Nullable`1<long> _etagForBackup;
    private string _databaseName;
    private RawShardingConfiguration _sharding;
    private DatabaseTopology _topology;
    private Nullable`1<bool> _isSharded;
    private Nullable`1<DatabaseStateStatus> _databaseState;
    private Nullable`1<DatabaseLockMode> _lockMode;
    private StudioConfiguration _studioConfiguration;
    private TimeSeriesConfiguration _timeSeriesConfiguration;
    private RevisionsConfiguration _revisionsConfiguration;
    private RevisionsCollectionConfiguration _revisionsForConflictsConfiguration;
    private DocumentsCompressionConfiguration _documentsCompressionConfiguration;
    private ConflictSolver _conflictSolverConfiguration;
    private ExpirationConfiguration _expirationConfiguration;
    private RefreshConfiguration _refreshConfiguration;
    private DataArchivalConfiguration _dataArchivalConfiguration;
    private List`1<ExternalReplication> _externalReplications;
    private List`1<PullReplicationDefinition> _hubPullReplications;
    private List`1<PullReplicationAsSink> _sinkPullReplications;
    private List`1<long> _periodicBackupsTaskIds;
    private List`1<PeriodicBackupConfiguration> _periodicBackups;
    private List`1<RavenEtlConfiguration> _ravenEtls;
    private List`1<SqlEtlConfiguration> _sqlEtls;
    private List`1<OlapEtlConfiguration> _olapEtls;
    private List`1<ElasticSearchEtlConfiguration> _elasticSearchEtls;
    private List`1<QueueEtlConfiguration> _queueEtls;
    private List`1<QueueSinkConfiguration> _queueSinks;
    private Dictionary`2<string, string> _settings;
    private Dictionary`2<string, DeletionInProgressStatus> _deletionInProgress;
    private Dictionary`2<string, RollingIndex> _rollingIndexes;
    private Dictionary`2<string, List`1<IndexHistoryEntry>> _indexesHistory;
    private Nullable`1<int> _countOfAutoIndexes;
    private Nullable`1<int> _countOfStaticIndexes;
    private Dictionary`2<string, IndexDefinition> _indexes;
    private Dictionary`2<string, AutoIndexDefinition> _autoIndexes;
    private Dictionary`2<string, SorterDefinition> _sorters;
    private Nullable`1<int> _countOfSorters;
    private Dictionary`2<string, AnalyzerDefinition> _analyzers;
    private Nullable`1<int> _countOfAnalyzers;
    private Dictionary`2<string, SqlConnectionString> _sqlConnectionStrings;
    private Dictionary`2<string, ElasticSearchConnectionString> _elasticSearchConnectionStrings;
    private Dictionary`2<string, RavenConnectionString> _ravenConnectionStrings;
    private Dictionary`2<string, OlapConnectionString> _olapConnectionStrings;
    private Dictionary`2<string, QueueConnectionString> _queueConnectionStrings;
    public BlittableJsonReaderObject Raw { get; }
    public bool IsDisabled { get; }
    public bool IsEncrypted { get; }
    public long EtagForBackup { get; }
    public string DatabaseName { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`2<string, DatabaseTopology>> Topologies { get; }
    public RawShardingConfiguration Sharding { get; }
    public DatabaseTopology Topology { get; }
    public bool IsSharded { get; }
    public DatabaseStateStatus DatabaseState { get; }
    public DatabaseLockMode LockMode { get; }
    public StudioConfiguration StudioConfiguration { get; }
    public TimeSeriesConfiguration TimeSeriesConfiguration { get; }
    public RevisionsConfiguration RevisionsConfiguration { get; }
    public RevisionsCollectionConfiguration RevisionsForConflicts { get; }
    public DocumentsCompressionConfiguration DocumentsCompressionConfiguration { get; }
    public ConflictSolver ConflictSolverConfiguration { get; }
    public ExpirationConfiguration ExpirationConfiguration { get; }
    public RefreshConfiguration RefreshConfiguration { get; }
    public DataArchivalConfiguration DataArchivalConfiguration { get; }
    public List`1<ExternalReplication> ExternalReplications { get; }
    public List`1<PullReplicationDefinition> HubPullReplications { get; }
    public List`1<PullReplicationAsSink> SinkPullReplications { get; }
    public List`1<long> PeriodicBackupsTaskIds { get; }
    public List`1<PeriodicBackupConfiguration> PeriodicBackups { get; }
    public List`1<RavenEtlConfiguration> RavenEtls { get; }
    public List`1<SqlEtlConfiguration> SqlEtls { get; }
    public List`1<OlapEtlConfiguration> OlapEtls { get; }
    public List`1<ElasticSearchEtlConfiguration> ElasticSearchEtls { get; }
    public List`1<QueueEtlConfiguration> QueueEtls { get; }
    public List`1<QueueSinkConfiguration> QueueSinks { get; }
    public Dictionary`2<string, string> Settings { get; }
    public Dictionary`2<string, DeletionInProgressStatus> DeletionInProgress { get; }
    public Dictionary`2<string, RollingIndex> RollingIndexes { get; }
    public Dictionary`2<string, List`1<IndexHistoryEntry>> IndexesHistory { get; }
    public int CountOfAutoIndexes { get; }
    public int CountOfStaticIndexes { get; }
    public int CountOfIndexes { get; }
    public Dictionary`2<string, IndexDefinition> Indexes { get; }
    public Dictionary`2<string, AutoIndexDefinition> AutoIndexes { get; }
    public Dictionary`2<string, SorterDefinition> Sorters { get; }
    public int CountOfSorters { get; }
    public Dictionary`2<string, AnalyzerDefinition> Analyzers { get; }
    public int CountOfAnalyzers { get; }
    public Dictionary`2<string, SqlConnectionString> SqlConnectionStrings { get; }
    public Dictionary`2<string, ElasticSearchConnectionString> ElasticSearchConnectionStrings { get; }
    public Dictionary`2<string, RavenConnectionString> RavenConnectionStrings { get; }
    public Dictionary`2<string, OlapConnectionString> OlapConnectionString { get; }
    public Dictionary`2<string, QueueConnectionString> QueueConnectionStrings { get; }
    public DatabaseRecord MaterializedRecord { get; }
    public RawDatabaseRecord(JsonOperationContext context, BlittableJsonReaderObject record);
    private RawDatabaseRecord(DatabaseRecord record);
    public BlittableJsonReaderObject get_Raw();
    public bool get_IsDisabled();
    public bool get_IsEncrypted();
    public long get_EtagForBackup();
    public string get_DatabaseName();
    public IEnumerable`1<ValueTuple`2<string, DatabaseTopology>> get_Topologies();
    public RawShardingConfiguration get_Sharding();
    public DatabaseTopology get_Topology();
    public bool get_IsSharded();
    public RawDatabaseRecord GetShardedDatabaseRecord(int shardNumber);
    public IEnumerable`1<RawDatabaseRecord> AsShardsOrNormal(string nodeTag);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.RawDatabaseRecord/<GetShardedDatabaseRecords>d__32")]
public IEnumerable`1<RawDatabaseRecord> GetShardedDatabaseRecords(string nodeTag);
    public bool EntireDatabasePendingDeletion();
    public string GetClusterTransactionId();
    public DatabaseStateStatus get_DatabaseState();
    public DatabaseLockMode get_LockMode();
    public StudioConfiguration get_StudioConfiguration();
    public TimeSeriesConfiguration get_TimeSeriesConfiguration();
    public RevisionsConfiguration get_RevisionsConfiguration();
    public RevisionsCollectionConfiguration get_RevisionsForConflicts();
    public DocumentsCompressionConfiguration get_DocumentsCompressionConfiguration();
    public ConflictSolver get_ConflictSolverConfiguration();
    public ExpirationConfiguration get_ExpirationConfiguration();
    public RefreshConfiguration get_RefreshConfiguration();
    public DataArchivalConfiguration get_DataArchivalConfiguration();
    public List`1<ExternalReplication> get_ExternalReplications();
    public List`1<PullReplicationDefinition> get_HubPullReplications();
    public List`1<PullReplicationAsSink> get_SinkPullReplications();
    public PullReplicationDefinition GetHubPullReplicationByName(string name);
    public PullReplicationDefinition GetHubPullReplicationById(Int64& key);
    public bool HubPullReplicationDefinitionExist();
    public List`1<long> get_PeriodicBackupsTaskIds();
    public List`1<PeriodicBackupConfiguration> get_PeriodicBackups();
    public PeriodicBackupConfiguration GetPeriodicBackupConfiguration(long taskId);
    public List`1<RavenEtlConfiguration> get_RavenEtls();
    public List`1<SqlEtlConfiguration> get_SqlEtls();
    public List`1<OlapEtlConfiguration> get_OlapEtls();
    public List`1<ElasticSearchEtlConfiguration> get_ElasticSearchEtls();
    public List`1<QueueEtlConfiguration> get_QueueEtls();
    public List`1<QueueSinkConfiguration> get_QueueSinks();
    public Dictionary`2<string, string> get_Settings();
    public Dictionary`2<string, DeletionInProgressStatus> get_DeletionInProgress();
    public Dictionary`2<string, RollingIndex> get_RollingIndexes();
    public Dictionary`2<string, List`1<IndexHistoryEntry>> get_IndexesHistory();
    public int get_CountOfAutoIndexes();
    public int get_CountOfStaticIndexes();
    public int get_CountOfIndexes();
    public Dictionary`2<string, IndexDefinition> get_Indexes();
    public Dictionary`2<string, AutoIndexDefinition> get_AutoIndexes();
    public Dictionary`2<string, SorterDefinition> get_Sorters();
    public int get_CountOfSorters();
    public Dictionary`2<string, AnalyzerDefinition> get_Analyzers();
    public int get_CountOfAnalyzers();
    public Dictionary`2<string, SqlConnectionString> get_SqlConnectionStrings();
    public Dictionary`2<string, ElasticSearchConnectionString> get_ElasticSearchConnectionStrings();
    public Dictionary`2<string, RavenConnectionString> get_RavenConnectionStrings();
    public Dictionary`2<string, OlapConnectionString> get_OlapConnectionString();
    public Dictionary`2<string, QueueConnectionString> get_QueueConnectionStrings();
    internal bool IsShardBeingDeletedOnAnyNode(int shardNumber);
    public sealed virtual void Dispose();
    public DatabaseRecord get_MaterializedRecord();
    public static DatabaseRecord op_Implicit(RawDatabaseRecord raw);
    public static RawDatabaseRecord op_Implicit(DatabaseRecord record);
}
[ExtensionAttribute]
public static class Raven.Server.ServerWide.RawDatabaseRecordExtensions : object {
    [ExtensionAttribute]
public static DatabaseTopology TopologyForSubscriptions(RawDatabaseRecord record);
}
public class Raven.Server.ServerWide.RecentLogIndexNotification : RaftIndexNotification {
    public string Type;
    public TimeSpan ExecutionTime;
    public Nullable`1<int> LeaderErrorCount;
    public Nullable`1<long> Term;
    public Nullable`1<long> LeaderShipDuration;
    public virtual string ToString();
}
public class Raven.Server.ServerWide.RejectPutClusterCommandException : Exception {
    public RejectPutClusterCommandException(string message);
    public RejectPutClusterCommandException(string message, Exception innerException);
    [DoesNotReturnAttribute]
public static void Throw(string msg);
}
public class Raven.Server.ServerWide.RejectSendToFollowerException : Exception {
    public RejectSendToFollowerException(string message);
    public RejectSendToFollowerException(string message, Exception innerException);
    [DoesNotReturnAttribute]
public static void Throw(string msg);
}
public enum Raven.Server.ServerWide.ResourceType : Enum {
    public int value__;
    public static ResourceType Server;
    public static ResourceType Database;
}
public class Raven.Server.ServerWide.SecretProtection : object {
    public static Byte[] EncryptionContext;
    private static Logger Logger;
    private Lazy`1<Byte[]> _serverMasterKey;
    private SecurityConfiguration _config;
    private static int MaxDeveloperCertificateValidityDurationInMonths;
    public SecretProtection(SecurityConfiguration config);
    private static SecretProtection();
    private Byte[] LoadMasterKey();
    public Byte[] Protect(Byte[] secret);
    private static Byte[] EncryptProtectedData(Byte[] secret, Byte[] key);
    public Byte[] Unprotect(Byte[] secret);
    private static Byte[] DecryptProtectedData(Byte[] secret, Byte[] key);
    private static void ValidateExpiration(string source, X509Certificate2 loadedCertificate, LicenseType licenseType, bool throwOnExpired, SetupProgressAndResult progress);
    public static CertificateHolder ValidateCertificateAndCreateCertificateHolder(string source, X509Certificate2 loadedCertificate, Byte[] rawBytes, string password, LicenseType licenseType, bool validateCertKeyUsages, SetupProgressAndResult progress);
    public static void ValidateKeyUsages(string source, X509Certificate2 loadedCertificate, bool validateKeyUsages, SetupProgressAndResult progress);
    public CertificateHolder LoadCertificateWithExecutable(string executable, string args, LicenseType licenseType, bool certificateValidationKeyUsages);
    public void NotifyExecutableOfCertificateChange(string executable, string args, string newCertificateBase64);
    private Byte[] LoadMasterKeyWithExecutable();
    public static void AddCertificateChainToTheUserCertificateAuthorityStoreAndCleanExpiredCerts(X509Certificate2 loadedCertificate, Byte[] rawBytes, string password, SetupProgressAndResult progress);
    public CertificateHolder LoadCertificateFromPath(string path, string password, LicenseType licenseType, bool certificateValidationKeyUsages);
    internal static void ValidatePrivateKey(string source, string certificatePassword, Byte[] rawData, AsymmetricKeyEntry& pk, SetupProgressAndResult progress);
    internal static void ValidateExpiration(string source, LicenseType currentLicenseType, LicenseType licenseType, X509Certificate2 certificate, DateTime certificateNotBefore, DateTime certificateNotAfter);
    public Byte[] LoadMasterKeyFromPath();
    [CompilerGeneratedAttribute]
internal static string <LoadCertificateWithExecutable>g__GetStdError|14_0(<>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static string <NotifyExecutableOfCertificateChange>g__GetStdError|15_0(<>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
internal static string <LoadMasterKeyWithExecutable>g__GetStdError|16_0(<>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
internal static IEnumerable <ValidatePrivateKey>g__GetAliases|19_0(string certificatePassword, Byte[] rawData, Func`2& getKey);
}
public class Raven.Server.ServerWide.ServerMetricCacher : MetricCacher {
    private SmapsReader _smapsReader;
    private RavenServer _server;
    public static int DefaultCpuRefreshRateInMs;
    public ServerMetricCacher(RavenServer server);
    public void Initialize();
    private object CalculateMemoryInfo();
    private object CalculateMemoryInfoExtended();
    private object CalculateDiskSpaceInfo();
    private GCMemoryInfo CalculateGcMemoryInfo(GCKind gcKind);
    private static object CalculateMemInfo();
    private static object CalculateMaxServerLimits();
    private static object CalculateCurrentServerLimits();
    [CompilerGeneratedAttribute]
private object <Initialize>b__4_0();
    [CompilerGeneratedAttribute]
private object <Initialize>b__4_1();
    [CompilerGeneratedAttribute]
private object <Initialize>b__4_2();
    [CompilerGeneratedAttribute]
private object <Initialize>b__4_3();
}
public class Raven.Server.ServerWide.ServerStatistics : object {
    private static TimeSpan PersistFrequency;
    private DateTime _lastPersist;
    [JsonDeserializationIgnoreAttribute]
public DateTime StartUpTime;
    public Nullable`1<DateTime> LastRequestTime;
    public Nullable`1<DateTime> LastAuthorizedNonClusterAdminRequestTime;
    public Dictionary`2<string, DateTime> LastRequestTimePerCertificate;
    [JsonDeserializationIgnoreAttribute]
public TimeSpan UpTime { get; }
    private static ServerStatistics();
    public TimeSpan get_UpTime();
    internal void UpdateLastCertificateRequestTime(string certificateThumbprint, DateTime requestTime);
    internal void RemoveLastAuthorizedCertificateRequestTime(List`1<string> certificateThumbprints);
    public void WriteTo(TWriter writer);
    internal void Load(TransactionContextPool contextPool, Logger logger);
    internal void Persist(TransactionContextPool contextPool, Logger logger);
    internal void MaybePersist(TransactionContextPool contextPool, Logger logger);
}
public class Raven.Server.ServerWide.ServerStore : object {
    private static string ResourceName;
    private static Logger Logger;
    public static string LicenseStorageKey;
    public static string LicenseLimitsStorageKey;
    private CancellationTokenSource _shutdownNotification;
    private FileLocker _fileLocker;
    internal StorageEnvironment _env;
    internal SizeLimitedConcurrentDictionary`2<string, ConcurrentQueue`1<DateTime>> ClientCreationRate;
    private NotificationsStorage _notificationsStorage;
    private OperationsStorage _operationsStorage;
    public ConcurrentDictionary`2<string, Dictionary`2<string, long>> IdleDatabases;
    private RequestExecutor _leaderRequestExecutor;
    internal long _lastClusterTopologyIndex;
    public RavenConfiguration Configuration;
    private RavenServer _server;
    public DatabasesLandlord DatabasesLandlord;
    public ServerNotificationCenter NotificationCenter;
    public ThreadsInfoNotifications ThreadsInfoNotifications;
    public LicenseManager LicenseManager;
    public FeedbackSender FeedbackSender;
    public StorageSpaceMonitor StorageSpaceMonitor;
    public ServerLimitsMonitor ServerLimitsMonitor;
    public SecretProtection Secrets;
    public AsyncManualResetEvent InitializationCompleted;
    public GlobalIndexingScratchSpaceMonitor GlobalIndexingScratchSpaceMonitor;
    public bool Initialized;
    private TimeSpan _frequencyToCheckForIdleDatabases;
    private Lazy`1<ClusterRequestExecutor> _clusterRequestExecutor;
    [CompilerGeneratedAttribute]
private long <LastClientConfigurationIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBackupsCounter <ConcurrentBackupsCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerOperations <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private CatastrophicFailureNotification <CatastrophicFailureNotification>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastCertificateUpdateTime>k__BackingField;
    internal FifoSemaphore ServerWideConcurrentlyRunningIndexesLock;
    [CompilerGeneratedAttribute]
private DatabaseInfoCache <DatabaseInfoCache>k__BackingField;
    public TransactionContextPool ContextPool;
    [CompilerGeneratedAttribute]
private IoChangesNotifications <IoChanges>k__BackingField;
    private Timer _timer;
    private RachisConsensus`1<ClusterStateMachine> _engine;
    private bool _disposed;
    private ShardingStore _sharding;
    public ClusterMaintenanceSupervisor ClusterMaintenanceSupervisor;
    private int _serverCertificateChanged;
    private LongRunningWork _clusterMaintenanceSetupTask;
    private LongRunningWork _updateTopologyChangeNotification;
    public bool ValidateFixedPort;
    [CompilerGeneratedAttribute]
private ClusterObserver <Observer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFixedPort>k__BackingField;
    public FeatureGuardian FeatureGuardian;
    private MultipleUseFlag _notify;
    public PublishedServerUrls PublishedServerUrls;
    public char DefaultIdentityPartsSeparator;
    internal TestingStuff ForTestingPurposes;
    public MemoryCache QueryClauseCache;
    public CancellationToken ServerShutdown { get; }
    public long LastClientConfigurationIndex { get; private set; }
    public ConcurrentBackupsCounter ConcurrentBackupsCounter { get; private set; }
    public ServerOperations Operations { get; }
    public CatastrophicFailureNotification CatastrophicFailureNotification { get; }
    public Nullable`1<DateTime> LastCertificateUpdateTime { get; private set; }
    internal ClusterRequestExecutor ClusterRequestExecutor { get; }
    private bool IsClusterRequestExecutorCreated { get; }
    public RavenServer Server { get; }
    public DatabaseInfoCache DatabaseInfoCache { get; public set; }
    public IoChangesNotifications IoChanges { get; private set; }
    public long LastRaftCommitIndex { get; }
    public ClusterStateMachine Cluster { get; }
    public string LeaderTag { get; }
    public RachisState CurrentRachisState { get; }
    public string NodeTag { get; }
    public bool Disposed { get; }
    public RachisConsensus`1<ClusterStateMachine> Engine { get; }
    public ShardingStore Sharding { get; }
    internal ClusterObserver Observer { get; internal set; }
    public bool HasFixedPort { get; internal set; }
    public Guid ServerId { get; }
    public ServerStore(RavenConfiguration configuration, RavenServer server);
    private static ServerStore();
    public CancellationToken get_ServerShutdown();
    [CompilerGeneratedAttribute]
public long get_LastClientConfigurationIndex();
    [CompilerGeneratedAttribute]
private void set_LastClientConfigurationIndex(long value);
    [CompilerGeneratedAttribute]
public ConcurrentBackupsCounter get_ConcurrentBackupsCounter();
    [CompilerGeneratedAttribute]
private void set_ConcurrentBackupsCounter(ConcurrentBackupsCounter value);
    [CompilerGeneratedAttribute]
public ServerOperations get_Operations();
    [CompilerGeneratedAttribute]
public CatastrophicFailureNotification get_CatastrophicFailureNotification();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastCertificateUpdateTime();
    [CompilerGeneratedAttribute]
private void set_LastCertificateUpdateTime(Nullable`1<DateTime> value);
    internal ClusterRequestExecutor get_ClusterRequestExecutor();
    private bool get_IsClusterRequestExecutorCreated();
    private Lazy`1<ClusterRequestExecutor> CreateClusterRequestExecutor();
    private void OnServerCertificateChanged(object sender, EventArgs e);
    public RavenServer get_Server();
    [CompilerGeneratedAttribute]
public DatabaseInfoCache get_DatabaseInfoCache();
    [CompilerGeneratedAttribute]
public void set_DatabaseInfoCache(DatabaseInfoCache value);
    [CompilerGeneratedAttribute]
public IoChangesNotifications get_IoChanges();
    [CompilerGeneratedAttribute]
private void set_IoChanges(IoChangesNotifications value);
    public long get_LastRaftCommitIndex();
    public ClusterStateMachine get_Cluster();
    public string get_LeaderTag();
    public RachisState get_CurrentRachisState();
    public string get_NodeTag();
    public bool get_Disposed();
    public RachisConsensus`1<ClusterStateMachine> get_Engine();
    public ShardingStore get_Sharding();
    public Dictionary`2<string, ClusterNodeStatusReport> ClusterStats();
    internal LicenseType GetLicenseType();
    public void UpdateTopologyChangeNotification();
    private void WaitForLeaderChangeTaskToComplete(Task leaderChangedTask);
    private static bool IsOperationCanceled(Exception e);
    private int ReconnectionBackoff(int delay);
    [CompilerGeneratedAttribute]
internal ClusterObserver get_Observer();
    [CompilerGeneratedAttribute]
internal void set_Observer(ClusterObserver value);
    public void ClusterMaintenanceSetupTask();
    public ClusterTopology GetClusterTopology();
    public bool ShouldUpdateTopology(long newRecordIndex, long currentIndex, String& url, ClusterTopology clusterTopology);
    public bool HasTopologyChanged(long topologyEtag);
    public ClusterTopology GetClusterTopology(TransactionOperationContext`1<TTransaction> context);
    [CompilerGeneratedAttribute]
public bool get_HasFixedPort();
    [CompilerGeneratedAttribute]
internal void set_HasFixedPort(bool value);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<AddNodeToClusterAsync>d__112")]
public Task AddNodeToClusterAsync(string nodeUrl, string nodeTag, bool validateNotInTopology, bool asWatcher, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<RemoveFromClusterAsync>d__113")]
public Task RemoveFromClusterAsync(string nodeTag, CancellationToken token);
    public void RequestSnapshot();
    public void PreInitialize();
    public void Initialize();
    public void LoadDefaultIdentityPartsSeparator(ClientConfiguration clientConfiguration);
    private void LoadDefaultIdentityPartsSeparator(ClusterOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<PublishServerUrlAsync>d__119")]
private Task PublishServerUrlAsync();
    private void CheckSwapOrPageFileAndRaiseNotification();
    private void ConfigureAuditLog();
    private void AssertCanWriteToAuditLogDirectory();
    public void TriggerDatabases();
    private void OnStateChanged(object sender, StateTransition state);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<RefreshOutgoingTasksAsync>d__125")]
private Task RefreshOutgoingTasksAsync();
    public Dictionary`2<string, NodeStatus> GetNodesStatuses();
    public void NotifyAboutClusterTopologyAndConnectivityChanges();
    private void OnTopologyChangeInternal(ClusterTopology localClusterTopology, ClusterTopology leaderClusterTopology, ServerNode topologyNode, Dictionary`2<string, NodeStatus> status);
    private Task OnDatabaseChanged(string databaseName, long index, string type, ClusterDatabaseChangeType _, object state);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<OnValueChanged>d__131")]
private Task OnValueChanged(long index, string type);
    private void RescheduleTimerIfDatabaseIdle(string db, object state);
    private void RescheduleTimerIfDatabaseIdleOnUpdatedResponsibleNode(string db, object state);
    private void ConfirmCertificateReplacedValueChanged(long index, string type);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<InstallUpdatedCertificateValueChanged>d__136")]
private Task InstallUpdatedCertificateValueChanged(long index, string type);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<ConfirmCertificateReceiptValueChanged>d__137")]
private Task ConfirmCertificateReceiptValueChanged(long index, string type);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<GetSecretKeysNames>d__138")]
public IEnumerable`1<string> GetSecretKeysNames(TransactionOperationContext context);
    public void PutSecretKey(string base64, string name, bool overwrite);
    public void PutSecretKey(TransactionOperationContext context, string name, Byte[] secretKey, bool overwrite, bool cloneKey);
    public Byte[] GetSecretKey(TransactionOperationContext context, string name);
    public Byte[] GetSecretKey(string databaseName);
    public void DeleteSecretKey(string databaseName);
    public void DeleteSecretKey(TransactionOperationContext context, string name);
    public Task`1<ValueTuple`2<long, object>> DeleteDatabaseAsync(string db, bool hardDelete, String[] fromNodes, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> UpdateExternalReplication(string dbName, BlittableJsonReaderObject blittableJson, string raftRequestId, ExternalReplication& watcher);
    public Task`1<ValueTuple`2<long, object>> UpdatePullReplicationAsSink(string dbName, BlittableJsonReaderObject blittableJson, string raftRequestId, PullReplicationAsSink& pullReplicationAsSink);
    public Task`1<ValueTuple`2<long, object>> DeleteOngoingTask(long taskId, string taskName, OngoingTaskType taskType, string dbName, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> PromoteDatabaseNode(string dbName, string nodeTag, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> ModifyConflictSolverAsync(string dbName, ConflictSolver solver, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> PutValueInClusterAsync(PutValueCommand`1<T> cmd);
    public Task`1<ValueTuple`2<long, object>> ModifyDatabaseExpiration(TransactionOperationContext context, string databaseName, BlittableJsonReaderObject configurationJson, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> ModifyDatabaseDataArchival(TransactionOperationContext context, string databaseName, BlittableJsonReaderObject configurationJson, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> ModifyDocumentsCompression(TransactionOperationContext context, string databaseName, BlittableJsonReaderObject configurationJson, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> ModifyPostgreSqlConfiguration(TransactionOperationContext context, string databaseName, BlittableJsonReaderObject configurationJson, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> ModifyPostgreSqlConfiguration(TransactionOperationContext context, string databaseName, PostgreSqlConfiguration configuration, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> ModifyDatabaseRefresh(TransactionOperationContext context, string databaseName, BlittableJsonReaderObject configurationJson, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> ToggleDatabasesStateAsync(ToggleType toggleType, String[] databaseNames, bool disable, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> PutServerWideBackupConfigurationAsync(ServerWideBackupConfiguration configuration, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> PutServerWideExternalReplicationAsync(ServerWideExternalReplication configuration, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> DeleteServerWideTaskAsync(DeleteConfiguration configuration, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> ToggleServerWideTaskStateAsync(Parameters configuration, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<ModifyPeriodicBackup>d__163")]
public Task`1<ValueTuple`2<long, object>> ModifyPeriodicBackup(TransactionOperationContext context, string name, PeriodicBackupConfiguration configuration, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<AddEtl>d__164")]
public Task`1<ValueTuple`2<long, object>> AddEtl(TransactionOperationContext context, string databaseName, BlittableJsonReaderObject etlConfiguration, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<AddQueueSink>d__165")]
public Task`1<ValueTuple`2<long, object>> AddQueueSink(TransactionOperationContext context, string databaseName, BlittableJsonReaderObject queueSinkConfiguration, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<UpdateQueueSink>d__166")]
public Task`1<ValueTuple`2<long, object>> UpdateQueueSink(TransactionOperationContext context, string databaseName, long id, BlittableJsonReaderObject queueSinkConfiguration, string raftRequestId);
    [DoesNotReturnAttribute]
private void ThrowInvalidConfigurationIfNecessary(BlittableJsonReaderObject etlConfiguration, IReadOnlyCollection`1<string> errors);
    private void ThrowInvalidQueueSinkConfigurationIfNecessary(BlittableJsonReaderObject queueSinkConfiguration, IReadOnlyCollection`1<string> errors);
    private bool ValidateConnectionString(RawDatabaseRecord databaseRecord, string connectionStringName, EtlType etlType);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<UpdateEtl>d__170")]
public Task`1<ValueTuple`2<long, object>> UpdateEtl(TransactionOperationContext context, string databaseName, long id, BlittableJsonReaderObject etlConfiguration, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> RemoveEtlProcessState(TransactionOperationContext context, string databaseName, string configurationName, string transformationName, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> RemoveQueueSinkProcessState(TransactionOperationContext context, string databaseName, string configurationName, string scriptName, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> ModifyDatabaseRevisions(JsonOperationContext context, string name, BlittableJsonReaderObject configurationJson, string raftRequestId);
    public Task`1<ValueTuple`2<long, object>> ModifyRevisionsForConflicts(JsonOperationContext context, string name, BlittableJsonReaderObject configurationJson, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<PutConnectionString>d__175")]
public Task`1<ValueTuple`2<long, object>> PutConnectionString(TransactionOperationContext context, string databaseName, BlittableJsonReaderObject connectionString, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<RemoveConnectionString>d__176")]
public Task`1<ValueTuple`2<long, object>> RemoveConnectionString(string databaseName, string connectionStringName, string type, string raftRequestId);
    public Guid GetServerId();
    public Guid get_ServerId();
    public bool IsShutdownRequested();
    public sealed virtual void Dispose();
    public void IdleOperations(object state);
    public bool CanUnloadDatabase(StringSegment databaseName, DateTime lastRecentlyUsed, IdleDatabaseStatistics statistics, DocumentDatabase& database);
    private bool DatabaseNeedsToRunIdleOperations(DocumentDatabase database, DatabaseCleanupMode& mode);
    public void AssignNodesToDatabase(ClusterTopology clusterTopology, string name, bool encrypted, DatabaseTopology databaseTopology);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<WriteDatabaseRecordAsync>d__187")]
public Task`1<ValueTuple`2<long, object>> WriteDatabaseRecordAsync(string databaseName, DatabaseRecord record, Nullable`1<long> index, string raftRequestId, Dictionary`2<string, BlittableJsonReaderObject> databaseValues, bool isRestore, int replicationFactor);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<EnsureNotPassiveAsync>d__188")]
public Task EnsureNotPassiveAsync(string publicServerUrl, string nodeTag, bool skipLicenseActivation);
    public bool IsLeader();
    public bool IsPassive();
    public DynamicJsonArray GetClusterErrors();
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<GenerateClusterIdentityAsync>d__192")]
public Task`1<ValueTuple`3<long, string, long>> GenerateClusterIdentityAsync(string id, char identityPartsSeparator, string databaseName, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<UpdateClusterIdentityAsync>d__193")]
public Task`1<long> UpdateClusterIdentityAsync(string id, string databaseName, long newIdentity, bool force, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<GenerateClusterIdentitiesBatchAsync>d__194")]
public Task`1<List`1<long>> GenerateClusterIdentitiesBatchAsync(string databaseName, List`1<string> ids, string raftRequestId);
    public NodeInfo GetNodeInfo();
    public License LoadLicense();
    public License LoadLicense(TransactionContextPool contextPool);
    public LicenseLimits LoadLicenseLimits();
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<PutLicenseAsync>d__199")]
public Task PutLicenseAsync(License license, string raftRequestId, bool fromApi);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<PutNodeLicenseLimitsAsync>d__200")]
public Task PutNodeLicenseLimitsAsync(string nodeTag, DetailsPerNode detailsPerNode, LicenseStatus licenseStatus, string raftRequestId);
    public DatabaseTopology LoadDatabaseTopology(string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<SendToLeaderAsync>d__202")]
public Task`1<ValueTuple`2<long, object>> SendToLeaderAsync(CommandBase cmd, Nullable`1<CancellationToken> token);
    public RequestExecutor GetLeaderRequestExecutor(string leaderTag);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<WaitForExecutionOnSpecificNodeAsync>d__204")]
protected internal Task WaitForExecutionOnSpecificNodeAsync(JsonOperationContext context, string node, long index);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<WaitForExecutionOnRelevantNodesAsync>d__205")]
public Task WaitForExecutionOnRelevantNodesAsync(JsonOperationContext context, List`1<string> members, long index);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<WaitForRaftIndexOnNodeAndReturnIfExceptionAsync>d__206")]
private Task`1<Exception> WaitForRaftIndexOnNodeAndReturnIfExceptionAsync(RequestExecutor executor, string nodeTag, long index, JsonOperationContext context, CancellationToken token);
    internal ClusterRequestExecutor CreateNewClusterRequestExecutor(string leaderUrl);
    public Task WaitForTopology(TopologyModification state, CancellationToken token);
    public Task`1<bool> WaitForState(RachisState rachisState, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<ClusterAcceptNewConnectionAsync>d__210")]
public Task ClusterAcceptNewConnectionAsync(TcpConnectionOptions tcp, TcpConnectionHeaderMessage header, Action disconnect, EndPoint remoteEndpoint);
    public Task WaitForCommitIndexChange(CommitIndexModification modification, long value, TimeSpan timeout, CancellationToken token);
    public Task WaitForCommitIndexChange(CommitIndexModification modification, long value, CancellationToken token);
    public string LastStateChangeReason();
    public string GetNodeHttpServerUrl(string clientRequestedNodeUrl);
    public string GetNodeTcpServerUrl(string clientRequestedNodeUrl);
    public String[] GetNodeClusterTcpServerUrls(string clientRequestedNodeUrl, bool forExternalUse);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<TestConnectionFromRemote>d__217")]
public Task`1<NodeConnectionTestResult> TestConnectionFromRemote(RequestExecutor requestExecutor, JsonOperationContext context, string nodeUrl);
    [AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<TestConnectionToRemote>d__218")]
public Task`1<NodeConnectionTestResult> TestConnectionToRemote(string url, string database);
    [DoesNotReturnAttribute]
private static void ThrowInvalidTcpUrlOnStartup();
    public DynamicJsonValue GetTcpInfoAndCertificates(string clientRequestedNodeUrl, bool forExternalUse);
    [IteratorStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<GetMountPointUsageDetailsFor>d__221")]
public IEnumerable`1<MountPointUsage> GetMountPointUsageDetailsFor(StorageEnvironmentWithType environment, bool includeTempBuffers);
    private static DiskSpaceResult FillDiskSpaceResult(DiskSpaceResult journalDiskSpaceResult);
    internal static IoStatsResult FillIoStatsResult(DiskStatsResult ioStatsResult);
    public StreamsTempFile GetTempFile(string fileTypeOrName, string suffix, Nullable`1<bool> isEncrypted);
    internal TestingStuff ForTestingPurposesOnly();
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__ExecuteSafely|52_3(Action action);
    [CompilerGeneratedAttribute]
private ClusterRequestExecutor <CreateClusterRequestExecutor>b__53_0();
    [CompilerGeneratedAttribute]
private void <TriggerDatabases>b__123_0(object _, ClusterTopology __);
    [CompilerGeneratedAttribute]
private void <TriggerDatabases>b__123_1(object x);
    [CompilerGeneratedAttribute]
private void <TriggerDatabases>b__123_2(object x);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<<OnStateChanged>b__124_0>d")]
[CompilerGeneratedAttribute]
private void <OnStateChanged>b__124_0(object _);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Raven.Server.ServerWide.ServerStore/<<NotifyAboutClusterTopologyAndConnectivityChanges>b__128_0>d")]
[CompilerGeneratedAttribute]
private Task <NotifyAboutClusterTopologyAndConnectivityChanges>b__128_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__182_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__182_1();
    [CompilerGeneratedAttribute]
private void <Dispose>b__182_2();
    [CompilerGeneratedAttribute]
private void <Dispose>b__182_3();
    [CompilerGeneratedAttribute]
private void <Dispose>b__182_4();
}
public class Raven.Server.ServerWide.ServerVersion : object {
    private static Nullable`1<int> _buildVersion;
    private static Nullable`1<BuildVersionType> _buildType;
    private static string _commitHash;
    private static string _version;
    private static string _fullVersion;
    private static string _assemblyVersion;
    private static string _releaseDate;
    public static int DevBuildNumber;
    public static string Version { get; }
    public static int Build { get; }
    public static BuildVersionType BuildType { get; }
    public static string CommitHash { get; }
    public static string FullVersion { get; }
    public static string AssemblyVersion { get; }
    public static string ReleaseDate { get; }
    public static string get_Version();
    public static int get_Build();
    public static BuildVersionType get_BuildType();
    public static string get_CommitHash();
    public static string get_FullVersion();
    public static string get_AssemblyVersion();
    public static string get_ReleaseDate();
    public static bool IsNightlyOrDev(long buildVersion);
}
public class Raven.Server.ServerWide.Sharding.PrefixedSettingComparer : object {
    public static PrefixedSettingComparer Instance;
    private static PrefixedSettingComparer();
    public sealed virtual int Compare(PrefixedShardingSetting x, PrefixedShardingSetting y);
}
public class Raven.Server.ServerWide.Sharding.RawShardingConfiguration : object {
    private ShardingConfiguration _materializedConfiguration;
    private BlittableJsonReaderObject _sharding;
    private JsonOperationContext _context;
    private string _shardedDatabaseId;
    private Dictionary`2<int, ShardBucketMigration> _bucketMigrations;
    private Dictionary`2<int, DatabaseTopology> _shards;
    private List`1<ShardBucketRange> _shardBucketRanges;
    private List`1<PrefixedShardingSetting> _prefixed;
    private OrchestratorConfiguration _orchestrator;
    public BlittableJsonReaderObject Raw { get; }
    public string ShardedDatabaseId { get; }
    public Dictionary`2<int, ShardBucketMigration> BucketMigrations { get; }
    public Dictionary`2<int, DatabaseTopology> Shards { get; }
    public List`1<ShardBucketRange> BucketRanges { get; }
    public List`1<PrefixedShardingSetting> Prefixed { get; }
    public OrchestratorConfiguration Orchestrator { get; }
    public ShardingConfiguration MaterializedConfiguration { get; }
    public RawShardingConfiguration(JsonOperationContext context, BlittableJsonReaderObject configuration);
    public RawShardingConfiguration(ShardingConfiguration configuration);
    public BlittableJsonReaderObject get_Raw();
    public string get_ShardedDatabaseId();
    public Dictionary`2<int, ShardBucketMigration> get_BucketMigrations();
    public bool HasActiveMigrations();
    public Dictionary`2<int, DatabaseTopology> get_Shards();
    internal static int GetShardNumberFromPropertyDetails(PropertyDetails propertyDetails);
    public List`1<ShardBucketRange> get_BucketRanges();
    public List`1<PrefixedShardingSetting> get_Prefixed();
    public OrchestratorConfiguration get_Orchestrator();
    public ShardingConfiguration get_MaterializedConfiguration();
    public bool DoesShardHaveBuckets(int shardNumber);
    public bool DoesShardHavePrefixes(int shardNumber);
}
public class Raven.Server.ServerWide.ShardingStore : object {
    private ServerStore _serverStore;
    public bool ManualMigration;
    public DocumentConventions DocumentConventionsForShard { get; }
    public DocumentConventions DocumentConventionsForOrchestrator { get; }
    public ShardingStore(ServerStore serverStore);
    public Task`1<ValueTuple`2<long, object>> StartBucketMigration(string database, int bucket, int toShard, string raftId);
    public Task`1<ValueTuple`2<long, object>> StartBucketMigration(string database, int bucket, int toShard, string prefix, string raftId);
    public Task`1<ValueTuple`2<long, object>> SourceMigrationCompleted(string database, int bucket, long migrationIndex, string lastChangeVector, string raftId);
    public static string GenerateDestinationMigrationConfirmRaftId(int bucket, long migrationIndex, string node);
    public Task`1<ValueTuple`2<long, object>> DestinationMigrationConfirm(string database, int bucket, long migrationIndex);
    public static string GenerateSourceMigrationCleanupRaftId(int bucket, long migrationIndex, string node);
    public Task`1<ValueTuple`2<long, object>> SourceMigrationCleanup(string database, int bucket, long migrationIndex);
    public IDisposable RegisterForReshardingStatusUpdate(string database, AsyncQueue`1<string> messages);
    public bool HasActiveMigrations(string database);
    public DocumentConventions get_DocumentConventionsForShard();
    public DocumentConventions get_DocumentConventionsForOrchestrator();
    public bool ShardingCustomValidationCallback(object message, X509Certificate cert, X509Chain chain, SslPolicyErrors errors);
    private DatabaseChangedDelegate CreateDelegateForReshardingStatus(string database, AsyncQueue`1<string> messages);
    public void FillShardingConfiguration(DatabaseRecord record, ClusterTopology clusterTopology, Nullable`1<long> index, bool isRestore);
    private static void FillPrefixedSharding(ShardingConfiguration shardingConfiguration);
    private static void AddPrefixedBucketRange(PrefixedShardingSetting setting, int rangeStart, ShardingConfiguration shardingConfiguration);
    internal static void AssertValidPrefix(PrefixedShardingSetting setting, ShardingConfiguration shardingConfiguration);
    private static Dictionary`2<string, int> GetNodesDistribution(ClusterTopology clusterTopology, Dictionary`2<int, DatabaseTopology> shards);
    [CompilerGeneratedAttribute]
private HttpClient <get_DocumentConventionsForShard>b__13_0(HttpClientHandler handler);
}
public enum Raven.Server.ServerWide.SodiumSubKeyId : Enum {
    public int value__;
    public static SodiumSubKeyId IndexDef;
    public static SodiumSubKeyId SecretProtection;
}
public class Raven.Server.ServerWide.SubscriptionsClusterStorage : object {
    private ClusterStateMachine _cluster;
    public SubscriptionsClusterStorage(ClusterStateMachine cluster);
    [ObsoleteAttribute("This method should not be used directly. Use the one from 'AbstractSubscriptionStorage'.")]
public SubscriptionState ReadSubscriptionStateByName(ClusterOperationContext context, string databaseName, string name);
    [ObsoleteAttribute("This method should not be used directly. Use the one from 'AbstractSubscriptionStorage'.")]
public string GetSubscriptionNameById(ClusterOperationContext context, string databaseName, long id);
    [ObsoleteAttribute("This method should not be used directly. Use the one from 'AbstractSubscriptionStorage'.")]
public BlittableJsonReaderObject ReadSubscriptionStateRaw(ClusterOperationContext context, string databaseName, string name);
}
internal class Raven.Server.ServerWide.Tcp.Sync.TcpNegotiateParameters : AbstractTcpNegotiateParameters {
    [CompilerGeneratedAttribute]
private Func`5<JsonOperationContext, BlittableJsonTextWriter, Stream, string, NegotiationResponse> <ReadResponseAndGetVersionCallback>k__BackingField;
    public Func`5<JsonOperationContext, BlittableJsonTextWriter, Stream, string, NegotiationResponse> ReadResponseAndGetVersionCallback { get; public set; }
    [CompilerGeneratedAttribute]
public Func`5<JsonOperationContext, BlittableJsonTextWriter, Stream, string, NegotiationResponse> get_ReadResponseAndGetVersionCallback();
    [CompilerGeneratedAttribute]
public void set_ReadResponseAndGetVersionCallback(Func`5<JsonOperationContext, BlittableJsonTextWriter, Stream, string, NegotiationResponse> value);
}
[ExtensionAttribute]
internal static class Raven.Server.ServerWide.Tcp.Sync.TcpNegotiationSyncExtensions : object {
    private static Logger Log;
    private static TcpNegotiationSyncExtensions();
    [ExtensionAttribute]
internal static SupportedFeatures NegotiateProtocolVersion(SyncTcpNegotiation syncTcpNegotiation, JsonOperationContext context, Stream stream, TcpNegotiateParameters parameters);
    private static void SendTcpVersionInfo(JsonOperationContext context, BlittableJsonTextWriter writer, TcpNegotiateParameters parameters, int currentVersion);
}
public class Raven.Server.ServerWide.TempCryptoStream : Stream {
    private bool _ignoreSetLength;
    private Stream _stream;
    private MemoryStream _authenticationTags;
    private MemoryStream _nonces;
    private long _startPosition;
    private Byte[] _key;
    private Byte[] _internalBuffer;
    private int _bufferIndex;
    private int _bufferValidIndex;
    private bool _needToWrite;
    private long _blockNumber;
    private long _maxLength;
    public Stream InnerStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public TempCryptoStream(Stream stream, TempCryptoStream other);
    public TempCryptoStream(Stream stream);
    public Stream get_InnerStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public TempCryptoStream IgnoreSetLength();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    private void EncryptToStream(Byte* pInternalBuffer);
    private void EnsureDetachedStreamsLength();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private int ReadIntoBuffer();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
public class Raven.Server.ServerWide.TransactionMerger.ClusterTransactionOperationsMerger : AbstractTransactionOperationsMerger`2<ClusterOperationContext, ClusterTransaction> {
    private ManualResetEventSlim _disposeEvent;
    public bool IsDisposed { get; }
    public ClusterTransactionOperationsMerger(RavenConfiguration configuration, SystemTime time, CancellationToken shutdown);
    internal virtual ClusterTransaction BeginAsyncCommitAndStartNewTransaction(ClusterTransaction previousTransaction, ClusterOperationContext currentContext);
    internal virtual void UpdateGlobalReplicationInfoBeforeCommit(ClusterOperationContext context);
    protected virtual void UpdateLastAccessTime(DateTime time);
    public Task Enqueue(Func`2<ClusterOperationContext, long> executeFunc);
    public void EnqueueSync(Func`2<ClusterOperationContext, long> executeFunc);
    public bool get_IsDisposed();
    public virtual void Dispose();
}
public class Raven.Server.ServerWide.TwoFactor : object {
    private SystemTime _time;
    private ConcurrentDictionary`2<string, TwoFactorAuthRegistration> _twoFactorAuthTimeByCertThumbprintExpiry;
    public TwoFactor(SystemTime time);
    public TwoFactorAuthRegistration GetAuthRegistration(string thumbprint);
    public void RegisterTwoFactorAuthSuccess(TwoFactorAuthRegistration registration);
    public void ForgotTwoFactorAuthSuccess(TwoFactorAuthRegistration registration);
    public bool ValidateTwoFactorConnectionLimits(string certificateThumbprint);
    public bool ValidateTwoFactorRequestLimits(RouteInformation routeInformation, HttpContext context, TwoFactorAuthRegistration twoFactorAuthRegistration, String& msg);
}
public class Raven.Server.ServerWide.UnknownClusterCommandException : Exception {
    public UnknownClusterCommandException(string message);
    public UnknownClusterCommandException(string message, Exception innerException);
}
public class Raven.Server.ServerWide.UnmanagedBuffersPoolWithLowMemoryHandling : UnmanagedBuffersPool {
    public UnmanagedBuffersPoolWithLowMemoryHandling(string debugTag, string databaseName);
    private sealed virtual override void Sparrow.LowMemory.ILowMemoryHandler.LowMemory(LowMemorySeverity lowMemorySeverity);
    private sealed virtual override void Sparrow.LowMemory.ILowMemoryHandler.LowMemoryOver();
}
internal abstract class Raven.Server.Smuggler.Documents.Actions.AbstractDatabaseCompareExchangeActions : object {
    private static int BatchSize;
    private Size _compareExchangeValuesBatchSize;
    private Size _compareExchangeValuesSize;
    private Size _clusterTransactionCommandsBatchSize;
    protected Size _clusterTransactionCommandsSize;
    private JsonOperationContext _context;
    protected ServerStore _serverStore;
    protected string _databaseName;
    private char _identityPartsSeparator;
    private List`1<RemoveCompareExchangeCommand> _compareExchangeRemoveCommands;
    private List`1<AddOrUpdateCompareExchangeCommand> _compareExchangeAddOrUpdateCommands;
    protected DisposableReturnedArray`1<ClusterTransactionDataCommand> _clusterTransactionCommands;
    protected Nullable`1<long> _lastAddOrUpdateOrRemoveResultIndex;
    protected Nullable`1<long> _lastClusterTransactionIndex;
    protected Nullable`1<BackupKind> _backupKind;
    protected CancellationToken _token;
    protected AbstractDatabaseCompareExchangeActions(ServerStore serverStore, string databaseName, char identityPartsSeparator, JsonOperationContext context, Nullable`1<BackupKind> backupKind, CancellationToken token);
    protected abstract virtual bool TryHandleAtomicGuard(string key, string documentId, BlittableJsonReaderObject value, Document existingDocument);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.AbstractDatabaseCompareExchangeActions/<WriteKeyValueAsync>d__18")]
public sealed virtual ValueTask WriteKeyValueAsync(string key, BlittableJsonReaderObject value, Document existingDocument);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.AbstractDatabaseCompareExchangeActions/<WriteTombstoneKeyAsync>d__19")]
public sealed virtual ValueTask WriteTombstoneKeyAsync(string key);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.AbstractDatabaseCompareExchangeActions/<FlushAsync>d__20")]
public sealed virtual ValueTask FlushAsync();
    protected abstract virtual ValueTask WaitForIndexNotificationAsync(Nullable`1<long> lastAddOrUpdateOrRemoveResultIndex, Nullable`1<long> lastClusterTransactionIndex);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.AbstractDatabaseCompareExchangeActions/<DisposeAsync>d__22")]
public virtual ValueTask DisposeAsync();
    protected virtual ClusterTransactionCommand CreateClusterTransactionCommand(string databaseName, char identityPartsSeparator, ArraySegment`1<ClusterTransactionDataCommand> parsedCommands, ClusterTransactionOptions options, string raftRequestId);
    protected virtual ValueTask`1<bool> SendClusterTransactionsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.AbstractDatabaseCompareExchangeActions/<SendAddOrUpdateCommandsAsync>d__25")]
private ValueTask SendAddOrUpdateCommandsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.AbstractDatabaseCompareExchangeActions/<SendRemoveCommandsAsync>d__26")]
private ValueTask SendRemoveCommandsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.AbstractDatabaseCompareExchangeActions/<<SendClusterTransactionsAsync>g__AsyncWork|24_0>d")]
[CompilerGeneratedAttribute]
private Task`1<bool> <SendClusterTransactionsAsync>g__AsyncWork|24_0();
}
internal class Raven.Server.Smuggler.Documents.Actions.DatabaseCompareExchangeActions : AbstractDatabaseCompareExchangeActions {
    private DocumentContextHolder _documentContextHolder;
    private DocumentDatabase _database;
    private SmugglerResult _result;
    private Action`1<IOperationProgress> _onProgress;
    public DatabaseCompareExchangeActions(string databaseName, DocumentDatabase database, JsonOperationContext context, Nullable`1<BackupKind> backupKind, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
    protected virtual bool TryHandleAtomicGuard(string key, string documentId, BlittableJsonReaderObject value, Document existingDocument);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseCompareExchangeActions/<WaitForIndexNotificationAsync>d__6")]
protected virtual ValueTask WaitForIndexNotificationAsync(Nullable`1<long> lastAddOrUpdateOrRemoveResultIndex, Nullable`1<long> lastClusterTransactionIndex);
    private void ExecuteClusterTransactions();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseCompareExchangeActions/<SendClusterTransactionsAsync>d__8")]
protected virtual ValueTask`1<bool> SendClusterTransactionsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseCompareExchangeActions/<DisposeAsync>d__9")]
public virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<bool> <>n__0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__1();
}
public class Raven.Server.Smuggler.Documents.Actions.DatabaseIndexActions : object {
    private AbstractIndexCreateController _controller;
    private SystemTime _time;
    private IndexBatchScope _batch;
    private RavenConfiguration _configuration;
    private static string _source;
    public DatabaseIndexActions(AbstractIndexCreateController controller, SystemTime time);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseIndexActions/<WriteAutoIndexAsync>d__5")]
public sealed virtual ValueTask WriteAutoIndexAsync(IndexDefinitionBaseServerSide indexDefinition, IndexType indexType, AuthorizationStatus authorizationStatus);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseIndexActions/<WriteIndexAsync>d__6")]
public sealed virtual ValueTask WriteIndexAsync(IndexDefinition indexDefinition, AuthorizationStatus authorizationStatus);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseIndexActions/<DisposeAsync>d__8")]
public sealed virtual ValueTask DisposeAsync();
}
public class Raven.Server.Smuggler.Documents.Actions.DatabaseKeyValueActions : object {
    private ServerStore _serverStore;
    private string _name;
    private Dictionary`2<string, long> _identities;
    public DatabaseKeyValueActions(DocumentDatabase database);
    public DatabaseKeyValueActions(ServerStore server, string name);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseKeyValueActions/<WriteKeyValueAsync>d__5")]
public sealed virtual ValueTask WriteKeyValueAsync(string key, long value);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseKeyValueActions/<DisposeAsync>d__6")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseKeyValueActions/<SendIdentitiesAsync>d__7")]
private ValueTask SendIdentitiesAsync();
}
public class Raven.Server.Smuggler.Documents.Actions.DatabaseRecordActions : object {
    private ServerStore _server;
    private Logger _log;
    private string _name;
    private DatabaseRecord _currentDatabaseRecord;
    public DatabaseRecordActions(DocumentDatabase database, Logger log);
    public DatabaseRecordActions(ServerStore server, DatabaseRecord currentDatabaseRecord, string name, Logger log);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseRecordActions/<WriteDatabaseRecordAsync>d__6")]
public sealed virtual ValueTask WriteDatabaseRecordAsync(DatabaseRecord databaseRecord, SmugglerResult result, AuthorizationStatus authorizationStatus, DatabaseRecordItemType databaseRecordItemType);
    private static bool CanAccess(AuthorizationStatus authorizationStatus);
    public sealed virtual ValueTask DisposeAsync();
}
public class Raven.Server.Smuggler.Documents.Actions.DatabaseReplicationHubCertificateActions : object {
    private ServerStore _server;
    private string _name;
    private List`1<RegisterReplicationHubAccessCommand> _commands;
    public DatabaseReplicationHubCertificateActions(DocumentDatabase database);
    public DatabaseReplicationHubCertificateActions(ServerStore serverStore, string name);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseReplicationHubCertificateActions/<DisposeAsync>d__5")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseReplicationHubCertificateActions/<WriteReplicationHubCertificateAsync>d__6")]
public sealed virtual ValueTask WriteReplicationHubCertificateAsync(string hub, ReplicationHubAccess access);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseReplicationHubCertificateActions/<SendCommandsAsync>d__7")]
private ValueTask SendCommandsAsync();
}
public class Raven.Server.Smuggler.Documents.Actions.DatabaseSubscriptionActions : DatabaseSubscriptionActionsBase`1<PutSubscriptionCommand> {
    public DatabaseSubscriptionActions(ServerStore serverStore, string name);
    protected virtual PutSubscriptionCommand CreatePutSubscriptionCommand(SubscriptionState subscriptionState);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseSubscriptionActions/<SendCommandsAsync>d__2")]
protected virtual ValueTask SendCommandsAsync();
}
public abstract class Raven.Server.Smuggler.Documents.Actions.DatabaseSubscriptionActionsBase`1 : object {
    protected ServerStore _serverStore;
    protected string _name;
    protected List`1<T> _subscriptionCommands;
    private static int _batchSize;
    protected DatabaseSubscriptionActionsBase`1(ServerStore serverStore, string name);
    private static DatabaseSubscriptionActionsBase`1();
    protected abstract virtual T CreatePutSubscriptionCommand(SubscriptionState subscriptionState);
    protected abstract virtual ValueTask SendCommandsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseSubscriptionActionsBase`1/<WriteSubscriptionAsync>d__7")]
public virtual ValueTask WriteSubscriptionAsync(SubscriptionState subscriptionState);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.DatabaseSubscriptionActionsBase`1/<DisposeAsync>d__8")]
public sealed virtual ValueTask DisposeAsync();
}
public class Raven.Server.Smuggler.Documents.Actions.ShardedDatabaseSubscriptionActions : DatabaseSubscriptionActionsBase`1<PutShardedSubscriptionCommand> {
    public ShardedDatabaseSubscriptionActions(ServerStore serverStore, string name);
    protected virtual PutShardedSubscriptionCommand CreatePutSubscriptionCommand(SubscriptionState subscriptionState);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Actions.ShardedDatabaseSubscriptionActions/<SendCommandsAsync>d__2")]
protected virtual ValueTask SendCommandsAsync();
}
public class Raven.Server.Smuggler.Documents.CounterItem : object {
    public string DocId;
    public string ChangeVector;
}
public class Raven.Server.Smuggler.Documents.CsvImportOptions : object {
    [CompilerGeneratedAttribute]
private string <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Quote>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowComments>k__BackingField;
    [CompilerGeneratedAttribute]
private TrimOptions <TrimOptions>k__BackingField;
    public string Delimiter { get; public set; }
    public char Quote { get; public set; }
    public Nullable`1<char> Comment { get; public set; }
    public bool AllowComments { get; public set; }
    public TrimOptions TrimOptions { get; public set; }
    public CsvImportOptions(string delimiter, char quote, TrimOptions trim, bool allowComments, char comment);
    [CompilerGeneratedAttribute]
public string get_Delimiter();
    [CompilerGeneratedAttribute]
public void set_Delimiter(string value);
    [CompilerGeneratedAttribute]
public char get_Quote();
    [CompilerGeneratedAttribute]
public void set_Quote(char value);
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(Nullable`1<char> value);
    [CompilerGeneratedAttribute]
public bool get_AllowComments();
    [CompilerGeneratedAttribute]
public void set_AllowComments(bool value);
    [CompilerGeneratedAttribute]
public TrimOptions get_TrimOptions();
    [CompilerGeneratedAttribute]
public void set_TrimOptions(TrimOptions value);
}
public class Raven.Server.Smuggler.Documents.CsvStreamSource : object {
    private DocumentDatabase _database;
    private Stream _stream;
    private JsonOperationContext _context;
    private SmugglerResult _result;
    private DatabaseItemType _currentType;
    private string _collection;
    private StreamReader _reader;
    private CsvReader _csvReader;
    private CsvConfiguration _csvHelperConfig;
    private bool _hasId;
    private int _idIndex;
    private bool _hasCollection;
    private int _collectionIndex;
    private Dictionary`2<int, string> _metadataPositionToPropertyNames;
    private Dictionary`2<int, String[]> _nestedPropertyDictionary;
    private bool _headersProcessed;
    private String[] _csvReaderFieldHeaders;
    private List`1<IDisposable> _disposables;
    public CsvStreamSource(DocumentDatabase database, Stream stream, JsonOperationContext context, string collection, CsvImportOptions csvConfig);
    public sealed virtual Task`1<SmugglerInitializeResult> InitializeAsync(DatabaseSmugglerOptionsServerSide options, SmugglerResult result);
    private bool ProcessFieldsIfNeeded();
    private static ValueTuple`2<String[], bool> SplitByDotWhileIgnoringEscapedDot(string csvReaderFieldHeader);
    public sealed virtual Task`1<DatabaseItemType> GetNextTypeAsync();
    public sealed virtual Task`1<DatabaseRecord> GetDatabaseRecordAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.CsvStreamSource/<GetDocumentsAsync>d__24")]
public sealed virtual IAsyncEnumerable`1<DocumentItem> GetDocumentsAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    private DocumentItem ConvertRecordToDocumentItem(JsonOperationContext context, String[] csvReaderCurrentRecord, String[] csvReaderFieldHeaders, string collection);
    private object ParseValue(string s);
    public sealed virtual IAsyncEnumerable`1<DocumentItem> GetRevisionDocumentsAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    public sealed virtual IAsyncEnumerable`1<DocumentItem> GetLegacyAttachmentsAsync(INewDocumentActions actions);
    public sealed virtual IAsyncEnumerable`1<string> GetLegacyAttachmentDeletionsAsync();
    public sealed virtual IAsyncEnumerable`1<string> GetLegacyDocumentDeletionsAsync();
    public sealed virtual IAsyncEnumerable`1<Tombstone> GetTombstonesAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    public sealed virtual IAsyncEnumerable`1<DocumentConflict> GetConflictsAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    public sealed virtual IAsyncEnumerable`1<IndexDefinitionAndType> GetIndexesAsync();
    public sealed virtual IAsyncEnumerable`1<ValueTuple`3<string, long, long>> GetIdentitiesAsync();
    public sealed virtual IAsyncEnumerable`1<ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject>> GetCompareExchangeValuesAsync();
    public sealed virtual IAsyncEnumerable`1<ValueTuple`2<CompareExchangeKey, long>> GetCompareExchangeTombstonesAsync();
    public sealed virtual IAsyncEnumerable`1<CounterGroupDetail> GetCounterValuesAsync(List`1<string> collectionsToExport, ICounterActions actions);
    public sealed virtual IAsyncEnumerable`1<SubscriptionState> GetSubscriptionsAsync();
    public sealed virtual IAsyncEnumerable`1<ValueTuple`2<string, ReplicationHubAccess>> GetReplicationHubCertificatesAsync();
    public sealed virtual IAsyncEnumerable`1<TimeSeriesItem> GetTimeSeriesAsync(ITimeSeriesActions action, List`1<string> collectionsToExport);
    public sealed virtual Task`1<long> SkipTypeAsync(DatabaseItemType type, Action`1<long> onSkipped, CancellationToken token);
    public sealed virtual SmugglerSourceType GetSourceType();
    public sealed virtual Stream GetAttachmentStream(LazyStringValue hash, String& tag);
    public sealed virtual IAsyncEnumerable`1<TimeSeriesDeletedRangeItemForSmuggler> GetTimeSeriesDeletedRangesAsync(ITimeSeriesActions action, List`1<string> collectionsToExport);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <InitializeAsync>b__19_0();
}
public class Raven.Server.Smuggler.Documents.Data.DatabaseSmugglerOptionsServerSide : DatabaseSmugglerOptions {
    [CompilerGeneratedAttribute]
private bool <ReadLegacyEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    private Nullable`1<AuthorizationStatus> _authorizationStatus;
    [CompilerGeneratedAttribute]
private bool <SkipRevisionCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ExportCompressionAlgorithm> <CompressionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CompressionLevel> <CompressionLevel>k__BackingField;
    public bool ReadLegacyEtag { get; public set; }
    public string FileName { get; public set; }
    public AuthorizationStatus AuthorizationStatus { get; }
    public bool SkipRevisionCreation { get; public set; }
    public Nullable`1<ExportCompressionAlgorithm> CompressionAlgorithm { get; public set; }
    public Nullable`1<CompressionLevel> CompressionLevel { get; public set; }
    public DatabaseSmugglerOptionsServerSide(AuthorizationStatus authorizationStatus);
    [CompilerGeneratedAttribute]
public bool get_ReadLegacyEtag();
    [CompilerGeneratedAttribute]
public void set_ReadLegacyEtag(bool value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    public AuthorizationStatus get_AuthorizationStatus();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipRevisionCreation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SkipRevisionCreation(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ExportCompressionAlgorithm> get_CompressionAlgorithm();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CompressionAlgorithm(Nullable`1<ExportCompressionAlgorithm> value);
    [CompilerGeneratedAttribute]
public Nullable`1<CompressionLevel> get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(Nullable`1<CompressionLevel> value);
    public void SetAuthorizationStatus(AuthorizationStatus authorizationStatus);
    public static DatabaseSmugglerOptionsServerSide Create(HttpContext httpContext, AuthorizationStatus authorizationStatus);
    public DatabaseSmugglerExportOptions ToExportOptions();
}
public interface Raven.Server.Smuggler.Documents.Data.ICompareExchangeActions {
    public abstract virtual ValueTask WriteKeyValueAsync(string key, BlittableJsonReaderObject value, Document existingDocument);
    public abstract virtual ValueTask WriteTombstoneKeyAsync(string key);
    public abstract virtual ValueTask FlushAsync();
}
public interface Raven.Server.Smuggler.Documents.Data.ICounterActions {
    public abstract virtual ValueTask WriteCounterAsync(CounterGroupDetail counterDetail);
    public abstract virtual ValueTask WriteLegacyCounterAsync(CounterDetail counterDetail);
    public abstract virtual void RegisterForDisposal(IDisposable data);
}
public interface Raven.Server.Smuggler.Documents.Data.IDatabaseRecordActions {
    public abstract virtual ValueTask WriteDatabaseRecordAsync(DatabaseRecord databaseRecord, SmugglerResult result, AuthorizationStatus authorizationStatus, DatabaseRecordItemType databaseRecordItemType);
}
public interface Raven.Server.Smuggler.Documents.Data.IDocumentActions {
    public abstract virtual ValueTask WriteDocumentAsync(DocumentItem item, CountsWithLastEtagAndAttachments progress, Func`1<ValueTask> beforeFlushing);
    public abstract virtual ValueTask WriteTombstoneAsync(Tombstone tombstone, CountsWithLastEtag progress);
    public abstract virtual ValueTask WriteConflictAsync(DocumentConflict conflict, CountsWithLastEtag progress);
    public abstract virtual ValueTask DeleteDocumentAsync(string id);
    public abstract virtual IEnumerable`1<DocumentItem> GetDocumentsWithDuplicateCollection();
}
public interface Raven.Server.Smuggler.Documents.Data.IIndexActions {
    public abstract virtual ValueTask WriteAutoIndexAsync(IndexDefinitionBaseServerSide indexDefinition, IndexType indexType, AuthorizationStatus authorizationStatus);
    public abstract virtual ValueTask WriteIndexAsync(IndexDefinition indexDefinition, AuthorizationStatus authorizationStatus);
}
public interface Raven.Server.Smuggler.Documents.Data.IKeyValueActions`1 {
    public abstract virtual ValueTask WriteKeyValueAsync(string key, T value);
}
public interface Raven.Server.Smuggler.Documents.Data.ILegacyActions {
    public abstract virtual ValueTask WriteLegacyDeletions(string id);
}
public class Raven.Server.Smuggler.Documents.Data.IndexDefinitionAndType : object {
    public object IndexDefinition;
    public IndexType Type;
}
public interface Raven.Server.Smuggler.Documents.Data.INewCompareExchangeActions {
}
public interface Raven.Server.Smuggler.Documents.Data.INewDocumentActions {
    public abstract virtual Task`1<Stream> GetTempStreamAsync();
}
public interface Raven.Server.Smuggler.Documents.Data.INewItemActions {
    public abstract virtual JsonOperationContext GetContextForNewDocument();
    public abstract virtual BlittableJsonDocumentBuilder GetBuilderForNewDocument(UnmanagedJsonParser parser, JsonParserState state, BlittableMetadataModifier modifier);
    public abstract virtual BlittableMetadataModifier GetMetadataModifierForNewDocument(string firstEtagOfLegacyRevision, long legacyRevisionsCount, bool legacyImport, bool readLegacyEtag, DatabaseItemType operateOnTypes);
}
public interface Raven.Server.Smuggler.Documents.Data.IReplicationHubCertificateActions {
    public abstract virtual ValueTask WriteReplicationHubCertificateAsync(string hub, ReplicationHubAccess access);
}
public interface Raven.Server.Smuggler.Documents.Data.ISmugglerDestination {
    public abstract virtual ValueTask`1<IAsyncDisposable> InitializeAsync(DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, long buildVersion);
    public abstract virtual IDatabaseRecordActions DatabaseRecord();
    public abstract virtual IDocumentActions Documents(bool throwOnCollectionMismatchError);
    public abstract virtual IDocumentActions RevisionDocuments();
    public abstract virtual IDocumentActions Tombstones();
    public abstract virtual IDocumentActions Conflicts();
    public abstract virtual IIndexActions Indexes();
    public abstract virtual IKeyValueActions`1<long> Identities();
    public abstract virtual ICompareExchangeActions CompareExchange(string databaseName, JsonOperationContext context, Nullable`1<BackupKind> backupKind, bool withDocuments);
    public abstract virtual ICompareExchangeActions CompareExchangeTombstones(string databaseName, JsonOperationContext context);
    public abstract virtual ICounterActions Counters(SmugglerResult result);
    public abstract virtual ISubscriptionActions Subscriptions();
    public abstract virtual IReplicationHubCertificateActions ReplicationHubCertificates();
    public abstract virtual ITimeSeriesActions TimeSeries();
    public abstract virtual ITimeSeriesActions TimeSeriesDeletedRanges();
    public abstract virtual ILegacyActions LegacyDocumentDeletions();
    public abstract virtual ILegacyActions LegacyAttachmentDeletions();
}
public interface Raven.Server.Smuggler.Documents.Data.ISmugglerSource {
    public abstract virtual Task`1<SmugglerInitializeResult> InitializeAsync(DatabaseSmugglerOptionsServerSide options, SmugglerResult result);
    public abstract virtual Task`1<DatabaseItemType> GetNextTypeAsync();
    public abstract virtual Task`1<DatabaseRecord> GetDatabaseRecordAsync();
    public abstract virtual IAsyncEnumerable`1<DocumentItem> GetDocumentsAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    public abstract virtual IAsyncEnumerable`1<DocumentItem> GetRevisionDocumentsAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    public abstract virtual IAsyncEnumerable`1<DocumentItem> GetLegacyAttachmentsAsync(INewDocumentActions actions);
    public abstract virtual IAsyncEnumerable`1<string> GetLegacyAttachmentDeletionsAsync();
    public abstract virtual IAsyncEnumerable`1<string> GetLegacyDocumentDeletionsAsync();
    public abstract virtual IAsyncEnumerable`1<Tombstone> GetTombstonesAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    public abstract virtual IAsyncEnumerable`1<DocumentConflict> GetConflictsAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    public abstract virtual IAsyncEnumerable`1<IndexDefinitionAndType> GetIndexesAsync();
    public abstract virtual IAsyncEnumerable`1<ValueTuple`3<string, long, long>> GetIdentitiesAsync();
    public abstract virtual IAsyncEnumerable`1<ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject>> GetCompareExchangeValuesAsync();
    public abstract virtual IAsyncEnumerable`1<ValueTuple`2<CompareExchangeKey, long>> GetCompareExchangeTombstonesAsync();
    public abstract virtual IAsyncEnumerable`1<CounterGroupDetail> GetCounterValuesAsync(List`1<string> collectionsToExport, ICounterActions actions);
    public abstract virtual IAsyncEnumerable`1<SubscriptionState> GetSubscriptionsAsync();
    public abstract virtual IAsyncEnumerable`1<ValueTuple`2<string, ReplicationHubAccess>> GetReplicationHubCertificatesAsync();
    public abstract virtual IAsyncEnumerable`1<TimeSeriesItem> GetTimeSeriesAsync(ITimeSeriesActions action, List`1<string> collectionsToExport);
    public abstract virtual Task`1<long> SkipTypeAsync(DatabaseItemType type, Action`1<long> onSkipped, CancellationToken token);
    public abstract virtual SmugglerSourceType GetSourceType();
    public abstract virtual Stream GetAttachmentStream(LazyStringValue hash, String& tag);
    public abstract virtual IAsyncEnumerable`1<TimeSeriesDeletedRangeItemForSmuggler> GetTimeSeriesDeletedRangesAsync(ITimeSeriesActions action, List`1<string> collectionsToExport);
}
public interface Raven.Server.Smuggler.Documents.Data.ISubscriptionActions {
    public abstract virtual ValueTask WriteSubscriptionAsync(SubscriptionState subscriptionState);
}
public interface Raven.Server.Smuggler.Documents.Data.ITimeSeriesActions {
    public abstract virtual ValueTask WriteTimeSeriesAsync(TimeSeriesItem ts);
    public abstract virtual ValueTask WriteTimeSeriesDeletedRangeAsync(TimeSeriesDeletedRangeItemForSmuggler deletedRange);
    public abstract virtual void RegisterForDisposal(IDisposable data);
    public abstract virtual void RegisterForReturnToTheContext(AllocatedMemoryData data);
}
internal class Raven.Server.Smuggler.Documents.Data.LegacyIndexDefinition : object {
    [CompilerGeneratedAttribute]
private int <IndexId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexLockMode <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <IndexVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reduce>k__BackingField;
    [JsonIgnoreAttribute]
private HashSet`1<string> _maps;
    [JsonIgnoreAttribute]
private Dictionary`2<string, FieldStorage> _stores;
    [JsonIgnoreAttribute]
private Dictionary`2<string, LegacyFieldIndexing> _indexes;
    [JsonIgnoreAttribute]
private Dictionary`2<string, LegacySortOptions> _sortOptions;
    [JsonIgnoreAttribute]
private Dictionary`2<string, string> _analyzers;
    [JsonIgnoreAttribute]
private List`1<string> _fields;
    [JsonIgnoreAttribute]
private Dictionary`2<string, FieldTermVector> _termVectors;
    [JsonIgnoreAttribute]
private Dictionary`2<string, SpatialOptions> _spatialIndexes;
    [JsonIgnoreAttribute]
private HashSet`1<string> _suggestionsOptions;
    public int IndexId { get; public set; }
    public string Name { get; public set; }
    public IndexLockMode LockMode { get; public set; }
    public Nullable`1<int> IndexVersion { get; public set; }
    public string Map { get; public set; }
    public HashSet`1<string> Maps { get; public set; }
    public string Reduce { get; public set; }
    public Dictionary`2<string, FieldStorage> Stores { get; public set; }
    public Dictionary`2<string, LegacyFieldIndexing> Indexes { get; public set; }
    public Dictionary`2<string, LegacySortOptions> SortOptions { get; public set; }
    public Dictionary`2<string, string> Analyzers { get; public set; }
    public List`1<string> Fields { get; public set; }
    [ObsoleteAttribute("Use SuggestionsOptions")]
public Dictionary`2<string, SuggestionOptions> Suggestions { get; public set; }
    public HashSet`1<string> SuggestionsOptions { get; public set; }
    public Dictionary`2<string, FieldTermVector> TermVectors { get; public set; }
    public Dictionary`2<string, SpatialOptions> SpatialIndexes { get; public set; }
    [CompilerGeneratedAttribute]
public int get_IndexId();
    [CompilerGeneratedAttribute]
public void set_IndexId(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IndexLockMode get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(IndexLockMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_IndexVersion();
    [CompilerGeneratedAttribute]
public void set_IndexVersion(Nullable`1<int> value);
    public string get_Map();
    public void set_Map(string value);
    public HashSet`1<string> get_Maps();
    public void set_Maps(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Reduce();
    [CompilerGeneratedAttribute]
public void set_Reduce(string value);
    public Dictionary`2<string, FieldStorage> get_Stores();
    public void set_Stores(Dictionary`2<string, FieldStorage> value);
    public Dictionary`2<string, LegacyFieldIndexing> get_Indexes();
    public void set_Indexes(Dictionary`2<string, LegacyFieldIndexing> value);
    public Dictionary`2<string, LegacySortOptions> get_SortOptions();
    public void set_SortOptions(Dictionary`2<string, LegacySortOptions> value);
    public Dictionary`2<string, string> get_Analyzers();
    public void set_Analyzers(Dictionary`2<string, string> value);
    public List`1<string> get_Fields();
    public void set_Fields(List`1<string> value);
    public Dictionary`2<string, SuggestionOptions> get_Suggestions();
    public void set_Suggestions(Dictionary`2<string, SuggestionOptions> value);
    public HashSet`1<string> get_SuggestionsOptions();
    public void set_SuggestionsOptions(HashSet`1<string> value);
    public Dictionary`2<string, FieldTermVector> get_TermVectors();
    public void set_TermVectors(Dictionary`2<string, FieldTermVector> value);
    public Dictionary`2<string, SpatialOptions> get_SpatialIndexes();
    public void set_SpatialIndexes(Dictionary`2<string, SpatialOptions> value);
    public virtual string ToString();
}
public class Raven.Server.Smuggler.Documents.Data.SmugglerInitializeResult : object {
    private IDisposable _disposable;
    public long BuildNumber;
    public SmugglerInitializeResult(IDisposable disposable, long buildNumber);
    public sealed virtual void Dispose();
}
public enum Raven.Server.Smuggler.Documents.Data.SmugglerSourceType : Enum {
    public int value__;
    public static SmugglerSourceType None;
    public static SmugglerSourceType FullExport;
    public static SmugglerSourceType IncrementalExport;
    public static SmugglerSourceType Import;
}
public class Raven.Server.Smuggler.Documents.DatabaseDestination : object {
    protected DocumentDatabase _database;
    protected CancellationToken _token;
    internal DuplicateDocsHandler _duplicateDocsHandler;
    private Logger _log;
    private BuildVersionType _buildType;
    private DatabaseSmugglerOptionsServerSide _options;
    protected SmugglerResult _result;
    protected Action`1<IOperationProgress> _onProgress;
    public DatabaseDestination(DocumentDatabase database, CancellationToken token);
    public sealed virtual ValueTask`1<IAsyncDisposable> InitializeAsync(DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, long buildVersion);
    public sealed virtual IDatabaseRecordActions DatabaseRecord();
    public sealed virtual IDocumentActions Documents(bool throwOnCollectionMismatchError);
    public sealed virtual IDocumentActions RevisionDocuments();
    public sealed virtual IDocumentActions Tombstones();
    public sealed virtual IDocumentActions Conflicts();
    public sealed virtual IKeyValueActions`1<long> Identities();
    public sealed virtual ICompareExchangeActions CompareExchange(string databaseName, JsonOperationContext context, Nullable`1<BackupKind> backupKind, bool withDocuments);
    protected virtual ICompareExchangeActions CreateCompareExchangeActions(string databaseName, JsonOperationContext context, Nullable`1<BackupKind> backupKind);
    public sealed virtual ICompareExchangeActions CompareExchangeTombstones(string databaseName, JsonOperationContext context);
    public sealed virtual ICounterActions Counters(SmugglerResult result);
    public virtual ISubscriptionActions Subscriptions();
    public sealed virtual IReplicationHubCertificateActions ReplicationHubCertificates();
    public sealed virtual ITimeSeriesActions TimeSeries();
    public sealed virtual ITimeSeriesActions TimeSeriesDeletedRanges();
    public sealed virtual ILegacyActions LegacyDocumentDeletions();
    public sealed virtual ILegacyActions LegacyAttachmentDeletions();
    public sealed virtual IIndexActions Indexes();
    [CompilerGeneratedAttribute]
private Task <InitializeAsync>b__9_0();
}
public class Raven.Server.Smuggler.Documents.DatabaseSmuggler : SmugglerBase {
    private DocumentDatabase _database;
    public static string PreV4RevisionsDocumentId;
    public DatabaseSmuggler(string databaseName, DocumentDatabase database, ISmugglerSource source, ISmugglerDestination destination, SystemTime time, JsonOperationContext context, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
    internal static bool IsPreV4Revision(BuildVersionType buildType, string id, Document document);
    public virtual SmugglerPatcher CreatePatcher();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSmuggler/<ProcessCompareExchangeAsync>d__5")]
protected virtual Task`1<Counts> ProcessCompareExchangeAsync(SmugglerResult result, string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSmuggler/<ProcessCompareExchangeTombstonesAsync>d__6")]
protected virtual Task`1<Counts> ProcessCompareExchangeTombstonesAsync(SmugglerResult result, string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSmuggler/<InternalProcessCompareExchangeAsync>d__7")]
protected virtual Task InternalProcessCompareExchangeAsync(SmugglerResult result, ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject> kvp, ICompareExchangeActions actions);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSmuggler/<InternalProcessCompareExchangeTombstonesAsync>d__8")]
protected virtual Task InternalProcessCompareExchangeTombstonesAsync(SmugglerResult result, ValueTuple`2<CompareExchangeKey, long> key, ICompareExchangeActions actions);
}
public class Raven.Server.Smuggler.Documents.DatabaseSmugglerPatcher : SmugglerPatcher {
    public DatabaseSmugglerPatcher(DatabaseSmugglerOptions options, DocumentDatabase database);
}
public class Raven.Server.Smuggler.Documents.DatabaseSource : object {
    private DocumentDatabase _database;
    private DocumentsOperationContext _context;
    private ClusterOperationContext _serverContext;
    private long _startDocumentEtag;
    private long _startRaftIndex;
    private Logger _logger;
    private IDisposable _returnContext;
    private IDisposable _returnServerContext;
    private DocumentsTransaction _disposeTransaction;
    private IDisposable _disposeServerTransaction;
    private int _currentTypeIndex;
    private DatabaseItemType[] _types;
    [CompilerGeneratedAttribute]
private long <LastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastDatabaseChangeVector>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastRaftIndex>k__BackingField;
    private SmugglerSourceType _type;
    private SmugglerResult _result;
    public EventHandler`1<InvalidOperationException> OnCorruptedDataHandler;
    public long LastEtag { get; private set; }
    public string LastDatabaseChangeVector { get; private set; }
    public long LastRaftIndex { get; private set; }
    public DatabaseSource(DocumentDatabase database, long startDocumentEtag, long startRaftIndex, Logger logger);
    [CompilerGeneratedAttribute]
public long get_LastEtag();
    [CompilerGeneratedAttribute]
private void set_LastEtag(long value);
    [CompilerGeneratedAttribute]
public string get_LastDatabaseChangeVector();
    [CompilerGeneratedAttribute]
private void set_LastDatabaseChangeVector(string value);
    [CompilerGeneratedAttribute]
public long get_LastRaftIndex();
    [CompilerGeneratedAttribute]
private void set_LastRaftIndex(long value);
    public sealed virtual Task`1<SmugglerInitializeResult> InitializeAsync(DatabaseSmugglerOptionsServerSide options, SmugglerResult result);
    public sealed virtual Task`1<DatabaseItemType> GetNextTypeAsync();
    public sealed virtual Task`1<DatabaseRecord> GetDatabaseRecordAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetDocumentsAsync>d__31")]
public sealed virtual IAsyncEnumerable`1<DocumentItem> GetDocumentsAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    protected virtual DatabaseRecord ReadDatabaseRecord();
    [IteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetDocumentsFromCollections>d__33")]
private IEnumerable`1<Document> GetDocumentsFromCollections(DocumentsOperationContext context, DocumentsIterationState state);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetRevisionDocumentsAsync>d__34")]
public sealed virtual IAsyncEnumerable`1<DocumentItem> GetRevisionDocumentsAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    [IteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetRevisionsFromCollections>d__35")]
private IEnumerable`1<Document> GetRevisionsFromCollections(DocumentsOperationContext context, DocumentsIterationState state);
    public sealed virtual IAsyncEnumerable`1<DocumentItem> GetLegacyAttachmentsAsync(INewDocumentActions actions);
    public sealed virtual IAsyncEnumerable`1<string> GetLegacyAttachmentDeletionsAsync();
    public sealed virtual IAsyncEnumerable`1<string> GetLegacyDocumentDeletionsAsync();
    public sealed virtual Stream GetAttachmentStream(LazyStringValue hash, String& tag);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetTombstonesAsync>d__40")]
public sealed virtual IAsyncEnumerable`1<Tombstone> GetTombstonesAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    [IteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetTombstonesFromCollections>d__41")]
private IEnumerable`1<Tombstone> GetTombstonesFromCollections(DocumentsOperationContext context, TombstonesIterationState state);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetConflictsAsync>d__42")]
public sealed virtual IAsyncEnumerable`1<DocumentConflict> GetConflictsAsync(List`1<string> collectionsToExport, INewDocumentActions actions);
    [IteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetConflictsFromCollections>d__43")]
private IEnumerable`1<DocumentConflict> GetConflictsFromCollections(DocumentsOperationContext context, HashSet`1<string> collections, DocumentConflictsIterationState state);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetIndexesAsync>d__44")]
public sealed virtual IAsyncEnumerable`1<IndexDefinitionAndType> GetIndexesAsync();
    public sealed virtual IAsyncEnumerable`1<ValueTuple`3<string, long, long>> GetIdentitiesAsync();
    public sealed virtual IAsyncEnumerable`1<ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject>> GetCompareExchangeValuesAsync();
    public sealed virtual IAsyncEnumerable`1<ValueTuple`2<CompareExchangeKey, long>> GetCompareExchangeTombstonesAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetCounterValuesAsync>d__48")]
public sealed virtual IAsyncEnumerable`1<CounterGroupDetail> GetCounterValuesAsync(List`1<string> collectionsToExport, ICounterActions actions);
    [IteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetCounterValuesFromCollections>d__49")]
private IEnumerable`1<CounterGroupDetail> GetCounterValuesFromCollections(DocumentsOperationContext context, CountersIterationState state);
    public sealed virtual IAsyncEnumerable`1<ValueTuple`2<string, ReplicationHubAccess>> GetReplicationHubCertificatesAsync();
    public sealed virtual IAsyncEnumerable`1<SubscriptionState> GetSubscriptionsAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetTimeSeriesAsync>d__52")]
public sealed virtual IAsyncEnumerable`1<TimeSeriesItem> GetTimeSeriesAsync(ITimeSeriesActions action, List`1<string> collectionsToExport);
    [IteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetAllTimeSeriesItems>d__53")]
private static IEnumerable`1<TimeSeriesItem> GetAllTimeSeriesItems(DocumentsOperationContext context, long startEtag);
    [IteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetTimeSeriesFromCollections>d__54")]
private static IEnumerable`1<TimeSeriesItem> GetTimeSeriesFromCollections(DocumentsOperationContext context, TimeSeriesIterationState state);
    public sealed virtual Task`1<long> SkipTypeAsync(DatabaseItemType type, Action`1<long> onSkipped, CancellationToken token);
    public sealed virtual SmugglerSourceType GetSourceType();
    public sealed virtual IAsyncEnumerable`1<TimeSeriesDeletedRangeItemForSmuggler> GetTimeSeriesDeletedRangesAsync(ITimeSeriesActions action, List`1<string> collectionsToExport);
    [IteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetTimeSeriesDeletedRanges>d__58")]
private IEnumerable`1<TimeSeriesDeletedRangeItemForSmuggler> GetTimeSeriesDeletedRanges(IEnumerable`1<string> collectionsToExport);
    [IteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetAlTimeSeriesDeletedRanges>d__59")]
private static IEnumerable`1<TimeSeriesDeletedRangeItemForSmuggler> GetAlTimeSeriesDeletedRanges(DocumentsOperationContext context, long startEtag);
    [IteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.DatabaseSource/<GetTimeSeriesDeletedRangesFromCollections>d__60")]
private static IEnumerable`1<TimeSeriesDeletedRangeItemForSmuggler> GetTimeSeriesDeletedRangesFromCollections(DocumentsOperationContext context, TimeSeriesDeletedRangeIterationState state);
    [CompilerGeneratedAttribute]
private void <InitializeAsync>b__28_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<Document> <GetDocumentsAsync>b__31_0(DocumentsIterationState state);
    [CompilerGeneratedAttribute]
private long <GetDocumentsAsync>b__31_2(string x);
    [CompilerGeneratedAttribute]
private IEnumerable`1<Tombstone> <GetTombstonesAsync>b__40_0(TombstonesIterationState state);
    [CompilerGeneratedAttribute]
private long <GetTombstonesAsync>b__40_2(string x);
    [CompilerGeneratedAttribute]
private IEnumerable`1<CounterGroupDetail> <GetCounterValuesAsync>b__48_0(CountersIterationState state);
    [CompilerGeneratedAttribute]
private long <GetCounterValuesAsync>b__48_2(string x);
    [CompilerGeneratedAttribute]
private long <GetTimeSeriesAsync>b__52_2(string x);
    [CompilerGeneratedAttribute]
private IEnumerable`1<TimeSeriesItem> <GetTimeSeriesAsync>b__52_0(TimeSeriesIterationState state);
    [CompilerGeneratedAttribute]
private long <GetTimeSeriesDeletedRanges>b__58_2(string x);
    [CompilerGeneratedAttribute]
private IEnumerable`1<TimeSeriesDeletedRangeItemForSmuggler> <GetTimeSeriesDeletedRanges>b__58_0(TimeSeriesDeletedRangeIterationState state);
}
public class Raven.Server.Smuggler.Documents.DocumentItem : object {
    public Document Document;
    public List`1<AttachmentStream> Attachments;
    public Tombstone Tombstone;
    public DocumentConflict Conflict;
}
public class Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler : DatabaseRequestHandler {
    public static RavenHttpClient HttpClient;
    private static SmugglerHandler();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<ValidateOptions>d__1")]
[RavenActionAttribute("/databases/*/smuggler/validate-options", "POST", "3", "1", "False", "False", "True", "0")]
public Task ValidateOptions();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<PostExport>d__2")]
[RavenActionAttribute("/databases/*/smuggler/export", "POST", "3", "1", "False", "False", "True", "0")]
public Task PostExport();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<GetImport>d__3")]
[RavenActionAttribute("/databases/*/admin/smuggler/import", "GET", "2", "False", "False", "True", "0")]
public Task GetImport();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<PostImportFromS3Directory>d__4")]
[RavenActionAttribute("/databases/*/admin/smuggler/import-s3-dir", "GET", "2", "False", "False", "True", "0")]
public Task PostImportFromS3Directory();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<PostImportDirectory>d__5")]
[RavenActionAttribute("/databases/*/admin/smuggler/import-dir", "GET", "2", "False", "False", "True", "0")]
public Task PostImportDirectory();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<BulkImport>d__6")]
private Task BulkImport(BlockingCollection`1<Func`1<Task`1<Stream>>> files, string directory);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<MigrateFromRavenDB>d__7")]
[RavenActionAttribute("/databases/*/admin/smuggler/migrate/ravendb", "POST", "2", "False", "False", "True", "0")]
public Task MigrateFromRavenDB();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<GetMigratedServerUrls>d__8")]
[RavenActionAttribute("/databases/*/migrate/get-migrated-server-urls", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetMigratedServerUrls();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<MigrateFromAnotherDatabase>d__9")]
[RavenActionAttribute("/databases/*/admin/smuggler/migrate", "POST", "2", "False", "False", "True", "0")]
public Task MigrateFromAnotherDatabase();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<ExitWithException>d__10")]
private static Task ExitWithException(Task`1<string> errorReadTask, Exception exception);
    private FileInfo ResolveMigratorPath(string migratorPath);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<PostImportAsync>d__12")]
[RavenActionAttribute("/databases/*/smuggler/import", "POST", "3", "2", "False", "False", "True", "0")]
public Task PostImportAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<ImportFromCsv>d__13")]
[RavenActionAttribute("/databases/*/smuggler/import/csv", "POST", "3", "2", "False", "False", "True", "0")]
public Task ImportFromCsv();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<ImportDocumentsFromCsvStreamAsync>d__14")]
private Task ImportDocumentsFromCsvStreamAsync(Stream stream, DocumentsOperationContext context, string entity, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, OperationCancelToken token, CsvImportOptions csvConfig);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.Handlers.SmugglerHandler/<DoImportInternalAsync>d__15")]
public Task`1<SmugglerResult> DoImportInternalAsync(JsonOperationContext context, Stream stream, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, long operationId, OperationCancelToken token);
}
public abstract class Raven.Server.Smuggler.Documents.Iteration.CollectionAwareIterationState`1 : PulsedEnumerationState`1<T> {
    public long StartEtag;
    public Dictionary`2<string, long> StartEtagByCollection;
    public string CurrentCollection;
    protected CollectionAwareIterationState`1(DocumentsOperationContext context, Size pulseLimit);
}
public class Raven.Server.Smuggler.Documents.Iteration.CountersIterationState : CollectionAwareIterationState`1<CounterGroupDetail> {
    public CountersIterationState(DocumentsOperationContext context, Size pulseLimit);
    public virtual void OnMoveNext(CounterGroupDetail current);
}
public class Raven.Server.Smuggler.Documents.Iteration.DocumentConflictsIterationState : PulsedEnumerationState`1<DocumentConflict> {
    public long StartEtag;
    public DocumentConflictsIterationState(DocumentsOperationContext context, Size pulseLimit);
    public virtual void OnMoveNext(DocumentConflict current);
}
public class Raven.Server.Smuggler.Documents.Iteration.DocumentsIterationState : CollectionAwareIterationState`1<Document> {
    public DocumentsIterationState(DocumentsOperationContext context, Size pulseLimit);
    public virtual void OnMoveNext(Document current);
}
public class Raven.Server.Smuggler.Documents.Iteration.TimeSeriesDeletedRangeIterationState : CollectionAwareIterationState`1<TimeSeriesDeletedRangeItemForSmuggler> {
    public TimeSeriesDeletedRangeIterationState(DocumentsOperationContext context, Size pulseLimit);
    public virtual void OnMoveNext(TimeSeriesDeletedRangeItemForSmuggler current);
}
public class Raven.Server.Smuggler.Documents.Iteration.TimeSeriesIterationState : CollectionAwareIterationState`1<TimeSeriesItem> {
    public TimeSeriesIterationState(DocumentsOperationContext context, Size pulseLimit);
    public virtual void OnMoveNext(TimeSeriesItem current);
}
public class Raven.Server.Smuggler.Documents.Iteration.TombstonesIterationState : CollectionAwareIterationState`1<Tombstone> {
    public TombstonesIterationState(DocumentsOperationContext context, Size pulseLimit);
    public virtual void OnMoveNext(Tombstone current);
}
public class Raven.Server.Smuggler.Documents.MultiShardedDestination : object {
    private ShardedDatabaseContext _databaseContext;
    private ShardedDatabaseRequestHandler _handler;
    private long _operationId;
    private ISmugglerSource _source;
    private Dictionary`2<int, StreamDestination> _destinations;
    private DatabaseSmugglerOptionsServerSide _options;
    private ByteStringContext _allocator;
    public MultiShardedDestination(ISmugglerSource source, ShardedDatabaseContext databaseContext, ShardedDatabaseRequestHandler handler, long operationId);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.MultiShardedDestination/<InitializeAsync>d__8")]
public sealed virtual ValueTask`1<IAsyncDisposable> InitializeAsync(DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, long buildVersion);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.MultiShardedDestination/<PrepareShardStreamDestination>d__9")]
private Task PrepareShardStreamDestination(Dictionary`2<int, StreamDestinationHolder> holders, int shardNumber, SmugglerResult result, Action`1<IOperationProgress> onProgress, long buildVersion);
    public sealed virtual IDatabaseRecordActions DatabaseRecord();
    public sealed virtual IIndexActions Indexes();
    public sealed virtual IKeyValueActions`1<long> Identities();
    public sealed virtual ISubscriptionActions Subscriptions();
    public sealed virtual IReplicationHubCertificateActions ReplicationHubCertificates();
    public sealed virtual ICompareExchangeActions CompareExchange(string databaseName, JsonOperationContext context, Nullable`1<BackupKind> backupKind, bool withDocuments);
    public sealed virtual ICompareExchangeActions CompareExchangeTombstones(string databaseName, JsonOperationContext context);
    public sealed virtual IDocumentActions Documents(bool throwOnCollectionMismatchError);
    public sealed virtual IDocumentActions RevisionDocuments();
    public sealed virtual IDocumentActions Tombstones();
    public sealed virtual IDocumentActions Conflicts();
    public sealed virtual ICounterActions Counters(SmugglerResult result);
    public sealed virtual ITimeSeriesActions TimeSeries();
    public sealed virtual ITimeSeriesActions TimeSeriesDeletedRanges();
    public sealed virtual ILegacyActions LegacyDocumentDeletions();
    public sealed virtual ILegacyActions LegacyAttachmentDeletions();
}
public class Raven.Server.Smuggler.Documents.OrchestratorStreamSource : StreamSource {
    private int _numberOfShards;
    private ConcurrentDictionary`2<Slice, UniqueStreamValue> _uniqueStreams;
    public OrchestratorStreamSource(Stream stream, JsonOperationContext context, string databaseName, int numberOfShards, DatabaseSmugglerOptionsServerSide options);
    public virtual Stream GetAttachmentStream(LazyStringValue hash, String& tag);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.OrchestratorStreamSource/<ProcessAttachmentStreamAsync>d__4")]
public virtual Task`1<AttachmentStream> ProcessAttachmentStreamAsync(JsonOperationContext context, BlittableJsonReaderObject data, INewDocumentActions actions);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<AttachmentStream> <>n__0(JsonOperationContext context, BlittableJsonReaderObject data, INewDocumentActions actions);
}
public static class Raven.Server.Smuggler.Documents.Processors.BuildVersion : object {
    public static BuildVersionType Type(long buildVersion);
}
public enum Raven.Server.Smuggler.Documents.Processors.BuildVersionType : Enum {
    public int value__;
    public static BuildVersionType Unknown;
    public static BuildVersionType V3;
    public static BuildVersionType V4;
    public static BuildVersionType V5;
    public static BuildVersionType V6;
    public static BuildVersionType GreaterThanCurrent;
}
public static class Raven.Server.Smuggler.Documents.Processors.IndexProcessor : object {
    public static object ReadIndexDefinition(BlittableJsonReaderObject reader, BuildVersionType buildVersionType, IndexType& type);
    public static void Import(BlittableJsonReaderObject indexDefinitionDoc, DocumentDatabase database, BuildVersionType buildType, bool removeAnalyzers);
    private static IndexType ReadIndexType(BlittableJsonReaderObject reader, BlittableJsonReaderObject& indexDef);
    private static IndexDefinition ReadLegacyIndexDefinition(BlittableJsonReaderObject reader);
    private static string ReplaceLegacyProperties(string str);
    private static bool IsFunctionValid(string function, String& message);
}
public class Raven.Server.Smuggler.Documents.ServerSmugglerPatcher : SmugglerPatcher {
    public ServerSmugglerPatcher(DatabaseSmugglerOptions options, ServerStore server);
}
public class Raven.Server.Smuggler.Documents.ShardedDatabaseSmuggler : SmugglerBase {
    private DatabaseRecord _databaseRecord;
    private ServerStore _server;
    public ShardedDatabaseSmuggler(ISmugglerSource source, ISmugglerDestination destination, JsonOperationContext jsonOperationContext, DatabaseRecord databaseRecord, ServerStore server, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
    public virtual SmugglerPatcher CreatePatcher();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.ShardedDatabaseSmuggler/<ProcessDatabaseRecordAsync>d__4")]
protected virtual Task`1<DatabaseRecordProgress> ProcessDatabaseRecordAsync(SmugglerResult result);
    protected virtual void SkipDatabaseRecordTypesIfNeeded(DatabaseRecord databaseRecord, SmugglerResult result, DatabaseRecordItemType databaseRecordItemType);
    protected virtual bool ShouldSkipIndex(IndexDefinitionAndType index, String& msg);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.ShardedDatabaseSmuggler/<ProcessIdentitiesAsync>d__7")]
protected virtual Task`1<Counts> ProcessIdentitiesAsync(SmugglerResult result, BuildVersionType buildType);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.ShardedDatabaseSmuggler/<ProcessCompareExchangeAsync>d__8")]
protected virtual Task`1<Counts> ProcessCompareExchangeAsync(SmugglerResult result, string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.ShardedDatabaseSmuggler/<ProcessCompareExchangeTombstonesAsync>d__9")]
protected virtual Task`1<Counts> ProcessCompareExchangeTombstonesAsync(SmugglerResult result, string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.ShardedDatabaseSmuggler/<ProcessSubscriptionsAsync>d__10")]
protected virtual Task`1<Counts> ProcessSubscriptionsAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.ShardedDatabaseSmuggler/<ProcessReplicationHubCertificatesAsync>d__11")]
protected virtual Task`1<Counts> ProcessReplicationHubCertificatesAsync(SmugglerResult result);
    [CompilerGeneratedAttribute]
internal static void <SkipDatabaseRecordTypesIfNeeded>g__AddWarning|5_0(DatabaseRecordItemType type, string name, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static void <SkipDatabaseRecordTypesIfNeeded>g__AddMentorNodeWarning|5_1(DatabaseRecordItemType type, string name, <>c__DisplayClass5_0& );
}
public class Raven.Server.Smuggler.Documents.ShardedDatabaseSource : DatabaseSource {
    private ShardedDocumentDatabase _database;
    public ShardedDatabaseSource(ShardedDocumentDatabase database, long startDocumentEtag, long startRaftIndex, Logger logger);
    protected virtual DatabaseRecord ReadDatabaseRecord();
}
internal class Raven.Server.Smuggler.Documents.SingleShardDatabaseSmuggler : DatabaseSmuggler {
    private int _index;
    private bool _processCompareExchange;
    private ByteStringContext _allocator;
    private ShardingConfiguration _sharding;
    public SingleShardDatabaseSmuggler(ShardedDocumentDatabase database, ISmugglerSource source, ISmugglerDestination destination, SystemTime time, JsonOperationContext context, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
    private void Initialize();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SingleShardDatabaseSmuggler/<InternalProcessCompareExchangeAsync>d__6")]
protected virtual Task InternalProcessCompareExchangeAsync(SmugglerResult result, ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject> kvp, ICompareExchangeActions actions);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SingleShardDatabaseSmuggler/<InternalProcessCompareExchangeTombstonesAsync>d__7")]
protected virtual Task InternalProcessCompareExchangeTombstonesAsync(SmugglerResult result, ValueTuple`2<CompareExchangeKey, long> key, ICompareExchangeActions actions);
    private bool SkipCompareExchange(CompareExchangeKey key);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SingleShardDatabaseSmuggler/<ExecuteAsync>d__9")]
public virtual Task`1<SmugglerResult> ExecuteAsync(bool ensureStepsProcessed, bool isLastFile);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(SmugglerResult result, ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject> kvp, ICompareExchangeActions actions);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(SmugglerResult result, ValueTuple`2<CompareExchangeKey, long> key, ICompareExchangeActions actions);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<SmugglerResult> <>n__2(bool ensureStepsProcessed, bool isLastFile);
}
public abstract class Raven.Server.Smuggler.Documents.SmugglerBase : object {
    private string _databaseName;
    internal ISmugglerSource _source;
    internal DatabaseSmugglerOptionsServerSide _options;
    internal SmugglerResult _result;
    internal SystemTime _time;
    internal Action`1<IOperationProgress> _onProgress;
    internal CancellationToken _token;
    protected JsonOperationContext _context;
    public Action`1<DatabaseRecord> OnDatabaseRecordAction;
    public Action`1<IndexDefinitionAndType> OnIndexAction;
    public BackupKind BackupKind;
    internal ISmugglerDestination _destination;
    private SmugglerPatcher _patcher;
    protected SmugglerBase(string databaseName, ISmugglerSource source, ISmugglerDestination destination, SystemTime time, JsonOperationContext context, DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
    public abstract virtual SmugglerPatcher CreatePatcher();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ExecuteAsync>d__15")]
public virtual Task`1<SmugglerResult> ExecuteAsync(bool ensureStepsProcessed, bool isLastFile);
    internal void ModifyV41OperateOnTypes(long buildVersion, bool isLastFile);
    public static void EnsureProcessed(SmugglerResult result, bool skipped, Nullable`1<bool> indexesSkipped);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessTypeAsync>d__18")]
protected virtual Task ProcessTypeAsync(DatabaseItemType type, SmugglerResult result, BuildVersionType buildType, bool ensureStepsProcessed);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<SkipTypeAsync>d__19")]
internal Task SkipTypeAsync(DatabaseItemType type, SmugglerResult result, bool ensureStepProcessed);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessDocumentsAsync>d__20")]
protected virtual Task`1<Counts> ProcessDocumentsAsync(SmugglerResult result, BuildVersionType buildType);
    protected virtual Task`1<DatabaseRecordProgress> ProcessDatabaseRecordAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessRevisionDocumentsAsync>d__22")]
protected virtual Task`1<Counts> ProcessRevisionDocumentsAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessTombstonesAsync>d__23")]
protected virtual Task`1<Counts> ProcessTombstonesAsync(SmugglerResult result, BuildVersionType buildType);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessDocumentsWithDuplicateCollectionAsync>d__24")]
protected virtual Task ProcessDocumentsWithDuplicateCollectionAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessConflictsAsync>d__25")]
protected virtual Task`1<Counts> ProcessConflictsAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessIndexesAsync>d__26")]
private Task`1<Counts> ProcessIndexesAsync(SmugglerResult result);
    protected virtual bool ShouldSkipIndex(IndexDefinitionAndType index, String& msg);
    protected virtual Task`1<Counts> ProcessIdentitiesAsync(SmugglerResult result, BuildVersionType buildType);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessLegacyAttachmentsAsync>d__29")]
protected virtual Task`1<Counts> ProcessLegacyAttachmentsAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessLegacyAttachmentDeletionsAsync>d__30")]
protected virtual Task`1<Counts> ProcessLegacyAttachmentDeletionsAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessLegacyDocumentDeletionsAsync>d__31")]
protected virtual Task`1<Counts> ProcessLegacyDocumentDeletionsAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessCountersAsync>d__32")]
protected virtual Task`1<Counts> ProcessCountersAsync(SmugglerResult result);
    protected virtual Task`1<Counts> ProcessSubscriptionsAsync(SmugglerResult result);
    protected virtual Task`1<Counts> ProcessReplicationHubCertificatesAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessTimeSeriesAsync>d__35")]
protected virtual Task`1<Counts> ProcessTimeSeriesAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessTimeSeriesDeletedRangesAsync>d__36")]
protected virtual Task`1<Counts> ProcessTimeSeriesDeletedRangesAsync(SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessDatabaseRecordInternalAsync>d__37")]
protected Task`1<DatabaseRecordProgress> ProcessDatabaseRecordInternalAsync(SmugglerResult result, IDatabaseRecordActions action);
    protected virtual void SkipDatabaseRecordTypesIfNeeded(DatabaseRecord databaseRecord, SmugglerResult result, DatabaseRecordItemType databaseRecordItemType);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessIdentitiesInternalAsync>d__39")]
protected Task`1<Counts> ProcessIdentitiesInternalAsync(SmugglerResult result, BuildVersionType buildType, IKeyValueActions`1<long> action);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessSubscriptionsInternalAsync>d__40")]
protected Task`1<Counts> ProcessSubscriptionsInternalAsync(SmugglerResult result, ISubscriptionActions action);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<ProcessReplicationHubCertificatesInternalAsync>d__41")]
protected Task`1<Counts> ProcessReplicationHubCertificatesInternalAsync(SmugglerResult result, IReplicationHubCertificateActions action);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<TryHandleLegacyDocumentTombstonesAsync>d__42")]
protected Task TryHandleLegacyDocumentTombstonesAsync(List`1<LazyStringValue> legacyIdsToDelete, IDocumentActions actions, SmugglerResult result);
    protected void AddInfoToSmugglerResult(SmugglerResult result, string message);
    protected void SetDocumentOrTombstoneFlags(DocumentFlags& flags, NonPersistentDocumentFlags& nonPersistentFlags, BuildVersionType buildType);
    protected static void SkipDocument(DocumentItem item, CountsWithSkippedCountAndLastEtagAndAttachments counts);
    protected bool SkipDocument(BuildVersionType buildType, bool isPreV4Revision, DocumentItem item, SmugglerResult result, List`1& legacyIdsToDelete);
    protected static bool CanSkipDocument(Document document, BuildVersionType buildType);
    [DoesNotReturnAttribute]
protected static void ThrowInvalidData();
    protected abstract virtual Task`1<Counts> ProcessCompareExchangeTombstonesAsync(SmugglerResult result, string databaseName);
    protected abstract virtual Task`1<Counts> ProcessCompareExchangeAsync(SmugglerResult result, string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.SmugglerBase/<WriteIndexAsync>d__51")]
private ValueTask WriteIndexAsync(SmugglerResult result, IndexDefinition indexDefinition, IIndexActions actions);
    [CompilerGeneratedAttribute]
internal static void <EnsureProcessed>g__EnsureStepProcessed|17_0(Counts counts, bool skipped);
    [CompilerGeneratedAttribute]
internal static bool <ProcessRevisionDocumentsAsync>g__ShouldSkip|22_0(DocumentItem item, SmugglerPatcher patcher);
    [CompilerGeneratedAttribute]
internal static bool <ProcessCountersAsync>g__ShouldSkip|32_0(CounterGroupDetail counterGroup, SmugglerPatcher patcher);
    [CompilerGeneratedAttribute]
internal static bool <ProcessTimeSeriesAsync>g__ShouldSkip|35_0(TimeSeriesItem ts, SmugglerPatcher patcher, bool isFullBackup);
    [CompilerGeneratedAttribute]
internal static bool <ProcessTimeSeriesDeletedRangesAsync>g__ShouldSkip|36_0(TimeSeriesDeletedRangeItemForSmuggler deletedRange, SmugglerPatcher patcher);
}
public abstract class Raven.Server.Smuggler.Documents.SmugglerPatcher : object {
    private DatabaseSmugglerOptions _options;
    private ScriptRunnerCache _cache;
    private SingleRun _run;
    private HashSet`1<string> _skippedDocumentIds;
    protected SmugglerPatcher(DatabaseSmugglerOptions options, ScriptRunnerCache cache);
    public Document Transform(Document document);
    public bool ShouldSkip(LazyStringValue documentId);
    public IDisposable Initialize();
}
public class Raven.Server.Smuggler.Documents.SnapshotDatabaseDestination : DatabaseDestination {
    private Dictionary`2<string, SubscriptionState> _subscriptions;
    public SnapshotDatabaseDestination(DocumentDatabase database, Dictionary`2<string, SubscriptionState> subscriptions, CancellationToken token);
    public virtual ISubscriptionActions Subscriptions();
}
public class Raven.Server.Smuggler.Documents.StreamDestination : object {
    private Stream _stream;
    private Stream _outputStream;
    private JsonOperationContext _context;
    private ISmugglerSource _source;
    private CompressionLevel _compressionLevel;
    private ExportCompressionAlgorithm _compressionAlgorithm;
    private AsyncBlittableJsonTextWriter _writer;
    private DatabaseSmugglerOptionsServerSide _options;
    private Func`2<LazyStringValue, bool> _filterMetadataProperty;
    public StreamDestination(Stream stream, JsonOperationContext context, ISmugglerSource source, ExportCompressionAlgorithm compressionAlgorithm, CompressionLevel compressionLevel);
    public sealed virtual ValueTask`1<IAsyncDisposable> InitializeAsync(DatabaseSmugglerOptionsServerSide options, SmugglerResult result, Action`1<IOperationProgress> onProgress, long buildVersion);
    private IAsyncDisposable InitializeAsyncDispose();
    private void SetupMetadataFilterMethod(JsonOperationContext context);
    public sealed virtual IDatabaseRecordActions DatabaseRecord();
    public sealed virtual IDocumentActions Documents(bool throwOnDuplicateCollection);
    public sealed virtual IDocumentActions RevisionDocuments();
    public sealed virtual IDocumentActions Tombstones();
    public sealed virtual IDocumentActions Conflicts();
    public sealed virtual IKeyValueActions`1<long> Identities();
    public sealed virtual ICompareExchangeActions CompareExchange(string databaseName, JsonOperationContext context, Nullable`1<BackupKind> backupKind, bool withDocuments);
    public sealed virtual ICompareExchangeActions CompareExchangeTombstones(string databaseName, JsonOperationContext context);
    public sealed virtual ICounterActions Counters(SmugglerResult result);
    public sealed virtual ISubscriptionActions Subscriptions();
    public sealed virtual IReplicationHubCertificateActions ReplicationHubCertificates();
    public sealed virtual ITimeSeriesActions TimeSeries();
    public sealed virtual ITimeSeriesActions TimeSeriesDeletedRanges();
    public sealed virtual IIndexActions Indexes();
    public sealed virtual ILegacyActions LegacyDocumentDeletions();
    public sealed virtual ILegacyActions LegacyAttachmentDeletions();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamDestination/<GetTempStreamAsync>d__41")]
public static Task`1<Stream> GetTempStreamAsync(DatabaseSmugglerOptionsServerSide options);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamDestination/<<InitializeAsyncDispose>b__11_0>d")]
[CompilerGeneratedAttribute]
private Task <InitializeAsyncDispose>b__11_0();
}
public class Raven.Server.Smuggler.Documents.StreamSource : object {
    private PeepingTomStream _peepingTomStream;
    private JsonOperationContext _context;
    private Logger _log;
    private MemoryBuffer _buffer;
    private ReturnBuffer _returnBuffer;
    private JsonParserState _state;
    private UnmanagedJsonParser _parser;
    private Nullable`1<DatabaseItemType> _currentType;
    private SmugglerResult _result;
    private BuildVersionType _buildVersionType;
    private bool _readLegacyEtag;
    private Size _totalObjectsRead;
    private DatabaseItemType _operateOnTypes;
    private DatabaseSmugglerOptionsServerSide _options;
    protected ByteStringContext _allocator;
    protected UsageMode Mode;
    private static char RecordSeparator;
    private static string DummyDocumentPrefix;
    public StreamSource(Stream stream, JsonOperationContext context, string databaseName, DatabaseSmugglerOptionsServerSide options);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<InitializeAsync>d__16")]
public sealed virtual Task`1<SmugglerInitializeResult> InitializeAsync(DatabaseSmugglerOptionsServerSide options, SmugglerResult result);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<GetNextTypeAsync>d__17")]
public sealed virtual Task`1<DatabaseItemType> GetNextTypeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<GetDatabaseRecordAsync>d__18")]
public sealed virtual Task`1<DatabaseRecord> GetDatabaseRecordAsync();
    public sealed virtual IAsyncEnumerable`1<ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject>> GetCompareExchangeValuesAsync();
    public sealed virtual IAsyncEnumerable`1<ValueTuple`2<CompareExchangeKey, long>> GetCompareExchangeTombstonesAsync();
    public sealed virtual IAsyncEnumerable`1<CounterGroupDetail> GetCounterValuesAsync(List`1<string> collectionsToExport, ICounterActions actions);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<GetReplicationHubCertificatesAsync>d__22")]
public sealed virtual IAsyncEnumerable`1<ValueTuple`2<string, ReplicationHubAccess>> GetReplicationHubCertificatesAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<GetSubscriptionsAsync>d__23")]
public sealed virtual IAsyncEnumerable`1<SubscriptionState> GetSubscriptionsAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<GetTimeSeriesAsync>d__24")]
public sealed virtual IAsyncEnumerable`1<TimeSeriesItem> GetTimeSeriesAsync(ITimeSeriesActions action, List`1<string> collectionsToOperate);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadSegmentAsync>d__25")]
private Task`1<TimeSeriesValuesSegment> ReadSegmentAsync(ITimeSeriesActions action, int segmentSize);
    private void SetBuffer(UnmanagedJsonParser parser, LazyStringValue value);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<InternalGetCompareExchangeValuesAsync>d__27")]
private IAsyncEnumerable`1<ValueTuple`3<CompareExchangeKey, long, BlittableJsonReaderObject>> InternalGetCompareExchangeValuesAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<InternalGetCompareExchangeTombstonesAsync>d__28")]
private IAsyncEnumerable`1<ValueTuple`2<CompareExchangeKey, long>> InternalGetCompareExchangeTombstonesAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<InternalGetCounterValuesAsync>d__29")]
private IAsyncEnumerable`1<CounterGroupDetail> InternalGetCounterValuesAsync(ICounterActions actions);
    private BlittableJsonReaderObject ConvertToBlob(BlittableJsonReaderObject values, ICounterActions actions);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<SkipTypeAsync>d__31")]
public sealed virtual Task`1<long> SkipTypeAsync(DatabaseItemType type, Action`1<long> onSkipped, CancellationToken token);
    public sealed virtual SmugglerSourceType GetSourceType();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<GetTimeSeriesDeletedRangesAsync>d__33")]
public sealed virtual IAsyncEnumerable`1<TimeSeriesDeletedRangeItemForSmuggler> GetTimeSeriesDeletedRangesAsync(ITimeSeriesActions action, List`1<string> collectionsToExport);
    public sealed virtual IAsyncEnumerable`1<DocumentItem> GetDocumentsAsync(List`1<string> collectionsToOperate, INewDocumentActions actions);
    public sealed virtual IAsyncEnumerable`1<DocumentItem> GetRevisionDocumentsAsync(List`1<string> collectionsToOperate, INewDocumentActions actions);
    public sealed virtual IAsyncEnumerable`1<DocumentItem> GetLegacyAttachmentsAsync(INewDocumentActions actions);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<GetLegacyAttachmentDeletionsAsync>d__37")]
public sealed virtual IAsyncEnumerable`1<string> GetLegacyAttachmentDeletionsAsync();
    public sealed virtual IAsyncEnumerable`1<string> GetLegacyDocumentDeletionsAsync();
    public sealed virtual IAsyncEnumerable`1<Tombstone> GetTombstonesAsync(List`1<string> collectionsToOperate, INewDocumentActions actions);
    public sealed virtual IAsyncEnumerable`1<DocumentConflict> GetConflictsAsync(List`1<string> collectionsToOperate, INewDocumentActions actions);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<GetIndexesAsync>d__41")]
public sealed virtual IAsyncEnumerable`1<IndexDefinitionAndType> GetIndexesAsync();
    public sealed virtual IAsyncEnumerable`1<ValueTuple`3<string, long, long>> GetIdentitiesAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<InternalGetIdentitiesAsync>d__43")]
private IAsyncEnumerable`1<ValueTuple`3<string, long, long>> InternalGetIdentitiesAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadTypeAsync>d__44")]
private Task`1<string> ReadTypeAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadObjectAsync>d__45")]
private Task ReadObjectAsync(BlittableJsonDocumentBuilder builder);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadObjectAsync>d__46")]
private Task ReadObjectAsync(Action`1<BlittableJsonReaderObject> readAction);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadBuildVersionAsync>d__47")]
private Task`1<long> ReadBuildVersionAsync();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<SkipArrayAsync>d__48")]
private Task`1<long> SkipArrayAsync(Action`1<long> onSkipped, Func`2<BlittableJsonReaderObject, Task> additionalSkip, CancellationToken token);
    private Task SkipBlobAsync(BlittableJsonReaderObject reader);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<MaySkipBlobAsync>d__50")]
private Task MaySkipBlobAsync(BlittableJsonReaderObject reader);
    private Task SkipAttachmentStreamAsync(BlittableJsonReaderObject data);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<SkipAsync>d__52")]
private Task SkipAsync(long size);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<SkipObjectAsync>d__53")]
private Task`1<long> SkipObjectAsync(Action`1<long> onSkipped);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadArrayAsync>d__54")]
private IAsyncEnumerable`1<BlittableJsonReaderObject> ReadArrayAsync(INewItemActions actions);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadLegacyDeletionsAsync>d__55")]
private IAsyncEnumerable`1<string> ReadLegacyDeletionsAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadLegacyAttachmentsAsync>d__56")]
private IAsyncEnumerable`1<DocumentItem> ReadLegacyAttachmentsAsync(INewDocumentActions actions);
    private static bool ShouldSkip(LegacyAttachmentDetails attachmentInfo);
    public static BlittableJsonReaderObject WriteDummyDocumentForAttachment(JsonOperationContext context, LegacyAttachmentDetails details);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadDocumentsAsync>d__60")]
private IAsyncEnumerable`1<DocumentItem> ReadDocumentsAsync(List`1<string> collectionsToOperate, INewDocumentActions actions);
    public Task`1<Stream> GetTempStreamAsync();
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadTombstonesAsync>d__62")]
private IAsyncEnumerable`1<Tombstone> ReadTombstonesAsync(List`1<string> collectionsToOperate, INewDocumentActions actions);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ReadConflictsAsync>d__63")]
private IAsyncEnumerable`1<DocumentConflict> ReadConflictsAsync(List`1<string> collectionsToOperate, INewDocumentActions actions);
    internal LegacyAttachmentDetails ProcessLegacyAttachment(JsonOperationContext context, BlittableJsonReaderObject data, AttachmentStream& attachment);
    public static string GetLegacyAttachmentId(string key);
    public static LegacyAttachmentDetails GenerateLegacyAttachmentDetails(JsonOperationContext context, Stream decodedStream, string key, BlittableJsonReaderObject metadata, ByteStringContext byteStringContext, AttachmentStream& attachment);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<ProcessAttachmentStreamAsync>d__70")]
public virtual Task`1<AttachmentStream> ProcessAttachmentStreamAsync(JsonOperationContext context, BlittableJsonReaderObject data, INewDocumentActions actions);
    private BlittableJsonDocumentBuilder CreateBuilder(JsonOperationContext context, BlittableMetadataModifier modifier);
    private static DatabaseItemType GetType(string type);
    public virtual Stream GetAttachmentStream(LazyStringValue hash, String& tag);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <InitializeAsync>b__16_0();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Documents.StreamSource/<<GetTimeSeriesAsync>g__SkipEntryAsync|24_0>d")]
[CompilerGeneratedAttribute]
private Task <GetTimeSeriesAsync>g__SkipEntryAsync|24_0(BlittableJsonReaderObject reader, int size, bool skipDueToReadError);
    [CompilerGeneratedAttribute]
private void <ReadTombstonesAsync>g__SkipEntry|62_0(BlittableJsonReaderObject data);
    [CompilerGeneratedAttribute]
private void <ReadConflictsAsync>g__SkipEntry|63_0(BlittableJsonReaderObject data);
}
public class Raven.Server.Smuggler.Documents.TimeSeriesDeletedRangeItemForSmuggler : object {
    public LazyStringValue DocId;
    public LazyStringValue Name;
    public LazyStringValue Collection;
    public LazyStringValue ChangeVector;
    public DateTime From;
    public DateTime To;
    public long Etag;
    public sealed virtual void Dispose();
}
public class Raven.Server.Smuggler.Documents.TimeSeriesItem : object {
    public LazyStringValue DocId;
    public string Name;
    public string ChangeVector;
    public TimeSeriesValuesSegment Segment;
    public int SegmentSize;
    public LazyStringValue Collection;
    public DateTime Baseline;
    public long Etag;
    public sealed virtual void Dispose();
}
public abstract class Raven.Server.Smuggler.Migration.AbstractLegacyMigrator : AbstractMigrator {
    protected AbstractLegacyMigrator(MigratorOptions options, MigratorParameters parameters, AuthorizationStatus authorizationStatus);
    protected LastEtagsInfo GetLastMigrationState();
    protected LastEtagsInfo GenerateLastEtagsInfo();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.AbstractLegacyMigrator/<SaveLastOperationState>d__3")]
protected Task SaveLastOperationState(LastEtagsInfo lastEtagsInfo);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.AbstractLegacyMigrator/<GetResourcesToMigrate>d__4")]
public static Task`1<List`1<string>> GetResourcesToMigrate(string serverUrl, RavenHttpClient httpClient, bool isRavenFs, string apiKey, bool enableBasicAuthenticationOverUnsecuredHttp, bool skipServerCertificateValidation, Reference`1<bool> isLegacyOAuthToken, CancellationToken cancelToken);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.AbstractLegacyMigrator/<WriteDocumentWithAttachmentAsync>d__5")]
protected ValueTask WriteDocumentWithAttachmentAsync(IDocumentActions documentActions, JsonOperationContext context, Stream dataStream, string key, BlittableJsonReaderObject metadata);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.AbstractLegacyMigrator/<RunWithAuthRetry>d__6")]
protected Task`1<HttpResponseMessage> RunWithAuthRetry(Func`1<Task`1<HttpResponseMessage>> requestOperation);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.AbstractLegacyMigrator/<RunWithAuthRetryInternal>d__7")]
private static Task`1<HttpResponseMessage> RunWithAuthRetryInternal(Func`1<Task`1<HttpResponseMessage>> requestOperation, string apiKey, string serverUrl, bool enableBasicAuthenticationOverUnsecuredHttp, bool skipServerCertificateValidation, RavenHttpClient httpClient, Reference`1<bool> isLegacyOAuthToken);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.AbstractLegacyMigrator/<GetOAuthToken>d__8")]
private static Task`1<string> GetOAuthToken(HttpResponseMessage unauthorizedResponse, string apiKey, string serverUrl, bool enableBasicAuthenticationOverUnsecuredHttp, bool skipServerCertificateValidation, Reference`1<bool> isLegacyOAuthToken);
    private static void SetAuthorization(RavenHttpClient httpClient, string oAuthToken);
}
public abstract class Raven.Server.Smuggler.Migration.AbstractMigrator : object {
    protected MigratorOptions Options;
    protected MigratorParameters Parameters;
    protected AuthorizationStatus AuthorizationStatus;
    protected AbstractMigrator(MigratorOptions options, MigratorParameters parameters, AuthorizationStatus authorizationStatus);
    public abstract virtual Task Execute();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.AbstractMigrator/<SaveLastOperationState>d__5")]
protected Task SaveLastOperationState(BlittableJsonReaderObject blittable);
}
internal class Raven.Server.Smuggler.Migration.ApiKey.ABCDStruct : ValueType {
    public UInt32 A;
    public UInt32 B;
    public UInt32 C;
    public UInt32 D;
}
public class Raven.Server.Smuggler.Migration.ApiKey.Authenticator : object {
    private static string BasicOAuthOverHttpError;
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.ApiKey.Authenticator/<GetOAuthToken>d__0")]
public static Task`1<string> GetOAuthToken(string baseUrl, string oauthSource, string apiKey, bool skipServerCertificateValidation);
    public static ValueTuple`2<string, string> GetApiKeyParts(string apiKey);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.ApiKey.Authenticator/<GetLegacyOAuthToken>d__2")]
public static Task`1<string> GetLegacyOAuthToken(string oauthSource, string apiKey, bool enableBasicAuthenticationOverUnsecuredHttp);
}
[ExtensionAttribute]
public static class Raven.Server.Smuggler.Migration.ApiKey.CryptoTransformExtensions : object {
    [ExtensionAttribute]
public static Byte[] TransformEntireBlock(ICryptoTransform transform, Byte[] data);
}
public class Raven.Server.Smuggler.Migration.ApiKey.DefaultEncryptor : EncryptorBase`3<DefaultHashEncryptor, FipsSymmetricalEncryptor, FipsAsymmetricalEncryptor> {
    [CompilerGeneratedAttribute]
private IHashEncryptor <Hash>k__BackingField;
    public IHashEncryptor Hash { get; protected set; }
    [CompilerGeneratedAttribute]
public virtual IHashEncryptor get_Hash();
    [CompilerGeneratedAttribute]
protected virtual void set_Hash(IHashEncryptor value);
}
public static class Raven.Server.Smuggler.Migration.ApiKey.Encryptor : object {
    [CompilerGeneratedAttribute]
private static IEncryptor <Current>k__BackingField;
    public static IEncryptor Current { get; private set; }
    public static Lazy`1<bool> IsFipsEnabled { get; }
    private static Encryptor();
    [CompilerGeneratedAttribute]
public static IEncryptor get_Current();
    [CompilerGeneratedAttribute]
private static void set_Current(IEncryptor value);
    public static Lazy`1<bool> get_IsFipsEnabled();
    public static void Initialize(bool useFips);
}
public abstract class Raven.Server.Smuggler.Migration.ApiKey.EncryptorBase`3 : object {
    public IHashEncryptor Hash { get; protected set; }
    public abstract virtual IHashEncryptor get_Hash();
    protected abstract virtual void set_Hash(IHashEncryptor value);
    public sealed virtual IHashEncryptor CreateHash();
    public sealed virtual ISymmetricalEncryptor CreateSymmetrical();
    public sealed virtual ISymmetricalEncryptor CreateSymmetrical(int keySize);
    public sealed virtual IAsymmetricalEncryptor CreateAsymmetrical();
    public sealed virtual IAsymmetricalEncryptor CreateAsymmetrical(Byte[] exponent, Byte[] modulus);
    public sealed virtual IAsymmetricalEncryptor CreateAsymmetrical(int keySize);
}
public class Raven.Server.Smuggler.Migration.ApiKey.ErrorResponseException : Exception {
    private HttpResponseMessage response;
    [CompilerGeneratedAttribute]
private string <ResponseString>k__BackingField;
    public HttpResponseMessage Response { get; }
    public HttpStatusCode StatusCode { get; }
    public string ResponseString { get; private set; }
    public ErrorResponseException(ErrorResponseException e, string message);
    public ErrorResponseException(HttpResponseMessage response, string msg, Exception exception);
    public ErrorResponseException(HttpResponseMessage response, string msg, string responseString, Exception inner);
    public HttpResponseMessage get_Response();
    public HttpStatusCode get_StatusCode();
    public static ErrorResponseException FromResponseMessage(HttpResponseMessage response, string msg, bool readErrorString);
    [CompilerGeneratedAttribute]
public string get_ResponseString();
    [CompilerGeneratedAttribute]
private void set_ResponseString(string value);
    public static ErrorResponseException FromException(TaskCanceledException e);
    public static ErrorResponseException FromException(HttpRequestException e);
}
public class Raven.Server.Smuggler.Migration.ApiKey.FipsEncryptor : EncryptorBase`3<FipsHashEncryptor, FipsSymmetricalEncryptor, FipsAsymmetricalEncryptor> {
    [CompilerGeneratedAttribute]
private IHashEncryptor <Hash>k__BackingField;
    public IHashEncryptor Hash { get; protected set; }
    [CompilerGeneratedAttribute]
public virtual IHashEncryptor get_Hash();
    [CompilerGeneratedAttribute]
protected virtual void set_Hash(IHashEncryptor value);
}
public abstract class Raven.Server.Smuggler.Migration.ApiKey.HashEncryptorBase : object {
    [CompilerGeneratedAttribute]
private bool <AllowNonThreadSafeMethods>k__BackingField;
    protected bool AllowNonThreadSafeMethods { get; private set; }
    protected HashEncryptorBase(bool allowNonThreadSafeMethods);
    [CompilerGeneratedAttribute]
protected bool get_AllowNonThreadSafeMethods();
    [CompilerGeneratedAttribute]
private void set_AllowNonThreadSafeMethods(bool value);
    protected Byte[] ComputeHashInternal(HashAlgorithm algorithm, Byte[] bytes, Nullable`1<int> size);
    protected Byte[] ComputeHashInternal(HashAlgorithm algorithm, Byte[] bytes, int offset, int count, Nullable`1<int> size);
    public Byte[] ComputeHash(HashAlgorithm algorithm, Byte[] bytes, Nullable`1<int> size);
    public Byte[] ComputeHash(HashAlgorithm algorithm, Byte[] bytes, int offset, int count, Nullable`1<int> size);
    protected void ThrowNotSupportedExceptionForNonThreadSafeMethod();
}
[ExtensionAttribute]
internal static class Raven.Server.Smuggler.Migration.ApiKey.HttpResponseHeadersExtensions : object {
    [ExtensionAttribute]
public static string GetFirstValue(HttpHeaders headers, string name);
}
public interface Raven.Server.Smuggler.Migration.ApiKey.IAsymmetricalEncryptor {
    public int KeySize { get; public set; }
    public AsymmetricAlgorithm Algorithm { get; }
    public abstract virtual int get_KeySize();
    public abstract virtual void set_KeySize(int value);
    public abstract virtual void ImportParameters(Byte[] exponent, Byte[] modulus);
    public abstract virtual Byte[] Encrypt(Byte[] bytes, bool fOAEP);
    public abstract virtual void ImportCspBlob(Byte[] keyBlob);
    public abstract virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public abstract virtual Byte[] SignHash(Byte[] hash, string str);
    public abstract virtual bool VerifyHash(Byte[] hash, string str, Byte[] signature);
    public abstract virtual Byte[] Decrypt(Byte[] bytes, bool fOAEP);
    public abstract virtual AsymmetricAlgorithm get_Algorithm();
    public abstract virtual void ImportParameters(RSAParameters parameters);
    public abstract virtual RSAParameters ExportParameters(bool includePrivateParameters);
}
public interface Raven.Server.Smuggler.Migration.ApiKey.IEncryptor {
    public IHashEncryptor Hash { get; }
    public abstract virtual IHashEncryptor get_Hash();
    public abstract virtual IHashEncryptor CreateHash();
    public abstract virtual ISymmetricalEncryptor CreateSymmetrical();
    public abstract virtual ISymmetricalEncryptor CreateSymmetrical(int keySize);
    public abstract virtual IAsymmetricalEncryptor CreateAsymmetrical();
    public abstract virtual IAsymmetricalEncryptor CreateAsymmetrical(Byte[] exponent, Byte[] modulus);
    public abstract virtual IAsymmetricalEncryptor CreateAsymmetrical(int keySize);
}
public interface Raven.Server.Smuggler.Migration.ApiKey.IHashEncryptor {
    public int StorageHashSize { get; }
    public abstract virtual int get_StorageHashSize();
    public abstract virtual Byte[] ComputeForOAuth(Byte[] bytes);
    public abstract virtual Byte[] Compute16(Byte[] bytes);
    public abstract virtual Byte[] Compute16(Stream stream);
    public abstract virtual Byte[] Compute16(Byte[] bytes, int offset, int size);
    public abstract virtual Byte[] Compute20(Byte[] bytes);
    public abstract virtual Byte[] Compute20(Byte[] bytes, int offset, int size);
}
public interface Raven.Server.Smuggler.Migration.ApiKey.ISymmetricalEncryptor {
    public Byte[] Key { get; public set; }
    public Byte[] IV { get; public set; }
    public int KeySize { get; public set; }
    public abstract virtual Byte[] get_Key();
    public abstract virtual void set_Key(Byte[] value);
    public abstract virtual Byte[] get_IV();
    public abstract virtual void set_IV(Byte[] value);
    public abstract virtual int get_KeySize();
    public abstract virtual void set_KeySize(int value);
    public abstract virtual void GenerateKey();
    public abstract virtual void GenerateIV();
    public abstract virtual ICryptoTransform CreateEncryptor();
    public abstract virtual ICryptoTransform CreateDecryptor();
    public abstract virtual ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
}
public class Raven.Server.Smuggler.Migration.ApiKey.MD5Core : object {
    public static Byte[] GetHash(string input, Encoding encoding);
    public static Byte[] GetHash(string input);
    public static string GetHashString(Byte[] input);
    public static string GetHashString(string input, Encoding encoding);
    public static string GetHashString(string input);
    internal static ABCDStruct GetInitialStruct();
    public static Byte[] GetHash(Byte[] input);
    public static Byte[] GetHash(Byte[] input, int offset, int length);
    internal static Byte[] GetHashFinalBlock(Byte[] input, int ibStart, int cbSize, ABCDStruct ABCD, long len);
    internal static void GetHashBlock(Byte[] input, ABCDStruct& ABCDValue, int ibStart);
    private static UInt32 r1(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 r2(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 r3(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 r4(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 LSR(UInt32 i, int s);
    private static UInt32[] Converter(Byte[] input, int ibStart);
}
public static class Raven.Server.Smuggler.Migration.ApiKey.OAuthHelper : object {
    [ThreadStaticAttribute]
private static IHashEncryptor sha1;
    public static string Hash(string data);
    public static string EncryptAsymmetric(Byte[] exponent, Byte[] modulus, string data);
    private static Byte[] AddEncryptedKeyAndIv(Byte[] exponent, Byte[] modulus, Byte[] key, Byte[] iv);
    public static Dictionary`2<string, string> ParseDictionary(string data);
    public static string DictionaryToString(Dictionary`2<string, string> data);
    public static Byte[] ParseBytes(string data);
    public static string BytesToString(Byte[] data);
}
[ExtensionAttribute]
internal static class Raven.Server.Smuggler.Migration.ApiKey.TaskExtensions : object {
    [ExtensionAttribute]
public static Task`1<T> AddUrlIfFaulting(Task`1<T> parent, Uri uri);
    [ExtensionAttribute]
public static Task`1<T> ConvertSecurityExceptionToServerNotFound(Task`1<T> parent);
}
[ExtensionAttribute]
public static class Raven.Server.Smuggler.Migration.ApiKey.WebResponseExtensions : object {
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.ApiKey.WebResponseExtensions/<GetResponseStreamWithHttpDecompression>d__0")]
[ExtensionAttribute]
public static Task`1<Stream> GetResponseStreamWithHttpDecompression(HttpResponseMessage response);
}
public class Raven.Server.Smuggler.Migration.ArrayStream : Stream {
    private Stream _baseStream;
    private long _position;
    private MemoryStream _beginningStream;
    private MemoryStream _endingStream;
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public ArrayStream(Stream baseStream, string propertyName);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void CheckDisposed();
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class Raven.Server.Smuggler.Migration.BuildInfo : object {
    [CompilerGeneratedAttribute]
private int <BuildVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private MajorVersion <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullVersion>k__BackingField;
    public int BuildVersion { get; public set; }
    public string ProductVersion { get; public set; }
    public MajorVersion MajorVersion { get; public set; }
    public string FullVersion { get; public set; }
    [CompilerGeneratedAttribute]
public int get_BuildVersion();
    [CompilerGeneratedAttribute]
public void set_BuildVersion(int value);
    [CompilerGeneratedAttribute]
public string get_ProductVersion();
    [CompilerGeneratedAttribute]
public void set_ProductVersion(string value);
    [CompilerGeneratedAttribute]
public MajorVersion get_MajorVersion();
    [CompilerGeneratedAttribute]
public void set_MajorVersion(MajorVersion value);
    [CompilerGeneratedAttribute]
public string get_FullVersion();
    [CompilerGeneratedAttribute]
public void set_FullVersion(string value);
}
public class Raven.Server.Smuggler.Migration.BuildInfoWithResourceNames : BuildInfo {
    [CompilerGeneratedAttribute]
private List`1<string> <DatabaseNames>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <FileSystemNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Authorized>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLegacyOAuthToken>k__BackingField;
    public List`1<string> DatabaseNames { get; public set; }
    public List`1<string> FileSystemNames { get; public set; }
    public bool Authorized { get; public set; }
    public bool IsLegacyOAuthToken { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_DatabaseNames();
    [CompilerGeneratedAttribute]
public void set_DatabaseNames(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_FileSystemNames();
    [CompilerGeneratedAttribute]
public void set_FileSystemNames(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_Authorized();
    [CompilerGeneratedAttribute]
public void set_Authorized(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLegacyOAuthToken();
    [CompilerGeneratedAttribute]
public void set_IsLegacyOAuthToken(bool value);
}
public class Raven.Server.Smuggler.Migration.DatabaseMigrationOptions : object {
    [CompilerGeneratedAttribute]
private ItemType <OperateOnTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExportDeletions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartDocsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartAttachmentsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartDocsDeletionEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartAttachmentsDeletionEtag>k__BackingField;
    public ItemType OperateOnTypes { get; public set; }
    public int BatchSize { get; public set; }
    public bool ExportDeletions { get; public set; }
    public string StartDocsEtag { get; public set; }
    public string StartAttachmentsEtag { get; public set; }
    public string StartDocsDeletionEtag { get; public set; }
    public string StartAttachmentsDeletionEtag { get; public set; }
    [CompilerGeneratedAttribute]
public ItemType get_OperateOnTypes();
    [CompilerGeneratedAttribute]
public void set_OperateOnTypes(ItemType value);
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
    [CompilerGeneratedAttribute]
public bool get_ExportDeletions();
    [CompilerGeneratedAttribute]
public void set_ExportDeletions(bool value);
    [CompilerGeneratedAttribute]
public string get_StartDocsEtag();
    [CompilerGeneratedAttribute]
public void set_StartDocsEtag(string value);
    [CompilerGeneratedAttribute]
public string get_StartAttachmentsEtag();
    [CompilerGeneratedAttribute]
public void set_StartAttachmentsEtag(string value);
    [CompilerGeneratedAttribute]
public string get_StartDocsDeletionEtag();
    [CompilerGeneratedAttribute]
public void set_StartDocsDeletionEtag(string value);
    [CompilerGeneratedAttribute]
public string get_StartAttachmentsDeletionEtag();
    [CompilerGeneratedAttribute]
public void set_StartAttachmentsDeletionEtag(string value);
}
public class Raven.Server.Smuggler.Migration.DatabaseMigrationSettings : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseItemType <OperateOnTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseRecordItemType <OperateOnDatabaseRecordTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveAnalyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImportRavenFs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransformScript>k__BackingField;
    public string DatabaseName { get; public set; }
    public DatabaseItemType OperateOnTypes { get; public set; }
    public DatabaseRecordItemType OperateOnDatabaseRecordTypes { get; public set; }
    public bool RemoveAnalyzers { get; public set; }
    public bool ImportRavenFs { get; public set; }
    public string TransformScript { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public DatabaseItemType get_OperateOnTypes();
    [CompilerGeneratedAttribute]
public void set_OperateOnTypes(DatabaseItemType value);
    [CompilerGeneratedAttribute]
public DatabaseRecordItemType get_OperateOnDatabaseRecordTypes();
    [CompilerGeneratedAttribute]
public void set_OperateOnDatabaseRecordTypes(DatabaseRecordItemType value);
    [CompilerGeneratedAttribute]
public bool get_RemoveAnalyzers();
    [CompilerGeneratedAttribute]
public void set_RemoveAnalyzers(bool value);
    [CompilerGeneratedAttribute]
public bool get_ImportRavenFs();
    [CompilerGeneratedAttribute]
public void set_ImportRavenFs(bool value);
    [CompilerGeneratedAttribute]
public string get_TransformScript();
    [CompilerGeneratedAttribute]
public void set_TransformScript(string value);
}
public class Raven.Server.Smuggler.Migration.DatabasesMigrationConfiguration : MigrationConfigurationBase {
    [CompilerGeneratedAttribute]
private List`1<DatabaseMigrationSettings> <Databases>k__BackingField;
    public List`1<DatabaseMigrationSettings> Databases { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<DatabaseMigrationSettings> get_Databases();
    [CompilerGeneratedAttribute]
public void set_Databases(List`1<DatabaseMigrationSettings> value);
}
public class Raven.Server.Smuggler.Migration.ExportDataV3 : object {
    [CompilerGeneratedAttribute]
private string <SmugglerOptions>k__BackingField;
    public string SmugglerOptions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SmugglerOptions();
    [CompilerGeneratedAttribute]
public void set_SmugglerOptions(string value);
}
public class Raven.Server.Smuggler.Migration.ExportDataV35 : object {
    [CompilerGeneratedAttribute]
private string <DownloadOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProgressTaskId>k__BackingField;
    public string DownloadOptions { get; public set; }
    public long ProgressTaskId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DownloadOptions();
    [CompilerGeneratedAttribute]
public void set_DownloadOptions(string value);
    [CompilerGeneratedAttribute]
public long get_ProgressTaskId();
    [CompilerGeneratedAttribute]
public void set_ProgressTaskId(long value);
}
public class Raven.Server.Smuggler.Migration.Importer : AbstractMigrator {
    private int _buildVersion;
    public Importer(MigratorOptions options, MigratorParameters parameters, int buildVersion, AuthorizationStatus authorizationStatus);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Importer/<Execute>d__2")]
public virtual Task Execute();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Importer/<SaveLastState>d__3")]
private Task SaveLastState(long operationId, ImportInfo previousImportInfo);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Importer/<GetOperationState>d__4")]
private Task`1<BlittableJsonReaderObject> GetOperationState(string databaseName, long operationId, TransactionOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Importer/<MigrateDatabase>d__5")]
private Task MigrateDatabase(long operationId, ImportInfo importInfo);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Importer/<GetOperationId>d__6")]
private Task`1<long> GetOperationId();
    private ImportInfo GetLastImportInfo();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Importer/<GetDatabasesToMigrate>d__8")]
public static Task`1<List`1<string>> GetDatabasesToMigrate(string serverUrl, RavenHttpClient httpClient, CancellationToken cancelToken);
}
public class Raven.Server.Smuggler.Migration.ImportInfo : object {
    [CompilerGeneratedAttribute]
private long <LastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastRaftIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    public long LastEtag { get; public set; }
    public long LastRaftIndex { get; public set; }
    public string ServerUrl { get; public set; }
    public string DatabaseName { get; public set; }
    [CompilerGeneratedAttribute]
public long get_LastEtag();
    [CompilerGeneratedAttribute]
public void set_LastEtag(long value);
    [CompilerGeneratedAttribute]
public long get_LastRaftIndex();
    [CompilerGeneratedAttribute]
public void set_LastRaftIndex(long value);
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
public void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
}
[FlagsAttribute]
public enum Raven.Server.Smuggler.Migration.ItemType : Enum {
    public int value__;
    public static ItemType None;
    public static ItemType Documents;
    public static ItemType Indexes;
    public static ItemType Attachments;
    public static ItemType RemoveAnalyzers;
}
public class Raven.Server.Smuggler.Migration.LastEtagsInfo : object {
    public static string EtagEmpty;
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastDocsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastDocDeleteEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastAttachmentsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastAttachmentsDeleteEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastRavenFsEtag>k__BackingField;
    public string ServerUrl { get; public set; }
    public string DatabaseName { get; public set; }
    public string LastDocsEtag { get; public set; }
    public string LastDocDeleteEtag { get; public set; }
    public string LastAttachmentsEtag { get; public set; }
    public string LastAttachmentsDeleteEtag { get; public set; }
    public string LastRavenFsEtag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
public void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_LastDocsEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocsEtag(string value);
    [CompilerGeneratedAttribute]
public string get_LastDocDeleteEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocDeleteEtag(string value);
    [CompilerGeneratedAttribute]
public string get_LastAttachmentsEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentsEtag(string value);
    [CompilerGeneratedAttribute]
public string get_LastAttachmentsDeleteEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentsDeleteEtag(string value);
    [CompilerGeneratedAttribute]
public string get_LastRavenFsEtag();
    [CompilerGeneratedAttribute]
public void set_LastRavenFsEtag(string value);
}
public enum Raven.Server.Smuggler.Migration.MajorVersion : Enum {
    public int value__;
    public static MajorVersion Unknown;
    [DescriptionAttribute("v2.x")]
public static MajorVersion V2;
    [DescriptionAttribute("v3.0")]
public static MajorVersion V30;
    [DescriptionAttribute("v3.5")]
public static MajorVersion V35;
    [DescriptionAttribute("v4.x")]
public static MajorVersion V4;
    [DescriptionAttribute("v5.x")]
public static MajorVersion V5;
    [DescriptionAttribute("v6.x")]
public static MajorVersion V6;
    [DescriptionAttribute("Greater than current")]
public static MajorVersion GreaterThanCurrent;
}
public class Raven.Server.Smuggler.Migration.MigratedServerUrls : object {
    [CompilerGeneratedAttribute]
private List`1<string> <List>k__BackingField;
    public List`1<string> List { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_List();
    [CompilerGeneratedAttribute]
public void set_List(List`1<string> value);
}
public class Raven.Server.Smuggler.Migration.MigrationConfiguration : object {
    [CompilerGeneratedAttribute]
private string <DatabaseTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MigratorFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private BlittableJsonReaderObject <InputConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransformScript>k__BackingField;
    public string DatabaseTypeName { get; public set; }
    public string MigratorFullPath { get; public set; }
    public BlittableJsonReaderObject InputConfiguration { get; public set; }
    public string TransformScript { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DatabaseTypeName();
    [CompilerGeneratedAttribute]
public void set_DatabaseTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_MigratorFullPath();
    [CompilerGeneratedAttribute]
public void set_MigratorFullPath(string value);
    [CompilerGeneratedAttribute]
public BlittableJsonReaderObject get_InputConfiguration();
    [CompilerGeneratedAttribute]
public void set_InputConfiguration(BlittableJsonReaderObject value);
    [CompilerGeneratedAttribute]
public string get_TransformScript();
    [CompilerGeneratedAttribute]
public void set_TransformScript(string value);
}
public abstract class Raven.Server.Smuggler.Migration.MigrationConfigurationBase : object {
    [CompilerGeneratedAttribute]
private MajorVersion <BuildMajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BuildVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableBasicAuthenticationOverUnsecuredHttp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipServerCertificateValidation>k__BackingField;
    public MajorVersion BuildMajorVersion { get; public set; }
    public int BuildVersion { get; public set; }
    public string ServerUrl { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    public string Domain { get; public set; }
    public string ApiKey { get; public set; }
    public bool EnableBasicAuthenticationOverUnsecuredHttp { get; public set; }
    public bool SkipServerCertificateValidation { get; public set; }
    [CompilerGeneratedAttribute]
public MajorVersion get_BuildMajorVersion();
    [CompilerGeneratedAttribute]
public void set_BuildMajorVersion(MajorVersion value);
    [CompilerGeneratedAttribute]
public int get_BuildVersion();
    [CompilerGeneratedAttribute]
public void set_BuildVersion(int value);
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
public void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
public void set_UserName(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public bool get_EnableBasicAuthenticationOverUnsecuredHttp();
    [CompilerGeneratedAttribute]
public void set_EnableBasicAuthenticationOverUnsecuredHttp(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipServerCertificateValidation();
    [CompilerGeneratedAttribute]
public void set_SkipServerCertificateValidation(bool value);
}
public class Raven.Server.Smuggler.Migration.Migrator : object {
    public static string MigrationStateKeyBase;
    private string _serverUrl;
    private RavenHttpClient _httpClient;
    private ServerStore _serverStore;
    private string _apiKey;
    private bool _enableBasicAuthenticationOverUnsecuredHttp;
    private bool _skipServerCertificateValidation;
    private MajorVersion _buildMajorVersion;
    private int _buildVersion;
    public Migrator(MigrationConfigurationBase configuration, ServerStore serverStore);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator/<UpdateBuildInfoIfNeeded>d__10")]
public Task UpdateBuildInfoIfNeeded();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator/<GetBuildInfo>d__11")]
public Task`1<BuildInfo> GetBuildInfo();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator/<MigrateDatabases>d__12")]
public Task MigrateDatabases(List`1<DatabaseMigrationSettings> databases, AuthorizationStatus authorizationStatus);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator/<GetFileSystemNames>d__13")]
public Task`1<List`1<string>> GetFileSystemNames(MajorVersion buildMajorVersion);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator/<GetDatabaseNames>d__14")]
public Task`1<List`1<string>> GetDatabaseNames(MajorVersion buildMajorVersion, Reference`1<bool> authorized, Reference`1<bool> isLegacyOAuthToken);
    public long StartMigratingSingleDatabase(DatabaseMigrationSettings settings, DocumentDatabase database, AuthorizationStatus authorizationStatus);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator/<CreateDatabaseIfNeeded>d__16")]
private Task CreateDatabaseIfNeeded(string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator/<GetDatabase>d__17")]
private Task`1<DocumentDatabase> GetDatabase(string databaseName);
}
public class Raven.Server.Smuggler.Migration.Migrator_V2 : AbstractLegacyMigrator {
    private static int AttachmentsPageSize;
    public Migrator_V2(MigratorOptions options, MigratorParameters parameters, AuthorizationStatus authorizationStatus);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V2/<Execute>d__2")]
public virtual Task Execute();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V2/<MigrateDocuments>d__3")]
private Task MigrateDocuments(string lastEtag);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V2/<MigrateAttachments>d__4")]
private Task MigrateAttachments(string lastEtag, SmugglerResult parametersResult);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V2/<GetAttachmentsList>d__5")]
private Task`1<BlittableJsonReaderArray> GetAttachmentsList(string lastEtag, TransactionOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V2/<GetAttachmentStream>d__6")]
private Task`1<Stream> GetAttachmentStream(string attachmentKey);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V2/<MigrateIndexes>d__7")]
private Task MigrateIndexes();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V2/<<MigrateIndexes>b__7_0>d")]
[CompilerGeneratedAttribute]
private Task`1<HttpResponseMessage> <MigrateIndexes>b__7_0();
}
public class Raven.Server.Smuggler.Migration.Migrator_V3 : AbstractLegacyMigrator {
    private static int RavenFsHeadersPageSize;
    private MajorVersion _majorVersion;
    private int _buildVersion;
    public Migrator_V3(MigratorOptions options, MigratorParameters parameters, MajorVersion majorVersion, int buildVersion, AuthorizationStatus authorizationStatus);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V3/<Execute>d__4")]
public virtual Task Execute();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V3/<MigrateRavenFs>d__5")]
private Task`1<string> MigrateRavenFs(string lastEtag, SmugglerResult parametersResult);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V3/<GetRavenFsStream>d__6")]
private Task`1<Stream> GetRavenFsStream(string key);
    private BlittableJsonReaderObject GetCleanMetadata(BlittableJsonReaderObject metadata, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V3/<GetRavenFsHeadersArray>d__8")]
private Task`1<BlittableJsonReaderArray> GetRavenFsHeadersArray(string lastEtag, TransactionOperationContext context);
    private ItemType GenerateOperateOnTypes();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V3/<MigrateDatabase>d__10")]
private Task`1<SmugglerResult> MigrateDatabase(string json, bool readLegacyEtag);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V3/<GetOperationId>d__11")]
private Task`1<long> GetOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V3/<GetLastState>d__12")]
private Task`1<LastEtagsInfo> GetLastState(bool canGetLastStateByOperationId, long operationId);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V3/<GetLastStateByOperationId>d__13")]
private Task`1<LastEtagsInfo> GetLastStateByOperationId(long operationId, TransactionOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V3/<GetOperationStatus>d__14")]
private Task`1<BlittableJsonReaderObject> GetOperationStatus(string databaseName, long operationId, TransactionOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Smuggler.Migration.Migrator_V3/<<GetOperationId>b__11_0>d")]
[CompilerGeneratedAttribute]
private Task`1<HttpResponseMessage> <GetOperationId>b__11_0();
}
public class Raven.Server.Smuggler.Migration.MigratorOptions : object {
    [CompilerGeneratedAttribute]
private string <MigrationStateKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransformScript>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableBasicAuthenticationOverUnsecuredHttp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipServerCertificateValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveAnalyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImportRavenFs>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseItemType <OperateOnTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseRecordItemType <OperateOnDatabaseRecordTypes>k__BackingField;
    public string MigrationStateKey { get; public set; }
    public string ServerUrl { get; public set; }
    public string DatabaseName { get; public set; }
    public string ApiKey { get; public set; }
    public string TransformScript { get; public set; }
    public bool EnableBasicAuthenticationOverUnsecuredHttp { get; public set; }
    public bool SkipServerCertificateValidation { get; public set; }
    public bool RemoveAnalyzers { get; public set; }
    public bool ImportRavenFs { get; public set; }
    public DatabaseItemType OperateOnTypes { get; public set; }
    public DatabaseRecordItemType OperateOnDatabaseRecordTypes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_MigrationStateKey();
    [CompilerGeneratedAttribute]
public void set_MigrationStateKey(string value);
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
public void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public string get_TransformScript();
    [CompilerGeneratedAttribute]
public void set_TransformScript(string value);
    [CompilerGeneratedAttribute]
public bool get_EnableBasicAuthenticationOverUnsecuredHttp();
    [CompilerGeneratedAttribute]
public void set_EnableBasicAuthenticationOverUnsecuredHttp(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipServerCertificateValidation();
    [CompilerGeneratedAttribute]
public void set_SkipServerCertificateValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemoveAnalyzers();
    [CompilerGeneratedAttribute]
public void set_RemoveAnalyzers(bool value);
    [CompilerGeneratedAttribute]
public bool get_ImportRavenFs();
    [CompilerGeneratedAttribute]
public void set_ImportRavenFs(bool value);
    [CompilerGeneratedAttribute]
public DatabaseItemType get_OperateOnTypes();
    [CompilerGeneratedAttribute]
public void set_OperateOnTypes(DatabaseItemType value);
    [CompilerGeneratedAttribute]
public DatabaseRecordItemType get_OperateOnDatabaseRecordTypes();
    [CompilerGeneratedAttribute]
public void set_OperateOnDatabaseRecordTypes(DatabaseRecordItemType value);
}
public class Raven.Server.Smuggler.Migration.MigratorParameters : object {
    [CompilerGeneratedAttribute]
private RavenHttpClient <HttpClient>k__BackingField;
    [CompilerGeneratedAttribute]
private SmugglerResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IOperationProgress> <OnProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationCancelToken <CancelToken>k__BackingField;
    public RavenHttpClient HttpClient { get; public set; }
    public SmugglerResult Result { get; public set; }
    public Action`1<IOperationProgress> OnProgress { get; public set; }
    public DocumentDatabase Database { get; public set; }
    public OperationCancelToken CancelToken { get; public set; }
    [CompilerGeneratedAttribute]
public RavenHttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
public void set_HttpClient(RavenHttpClient value);
    [CompilerGeneratedAttribute]
public SmugglerResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(SmugglerResult value);
    [CompilerGeneratedAttribute]
public Action`1<IOperationProgress> get_OnProgress();
    [CompilerGeneratedAttribute]
public void set_OnProgress(Action`1<IOperationProgress> value);
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    [CompilerGeneratedAttribute]
public OperationCancelToken get_CancelToken();
    [CompilerGeneratedAttribute]
public void set_CancelToken(OperationCancelToken value);
}
public class Raven.Server.Smuggler.Migration.SingleDatabaseMigrationConfiguration : MigrationConfigurationBase {
    [CompilerGeneratedAttribute]
private DatabaseMigrationSettings <MigrationSettings>k__BackingField;
    public DatabaseMigrationSettings MigrationSettings { get; public set; }
    [CompilerGeneratedAttribute]
public DatabaseMigrationSettings get_MigrationSettings();
    [CompilerGeneratedAttribute]
public void set_MigrationSettings(DatabaseMigrationSettings value);
}
public static class Raven.Server.Smuggler.MultipartRequestHelper : object {
    private static FormOptions DefaultFormOptions;
    public static int MultipartBoundaryLengthLimit { get; }
    private static MultipartRequestHelper();
    public static int get_MultipartBoundaryLengthLimit();
    public static string GetBoundary(MediaTypeHeaderValue contentType, int lengthLimit);
    public static bool IsMultipartContentType(string contentType);
    public static bool HasFormDataContentDisposition(ContentDispositionHeaderValue contentDisposition);
    public static bool HasFileContentDisposition(ContentDispositionHeaderValue contentDisposition);
    public static Encoding GetEncoding(MultipartSection section);
}
public static class Raven.Server.SqlMigration.DatabaseDriverDispatcher : object {
    public static IDatabaseDriver CreateDriver(MigrationProvider provider, string connectionString, String[] schemas);
}
public abstract class Raven.Server.SqlMigration.GenericDatabaseMigrator : object {
    protected string ConnectionString;
    protected string FactoryName { get; }
    protected GenericDatabaseMigrator(string connectionString);
    public abstract virtual DatabaseSchema FindSchema();
    public sealed virtual ValueTuple`2<BlittableJsonReaderObject, string> Test(MigrationTestSettings settings, DatabaseSchema dbSchema, DocumentsOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.SqlMigration.GenericDatabaseMigrator/<Migrate>d__4")]
public sealed virtual Task Migrate(MigrationSettings settings, DatabaseSchema dbSchema, DocumentDatabase db, DocumentsOperationContext context, MigrationResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
    private static ValueTuple`2<DynamicJsonArray, DynamicJsonValue> BuildEmbeddedSqlKeysDictionary(ReferenceInformation refInfo, List`1<DynamicJsonValue> specialColumnsValues, DynamicJsonValue specialColumns);
    private static string ConvertColumnNameToPascalCase(string columnName);
    private void FillDocumentFields(DynamicJsonValue value, DynamicJsonValue specialColumns, List`1<ReferenceInformation> references, string attachmentNamePrefix, Dictionary`2<string, Byte[]> attachments);
    private string GenerateAttachmentKey(String[] tokens);
    private void DisposeDataProviders(List`1<ReferenceInformation> references);
    private void InitializeDataProviders(List`1<ReferenceInformation> references, DbConnection connection);
    private List`1<ReferenceInformation> ResolveReferences(CollectionWithReferences sourceCollection, DatabaseSchema dbSchema, Func`4<string, string, bool, string> collectionNameProvider);
    private ReferenceInformation CreateReference(DatabaseSchema dbSchema, Func`4<string, string, bool, string> collectionNameProvider, AbstractCollection sourceCollection, ICollectionReference destinationCollection);
    protected Dictionary`2<string, Byte[]> ExtractAttachments(IDataReader reader, Dictionary`2<string, string> attachmentNameMapping);
    public static Object[] GetColumns(DynamicJsonValue columns, List`1<string> columnsToUse);
    protected string GenerateDocumentId(string collection, Object[] values);
    protected DynamicJsonValue ExtractFromReader(DbDataReader reader, IEnumerable`1<string> columnNames);
    protected DynamicJsonValue ExtractFromReader(DbDataReader reader, Dictionary`2<string, string> columnsMapping);
    private object ExtractValue(object value);
    protected abstract virtual string LimitRowsNumber(string inputQuery, Nullable`1<int> rowsLimit);
    protected abstract virtual string GetSelectAllQueryForTable(string tableSchema, string tableName);
    protected abstract virtual string QuoteTable(string schema, string tableName);
    protected abstract virtual string QuoteColumn(string columnName);
    protected abstract virtual string get_FactoryName();
    protected IDataProvider`1<string> CreateObjectLinkDataProvider(ReferenceInformation refInfo);
    protected DbConnection OpenConnection();
    protected virtual string GetQueryByPrimaryKey(RootCollection collection, SqlTableSchema tableSchema, String[] primaryKeyValues, Dictionary`2& queryParameters);
    public object ValueAsObject(SqlTableSchema tableSchema, string column, String[] primaryKeyValue, int index);
    [IteratorStateMachineAttribute("Raven.Server.SqlMigration.GenericDatabaseMigrator/<EnumerateTable>d__29")]
protected IEnumerable`1<SqlMigrationDocument> EnumerateTable(string tableQuery, Dictionary`2<string, string> documentPropertiesMapping, HashSet`1<string> specialColumns, Dictionary`2<string, string> attachmentNameMapping, DbConnection connection, Nullable`1<int> rowsLimit, Dictionary`2<string, object> queryParameters);
    protected virtual IDataProvider`1<DynamicJsonArray> CreateArrayLinkDataProvider(ReferenceInformation refInfo, DbConnection connection);
    protected virtual IDataProvider`1<EmbeddedObjectValue> CreateObjectEmbedDataProvider(ReferenceInformation refInfo, DbConnection connection);
    protected virtual IDataProvider`1<EmbeddedArrayValue> CreateArrayEmbedDataProvider(ReferenceInformation refInfo, DbConnection connection);
    protected string GetQueryForCollection(RootCollection collection);
}
public interface Raven.Server.SqlMigration.IDatabaseDriver {
    public abstract virtual DatabaseSchema FindSchema();
    public abstract virtual ValueTuple`2<BlittableJsonReaderObject, string> Test(MigrationTestSettings settings, DatabaseSchema dbSchema, DocumentsOperationContext context);
    public abstract virtual Task Migrate(MigrationSettings settings, DatabaseSchema schema, DocumentDatabase db, DocumentsOperationContext context, MigrationResult result, Action`1<IOperationProgress> onProgress, CancellationToken token);
}
public interface Raven.Server.SqlMigration.IDataProvider`1 {
    public abstract virtual T Provide(DynamicJsonValue specialColumns);
}
public class Raven.Server.SqlMigration.JsPatcher : object {
    private SingleRun _runner;
    private DocumentsOperationContext _context;
    private ReturnRun scriptRunner;
    public JsPatcher(RootCollection collection, DocumentsOperationContext context);
    public BlittableJsonReaderObject Patch(BlittableJsonReaderObject document);
    public sealed virtual void Dispose();
}
public class Raven.Server.SqlMigration.LocalDataProvider`1 : object {
    private Func`2<DynamicJsonValue, T> _provider;
    public LocalDataProvider`1(Func`2<DynamicJsonValue, T> provider);
    public sealed virtual T Provide(DynamicJsonValue specialColumns);
    public sealed virtual void Dispose();
}
public enum Raven.Server.SqlMigration.MigrationProvider : Enum {
    public int value__;
    public static MigrationProvider MsSQL;
    [ObsoleteAttribute("Unsupported provider. Use 'MySQL_MySqlConnector' instead.")]
public static MigrationProvider MySQL_MySql_Data;
    public static MigrationProvider MySQL_MySqlConnector;
    public static MigrationProvider NpgSQL;
    public static MigrationProvider Oracle;
}
public abstract class Raven.Server.SqlMigration.Model.AbstractCollection : object {
    [CompilerGeneratedAttribute]
private string <SourceTableSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceTableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ColumnsMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AttachmentNameMapping>k__BackingField;
    public string SourceTableSchema { get; public set; }
    public string SourceTableName { get; public set; }
    public string Name { get; public set; }
    public Dictionary`2<string, string> ColumnsMapping { get; public set; }
    public Dictionary`2<string, string> AttachmentNameMapping { get; public set; }
    protected AbstractCollection(string sourceTableSchema, string sourceTableName, string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceTableSchema();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SourceTableSchema(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceTableName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SourceTableName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_ColumnsMapping();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ColumnsMapping(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_AttachmentNameMapping();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AttachmentNameMapping(Dictionary`2<string, string> value);
}
public class Raven.Server.SqlMigration.Model.CollectionNamesMapping : object {
    [CompilerGeneratedAttribute]
private string <TableSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    public string TableSchema { get; public set; }
    public string TableName { get; public set; }
    public string CollectionName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TableSchema();
    [CompilerGeneratedAttribute]
public void set_TableSchema(string value);
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
public void set_TableName(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
public void set_CollectionName(string value);
}
public class Raven.Server.SqlMigration.Model.CollectionWithReferences : AbstractCollection {
    [CompilerGeneratedAttribute]
private List`1<EmbeddedCollection> <NestedCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LinkedCollection> <LinkedCollections>k__BackingField;
    public List`1<EmbeddedCollection> NestedCollections { get; public set; }
    public List`1<LinkedCollection> LinkedCollections { get; public set; }
    public CollectionWithReferences(string sourceTableSchema, string sourceTableName, string name);
    [CompilerGeneratedAttribute]
public List`1<EmbeddedCollection> get_NestedCollections();
    [CompilerGeneratedAttribute]
public void set_NestedCollections(List`1<EmbeddedCollection> value);
    [CompilerGeneratedAttribute]
public List`1<LinkedCollection> get_LinkedCollections();
    [CompilerGeneratedAttribute]
public void set_LinkedCollections(List`1<LinkedCollection> value);
}
public class Raven.Server.SqlMigration.Model.Counts : object {
    [CompilerGeneratedAttribute]
private bool <Processed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ErroredCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SkippedCount>k__BackingField;
    public bool Processed { get; public set; }
    public long ReadCount { get; public set; }
    public long ErroredCount { get; public set; }
    public long SkippedCount { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Processed();
    [CompilerGeneratedAttribute]
public void set_Processed(bool value);
    [CompilerGeneratedAttribute]
public long get_ReadCount();
    [CompilerGeneratedAttribute]
public void set_ReadCount(long value);
    [CompilerGeneratedAttribute]
public long get_ErroredCount();
    [CompilerGeneratedAttribute]
public void set_ErroredCount(long value);
    [CompilerGeneratedAttribute]
public long get_SkippedCount();
    [CompilerGeneratedAttribute]
public void set_SkippedCount(long value);
    public sealed virtual DynamicJsonValue ToJson();
    public virtual string ToString();
}
public class Raven.Server.SqlMigration.Model.EmbeddedArrayValue : object {
    [CompilerGeneratedAttribute]
private DynamicJsonArray <ArrayOfNestedObjects>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DynamicJsonValue> <SpecialColumnsValues>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Dictionary`2<string, Byte[]>> <Attachments>k__BackingField;
    public DynamicJsonArray ArrayOfNestedObjects { get; public set; }
    public List`1<DynamicJsonValue> SpecialColumnsValues { get; public set; }
    public List`1<Dictionary`2<string, Byte[]>> Attachments { get; public set; }
    [CompilerGeneratedAttribute]
public DynamicJsonArray get_ArrayOfNestedObjects();
    [CompilerGeneratedAttribute]
public void set_ArrayOfNestedObjects(DynamicJsonArray value);
    [CompilerGeneratedAttribute]
public List`1<DynamicJsonValue> get_SpecialColumnsValues();
    [CompilerGeneratedAttribute]
public void set_SpecialColumnsValues(List`1<DynamicJsonValue> value);
    [CompilerGeneratedAttribute]
public List`1<Dictionary`2<string, Byte[]>> get_Attachments();
    [CompilerGeneratedAttribute]
public void set_Attachments(List`1<Dictionary`2<string, Byte[]>> value);
}
public class Raven.Server.SqlMigration.Model.EmbeddedCollection : CollectionWithReferences {
    [CompilerGeneratedAttribute]
private List`1<string> <JoinColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private RelationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedDocumentSqlKeysStorage <SqlKeysStorage>k__BackingField;
    public List`1<string> JoinColumns { get; public set; }
    public RelationType Type { get; public set; }
    public EmbeddedDocumentSqlKeysStorage SqlKeysStorage { get; public set; }
    public EmbeddedCollection(string sourceTableSchema, string sourceTableName, RelationType type, List`1<string> columns, string name, EmbeddedDocumentSqlKeysStorage sqlKeysStorage);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<string> get_JoinColumns();
    [CompilerGeneratedAttribute]
public sealed virtual void set_JoinColumns(List`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual RelationType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Type(RelationType value);
    [CompilerGeneratedAttribute]
public EmbeddedDocumentSqlKeysStorage get_SqlKeysStorage();
    [CompilerGeneratedAttribute]
public void set_SqlKeysStorage(EmbeddedDocumentSqlKeysStorage value);
}
public enum Raven.Server.SqlMigration.Model.EmbeddedDocumentSqlKeysStorage : Enum {
    public int value__;
    public static EmbeddedDocumentSqlKeysStorage None;
    public static EmbeddedDocumentSqlKeysStorage AsNestedDocumentProperty;
    public static EmbeddedDocumentSqlKeysStorage OnDocumentMetadata;
}
public class Raven.Server.SqlMigration.Model.EmbeddedObjectValue : object {
    [CompilerGeneratedAttribute]
private DynamicJsonValue <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicJsonValue <SpecialColumnsValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Byte[]> <Attachments>k__BackingField;
    public DynamicJsonValue Object { get; public set; }
    public DynamicJsonValue SpecialColumnsValues { get; public set; }
    public Dictionary`2<string, Byte[]> Attachments { get; public set; }
    [CompilerGeneratedAttribute]
public DynamicJsonValue get_Object();
    [CompilerGeneratedAttribute]
public void set_Object(DynamicJsonValue value);
    [CompilerGeneratedAttribute]
public DynamicJsonValue get_SpecialColumnsValues();
    [CompilerGeneratedAttribute]
public void set_SpecialColumnsValues(DynamicJsonValue value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Byte[]> get_Attachments();
    [CompilerGeneratedAttribute]
public void set_Attachments(Dictionary`2<string, Byte[]> value);
}
public interface Raven.Server.SqlMigration.Model.ICollectionReference {
    public string SourceTableSchema { get; public set; }
    public string SourceTableName { get; public set; }
    public string Name { get; public set; }
    public List`1<string> JoinColumns { get; public set; }
    public RelationType Type { get; public set; }
    public Dictionary`2<string, string> ColumnsMapping { get; public set; }
    public Dictionary`2<string, string> AttachmentNameMapping { get; public set; }
    public abstract virtual string get_SourceTableSchema();
    public abstract virtual void set_SourceTableSchema(string value);
    public abstract virtual string get_SourceTableName();
    public abstract virtual void set_SourceTableName(string value);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual List`1<string> get_JoinColumns();
    public abstract virtual void set_JoinColumns(List`1<string> value);
    public abstract virtual RelationType get_Type();
    public abstract virtual void set_Type(RelationType value);
    public abstract virtual Dictionary`2<string, string> get_ColumnsMapping();
    public abstract virtual void set_ColumnsMapping(Dictionary`2<string, string> value);
    public abstract virtual Dictionary`2<string, string> get_AttachmentNameMapping();
    public abstract virtual void set_AttachmentNameMapping(Dictionary`2<string, string> value);
}
public class Raven.Server.SqlMigration.Model.LinkedCollection : AbstractCollection {
    [CompilerGeneratedAttribute]
private List`1<string> <JoinColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private RelationType <Type>k__BackingField;
    public List`1<string> JoinColumns { get; public set; }
    public RelationType Type { get; public set; }
    public LinkedCollection(string sourceTableSchema, string sourceTableName, RelationType type, List`1<string> joinColumns, string name);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<string> get_JoinColumns();
    [CompilerGeneratedAttribute]
public sealed virtual void set_JoinColumns(List`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual RelationType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Type(RelationType value);
}
public class Raven.Server.SqlMigration.Model.MigrationProgress : object {
    private MigrationResult _result;
    private string Message { get; }
    private bool Raven.Client.Documents.Operations.IOperationProgress.CanMerge { get; }
    public MigrationProgress(MigrationResult result);
    private string get_Message();
    public sealed virtual DynamicJsonValue ToJson();
    private sealed virtual override IOperationProgress Raven.Client.Documents.Operations.IOperationProgress.Clone();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationProgress.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationProgress.MergeWith(IOperationProgress progress);
}
public class Raven.Server.SqlMigration.Model.MigrationRequest : object {
    [CompilerGeneratedAttribute]
private MigrationSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceSqlDatabase <Source>k__BackingField;
    public MigrationSettings Settings { get; public set; }
    public SourceSqlDatabase Source { get; public set; }
    [CompilerGeneratedAttribute]
public MigrationSettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(MigrationSettings value);
    [CompilerGeneratedAttribute]
public SourceSqlDatabase get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(SourceSqlDatabase value);
}
public class Raven.Server.SqlMigration.Model.MigrationResult : object {
    private List`1<string> _messages;
    private MigrationProgress _progress;
    private Stopwatch _sw;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Counts> <PerCollectionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public bool ShouldPersist { get; }
    private bool Raven.Client.Documents.Operations.IOperationResult.CanMerge { get; }
    public Dictionary`2<string, Counts> PerCollectionCount { get; public set; }
    public string Message { get; private set; }
    public TimeSpan Elapsed { get; }
    public IOperationProgress Progress { get; }
    public IReadOnlyList`1<string> Messages { get; }
    public MigrationResult(MigrationSettings settings);
    public sealed virtual bool get_ShouldPersist();
    private sealed virtual override bool Raven.Client.Documents.Operations.IOperationResult.get_CanMerge();
    private sealed virtual override void Raven.Client.Documents.Operations.IOperationResult.MergeWith(IOperationResult result);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Counts> get_PerCollectionCount();
    [CompilerGeneratedAttribute]
public void set_PerCollectionCount(Dictionary`2<string, Counts> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    public TimeSpan get_Elapsed();
    public IOperationProgress get_Progress();
    public IReadOnlyList`1<string> get_Messages();
    public void AddWarning(string message);
    public void AddInfo(string message);
    public void AddError(string message);
    internal void AddMessage(string message);
    private void AddMessage(string type, string message);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.SqlMigration.Model.MigrationSettings : object {
    [CompilerGeneratedAttribute]
private List`1<RootCollection> <Collections>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxRowsPerTable>k__BackingField;
    public List`1<RootCollection> Collections { get; public set; }
    public int BatchSize { get; public set; }
    public Nullable`1<int> MaxRowsPerTable { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<RootCollection> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(List`1<RootCollection> value);
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxRowsPerTable();
    [CompilerGeneratedAttribute]
public void set_MaxRowsPerTable(Nullable`1<int> value);
}
public enum Raven.Server.SqlMigration.Model.MigrationTestMode : Enum {
    public int value__;
    public static MigrationTestMode First;
    public static MigrationTestMode ByPrimaryKey;
}
public class Raven.Server.SqlMigration.Model.MigrationTestRequest : object {
    [CompilerGeneratedAttribute]
private SourceSqlDatabase <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private MigrationTestSettings <Settings>k__BackingField;
    public SourceSqlDatabase Source { get; public set; }
    public MigrationTestSettings Settings { get; public set; }
    [CompilerGeneratedAttribute]
public SourceSqlDatabase get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(SourceSqlDatabase value);
    [CompilerGeneratedAttribute]
public MigrationTestSettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(MigrationTestSettings value);
}
public class Raven.Server.SqlMigration.Model.MigrationTestSettings : object {
    [CompilerGeneratedAttribute]
private bool <BinaryToAttachment>k__BackingField;
    [CompilerGeneratedAttribute]
private RootCollection <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private MigrationTestMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PrimaryKeyValues>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CollectionNamesMapping> <CollectionsMapping>k__BackingField;
    public bool BinaryToAttachment { get; public set; }
    public RootCollection Collection { get; public set; }
    public MigrationTestMode Mode { get; public set; }
    public String[] PrimaryKeyValues { get; public set; }
    public List`1<CollectionNamesMapping> CollectionsMapping { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_BinaryToAttachment();
    [CompilerGeneratedAttribute]
public void set_BinaryToAttachment(bool value);
    [CompilerGeneratedAttribute]
public RootCollection get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(RootCollection value);
    [CompilerGeneratedAttribute]
public MigrationTestMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(MigrationTestMode value);
    [CompilerGeneratedAttribute]
public String[] get_PrimaryKeyValues();
    [CompilerGeneratedAttribute]
public void set_PrimaryKeyValues(String[] value);
    [CompilerGeneratedAttribute]
public List`1<CollectionNamesMapping> get_CollectionsMapping();
    [CompilerGeneratedAttribute]
public void set_CollectionsMapping(List`1<CollectionNamesMapping> value);
}
public class Raven.Server.SqlMigration.Model.ReferenceInformation : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceTableName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <SourcePrimaryKeyColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <TargetPrimaryKeyColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ForeignKeyColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionNameToUseInLinks>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataProvider`1<object> <DataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataProvider`1<object> <EmbeddedReferenceKeyDataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedDocumentSqlKeysStorage <EmbeddedDocumentsSqlKeysStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <TargetSpecialColumnsNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <TargetDocumentColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <TargetAttachmentColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ReferenceInformation> <ChildReferences>k__BackingField;
    public string PropertyName { get; public set; }
    public string SourceSchema { get; public set; }
    public string SourceTableName { get; public set; }
    public List`1<string> SourcePrimaryKeyColumns { get; public set; }
    public List`1<string> TargetPrimaryKeyColumns { get; public set; }
    public List`1<string> ForeignKeyColumns { get; public set; }
    public string CollectionNameToUseInLinks { get; public set; }
    public IDataProvider`1<object> DataProvider { get; public set; }
    public IDataProvider`1<object> EmbeddedReferenceKeyDataProvider { get; public set; }
    public EmbeddedDocumentSqlKeysStorage EmbeddedDocumentsSqlKeysStorage { get; public set; }
    public HashSet`1<string> TargetSpecialColumnsNames { get; public set; }
    public Dictionary`2<string, string> TargetDocumentColumns { get; public set; }
    public Dictionary`2<string, string> TargetAttachmentColumns { get; public set; }
    public ReferenceType Type { get; public set; }
    public List`1<ReferenceInformation> ChildReferences { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public string get_SourceSchema();
    [CompilerGeneratedAttribute]
public void set_SourceSchema(string value);
    [CompilerGeneratedAttribute]
public string get_SourceTableName();
    [CompilerGeneratedAttribute]
public void set_SourceTableName(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_SourcePrimaryKeyColumns();
    [CompilerGeneratedAttribute]
public void set_SourcePrimaryKeyColumns(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_TargetPrimaryKeyColumns();
    [CompilerGeneratedAttribute]
public void set_TargetPrimaryKeyColumns(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ForeignKeyColumns();
    [CompilerGeneratedAttribute]
public void set_ForeignKeyColumns(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_CollectionNameToUseInLinks();
    [CompilerGeneratedAttribute]
public void set_CollectionNameToUseInLinks(string value);
    [CompilerGeneratedAttribute]
public IDataProvider`1<object> get_DataProvider();
    [CompilerGeneratedAttribute]
public void set_DataProvider(IDataProvider`1<object> value);
    [CompilerGeneratedAttribute]
public IDataProvider`1<object> get_EmbeddedReferenceKeyDataProvider();
    [CompilerGeneratedAttribute]
public void set_EmbeddedReferenceKeyDataProvider(IDataProvider`1<object> value);
    [CompilerGeneratedAttribute]
public EmbeddedDocumentSqlKeysStorage get_EmbeddedDocumentsSqlKeysStorage();
    [CompilerGeneratedAttribute]
public void set_EmbeddedDocumentsSqlKeysStorage(EmbeddedDocumentSqlKeysStorage value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_TargetSpecialColumnsNames();
    [CompilerGeneratedAttribute]
public void set_TargetSpecialColumnsNames(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_TargetDocumentColumns();
    [CompilerGeneratedAttribute]
public void set_TargetDocumentColumns(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_TargetAttachmentColumns();
    [CompilerGeneratedAttribute]
public void set_TargetAttachmentColumns(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public ReferenceType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ReferenceType value);
    [CompilerGeneratedAttribute]
public List`1<ReferenceInformation> get_ChildReferences();
    [CompilerGeneratedAttribute]
public void set_ChildReferences(List`1<ReferenceInformation> value);
}
public enum Raven.Server.SqlMigration.Model.ReferenceType : Enum {
    public int value__;
    public static ReferenceType ArrayLink;
    public static ReferenceType ArrayEmbed;
    public static ReferenceType ObjectLink;
    public static ReferenceType ObjectEmbed;
}
public enum Raven.Server.SqlMigration.Model.RelationType : Enum {
    public int value__;
    public static RelationType OneToMany;
    public static RelationType ManyToOne;
}
public class Raven.Server.SqlMigration.Model.RootCollection : CollectionWithReferences {
    [CompilerGeneratedAttribute]
private string <SourceTableQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Patch>k__BackingField;
    public string SourceTableQuery { get; public set; }
    public string Patch { get; public set; }
    public RootCollection(string sourceTableSchema, string sourceTableName, string name);
    [CompilerGeneratedAttribute]
public string get_SourceTableQuery();
    [CompilerGeneratedAttribute]
public void set_SourceTableQuery(string value);
    [CompilerGeneratedAttribute]
public string get_Patch();
    [CompilerGeneratedAttribute]
public void set_Patch(string value);
}
public class Raven.Server.SqlMigration.Model.SourceSqlDatabase : object {
    [CompilerGeneratedAttribute]
private MigrationProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Schemas>k__BackingField;
    public MigrationProvider Provider { get; public set; }
    public string ConnectionString { get; public set; }
    public String[] Schemas { get; public set; }
    [CompilerGeneratedAttribute]
public MigrationProvider get_Provider();
    [CompilerGeneratedAttribute]
public void set_Provider(MigrationProvider value);
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(string value);
    [CompilerGeneratedAttribute]
public String[] get_Schemas();
    [CompilerGeneratedAttribute]
public void set_Schemas(String[] value);
}
public class Raven.Server.SqlMigration.Model.SqlMigrationDocument : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicJsonValue <SpecialColumnsValues>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicJsonValue <Object>k__BackingField;
    public Dictionary`2<string, Byte[]> Attachments;
    public string Id { get; public set; }
    public string Collection { get; public set; }
    public DynamicJsonValue SpecialColumnsValues { get; public set; }
    public DynamicJsonValue Object { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public DynamicJsonValue get_SpecialColumnsValues();
    [CompilerGeneratedAttribute]
public void set_SpecialColumnsValues(DynamicJsonValue value);
    [CompilerGeneratedAttribute]
public DynamicJsonValue get_Object();
    [CompilerGeneratedAttribute]
public void set_Object(DynamicJsonValue value);
    public void SetCollectionAndId(string collectionName, string id);
    public BlittableJsonReaderObject ToBlittable(JsonOperationContext context);
}
public class Raven.Server.SqlMigration.Model.SqlStatementProvider`1 : object {
    private DbCommand _command;
    private Func`2<DynamicJsonValue, Object[]> _parametersProvider;
    private Func`2<DbDataReader, T> _extractor;
    public SqlStatementProvider`1(DbConnection connection, string query, Func`2<DynamicJsonValue, Object[]> parametersProvider, Func`2<DbDataReader, T> extractor);
    public sealed virtual T Provide(DynamicJsonValue specialColumns);
    public sealed virtual void Dispose();
}
internal class Raven.Server.SqlMigration.MsSQL.MsSqlDatabaseMigrator : GenericDatabaseMigrator {
    public static string SelectColumns;
    public static string SelectPrimaryKeys;
    public static string SelectReferentialConstraints;
    public static string SelectKeyColumnUsage;
    protected string FactoryName { get; }
    public MsSqlDatabaseMigrator(string connectionString);
    protected virtual string get_FactoryName();
    protected virtual string QuoteColumn(string columnName);
    protected virtual string QuoteTable(string schema, string tableName);
    private ColumnType MapColumnType(string type);
    protected virtual string LimitRowsNumber(string inputQuery, Nullable`1<int> rowsLimit);
    protected virtual string GetSelectAllQueryForTable(string tableSchema, string tableName);
    public virtual DatabaseSchema FindSchema();
    private void FindTableNames(DbConnection connection, DatabaseSchema dbSchema);
    private void FindPrimaryKeys(DbConnection connection, DatabaseSchema dbSchema);
    private void FindForeignKeys(DbConnection connection, DatabaseSchema dbSchema);
    private Dictionary`2<string, ValueTuple`3<string, string, List`1<string>>> GetKeyColumnUsageCache(DbConnection connection);
    private static ValueTuple`2<string, string> GetTableNameFromReader(DbDataReader reader);
}
internal class Raven.Server.SqlMigration.MySQL.MySqlDatabaseMigrator : GenericDatabaseMigrator {
    private string _factoryName;
    public static string SelectColumns;
    public static string SelectPrimaryKeys;
    public static string SelectReferentialConstraints;
    public static string SelectKeyColumnUsage;
    protected string FactoryName { get; }
    public MySqlDatabaseMigrator(string connectionString, string factoryName);
    protected virtual string get_FactoryName();
    protected virtual string QuoteColumn(string columnName);
    protected virtual string QuoteTable(string schema, string tableName);
    private ColumnType MapColumnType(string type);
    protected virtual string LimitRowsNumber(string inputQuery, Nullable`1<int> rowsLimit);
    protected virtual string GetSelectAllQueryForTable(string tableSchema, string tableName);
    public virtual DatabaseSchema FindSchema();
    private void FindTableNames(DbConnection connection, DatabaseSchema dbSchema);
    private void FindPrimaryKeys(DbConnection connection, DatabaseSchema dbSchema);
    private void FindForeignKeys(DbConnection connection, DatabaseSchema dbSchema);
    private Dictionary`2<string, ValueTuple`2<List`1<string>, List`1<string>>> GetKeyColumnUsageCache(DbConnection connection);
    private static ValueTuple`2<string, string> GetTableNameFromReader(DbDataReader reader);
}
internal class Raven.Server.SqlMigration.NpgSQL.NpgSqlDatabaseMigrator : GenericDatabaseMigrator {
    private static string SelectColumnsTemplate;
    private string _selectColumns;
    public static string SelectPrimaryKeys;
    public static string SelectReferentialConstraints;
    public static string SelectKeyColumnUsage;
    protected string FactoryName { get; }
    public NpgSqlDatabaseMigrator(string connectionString, String[] schemas);
    protected virtual string get_FactoryName();
    protected virtual string QuoteColumn(string columnName);
    protected virtual string QuoteTable(string schema, string tableName);
    private ColumnType MapColumnType(string type);
    protected virtual string LimitRowsNumber(string inputQuery, Nullable`1<int> rowsLimit);
    protected virtual string GetSelectAllQueryForTable(string tableSchema, string tableName);
    public virtual DatabaseSchema FindSchema();
    private void FindTableNames(DbConnection connection, DatabaseSchema dbSchema);
    private void FindPrimaryKeys(DbConnection connection, DatabaseSchema dbSchema);
    private void FindForeignKeys(DbConnection connection, DatabaseSchema dbSchema);
    private Dictionary`2<string, ValueTuple`3<string, string, List`1<string>>> GetKeyColumnUsageCache(DbConnection connection);
    private static ValueTuple`2<string, string> GetTableNameFromReader(DbDataReader reader);
}
internal class Raven.Server.SqlMigration.Oracle.OracleDatabaseMigrator : GenericDatabaseMigrator {
    public static string GetSchema;
    public static string SelectColumns;
    public static string SelectPrimaryKeys;
    public static string SelectReferentialConstraints;
    public static string SelectKeyColumnUsage;
    protected string FactoryName { get; }
    public OracleDatabaseMigrator(string connectionString);
    private static OracleDatabaseMigrator();
    protected virtual string get_FactoryName();
    protected virtual string QuoteColumn(string columnName);
    protected virtual string QuoteTable(string schema, string tableName);
    private ColumnType MapColumnType(string type);
    protected virtual string LimitRowsNumber(string inputQuery, Nullable`1<int> rowsLimit);
    protected virtual string GetSelectAllQueryForTable(string tableSchema, string tableName);
    protected virtual string GetQueryByPrimaryKey(RootCollection collection, SqlTableSchema tableSchema, String[] primaryKeyValues, Dictionary`2& queryParameters);
    protected virtual IDataProvider`1<DynamicJsonArray> CreateArrayLinkDataProvider(ReferenceInformation refInfo, DbConnection connection);
    protected virtual IDataProvider`1<EmbeddedObjectValue> CreateObjectEmbedDataProvider(ReferenceInformation refInfo, DbConnection connection);
    protected virtual IDataProvider`1<EmbeddedArrayValue> CreateArrayEmbedDataProvider(ReferenceInformation refInfo, DbConnection connection);
    public virtual DatabaseSchema FindSchema();
    private void FindTableNames(DbConnection connection, DatabaseSchema dbSchema);
    private void FindPrimaryKeys(DbConnection connection, DatabaseSchema dbSchema);
    private void FindForeignKeys(DbConnection connection, DatabaseSchema dbSchema);
    private Dictionary`2<string, ValueTuple`3<string, string, List`1<string>>> GetKeyColumnUsageCache(DbConnection connection);
    private static ValueTuple`2<string, string> GetTableNameFromReader(DbDataReader reader);
}
public enum Raven.Server.SqlMigration.Schema.ColumnType : Enum {
    public int value__;
    public static ColumnType String;
    public static ColumnType Number;
    public static ColumnType Array;
    public static ColumnType Boolean;
    public static ColumnType Object;
    public static ColumnType Binary;
    public static ColumnType Unsupported;
}
public class Raven.Server.SqlMigration.Schema.DatabaseSchema : object {
    [CompilerGeneratedAttribute]
private string <CatalogName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SqlTableSchema> <Tables>k__BackingField;
    public string CatalogName { get; public set; }
    public List`1<SqlTableSchema> Tables { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CatalogName();
    [CompilerGeneratedAttribute]
public void set_CatalogName(string value);
    [CompilerGeneratedAttribute]
public List`1<SqlTableSchema> get_Tables();
    [CompilerGeneratedAttribute]
public void set_Tables(List`1<SqlTableSchema> value);
    public sealed virtual DynamicJsonValue ToJson();
    public SqlTableSchema GetTable(string schema, string tableName);
    public HashSet`1<string> FindSpecialColumns(string tableSchema, string tableName);
}
public class Raven.Server.SqlMigration.Schema.SqlTableSchema : object {
    [CompilerGeneratedAttribute]
private string <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TableColumn> <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <PrimaryKeyColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TableReference> <References>k__BackingField;
    public string Schema { get; public set; }
    public string TableName { get; public set; }
    public string DefaultQuery { get; public set; }
    public List`1<TableColumn> Columns { get; public set; }
    public List`1<string> PrimaryKeyColumns { get; public set; }
    public List`1<TableReference> References { get; public set; }
    public SqlTableSchema(string schema, string tableName, string defaultQuery);
    [CompilerGeneratedAttribute]
public string get_Schema();
    [CompilerGeneratedAttribute]
public void set_Schema(string value);
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
public void set_TableName(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultQuery();
    [CompilerGeneratedAttribute]
public void set_DefaultQuery(string value);
    [CompilerGeneratedAttribute]
public List`1<TableColumn> get_Columns();
    [CompilerGeneratedAttribute]
public void set_Columns(List`1<TableColumn> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_PrimaryKeyColumns();
    [CompilerGeneratedAttribute]
public void set_PrimaryKeyColumns(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<TableReference> get_References();
    [CompilerGeneratedAttribute]
public void set_References(List`1<TableReference> value);
    public sealed virtual DynamicJsonValue ToJson();
    public TableReference FindReference(AbstractCollection collection, List`1<string> columns);
}
public class Raven.Server.SqlMigration.Schema.TableColumn : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ColumnType <Type>k__BackingField;
    public string Name { get; public set; }
    public ColumnType Type { get; public set; }
    public TableColumn(ColumnType type, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ColumnType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ColumnType value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.SqlMigration.Schema.TableReference : object {
    [CompilerGeneratedAttribute]
private string <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Table>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Columns>k__BackingField;
    public string Schema { get; public set; }
    public string Table { get; public set; }
    public List`1<string> Columns { get; public set; }
    public TableReference(string schema, string table);
    [CompilerGeneratedAttribute]
public string get_Schema();
    [CompilerGeneratedAttribute]
public void set_Schema(string value);
    [CompilerGeneratedAttribute]
public string get_Table();
    [CompilerGeneratedAttribute]
public void set_Table(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Columns();
    [CompilerGeneratedAttribute]
public void set_Columns(List`1<string> value);
    public sealed virtual DynamicJsonValue ToJson();
}
internal class Raven.Server.SqlMigration.SqlMigrationWriter : object {
    private DocumentsOperationContext _context;
    private MergedBatchCommand _command;
    private int _batchSize;
    private List`1<CommandData> _commands;
    private List`1<AttachmentStream> _attachmentStreams;
    private List`1<IDisposable> _toDispose;
    public SqlMigrationWriter(DocumentsOperationContext context, int batchSize);
    [AsyncStateMachineAttribute("Raven.Server.SqlMigration.SqlMigrationWriter/<InsertDocument>d__7")]
public Task InsertDocument(BlittableJsonReaderObject document, string id, Dictionary`2<string, Byte[]> attachments);
    [AsyncStateMachineAttribute("Raven.Server.SqlMigration.SqlMigrationWriter/<FlushCommands>d__8")]
private Task FlushCommands();
    private void Reset();
    public sealed virtual void Dispose();
}
public static class Raven.Server.Storage.Layout.StorageLoader : object {
    public static StorageEnvironment OpenEnvironment(StorageEnvironmentOptions options, StorageEnvironmentType type);
    private static StorageEnvironment OpenEnvironmentWithPossibleLayoutUpdate(DirectoryStorageEnvironmentOptions options, StorageEnvironmentType type);
    private static bool TryMoveJournals(VoronPathSetting basePath, VoronPathSetting journalsPath);
    private static void BackupAndDeleteFile(VoronPathSetting path);
}
public interface Raven.Server.Storage.Schema.ISchemaUpdate {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public abstract virtual int get_From();
    public abstract virtual int get_To();
    public abstract virtual StorageType get_StorageType();
    public abstract virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.SchemaUpgradeExtensions : object {
    public static string DbKey;
    public static List`1<string> GetDatabases(UpdateStep step);
}
public static class Raven.Server.Storage.Schema.SchemaUpgrader : object {
    private static Int32[] SkippedDocumentsVersion;
    private static SchemaUpgrader();
    public static UpgraderDelegate Upgrader(StorageType storageType, ConfigurationStorage configurationStorage, DocumentsStorage documentsStorage, ServerStore serverStore);
}
public class Raven.Server.Storage.Schema.Updates.Configuration.From40010 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Configuration.From40011 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.CoraxIndex.From54000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.CoraxIndex.From60000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.CoraxIndex.From61000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From40010 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From40011 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From40013 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From40014 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From40015 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From41016 : object {
    internal static int NumberOfCountersToMigrateInSingleTransaction;
    private static Slice CountersTombstonesSlice;
    private static Slice AllCountersEtagSlice;
    private static Slice CollectionCountersEtagsSlice;
    private static Slice CounterKeysSlice;
    private static string CountersTombstones;
    private string _dbId;
    private static TableSchema LegacyCountersSchema;
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    private static From41016();
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
    private void DeleteMigratedLegacyCounters(Table table, List`1<long> etags);
    private void DeleteCounter(UpdateStep step, LazyStringValue tombstoneKey, DocumentsOperationContext context);
    [IteratorStateMachineAttribute("Raven.Server.Storage.Schema.Updates.Documents.From41016/<GetCounters>d__20")]
private static IEnumerable`1<ValueTuple`2<CounterDetail, long>> GetCounters(Table table, DocumentsOperationContext ctx);
    private CollectionName PutCounters(UpdateStep step, DocumentsOperationContext context, HashSet`1<string> dbIds, Dictionary`2<string, List`1<CounterDetail>> allCountersBatch, string docId);
    private static ExternalScope<ByteStringMemoryCache> CreateCounterKeySlice(DocumentsOperationContext context, ByteString buffer, Slice documentIdPrefix, Slice counterName, Slice& counterKeySlice);
    internal static string ReadDbId(UpdateStep step);
    private static CounterDetail TableValueToCounterDetail(JsonOperationContext context, TableValueReader tvr);
    private static ValueTuple`2<LazyStringValue, LazyStringValue> ExtractDocIdAndNameFromLegacyCounter(JsonOperationContext context, TableValueReader& tvr);
    private static ValueTuple`2<LazyStringValue, LazyStringValue> ExtractDocIdAndNameFromCounterTombstone(JsonOperationContext context, LazyStringValue counterKey);
    private static LazyStringValue ExtractDbId(JsonOperationContext context, LazyStringValue counterKey);
    private static BlittableJsonReaderObject WriteNewCountersDocument(DocumentsOperationContext context, List`1<string> dbIds, IEnumerable`1<KeyValuePair`2<string, List`1<CounterDetail>>> batch);
    private static void WriteRawBlob(DocumentsOperationContext context, List`1<string> dbIds, List`1<CounterDetail> counters, ByteString newVal, ManualBlittableJsonDocumentBuilder`1<UnmanagedWriteBuffer> builder);
    private static int GetMaxDbIdIndex(DocumentsOperationContext context, List`1<string> dbIds, List`1<CounterDetail> counters);
    private void DeleteFromTable(DocumentsOperationContext context, Table table, IndexDef pk, Func`2<TableValueHolder, bool> shouldSkip);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From42017 : object {
    internal static int NumberOfCounterGroupsToMigrateInSingleTransaction;
    internal static int MaxSizeToMigrateInSingleTransaction;
    private string _dbId;
    private ObjectPool`1<Dictionary`2<LazyStringValue, PutCountersData>> _dictionariesPool;
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    private static From42017();
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
    private static void UpdateSchemaForDocumentsAndRevisions(UpdateStep step);
    private static void UpdateDocumentCounters(UpdateStep step, DocumentsOperationContext context, string docId, CollectionName collection);
    private void PutCounterGroups(UpdateStep step, CounterBatchUpdate batch, DocumentsOperationContext context, CollectionName collection);
    private static void DeleteProcessedEntries(UpdateStep step, List`1<long> toDelete, CollectionName collection);
    [IteratorStateMachineAttribute("Raven.Server.Storage.Schema.Updates.Documents.From42017/<GetCounters>d__15")]
private static IEnumerable`1<CounterReplicationItem> GetCounters(Table table, DocumentsOperationContext ctx, string prefix);
    private void PutCounters(DocumentsOperationContext context, UpdateStep step, string documentId, string changeVector, BlittableJsonReaderObject sourceData, CollectionName collection);
    private static void CreateFirstEntry(DocumentsOperationContext context, string documentId, string changeVector, BlittableJsonReaderObject sourceData, BlittableJsonReaderObject sourceCounterNames, BlittableJsonReaderObject sourceCounters, CollectionName collectionName, Table table, Slice documentKeyPrefix);
    private static void SplitCounterGroup(DocumentsOperationContext context, CollectionName collectionName, Table table, Slice documentKeyPrefix, Slice countersGroupKey, BlittableJsonReaderObject values, BlittableJsonReaderArray dbIds, BlittableJsonReaderObject originalNames, string changeVector, string dbId);
    private static ValueTuple`2<BlittableJsonReaderObject, BlittableJsonReaderObject> SplitCounterDocument(DocumentsOperationContext context, BlittableJsonReaderObject values, BlittableJsonReaderArray dbIds, BlittableJsonReaderObject originalNames);
    private static BlittableJsonReaderObject CreateHalfDocument(DocumentsOperationContext context, BlittableJsonReaderObject values, int start, int end, BlittableJsonReaderArray dbIds, BlittableJsonReaderObject originalNames);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From50000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From50001 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From50002 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From60000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Documents.From61000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.LuceneIndex.From40010 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
    private static bool UpdateErrorTimestampsTreeInErrorsTable(UpdateStep step);
    private static Tree GetNewErrorTimestampsTreeFromErrorsTable(UpdateStep step, Slice errorTimestampsSlice);
    private static Table GetOldErrorsTable(UpdateStep step, Slice errorTimestampsSlice, TableSchema& oldTableSchema);
}
public class Raven.Server.Storage.Schema.Updates.LuceneIndex.From40011 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.LuceneIndex.From40012 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.LuceneIndex.From5000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.LuceneIndex.From54000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.LuceneIndex.From60000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.LuceneIndex.From61000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Server.From40010 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Server.From40011 : object {
    private static string LocalNodeStateTreeName;
    private static TableSchema ItemsSchema;
    private static TableSchema CertificatesSchema;
    private static Slice Items;
    private static Slice CertificatesSlice;
    private static Slice CertificatesHashSlice;
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    private static From40011();
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
    [IteratorStateMachineAttribute("Raven.Server.Storage.Schema.Updates.Server.From40011/<GetCertificateKeysFromLocalState>d__15")]
public IEnumerable`1<string> GetCertificateKeysFromLocalState(Transaction tx);
    public BlittableJsonReaderObject GetLocalStateByThumbprint(Transaction tx, JsonOperationContext context, string key);
    public void PutLocalState(Transaction tx, string key, BlittableJsonReaderObject value);
    [IteratorStateMachineAttribute("Raven.Server.Storage.Schema.Updates.Server.From40011/<ItemsStartingWith>d__18")]
private IEnumerable`1<ValueTuple`2<string, BlittableJsonReaderObject>> ItemsStartingWith(Transaction tx, JsonOperationContext context, ByteStringContext allocator, string prefix, int start, int take);
    private static ValueTuple`2<string, BlittableJsonReaderObject> GetCurrentItem(Transaction tx, JsonOperationContext context, TableValueHolder result);
    public static void DropCertificatePrefixFromDefinition(CertificateDefinition definition, Boolean& touched);
}
public class Raven.Server.Storage.Schema.Updates.Server.From42012 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
    private ValueTuple`2<BlittableJsonReaderObject, long> GetBjroAndIndex(JsonOperationContext context, Table items, Slice lowerKeySlice);
}
public class Raven.Server.Storage.Schema.Updates.Server.From42013 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Server.From42014 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
    private ValueTuple`2<BlittableJsonReaderObject, long> GetBjroAndIndex(JsonOperationContext context, Table items, Slice lowerKeySlice);
}
public class Raven.Server.Storage.Schema.Updates.Server.From42015 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
    internal static bool UpdateCertificatesTableInternal(UpdateStep step);
    private static ValueTuple`2<string, BlittableJsonReaderObject> GetCurrentItem(Transaction tx, JsonOperationContext context, TableValueHolder result);
}
public class Raven.Server.Storage.Schema.Updates.Server.From42016 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Server.From42017 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Server.From42018 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Server.From42019 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Server.From50000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Server.From52000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
internal class Raven.Server.Storage.Schema.Updates.Server.From53000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
    [IteratorStateMachineAttribute("Raven.Server.Storage.Schema.Updates.Server.From53000/<GetAllCompareExchange>d__7")]
public static IEnumerable`1<ValueTuple`2<Slice, BlittableJsonReaderObject>> GetAllCompareExchange(Transaction tx);
    private static BlittableJsonReaderObject ReadCompareExchangeValue(JsonOperationContext context, TableValueReader reader);
    private static LazyStringValue ReadCompareExchangeKey(JsonOperationContext context, TableValueReader reader);
    private static void Put(Transaction tx, Slice keySlice, long ticks);
}
public class Raven.Server.Storage.Schema.Updates.Server.From53001 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Server.From60000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.Updates.Server.From61000 : object {
    public int From { get; }
    public int To { get; }
    public StorageType StorageType { get; }
    public sealed virtual int get_From();
    public sealed virtual int get_To();
    public sealed virtual StorageType get_StorageType();
    public sealed virtual bool Update(UpdateStep step);
}
public class Raven.Server.Storage.Schema.UpdateStep : object {
    private SchemaUpgradeTransactions _transactions;
    private Nullable`1<short> _lastCommittedTxMarker;
    public ConfigurationStorage ConfigurationStorage;
    public DocumentsStorage DocumentsStorage;
    public ClusterStateMachine ClusterStateMachine;
    public Transaction ReadTx { get; }
    public Transaction WriteTx { get; }
    public UpdateStep(SchemaUpgradeTransactions transactions);
    public Transaction get_ReadTx();
    public Transaction get_WriteTx();
    public void Commit(DocumentsOperationContext txContext);
    public void RenewTransactions();
}
public class Raven.Server.Storage.StorageSpaceMonitor : object {
    private static TimeSpan CheckFrequency;
    private Logger _logger;
    private LinkedList`1<DocumentDatabase> _databases;
    private object _runLock;
    private object _subscribeLock;
    private ServerNotificationCenter _notificationCenter;
    private Timer _timer;
    internal bool SimulateLowDiskSpace;
    public StorageSpaceMonitor(ServerNotificationCenter notificationCenter);
    private static StorageSpaceMonitor();
    public void Subscribe(DocumentDatabase database);
    public void Unsubscribe(DocumentDatabase database);
    internal void Run(object state);
    private ValueTuple`2<HashSet`1<LowDiskSpace>, HashSet`1<StorageEnvironment>> GetLowSpaceDisksAndRelevantEnvironments();
    internal static bool IsLowSpace(Size totalFreeSpace, Size diskSpace, StorageConfiguration config, String& reason, bool simulateLowDiskSpace);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <GetLowSpaceDisksAndRelevantEnvironments>g__AddEnvironmentIfLowSpace|12_0(DiskSpaceResult diskSpace, <>c__DisplayClass12_0& , <>c__DisplayClass12_1& , <>c__DisplayClass12_2& );
}
internal class Raven.Server.TrafficWatch.TrafficWatchConnection : object {
    private static Logger Logger;
    private WebSocket _webSocket;
    private JsonOperationContext _context;
    [CompilerGeneratedAttribute]
private string <TenantSpecific>k__BackingField;
    private AsyncManualResetEvent _manualResetEvent;
    private CancellationTokenSource _cancellationTokenSource;
    private Task`1<WebSocketReceiveResult> _receive;
    private ConcurrentQueue`1<TrafficWatchChangeBase> _messages;
    private MemoryStream _bufferStream;
    private bool _disposed;
    public string TenantSpecific { get; public set; }
    public bool IsAlive { get; }
    public TrafficWatchConnection(WebSocket webSocket, string resourceName, JsonOperationContext context, CancellationToken ctk);
    private static TrafficWatchConnection();
    [CompilerGeneratedAttribute]
public string get_TenantSpecific();
    [CompilerGeneratedAttribute]
public void set_TenantSpecific(string value);
    public bool get_IsAlive();
    [AsyncStateMachineAttribute("Raven.Server.TrafficWatch.TrafficWatchConnection/<StartSendingNotifications>d__16")]
public Task StartSendingNotifications();
    [AsyncStateMachineAttribute("Raven.Server.TrafficWatch.TrafficWatchConnection/<ToByteArraySegmentAsync>d__17")]
private Task`1<ArraySegment`1<byte>> ToByteArraySegmentAsync(TrafficWatchChangeBase change);
    [AsyncStateMachineAttribute("Raven.Server.TrafficWatch.TrafficWatchConnection/<SendMessage>d__18")]
private Task SendMessage(ArraySegment`1<byte> message);
    public void EnqueueMsg(TrafficWatchChangeBase msg);
    public void Dispose();
}
public class Raven.Server.TrafficWatch.TrafficWatchHandler : ServerRequestHandler {
    private static Logger _logger;
    private static TrafficWatchHandler();
    [AsyncStateMachineAttribute("Raven.Server.TrafficWatch.TrafficWatchHandler/<TrafficWatchWebsockets>d__1")]
[RavenActionAttribute("/admin/traffic-watch", "GET", "1", "False", "False", "True", "0")]
public Task TrafficWatchWebsockets();
    [AsyncStateMachineAttribute("Raven.Server.TrafficWatch.TrafficWatchHandler/<GetConfiguration>d__2")]
[RavenActionAttribute("/admin/traffic-watch/configuration", "GET", "1", "False", "False", "True", "0")]
public Task GetConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.TrafficWatch.TrafficWatchHandler/<SetConfiguration>d__3")]
[RavenActionAttribute("/admin/traffic-watch/configuration", "POST", "1", "False", "False", "True", "0")]
public Task SetConfiguration();
}
internal static class Raven.Server.TrafficWatch.TrafficWatchManager : object {
    private static ConcurrentSet`1<TrafficWatchConnection> ServerHttpTrace;
    public static bool HasRegisteredClients { get; }
    private static TrafficWatchManager();
    public static bool get_HasRegisteredClients();
    public static void AddConnection(TrafficWatchConnection connection);
    public static void Disconnect(TrafficWatchConnection connection);
    public static void DispatchMessage(TrafficWatchChangeBase trafficWatchData);
}
internal class Raven.Server.TrafficWatch.TrafficWatchToLog : object {
    private static Logger Logger;
    private TrafficWatchMode _trafficWatchMode;
    private List`1<string> _databases;
    private List`1<int> _statusCodes;
    private long _minimumResponseSizeInBytes;
    private long _minimumRequestSizeInBytes;
    private long _minimumDurationInMs;
    private List`1<string> _httpMethods;
    private List`1<TrafficWatchChangeType> _changeTypes;
    private List`1<string> _certificateThumbprints;
    public static TrafficWatchToLog Instance;
    public bool LogToFile { get; }
    private static TrafficWatchToLog();
    public bool get_LogToFile();
    public void Log(TrafficWatchChangeBase trafficWatchData);
    public void UpdateConfiguration(TrafficWatchConfiguration configuration);
    public void UpdateConfiguration(Parameters configuration);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.AffinityHelper : object {
    private static ConcurrentSet`1<PooledThread> _customAffinityThreads;
    private static Logger _logger;
    private static AffinityHelper();
    public static void SetProcessAffinity(Process process, int cores, Nullable`1<long> processAffinityMask, Int64& currentlyAssignedCores);
    internal static bool ResetThreadAffinity(PooledThread pooledThread);
    internal static void SetCustomThreadAffinity(PooledThread pooledThread);
    private static bool ChangeThreadAffinityWithRetries(Process currentProcess, Action`1<long> action);
    private static void SetCustomThreadAffinityInternal(PooledThread pooledThread, long currentAffinity);
    private static void SetThreadAffinity(PooledThread pooledThread, long affinity);
}
public class Raven.Server.Utils.AsyncBlittableJsonTextWriterForDebug : object {
    private ServerStore _serverStore;
    private bool _isFirst;
    private bool _isOnlyWrite;
    private AsyncBlittableJsonTextWriter _inner;
    public AsyncBlittableJsonTextWriterForDebug(JsonOperationContext context, ServerStore serverStore, Stream stream, CancellationToken cancellationToken);
    public sealed virtual void WriteStartObject();
    public sealed virtual void WriteEndObject();
    public sealed virtual void WriteObject(BlittableJsonReaderObject obj);
    public sealed virtual void WriteValue(BlittableJsonToken token, object val);
    public sealed virtual int WriteDateTime(Nullable`1<DateTime> value, bool isUtc);
    public sealed virtual int WriteDateTime(DateTime value, bool isUtc);
    public sealed virtual void WriteString(string str, bool skipEscaping);
    public sealed virtual void WriteString(LazyStringValue str, bool skipEscaping);
    public sealed virtual void WriteString(LazyCompressedStringValue str);
    public sealed virtual void WriteStartArray();
    public sealed virtual void WriteEndArray();
    public sealed virtual void WriteNull();
    public sealed virtual void WriteBool(bool val);
    public sealed virtual void WriteComma();
    public sealed virtual void WriteInteger(long val);
    public sealed virtual void WriteDouble(LazyNumberValue val);
    public sealed virtual void WriteDouble(double val);
    public sealed virtual void WriteNewLine();
    public sealed virtual void WritePropertyName(ReadOnlySpan`1<byte> prop);
    public sealed virtual void WritePropertyName(string prop);
    public sealed virtual void WritePropertyName(StringSegment prop);
    public ValueTask`1<int> MaybeFlushAsync(CancellationToken token);
    public sealed virtual ValueTask DisposeAsync();
}
public class Raven.Server.Utils.AsyncLock : object {
    private SemaphoreSlim _semaphore;
    private Task`1<IDisposable> _releaser;
    public Task`1<IDisposable> LockAsync();
}
internal static class Raven.Server.Utils.BackupUtils : object {
    internal static BackupTask GetBackupTask(DocumentDatabase database, BackupParameters backupParameters, BackupConfiguration configuration, OperationCancelToken token, Logger logger, TestingStuff forTestingPurposes);
    [AsyncStateMachineAttribute("Raven.Server.Utils.BackupUtils/<GetDecompressionStreamAsync>d__1")]
internal static Task`1<Stream> GetDecompressionStreamAsync(Stream stream, CancellationToken token);
    internal static Stream GetCompressionStream(Stream stream, ExportCompressionAlgorithm compressionAlgorithm, CompressionLevel compressionLevel);
    internal static BackupInfo GetBackupInfo(BackupInfoParameters parameters);
    internal static PeriodicBackupStatus GetBackupStatusFromCluster(ServerStore serverStore, ClusterOperationContext context, string databaseName, long taskId);
    internal static BlittableJsonReaderObject GetResponsibleNodeInfoFromCluster(ServerStore serverStore, ClusterOperationContext context, string databaseName, long taskId);
    internal static long GetTasksCountOnNode(ServerStore serverStore, string databaseName, ClusterOperationContext context);
    internal static string GetResponsibleNodeTag(ServerStore serverStore, string databaseName, long taskId);
    internal static PeriodicBackupStatus ComparePeriodicBackupStatus(long taskId, PeriodicBackupStatus backupStatus, PeriodicBackupStatus inMemoryBackupStatus);
    private static List`1<string> AddDestinations(PeriodicBackupStatus backupStatus);
    public static NextBackup GetNextBackupDetails(NextBackupDetailsParameters parameters);
    internal static Nullable`1<DateTime> GetNextBackupOccurrence(NextBackupOccurrenceParameters parameters);
    public static DateTime GetNextBackupDateTime(Nullable`1<DateTime> nextFullBackup, Nullable`1<DateTime> nextIncrementalBackup, Nullable`1<DateTime> delayUntil);
    private static bool IsFullBackup(PeriodicBackupStatus backupStatus, PeriodicBackupConfiguration configuration, Nullable`1<DateTime> nextFullBackup, Nullable`1<DateTime> nextIncrementalBackup, string responsibleNodeTag);
    internal static void CheckServerHealthBeforeBackup(ServerStore serverStore, string name);
    public static PathSetting GetBackupTempPath(RavenConfiguration configuration, string dir, PathSetting& basePath);
    public static IdleDatabaseActivity GetEarliestIdleDatabaseActivity(EarliestIdleDatabaseActivityParameters parameters);
    private static IdleDatabaseActivity GetNextIdleDatabaseActivity(NextIdleDatabaseActivityParameters parameters);
    public static void SaveBackupStatus(PeriodicBackupStatus status, string databaseName, ServerStore serverStore, Logger logger, BackupResult backupResult, Action`1<IOperationProgress> onProgress, OperationCancelToken operationCancelToken);
}
[ExtensionAttribute]
public static class Raven.Server.Utils.CertificateUtils : object {
    private static int BitsPerByte;
    private static Logger Logger;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<ValueTuple`2<Byte[], Byte[]>> caKeyPair;
    private static CertificateUtils();
    private static string GetCertificateName(X509Certificate2 certificate);
    private static string GenerateCertificateChainDebugLog(X509Chain chain);
    internal static bool CertHasKnownIssuer(X509Certificate2 userCertificate, X509Certificate2 knownCertificate, SecurityConfiguration securityConfiguration, List`1<string> explanations);
    public static Byte[] CreateSelfSignedTestCertificate(string commonNameValue, string issuerName, StringBuilder log);
    private static void RemoveOldTestCertificatesFromOsStore(string commonNameValue);
    public static X509Certificate2 CreateSelfSignedClientCertificate(string commonNameValue, CertificateHolder certificateHolder, Byte[]& certBytes, DateTime notAfter);
    private static void ValidateNoPrivateKeyInServerCert(Byte[] serverCertBytes);
    public static X509Certificate2 CreateSelfSignedExpiredClientCertificate(string commonNameValue, CertificateHolder certificateHolder);
    public static void CreateSelfSignedCertificateBasedOnPrivateKey(string commonNameValue, X509Name issuer, ValueTuple`2<AsymmetricKeyParameter, AsymmetricKeyParameter> issuerKeyPair, bool isClientCertificate, bool isCaCertificate, DateTime notAfter, Byte[]& certBytes, AsymmetricCipherKeyPair subjectKeyPair, StringBuilder log);
    public static X509Certificate2 CreateCertificateAuthorityCertificate(string commonNameValue, ValueTuple`2& ca, X509Name& name, StringBuilder log);
    private static ValueTuple`2<Byte[], Byte[]> GenerateKey();
    private static AsymmetricCipherKeyPair GetRsaKey();
    public static SecureRandom GetSeededSecureRandom();
    public static string GetServerUrlFromCertificate(X509Certificate2 cert, SetupInfo setupInfo, string nodeTag, int port, int tcpPort, String& publicTcpUrl, String& domain);
    [IteratorStateMachineAttribute("Raven.Server.Utils.CertificateUtils/<GetCertificateAlternativeNames>d__18")]
public static IEnumerable`1<string> GetCertificateAlternativeNames(X509Certificate2 cert);
    public static void RegisterClientCertInOs(Action`1<IOperationProgress> onProgress, SetupProgressAndResult progress, X509Certificate2 clientCert);
    [AsyncStateMachineAttribute("Raven.Server.Utils.CertificateUtils/<CompleteAuthorizationAndGetCertificate>d__20")]
public static Task`1<X509Certificate2> CompleteAuthorizationAndGetCertificate(CompleteAuthorizationAndGetCertificateParameters parameters);
    private static X509Certificate2 BuildNewPfx(SetupInfo setupInfo, X509Certificate2 certificate, RSA privateKey);
    [ExtensionAttribute]
public static string GetBasicCertificateInfo(X509Certificate2 certificate);
}
public class Raven.Server.Utils.ChangeVector : object {
    internal static PerCoreContainer`1<FastList`1<ChangeVector>> PerCoreChangeVectors;
    private static char Separator;
    private string _changeVector;
    private ChangeVector _order;
    private ChangeVector _version;
    public ChangeVector Order { get; }
    public ChangeVector Version { get; }
    public bool IsNullOrEmpty { get; }
    public bool IsSingle { get; }
    public ChangeVector(string changeVector, IChangeVectorOperationContext context);
    public ChangeVector(ChangeVector version, ChangeVector order);
    public ChangeVector(string changeVector, bool throwOnRecursion, IChangeVectorOperationContext context);
    private static ChangeVector();
    public ChangeVector get_Order();
    public ChangeVector get_Version();
    public void Renew(string changeVector, bool throwOnRecursion, IChangeVectorOperationContext context);
    public void Renew(ChangeVector version, ChangeVector order);
    public bool get_IsNullOrEmpty();
    public bool get_IsSingle();
    public bool IsEqual(ChangeVector changeVector);
    public bool Contains(string dbId);
    public ChangeVector MergeWith(ChangeVector changeVector, IChangeVectorOperationContext context);
    public ChangeVector MergeWith(string changeVector, IChangeVectorOperationContext context);
    public ChangeVector UpdateOrder(string nodeTag, string dbId, long etag, IChangeVectorOperationContext context);
    public ChangeVector MergeOrderWith(ChangeVector changeVector, IChangeVectorOperationContext context);
    public ChangeVector UpdateVersion(string nodeTag, string dbId, long etag, IChangeVectorOperationContext context);
    public static ConflictStatus GetConflictStatusForDocument(ChangeVector remote, ChangeVector local);
    public static ConflictStatus GetConflictStatus(IChangeVectorOperationContext context, string remote, string local);
    private ChangeVector UpdateInternal(string nodeTag, string dbId, long etag, ChangeVector changeVector, IChangeVectorOperationContext context);
    private static ConflictStatus GetConflictStatusInternal(ChangeVector remote, ChangeVector local);
    public static ChangeVector Merge(ChangeVector cv1, ChangeVector cv2, IChangeVectorOperationContext context);
    public static ChangeVector MergeWithDatabaseChangeVector(DocumentsOperationContext context, ChangeVector changeVector);
    public static void MergeWithDatabaseChangeVector(DocumentsOperationContext context, string changeVector);
    public static ChangeVector MergeWithNewDatabaseChangeVector(DocumentsOperationContext context, ChangeVector changeVector, Nullable`1<long> newEtag);
    public static ChangeVector MergeWithNewDatabaseChangeVector(DocumentsOperationContext context, string changeVector);
    public static ChangeVector Merge(List`1<ChangeVector> changeVectors, IChangeVectorOperationContext context);
    public static int CompareVersion(ChangeVector changeVector1, ChangeVector changeVector2);
    public static int CompareVersion(ChangeVector changeVector1, string changeVector2, IChangeVectorOperationContext context);
    public static int CompareVersion(string changeVector1, string changeVector2, IChangeVectorOperationContext context);
    public ChangeVector RemoveId(string id, IChangeVectorOperationContext context);
    public bool TryRemoveIds(HashSet`1<string> ids, IChangeVectorOperationContext context, ChangeVector& changeVector);
    private ChangeVector StripTags(string tag, string exclude, IChangeVectorOperationContext context);
    public ChangeVector StripMoveTag(IChangeVectorOperationContext context);
    public static ChangeVector StripMoveTag(string changeVectorStr, IChangeVectorOperationContext context);
    public ChangeVector StripTrxnTags(IChangeVectorOperationContext context);
    public ChangeVector StripSinkTags(IChangeVectorOperationContext context);
    public ChangeVector StripSinkTags(string exclude, IChangeVectorOperationContext context);
    private static string StripTags(string from, string tag, string exclude);
    private void EnsureValid();
    [DoesNotReturnAttribute]
private void ThrowInvalidChangeVectorState();
    [DoesNotReturnAttribute]
private void ThrowInvalidInnerChangeVector();
    public static string op_Implicit(ChangeVector changeVector);
    public string AsString();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static bool <TryRemoveIds>g__TryRemoveIdsInternal|39_0(string changeVector, HashSet`1<string> ids, String& newChangeVector);
}
public enum Raven.Server.Utils.ChangeVectorMode : Enum {
    public int value__;
    public static ChangeVectorMode Version;
    public static ChangeVectorMode Order;
}
public static class Raven.Server.Utils.ChangeVectorUtils : object {
    [ThreadStaticAttribute]
private static StringBuilder _changeVectorBuffer;
    [ThreadStaticAttribute]
private static List`1<ChangeVectorEntry> _mergeVectorBuffer;
    private static ChangeVectorUtils();
    public static ConflictStatus GetConflictStatus(ChangeVector remoteChangeVector, ChangeVector localChangeVector, HashSet`1<string> exclude, ChangeVectorMode mode);
    public static ConflictStatus GetConflictStatus(string remoteAsString, string localAsString, HashSet`1<string> exclude);
    private static int NumberOfDigits(long etag);
    private static long ParseToLong(string s, int start, int len);
    public static ValueTuple`2<bool, string> TryUpdateChangeVector(DocumentDatabase database, ChangeVector oldChangeVector, Nullable`1<long> etag);
    public static ValueTuple`2<bool, string> TryUpdateChangeVector(string nodeTag, string dbIdInBase64, long etag, ChangeVector changeVector);
    private static void InitializeThreadLocalState();
    public static string MergeVectors(string vectorAstring, string vectorBstring);
    public static string MergeVectors(String[] changeVectors);
    public static string MergeVectors(List`1<string> changeVectors);
    public static ChangeVector MergeVectors(IChangeVectorOperationContext context, IEnumerable`1<ChangeVector> changeVectors);
    public static ChangeVector MergeVectors(IChangeVectorOperationContext context, IEnumerable`1<string> changeVectors);
    public static string MergeVectorsDown(List`1<string> changeVectors);
    public static ChangeVector NewChangeVector(DocumentDatabase database, long etag, IChangeVectorOperationContext context);
    public static string NewChangeVector(string nodeTag, long etag, string dbIdInBase64);
    public static long GetEtagById(string changeVector, string id);
    public static string GetNodeTagById(string changeVector, string id);
    public static long Distance(string changeVectorA, string changeVectorB);
    private static long ConsumeRest(List`1<ChangeVectorEntry> changeVectorEntries, Int32& index);
    public static string GetClusterWideChangeVector(string databaseId, long prevCountPerShard, bool addTrxAddition, long index, string clusterTransactionId);
}
public class Raven.Server.Utils.ChunkedMmapStream : Stream {
    private PtrSize[] _ptrsSizes;
    private Int32[] _positions;
    private int _maxChunkSize;
    private int _index;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ChunkedMmapStream(PtrSize[] ptrsSizes, int maxChunkSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    [CompilerGeneratedAttribute]
public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public static class Raven.Server.Utils.Cli.BrowserHelper : object {
    public static bool OpenStudioInBrowser(string url, Action`1<object> onError);
}
public class Raven.Server.Utils.Cli.ClusterMessage : ConsoleMessage {
    private string _nodeTag;
    private string _clusterId;
    public ClusterMessage(TextWriter tw, string nodeTag, string clusterId);
    public virtual void Print();
}
public static class Raven.Server.Utils.Cli.CommandLineConfigurationArgumentsHelper : object {
    public static String[] FormatCliArgPrefixes(string key);
    public static bool IsConfigurationKeyInCliArgs(string key, IEnumerable`1<string> cliArgs);
    public static int FindIndexOfCliOptFor(String[] args, string key);
}
internal class Raven.Server.Utils.Cli.CommandLineSwitches : object {
    public static string DefaultServiceName;
    private static CommandLineApplication _app;
    private static CommandOption _logToConsole;
    private static CommandOption _printIdOption;
    private static CommandOption _browserOption;
    private static CommandOption _versionOption;
    private static CommandOption _infoOption;
    private static CommandOption _nonInteractiveOption;
    private static CommandOption _serviceNameOption;
    private static CommandOption _helpOption;
    private static CommandOption _customConfigPathOption;
    public static bool PrintServerId { get; }
    public static bool LaunchBrowser { get; }
    public static bool PrintVersionAndExit { get; }
    public static bool PrintInfoAndExit { get; }
    public static bool NonInteractive { get; }
    public static string ServiceName { get; }
    public static string CustomConfigPath { get; }
    public static bool ShouldShowHelp { get; }
    public static bool LogToConsole { get; }
    public static bool get_PrintServerId();
    public static bool get_LaunchBrowser();
    public static bool get_PrintVersionAndExit();
    public static bool get_PrintInfoAndExit();
    public static bool get_NonInteractive();
    public static string get_ServiceName();
    public static string get_CustomConfigPath();
    public static bool get_ShouldShowHelp();
    public static bool get_LogToConsole();
    public static void ShowHelp();
    public static String[] Process(String[] args);
    private static void Validate();
    private static bool ParseSwitchOption(CommandOption opt);
}
public abstract class Raven.Server.Utils.Cli.ConsoleMessage : object {
    protected TextWriter _tw;
    protected ConsoleMessage(TextWriter tw);
    private bool WithColoring();
    public abstract virtual void Print();
    protected void ConsoleWriteWithColor(ConsoleText[] consoleTexts);
    protected void ConsoleWriteLineWithColor(ConsoleColor color, string message, Object[] args);
}
internal class Raven.Server.Utils.Cli.JavaScriptCli : object {
    private static string ExecutionStr;
    private static string ServerExecutionStr;
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private AdminJsConsole <AdminConsole>k__BackingField;
    public string Script { get; public set; }
    public AdminJsConsole AdminConsole { get; public set; }
    public bool CreateScript(TextReader reader, TextWriter writer, bool consoleColoring, DocumentDatabase database, RavenServer server);
    [CompilerGeneratedAttribute]
public string get_Script();
    [CompilerGeneratedAttribute]
public void set_Script(string value);
    [CompilerGeneratedAttribute]
public AdminJsConsole get_AdminConsole();
    [CompilerGeneratedAttribute]
public void set_AdminConsole(AdminJsConsole value);
}
public static class Raven.Server.Utils.Cli.PostSetupCliArgumentsUpdater : object {
    public static String[] Process(String[] configurationArgs, RavenConfiguration configBeforeRestart, RavenConfiguration currentConfiguration);
    private static String[] UpdateServerUrlCommandLineArgAfterSetupIfNecessary(String[] originalCommandLineArgs, String[] oldServerUrl, string newServerUrl);
    private static String[] FilterOutSetupModeArg(String[] args);
    private static String[] FilterOutArgByConfigurationKey(String[] args, string confKey);
    private static String[] FilterOutUnsecuredAccessAllowedIfNeeded(String[] args);
}
public class Raven.Server.Utils.Cli.RavenCli : object {
    public static string DelimiterKeyWord;
    private static Action`4<List`1<string>, bool, RavenServer, TextWriter> Prompt;
    private TextWriter _writer;
    private TextReader _reader;
    private RavenServer _server;
    private bool _experimental;
    private bool _consoleColoring;
    private bool _usingNamedPipes;
    private List`1<string> _promptArgs;
    private static ConsoleColor PromptHeaderColor;
    private static ConsoleColor PromptArrowColor;
    private static ConsoleColor UserInputColor;
    private static ConsoleColor WarningColor;
    private static ConsoleColor TextColor;
    private static ConsoleColor ErrorColor;
    private static string ServerAuthenticationOid;
    private static string ClientAuthenticationOid;
    private Dictionary`2<Command, SingleAction> _actions;
    private static RavenCli();
    public static string GetDelimiterString(Delimiter delimiter);
    private static void PrintCliHeader(RavenCli cli);
    private static void WriteError(string txt, RavenCli cli);
    private static void WriteWarning(string txt, RavenCli cli);
    private static void WriteText(string txt, ConsoleColor color, RavenCli cli, bool newLine);
    private static char ReadKey(RavenCli cli);
    private string ReadLine(RavenCli cli);
    private static bool CommandLogout(List`1<string> args, RavenCli cli);
    private static bool CommandShutdown(List`1<string> args, RavenCli cli);
    private static bool CommandOpenBrowser(List`1<string> args, RavenCli cli);
    private static bool CommandRestartServer(List`1<string> args, RavenCli cli);
    private static bool CommandStats(List`1<string> args, RavenCli cli);
    private static void SetupLogMode(LogMode logMode, LogsConfiguration configuration);
    private static bool CommandTopThreads(List`1<string> args, RavenCli cli);
    private static bool CommandPrompt(List`1<string> args, RavenCli cli);
    private static bool CommandHelpPrompt(List`1<string> args, RavenCli cli);
    private static bool CommandGc(List`1<string> args, RavenCli cli);
    private static bool CommandTimer(List`1<string> args, RavenCli cli);
    private static bool CommandLog(List`1<string> args, RavenCli cli);
    private static bool CommandClear(List`1<string> args, RavenCli cli);
    private static bool CommandInfo(List`1<string> args, RavenCli cli);
    public static string GetInfoText();
    private static bool CommandLogo(List`1<string> args, RavenCli cli);
    private static bool CommandExperimental(List`1<string> args, RavenCli cli);
    private static bool CommandTrustServerCert(List`1<string> args, RavenCli cli);
    private static bool CommandTrustClientCert(List`1<string> args, RavenCli cli);
    private static bool CommandGenerateClientCert(List`1<string> args, RavenCli cli);
    private static bool CommandReplaceClusterCert(List`1<string> args, RavenCli cli);
    private static bool CommandTriggerCertificateRefresh(List`1<string> args, RavenCli cli);
    private static bool CommandScript(List`1<string> args, RavenCli cli);
    public static string ConvertResultToString(ScriptRunnerResult result);
    private static bool CommandLowMem(List`1<string> args, RavenCli cli);
    public static ValueTuple`5<string, string, string, string, string> MemoryStatsWithMemoryMappedInfo();
    private static bool CommandImportDir(List`1<string> args, RavenCli cli);
    private static bool CommandCreateDb(List`1<string> args, RavenCli cli);
    private static bool CommandPrint(List`1<string> args, RavenCli cli);
    private static bool CommandHelp(List`1<string> args, RavenCli cli);
    public bool Start(RavenServer server, TextWriter textWriter, TextReader textReader, bool consoleColoring, bool usingNamedPipes);
    private bool StartCli();
    private static void PrintBothToConsoleAndRemotePipe(string str, RavenCli cli, Delimiter delimiter);
    private static Command GetCommand(string fromWord);
    private bool ParseLine(string line, ParsedLine parsedLine, List`1<string> recursiveWords, Nullable`1<ConcatAction> lastAction);
}
public class Raven.Server.Utils.Cli.RuntimeSettings : ConsoleMessage {
    public RuntimeSettings(TextWriter tw);
    private static ValueTuple`2<bool, bool> TryGetRetainVMSettingValue();
    public static string Describe();
    public virtual void Print();
}
public class Raven.Server.Utils.Cli.WelcomeMessage : ConsoleMessage {
    public static string AsciiHeader;
    public WelcomeMessage(TextWriter tw);
    public virtual void Print();
}
[ExtensionAttribute]
public static class Raven.Server.Utils.ConcurrentQueueExtensions : object {
    [ExtensionAttribute]
public static void LimitedSizeEnqueue(ConcurrentQueue`1<T> queue, T item, int sizeOfQueue);
}
public static class Raven.Server.Utils.Configuration.ClientConfigurationHelper : object {
    public static bool HasClientConfigurationChanged(ClientConfiguration clientConfiguration, ServerStore serverStore, long index);
    public static long GetClientConfigurationEtag(ClientConfiguration clientConfiguration, ServerStore serverStore);
}
public class Raven.Server.Utils.ConflictResolverAdvisor : object {
    private BlittableJsonReaderObject[] _docs;
    internal bool IsMetadataResolver;
    private JsonOperationContext _context;
    public ConflictResolverAdvisor(IEnumerable`1<BlittableJsonReaderObject> docs, JsonOperationContext ctx, bool isMetadataResolver);
    public MergeResult Resolve(int indent);
    private bool TryHandleObjectValue(int index, Dictionary`2<string, object> result, KeyValuePair`2<string, BlittableJsonReaderObject> prop);
    private bool TryHandleArrayValue(int index, Dictionary`2<string, object> result, KeyValuePair`2<string, BlittableJsonReaderArray> prop);
    private void HandleSimpleValues(Dictionary`2<string, object> result, PropertyDetails prop, int index);
    private static void WriteToken(ManualBlittableJsonDocumentBuilder`1<UnmanagedWriteBuffer> writer, string propertyName, object propertyValue);
    private static void WriteConflictResolver(string name, ManualBlittableJsonDocumentBuilder`1<UnmanagedWriteBuffer> documentWriter, ManualBlittableJsonDocumentBuilder`1<UnmanagedWriteBuffer> metadataWriter, ConflictResolverAdvisor resolver, int indent);
    private MergeResult GenerateOutput(Dictionary`2<string, object> result, int indent);
}
public enum Raven.Server.Utils.ConflictStatus : Enum {
    public int value__;
    public static ConflictStatus Update;
    public static ConflictStatus Conflict;
    public static ConflictStatus AlreadyMerged;
}
public static class Raven.Server.Utils.Cpu.CpuHelper : object {
    private static Logger Logger;
    private static CpuHelper();
    internal static ICpuUsageCalculator GetOSCpuUsageCalculator();
    internal static ExtensionPointCpuUsageCalculator GetExtensionPointCpuUsageCalculator(JsonContextPool contextPool, MonitoringConfiguration configuration, ServerNotificationCenter notificationCenter);
    public static long GetNumberOfActiveCores(Process process);
    public static ValueTuple`2<long, long> GetProcessTimes(Process process);
}
internal abstract class Raven.Server.Utils.Cpu.CpuUsageCalculator`1 : object {
    protected Logger Logger;
    private object _locker;
    protected CpuUsageStats LastCpuUsage;
    protected T PreviousInfo;
    public sealed virtual void Init();
    protected abstract virtual ValueTuple`2<double, Nullable`1<double>> CalculateMachineCpuUsage(T processInfo);
    public sealed virtual CpuUsageStats Calculate();
    protected abstract virtual T GetProcessInfo();
    private double CalculateProcessCpuUsage(ProcessInfo currentInfo, double machineCpuUsage);
    public sealed virtual void Dispose();
}
public class Raven.Server.Utils.Cpu.CpuUsageExtensionPoint : object {
    private JsonContextPool _contextPool;
    private Logger _logger;
    private ServerNotificationCenter _notificationCenter;
    private ProcessStartInfo _startInfo;
    private TimeSpan _timeout;
    private Process _process;
    private DateTime _lastRestart;
    private ExtensionPointData _data;
    public ExtensionPointData BadData;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public ExtensionPointData Data { get; }
    public bool IsDisposed { get; private set; }
    public CpuUsageExtensionPoint(JsonContextPool contextPool, string exec, string args, ServerNotificationCenter notificationCenter);
    public ExtensionPointData get_Data();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public void Start();
    [AsyncStateMachineAttribute("Raven.Server.Utils.Cpu.CpuUsageExtensionPoint/<ReadErrors>d__17")]
private Task ReadErrors();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Server.Utils.Cpu.CpuUsageExtensionPoint/<ReadProcess>d__19")]
private Task ReadProcess();
    private bool HandleInfoReceived(string data);
    private bool TryGetCpuUsage(BlittableJsonReaderObject blittable, string propertyName, Double& cpuUsage);
    private void HandleError(string msg, Exception e);
    private void NotifyWarning(string warningMsg, Exception e);
}
public class Raven.Server.Utils.Cpu.CpuUsageStats : object {
    public static CpuUsageStats EmptyCpuUsage;
    public double MachineCpuUsage;
    public double ProcessCpuUsage;
    public Nullable`1<double> MachineIoWait;
    public CpuUsageStats(double machineCpuUsage, double processCpuUsage, Nullable`1<double> machineIoWait);
    private static CpuUsageStats();
}
internal class Raven.Server.Utils.Cpu.ExtensionPointCpuUsageCalculator : object {
    private CpuUsageExtensionPoint _inspector;
    public ExtensionPointCpuUsageCalculator(JsonContextPool contextPool, string exec, string args, ServerNotificationCenter notificationCenter);
    public sealed virtual CpuUsageStats Calculate();
    public sealed virtual void Init();
    public sealed virtual void Dispose();
}
public class Raven.Server.Utils.Cpu.ExtensionPointData : ValueType {
    [CompilerGeneratedAttribute]
private double <MachineCpuUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ProcessCpuUsage>k__BackingField;
    public double MachineCpuUsage { get; public set; }
    public double ProcessCpuUsage { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_MachineCpuUsage();
    [CompilerGeneratedAttribute]
public void set_MachineCpuUsage(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_ProcessCpuUsage();
    [CompilerGeneratedAttribute]
public void set_ProcessCpuUsage(double value);
}
public interface Raven.Server.Utils.Cpu.ICpuUsageCalculator {
    public abstract virtual CpuUsageStats Calculate();
    public abstract virtual void Init();
}
internal class Raven.Server.Utils.Cpu.LinuxCpuUsageCalculator : CpuUsageCalculator`1<LinuxInfo> {
    private static Char[] Separators;
    private static LinuxCpuUsageCalculator();
    protected virtual ValueTuple`2<double, Nullable`1<double>> CalculateMachineCpuUsage(LinuxInfo linuxInfo);
    protected virtual LinuxInfo GetProcessInfo();
}
internal class Raven.Server.Utils.Cpu.LinuxInfo : ProcessInfo {
    [CompilerGeneratedAttribute]
private ulong <TotalUserTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TotalUserLowTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TotalSystemTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TotalIdleTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TotalIoWait>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TotalIRQTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TotalSoftIRQTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TotalStealTime>k__BackingField;
    private ulong TotalUserTime { get; public set; }
    private ulong TotalUserLowTime { get; public set; }
    private ulong TotalSystemTime { get; public set; }
    private ulong TotalIdleTime { get; public set; }
    public ulong TotalIoWait { get; public set; }
    private ulong TotalIRQTime { get; public set; }
    private ulong TotalSoftIRQTime { get; public set; }
    private ulong TotalStealTime { get; public set; }
    public ulong TotalWorkTime { get; }
    public ulong TotalIdle { get; }
    [CompilerGeneratedAttribute]
private ulong get_TotalUserTime();
    [CompilerGeneratedAttribute]
public void set_TotalUserTime(ulong value);
    [CompilerGeneratedAttribute]
private ulong get_TotalUserLowTime();
    [CompilerGeneratedAttribute]
public void set_TotalUserLowTime(ulong value);
    [CompilerGeneratedAttribute]
private ulong get_TotalSystemTime();
    [CompilerGeneratedAttribute]
public void set_TotalSystemTime(ulong value);
    [CompilerGeneratedAttribute]
private ulong get_TotalIdleTime();
    [CompilerGeneratedAttribute]
public void set_TotalIdleTime(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_TotalIoWait();
    [CompilerGeneratedAttribute]
public void set_TotalIoWait(ulong value);
    [CompilerGeneratedAttribute]
private ulong get_TotalIRQTime();
    [CompilerGeneratedAttribute]
public void set_TotalIRQTime(ulong value);
    [CompilerGeneratedAttribute]
private ulong get_TotalSoftIRQTime();
    [CompilerGeneratedAttribute]
public void set_TotalSoftIRQTime(ulong value);
    [CompilerGeneratedAttribute]
private ulong get_TotalStealTime();
    [CompilerGeneratedAttribute]
public void set_TotalStealTime(ulong value);
    public ulong get_TotalWorkTime();
    public ulong get_TotalIdle();
}
internal class Raven.Server.Utils.Cpu.MacInfo : ProcessInfo {
    [CompilerGeneratedAttribute]
private ulong <TotalTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <IdleTicks>k__BackingField;
    public ulong TotalTicks { get; public set; }
    public ulong IdleTicks { get; public set; }
    [CompilerGeneratedAttribute]
public ulong get_TotalTicks();
    [CompilerGeneratedAttribute]
public void set_TotalTicks(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_IdleTicks();
    [CompilerGeneratedAttribute]
public void set_IdleTicks(ulong value);
}
internal class Raven.Server.Utils.Cpu.MacInfoCpuUsageCalculator : CpuUsageCalculator`1<MacInfo> {
    private static int HostCpuLoadInfoSize;
    private static MacInfoCpuUsageCalculator();
    protected virtual ValueTuple`2<double, Nullable`1<double>> CalculateMachineCpuUsage(MacInfo macInfo);
    protected virtual MacInfo GetProcessInfo();
}
internal class Raven.Server.Utils.Cpu.ProcessInfo : object {
    [CompilerGeneratedAttribute]
private long <TotalProcessorTimeTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TimeTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ActiveCores>k__BackingField;
    public long TotalProcessorTimeTicks { get; }
    public long TimeTicks { get; }
    public long ActiveCores { get; }
    [CompilerGeneratedAttribute]
public long get_TotalProcessorTimeTicks();
    [CompilerGeneratedAttribute]
public long get_TimeTicks();
    [CompilerGeneratedAttribute]
public long get_ActiveCores();
}
internal class Raven.Server.Utils.Cpu.WindowsCpuUsageCalculator : CpuUsageCalculator`1<WindowsInfo> {
    protected virtual ValueTuple`2<double, Nullable`1<double>> CalculateMachineCpuUsage(WindowsInfo windowsInfo);
    protected virtual WindowsInfo GetProcessInfo();
    internal static bool GetSystemTimes(FileTime& lpIdleTime, FileTime& lpKernelTime, FileTime& lpUserTime);
    internal static ulong GetTime(FileTime fileTime);
}
internal class Raven.Server.Utils.Cpu.WindowsInfo : ProcessInfo {
    [CompilerGeneratedAttribute]
private ulong <SystemIdleTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SystemKernelTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SystemUserTime>k__BackingField;
    public ulong SystemIdleTime { get; public set; }
    public ulong SystemKernelTime { get; public set; }
    public ulong SystemUserTime { get; public set; }
    [CompilerGeneratedAttribute]
public ulong get_SystemIdleTime();
    [CompilerGeneratedAttribute]
public void set_SystemIdleTime(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_SystemKernelTime();
    [CompilerGeneratedAttribute]
public void set_SystemKernelTime(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_SystemUserTime();
    [CompilerGeneratedAttribute]
public void set_SystemUserTime(ulong value);
}
public static class Raven.Server.Utils.CultureHelper : object {
    private static Lazy`1<Dictionary`2<string, CultureInfo>> CulturesLazy;
    internal static Dictionary`2<string, CultureInfo> Cultures { get; }
    private static CultureHelper();
    internal static IDisposable EnsureInvariantCulture();
    internal static IDisposable EnsureCulture(CultureInfo culture);
    internal static Dictionary`2<string, CultureInfo> get_Cultures();
}
public static class Raven.Server.Utils.DebuggerAttachedTimeout : object {
    public static bool DisableLongTimespan;
    private static bool IsDisabled { get; }
    private static DebuggerAttachedTimeout();
    private static bool get_IsDisabled();
    [ConditionalAttribute("DEBUG")]
public static void OutgoingReplication(Int32& timespan);
    [ConditionalAttribute("DEBUG")]
public static void SendTimeout(Int32& timespan);
    [ConditionalAttribute("DEBUG")]
public static void LongTimespanIfDebugging(TimeSpan& timespan);
}
public class Raven.Server.Utils.DeleteOnCloseZipArchive : ZipArchive {
    private string _filePath;
    public DeleteOnCloseZipArchive(Stream stream, ZipArchiveMode mode);
    protected virtual void Dispose(bool disposing);
}
public static class Raven.Server.Utils.DirectoryExecUtils : object {
    public static void SubscribeToOnDirectoryInitializeExec(StorageEnvironmentOptions options, StorageConfiguration config, string databaseName, EnvironmentType envType, Logger logger);
    public static void OnDirectoryInitialize(StorageEnvironmentOptions options, DirectoryParameters parameters, Logger log);
    [CompilerGeneratedAttribute]
internal static string <OnDirectoryInitialize>g__GetStdError|1_0(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static string <OnDirectoryInitialize>g__GetStdOut|1_1(<>c__DisplayClass1_0& );
}
public class Raven.Server.Utils.DisposableLazy`1 : object {
    private Lazy`1<T> _lazy;
    public T Value { get; }
    public bool IsValueCreated { get; }
    public DisposableLazy`1(Func`1<T> factory);
    public T get_Value();
    public bool get_IsValueCreated();
    public sealed virtual void Dispose();
}
internal static class Raven.Server.Utils.EchoServer : object {
    private static Logger Logger;
    private static EchoServer();
    public static void StartEchoSockets(Nullable`1<int> echoSocketPort);
    [AsyncStateMachineAttribute("Raven.Server.Utils.EchoServer/<EchoSocketAsync>d__2")]
private static Task EchoSocketAsync(int port);
    private static void EchoSocketSync(object o);
    [AsyncStateMachineAttribute("Raven.Server.Utils.EchoServer/<EchoAsync>d__4")]
private static Task EchoAsync(Socket s);
    private static void EchoSync(object o);
    private static void CreateLogfile(EndPoint remote);
}
public abstract class Raven.Server.Utils.Enumerators.PulsedEnumerationState`1 : object {
    public static int DefaultNumberOfEnumeratedDocumentsToCheckIfPulseLimitExceeded;
    private int _numberOfEnumeratedDocumentsToCheckIfPulseLimitExceeded;
    protected DocumentsOperationContext Context;
    private Size _pulseLimit;
    public int ReadCount;
    protected PulsedEnumerationState`1(DocumentsOperationContext context, Size pulseLimit, int numberOfEnumeratedDocumentsToCheckIfPulseLimitExceeded);
    public virtual bool ShouldPulseTransaction();
    public abstract virtual void OnMoveNext(T current);
}
public class Raven.Server.Utils.Enumerators.PulsedTransactionEnumerator`2 : object {
    private DocumentsOperationContext _context;
    private Func`2<TState, IEnumerable`1<T>> _getEnumerable;
    private Func`2<TState, IEnumerator`1<T>> _getEnumerator;
    private TState _state;
    private IEnumerator`1<T> _innerEnumerator;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    public PulsedTransactionEnumerator`2(DocumentsOperationContext context, Func`2<TState, IEnumerable`1<T>> getEnumerable, TState state);
    public PulsedTransactionEnumerator`2(DocumentsOperationContext context, Func`2<TState, IEnumerator`1<T>> getEnumerator, TState state);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(T value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
}
public abstract class Raven.Server.Utils.Enumerators.TransactionForgetAboutAbstractEnumerator`1 : object {
    private IEnumerator`1<T> _innerEnumerator;
    protected DocumentsOperationContext DocsContext;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    protected TransactionForgetAboutAbstractEnumerator`1(IEnumerator`1<T> innerEnumerator, DocumentsOperationContext docsContext);
    protected abstract virtual void ForgetAbout(T item);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(T value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
}
[TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Raven.Server.Utils.Enumerators.TransactionForgetAboutCurrentPreviousRevisionEnumerator : TransactionForgetAboutAbstractEnumerator`1<ValueTuple`2<Document, Document>> {
    public TransactionForgetAboutCurrentPreviousRevisionEnumerator(IEnumerator`1<ValueTuple`2<Document, Document>> innerEnumerator, DocumentsOperationContext docsContext);
    protected virtual void ForgetAbout(ValueTuple`2<Document, Document> item);
}
public class Raven.Server.Utils.Enumerators.TransactionForgetAboutDocumentEnumerator : TransactionForgetAboutAbstractEnumerator`1<Document> {
    public TransactionForgetAboutDocumentEnumerator(IEnumerator`1<Document> innerEnumerator, DocumentsOperationContext docsContext);
    protected virtual void ForgetAbout(Document item);
}
[ExtensionAttribute]
public static class Raven.Server.Utils.EnumExtensions : object {
    [ExtensionAttribute]
public static string GetDescription(Enum value);
}
public class Raven.Server.Utils.ExceptionAggregator : object {
    private Logger _logger;
    private string _errorMsg;
    private ConcurrentSet`1<Exception> _list;
    public ExceptionAggregator(string errorMsg);
    public ExceptionAggregator(Logger logger, string errorMsg);
    public void Execute(IDisposable d);
    public void Execute(Action action);
    [AsyncStateMachineAttribute("Raven.Server.Utils.ExceptionAggregator/<ExecuteAsync>d__7")]
public Task ExecuteAsync(Task task);
    [AsyncStateMachineAttribute("Raven.Server.Utils.ExceptionAggregator/<ExecuteAsync>d__8")]
public Task ExecuteAsync(ValueTask task);
    public AggregateException GetAggregateException();
    public void ThrowIfNeeded();
}
[ExtensionAttribute]
public static class Raven.Server.Utils.ExceptionHelper : object {
    private static int ERROR_COMMITMENT_LIMIT;
    [ExtensionAttribute]
public static bool IsIndexError(Exception e);
    [ExtensionAttribute]
public static bool IsOutOfMemory(Exception e);
    [ExtensionAttribute]
public static bool IsOutOfDiskSpaceException(Exception ioe);
    [ExtensionAttribute]
public static bool IsMediaWriteProtected(IOException ioe);
    [ExtensionAttribute]
public static bool IsRavenDiskFullException(Exception e);
    [ExtensionAttribute]
public static bool IsPageFileTooSmall(Exception e);
    [DoesNotReturnAttribute]
public static void ThrowMediaIsWriteProtected(Exception inner);
    [DoesNotReturnAttribute]
public static void ThrowDiskFullException(string path);
}
public enum Raven.Server.Utils.Features.Feature : Enum {
    public int value__;
    [DescriptionAttribute("PostgreSQL")]
public static Feature PostgreSql;
    [DescriptionAttribute("Corax")]
public static Feature Corax;
}
public class Raven.Server.Utils.Features.FeatureGuardian : object {
    private RavenConfiguration _configuration;
    public bool AnyExperimental;
    public FeatureGuardian(RavenConfiguration configuration);
    public void Assert(Feature feature, Func`1<string> getExceptionMessage);
    public bool CanUse(Feature feature);
    private void AssertExperimental(Feature feature, Func`1<string> getExceptionMessage);
}
public enum Raven.Server.Utils.Features.FeaturesAvailability : Enum {
    public int value__;
    public static FeaturesAvailability Stable;
    public static FeaturesAvailability Experimental;
}
public class Raven.Server.Utils.FileLocker : ValueType {
    private static ConcurrentDictionary`2<string, object> _inMemoryLocks;
    private bool _inMemLock;
    private string _lockFile;
    private FileStream _writeLockFile;
    public FileLocker(string lockFile);
    private static FileLocker();
    public void TryAcquireWriteLock(Logger logger, int numberOfRetries);
    public sealed virtual void Dispose();
}
public static class Raven.Server.Utils.HttpResponseHelper : object {
    private static HashSet`1<string> HeadersToIgnore;
    private static HttpResponseHelper();
    public static void CopyStatusCode(HttpResponseMessage from, HttpResponse to);
    public static void CopyHeaders(HttpResponseMessage from, HttpResponse to);
    public static Task CopyContentAsync(HttpResponseMessage from, HttpResponse to);
}
internal class Raven.Server.Utils.Imports.Memory.CacheEntry : object {
    private static Action`1<object> ExpirationCallback;
    private MemoryCache _cache;
    private CacheEntryTokens _tokens;
    private Nullable`1<TimeSpan> _absoluteExpirationRelativeToNow;
    private Nullable`1<TimeSpan> _slidingExpiration;
    private Nullable`1<long> _size;
    private CacheEntry _previous;
    private object _value;
    private CacheEntryState _state;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <AbsoluteExpiration>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastAccessed>k__BackingField;
    public Nullable`1<DateTimeOffset> AbsoluteExpiration { get; public set; }
    public Nullable`1<TimeSpan> AbsoluteExpirationRelativeToNow { get; public set; }
    public Nullable`1<TimeSpan> SlidingExpiration { get; public set; }
    public IList`1<IChangeToken> ExpirationTokens { get; }
    public IList`1<PostEvictionCallbackRegistration> PostEvictionCallbacks { get; }
    public CacheItemPriority Priority { get; public set; }
    public Nullable`1<long> Size { get; public set; }
    public object Key { get; private set; }
    public object Value { get; public set; }
    internal DateTimeOffset LastAccessed { get; internal set; }
    internal EvictionReason EvictionReason { get; private set; }
    internal CacheEntry(object key, MemoryCache memoryCache);
    private static CacheEntry();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_AbsoluteExpiration();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AbsoluteExpiration(Nullable`1<DateTimeOffset> value);
    public sealed virtual Nullable`1<TimeSpan> get_AbsoluteExpirationRelativeToNow();
    public sealed virtual void set_AbsoluteExpirationRelativeToNow(Nullable`1<TimeSpan> value);
    public sealed virtual Nullable`1<TimeSpan> get_SlidingExpiration();
    public sealed virtual void set_SlidingExpiration(Nullable`1<TimeSpan> value);
    public sealed virtual IList`1<IChangeToken> get_ExpirationTokens();
    public sealed virtual IList`1<PostEvictionCallbackRegistration> get_PostEvictionCallbacks();
    public sealed virtual CacheItemPriority get_Priority();
    public sealed virtual void set_Priority(CacheItemPriority value);
    public sealed virtual Nullable`1<long> get_Size();
    public sealed virtual void set_Size(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(object value);
    public sealed virtual object get_Value();
    public sealed virtual void set_Value(object value);
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_LastAccessed();
    [CompilerGeneratedAttribute]
internal void set_LastAccessed(DateTimeOffset value);
    internal EvictionReason get_EvictionReason();
    private void set_EvictionReason(EvictionReason value);
    public sealed virtual void Dispose();
    internal bool CheckExpired(DateTimeOffset& now);
    internal void SetExpired(EvictionReason reason);
    private bool CheckForExpiredTime(DateTimeOffset& now);
    internal void AttachTokens();
    private static void ExpirationTokensExpired(object obj);
    internal void InvokeEvictionCallbacks();
    internal bool CanPropagateOptions();
    internal void PropagateOptions(CacheEntry parent);
    private CacheEntryTokens GetOrCreateTokens();
    [CompilerGeneratedAttribute]
private bool <CheckForExpiredTime>g__FullCheck|49_0(DateTimeOffset& offset);
}
internal static class Raven.Server.Utils.Imports.Memory.CacheEntryHelper : object {
    private static AsyncLocal`1<CacheEntry> _current;
    internal static CacheEntry Current { get; private set; }
    private static CacheEntryHelper();
    internal static CacheEntry get_Current();
    private static void set_Current(CacheEntry value);
    internal static CacheEntry EnterScope(CacheEntry current);
    internal static void ExitScope(CacheEntry current, CacheEntry previous);
}
public class Raven.Server.Utils.Imports.Memory.MemoryCache : object {
    internal ILogger _logger;
    private MemoryCacheOptions _options;
    private CoherentState _coherentState;
    private bool _disposed;
    private DateTimeOffset _lastExpirationScan;
    [CompilerGeneratedAttribute]
private bool <TrackLinkedCacheEntries>k__BackingField;
    public int Count { get; }
    internal long Size { get; }
    internal bool TrackLinkedCacheEntries { get; }
    public IEnumerable`1<KeyValuePair`2<object, object>> EntriesForDebug { get; }
    public MemoryCache(IOptions`1<MemoryCacheOptions> optionsAccessor);
    public MemoryCache(IOptions`1<MemoryCacheOptions> optionsAccessor, ILoggerFactory loggerFactory);
    protected virtual override void Finalize();
    public int get_Count();
    internal long get_Size();
    [CompilerGeneratedAttribute]
internal bool get_TrackLinkedCacheEntries();
    public sealed virtual ICacheEntry CreateEntry(object key);
    internal void SetEntry(CacheEntry entry);
    public sealed virtual bool TryGetValue(object key, Object& result);
    public sealed virtual void Remove(object key);
    public void Clear();
    internal void EntryExpired(CacheEntry entry);
    private void StartScanForExpiredItemsIfNeeded(DateTimeOffset utcNow);
    private static void ScanForExpiredItems(MemoryCache cache);
    private bool UpdateCacheSizeExceedsCapacity(CacheEntry entry, CoherentState coherentState);
    private void TriggerOvercapacityCompaction();
    private static void OvercapacityCompaction(MemoryCache cache);
    public void Compact(double percentage);
    private void Compact(long removalSizeTarget, Func`2<CacheEntry, long> computeEntrySize, CoherentState coherentState);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void CheckDisposed();
    private static void ValidateCacheKey(object key);
    public IEnumerable`1<KeyValuePair`2<object, object>> get_EntriesForDebug();
    [CompilerGeneratedAttribute]
private void <StartScanForExpiredItemsIfNeeded>g__ScheduleTask|21_0(DateTimeOffset utcNow);
    [CompilerGeneratedAttribute]
internal static void <Compact>g__ExpirePriorityBucket|27_0(Int64& removedSize, long removalSizeTarget, Func`2<CacheEntry, long> computeEntrySize, List`1<CacheEntry> entriesToRemove, List`1<ValueTuple`2<CacheEntry, DateTimeOffset>> priorityEntries);
    [CompilerGeneratedAttribute]
internal static void <CheckDisposed>g__Throw|30_0();
    [CompilerGeneratedAttribute]
internal static void <ValidateCacheKey>g__Throw|31_0();
}
public class Raven.Server.Utils.Imports.Memory.MemoryCacheOptions : object {
    private Nullable`1<long> _sizeLimit;
    private double _compactionPercentage;
    [CompilerGeneratedAttribute]
private ISystemClock <Clock>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ExpirationScanFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackLinkedCacheEntries>k__BackingField;
    public ISystemClock Clock { get; public set; }
    public TimeSpan ExpirationScanFrequency { get; public set; }
    public Nullable`1<long> SizeLimit { get; public set; }
    public double CompactionPercentage { get; public set; }
    public bool TrackLinkedCacheEntries { get; public set; }
    private MemoryCacheOptions Microsoft.Extensions.Options.IOptions<Raven.Server.Utils.Imports.Memory.MemoryCacheOptions>.Value { get; }
    [CompilerGeneratedAttribute]
public ISystemClock get_Clock();
    [CompilerGeneratedAttribute]
public void set_Clock(ISystemClock value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ExpirationScanFrequency();
    [CompilerGeneratedAttribute]
public void set_ExpirationScanFrequency(TimeSpan value);
    public Nullable`1<long> get_SizeLimit();
    public void set_SizeLimit(Nullable`1<long> value);
    public double get_CompactionPercentage();
    public void set_CompactionPercentage(double value);
    [CompilerGeneratedAttribute]
public bool get_TrackLinkedCacheEntries();
    [CompilerGeneratedAttribute]
public void set_TrackLinkedCacheEntries(bool value);
    private sealed virtual override MemoryCacheOptions Microsoft.Extensions.Options.IOptions<Raven.Server.Utils.Imports.Memory.MemoryCacheOptions>.get_Value();
}
public static class Raven.Server.Utils.IncludeUtil : object {
    private static char PrefixSeparator;
    private static char SuffixSeparator;
    private static string SuffixStart;
    private static Char[] PrefixSeparatorChar;
    private static IncludeUtil();
    public static void GetDocIdFromInclude(BlittableJsonReaderObject docReader, StringSegment includePath, HashSet`1<string> includedIds, char identityPartsSeparator);
    public static void GetDocIdFromInclude(BlittableJsonReaderObject docReader, StringSegment includePath, char identityPartsSeparator, TIncludeOp op);
    private static bool HasSuffixSeparator(StringSegment includePath, Int32& indexOfPrefixStart);
    private static string HandleSuffixValue(object val, StringSegment suffixSegment, char identityPartsSeparator);
    private static string HandlePrefixValue(object val, StringSegment prefixSegment, char identityPartsSeparator);
    private static string ValueWithPrefix(object val, StringSegment prefixSegment, char identityPartsSeparator);
    private static string BlittableValueToString(object value);
}
public static class Raven.Server.Utils.IOExtensions : object {
    private static int Retries;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static EventHandler`1<ValueTuple`3<string, TimeSpan, int>> AfterGc;
    public static void DeleteFile(string file);
    public static void RenameFile(string oldFile, string newFile);
    public static bool EnsureReadWritePermissionForDirectory(string directory);
    public static void MoveDirectory(string src, string dst);
    public static void DeleteDirectory(string directory);
    public static void CreateDirectory(string directory);
    private static void TryHandlingError(string directory, int i, Exception e);
    private static void SetDirectoryAttributes(string path, FileAttributes attributes);
    private static void RunGc(string path, int attempt);
}
public enum Raven.Server.Utils.IoMetrics.FileStatus : Enum {
    public int value__;
    public static FileStatus Closed;
    public static FileStatus InUse;
}
public class Raven.Server.Utils.IoMetrics.IOMetricsEnvironment : object {
    [CompilerGeneratedAttribute]
private StorageEnvironmentType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IOMetricsFileStats> <Files>k__BackingField;
    public StorageEnvironmentType Type { get; public set; }
    public string Path { get; public set; }
    public List`1<IOMetricsFileStats> Files { get; public set; }
    [CompilerGeneratedAttribute]
public StorageEnvironmentType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(StorageEnvironmentType value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public List`1<IOMetricsFileStats> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(List`1<IOMetricsFileStats> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.IoMetrics.IOMetricsFileStats : object {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private FileStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IOMetricsRecentStats> <Recent>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IOMetricsHistoryStats> <History>k__BackingField;
    public string File { get; public set; }
    public FileStatus Status { get; public set; }
    public List`1<IOMetricsRecentStats> Recent { get; public set; }
    public List`1<IOMetricsHistoryStats> History { get; public set; }
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public FileStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(FileStatus value);
    [CompilerGeneratedAttribute]
public List`1<IOMetricsRecentStats> get_Recent();
    [CompilerGeneratedAttribute]
public void set_Recent(List`1<IOMetricsRecentStats> value);
    [CompilerGeneratedAttribute]
public List`1<IOMetricsHistoryStats> get_History();
    [CompilerGeneratedAttribute]
public void set_History(List`1<IOMetricsHistoryStats> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.IoMetrics.IOMetricsHistoryStats : object {
    [CompilerGeneratedAttribute]
private string <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private string <End>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HumaneSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HumaneFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ActiveDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAcceleration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinAcceleration>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HumaneCompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterType <Type>k__BackingField;
    public string Start { get; public set; }
    public string End { get; public set; }
    public long Size { get; public set; }
    public string HumaneSize { get; public set; }
    public long FileSize { get; public set; }
    public string HumaneFileSize { get; public set; }
    public double Duration { get; public set; }
    public double ActiveDuration { get; public set; }
    public double MaxDuration { get; public set; }
    public double MinDuration { get; public set; }
    public int MaxAcceleration { get; public set; }
    public int MinAcceleration { get; public set; }
    public long CompressedSize { get; public set; }
    public string HumaneCompressedSize { get; public set; }
    public MeterType Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(string value);
    [CompilerGeneratedAttribute]
public string get_End();
    [CompilerGeneratedAttribute]
public void set_End(string value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(long value);
    [CompilerGeneratedAttribute]
public string get_HumaneSize();
    [CompilerGeneratedAttribute]
public void set_HumaneSize(string value);
    [CompilerGeneratedAttribute]
public long get_FileSize();
    [CompilerGeneratedAttribute]
public void set_FileSize(long value);
    [CompilerGeneratedAttribute]
public string get_HumaneFileSize();
    [CompilerGeneratedAttribute]
public void set_HumaneFileSize(string value);
    [CompilerGeneratedAttribute]
public double get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(double value);
    [CompilerGeneratedAttribute]
public double get_ActiveDuration();
    [CompilerGeneratedAttribute]
public void set_ActiveDuration(double value);
    [CompilerGeneratedAttribute]
public double get_MaxDuration();
    [CompilerGeneratedAttribute]
public void set_MaxDuration(double value);
    [CompilerGeneratedAttribute]
public double get_MinDuration();
    [CompilerGeneratedAttribute]
public void set_MinDuration(double value);
    [CompilerGeneratedAttribute]
public int get_MaxAcceleration();
    [CompilerGeneratedAttribute]
public void set_MaxAcceleration(int value);
    [CompilerGeneratedAttribute]
public int get_MinAcceleration();
    [CompilerGeneratedAttribute]
public void set_MinAcceleration(int value);
    [CompilerGeneratedAttribute]
public long get_CompressedSize();
    [CompilerGeneratedAttribute]
public void set_CompressedSize(long value);
    [CompilerGeneratedAttribute]
public string get_HumaneCompressedSize();
    [CompilerGeneratedAttribute]
public void set_HumaneCompressedSize(string value);
    [CompilerGeneratedAttribute]
public MeterType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(MeterType value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.IoMetrics.IOMetricsRecentStats : object {
    [CompilerGeneratedAttribute]
private string <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HumaneSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HumaneCompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Acceleration>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HumaneFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterType <Type>k__BackingField;
    public string Start { get; public set; }
    public long Size { get; public set; }
    public string HumaneSize { get; public set; }
    public long CompressedSize { get; public set; }
    public string HumaneCompressedSize { get; public set; }
    public int Acceleration { get; public set; }
    public long FileSize { get; public set; }
    public string HumaneFileSize { get; public set; }
    public double Duration { get; public set; }
    public MeterType Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(string value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(long value);
    [CompilerGeneratedAttribute]
public string get_HumaneSize();
    [CompilerGeneratedAttribute]
public void set_HumaneSize(string value);
    [CompilerGeneratedAttribute]
public long get_CompressedSize();
    [CompilerGeneratedAttribute]
public void set_CompressedSize(long value);
    [CompilerGeneratedAttribute]
public string get_HumaneCompressedSize();
    [CompilerGeneratedAttribute]
public void set_HumaneCompressedSize(string value);
    [CompilerGeneratedAttribute]
public int get_Acceleration();
    [CompilerGeneratedAttribute]
public void set_Acceleration(int value);
    [CompilerGeneratedAttribute]
public long get_FileSize();
    [CompilerGeneratedAttribute]
public void set_FileSize(long value);
    [CompilerGeneratedAttribute]
public string get_HumaneFileSize();
    [CompilerGeneratedAttribute]
public void set_HumaneFileSize(string value);
    [CompilerGeneratedAttribute]
public double get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(double value);
    [CompilerGeneratedAttribute]
public MeterType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(MeterType value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.IoMetrics.IOMetricsRecentStatsAdditionalTypes : IOMetricsRecentStats {
    public long OriginalSize;
    public string HumaneOriginalSize;
    public double CompressionRatio;
}
public class Raven.Server.Utils.IoMetrics.IOMetricsResponse : object {
    [CompilerGeneratedAttribute]
private List`1<PerformanceMetrics> <Performances>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IOMetricsEnvironment> <Environments>k__BackingField;
    public List`1<PerformanceMetrics> Performances { get; public set; }
    public List`1<IOMetricsEnvironment> Environments { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<PerformanceMetrics> get_Performances();
    [CompilerGeneratedAttribute]
public void set_Performances(List`1<PerformanceMetrics> value);
    [CompilerGeneratedAttribute]
public List`1<IOMetricsEnvironment> get_Environments();
    [CompilerGeneratedAttribute]
public void set_Environments(List`1<IOMetricsEnvironment> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.IoMetrics.IoMetricsUtil : object {
    public static IOMetricsResponse GetIoMetricsResponse(IEnumerable`1<StorageEnvironmentWithType> environments, IEnumerable`1<DatabasePerformanceMetrics> performanceMetrics);
    public static IOMetricsEnvironment GetIoMetrics(StorageEnvironment storageEnvironment);
    private static IOMetricsFileStats GetFileMetrics(FileIoMetrics fileMetric);
    public static IOMetricsRecentStats GetIoMetricsRecentStats(MeterItem recentMetric);
    public static void CleanIoMetrics(IEnumerable`1<StorageEnvironmentWithType> environments, long untilTicks);
}
public abstract class Raven.Server.Utils.IoMetrics.LiveIoStatsCollector`1 : object {
    private ConcurrentDictionary`2<string, BlockingCollection`1<MeterItem>> _perEnvironmentsFilesMetrics;
    [CompilerGeneratedAttribute]
private AsyncQueue`1<IOMetricsResponse> <MetricsQueue>k__BackingField;
    private string _basePath;
    private IoChangesNotifications _ioChanges;
    private List`1<StorageEnvironmentWithType> _environments;
    private IEnumerable`1<DatabasePerformanceMetrics> _performanceMetrics;
    private JsonContextPoolBase`1<T> _contextPool;
    private CancellationToken _resourceShutdown;
    private CancellationTokenSource _cts;
    public AsyncQueue`1<IOMetricsResponse> MetricsQueue { get; }
    protected LiveIoStatsCollector`1(IoChangesNotifications ioChanges, List`1<StorageEnvironmentWithType> environments, IEnumerable`1<DatabasePerformanceMetrics> performanceMetrics, JsonContextPoolBase`1<T> contextPool, CancellationToken resourceShutdown);
    [CompilerGeneratedAttribute]
public AsyncQueue`1<IOMetricsResponse> get_MetricsQueue();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Server.Utils.IoMetrics.LiveIoStatsCollector`1/<SendDataOrHeartbeatToWebSocket>d__13")]
public Task`1<bool> SendDataOrHeartbeatToWebSocket(Task`1<WebSocketReceiveResult> receive, WebSocket webSocket, MemoryStream ms, int timeToWait);
    [AsyncStateMachineAttribute("Raven.Server.Utils.IoMetrics.LiveIoStatsCollector`1/<StartCollectingMetrics>d__14")]
private Task StartCollectingMetrics();
    private IOMetricsResponse PrepareIOMetrics();
    private void OnIOChange(IoChange recentFileIoItem);
}
public class Raven.Server.Utils.JsonStringHelper : object {
    public static string Indent(string json);
}
public class Raven.Server.Utils.LeaveOpenStream : Stream {
    private Stream _inner;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LeaveOpenStream(Stream inner);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual ValueTask DisposeAsync();
    protected virtual void Dispose(bool disposing);
}
[DefaultMemberAttribute("Item")]
public class Raven.Server.Utils.LruDictionary`2 : object {
    private int _maxCapacity;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TKey, ValueTuple`2<LinkedListNode`1<TKey>, TValue>> _cache;
    private LinkedList`1<TKey> _list;
    public TValue Item { get; public set; }
    public LruDictionary`2(int maxCapacity);
    public bool TryGetValue(TKey key, TValue& value);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
}
public class Raven.Server.Utils.MetricCacher : object {
    private ConcurrentDictionary`2<string, MetricValue> _metrics;
    public void Register(string key, TimeSpan refreshRate, Func`1<object> factory, bool asyncRefresh);
    public T GetValue(string key, Func`1<T> factory);
}
public class Raven.Server.Utils.MetricCounters : object {
    public RequestCounters Requests;
    public DocCounters Docs;
    public AttachmentCounters Attachments;
    public CounterCounters Counters;
    public TimeSeriesCounters TimeSeries;
    public MapIndexCounters MapIndexes;
    public MapReduceIndexCounters MapReduceIndexes;
    public SqlReplicationCounters SqlReplications;
    public void Reset();
    private void CreateNew();
    public DynamicJsonValue ToJson();
    public DynamicJsonValue ToJsonForGetPuts(bool empty);
    public DynamicJsonValue ToJsonForGetBytes(bool empty);
}
public class Raven.Server.Utils.Metrics.Clock : object {
    public static int NanosecondsInSecond;
    public static int NanosecondsInMillisecond;
    public static long FrequencyFactor;
    public static long Nanoseconds { get; }
    public static long Milliseconds { get; }
    private static Clock();
    public static long get_Nanoseconds();
    public static long get_Milliseconds();
}
internal class Raven.Server.Utils.Metrics.Commands.GetDatabaseMetricsCommand : RavenCommand {
    private bool _putsOnly;
    private bool _bytesOnly;
    private Nullable`1<bool> _filterEmpty;
    public bool IsReadRequest { get; }
    public GetDatabaseMetricsCommand(bool putsOnly, bool bytesOnly);
    public GetDatabaseMetricsCommand(bool putsOnly, bool bytesOnly, bool filterEmpty);
    public GetDatabaseMetricsCommand(string nodeTag, bool putsOnly, bool bytesOnly, bool filterEmpty);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Server.Utils.Metrics.Ewma : object {
    private static int Interval;
    private static double SecondsPerMinute;
    private static int OneMinute;
    private static int FiveMinutes;
    private static int FifteenMinutes;
    private static double M1Second;
    private static double M1Alpha;
    private static double M5Alpha;
    private static double M15Alpha;
    private double _alpha;
    private double _interval;
    private SingleUseFlag _initialized;
    private double _rate;
    private long _uncounted;
    public Ewma(double alpha, long interval);
    private static Ewma();
    public static Ewma OneSecondEwma();
    public static Ewma OneMinuteEwma();
    public static Ewma FiveMinuteEwma();
    public static Ewma FifteenMinuteEwma();
    public void Update(long value);
    public void Tick();
    public double GetRate();
}
public class Raven.Server.Utils.Metrics.MeterMetric : object {
    private long _count;
    private long _lastCount;
    private Double[] _m15Rate;
    private int _index;
    private long _startTime;
    private long _lastTick;
    public double OneSecondRate;
    public double FifteenMinuteRate { get; }
    public double FiveMinuteRate { get; }
    public double OneMinuteRate { get; }
    public double FiveSecondRate { get; }
    public double MeanRate { get; }
    public long Count { get; }
    public double get_FifteenMinuteRate();
    public double get_FiveMinuteRate();
    public double get_OneMinuteRate();
    public double get_FiveSecondRate();
    internal double GetRate(int count);
    internal int GetIntRate(int count);
    public double get_MeanRate();
    public long get_Count();
    public void Tick();
    public void Mark(long val);
    public void MarkSingleThreaded(long val);
    public double GetMeanRate(double elapsed);
    public void Mark();
    public DynamicJsonValue CreateMeterData(bool allResults, bool filterEmpty);
}
public class Raven.Server.Utils.Metrics.MeterValue : ValueType {
    public long Count;
    public double MeanRate;
    public double OneMinuteRate;
    public double FiveMinuteRate;
    public double FifteenMinuteRate;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    [JsonConstructorAttribute]
public MeterValue(string name, long count, double meanRate, double oneMinuteRate, double fiveMinuteRate, double fifteenMinuteRate);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
}
public class Raven.Server.Utils.Metrics.MetricsScheduler : object {
    private Thread _schedulerThread;
    private ManualResetEvent _done;
    private ConcurrentSet`1<WeakReference`1<MeterMetric>> _scheduledMetricActions;
    private ConcurrentSet`1<WeakReference`1<Ewma>> _scheduledEwmaActions;
    private Logger _logger;
    public static MetricsScheduler Instance;
    private int _tickIntervalInNanoseconds;
    private static MetricsScheduler();
    private void SchedulerTicking();
    public void StartTickingMetric(MeterMetric tickable);
    public void StartTickingEwma(Ewma tickable);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Raven.Server.Utils.MetricsExtensions : object {
    [ExtensionAttribute]
public static void SetMinimalHumaneMeterData(MeterMetric self, string name, DynamicJsonValue obj);
    [ExtensionAttribute]
public static void SetMinimalMeterData(MeterMetric self, string name, DynamicJsonValue obj);
}
[ExtensionAttribute]
public static class Raven.Server.Utils.MicrosoftLogging.LogLevelToString : object {
    private static string Trace;
    private static string Debug;
    private static string Information;
    private static string Warning;
    private static string Error;
    private static string Critical;
    private static string None;
    [ExtensionAttribute]
public static string ToStringWithoutBoxing(LogLevel logLevel);
}
public class Raven.Server.Utils.MicrosoftLogging.MicrosoftLoggerFactory : object {
    private MicrosoftLoggingProvider _provider;
    public MicrosoftLoggerFactory(MicrosoftLoggingProvider provider);
    public sealed virtual void Dispose();
    public sealed virtual void AddProvider(ILoggerProvider provider);
    public sealed virtual ILogger CreateLogger(string categoryName);
}
public class Raven.Server.Utils.MicrosoftLogging.MicrosoftLoggingConfiguration : object {
    private static Logger Logger;
    private static string NotificationKey;
    private static AlertType AlertType;
    private string _notificationId;
    private IEnumerable`1<KeyValuePair`2<string, SparrowLoggerWrapper>> _loggers;
    private ServerNotificationCenter _notificationCenter;
    private ConcurrentDictionary`2<StringSegment, LogLevel> _configuration;
    public MicrosoftLoggingConfiguration(IEnumerable`1<KeyValuePair`2<string, SparrowLoggerWrapper>> loggers, ServerNotificationCenter notificationCenter);
    private static MicrosoftLoggingConfiguration();
    public LogLevel GetLogLevelForCategory(string categoryName);
    [IteratorStateMachineAttribute("Raven.Server.Utils.MicrosoftLogging.MicrosoftLoggingConfiguration/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<ValueTuple`2<string, LogLevel>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void ReadConfiguration(string configurationPath, JsonOperationContext context, bool shouldThrow, bool reset);
    public void ReadConfiguration(Stream streamConfiguration, JsonOperationContext context, bool reset);
    public void ReadConfigurationOrThrow(BlittableJsonReaderObject blitConfiguration, bool reset);
    private void ReadConfiguration(BlittableJsonReaderObject jConfiguration, string rootCategory);
    private void HandleReadConfigurationFailure(BlittableJsonReaderObject blitConfiguration, Exception e);
    private static AlertRaised CreateAlert(string msg, Exception e);
    [CompilerGeneratedAttribute]
private void <ReadConfiguration>b__11_0(Task`1<AbstractNotificationCenter> task);
    [CompilerGeneratedAttribute]
private void <ReadConfiguration>b__12_0(Task`1<AbstractNotificationCenter> task);
}
[ProviderAliasAttribute("Sparrow")]
public class Raven.Server.Utils.MicrosoftLogging.MicrosoftLoggingProvider : object {
    public LoggingSource LoggingSource;
    private ConcurrentDictionary`2<string, SparrowLoggerWrapper> _loggers;
    private MultipleUseFlag _enable;
    public MicrosoftLoggingConfiguration Configuration;
    public bool IsActive { get; }
    public ValueTuple`2[] Loggers { get; }
    public MicrosoftLoggingProvider(LoggingSource loggingSource, ServerNotificationCenter notificationCenter);
    public bool get_IsActive();
    public ValueTuple`2[] get_Loggers();
    public sealed virtual ILogger CreateLogger(string categoryName);
    public IEnumerable`1<ValueTuple`2<string, LogLevel>> GetLoggers();
    public void ApplyConfiguration();
    public void DisableLogging();
    public sealed virtual void Dispose();
}
public class Raven.Server.Utils.MicrosoftLogging.SparrowLoggerWrapper : object {
    private Logger _sparrowLogger;
    [CompilerGeneratedAttribute]
private LogLevel <MinLogLevel>k__BackingField;
    public LogLevel MinLogLevel { get; public set; }
    public SparrowLoggerWrapper(Logger sparrowLogger, LogLevel logLevel);
    [CompilerGeneratedAttribute]
public LogLevel get_MinLogLevel();
    [CompilerGeneratedAttribute]
public void set_MinLogLevel(LogLevel value);
    public sealed virtual IDisposable BeginScope(TState state);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
}
[ExtensionAttribute]
public static class Raven.Server.Utils.MicrosoftLogging.WebHostBuilderExtensions : object {
    [ExtensionAttribute]
public static IWebHostBuilder ConfigureMicrosoftLogging(IWebHostBuilder hostBuilder, LogsConfiguration configuration, ServerNotificationCenter notificationCenter);
}
public class Raven.Server.Utils.Monitoring.AllDatabasesMetrics : object {
    [CompilerGeneratedAttribute]
private int <TotalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoadedCount>k__BackingField;
    public int TotalCount { get; public set; }
    public int LoadedCount { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TotalCount();
    [CompilerGeneratedAttribute]
public void set_TotalCount(int value);
    [CompilerGeneratedAttribute]
public int get_LoadedCount();
    [CompilerGeneratedAttribute]
public void set_LoadedCount(int value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.BackupMetrics : object {
    [CompilerGeneratedAttribute]
private int <CurrentNumberOfRunningBackups>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfConcurrentBackups>k__BackingField;
    public int CurrentNumberOfRunningBackups { get; public set; }
    public int MaxNumberOfConcurrentBackups { get; public set; }
    [CompilerGeneratedAttribute]
public int get_CurrentNumberOfRunningBackups();
    [CompilerGeneratedAttribute]
public void set_CurrentNumberOfRunningBackups(int value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfConcurrentBackups();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfConcurrentBackups(int value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.CertificateMetrics : object {
    [CompilerGeneratedAttribute]
private Nullable`1<double> <ServerCertificateExpirationLeftInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WellKnownAdminCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WellKnownAdminIssuers>k__BackingField;
    public Nullable`1<double> ServerCertificateExpirationLeftInSec { get; public set; }
    public String[] WellKnownAdminCertificates { get; public set; }
    public String[] WellKnownAdminIssuers { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_ServerCertificateExpirationLeftInSec();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateExpirationLeftInSec(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public String[] get_WellKnownAdminCertificates();
    [CompilerGeneratedAttribute]
public void set_WellKnownAdminCertificates(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_WellKnownAdminIssuers();
    [CompilerGeneratedAttribute]
public void set_WellKnownAdminIssuers(String[] value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.ClusterMetrics : object {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private RachisState <NodeState>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string NodeTag { get; public set; }
    public RachisState NodeState { get; public set; }
    public long CurrentTerm { get; public set; }
    public long Index { get; public set; }
    public string Id { get; public set; }
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public RachisState get_NodeState();
    [CompilerGeneratedAttribute]
public void set_NodeState(RachisState value);
    [CompilerGeneratedAttribute]
public long get_CurrentTerm();
    [CompilerGeneratedAttribute]
public void set_CurrentTerm(long value);
    [CompilerGeneratedAttribute]
public long get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(long value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.CollectionMetrics : object {
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DocumentsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DocumentsSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TombstonesSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RevisionsSizeInBytes>k__BackingField;
    public string CollectionName { get; public set; }
    public long DocumentsCount { get; public set; }
    public long TotalSizeInBytes { get; public set; }
    public long DocumentsSizeInBytes { get; public set; }
    public long TombstonesSizeInBytes { get; public set; }
    public long RevisionsSizeInBytes { get; public set; }
    public CollectionMetrics(CollectionDetails collectionDetails);
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
public void set_CollectionName(string value);
    [CompilerGeneratedAttribute]
public long get_DocumentsCount();
    [CompilerGeneratedAttribute]
public void set_DocumentsCount(long value);
    [CompilerGeneratedAttribute]
public long get_TotalSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_TotalSizeInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_DocumentsSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_DocumentsSizeInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_TombstonesSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_TombstonesSizeInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_RevisionsSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_RevisionsSizeInBytes(long value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.CollectionsMetrics : object {
    [CompilerGeneratedAttribute]
private string <PublicServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PerDatabaseCollectionMetrics> <Results>k__BackingField;
    public string PublicServerUrl { get; public set; }
    public string NodeTag { get; public set; }
    public List`1<PerDatabaseCollectionMetrics> Results { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PublicServerUrl();
    [CompilerGeneratedAttribute]
public void set_PublicServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public List`1<PerDatabaseCollectionMetrics> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(List`1<PerDatabaseCollectionMetrics> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.ConfigurationMetrics : object {
    [CompilerGeneratedAttribute]
private String[] <ServerUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublicServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TcpServerUrls>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PublicTcpServerUrls>k__BackingField;
    public String[] ServerUrls { get; public set; }
    public string PublicServerUrl { get; public set; }
    public String[] TcpServerUrls { get; public set; }
    public String[] PublicTcpServerUrls { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_ServerUrls();
    [CompilerGeneratedAttribute]
public void set_ServerUrls(String[] value);
    [CompilerGeneratedAttribute]
public string get_PublicServerUrl();
    [CompilerGeneratedAttribute]
public void set_PublicServerUrl(string value);
    [CompilerGeneratedAttribute]
public String[] get_TcpServerUrls();
    [CompilerGeneratedAttribute]
public void set_TcpServerUrls(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_PublicTcpServerUrls();
    [CompilerGeneratedAttribute]
public void set_PublicTcpServerUrls(String[] value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.CpuMetrics : object {
    [CompilerGeneratedAttribute]
private double <ProcessUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MachineUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <MachineIoWait>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AssignedProcessorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadPoolAvailableWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadPoolAvailableCompletionPortThreads>k__BackingField;
    public double ProcessUsage { get; public set; }
    public double MachineUsage { get; public set; }
    public Nullable`1<double> MachineIoWait { get; public set; }
    public int ProcessorCount { get; public set; }
    public int AssignedProcessorCount { get; public set; }
    public int ThreadPoolAvailableWorkerThreads { get; public set; }
    public int ThreadPoolAvailableCompletionPortThreads { get; public set; }
    [CompilerGeneratedAttribute]
public double get_ProcessUsage();
    [CompilerGeneratedAttribute]
public void set_ProcessUsage(double value);
    [CompilerGeneratedAttribute]
public double get_MachineUsage();
    [CompilerGeneratedAttribute]
public void set_MachineUsage(double value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_MachineIoWait();
    [CompilerGeneratedAttribute]
public void set_MachineIoWait(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public int get_ProcessorCount();
    [CompilerGeneratedAttribute]
public void set_ProcessorCount(int value);
    [CompilerGeneratedAttribute]
public int get_AssignedProcessorCount();
    [CompilerGeneratedAttribute]
public void set_AssignedProcessorCount(int value);
    [CompilerGeneratedAttribute]
public int get_ThreadPoolAvailableWorkerThreads();
    [CompilerGeneratedAttribute]
public void set_ThreadPoolAvailableWorkerThreads(int value);
    [CompilerGeneratedAttribute]
public int get_ThreadPoolAvailableCompletionPortThreads();
    [CompilerGeneratedAttribute]
public void set_ThreadPoolAvailableCompletionPortThreads(int value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.DatabaseCounts : object {
    [CompilerGeneratedAttribute]
private long <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Revisions>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Attachments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UniqueAttachments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Alerts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rehabs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PerformanceHints>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplicationFactor>k__BackingField;
    public long Documents { get; public set; }
    public long Revisions { get; public set; }
    public long Attachments { get; public set; }
    public long UniqueAttachments { get; public set; }
    public long Alerts { get; public set; }
    public int Rehabs { get; public set; }
    public long PerformanceHints { get; public set; }
    public int ReplicationFactor { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Documents();
    [CompilerGeneratedAttribute]
public void set_Documents(long value);
    [CompilerGeneratedAttribute]
public long get_Revisions();
    [CompilerGeneratedAttribute]
public void set_Revisions(long value);
    [CompilerGeneratedAttribute]
public long get_Attachments();
    [CompilerGeneratedAttribute]
public void set_Attachments(long value);
    [CompilerGeneratedAttribute]
public long get_UniqueAttachments();
    [CompilerGeneratedAttribute]
public void set_UniqueAttachments(long value);
    [CompilerGeneratedAttribute]
public long get_Alerts();
    [CompilerGeneratedAttribute]
public void set_Alerts(long value);
    [CompilerGeneratedAttribute]
public int get_Rehabs();
    [CompilerGeneratedAttribute]
public void set_Rehabs(int value);
    [CompilerGeneratedAttribute]
public long get_PerformanceHints();
    [CompilerGeneratedAttribute]
public void set_PerformanceHints(long value);
    [CompilerGeneratedAttribute]
public int get_ReplicationFactor();
    [CompilerGeneratedAttribute]
public void set_ReplicationFactor(int value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.DatabaseIndexesMetrics : object {
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StaleCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ErrorsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StaticCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AutoCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IdleCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DisabledCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErroredCount>k__BackingField;
    public long Count { get; public set; }
    public int StaleCount { get; public set; }
    public long ErrorsCount { get; public set; }
    public int StaticCount { get; public set; }
    public int AutoCount { get; public set; }
    public int IdleCount { get; public set; }
    public int DisabledCount { get; public set; }
    public int ErroredCount { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(long value);
    [CompilerGeneratedAttribute]
public int get_StaleCount();
    [CompilerGeneratedAttribute]
public void set_StaleCount(int value);
    [CompilerGeneratedAttribute]
public long get_ErrorsCount();
    [CompilerGeneratedAttribute]
public void set_ErrorsCount(long value);
    [CompilerGeneratedAttribute]
public int get_StaticCount();
    [CompilerGeneratedAttribute]
public void set_StaticCount(int value);
    [CompilerGeneratedAttribute]
public int get_AutoCount();
    [CompilerGeneratedAttribute]
public void set_AutoCount(int value);
    [CompilerGeneratedAttribute]
public int get_IdleCount();
    [CompilerGeneratedAttribute]
public void set_IdleCount(int value);
    [CompilerGeneratedAttribute]
public int get_DisabledCount();
    [CompilerGeneratedAttribute]
public void set_DisabledCount(int value);
    [CompilerGeneratedAttribute]
public int get_ErroredCount();
    [CompilerGeneratedAttribute]
public void set_ErroredCount(int value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.DatabaseMetrics : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UptimeInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <TimeSinceLastBackupInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseCounts <Counts>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseStatistics <Statistics>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseIndexesMetrics <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseStorageMetrics <Storage>k__BackingField;
    public string DatabaseName { get; public set; }
    public string DatabaseId { get; public set; }
    public int UptimeInSec { get; public set; }
    public Nullable`1<double> TimeSinceLastBackupInSec { get; public set; }
    public DatabaseCounts Counts { get; public set; }
    public DatabaseStatistics Statistics { get; public set; }
    public DatabaseIndexesMetrics Indexes { get; public set; }
    public DatabaseStorageMetrics Storage { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseId();
    [CompilerGeneratedAttribute]
public void set_DatabaseId(string value);
    [CompilerGeneratedAttribute]
public int get_UptimeInSec();
    [CompilerGeneratedAttribute]
public void set_UptimeInSec(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_TimeSinceLastBackupInSec();
    [CompilerGeneratedAttribute]
public void set_TimeSinceLastBackupInSec(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public DatabaseCounts get_Counts();
    [CompilerGeneratedAttribute]
public void set_Counts(DatabaseCounts value);
    [CompilerGeneratedAttribute]
public DatabaseStatistics get_Statistics();
    [CompilerGeneratedAttribute]
public void set_Statistics(DatabaseStatistics value);
    [CompilerGeneratedAttribute]
public DatabaseIndexesMetrics get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(DatabaseIndexesMetrics value);
    [CompilerGeneratedAttribute]
public DatabaseStorageMetrics get_Storage();
    [CompilerGeneratedAttribute]
public void set_Storage(DatabaseStorageMetrics value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.DatabasesMetrics : object {
    [CompilerGeneratedAttribute]
private List`1<DatabaseMetrics> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublicServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    public List`1<DatabaseMetrics> Results { get; public set; }
    public string PublicServerUrl { get; public set; }
    public string NodeTag { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<DatabaseMetrics> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(List`1<DatabaseMetrics> value);
    [CompilerGeneratedAttribute]
public string get_PublicServerUrl();
    [CompilerGeneratedAttribute]
public void set_PublicServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.DatabaseStatistics : object {
    [CompilerGeneratedAttribute]
private double <DocPutsPerSec>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MapIndexIndexesPerSec>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MapReduceIndexMappedPerSec>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MapReduceIndexReducedPerSec>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RequestsPerSec>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequestsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RequestAverageDurationInMs>k__BackingField;
    public double DocPutsPerSec { get; public set; }
    public double MapIndexIndexesPerSec { get; public set; }
    public double MapReduceIndexMappedPerSec { get; public set; }
    public double MapReduceIndexReducedPerSec { get; public set; }
    public double RequestsPerSec { get; public set; }
    public int RequestsCount { get; public set; }
    public double RequestAverageDurationInMs { get; public set; }
    [CompilerGeneratedAttribute]
public double get_DocPutsPerSec();
    [CompilerGeneratedAttribute]
public void set_DocPutsPerSec(double value);
    [CompilerGeneratedAttribute]
public double get_MapIndexIndexesPerSec();
    [CompilerGeneratedAttribute]
public void set_MapIndexIndexesPerSec(double value);
    [CompilerGeneratedAttribute]
public double get_MapReduceIndexMappedPerSec();
    [CompilerGeneratedAttribute]
public void set_MapReduceIndexMappedPerSec(double value);
    [CompilerGeneratedAttribute]
public double get_MapReduceIndexReducedPerSec();
    [CompilerGeneratedAttribute]
public void set_MapReduceIndexReducedPerSec(double value);
    [CompilerGeneratedAttribute]
public double get_RequestsPerSec();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSec(double value);
    [CompilerGeneratedAttribute]
public int get_RequestsCount();
    [CompilerGeneratedAttribute]
public void set_RequestsCount(int value);
    [CompilerGeneratedAttribute]
public double get_RequestAverageDurationInMs();
    [CompilerGeneratedAttribute]
public void set_RequestAverageDurationInMs(double value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.DatabaseStorageMetrics : object {
    [CompilerGeneratedAttribute]
private long <DocumentsAllocatedDataFileInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DocumentsUsedDataFileInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <IndexesAllocatedDataFileInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <IndexesUsedDataFileInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalAllocatedStorageFileInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalFreeSpaceInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <IoReadOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <IoWriteOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ReadThroughputInKb>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <WriteThroughputInKb>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <QueueLength>k__BackingField;
    public long DocumentsAllocatedDataFileInMb { get; public set; }
    public long DocumentsUsedDataFileInMb { get; public set; }
    public long IndexesAllocatedDataFileInMb { get; public set; }
    public long IndexesUsedDataFileInMb { get; public set; }
    public long TotalAllocatedStorageFileInMb { get; public set; }
    public long TotalFreeSpaceInMb { get; public set; }
    public Nullable`1<double> IoReadOperations { get; public set; }
    public Nullable`1<double> IoWriteOperations { get; public set; }
    public Nullable`1<long> ReadThroughputInKb { get; public set; }
    public Nullable`1<long> WriteThroughputInKb { get; public set; }
    public Nullable`1<long> QueueLength { get; public set; }
    [CompilerGeneratedAttribute]
public long get_DocumentsAllocatedDataFileInMb();
    [CompilerGeneratedAttribute]
public void set_DocumentsAllocatedDataFileInMb(long value);
    [CompilerGeneratedAttribute]
public long get_DocumentsUsedDataFileInMb();
    [CompilerGeneratedAttribute]
public void set_DocumentsUsedDataFileInMb(long value);
    [CompilerGeneratedAttribute]
public long get_IndexesAllocatedDataFileInMb();
    [CompilerGeneratedAttribute]
public void set_IndexesAllocatedDataFileInMb(long value);
    [CompilerGeneratedAttribute]
public long get_IndexesUsedDataFileInMb();
    [CompilerGeneratedAttribute]
public void set_IndexesUsedDataFileInMb(long value);
    [CompilerGeneratedAttribute]
public long get_TotalAllocatedStorageFileInMb();
    [CompilerGeneratedAttribute]
public void set_TotalAllocatedStorageFileInMb(long value);
    [CompilerGeneratedAttribute]
public long get_TotalFreeSpaceInMb();
    [CompilerGeneratedAttribute]
public void set_TotalFreeSpaceInMb(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_IoReadOperations();
    [CompilerGeneratedAttribute]
public void set_IoReadOperations(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_IoWriteOperations();
    [CompilerGeneratedAttribute]
public void set_IoWriteOperations(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ReadThroughputInKb();
    [CompilerGeneratedAttribute]
public void set_ReadThroughputInKb(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_WriteThroughputInKb();
    [CompilerGeneratedAttribute]
public void set_WriteThroughputInKb(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_QueueLength();
    [CompilerGeneratedAttribute]
public void set_QueueLength(Nullable`1<long> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.DiskMetrics : object {
    [CompilerGeneratedAttribute]
private long <SystemStoreUsedDataFileSizeInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SystemStoreTotalDataFileSizeInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalFreeSpaceInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemainingStorageSpacePercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <IoReadOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <IoWriteOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ReadThroughputInKb>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <WriteThroughputInKb>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <QueueLength>k__BackingField;
    public long SystemStoreUsedDataFileSizeInMb { get; public set; }
    public long SystemStoreTotalDataFileSizeInMb { get; public set; }
    public long TotalFreeSpaceInMb { get; public set; }
    public int RemainingStorageSpacePercentage { get; public set; }
    public Nullable`1<double> IoReadOperations { get; public set; }
    public Nullable`1<double> IoWriteOperations { get; public set; }
    public Nullable`1<long> ReadThroughputInKb { get; public set; }
    public Nullable`1<long> WriteThroughputInKb { get; public set; }
    public Nullable`1<long> QueueLength { get; public set; }
    [CompilerGeneratedAttribute]
public long get_SystemStoreUsedDataFileSizeInMb();
    [CompilerGeneratedAttribute]
public void set_SystemStoreUsedDataFileSizeInMb(long value);
    [CompilerGeneratedAttribute]
public long get_SystemStoreTotalDataFileSizeInMb();
    [CompilerGeneratedAttribute]
public void set_SystemStoreTotalDataFileSizeInMb(long value);
    [CompilerGeneratedAttribute]
public long get_TotalFreeSpaceInMb();
    [CompilerGeneratedAttribute]
public void set_TotalFreeSpaceInMb(long value);
    [CompilerGeneratedAttribute]
public int get_RemainingStorageSpacePercentage();
    [CompilerGeneratedAttribute]
public void set_RemainingStorageSpacePercentage(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_IoReadOperations();
    [CompilerGeneratedAttribute]
public void set_IoReadOperations(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_IoWriteOperations();
    [CompilerGeneratedAttribute]
public void set_IoWriteOperations(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ReadThroughputInKb();
    [CompilerGeneratedAttribute]
public void set_ReadThroughputInKb(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_WriteThroughputInKb();
    [CompilerGeneratedAttribute]
public void set_WriteThroughputInKb(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_QueueLength();
    [CompilerGeneratedAttribute]
public void set_QueueLength(Nullable`1<long> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.IndexesMetrics : object {
    [CompilerGeneratedAttribute]
private List`1<PerDatabaseIndexMetrics> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublicServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    public List`1<PerDatabaseIndexMetrics> Results { get; public set; }
    public string PublicServerUrl { get; public set; }
    public string NodeTag { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<PerDatabaseIndexMetrics> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(List`1<PerDatabaseIndexMetrics> value);
    [CompilerGeneratedAttribute]
public string get_PublicServerUrl();
    [CompilerGeneratedAttribute]
public void set_PublicServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.IndexMetrics : object {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <TimeSinceLastQueryInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <TimeSinceLastIndexingInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexLockMode <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ArchivedDataProcessingBehavior <ArchivedDataProcessingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInvalid>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexRunningStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MappedPerSec>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ReducedPerSec>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EntriesCount>k__BackingField;
    public string IndexName { get; public set; }
    public IndexPriority Priority { get; public set; }
    public IndexState State { get; public set; }
    public int Errors { get; public set; }
    public Nullable`1<double> TimeSinceLastQueryInSec { get; public set; }
    public Nullable`1<double> TimeSinceLastIndexingInSec { get; public set; }
    public IndexLockMode LockMode { get; public set; }
    public ArchivedDataProcessingBehavior ArchivedDataProcessingBehavior { get; public set; }
    public bool IsInvalid { get; public set; }
    public IndexRunningStatus Status { get; public set; }
    public double MappedPerSec { get; public set; }
    public double ReducedPerSec { get; public set; }
    public IndexType Type { get; public set; }
    public long EntriesCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public IndexPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(IndexPriority value);
    [CompilerGeneratedAttribute]
public IndexState get_State();
    [CompilerGeneratedAttribute]
public void set_State(IndexState value);
    [CompilerGeneratedAttribute]
public int get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_TimeSinceLastQueryInSec();
    [CompilerGeneratedAttribute]
public void set_TimeSinceLastQueryInSec(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_TimeSinceLastIndexingInSec();
    [CompilerGeneratedAttribute]
public void set_TimeSinceLastIndexingInSec(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public IndexLockMode get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(IndexLockMode value);
    [CompilerGeneratedAttribute]
public ArchivedDataProcessingBehavior get_ArchivedDataProcessingBehavior();
    [CompilerGeneratedAttribute]
public void set_ArchivedDataProcessingBehavior(ArchivedDataProcessingBehavior value);
    [CompilerGeneratedAttribute]
public bool get_IsInvalid();
    [CompilerGeneratedAttribute]
public void set_IsInvalid(bool value);
    [CompilerGeneratedAttribute]
public IndexRunningStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(IndexRunningStatus value);
    [CompilerGeneratedAttribute]
public double get_MappedPerSec();
    [CompilerGeneratedAttribute]
public void set_MappedPerSec(double value);
    [CompilerGeneratedAttribute]
public double get_ReducedPerSec();
    [CompilerGeneratedAttribute]
public void set_ReducedPerSec(double value);
    [CompilerGeneratedAttribute]
public IndexType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IndexType value);
    [CompilerGeneratedAttribute]
public long get_EntriesCount();
    [CompilerGeneratedAttribute]
public void set_EntriesCount(long value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.LicenseMetrics : object {
    [CompilerGeneratedAttribute]
private LicenseType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <ExpirationLeftInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UtilizedCpuCores>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCores>k__BackingField;
    public LicenseType Type { get; public set; }
    public Nullable`1<double> ExpirationLeftInSec { get; public set; }
    public int UtilizedCpuCores { get; public set; }
    public int MaxCores { get; public set; }
    [CompilerGeneratedAttribute]
public LicenseType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(LicenseType value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_ExpirationLeftInSec();
    [CompilerGeneratedAttribute]
public void set_ExpirationLeftInSec(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public int get_UtilizedCpuCores();
    [CompilerGeneratedAttribute]
public void set_UtilizedCpuCores(int value);
    [CompilerGeneratedAttribute]
public int get_MaxCores();
    [CompilerGeneratedAttribute]
public void set_MaxCores(int value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.MemoryMetrics : object {
    [CompilerGeneratedAttribute]
private long <InstalledMemoryInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PhysicalMemoryInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocatedMemoryInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private LowMemorySeverity <LowMemorySeverity>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSwapSizeInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSwapUsageInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <WorkingSetSwapUsageInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalDirtyInMb>k__BackingField;
    public long InstalledMemoryInMb { get; public set; }
    public long PhysicalMemoryInMb { get; public set; }
    public long AllocatedMemoryInMb { get; public set; }
    public LowMemorySeverity LowMemorySeverity { get; public set; }
    public long TotalSwapSizeInMb { get; public set; }
    public long TotalSwapUsageInMb { get; public set; }
    public long WorkingSetSwapUsageInMb { get; public set; }
    public long TotalDirtyInMb { get; public set; }
    [CompilerGeneratedAttribute]
public long get_InstalledMemoryInMb();
    [CompilerGeneratedAttribute]
public void set_InstalledMemoryInMb(long value);
    [CompilerGeneratedAttribute]
public long get_PhysicalMemoryInMb();
    [CompilerGeneratedAttribute]
public void set_PhysicalMemoryInMb(long value);
    [CompilerGeneratedAttribute]
public long get_AllocatedMemoryInMb();
    [CompilerGeneratedAttribute]
public void set_AllocatedMemoryInMb(long value);
    [CompilerGeneratedAttribute]
public LowMemorySeverity get_LowMemorySeverity();
    [CompilerGeneratedAttribute]
public void set_LowMemorySeverity(LowMemorySeverity value);
    [CompilerGeneratedAttribute]
public long get_TotalSwapSizeInMb();
    [CompilerGeneratedAttribute]
public void set_TotalSwapSizeInMb(long value);
    [CompilerGeneratedAttribute]
public long get_TotalSwapUsageInMb();
    [CompilerGeneratedAttribute]
public void set_TotalSwapUsageInMb(long value);
    [CompilerGeneratedAttribute]
public long get_WorkingSetSwapUsageInMb();
    [CompilerGeneratedAttribute]
public void set_WorkingSetSwapUsageInMb(long value);
    [CompilerGeneratedAttribute]
public long get_TotalDirtyInMb();
    [CompilerGeneratedAttribute]
public void set_TotalDirtyInMb(long value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.NetworkMetrics : object {
    [CompilerGeneratedAttribute]
private long <TcpActiveConnections>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ConcurrentRequestsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RequestsPerSec>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <LastRequestTimeInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <LastAuthorizedNonClusterAdminRequestTimeInSec>k__BackingField;
    public long TcpActiveConnections { get; public set; }
    public long ConcurrentRequestsCount { get; public set; }
    public long TotalRequests { get; public set; }
    public double RequestsPerSec { get; public set; }
    public Nullable`1<double> LastRequestTimeInSec { get; public set; }
    public Nullable`1<double> LastAuthorizedNonClusterAdminRequestTimeInSec { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TcpActiveConnections();
    [CompilerGeneratedAttribute]
public void set_TcpActiveConnections(long value);
    [CompilerGeneratedAttribute]
public long get_ConcurrentRequestsCount();
    [CompilerGeneratedAttribute]
public void set_ConcurrentRequestsCount(long value);
    [CompilerGeneratedAttribute]
public long get_TotalRequests();
    [CompilerGeneratedAttribute]
public void set_TotalRequests(long value);
    [CompilerGeneratedAttribute]
public double get_RequestsPerSec();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSec(double value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_LastRequestTimeInSec();
    [CompilerGeneratedAttribute]
public void set_LastRequestTimeInSec(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_LastAuthorizedNonClusterAdminRequestTimeInSec();
    [CompilerGeneratedAttribute]
public void set_LastAuthorizedNonClusterAdminRequestTimeInSec(Nullable`1<double> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.PerDatabaseCollectionMetrics : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CollectionMetrics> <Collections>k__BackingField;
    public string DatabaseName { get; public set; }
    public List`1<CollectionMetrics> Collections { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public List`1<CollectionMetrics> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(List`1<CollectionMetrics> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.PerDatabaseIndexMetrics : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IndexMetrics> <Indexes>k__BackingField;
    public string DatabaseName { get; public set; }
    public List`1<IndexMetrics> Indexes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public List`1<IndexMetrics> get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(List`1<IndexMetrics> value);
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Utils.Monitoring.ServerMetrics : object {
    [CompilerGeneratedAttribute]
private string <ServerVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerFullVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UpTimeInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ServerProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationMetrics <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private BackupMetrics <Backup>k__BackingField;
    [CompilerGeneratedAttribute]
private CpuMetrics <Cpu>k__BackingField;
    [CompilerGeneratedAttribute]
private MemoryMetrics <Memory>k__BackingField;
    [CompilerGeneratedAttribute]
private DiskMetrics <Disk>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseMetrics <License>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkMetrics <Network>k__BackingField;
    [CompilerGeneratedAttribute]
private CertificateMetrics <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private ClusterMetrics <Cluster>k__BackingField;
    [CompilerGeneratedAttribute]
private AllDatabasesMetrics <Databases>k__BackingField;
    public string ServerVersion { get; public set; }
    public string ServerFullVersion { get; public set; }
    public int UpTimeInSec { get; public set; }
    public int ServerProcessId { get; public set; }
    public ConfigurationMetrics Config { get; public set; }
    public BackupMetrics Backup { get; public set; }
    public CpuMetrics Cpu { get; public set; }
    public MemoryMetrics Memory { get; public set; }
    public DiskMetrics Disk { get; public set; }
    public LicenseMetrics License { get; public set; }
    public NetworkMetrics Network { get; public set; }
    public CertificateMetrics Certificate { get; public set; }
    public ClusterMetrics Cluster { get; public set; }
    public AllDatabasesMetrics Databases { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServerVersion();
    [CompilerGeneratedAttribute]
public void set_ServerVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ServerFullVersion();
    [CompilerGeneratedAttribute]
public void set_ServerFullVersion(string value);
    [CompilerGeneratedAttribute]
public int get_UpTimeInSec();
    [CompilerGeneratedAttribute]
public void set_UpTimeInSec(int value);
    [CompilerGeneratedAttribute]
public int get_ServerProcessId();
    [CompilerGeneratedAttribute]
public void set_ServerProcessId(int value);
    [CompilerGeneratedAttribute]
public ConfigurationMetrics get_Config();
    [CompilerGeneratedAttribute]
public void set_Config(ConfigurationMetrics value);
    [CompilerGeneratedAttribute]
public BackupMetrics get_Backup();
    [CompilerGeneratedAttribute]
public void set_Backup(BackupMetrics value);
    [CompilerGeneratedAttribute]
public CpuMetrics get_Cpu();
    [CompilerGeneratedAttribute]
public void set_Cpu(CpuMetrics value);
    [CompilerGeneratedAttribute]
public MemoryMetrics get_Memory();
    [CompilerGeneratedAttribute]
public void set_Memory(MemoryMetrics value);
    [CompilerGeneratedAttribute]
public DiskMetrics get_Disk();
    [CompilerGeneratedAttribute]
public void set_Disk(DiskMetrics value);
    [CompilerGeneratedAttribute]
public LicenseMetrics get_License();
    [CompilerGeneratedAttribute]
public void set_License(LicenseMetrics value);
    [CompilerGeneratedAttribute]
public NetworkMetrics get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(NetworkMetrics value);
    [CompilerGeneratedAttribute]
public CertificateMetrics get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(CertificateMetrics value);
    [CompilerGeneratedAttribute]
public ClusterMetrics get_Cluster();
    [CompilerGeneratedAttribute]
public void set_Cluster(ClusterMetrics value);
    [CompilerGeneratedAttribute]
public AllDatabasesMetrics get_Databases();
    [CompilerGeneratedAttribute]
public void set_Databases(AllDatabasesMetrics value);
    public DynamicJsonValue ToJson();
}
internal static class Raven.Server.Utils.OngoingTasksUtils : object {
    internal static string WhoseTaskIsIt(ServerStore serverStore, DatabaseTopology databaseTopology, IDatabaseTask configuration, IDatabaseTaskStatus taskStatus, AbstractNotificationCenter notificationCenter, List`1<string> explanations);
    internal static void RaiseAlertIfNecessary(DatabaseTopology databaseTopology, IDatabaseTask configuration, string lastResponsibleNode, ServerStore serverStore, AbstractNotificationCenter notificationCenter);
}
public static class Raven.Server.Utils.OperationIdEncoder : object {
    private static int BaseChar;
    private static int NumberOfBitsNeededToEncodeSingleNodeTagChar;
    private static int MaxNumberOfBitsUsedForOperationId;
    private static int MaxNodeTagLength;
    private static long MaxEncodedId;
    public static long MaxOperationId;
    public static long EncodeOperationId(long operationId, string nodeTag);
    public static long DecodeOperationId(long input, String& nodeTag);
    [CompilerGeneratedAttribute]
internal static Int64[] <EncodeOperationId>g__ConvertToLongs|6_0(string nodeTag);
    [CompilerGeneratedAttribute]
internal static char <DecodeOperationId>g__ExtractChar|7_0(Int64& input);
}
public class Raven.Server.Utils.ParentProcessUtilities : ValueType {
    internal IntPtr Reserved1;
    internal IntPtr PebBaseAddress;
    internal IntPtr Reserved2_0;
    internal IntPtr Reserved2_1;
    internal IntPtr UniqueProcessId;
    internal IntPtr InheritedFromUniqueProcessId;
    private static int NtQueryInformationProcess(IntPtr processHandle, int processInformationClass, ParentProcessUtilities& processInformation, int processInformationLength, Int32& returnLength);
    public static Process GetParentProcess();
    public static Process GetParentProcess(int processId);
    private static Process GetParentProcess(IntPtr handle);
}
public class Raven.Server.Utils.PartialStream : Stream {
    private Stream _inner;
    private int _size;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PartialStream(Stream inner, int size);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
}
public class Raven.Server.Utils.Pipes : object {
    private static Logger Logger;
    public static string AdminConsolePipePrefix;
    public static string LogStreamPipePrefix;
    private static string PipesDir;
    private static Pipes();
    public static NamedPipeServerStream OpenAdminConsolePipe();
    private static string GetPipeName(string namePrefix);
    public static string GetPipeName(string namePrefix, int pid);
    public static void CleanupOldPipeFiles();
    [AsyncStateMachineAttribute("Raven.Server.Utils.Pipes/<ListenToAdminConsolePipe>d__8")]
public static Task ListenToAdminConsolePipe(RavenServer ravenServer, NamedPipeServerStream adminConsolePipe);
    private static void DeleteOldPipeFiles(string pipeDir);
    public static NamedPipeServerStream OpenLogStreamPipe();
    [AsyncStateMachineAttribute("Raven.Server.Utils.Pipes/<ListenToLogStreamPipe>d__11")]
public static Task ListenToLogStreamPipe(RavenServer ravenServer, NamedPipeServerStream logstreamPipe);
}
public class Raven.Server.Utils.PoolOfThreads : object {
    private static Lazy`1<PoolOfThreads> _globalRavenThreadPool;
    private static Logger Logger;
    public int TotalNumberOfThreads;
    private SharedMultipleUseFlag _lowMemoryFlag;
    private CountingConcurrentStack`1<PooledThread> _pool;
    private bool _disposed;
    private Timer _cleanupTimer;
    public static PoolOfThreads GlobalRavenThreadPool { get; }
    private static PoolOfThreads();
    public static PoolOfThreads get_GlobalRavenThreadPool();
    public sealed virtual void Dispose();
    public LongRunningWork LongRunning(Action`1<object> action, object state, ThreadInfo threadInfo);
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    private static void ReleaseThread(PooledThread pooled);
    private void Clear();
    private void Cleanup(object _);
}
public class Raven.Server.Utils.PosixFile : object {
    public static void DeleteOnClose(string file);
}
public static class Raven.Server.Utils.ProcessExtensions : object {
    public static bool TryKill(Process process);
    public static bool TryClose(Process process);
    [AsyncStateMachineAttribute("Raven.Server.Utils.ProcessExtensions/<ReadOutput>d__2")]
public static Task`1<string> ReadOutput(StreamReader output);
}
[ExtensionAttribute]
public static class Raven.Server.Utils.PublicKeyPinningHashHelpers : object {
    [ExtensionAttribute]
public static string GetPublicKeyPinningHash(X509Certificate2 cert);
    public static Byte[] GetSubjectPublicKeyInfoRaw(X509Certificate2 cert);
    private static Byte* AsnNext(Byte* buffer, Int32& bufferLength, bool unwrap, bool getRemaining);
}
public class Raven.Server.Utils.RavenHttpClient : HttpClient {
    private static string UserAgent;
    public RavenHttpClient(HttpMessageHandler handler);
    public RavenHttpClient(HttpMessageHandler handler, bool disposeHandler);
    private static RavenHttpClient();
    private void AddUserAgentHeader();
}
internal class Raven.Server.Utils.RavenWin32Service : object {
    private static Logger Logger;
    private RavenServer _ravenServer;
    private String[] _args;
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    private ServiceStoppedCallback _serviceStoppedCallback;
    public string ServiceName { get; }
    public RavenWin32Service(string serviceName, RavenConfiguration configuration, String[] args);
    private static RavenWin32Service();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServiceName();
    public sealed virtual void Start(String[] startupArguments, ServiceStoppedCallback serviceStoppedCallback);
    public void Restart();
    public sealed virtual void Stop();
}
public class Raven.Server.Utils.Reference`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
internal static class Raven.Server.Utils.ReplicationUtils : object {
    public static TcpConnectionInfo GetTcpInfoForInternalReplication(string url, string databaseName, string databaseId, long etag, string tag, X509Certificate2 certificate, string localNodeTag, CancellationToken token);
    public static TcpConnectionInfo GetServerTcpInfo(string url, string tag, X509Certificate2 certificate, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Utils.ReplicationUtils/<GetServerTcpInfoAsync>d__2")]
public static Task`1<TcpConnectionInfo> GetServerTcpInfoAsync(string url, string tag, X509Certificate2 certificate, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Utils.ReplicationUtils/<GetDatabaseTcpInfoAsync>d__3")]
public static Task`1<TcpConnectionInfo> GetDatabaseTcpInfoAsync(string senderUrl, string url, string databaseName, string tag, X509Certificate2 certificate, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Utils.ReplicationUtils/<GetTcpInfoAsync>d__4")]
private static Task`1<TcpConnectionInfo> GetTcpInfoAsync(string url, GetTcpInfoCommand getTcpInfoCommand, X509Certificate2 certificate, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Utils.ReplicationUtils/<GetTcpInfoForInternalReplicationAsync>d__5")]
private static Task`1<TcpConnectionInfo> GetTcpInfoForInternalReplicationAsync(string url, string databaseName, string databaseId, long etag, string tag, X509Certificate2 certificate, string localNodeTag, CancellationToken token);
    public static void EnsureCollectionTag(BlittableJsonReaderObject obj, string collection);
    [DoesNotReturnAttribute]
private static void ThrowInvalidCollectionAfterResolve(string collection, string actual);
}
public static class Raven.Server.Utils.SecurityClearanceValidator : object {
    internal static void AssertSecurityClearance(object input, Nullable`1<AuthenticationStatus> status);
    private static void AssertSecurityClearanceLevel(SecurityClearance attributeStatus, AuthenticationStatus userStatus);
}
public static class Raven.Server.Utils.SecurityUtils : object {
    public static bool IsUnsecuredAccessAllowedForAddress(UnsecuredAccessAddressRange addressRange, IPAddress ipAddress);
    private static bool IsUnsecuredAccessAllowedForIPv4Address(UnsecuredAccessAddressRange addressRange, IPAddress address);
    private static bool IsUnsecuredAccessAllowedForIPv6Address(UnsecuredAccessAddressRange addressRange, IPAddress address);
    private static bool IsLoopbackIpv6(Byte[] arr);
    private static bool IsPrivateIpv6(Byte[] arr);
    private static bool AddressRangeIncludes(UnsecuredAccessAddressRange subjectAddressRange, UnsecuredAccessAddressRange addressRangeToCheck);
}
[ExtensionAttribute]
public static class Raven.Server.Utils.ShardHelper : object {
    public static int NumberOfBuckets;
    public static int GetBucketFor(ShardingConfiguration configuration, ByteStringContext context, string id);
    public static int GetBucketFor(ShardingConfiguration configuration, Slice lowerId);
    public static int GetBucketFor(ShardingConfiguration configuration, ReadOnlySpan`1<byte> lowerId);
    private static int GetBucketFor(ReadOnlySpan`1<byte> buffer);
    private static void AdjustAfterSeparator(char expected, Char*& ptr, Int32& len);
    public static bool TryGetShardNumberAndDatabaseName(string databaseName, String& shardedDatabaseName, Int32& shardNumber);
    public static bool TryGetShardNumberFromDatabaseName(string shardedDatabaseName, Int32& shardNumber);
    public static int GetShardNumberFromDatabaseName(string shardedDatabaseName, bool throwIfShardNumberNotFound);
    public static string ToDatabaseName(string shardName);
    public static string ToShardName(string database, int shard);
    public static bool IsShardName(string name);
    public static IEnumerable`1<string> GetShardNames(DatabaseRecord record);
    [IteratorStateMachineAttribute("Raven.Server.Utils.ShardHelper/<GetShardNames>d__13")]
public static IEnumerable`1<string> GetShardNames(string databaseName, IEnumerable`1<int> shards);
    public static int GetShardNumberFor(ShardingConfiguration configuration, int bucket);
    public static int GetShardNumberFor(ShardingConfiguration configuration, ByteStringContext allocator, string id);
    public static int GetShardNumberFor(ShardingConfiguration configuration, ByteStringContext allocator, LazyStringValue id);
    public static int GetShardNumberFor(ShardingConfiguration configuration, TransactionOperationContext`1<TTransaction> context, string id);
    public static int GetShardNumberFor(RawShardingConfiguration configuration, TransactionOperationContext`1<TTransaction> context, string id);
    public static int GetShardNumberFor(ShardingConfiguration configuration, Slice id);
    private static ValueTuple`2<int, int> GetShardNumberAndBucketFor(ShardingConfiguration configuration, Slice id);
    public static ValueTuple`2<int, int> GetShardNumberAndBucketFor(ShardingConfiguration configuration, ByteStringContext allocator, string id);
    public static ValueTuple`2<int, int> GetShardNumberAndBucketFor(ShardingConfiguration configuration, ByteStringContext allocator, LazyStringValue id);
    public static ValueTuple`2<int, int> GetShardNumberAndBucketFor(ShardingConfiguration configuration, TransactionOperationContext`1<TTransaction> context, string id);
    public static ValueTuple`2<int, int> GetShardNumberAndBucketFor(RawShardingConfiguration configuration, TransactionOperationContext`1<TTransaction> context, string id);
    private static int FindBucketShard(List`1<ShardBucketRange> ranges, int bucket);
    [ExtensionAttribute]
public static void MoveBucket(DatabaseRecord record, int bucket, int toShard);
    private static void ValidateBucketsMapping(DatabaseRecord record);
    public static string GenerateStickyId(string id, char identityPartsSeparator);
    public static string GenerateStickyId(string id, string originalId, char identityPartsSeparator);
    public static ValueTuple`2<int, int> GetShardNumberAndBucketForIdentity(ShardingConfiguration configuration, TransactionOperationContext context, string id, char identityPartsSeparator);
    public static int GetShardNumberFor(ShardingConfiguration configuration, TransactionOperationContext context, string id, char identityPartsSeparator);
    public static void ExtractStickyId(Char*& buffer, Int32& size);
}
public class Raven.Server.Utils.SizeLimitedConcurrentDictionary`2 : object {
    private ConcurrentDictionary`2<TKey, TValue> _dic;
    private ConcurrentQueue`1<TKey> _queue;
    private int _size;
    public SizeLimitedConcurrentDictionary`2(int size);
    public SizeLimitedConcurrentDictionary`2(int size, IEqualityComparer`1<TKey> equalityComparer);
    public void Set(TKey key, TValue item);
    public bool TryGetValue(TKey key, TValue& value);
    public bool TryRemove(TKey key, TValue& value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public TValue GetOrCreate(TKey key);
}
public abstract class Raven.Server.Utils.Stats.DatabaseAwareLivePerformanceCollector`1 : LivePerformanceCollector`1<T> {
    protected DocumentDatabase Database;
    protected DatabaseAwareLivePerformanceCollector`1(DocumentDatabase database);
}
public interface Raven.Server.Utils.Stats.IStatsAggregator {
    public DateTime StartTime { get; }
    public IStatsScope StatsScope { get; }
    public abstract virtual DateTime get_StartTime();
    public abstract virtual IStatsScope get_StatsScope();
}
public interface Raven.Server.Utils.Stats.IStatsScope {
    public TimeSpan Duration { get; }
    public abstract virtual TimeSpan get_Duration();
}
public abstract class Raven.Server.Utils.Stats.LivePerformanceCollector`1 : object {
    private CancellationTokenSource _cts;
    private Task _task;
    protected Logger Logger;
    [CompilerGeneratedAttribute]
private AsyncQueue`1<List`1<T>> <Stats>k__BackingField;
    public AsyncQueue`1<List`1<T>> Stats { get; }
    protected CancellationToken CancellationToken { get; }
    protected TimeSpan SleepTime { get; }
    protected LivePerformanceCollector`1(CancellationToken parentCts, string loggingSource);
    protected void Start();
    [CompilerGeneratedAttribute]
public AsyncQueue`1<List`1<T>> get_Stats();
    protected CancellationToken get_CancellationToken();
    protected virtual TimeSpan get_SleepTime();
    protected abstract virtual Task StartCollectingStats();
    [AsyncStateMachineAttribute("Raven.Server.Utils.Stats.LivePerformanceCollector`1/<RunInLoop>d__13")]
protected Task RunInLoop();
    protected virtual bool ShouldEnqueue(List`1<T> items);
    protected abstract virtual List`1<T> PreparePerformanceStats();
    [AsyncStateMachineAttribute("Raven.Server.Utils.Stats.LivePerformanceCollector`1/<SendStatsOrHeartbeatToWebSocket>d__16`1")]
public Task`1<bool> SendStatsOrHeartbeatToWebSocket(Task`1<WebSocketReceiveResult> receive, WebSocket webSocket, JsonContextPoolBase`1<TContext> contextPool, MemoryStream ms, int timeToWait);
    protected abstract virtual void WriteStats(List`1<T> stats, AsyncBlittableJsonTextWriter writer, JsonOperationContext context);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Dispose>b__18_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__18_1();
}
public abstract class Raven.Server.Utils.Stats.StatsAggregator`2 : object {
    public int Id;
    private bool _completed;
    protected TStats Stats;
    protected TStatsScope Scope;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    public IStatsScope StatsScope { get; }
    public bool Completed { get; }
    public DateTime StartTime { get; protected set; }
    protected StatsAggregator`2(int id, IStatsAggregator lastStats);
    public sealed virtual IStatsScope get_StatsScope();
    protected void SetStartTime(IStatsAggregator lastStats);
    public void Complete();
    public sealed virtual bool get_Completed();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
protected void set_StartTime(DateTime value);
    public TStats ToIndexingBatchStats();
    public abstract virtual TStatsScope CreateScope();
}
public abstract class Raven.Server.Utils.Stats.StatsScope`2 : object {
    private Stopwatch _sw;
    private T _stats;
    private Dictionary`2<string, TStatsScope> _scopes;
    protected List`1<KeyValuePair`2<string, TStatsScope>> Scopes;
    public TimeSpan Duration { get; }
    public T CurrentStats { get; }
    protected StatsScope`2(T stats, bool start);
    public sealed virtual TimeSpan get_Duration();
    public T get_CurrentStats();
    public TStatsScope Start();
    protected abstract virtual TStatsScope OpenNewScope(T stats, bool start);
    public TStatsScope For(string name, bool start);
    public sealed virtual void Dispose();
}
public static class Raven.Server.Utils.ThreadHelper : object {
    public static bool TrySetThreadPriority(ThreadPriority priority, string threadName, Logger logger);
    public static ThreadPriority GetThreadPriority();
}
public class Raven.Server.Utils.ThreadsUsage : object {
    private static Logger Logger;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<long, long> _processTimes;
    private Dictionary`2<int, long> _threadTimesInfo;
    private static ThreadsUsage();
    public ThreadsInfo Calculate(Nullable`1<int> take, HashSet`1<int> threadIds);
    private static T GetThreadInfoOrDefault(Func`1<T> action);
    private static List`1<ProcessThread> GetProcessThreads(Process process);
    private Nullable`1<double> GetThreadCpuUsage(int threadId, TimeSpan threadTotalProcessorTime, long processorTimeDiff, double processCpuUsage);
}
public class Raven.Server.Utils.ThrottledManualResetEventSlim : object {
    private ManualResetEventSlim _mre;
    private MultipleUseFlag _setCalled;
    private TimerManagement _timerManagement;
    private CancellationToken _token;
    private bool _throttlingStarted;
    private Nullable`1<TimeSpan> _throttlingInterval;
    internal Task _timerTask;
    private CancellationTokenSource _timerCts;
    public Nullable`1<TimeSpan> ThrottlingInterval { get; }
    public WaitHandle WaitHandle { get; }
    public bool IsSet { get; }
    public bool IsSetScheduled { get; }
    public ThrottledManualResetEventSlim(Nullable`1<TimeSpan> throttlingInterval, bool initialState, TimerManagement timerManagement, CancellationToken token);
    public Nullable`1<TimeSpan> get_ThrottlingInterval();
    public void Set(bool ignoreThrottling);
    public void Reset();
    public bool Wait(int timeout, CancellationToken token);
    public WaitHandle get_WaitHandle();
    public bool get_IsSet();
    public bool get_IsSetScheduled();
    public void EnableThrottlingTimer();
    public void DisableThrottlingTimer();
    public void Update(Nullable`1<TimeSpan> throttlingInterval);
    private void StartThrottling();
    private void StopThrottling();
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Raven.Server.Utils.ThrottledManualResetEventSlim/<<StartThrottling>b__24_0>d")]
[CompilerGeneratedAttribute]
private Task <StartThrottling>b__24_0();
}
public class Raven.Server.Utils.TransactionHolder : object {
    private Transaction _tx;
    private SemaphoreSlim _lock;
    public TransactionHolder(Transaction tx);
    public IDisposable AcquireTransaction(Transaction& tx);
    [CompilerGeneratedAttribute]
private void <AcquireTransaction>b__3_0();
}
internal static class Raven.Server.Utils.TypeConverter : object {
    private static string TypePropertyName;
    private static StringSegment ValuesPropertyName;
    private static StringSegment ValuePropertyName;
    private static ConcurrentDictionary`2<Type, IPropertyAccessor> PropertyAccessorCache;
    private static ConcurrentDictionary`2<Type, IPropertyAccessor> PropertyAccessorForMapReduceOutputCache;
    private static TypeCache`1<bool> _isSupportedTypeCache;
    private static TypeCache`1<BlittableSupportedReturnType> _supportedTypeCache;
    [CompilerGeneratedAttribute]
private static int <MaxAllowedRecursiveLevelForType>k__BackingField;
    private static HashSet`1<string> _timeSpanPropertiesNames;
    private static HashSet`1<string> _timeOnlyPropertiesNames;
    private static TypeCache`1<bool> _treatAsEnumerableCache;
    public static int MaxAllowedRecursiveLevelForType { get; }
    private static TypeConverter();
    private static bool IsSupportedTypeInternal(object value);
    private static bool UnlikelyIsSupportedType(object value);
    public static bool IsSupportedType(object value);
    public static object ToBlittableSupportedType(object value, bool flattenArrays, bool forIndexing, bool canTryJsStringToDateConversion, Engine engine, JsonOperationContext context);
    public static object ToBlittableSupportedType(object value, BlittableSupportedReturnType& returnType, bool flattenArrays, bool forIndexing, bool canTryJsStringToDateConversion, Engine engine, JsonOperationContext context);
    private static BlittableSupportedReturnType DoBlittableSupportedTypeInternal(Type type, object value);
    private static object ToBlittableSupportedType(object root, object value, bool flattenArrays, bool forIndexing, int recursiveLevel, bool canTryJsStringToDateConversion, Engine engine, JsonOperationContext context, BlittableSupportedReturnType& blittableSupportedReturnType);
    public static string KeyAsString(object key);
    [DoesNotReturnAttribute]
private static void ThrowInvalidObject(JsValue jsValue);
    [IteratorStateMachineAttribute("Raven.Server.Utils.TypeConverter/<EnumerateArray>d__17")]
private static IEnumerable`1<object> EnumerateArray(object root, JsArray arr, bool flattenArrays, bool forIndexing, int recursiveLevel, bool canTryJsStringToDateConversion, Engine engine, JsonOperationContext context);
    private static DynamicJsonArray EnumerableToJsonArray(IEnumerable propertyEnumerable, object root, bool flattenArrays, bool forIndexing, int recursiveLevel, bool canTryJsStringToDateConversion, Engine engine, JsonOperationContext context);
    private static void NestingLevelTooDeep(object value);
    [CompilerGeneratedAttribute]
public static int get_MaxAllowedRecursiveLevelForType();
    [IteratorStateMachineAttribute("Raven.Server.Utils.TypeConverter/<Flatten>d__23")]
internal static IEnumerable`1<object> Flatten(IEnumerable items);
    public static object ToDynamicType(object value);
    private static object ConvertLazyStringValue(LazyStringValue value, StringSegment member, bool supportTimeOnlyDateOnly);
    public static object TryConvertBlittableJsonReaderObject(BlittableJsonReaderObject blittable);
    internal static bool TryConvertStringValue(string value, Object& output);
    internal static bool TryConvertStringValue(string value, bool supportDateOnlyTimeOnly, Object& output);
    public static object ConvertForIndexing(object value, StringSegment propertyName, bool supportTimeOnlyDateOnly);
    public static T Convert(object value, bool cast);
    public static IPropertyAccessor GetPropertyAccessor(object value);
    public static IPropertyAccessor GetPropertyAccessorForMapReduceOutput(object value, Dictionary`2<string, CompiledIndexField> groupByFields);
    public static bool ShouldTreatAsEnumerable(object item);
    private static bool UnlikelyShouldTreatAsEnumerable(object item);
}
public class Raven.Server.Utils.UnhandledExceptions : object {
    internal static TimeSpan TimeToWaitForLog;
    private static UnhandledExceptions();
    public static void Track(Logger logger);
}
public static class Raven.Server.Utils.UrlUtil : object {
    public static string TrimTrailingSlash(string url);
    public static bool IsZeros(string hostName);
}
public class Raven.Server.Utils.WebSocketHelper : object {
    public static ArraySegment`1<byte> Heartbeat;
    private static WebSocketHelper();
}
public class Raven.Server.Utils.WildcardMatcher : object {
    private static Char[] Separator;
    private static WildcardMatcher();
    public static bool Matches(string pattern, string input);
    public static bool MatchesExclusion(string pattern, string input);
    private static bool MatchesImpl(string pattern, string input);
    private static bool MatchesImpl(string pattern, string input, int patternPos, int inputPos);
}
public static class Raven.Server.Utils.WindowsServiceRunner : object {
    public static void Run(string serviceName, RavenConfiguration configuration, String[] args);
    public static bool ShouldRunAsWindowsService();
}
internal abstract class Raven.Server.Web.AbstractQueryStringParameters : object {
    private HttpRequest _httpRequest;
    protected static ReadOnlyMemory`1<char> MetadataOnlyQueryStringName;
    protected static ReadOnlyMemory`1<char> IncludesQueryStringName;
    protected static ReadOnlyMemory`1<char> IdQueryStringName;
    protected static ReadOnlyMemory`1<char> TxModeQueryStringName;
    protected static ReadOnlyMemory`1<char> CounterQueryStringName;
    protected static ReadOnlyMemory`1<char> RevisionsQueryStringName;
    protected static ReadOnlyMemory`1<char> RevisionsBeforeQueryStringName;
    protected static ReadOnlyMemory`1<char> TimeSeriesQueryStringName;
    protected static ReadOnlyMemory`1<char> AllTimeSeries;
    protected static ReadOnlyMemory`1<char> TimeSeriesTimesQueryStringName;
    protected static ReadOnlyMemory`1<char> TimeSeriesCountsQueryStringName;
    protected static ReadOnlyMemory`1<char> CmpxchgQueryStringName;
    protected static ReadOnlyMemory`1<char> FromQueryStringName;
    protected static ReadOnlyMemory`1<char> ToQueryStringName;
    protected static ReadOnlyMemory`1<char> TimeTypeQueryStringName;
    protected static ReadOnlyMemory`1<char> TimeValueQueryStringName;
    protected static ReadOnlyMemory`1<char> TimeUnitQueryStringName;
    protected static ReadOnlyMemory`1<char> CountTypeQueryStringName;
    protected static ReadOnlyMemory`1<char> CountValueQueryStringName;
    protected static ReadOnlyMemory`1<char> AddSpatialPropertiesQueryStringName;
    protected static ReadOnlyMemory`1<char> IncludeServerSideQueryQueryStringName;
    protected static ReadOnlyMemory`1<char> DiagnosticsQueryStringName;
    protected static ReadOnlyMemory`1<char> AddTimeSeriesNamesQueryStringName;
    protected static ReadOnlyMemory`1<char> DisableAutoIndexCreationQueryStringName;
    protected static ReadOnlyMemory`1<char> DebugQueryStringName;
    protected static ReadOnlyMemory`1<char> IgnoreLimitQueryStringName;
    protected static ReadOnlyMemory`1<char> NoReplyQueryStringName;
    protected static ReadOnlyMemory`1<char> WaitForIndexesTimeoutQueryStringName;
    protected static ReadOnlyMemory`1<char> WaitForIndexThrowQueryStringName;
    protected static ReadOnlyMemory`1<char> WaitForSpecificIndexQueryStringName;
    protected static ReadOnlyMemory`1<char> WaitForReplicasTimeoutQueryStringName;
    protected static ReadOnlyMemory`1<char> NumberOfReplicasToWaitForQueryStringName;
    protected static ReadOnlyMemory`1<char> ThrowOnTimeoutInWaitForReplicasQueryStringName;
    private Dictionary`2<string, List`1<string>> _tempStringValues;
    protected AbstractQueryStringParameters(HttpRequest httpRequest);
    private static AbstractQueryStringParameters();
    protected void Parse();
    protected void AddForStringValues(string name, ReadOnlyMemory`1<char> value);
    protected bool AnyStringValues();
    protected StringValues ConvertToStringValues(string name);
    protected abstract virtual void OnFinalize();
    protected abstract virtual void OnValue(EncodedNameValuePair pair);
    protected static bool IsMatch(ReadOnlyMemory`1<char> name, ReadOnlyMemory`1<char> expectedName);
    protected static bool GetBoolValue(ReadOnlyMemory`1<char> name, ReadOnlyMemory`1<char> value);
    protected static int GetIntValue(ReadOnlyMemory`1<char> name, ReadOnlyMemory`1<char> value);
    protected static bool TryGetEnumValue(ReadOnlyMemory`1<char> value, TEnum& outValue);
    protected static TimeSpan GetTimeSpan(ReadOnlyMemory`1<char> name, ReadOnlyMemory`1<char> value);
    [DoesNotReturnAttribute]
private static void ThrowInvalidTimeSpan(ReadOnlyMemory`1<char> name, ReadOnlyMemory`1<char> value);
    [DoesNotReturnAttribute]
private static void ThrowInvalidBool(ReadOnlyMemory`1<char> name, ReadOnlyMemory`1<char> value);
    [DoesNotReturnAttribute]
private static void ThrowInvalidInt(ReadOnlyMemory`1<char> name, ReadOnlyMemory`1<char> value);
}
public class Raven.Server.Web.Authentication.AdminCertificatesHandler : ServerRequestHandler {
    private static Logger Logger;
    public static string HasTwoFactorFieldName;
    public static string TwoFactorExpirationDate;
    private static AdminCertificatesHandler();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<GenerateSecret>d__3")]
[RavenActionAttribute("/admin/certificates/2fa/generate", "GET", "1", "False", "False", "True", "0")]
public Task GenerateSecret();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<Generate>d__4")]
[RavenActionAttribute("/admin/certificates", "POST", "1", "False", "False", "True", "0")]
public Task Generate();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<GenerateCertificateInternal>d__5")]
public static Task`1<Byte[]> GenerateCertificateInternal(CertificateDefinition certificate, ServerStore serverStore, string twoFactorAuthenticationKey, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<Put>d__6")]
[RavenActionAttribute("/admin/certificates", "PUT", "1", "False", "False", "True", "0")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<PutCertificateCollectionInCluster>d__7")]
public static Task PutCertificateCollectionInCluster(CertificateDefinition certDef, Byte[] certBytes, string password, ServerStore serverStore, TransactionOperationContext ctx, string twoFactorAuthenticationKey, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<PurgeExpired>d__8")]
[RavenActionAttribute("/admin/certificates/purge", "DELETE", "1", "False", "False", "True", "0")]
public Task PurgeExpired();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<Delete>d__9")]
[RavenActionAttribute("/admin/certificates", "DELETE", "1", "False", "False", "True", "0")]
public Task Delete();
    private CertificateDefinition ReadCertificateFromCluster(TransactionOperationContext ctx, string key);
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<DeleteInternal>d__11")]
private Task DeleteInternal(List`1<string> keys, string requestId);
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<GetCertificates>d__12")]
[RavenActionAttribute("/admin/certificates", "GET", "1", "False", "False", "True", "0")]
public Task GetCertificates();
    private bool TryGetCertificateByThumbprint(TransactionOperationContext context, string thumbprint, BlittableJsonReaderObject& certificate);
    private bool TryGetAndAddCertificateByThumbprint(TransactionOperationContext context, Dictionary`2<string, BlittableJsonReaderObject> certificateList, string thumbprint, bool metadataOnly);
    private void GetAllRegisteredCertificates(TransactionOperationContext context, Dictionary`2<string, BlittableJsonReaderObject> certificates, bool includeSecondary, string name, bool metadataOnly);
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<WhoAmI>d__16")]
[RavenActionAttribute("/certificates/whoami", "GET", "4", "False", "False", "True", "0")]
public Task WhoAmI();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<Edit>d__17")]
[RavenActionAttribute("/admin/certificates/edit", "POST", "1", "False", "False", "True", "0")]
public Task Edit();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<GetClusterCertificates>d__18")]
[RavenActionAttribute("/admin/certificates/export", "GET", "1", "False", "False", "True", "0")]
public Task GetClusterCertificates();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<Mode>d__19")]
[RavenActionAttribute("/admin/certificates/mode", "GET", "0", "False", "False", "True", "0")]
public Task Mode();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<ClusterDomains>d__20")]
[RavenActionAttribute("/admin/certificates/cluster-domains", "GET", "0", "False", "False", "True", "0")]
public Task ClusterDomains();
    [RavenActionAttribute("/admin/certificates/replacement/reset", "POST", "0", "False", "False", "True", "0")]
public Task ReplacementReset();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<ReplacementStatus>d__22")]
[RavenActionAttribute("/admin/certificates/replacement/status", "GET", "0", "False", "False", "True", "0")]
public Task ReplacementStatus();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<RenewalDate>d__23")]
[RavenActionAttribute("/admin/certificates/letsencrypt/renewal-date", "GET", "0", "False", "False", "True", "0")]
public Task RenewalDate();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<ForceRenew>d__24")]
[RavenActionAttribute("/admin/certificates/letsencrypt/force-renew", "POST", "0", "False", "False", "True", "0")]
public Task ForceRenew();
    [RavenActionAttribute("/admin/certificates/refresh", "POST", "0", "False", "False", "True", "0")]
public Task TriggerCertificateRefresh();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<ReplaceClusterCert>d__26")]
[RavenActionAttribute("/admin/certificates/replace-cluster-cert", "POST", "0", "False", "False", "True", "0")]
public Task ReplaceClusterCert();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<GetLocalState>d__27")]
[RavenActionAttribute("/admin/certificates/local-state", "GET", "1", "False", "False", "True", "0")]
public Task GetLocalState();
    [RavenActionAttribute("/admin/certificates/local-state", "DELETE", "0", "False", "False", "True", "0")]
public Task LocalStateDelete();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.AdminCertificatesHandler/<LocalStateApply>d__29")]
[RavenActionAttribute("/admin/certificates/local-state/apply", "POST", "0", "False", "False", "True", "0")]
public Task LocalStateApply();
    public static void ValidateCertificateDefinition(CertificateDefinition certificate, ServerStore serverStore);
    private static void ValidatePermissions(CertificateDefinition certificate, ServerStore serverStore);
}
public static class Raven.Server.Web.Authentication.TwoFactorAuthentication : object {
    private static string _base32Chars;
    public static string CookieName;
    public static string CreateValidationCode(string twoFactorAuthenticationKey);
    public static bool ValidateCode(string twoFactorAuthenticationKey, int token);
    public static string GenerateQrCodeUri(string secret, string host, string name);
    public static string GenerateSecret();
    private static string GenerateBase32();
    private static int GetNextGroup(Span`1<byte> input, Int32& offset, Byte& a, Byte& b, Byte& c, Byte& d, Byte& e, Byte& f, Byte& g, Byte& h);
    public static Byte[] FromBase32(string input);
}
public class Raven.Server.Web.Authentication.TwoFactorAuthenticationHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.TwoFactorAuthenticationHandler/<TotpConfiguration>d__0")]
[RavenActionAttribute("/authentication/2fa/configuration", "GET", "4", "False", "False", "True", "0")]
public Task TotpConfiguration();
    [RavenActionAttribute("/authentication/2fa", "DELETE", "4", "False", "False", "True", "0")]
public Task LogoutTotp();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.TwoFactorAuthenticationHandler/<ValidateTotp>d__2")]
[RavenActionAttribute("/authentication/2fa", "POST", "4", "False", "False", "True", "0")]
public Task ValidateTotp();
    [AsyncStateMachineAttribute("Raven.Server.Web.Authentication.TwoFactorAuthenticationHandler/<ReplyWith>d__3")]
private Task ReplyWith(TransactionOperationContext ctx, string err, HttpStatusCode httpStatusCode);
}
public class Raven.Server.Web.HtmlUtil : object {
    private static string UnsafePageHtmlResource;
    private static string AuthErrorPageHtmlResource;
    private static string _unsafePageRenderedHtml;
    public static string RenderPlaceholders(string html, IDictionary`2<string, string> substitutions);
    public static string RenderUnsafePage();
    private static string GetUnsecuredAccessFlagsHtml();
    public static string RenderStudioAuthErrorPage(string error);
}
internal class Raven.Server.Web.Http.Behaviors.ProxyCommandResponseBehavior : AbstractCommandResponseBehavior {
    private HttpResponse _response;
    public ProxyCommandResponseBehavior(HttpResponse response);
    public virtual ValueTask HandleNotModifiedAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response, BlittableJsonReaderObject cachedValue);
    public virtual ValueTask`1<bool> TryHandleNotFoundAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response);
    [AsyncStateMachineAttribute("Raven.Server.Web.Http.Behaviors.ProxyCommandResponseBehavior/<TryHandleConflictAsync>d__4`1")]
public virtual ValueTask`1<bool> TryHandleConflictAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response);
    [AsyncStateMachineAttribute("Raven.Server.Web.Http.Behaviors.ProxyCommandResponseBehavior/<TryHandleUnsuccessfulResponseAsync>d__5`1")]
public virtual ValueTask`1<bool> TryHandleUnsuccessfulResponseAsync(JsonOperationContext context, RavenCommand`1<TResult> command, HttpResponseMessage response, CommandUnsuccessfulResponseBehavior unsuccessfulResponseBehavior);
}
public class Raven.Server.Web.Http.ProxyCommand : ProxyCommand`1<object> {
    public ProxyCommand(RavenCommand command, HttpResponse response);
}
public class Raven.Server.Web.Http.ProxyCommand`1 : RavenCommand {
    private RavenCommand`1<T> _command;
    private HttpResponse _response;
    public bool IsReadRequest { get; }
    public bool CanCache { get; protected internal set; }
    public bool CanCacheAggressively { get; protected internal set; }
    internal bool CanReadFromCache { get; internal set; }
    public RavenCommandResponseType ResponseType { get; protected internal set; }
    public string SelectedNodeTag { get; protected internal set; }
    public Nullable`1<TimeSpan> Timeout { get; protected internal set; }
    public ProxyCommand`1(RavenCommand`1<T> command, HttpResponse response);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    [AsyncStateMachineAttribute("Raven.Server.Web.Http.ProxyCommand`1/<ProcessResponse>d__4")]
public virtual Task`1<ResponseDisposeHandling> ProcessResponse(JsonOperationContext context, HttpCache cache, HttpResponseMessage response, string url);
    public virtual bool get_IsReadRequest();
    public virtual bool get_CanCache();
    protected internal virtual void set_CanCache(bool value);
    public virtual bool get_CanCacheAggressively();
    protected internal virtual void set_CanCacheAggressively(bool value);
    internal virtual bool get_CanReadFromCache();
    internal virtual void set_CanReadFromCache(bool value);
    public virtual RavenCommandResponseType get_ResponseType();
    protected internal virtual void set_ResponseType(RavenCommandResponseType value);
    public virtual string get_SelectedNodeTag();
    protected internal virtual void set_SelectedNodeTag(string value);
    public virtual Nullable`1<TimeSpan> get_Timeout();
    protected internal virtual void set_Timeout(Nullable`1<TimeSpan> value);
}
internal class Raven.Server.Web.Operations.GetSuggestConflictResolutionOperation : object {
    private string _documentId;
    public GetSuggestConflictResolutionOperation(string documentId);
    public sealed virtual RavenCommand`1<MergeResult> GetCommand(DocumentConventions conventions, JsonOperationContext context);
}
public class Raven.Server.Web.Operations.OperationsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.OperationsHandler/<GetNextOperationId>d__0")]
[RavenActionAttribute("/databases/*/operations/next-operation-id", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetNextOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.OperationsHandler/<Kill>d__1")]
[RavenActionAttribute("/databases/*/operations/kill", "POST", "3", "2", "False", "False", "True", "0")]
public Task Kill();
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.OperationsHandler/<GetAll>d__2")]
[RavenActionAttribute("/databases/*/operations", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetAll();
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.OperationsHandler/<State>d__3")]
[RavenActionAttribute("/databases/*/operations/state", "GET", "3", "1", "False", "False", "True", "0")]
public Task State();
}
public class Raven.Server.Web.Operations.OperationsServerHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.OperationsServerHandler/<GetNextOperationId>d__0")]
[RavenActionAttribute("/admin/operations/next-operation-id", "GET", "1", "False", "False", "True", "0")]
public Task GetNextOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.OperationsServerHandler/<Kill>d__1")]
[RavenActionAttribute("/admin/operations/kill", "POST", "1", "False", "False", "True", "0")]
public Task Kill();
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.OperationsServerHandler/<State>d__2")]
[RavenActionAttribute("/operations/state", "GET", "3", "1", "False", "False", "True", "0")]
public Task State();
}
internal abstract class Raven.Server.Web.Operations.Processors.AbstractOperationsHandlerProcessorForGetAll`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractOperationsHandlerProcessorForGetAll`2(TRequestHandler requestHandler);
    protected abstract virtual AbstractOperation GetOperation(long operationId);
    protected abstract virtual IEnumerable`1<AbstractOperation> GetAllOperations();
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.Processors.AbstractOperationsHandlerProcessorForGetAll`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Web.Operations.Processors.AbstractOperationsHandlerProcessorForGetNextOperationId`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractOperationsHandlerProcessorForGetNextOperationId`2(TRequestHandler requestHandler);
    protected abstract virtual long GetNextOperationId();
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.Processors.AbstractOperationsHandlerProcessorForGetNextOperationId`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Web.Operations.Processors.AbstractOperationsHandlerProcessorForKill`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractOperationsHandlerProcessorForKill`2(TRequestHandler requestHandler);
    protected abstract virtual ValueTask KillOperationAsync(long operationId, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.Processors.AbstractOperationsHandlerProcessorForKill`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Web.Operations.Processors.AbstractOperationsHandlerProcessorForState`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractOperationsHandlerProcessorForState`2(TRequestHandler requestHandler);
    protected abstract virtual OperationState GetOperationState(long operationId);
    [AsyncStateMachineAttribute("Raven.Server.Web.Operations.Processors.AbstractOperationsHandlerProcessorForState`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Web.Operations.Processors.OperationsHandlerProcessorForGetAll : AbstractOperationsHandlerProcessorForGetAll`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OperationsHandlerProcessorForGetAll(DatabaseRequestHandler requestHandler);
    protected virtual AbstractOperation GetOperation(long operationId);
    protected virtual IEnumerable`1<AbstractOperation> GetAllOperations();
}
internal class Raven.Server.Web.Operations.Processors.OperationsHandlerProcessorForGetNextOperationId : AbstractOperationsHandlerProcessorForGetNextOperationId`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OperationsHandlerProcessorForGetNextOperationId(DatabaseRequestHandler requestHandler);
    protected virtual long GetNextOperationId();
}
internal class Raven.Server.Web.Operations.Processors.OperationsHandlerProcessorForKill : AbstractOperationsHandlerProcessorForKill`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OperationsHandlerProcessorForKill(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask KillOperationAsync(long operationId, CancellationToken token);
}
internal class Raven.Server.Web.Operations.Processors.OperationsHandlerProcessorForState : AbstractOperationsHandlerProcessorForState`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public OperationsHandlerProcessorForState(DatabaseRequestHandler requestHandler);
    protected virtual OperationState GetOperationState(long operationId);
}
public abstract class Raven.Server.Web.RequestHandler : object {
    public static string StartParameter;
    public static string PageSizeParameter;
    internal static HashSet`1<string> SafeCsrfMethods;
    private RequestHandlerContext _context;
    private Stream _requestBodyStream;
    private Stream _responseStream;
    public static string BackupDatabaseOnceTag;
    public static string DefineHubDebugTag;
    public static string UpdatePullReplicationOnSinkNodeDebugTag;
    public static string UpdatePeriodicBackupDebugTag;
    public static string PutConnectionStringDebugTag;
    public static string AddEtlDebugTag;
    public static string AddQueueSinkDebugTag;
    public static string UpdateExternalReplicationDebugTag;
    public string RequestIp { get; }
    internal HttpContext HttpContext { get; }
    public RavenServer Server { get; }
    public ServerStore ServerStore { get; }
    public RouteMatch RouteMatch { get; }
    public CancellationToken AbortRequestToken { get; }
    private static RequestHandler();
    public void LogTaskToAudit(string description, long id, BlittableJsonReaderObject configuration);
    public bool IsLocalRequest();
    public string get_RequestIp();
    public void LogAuditFor(string logger, string action, string target, Exception e);
    internal HttpContext get_HttpContext();
    public RavenServer get_Server();
    public ServerStore get_ServerStore();
    public RouteMatch get_RouteMatch();
    public X509Certificate2 GetCurrentCertificate();
    public CancellationToken get_AbortRequestToken();
    public virtual void Init(RequestHandlerContext context);
    public abstract virtual Task CheckForChanges(RequestHandlerContext context);
    internal Stream TryGetRequestFromStream(string itemName);
    internal Stream RequestBodyStream();
    public Stream GetBodyStream(MultipartSection section);
    internal Stream GetDecompressedStream(Stream stream, IDictionary`2<string, StringValues> headers);
    protected static GZipStream GetGzipStream(Stream stream, CompressionMode mode, CompressionLevel level);
    protected bool ClientAcceptsGzipResponse();
    private static Nullable`1<HttpCompressionAlgorithm> GetHttpCompressionAlgorithmFromHeaders(IDictionary`2<string, StringValues> headers, string encodingsHeader);
    public static void ValidateNodeForAddingToDb(string databaseName, string node, DatabaseRecord databaseRecord, ClusterTopology clusterTopology, RavenServer server, string baseMessage);
    public void AddStringToHttpContext(string str, TrafficWatchChangeType type);
    internal Stream ResponseBodyStream();
    internal string GetRaftRequestIdFromQuery();
    protected internal string GetStringFromHeaders(string name);
    public virtual Nullable`1<long> GetLongFromHeaders(string name);
    [DoesNotReturnAttribute]
public void ThrowInvalidInteger(string name, string etag, string type);
    protected internal int GetStart(int defaultStart);
    protected internal int GetPageSize(int defaultPageSize);
    protected internal Nullable`1<int> GetIntValueQueryString(string name, bool required);
    internal long GetLongQueryString(string name);
    internal Nullable`1<long> GetLongQueryString(string name, bool required);
    internal string GetStringQueryString(string name, bool required);
    internal Nullable`1<char> GetCharQueryString(string name, bool required);
    [DoesNotReturnAttribute]
private static void ThrowSingleCharacterRequired(string name, string value);
    [DoesNotReturnAttribute]
private static void ThrowRequiredMember(string name);
    [DoesNotReturnAttribute]
public static void ThrowRequiredPropertyNameInRequest(string name);
    internal StringValues GetStringValuesQueryString(string name, bool required);
    internal Nullable`1<bool> GetBoolValueQueryString(string name, bool required);
    [DoesNotReturnAttribute]
private static void ThrowInvalidBoolean(string name, string val);
    internal Nullable`1<DateTime> GetDateTimeQueryString(string name, bool required);
    [DoesNotReturnAttribute]
public static void ThrowInvalidDateTime(string name, string dataAsString);
    protected internal Nullable`1<TimeSpan> GetTimeSpanQueryString(string name, bool required);
    [DoesNotReturnAttribute]
private static void ThrowInvalidTimeSpan(string name, string timeSpanAsString);
    internal string GetQueryStringValueAndAssertIfSingleAndNotEmpty(string name);
    private static void InvalidEmptyValue(string name);
    private static void InvalidCountOfValues(string name);
    internal Task NoContent(HttpStatusCode statusCode);
    internal void NoContentStatus(HttpStatusCode statusCode);
    protected bool IsClusterAdmin();
    [AsyncStateMachineAttribute("Raven.Server.Web.RequestHandler/<IsOperatorAsync>d__61")]
public Task`1<bool> IsOperatorAsync();
    [AsyncStateMachineAttribute("Raven.Server.Web.RequestHandler/<CanAccessDatabaseAsync>d__63")]
internal Task`1<bool> CanAccessDatabaseAsync(string dbName, bool requireAdmin, bool requireWrite);
    [AsyncStateMachineAttribute("Raven.Server.Web.RequestHandler/<GetAllowedDbsAsync>d__64")]
protected internal Task`1<AllowedDbs> GetAllowedDbsAsync(string dbName, bool requireAdmin, bool requireWrite);
    [DoesNotReturnAttribute]
private static void ThrowInvalidAuthStatus(Nullable`1<AuthenticationStatus> status);
    public static bool CheckCSRF(HttpContext httpContext, ServerStore serverStore);
    public static void SetupCORSHeaders(HttpContext httpContext, ServerStore serverStore, CorsMode corsMode);
    private static bool IsOriginAllowed(string origin, ServerStore serverStore);
    protected void RedirectToLeader();
    public virtual bool IsShutdownRequested();
    [DoesNotReturnAttribute]
public virtual void ThrowShutdownException(Exception inner);
    public virtual OperationCancelToken CreateHttpRequestBoundOperationToken();
    public virtual OperationCancelToken CreateHttpRequestBoundOperationToken(CancellationToken token);
    public virtual OperationCancelToken CreateHttpRequestBoundTimeLimitedOperationToken(TimeSpan cancelAfter);
    public virtual OperationCancelToken CreateBackgroundOperationToken();
    public virtual Task WaitForIndexToBeAppliedAsync(TransactionOperationContext context, long index);
    private DynamicJsonValue GetCustomConfigurationAuditJson(string name, BlittableJsonReaderObject configuration);
    private DynamicJsonValue GetEtlConfigurationAuditJson(BlittableJsonReaderObject configuration);
    private DynamicJsonValue GetConnectionStringConfigurationAuditJson(BlittableJsonReaderObject configuration);
    internal void TrafficWatchQuery(IndexQueryServerSide indexQuery);
    internal void TrafficWatchStreamQuery(IndexQueryServerSide indexQuery);
    private void TrafficWatchQuery(IndexQueryServerSide indexQuery, TrafficWatchChangeType type);
    public AuthorizationStatus GetAuthorizationStatusForSmuggler(string databaseName);
}
public class Raven.Server.Web.RequestHandlerContext : object {
    public HttpContext HttpContext;
    public RavenServer RavenServer;
    public RouteMatch RouteMatch;
    public DocumentDatabase Database;
    public bool CheckForChanges;
    public ShardedDatabaseContext DatabaseContext;
    public string DatabaseName { get; }
    public MetricCounters DatabaseMetrics { get; }
    public string get_DatabaseName();
    public MetricCounters get_DatabaseMetrics();
}
public class Raven.Server.Web.ResponseCompression.DeflateCompressionProvider : object {
    [CompilerGeneratedAttribute]
private DeflateCompressionProviderOptions <Options>k__BackingField;
    private DeflateCompressionProviderOptions Options { get; }
    public string EncodingName { get; }
    public bool SupportsFlush { get; }
    public DeflateCompressionProvider(IOptions`1<DeflateCompressionProviderOptions> options);
    [CompilerGeneratedAttribute]
private DeflateCompressionProviderOptions get_Options();
    public sealed virtual Stream CreateStream(Stream outputStream);
    public sealed virtual string get_EncodingName();
    public sealed virtual bool get_SupportsFlush();
}
public class Raven.Server.Web.ResponseCompression.DeflateCompressionProviderOptions : object {
    [CompilerGeneratedAttribute]
private CompressionLevel <Level>k__BackingField;
    public CompressionLevel Level { get; public set; }
    private DeflateCompressionProviderOptions Microsoft.Extensions.Options.IOptions<Raven.Server.Web.ResponseCompression.DeflateCompressionProviderOptions>.Value { get; }
    [CompilerGeneratedAttribute]
public CompressionLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(CompressionLevel value);
    private sealed virtual override DeflateCompressionProviderOptions Microsoft.Extensions.Options.IOptions<Raven.Server.Web.ResponseCompression.DeflateCompressionProviderOptions>.get_Value();
}
public class Raven.Server.Web.ResponseCompression.ZstdCompressionProvider : object {
    [CompilerGeneratedAttribute]
private ZstdCompressionProviderOptions <Options>k__BackingField;
    private ZstdCompressionProviderOptions Options { get; }
    public string EncodingName { get; }
    public bool SupportsFlush { get; }
    public ZstdCompressionProvider(IOptions`1<ZstdCompressionProviderOptions> options);
    [CompilerGeneratedAttribute]
private ZstdCompressionProviderOptions get_Options();
    public sealed virtual Stream CreateStream(Stream outputStream);
    public sealed virtual string get_EncodingName();
    public sealed virtual bool get_SupportsFlush();
}
public class Raven.Server.Web.ResponseCompression.ZstdCompressionProviderOptions : object {
    [CompilerGeneratedAttribute]
private CompressionLevel <Level>k__BackingField;
    public CompressionLevel Level { get; public set; }
    private ZstdCompressionProviderOptions Microsoft.Extensions.Options.IOptions<Raven.Server.Web.ResponseCompression.ZstdCompressionProviderOptions>.Value { get; }
    [CompilerGeneratedAttribute]
public CompressionLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(CompressionLevel value);
    private sealed virtual override ZstdCompressionProviderOptions Microsoft.Extensions.Options.IOptions<Raven.Server.Web.ResponseCompression.ZstdCompressionProviderOptions>.get_Value();
}
public abstract class Raven.Server.Web.ServerRequestHandler : RequestHandler {
    public virtual Task CheckForChanges(RequestHandlerContext context);
    protected void AssertCanPersistConfiguration();
}
public class Raven.Server.Web.Studio.DataDirectoryInfo : object {
    private static Logger Logger;
    private ServerStore _serverStore;
    private string _path;
    private string _name;
    private bool _isBackup;
    private bool _getNodesInfo;
    private int _requestTimeoutInMs;
    private Stream _responseBodyStream;
    public DataDirectoryInfo(ServerStore serverStore, string path, string name, bool isBackup, bool getNodesInfo, int requestTimeoutInMs, Stream responseBodyStream);
    private static DataDirectoryInfo();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.DataDirectoryInfo/<UpdateDirectoryResult>d__9")]
public Task UpdateDirectoryResult(string databaseName, string error);
    public static bool CanAccessPath(string folderPath, String& error);
    private List`1<string> GetRelevantNodes(string databaseName, ClusterTopology clusterTopology);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.DataDirectoryInfo/<UpdateNodesDirectoryResult>d__12")]
private Task UpdateNodesDirectoryResult(IEnumerable`1<string> nodes, ClusterTopology clusterTopology, DataDirectoryResult dataDirectoryResult);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.DataDirectoryInfo/<GetSingleNodeDataDirectoryInfo>d__13")]
private Task`1<SingleNodeDataDirectoryResult> GetSingleNodeDataDirectoryInfo(string serverUrl);
}
public class Raven.Server.Web.Studio.DataDirectoryResult : object {
    public SortedSet`1<SingleNodeDataDirectoryResult> List;
    public sealed virtual DynamicJsonValue ToJson();
}
public static class Raven.Server.Web.Studio.FolderPath : object {
    public static FolderPathOptions GetOptions(string path, bool isBackupFolder, RavenConfiguration ravenConfiguration);
    private static bool IsHiddenOrSystemDirectory(string directory);
    private static List`1<string> GetAvailableDrives();
    private static string GetRestrictedFolder(bool isBackupFolder, RavenConfiguration ravenConfiguration);
}
public class Raven.Server.Web.Studio.FolderPathOptions : object {
    [CompilerGeneratedAttribute]
private SortedSet`1<string> <List>k__BackingField;
    public SortedSet`1<string> List { get; }
    [CompilerGeneratedAttribute]
public SortedSet`1<string> get_List();
}
public class Raven.Server.Web.Studio.LicenseHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.LicenseHandler/<Eula>d__0")]
[RavenActionAttribute("/license/eula", "GET", "3", "1", "False", "False", "True", "0")]
public Task Eula();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.LicenseHandler/<AcceptEula>d__1")]
[RavenActionAttribute("/admin/license/eula/accept", "POST", "1", "False", "False", "True", "0")]
public Task AcceptEula();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.LicenseHandler/<Status>d__2")]
[RavenActionAttribute("/license/status", "GET", "3", "1", "False", "False", "True", "0")]
public Task Status();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.LicenseHandler/<GetLicenseConfigurationSettings>d__3")]
[RavenActionAttribute("/license/configuration", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetLicenseConfigurationSettings();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.LicenseHandler/<Activate>d__4")]
[RavenActionAttribute("/admin/license/activate", "POST", "0", "False", "False", "True", "0")]
public Task Activate();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.LicenseHandler/<ForceUpdate>d__5")]
[RavenActionAttribute("/admin/license/forceUpdate", "POST", "0", "False", "False", "True", "0")]
public Task ForceUpdate();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.LicenseHandler/<LicenseSupport>d__6")]
[RavenActionAttribute("/license/support", "GET", "3", "1", "False", "False", "True", "0")]
public Task LicenseSupport();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.LicenseHandler/<RenewLicense>d__7")]
[RavenActionAttribute("/admin/license/renew", "POST", "0", "False", "False", "True", "0")]
public Task RenewLicense();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.LicenseHandler/<CheckConnectivityToLicenseServer>d__8")]
[RavenActionAttribute("/license-server/connectivity", "GET", "3", "1", "False", "False", "True", "0")]
public Task CheckConnectivityToLicenseServer();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.LicenseHandler/<GetLicenseLimitsUsage>d__10")]
[RavenActionAttribute("/license/limits-usage", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetLicenseLimitsUsage();
}
internal abstract class Raven.Server.Web.Studio.Processors.AbstractBucketsHandlerProcessorForGetBucket`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractBucketsHandlerProcessorForGetBucket`2(TRequestHandler requestHandler);
    public int GetBucket();
    protected abstract virtual ValueTask`1<BucketInfo> GetBucketInfo(TOperationContext context, int bucket);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.AbstractBucketsHandlerProcessorForGetBucket`2/<ExecuteAsync>d__3")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Web.Studio.Processors.AbstractBucketsHandlerProcessorForGetBuckets`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractBucketsHandlerProcessorForGetBuckets`2(TRequestHandler requestHandler);
    protected ValueTuple`3<int, int, int> GetParameters();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.AbstractBucketsHandlerProcessorForGetBuckets`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    protected abstract virtual ValueTask`1<BucketsResults> GetBucketsResults(TOperationContext context, int fromBucket, int toBucket, int range, CancellationToken token);
}
public abstract class Raven.Server.Web.Studio.Processors.AbstractStudioCollectionsHandlerProcessorForPreviewCollection`2 : object {
    private static int ColumnsSamplingLimit;
    private static int StringLengthLimit;
    protected TRequestHandler RequestHandler;
    protected HttpContext HttpContext;
    protected string Collection;
    protected bool IsAllDocsCollection;
    private StringValues _bindings;
    private StringValues _fullBindings;
    protected AbstractStudioCollectionsHandlerProcessorForPreviewCollection`2(TRequestHandler requestHandler);
    protected virtual ValueTask InitializeAsync();
    protected abstract virtual JsonOperationContext GetContext();
    protected abstract virtual ValueTask`1<long> GetTotalResultsAsync();
    protected abstract virtual bool NotModified(String& etag);
    protected abstract virtual IAsyncEnumerable`1<TResult> GetDocumentsAsync();
    protected abstract virtual ValueTask`1<List`1<string>> GetAvailableColumnsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.AbstractStudioCollectionsHandlerProcessorForPreviewCollection`2/<ExecuteAsync>d__15")]
public Task ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.AbstractStudioCollectionsHandlerProcessorForPreviewCollection`2/<WriteResultsAsync>d__16")]
protected virtual ValueTask WriteResultsAsync(AsyncBlittableJsonTextWriter writer, IAsyncEnumerable`1<TResult> results, JsonOperationContext context, PreviewState<TRequestHandler, TResult> state);
    protected virtual PreviewState<TRequestHandler, TResult> CreatePreviewState();
    protected abstract virtual void WriteResult(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, TResult document, PreviewState<TRequestHandler, TResult> state);
    protected abstract virtual void WriteMetadata(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, Document document, BlittableJsonReaderObject metadata);
    protected void WriteDocument(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, Document document, PreviewState<TRequestHandler, TResult> state);
    private static void WriteTrimmedValue(AsyncBlittableJsonTextWriter writer, BlittableJsonToken token, object val);
    private static ValueWriteStrategy<TRequestHandler, TResult> FindWriteStrategy(BlittableJsonToken token, object val);
    public virtual void Dispose();
}
internal abstract class Raven.Server.Web.Studio.Processors.AbstractStudioDatabaseTasksHandlerProcessorForGetIndexDefaults`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractStudioDatabaseTasksHandlerProcessorForGetIndexDefaults`2(TRequestHandler requestHandler);
    protected abstract virtual RavenConfiguration GetDatabaseConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.AbstractStudioDatabaseTasksHandlerProcessorForGetIndexDefaults`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Web.Studio.Processors.AbstractStudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractStudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution`2(TRequestHandler requestHandler);
    protected abstract virtual Task GetSuggestConflictResolutionAsync(TOperationContext context, string documentId);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.AbstractStudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Web.Studio.Processors.AbstractStudioDatabaseTasksHandlerProcessorForRestartDatabase`2 : AbstractHandlerProxyNoContentProcessor`2<TRequestHandler, TOperationContext> {
    protected bool SupportsCurrentNode { get; }
    protected AbstractStudioDatabaseTasksHandlerProcessorForRestartDatabase`2(TRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.AbstractStudioDatabaseTasksHandlerProcessorForRestartDatabase`2/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual RavenCommand`1<object> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Web.Studio.Processors.AbstractStudioIndexHandlerForPostIndexFields`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    protected AbstractStudioIndexHandlerForPostIndexFields`2(TRequestHandler requestHandler);
    protected abstract virtual RavenConfiguration GetDatabaseConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.AbstractStudioIndexHandlerForPostIndexFields`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    private static Dictionary`2<string, string> ConvertToAdditionalSources(BlittableJsonReaderObject json);
    private static HashSet`1<AdditionalAssembly> ConvertToAdditionalAssemblies(BlittableJsonReaderArray jsonArray);
    private static AdditionalAssembly GetAssembly(BlittableJsonReaderObject json);
}
internal abstract class Raven.Server.Web.Studio.Processors.AbstractStudioIndexHandlerProcessorForGetIndexErrorsCount`2 : AbstractHandlerProxyReadProcessor`3<IndexErrorsCount[], TRequestHandler, TOperationContext> {
    protected AbstractStudioIndexHandlerProcessorForGetIndexErrorsCount`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<IndexErrorsCount[]> CreateCommandForNode(string nodeTag);
    protected String[] GetIndexNames();
}
public class Raven.Server.Web.Studio.Processors.BucketInfo : BucketStats {
    public List`1<string> Items;
    public virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Web.Studio.Processors.BucketRange : object {
    public long FromBucket;
    public long ToBucket;
    public long NumberOfBuckets;
    public long RangeSize;
    public HashSet`1<int> ShardNumbers;
    public long DocumentsCount;
    public DateTime LastModified;
    public string RangeSizeHumane { get; }
    public string get_RangeSizeHumane();
    public sealed virtual DynamicJsonValue ToJson();
}
internal class Raven.Server.Web.Studio.Processors.BucketsHandlerProcessorForGetBucket : AbstractBucketsHandlerProcessorForGetBucket`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public BucketsHandlerProcessorForGetBucket(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<BucketInfo> GetBucketInfo(DocumentsOperationContext context, int bucket);
}
internal class Raven.Server.Web.Studio.Processors.BucketsHandlerProcessorForGetBuckets : AbstractBucketsHandlerProcessorForGetBuckets`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public BucketsHandlerProcessorForGetBuckets(DatabaseRequestHandler requestHandler);
    protected virtual ValueTask`1<BucketsResults> GetBucketsResults(DocumentsOperationContext context, int fromBucket, int toBucket, int range, CancellationToken token);
}
public class Raven.Server.Web.Studio.Processors.BucketsResults : object {
    public long TotalSize;
    public Dictionary`2<int, BucketRange> BucketRanges;
    public string TotalSizeHumane { get; }
    public string get_TotalSizeHumane();
    public DynamicJsonValue ToJson();
}
public class Raven.Server.Web.Studio.Processors.GetBucketInfoCommand : RavenCommand`1<BucketInfo> {
    private int _bucket;
    public bool IsReadRequest { get; }
    internal GetBucketInfoCommand(int bucket);
    public virtual bool get_IsReadRequest();
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
}
public class Raven.Server.Web.Studio.Processors.GetBucketsCommand : RavenCommand`1<BucketsResults> {
    private int _fromBucket;
    private int _toBucket;
    private int _range;
    private Nullable`1<int> _shardNumber;
    public bool IsReadRequest { get; }
    internal GetBucketsCommand(int fromBucket, int toBucket, int range, Nullable`1<int> shardNumber);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public class Raven.Server.Web.Studio.Processors.IndexDefaults : object {
    [CompilerGeneratedAttribute]
private IndexDeploymentMode <AutoIndexDeploymentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexDeploymentMode <StaticIndexDeploymentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchEngineType <StaticIndexingEngineType>k__BackingField;
    public IndexDeploymentMode AutoIndexDeploymentMode { get; public set; }
    public IndexDeploymentMode StaticIndexDeploymentMode { get; public set; }
    public SearchEngineType StaticIndexingEngineType { get; public set; }
    [CompilerGeneratedAttribute]
public IndexDeploymentMode get_AutoIndexDeploymentMode();
    [CompilerGeneratedAttribute]
public void set_AutoIndexDeploymentMode(IndexDeploymentMode value);
    [CompilerGeneratedAttribute]
public IndexDeploymentMode get_StaticIndexDeploymentMode();
    [CompilerGeneratedAttribute]
public void set_StaticIndexDeploymentMode(IndexDeploymentMode value);
    [CompilerGeneratedAttribute]
public SearchEngineType get_StaticIndexingEngineType();
    [CompilerGeneratedAttribute]
public void set_StaticIndexingEngineType(SearchEngineType value);
}
public class Raven.Server.Web.Studio.Processors.IndexTypeInfo : object {
    [CompilerGeneratedAttribute]
private IndexType <IndexType>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexSourceType <IndexSourceType>k__BackingField;
    public IndexType IndexType { get; public set; }
    public IndexSourceType IndexSourceType { get; public set; }
    [CompilerGeneratedAttribute]
public IndexType get_IndexType();
    [CompilerGeneratedAttribute]
public void set_IndexType(IndexType value);
    [CompilerGeneratedAttribute]
public IndexSourceType get_IndexSourceType();
    [CompilerGeneratedAttribute]
public void set_IndexSourceType(IndexSourceType value);
}
public class Raven.Server.Web.Studio.Processors.StudioCollectionsHandlerProcessorForPreviewCollection : AbstractStudioCollectionsHandlerProcessorForPreviewCollection`2<DatabaseRequestHandler, Document> {
    private DocumentDatabase _database;
    private int _start;
    private int _pageSize;
    private long _totalResults;
    private IDisposable _releaseContext;
    private IDisposable _closeTransaction;
    private DocumentsOperationContext _context;
    private List`1<Document> _documents;
    public StudioCollectionsHandlerProcessorForPreviewCollection(DatabaseRequestHandler requestHandler, DocumentDatabase database);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.StudioCollectionsHandlerProcessorForPreviewCollection/<InitializeAsync>d__9")]
protected virtual ValueTask InitializeAsync();
    protected virtual JsonOperationContext GetContext();
    protected virtual ValueTask`1<long> GetTotalResultsAsync();
    protected virtual bool NotModified(String& etag);
    protected virtual IAsyncEnumerable`1<Document> GetDocumentsAsync();
    protected virtual ValueTask`1<List`1<string>> GetAvailableColumnsAsync();
    protected virtual void WriteResult(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, Document document, PreviewState<DatabaseRequestHandler, Document> state);
    protected virtual void WriteMetadata(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, Document document, BlittableJsonReaderObject metadata);
    public virtual void Dispose();
    private static List`1<string> ExtractColumnNames(List`1<Document> documents, JsonOperationContext context);
    private static void FetchColumnNames(BlittableJsonReaderObject data, List`1<string> columns);
    private static void RemoveMetadata(JsonOperationContext context, List`1<string> columns);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
internal class Raven.Server.Web.Studio.Processors.StudioDatabaseTasksHandlerProcessorForGetFolderPathOptionsForDatabaseAdmin : AbstractServerHandlerProxyReadProcessor`1<FolderPathOptions> {
    protected bool SupportsCurrentNode { get; }
    public StudioDatabaseTasksHandlerProcessorForGetFolderPathOptionsForDatabaseAdmin(RequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.StudioDatabaseTasksHandlerProcessorForGetFolderPathOptionsForDatabaseAdmin/<HandleCurrentNodeAsync>d__1")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<FolderPathOptions> command, JsonOperationContext context, OperationCancelToken token);
    protected virtual ValueTask`1<RavenCommand`1<FolderPathOptions>> CreateCommandForNodeAsync(string nodeTag, JsonOperationContext context);
    protected PeriodicBackupConnectionType GetPeriodicBackupConnectionType();
    protected bool IsBackupFolder();
    protected string GetPath();
    protected virtual bool get_SupportsCurrentNode();
}
internal class Raven.Server.Web.Studio.Processors.StudioDatabaseTasksHandlerProcessorForGetFolderPathOptionsForOperator : StudioDatabaseTasksHandlerProcessorForGetFolderPathOptionsForDatabaseAdmin {
    public StudioDatabaseTasksHandlerProcessorForGetFolderPathOptionsForOperator(RequestHandler requestHandler);
    protected virtual ValueTask`1<RavenCommand`1<FolderPathOptions>> CreateCommandForNodeAsync(string nodeTag, JsonOperationContext context);
}
internal class Raven.Server.Web.Studio.Processors.StudioDatabaseTasksHandlerProcessorForGetIndexDefaults : AbstractStudioDatabaseTasksHandlerProcessorForGetIndexDefaults`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StudioDatabaseTasksHandlerProcessorForGetIndexDefaults(DatabaseRequestHandler requestHandler);
    protected virtual RavenConfiguration GetDatabaseConfiguration();
}
internal class Raven.Server.Web.Studio.Processors.StudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution : AbstractStudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution(DatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.StudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution/<GetSuggestConflictResolutionAsync>d__1")]
protected virtual Task GetSuggestConflictResolutionAsync(DocumentsOperationContext context, string documentId);
}
internal class Raven.Server.Web.Studio.Processors.StudioDatabaseTasksHandlerProcessorForRestartDatabase : AbstractStudioDatabaseTasksHandlerProcessorForRestartDatabase`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StudioDatabaseTasksHandlerProcessorForRestartDatabase(DatabaseRequestHandler requestHandler);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Web.Studio.Processors.StudioIndexHandlerForPostIndexFields : AbstractStudioIndexHandlerForPostIndexFields`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public StudioIndexHandlerForPostIndexFields(DatabaseRequestHandler requestHandler);
    protected virtual RavenConfiguration GetDatabaseConfiguration();
}
internal class Raven.Server.Web.Studio.Processors.StudioIndexHandlerForPostIndexType`1 : AbstractDatabaseHandlerProcessor`1<TOperationContext> {
    public StudioIndexHandlerForPostIndexType`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.StudioIndexHandlerForPostIndexType`1/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Web.Studio.Processors.StudioTasksHandlerProcessorForTestPeriodicBackupCredentials : AbstractHandlerProcessor`1<RequestHandler> {
    public StudioTasksHandlerProcessorForTestPeriodicBackupCredentials(RequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Processors.StudioTasksHandlerProcessorForTestPeriodicBackupCredentials/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
public class Raven.Server.Web.Studio.SampleDataHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.SampleDataHandler/<PostCreateSampleData>d__0")]
[RavenActionAttribute("/databases/*/studio/sample-data", "POST", "3", "2", "False", "False", "True", "0")]
public Task PostCreateSampleData();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.SampleDataHandler/<GetSampleDataClasses>d__1")]
[RavenActionAttribute("/databases/*/studio/sample-data/classes", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetSampleDataClasses();
}
public class Raven.Server.Web.Studio.Sharding.BucketsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.BucketsHandler/<GetBuckets>d__0")]
[RavenActionAttribute("/databases/*/debug/sharding/buckets", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetBuckets();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.BucketsHandler/<GetBucket>d__1")]
[RavenActionAttribute("/databases/*/debug/sharding/bucket", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetBucket();
}
internal class Raven.Server.Web.Studio.Sharding.Processors.ShardedBucketsHandlerProcessorForGetBucket : AbstractBucketsHandlerProcessorForGetBucket`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedBucketsHandlerProcessorForGetBucket(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.Processors.ShardedBucketsHandlerProcessorForGetBucket/<GetBucketInfo>d__1")]
protected virtual ValueTask`1<BucketInfo> GetBucketInfo(TransactionOperationContext context, int bucket);
}
internal class Raven.Server.Web.Studio.Sharding.Processors.ShardedBucketsHandlerProcessorForGetBuckets : AbstractBucketsHandlerProcessorForGetBuckets`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedBucketsHandlerProcessorForGetBuckets(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.Processors.ShardedBucketsHandlerProcessorForGetBuckets/<GetBucketsResults>d__1")]
protected virtual ValueTask`1<BucketsResults> GetBucketsResults(TransactionOperationContext context, int fromBucket, int toBucket, int range, CancellationToken token);
}
[IsReadOnlyAttribute]
public class Raven.Server.Web.Studio.Sharding.Processors.ShardedGetBucketsOperation : ValueType {
    private HttpRequest _request;
    private int _fromBucket;
    private int _toBucket;
    private int _range;
    public HttpRequest HttpRequest { get; }
    public ShardedGetBucketsOperation(HttpRequest httpRequest, int fromBucket, int toBucket, int range);
    public sealed virtual HttpRequest get_HttpRequest();
    public sealed virtual BucketsResults Combine(Dictionary`2<int, ShardExecutionResult`1<BucketsResults>> results);
    public sealed virtual RavenCommand`1<BucketsResults> CreateCommandForShard(int shardNumber);
}
public class Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioCollectionsHandlerProcessorForPreviewCollection : AbstractStudioCollectionsHandlerProcessorForPreviewCollection`2<ShardedDatabaseRequestHandler, ShardStreamItem`1<Document>> {
    private ShardedDatabaseRequestHandler _requestHandler;
    private IDisposable _releaseContext;
    private JsonOperationContext _context;
    private ShardedPagingContinuation _continuationToken;
    private CombinedReadContinuationState _combinedReadState;
    private string _combinedEtag;
    public ShardedStudioCollectionsHandlerProcessorForPreviewCollection(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioCollectionsHandlerProcessorForPreviewCollection/<InitializeAsync>d__7")]
protected virtual ValueTask InitializeAsync();
    protected virtual JsonOperationContext GetContext();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioCollectionsHandlerProcessorForPreviewCollection/<WriteResultsAsync>d__9")]
protected virtual ValueTask WriteResultsAsync(AsyncBlittableJsonTextWriter writer, IAsyncEnumerable`1<ShardStreamItem`1<Document>> results, JsonOperationContext context, PreviewState<ShardedDatabaseRequestHandler, ShardStreamItem`1<Document>> state);
    protected virtual PreviewState<ShardedDatabaseRequestHandler, ShardStreamItem`1<Document>> CreatePreviewState();
    protected virtual void WriteResult(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, ShardStreamItem`1<Document> result, PreviewState<ShardedDatabaseRequestHandler, ShardStreamItem`1<Document>> state);
    protected virtual void WriteMetadata(AsyncBlittableJsonTextWriter writer, JsonOperationContext context, Document document, BlittableJsonReaderObject metadata);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioCollectionsHandlerProcessorForPreviewCollection/<GetTotalResultsAsync>d__14")]
protected virtual ValueTask`1<long> GetTotalResultsAsync();
    protected virtual bool NotModified(String& etag);
    protected virtual IAsyncEnumerable`1<ShardStreamItem`1<Document>> GetDocumentsAsync();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioCollectionsHandlerProcessorForPreviewCollection/<GetAvailableColumnsAsync>d__17")]
protected virtual ValueTask`1<List`1<string>> GetAvailableColumnsAsync();
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__1(AsyncBlittableJsonTextWriter writer, IAsyncEnumerable`1<ShardStreamItem`1<Document>> results, JsonOperationContext context, PreviewState<ShardedDatabaseRequestHandler, ShardStreamItem`1<Document>> state);
}
internal class Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioDatabaseTasksHandlerProcessorForGetIndexDefaults : AbstractStudioDatabaseTasksHandlerProcessorForGetIndexDefaults`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStudioDatabaseTasksHandlerProcessorForGetIndexDefaults(ShardedDatabaseRequestHandler requestHandler);
    protected virtual RavenConfiguration GetDatabaseConfiguration();
}
internal class Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution : AbstractStudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution(ShardedDatabaseRequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioDatabaseTasksHandlerProcessorForGetSuggestConflictResolution/<GetSuggestConflictResolutionAsync>d__1")]
protected virtual Task GetSuggestConflictResolutionAsync(TransactionOperationContext context, string documentId);
}
internal class Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioDatabaseTasksHandlerProcessorForRestartDatabase : AbstractStudioDatabaseTasksHandlerProcessorForRestartDatabase`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsOptionalShardNumber { get; }
    public ShardedStudioDatabaseTasksHandlerProcessorForRestartDatabase(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsOptionalShardNumber();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<object> command, OperationCancelToken token);
}
internal class Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioIndexHandlerForPostIndexFields : AbstractStudioIndexHandlerForPostIndexFields`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    public ShardedStudioIndexHandlerForPostIndexFields(ShardedDatabaseRequestHandler requestHandler);
    protected virtual RavenConfiguration GetDatabaseConfiguration();
}
internal class Raven.Server.Web.Studio.Sharding.Processors.ShardedStudioIndexHandlerProcessorForGetIndexErrorsCount : AbstractStudioIndexHandlerProcessorForGetIndexErrorsCount`2<ShardedDatabaseRequestHandler, TransactionOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public ShardedStudioIndexHandlerProcessorForGetIndexErrorsCount(ShardedDatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<IndexErrorsCount[]> command, OperationCancelToken token);
}
public class Raven.Server.Web.Studio.Sharding.ShardedBucketsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedBucketsHandler/<GetBuckets>d__0")]
[RavenShardedActionAttribute("/databases/*/debug/sharding/buckets", "GET")]
public Task GetBuckets();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedBucketsHandler/<GetBucket>d__1")]
[RavenShardedActionAttribute("/databases/*/debug/sharding/bucket", "GET")]
public Task GetBucket();
}
public class Raven.Server.Web.Studio.Sharding.ShardedSqlMigrationHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedSqlMigrationHandler/<ImportFromCsv>d__0")]
[RavenShardedActionAttribute("/databases/*/smuggler/import/csv", "POST")]
public Task ImportFromCsv();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedSqlMigrationHandler/<ImportSql>d__1")]
[RavenShardedActionAttribute("/databases/*/admin/sql-migration/import", "POST")]
public Task ImportSql();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedSqlMigrationHandler/<TestSql>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/sql-migration/test", "POST")]
public Task TestSql();
}
public class Raven.Server.Web.Studio.Sharding.ShardedStudioCollectionsHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedStudioCollectionsHandler/<PreviewCollection>d__0")]
[RavenShardedActionAttribute("/databases/*/studio/collections/preview", "GET")]
public Task PreviewCollection();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedStudioCollectionsHandler/<Delete>d__1")]
[RavenShardedActionAttribute("/databases/*/studio/collections/docs", "DELETE")]
public Task Delete();
}
public class Raven.Server.Web.Studio.Sharding.ShardedStudioDatabaseTasksHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedStudioDatabaseTasksHandler/<GetFolderPathOptionsForDatabaseAdmin>d__0")]
[RavenShardedActionAttribute("/databases/*/admin/studio-tasks/folder-path-options", "POST")]
public Task GetFolderPathOptionsForDatabaseAdmin();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedStudioDatabaseTasksHandler/<GetIndexDefaults>d__1")]
[RavenShardedActionAttribute("/databases/*/studio-tasks/indexes/configuration/defaults", "GET")]
public Task GetIndexDefaults();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedStudioDatabaseTasksHandler/<RestartDatabase>d__2")]
[RavenShardedActionAttribute("/databases/*/admin/studio-tasks/restart", "POST")]
public Task RestartDatabase();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedStudioDatabaseTasksHandler/<SuggestConflictResolution>d__3")]
[RavenShardedActionAttribute("/databases/*/studio-tasks/suggest-conflict-resolution", "GET")]
public Task SuggestConflictResolution();
}
public class Raven.Server.Web.Studio.Sharding.ShardedStudioIndexHandler : ShardedDatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedStudioIndexHandler/<PreviewCollection>d__0")]
[RavenShardedActionAttribute("/databases/*/studio/indexes/errors-count", "GET")]
public Task PreviewCollection();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedStudioIndexHandler/<PostIndexType>d__1")]
[RavenShardedActionAttribute("/databases/*/studio/index-type", "POST")]
public Task PostIndexType();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.Sharding.ShardedStudioIndexHandler/<PostIndexFields>d__2")]
[RavenShardedActionAttribute("/databases/*/studio/index-fields", "POST")]
public Task PostIndexFields();
}
public class Raven.Server.Web.Studio.SingleNodeDataDirectoryResult : object {
    [CompilerGeneratedAttribute]
private string <NodeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FreeSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FreeSpaceHumane>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TotalSpaceHumane>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public string NodeTag { get; public set; }
    public string FullPath { get; public set; }
    public long FreeSpaceInBytes { get; public set; }
    public string FreeSpaceHumane { get; public set; }
    public long TotalSpaceInBytes { get; public set; }
    public string TotalSpaceHumane { get; public set; }
    public string Error { get; public set; }
    [CompilerGeneratedAttribute]
public string get_NodeTag();
    [CompilerGeneratedAttribute]
public void set_NodeTag(string value);
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
public void set_FullPath(string value);
    [CompilerGeneratedAttribute]
public long get_FreeSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_FreeSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public string get_FreeSpaceHumane();
    [CompilerGeneratedAttribute]
public void set_FreeSpaceHumane(string value);
    [CompilerGeneratedAttribute]
public long get_TotalSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_TotalSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public string get_TotalSpaceHumane();
    [CompilerGeneratedAttribute]
public void set_TotalSpaceHumane(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Web.Studio.SqlMigrationHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.SqlMigrationHandler/<SqlSchema>d__0")]
[RavenActionAttribute("/databases/*/admin/sql-migration/schema", "POST", "2", "False", "False", "True", "0")]
public Task SqlSchema();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.SqlMigrationHandler/<ImportSql>d__1")]
[RavenActionAttribute("/databases/*/admin/sql-migration/import", "POST", "2", "False", "False", "True", "0")]
public Task ImportSql();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.SqlMigrationHandler/<TestSql>d__2")]
[RavenActionAttribute("/databases/*/admin/sql-migration/test", "POST", "2", "False", "False", "True", "0")]
public Task TestSql();
}
public class Raven.Server.Web.Studio.StudioCollectionFieldsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioCollectionFieldsHandler/<GetCollectionFields>d__0")]
[RavenActionAttribute("/databases/*/studio/collections/fields", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetCollectionFields();
}
internal class Raven.Server.Web.Studio.StudioCollectionRunner : CollectionRunner {
    private HashSet`1<string> _excludeIds;
    public StudioCollectionRunner(DocumentDatabase database, DocumentsOperationContext context, HashSet`1<string> excludeIds);
    public virtual Task`1<IOperationResult> ExecuteDelete(string collectionName, long start, long take, CollectionOperationOptions options, Action`1<IOperationProgress> onProgress, OperationCancelToken token);
    [CompilerGeneratedAttribute]
private MergedTransactionCommand`2<DocumentsOperationContext, DocumentsTransaction> <ExecuteDelete>b__2_0(string key);
}
public class Raven.Server.Web.Studio.StudioCollectionsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioCollectionsHandler/<PreviewCollection>d__0")]
[RavenActionAttribute("/databases/*/studio/collections/preview", "GET", "3", "1", "False", "False", "True", "0")]
public Task PreviewCollection();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioCollectionsHandler/<Delete>d__1")]
[RavenActionAttribute("/databases/*/studio/collections/docs", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task Delete();
}
public class Raven.Server.Web.Studio.StudioDatabaseTasksHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioDatabaseTasksHandler/<GetFolderPathOptionsForDatabaseAdmin>d__0")]
[RavenActionAttribute("/databases/*/admin/studio-tasks/folder-path-options", "POST", "2", "False", "False", "True", "0")]
public Task GetFolderPathOptionsForDatabaseAdmin();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioDatabaseTasksHandler/<GetIndexDefaults>d__1")]
[RavenActionAttribute("/databases/*/studio-tasks/indexes/configuration/defaults", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetIndexDefaults();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioDatabaseTasksHandler/<RestartDatabase>d__2")]
[RavenActionAttribute("/databases/*/admin/studio-tasks/restart", "POST", "2", "False", "False", "True", "0")]
public Task RestartDatabase();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioDatabaseTasksHandler/<SuggestConflictResolution>d__3")]
[RavenActionAttribute("/databases/*/studio-tasks/suggest-conflict-resolution", "GET", "3", "1", "False", "False", "True", "0")]
public Task SuggestConflictResolution();
}
public class Raven.Server.Web.Studio.StudioFeedbackHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioFeedbackHandler/<Feedback>d__0")]
[RavenActionAttribute("/studio/feedback", "POST", "3", "1", "False", "False", "True", "0")]
public Task Feedback();
}
public class Raven.Server.Web.Studio.StudioIndexHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioIndexHandler/<GetIndexErrorsCount>d__0")]
[RavenActionAttribute("/databases/*/studio/indexes/errors-count", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetIndexErrorsCount();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioIndexHandler/<PostIndexType>d__1")]
[RavenActionAttribute("/databases/*/studio/index-type", "POST", "3", "1", "False", "False", "True", "0")]
public Task PostIndexType();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioIndexHandler/<PostIndexFields>d__2")]
[RavenActionAttribute("/databases/*/studio/index-fields", "POST", "3", "1", "False", "False", "True", "0")]
public Task PostIndexFields();
}
public class Raven.Server.Web.Studio.StudioStatsHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioStatsHandler/<GetFooterStats>d__0")]
[RavenActionAttribute("/databases/*/studio/footer/stats", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetFooterStats();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioStatsHandler/<GetLicenseLimitsUsage>d__1")]
[RavenActionAttribute("/databases/*/studio/license/limits-usage", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetLicenseLimitsUsage();
}
public class Raven.Server.Web.Studio.StudioTasksHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioTasksHandler/<FullDataDirectory>d__0")]
[RavenActionAttribute("/admin/studio-tasks/full-data-directory", "GET", "1", "False", "False", "True", "0")]
public Task FullDataDirectory();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioTasksHandler/<GetFolderPathOptionsForOperator>d__1")]
[RavenActionAttribute("/admin/studio-tasks/folder-path-options", "POST", "1", "False", "False", "True", "0")]
public Task GetFolderPathOptionsForOperator();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioTasksHandler/<OfflineMigrationTest>d__2")]
[RavenActionAttribute("/admin/studio-tasks/offline-migration-test", "GET", "1", "False", "False", "True", "0")]
public Task OfflineMigrationTest();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioTasksHandler/<TestPeriodicBackupCredentials>d__4")]
[RavenActionAttribute("/studio-tasks/periodic-backup/test-credentials", "POST", "3", "1", "False", "False", "True", "0")]
public Task TestPeriodicBackupCredentials();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioTasksHandler/<IsValidName>d__5")]
[RavenActionAttribute("/studio-tasks/is-valid-name", "GET", "3", "1", "False", "False", "True", "0")]
public Task IsValidName();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioTasksHandler/<HasMigratorPathInConfiguration>d__6")]
[RavenActionAttribute("/studio-tasks/admin/migrator-path", "GET", "1", "False", "False", "True", "0")]
public Task HasMigratorPathInConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioTasksHandler/<Bootstrap>d__7")]
[RavenActionAttribute("/studio-tasks/bootstrap", "GET", "3", "1", "False", "False", "True", "0")]
public Task Bootstrap();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioTasksHandler/<Format>d__8")]
[RavenActionAttribute("/studio-tasks/format", "POST", "3", "1", "False", "False", "True", "0")]
public Task Format();
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.StudioTasksHandler/<GetNextCronExpressionOccurrence>d__9")]
[RavenActionAttribute("/studio-tasks/next-cron-expression-occurrence", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetNextCronExpressionOccurrence();
}
public class Raven.Server.Web.Studio.UpgradeInfoHandler : ServerRequestHandler {
    private static string ErrorPropertyName;
    [AsyncStateMachineAttribute("Raven.Server.Web.Studio.UpgradeInfoHandler/<GetUpgradeInfo>d__1")]
[RavenActionAttribute("/studio/upgrade-info", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetUpgradeInfo();
}
public class Raven.Server.Web.System.AdminConfigurationHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminConfigurationHandler/<GetSettings>d__0")]
[RavenActionAttribute("/admin/configuration/settings", "GET", "0", "False", "False", "True", "0")]
public Task GetSettings();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminConfigurationHandler/<PutStudioConfiguration>d__1")]
[RavenActionAttribute("/admin/configuration/studio", "PUT", "1", "False", "False", "True", "0")]
public Task PutStudioConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminConfigurationHandler/<GetStudioConfiguration>d__2")]
[RavenActionAttribute("/configuration/studio", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetStudioConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminConfigurationHandler/<PutClientConfiguration>d__3")]
[RavenActionAttribute("/admin/configuration/client", "PUT", "1", "False", "False", "True", "0")]
public Task PutClientConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminConfigurationHandler/<GetClientConfiguration>d__4")]
[RavenActionAttribute("/configuration/client", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetClientConfiguration();
}
public class Raven.Server.Web.System.AdminCpuCreditsHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminCpuCreditsHandler/<UpdateCpuCredits>d__0")]
[RavenActionAttribute("/admin/cpu-credits", "POST", "0", "False", "False", "True", "0")]
public Task UpdateCpuCredits();
    [RavenActionAttribute("/admin/cpu-credits/sync", "POST", "0", "False", "False", "True", "0")]
public Task SyncCpuCredits();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminCpuCreditsHandler/<GetCpuCredits>d__2")]
[RavenActionAttribute("/debug/cpu-credits", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetCpuCredits();
}
public class Raven.Server.Web.System.AdminDatabasesHandler : ServerRequestHandler {
    private static Logger Logger;
    private static AdminDatabasesHandler();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<Get>d__1")]
[RavenActionAttribute("/admin/databases", "GET", "1", "False", "False", "True", "0")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<AddDatabaseNode>d__2")]
[RavenActionAttribute("/admin/databases/node", "PUT", "1", "False", "False", "True", "0")]
public Task AddDatabaseNode();
    public static bool NotUsingHttps(string url);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<Put>d__4")]
[RavenActionAttribute("/admin/databases", "PUT", "1", "False", "False", "True", "0")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<ProxyToLeaderIfNeeded>d__5")]
private Task`1<bool> ProxyToLeaderIfNeeded(JsonOperationContext context, DatabaseRecord databaseRecord, int replicationFactor, Nullable`1<long> index);
    private void RecreateIndexes(string databaseName, DatabaseRecord databaseRecord);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<CreateDatabase>d__7")]
private Task`1<ValueTuple`3<long, DatabaseTopology, List`1<string>>> CreateDatabase(string name, DatabaseRecord databaseRecord, TransactionOperationContext context, int replicationFactor, Nullable`1<long> index, string raftRequestId);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<Reorder>d__8")]
[RavenActionAttribute("/admin/databases/reorder", "POST", "1", "False", "False", "True", "0")]
public Task Reorder();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<GetRestorePoints>d__9")]
[RavenActionAttribute("/admin/restore/points", "POST", "1", "False", "False", "True", "0")]
public Task GetRestorePoints();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<RestoreDatabase>d__10")]
[RavenActionAttribute("/admin/restore/database", "POST", "1", "False", "False", "True", "0")]
public Task RestoreDatabase();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<DelayBackupTask>d__11")]
[RavenActionAttribute("/admin/backup-task/delay", "POST", "1", "False", "False", "True", "0")]
public Task DelayBackupTask();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<Delete>d__12")]
[RavenActionAttribute("/admin/databases", "DELETE", "1", "False", "False", "True", "0")]
public Task Delete();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<WaitForDeletionToComplete>d__13")]
private Task`1<long> WaitForDeletionToComplete(TransactionOperationContext context, Parameters parameters, long index, IList`1<string> waitOnDeletion);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<DisableDatabases>d__14")]
[RavenActionAttribute("/admin/databases/disable", "POST", "1", "False", "False", "True", "0")]
public Task DisableDatabases();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<EnableDatabases>d__15")]
[RavenActionAttribute("/admin/databases/enable", "POST", "1", "False", "False", "True", "0")]
public Task EnableDatabases();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<ToggleIndexing>d__16")]
[RavenActionAttribute("/admin/databases/indexing", "POST", "1", "False", "False", "True", "0")]
public Task ToggleIndexing();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<ToggleDynamicDatabaseDistribution>d__17")]
[RavenActionAttribute("/admin/databases/dynamic-node-distribution", "POST", "1", "False", "False", "True", "0")]
public Task ToggleDynamicDatabaseDistribution();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<ToggleDisableDatabases>d__18")]
private Task ToggleDisableDatabases(bool disable);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<PromoteImmediately>d__19")]
[RavenActionAttribute("/admin/databases/promote", "POST", "1", "False", "False", "True", "0")]
public Task PromoteImmediately();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<AdminConsole>d__20")]
[RavenActionAttribute("/admin/console", "POST", "0", "False", "False", "True", "0")]
public Task AdminConsole();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<UpdateConflictSolver>d__21")]
[RavenActionAttribute("/admin/replication/conflicts/solver", "POST", "3", "2", "False", "False", "True", "0")]
public Task UpdateConflictSolver();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<CompactDatabase>d__22")]
[RavenActionAttribute("/admin/compact", "POST", "1", "False", "False", "True", "0")]
public Task CompactDatabase();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<CalculateStorageSize>d__23")]
private Task`1<Size> CalculateStorageSize(string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<SetUnusedDatabaseIds>d__24")]
[RavenActionAttribute("/admin/databases/unused-ids", "POST", "1", "False", "False", "True", "0")]
public Task SetUnusedDatabaseIds();
    private static void ValidateDatabaseIdFormat(string id);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<ValidateUnusedIdsAsync>d__26")]
private Task ValidateUnusedIdsAsync(HashSet`1<string> unusedIds, string database, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<MigrateDatabases>d__27")]
[RavenActionAttribute("/admin/migrate", "POST", "1", "False", "False", "True", "0")]
public Task MigrateDatabases();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<MigrateDatabaseOffline>d__28")]
[RavenActionAttribute("/admin/migrate/offline", "POST", "1", "False", "False", "True", "0")]
public Task MigrateDatabaseOffline();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<SetLockMode>d__29")]
[RavenActionAttribute("/admin/databases/set-lock", "POST", "1", "False", "False", "True", "0")]
public Task SetLockMode();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDatabasesHandler/<ReadLineOrTimeout>d__30")]
private static Task`1<ValueTuple`2<bool, string>> ReadLineOrTimeout(Process process, Task timeout, OfflineMigrationConfiguration configuration, CancellationToken token);
}
public class Raven.Server.Web.System.AdminDebugQueryClauseCacheHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDebugQueryClauseCacheHandler/<QueryClauseCache>d__0")]
[RavenActionAttribute("/admin/indexes/lucene/query-clause-cache", "GET", "1", "False", "False", "True", "0")]
public Task QueryClauseCache();
    [IteratorStateMachineAttribute("Raven.Server.Web.System.AdminDebugQueryClauseCacheHandler/<GetEntriesForDebug>d__1")]
private IEnumerable`1<ValueTuple`2<QueryCacheKey, FastBitArray>> GetEntriesForDebug();
}
public class Raven.Server.Web.System.AdminDumpHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDumpHandler/<Dump>d__0")]
[RavenActionAttribute("/admin/debug/dump", "GET", "0", "False", "False", "True", "0")]
public Task Dump();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminDumpHandler/<GcDump>d__1")]
[RavenActionAttribute("/admin/debug/gcdump", "GET", "0", "False", "False", "True", "0")]
public Task GcDump();
    private static void Execute(string args, int processId, string output);
    private static void AssertOutputExists(string filePath, string ravenDebugExecPath, string ravenDebugExecOutput);
    private ValueTuple`2<string, string> GetFileNames(string extension);
}
public class Raven.Server.Web.System.AdminGcDebugHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminGcDebugHandler/<Allocations>d__0")]
[RavenActionAttribute("/admin/debug/memory/allocations", "GET", "1", "False", "False", "True", "0")]
public Task Allocations();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminGcDebugHandler/<GcEvents>d__1")]
[RavenActionAttribute("/admin/debug/memory/gc-events", "GET", "1", "False", "False", "True", "0")]
public Task GcEvents();
}
public class Raven.Server.Web.System.AdminIoMetricsHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminIoMetricsHandler/<IoMetrics>d__0")]
[RavenActionAttribute("/admin/debug/io-metrics", "GET", "1", "False", "False", "True", "0")]
public Task IoMetrics();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminIoMetricsHandler/<IoMetricsLive>d__1")]
[RavenActionAttribute("/admin/debug/io-metrics/live", "GET", "1", "False", "False", "True", "0")]
public Task IoMetricsLive();
    private static List`1<StorageEnvironmentWithType> GetSystemEnvironment(ServerStore serverStore);
}
public class Raven.Server.Web.System.AdminMetricsHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminMetricsHandler/<GetRootStats>d__0")]
[RavenActionAttribute("/admin/metrics", "GET", "1", "False", "False", "True", "0")]
public Task GetRootStats();
}
public class Raven.Server.Web.System.AdminMonitoringHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminMonitoringHandler/<MonitoringServer>d__0")]
[RavenActionAttribute("/admin/monitoring/v1/server", "GET", "1", "False", "False", "True", "0")]
public Task MonitoringServer();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminMonitoringHandler/<MonitoringDatabases>d__1")]
[RavenActionAttribute("/admin/monitoring/v1/databases", "GET", "1", "False", "False", "True", "0")]
public Task MonitoringDatabases();
    private List`1<DocumentDatabase> GetDatabases();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminMonitoringHandler/<MonitoringIndexes>d__3")]
[RavenActionAttribute("/admin/monitoring/v1/indexes", "GET", "1", "False", "False", "True", "0")]
public Task MonitoringIndexes();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminMonitoringHandler/<MonitoringCollections>d__4")]
[RavenActionAttribute("/admin/monitoring/v1/collections", "GET", "1", "False", "False", "True", "0")]
public Task MonitoringCollections();
}
public class Raven.Server.Web.System.AdminPrometheusMonitoringHandler : ServerRequestHandler {
    public static string PrometheusContentType;
    public static string MetricsPrefix;
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminPrometheusMonitoringHandler/<Metrics>d__3")]
[RavenActionAttribute("/admin/monitoring/v1/prometheus", "GET", "1", "False", "False", "True", "0")]
public Task Metrics();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminPrometheusMonitoringHandler/<WriteServerMetricsAsync>d__4")]
private Task WriteServerMetricsAsync(MetricsProvider provider, Stream responseStream);
    private static double KiloBytesToBytes(Nullable`1<long> input);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminPrometheusMonitoringHandler/<WriteDatabaseMetricsAsync>d__6")]
private Task WriteDatabaseMetricsAsync(MetricsProvider provider, List`1<DocumentDatabase> databases, Stream responseStream);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminPrometheusMonitoringHandler/<WriteIndexMetricsAsync>d__7")]
private Task WriteIndexMetricsAsync(MetricsProvider provider, List`1<DocumentDatabase> databases, Stream responseStream);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminPrometheusMonitoringHandler/<WriteCollectionMetricsAsync>d__8")]
private Task WriteCollectionMetricsAsync(List`1<DocumentDatabase> databases, Stream responseStream);
    private StreamWriter PrometheusWriter(MemoryStream ms);
    private void WriteGauges(StreamWriter writer, string help, string name, List`1<T> metrics, Func`2<T, Nullable`1<double>> valueExtractor, List`1<string> serializedTags);
    private void WriteCounters(StreamWriter writer, string help, string name, List`1<T> metrics, Func`2<T, long> valueExtractor, List`1<string> serializedTags);
    private string SerializeTags(Dictionary`2<string, string> input);
    private static string EscapeValue(string input);
    private List`1<DocumentDatabase> GetDatabases();
    private Dictionary`2<string, string> GetServerInfo(ServerMetrics serverMetrics);
    private void WriteHelpAndType(StreamWriter writer, string help, string name, MetricType metricType);
    private void WriteGauge(StreamWriter writer, string name, Nullable`1<double> value, string serializedTags);
    private void WriteCounter(StreamWriter writer, string name, long value, string serializedTags);
    private void WriteGaugeWithHelp(StreamWriter writer, string help, string name, Nullable`1<double> value, string serializedTags);
    private void WriteCounterWithHelp(StreamWriter writer, string help, string name, long value, string serializedTags);
    [CompilerGeneratedAttribute]
private string <WriteDatabaseMetricsAsync>b__6_0(DatabaseMetrics x);
}
public class Raven.Server.Web.System.AdminServerWideHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminServerWideHandler/<GetConfigurationServerWide>d__0")]
[RavenActionAttribute("/admin/configuration/server-wide", "GET", "0", "False", "False", "True", "0")]
public Task GetConfigurationServerWide();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminServerWideHandler/<PutServerWideBackupConfigurationCommand>d__1")]
[RavenActionAttribute("/admin/configuration/server-wide/backup", "PUT", "0", "False", "False", "True", "0")]
public Task PutServerWideBackupConfigurationCommand();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminServerWideHandler/<PutServerWideExternalReplicationCommand>d__2")]
[RavenActionAttribute("/admin/configuration/server-wide/external-replication", "PUT", "0", "False", "False", "True", "0")]
public Task PutServerWideExternalReplicationCommand();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminServerWideHandler/<DeleteServerWideBackupConfigurationCommand>d__3")]
[RavenActionAttribute("/admin/configuration/server-wide/backup", "DELETE", "0", "False", "False", "True", "0")]
public Task DeleteServerWideBackupConfigurationCommand();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminServerWideHandler/<DeleteServerWideTaskCommand>d__4")]
[RavenActionAttribute("/admin/configuration/server-wide/task", "DELETE", "0", "False", "False", "True", "0")]
public Task DeleteServerWideTaskCommand();
    [RavenActionAttribute("/admin/configuration/server-wide/backup", "GET", "0", "False", "False", "True", "0")]
public Task GetServerWideBackupConfigurations();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminServerWideHandler/<GetServerWideTasks>d__6")]
[RavenActionAttribute("/admin/configuration/server-wide/tasks", "GET", "0", "False", "False", "True", "0")]
public Task GetServerWideTasks();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminServerWideHandler/<ToggleServerWideTaskState>d__7")]
[RavenActionAttribute("/admin/configuration/server-wide/state", "POST", "0", "False", "False", "True", "0")]
public Task ToggleServerWideTaskState();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminServerWideHandler/<DeleteServerWideTaskCommand>d__8")]
private Task DeleteServerWideTaskCommand(OngoingTaskType taskType);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminServerWideHandler/<GetTaskConfigurationsAsync>d__9`1")]
private Task GetTaskConfigurationsAsync(OngoingTaskType type, Func`2<BlittableJsonReaderObject, T> converter);
}
public class Raven.Server.Web.System.AdminStatsHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminStatsHandler/<GetServerStatistics>d__0")]
[RavenActionAttribute("/admin/stats", "GET", "1", "False", "False", "True", "0")]
public Task GetServerStatistics();
}
public class Raven.Server.Web.System.AdminStorageHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminStorageHandler/<SystemEnvironmentReport>d__0")]
[RavenActionAttribute("/admin/debug/storage/environment/report", "GET", "1", "False", "False", "True", "0")]
public Task SystemEnvironmentReport();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminStorageHandler/<SystemScratchBufferPoolInfoReport>d__1")]
[RavenActionAttribute("/admin/debug/storage/environment/scratch-buffer-info", "GET", "1", "False", "False", "True", "0")]
public Task SystemScratchBufferPoolInfoReport();
}
public class Raven.Server.Web.System.AdminStudioServerWideHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminStudioServerWideHandler/<GetServerWideTasksForStudio>d__0")]
[RavenActionAttribute("/admin/server-wide/tasks", "GET", "0", "False", "False", "True", "0")]
public Task GetServerWideTasksForStudio();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminStudioServerWideHandler/<FullBackupDataDirectory>d__1")]
[RavenActionAttribute("/admin/server-wide/backup-data-directory", "GET", "0", "False", "False", "True", "0")]
public Task FullBackupDataDirectory();
}
public class Raven.Server.Web.System.AdminTcpConnectionDebugInfoHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminTcpConnectionDebugInfoHandler/<Statistics>d__0")]
[RavenActionAttribute("/admin/debug/info/tcp/stats", "GET", "1", "False", "False", "True", "0")]
public Task Statistics();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.AdminTcpConnectionDebugInfoHandler/<ActiveConnections>d__1")]
[RavenActionAttribute("/admin/debug/info/tcp/active-connections", "GET", "1", "False", "False", "True", "0")]
public Task ActiveConnections();
    [CompilerGeneratedAttribute]
internal static DynamicJsonValue <Statistics>g__ToDynamic|0_0(TcpStatistics stats);
    [CompilerGeneratedAttribute]
internal static DynamicJsonValue <ActiveConnections>g__ToDynamic|1_0(TcpConnectionInformation[] connections);
    [CompilerGeneratedAttribute]
internal static DynamicJsonArray <ActiveConnections>g__ToDynamicArray|1_1(IEnumerable`1<TcpConnectionInformation> connections);
}
public class Raven.Server.Web.System.Analyzers.AdminAnalyzersHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Analyzers.AdminAnalyzersHandler/<Put>d__0")]
[RavenActionAttribute("/admin/analyzers", "PUT", "1", "False", "False", "True", "0")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Analyzers.AdminAnalyzersHandler/<Delete>d__1")]
[RavenActionAttribute("/admin/analyzers", "DELETE", "1", "False", "False", "True", "0")]
public Task Delete();
}
public class Raven.Server.Web.System.Analyzers.AnalyzersHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Analyzers.AnalyzersHandler/<Get>d__0")]
[RavenActionAttribute("/analyzers", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
}
public class Raven.Server.Web.System.BackupDatabaseHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.BackupDatabaseHandler/<GetPeriodicBackup>d__0")]
[RavenActionAttribute("/periodic-backup", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetPeriodicBackup();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.BackupDatabaseHandler/<GetPeriodicBackupStatus>d__1")]
[RavenActionAttribute("/periodic-backup/status", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetPeriodicBackupStatus();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.BackupDatabaseHandler/<GetAllPeriodicBackupsTimers>d__2")]
[RavenActionAttribute("/admin/debug/periodic-backup/timers", "GET", "1", "False", "False", "True", "0")]
public Task GetAllPeriodicBackupsTimers();
}
public class Raven.Server.Web.System.BuildVersionHandler : ServerRequestHandler {
    private static Lazy`1<Byte[]> VersionBuffer;
    private static Nullable`1<DateTime> _lastRunAt;
    private static TimeSpan LatestVersionCheckThrottlePeriod;
    private static BuildVersionHandler();
    private static Byte[] GetVersionBuffer();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.BuildVersionHandler/<Get>d__3")]
[RavenActionAttribute("/build/version", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.BuildVersionHandler/<GetVersionUpdatesInfo>d__4")]
[RavenActionAttribute("/build/version/updates", "POST", "3", "1", "False", "False", "True", "0")]
public Task GetVersionUpdatesInfo();
    private static bool IsLatestVersionCheckThrottled();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.BuildVersionHandler/<WriteVersionUpdatesInfo>d__7")]
private Task WriteVersionUpdatesInfo();
}
internal class Raven.Server.Web.System.CompareExchangeHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.CompareExchangeHandler/<GetCompareExchangeValues>d__0")]
[RavenActionAttribute("/databases/*/cmpxchg", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetCompareExchangeValues();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.CompareExchangeHandler/<PutCompareExchangeValue>d__1")]
[RavenActionAttribute("/databases/*/cmpxchg", "PUT", "3", "2", "False", "False", "True", "0")]
public Task PutCompareExchangeValue();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.CompareExchangeHandler/<DeleteCompareExchangeValue>d__2")]
[RavenActionAttribute("/databases/*/cmpxchg", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task DeleteCompareExchangeValue();
}
public class Raven.Server.Web.System.ConfigurationNodeInfo : object {
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublicServerUrl>k__BackingField;
    public string Tag { get; public set; }
    public string ServerUrl { get; public set; }
    public string PublicServerUrl { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
public void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_PublicServerUrl();
    [CompilerGeneratedAttribute]
public void set_PublicServerUrl(string value);
}
public class Raven.Server.Web.System.CorsPreflightHandler : ServerRequestHandler {
    public Task HandlePreflightRequest();
}
public static class Raven.Server.Web.System.DatabaseHelper : object {
    private static Lazy`1<String[]> ServerWideOnlyConfigurationKeys;
    private static DatabaseHelper();
    public static String[] GetServerWideOnlyConfigurationKeys();
    public static void DeleteDatabaseFiles(RavenConfiguration configuration);
    public static void Validate(string name, DatabaseRecord record, RavenConfiguration serverConfiguration);
    public static void FillDatabaseTopology(ServerStore server, ClusterOperationContext context, string name, DatabaseRecord record, int replicationFactor, Nullable`1<long> index, bool isRestore);
    private static void ValidateClusterMembers(ServerStore server, ClusterTopology clusterTopology, DatabaseRecord databaseRecord);
    private static void SetReplicationFactor(DatabaseTopology databaseTopology, ClusterTopology clusterTopology, int replicationFactor);
    private static void InitializeDatabaseTopology(ServerStore server, DatabaseTopology databaseTopology, ClusterTopology clusterTopology, int replicationFactor, string clusterTransactionId);
    private static void InitializeDatabaseTopology(ServerStore server, DatabaseRecord databaseRecord, ClusterTopology clusterTopology, int replicationFactor);
}
public class Raven.Server.Web.System.DatabasesDebugHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.DatabasesDebugHandler/<Idle>d__0")]
[RavenActionAttribute("/admin/debug/databases/idle", "GET", "1", "False", "False", "True", "0")]
public Task Idle();
}
public class Raven.Server.Web.System.DatabasesHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.DatabasesHandler/<Databases>d__0")]
[RavenActionAttribute("/databases", "GET", "3", "1", "False", "False", "True", "0")]
public Task Databases();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.DatabasesHandler/<ModifyTopology>d__1")]
[RavenActionAttribute("/admin/databases/topology/modify", "POST", "1", "False", "False", "True", "0")]
public Task ModifyTopology();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.DatabasesHandler/<GetTopology>d__2")]
[RavenActionAttribute("/topology", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetTopology();
    private DynamicJsonValue TopologyNodeToJson(string tag, string url, string name, Role role, DetailsPerNode details);
    private void AlertIfDocumentStoreCreationRateIsNotReasonable(string applicationIdentifier, string name);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.DatabasesHandler/<IsDatabaseLoaded>d__5")]
[RavenActionAttribute("/debug/is-loaded", "GET", "3", "1", "False", "False", "True", "0")]
public Task IsDatabaseLoaded();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.DatabasesHandler/<GetRemoteServerBuildInfoWithDatabases>d__6")]
[RavenActionAttribute("/admin/remote-server/build/version", "GET", "1", "False", "False", "True", "0")]
public Task GetRemoteServerBuildInfoWithDatabases();
    private string GetUrl(string tag, ClusterTopology clusterTopology, bool usePrivate);
    [CompilerGeneratedAttribute]
private string <AlertIfDocumentStoreCreationRateIsNotReasonable>g__GetCertificateInfo|4_0();
}
public class Raven.Server.Web.System.DatabaseTcpConnectionInfoHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.DatabaseTcpConnectionInfoHandler/<Get>d__0")]
[RavenActionAttribute("/databases/*/info/tcp", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
}
public class Raven.Server.Web.System.DebugHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.DebugHandler/<Routes>d__0")]
[RavenActionAttribute("/debug/routes", "GET", "3", "1", "False", "False", "True", "0")]
public Task Routes();
}
public class Raven.Server.Web.System.EmptyMessageHandler : ServerRequestHandler {
    public static Lazy`1<Byte[]> LazyBuffer;
    private static EmptyMessageHandler();
    [RavenActionAttribute("/admin/test/empty-message", "GET", "1", "False", "False", "True", "0")]
public Task Get();
    [RavenActionAttribute("/admin/test/delay", "GET", "1", "False", "False", "True", "0")]
public Task Delay();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.EmptyMessageHandler/<GetBuffer>d__2")]
[RavenActionAttribute("/admin/test/sized-message", "GET", "1", "False", "False", "True", "0")]
public Task GetBuffer();
}
public static class Raven.Server.Web.System.EnumHelper : object {
    public static string GetDescription(Enum value);
}
public class Raven.Server.Web.System.LicenseInfo : object {
    [CompilerGeneratedAttribute]
private License <License>k__BackingField;
    public License License { get; public set; }
    [CompilerGeneratedAttribute]
public License get_License();
    [CompilerGeneratedAttribute]
public void set_License(License value);
}
public enum Raven.Server.Web.System.MetricType : Enum {
    public int value__;
    public static MetricType Counter;
    public static MetricType Gauge;
}
public class Raven.Server.Web.System.NodeConnectionTestResult : object {
    public bool Success;
    public bool HTTPSuccess;
    public string TcpServerUrl;
    public string Error;
    public List`1<string> Log;
    public sealed virtual DynamicJsonValue ToJson();
    public static string GetError(string source, string dest);
}
public class Raven.Server.Web.System.OngoingTasksHandler : DatabaseRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<GetOngoingTasks>d__0")]
[RavenActionAttribute("/databases/*/tasks", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetOngoingTasks();
    internal OngoingTaskPullReplicationAsHub GetPullReplicationAsHubTaskInfo(ClusterTopology clusterTopology, ExternalReplication ex);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<GetConfiguration>d__2")]
[RavenActionAttribute("/databases/*/admin/periodic-backup/config", "GET", "2", "False", "False", "True", "0")]
public Task GetConfiguration();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<GetPeriodicBackupTimers>d__3")]
[RavenActionAttribute("/databases/*/admin/debug/periodic-backup/timers", "GET", "2", "False", "False", "True", "0")]
public Task GetPeriodicBackupTimers();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<UpdatePeriodicBackup>d__4")]
[RavenActionAttribute("/databases/*/admin/periodic-backup", "POST", "2", "False", "False", "True", "0")]
public Task UpdatePeriodicBackup();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<FullBackupDataDirectory>d__5")]
[RavenActionAttribute("/databases/*/admin/backup-data-directory", "GET", "2", "False", "False", "True", "0")]
public Task FullBackupDataDirectory();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<BackupDatabase>d__6")]
[RavenActionAttribute("/databases/*/admin/backup/database", "POST", "2", "False", "False", "True", "0")]
public Task BackupDatabase();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<BackupDatabaseOnce>d__7")]
[RavenActionAttribute("/databases/*/admin/backup", "POST", "2", "False", "False", "True", "0")]
public Task BackupDatabaseOnce();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<RemoveConnectionString>d__8")]
[RavenActionAttribute("/databases/*/admin/connection-strings", "DELETE", "2", "False", "False", "True", "0")]
public Task RemoveConnectionString();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<GetConnectionStrings>d__9")]
[RavenActionAttribute("/databases/*/admin/connection-strings", "GET", "2", "False", "False", "True", "0")]
public Task GetConnectionStrings();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<PutConnectionString>d__10")]
[RavenActionAttribute("/databases/*/admin/connection-strings", "PUT", "2", "False", "False", "True", "0")]
public Task PutConnectionString();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<ResetEtl>d__11")]
[RavenActionAttribute("/databases/*/admin/etl", "RESET", "2", "False", "False", "True", "0")]
public Task ResetEtl();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<AddEtl>d__12")]
[RavenActionAttribute("/databases/*/admin/etl", "PUT", "2", "False", "False", "True", "0")]
public Task AddEtl();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<GetOngoingTaskInfo>d__13")]
[RavenActionAttribute("/databases/*/task", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetOngoingTaskInfo();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<GetHubTasksInfo>d__14")]
[RavenActionAttribute("/databases/*/tasks/pull-replication/hub", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetHubTasksInfo();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<ToggleSubscriptionTaskState>d__15")]
[RavenActionAttribute("/databases/*/subscription-tasks/state", "POST", "3", "2", "False", "False", "True", "0")]
public Task ToggleSubscriptionTaskState();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<ToggleTaskState>d__16")]
[RavenActionAttribute("/databases/*/admin/tasks/state", "POST", "2", "False", "False", "True", "0")]
public Task ToggleTaskState();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<UpdateExternalReplication>d__17")]
[RavenActionAttribute("/databases/*/admin/tasks/external-replication", "POST", "2", "False", "False", "True", "0")]
public Task UpdateExternalReplication();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<DeleteSubscriptionTask>d__18")]
[RavenActionAttribute("/databases/*/subscription-tasks", "DELETE", "3", "2", "False", "False", "True", "0")]
public Task DeleteSubscriptionTask();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<DeleteOngoingTask>d__19")]
[RavenActionAttribute("/databases/*/admin/tasks", "DELETE", "2", "False", "False", "True", "0")]
public Task DeleteOngoingTask();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.OngoingTasksHandler/<AddQueueSink>d__20")]
[RavenActionAttribute("/databases/*/admin/queue-sink", "PUT", "2", "False", "False", "True", "0")]
public Task AddQueueSink();
    internal static OngoingTaskState GetEtlTaskState(EtlConfiguration`1<T> config);
    internal static OngoingTaskState GetQueueSinkTaskState(QueueSinkConfiguration config);
}
public class Raven.Server.Web.System.OngoingTasksResult : object {
    [CompilerGeneratedAttribute]
private List`1<OngoingTask> <OngoingTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubscriptionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PullReplicationDefinition> <PullReplications>k__BackingField;
    public List`1<OngoingTask> OngoingTasks { get; public set; }
    public int SubscriptionsCount { get; public set; }
    public List`1<PullReplicationDefinition> PullReplications { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<OngoingTask> get_OngoingTasks();
    [CompilerGeneratedAttribute]
public void set_OngoingTasks(List`1<OngoingTask> value);
    [CompilerGeneratedAttribute]
public int get_SubscriptionsCount();
    [CompilerGeneratedAttribute]
public void set_SubscriptionsCount(int value);
    [CompilerGeneratedAttribute]
public List`1<PullReplicationDefinition> get_PullReplications();
    [CompilerGeneratedAttribute]
public void set_PullReplications(List`1<PullReplicationDefinition> value);
    public sealed virtual DynamicJsonValue ToJson();
}
internal class Raven.Server.Web.System.Processors.Backups.BackupDatabaseHandlerProcessorForGetPeriodicBackup : AbstractHandlerProcessor`1<RequestHandler> {
    public BackupDatabaseHandlerProcessorForGetPeriodicBackup(RequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.Backups.BackupDatabaseHandlerProcessorForGetPeriodicBackup/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Web.System.Processors.Backups.BackupDatabaseHandlerProcessorForGetPeriodicBackupStatus : AbstractHandlerProcessor`1<RequestHandler> {
    public BackupDatabaseHandlerProcessorForGetPeriodicBackupStatus(RequestHandler requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.Backups.BackupDatabaseHandlerProcessorForGetPeriodicBackupStatus/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal abstract class Raven.Server.Web.System.Processors.CompareExchange.AbstractCompareExchangeHandlerProcessorForGetCompareExchangeValues`2 : AbstractDatabaseHandlerProcessor`2<TRequestHandler, TOperationContext> {
    private AbstractCompareExchangeStorage _compareExchangeStorage;
    protected AbstractCompareExchangeHandlerProcessorForGetCompareExchangeValues`2(TRequestHandler requestHandler, AbstractCompareExchangeStorage compareExchangeStorage);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.CompareExchange.AbstractCompareExchangeHandlerProcessorForGetCompareExchangeValues`2/<ExecuteAsync>d__2")]
public virtual ValueTask ExecuteAsync();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.CompareExchange.AbstractCompareExchangeHandlerProcessorForGetCompareExchangeValues`2/<GetCompareExchangeValues>d__3")]
private Task GetCompareExchangeValues(ClusterOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.CompareExchange.AbstractCompareExchangeHandlerProcessorForGetCompareExchangeValues`2/<GetCompareExchangeValuesByKey>d__4")]
private Task GetCompareExchangeValuesByKey(ClusterOperationContext context, StringValues keys);
}
internal class Raven.Server.Web.System.Processors.CompareExchange.CompareExchangeHandlerProcessorForDeleteCompareExchangeValue`1 : AbstractDatabaseHandlerProcessor`1<TOperationContext> {
    public CompareExchangeHandlerProcessorForDeleteCompareExchangeValue`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.CompareExchange.CompareExchangeHandlerProcessorForDeleteCompareExchangeValue`1/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
}
internal class Raven.Server.Web.System.Processors.CompareExchange.CompareExchangeHandlerProcessorForGetCompareExchangeValues : AbstractCompareExchangeHandlerProcessorForGetCompareExchangeValues`2<DatabaseRequestHandler, DocumentsOperationContext> {
    public CompareExchangeHandlerProcessorForGetCompareExchangeValues(DatabaseRequestHandler requestHandler);
}
public class Raven.Server.Web.System.Processors.CompareExchange.CompareExchangeHandlerProcessorForPutCompareExchangeValue : object {
    private RequestHandler _requestHandler;
    private string _databaseName;
    public CompareExchangeHandlerProcessorForPutCompareExchangeValue(RequestHandler requestHandler, string databaseName);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.CompareExchange.CompareExchangeHandlerProcessorForPutCompareExchangeValue/<ExecuteAsync>d__3")]
public ValueTask ExecuteAsync();
    public sealed virtual void Dispose();
}
internal abstract class Raven.Server.Web.System.Processors.Databases.AbstractDatabasesHandlerProcessorForAllowedDatabases`1 : AbstractServerHandlerProxyReadProcessor`1<TResult> {
    protected bool SupportsCurrentNode { get; }
    protected AbstractDatabasesHandlerProcessorForAllowedDatabases`1(RequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    protected string GetName();
    protected int GetStart();
    protected int GetPageSize();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<TResult> command, JsonOperationContext context, OperationCancelToken token);
    protected static BackupInfo GetBackupInfo(string databaseName, RawDatabaseRecord record, DocumentDatabase database, ServerStore serverStore, ClusterOperationContext context);
    protected static Nullable`1<TimeSpan> GetUpTime(DocumentDatabase database);
    protected static Nullable`1<IndexRunningStatus> GetIndexingStatus(RawDatabaseRecord record, DocumentDatabase database);
    protected static StudioEnvironment GetStudioEnvironment(RawDatabaseRecord record);
    [AsyncIteratorStateMachineAttribute("Raven.Server.Web.System.Processors.Databases.AbstractDatabasesHandlerProcessorForAllowedDatabases`1/<GetAllowedDatabaseRecordsAsync>d__11")]
protected IAsyncEnumerable`1<RawDatabaseRecord> GetAllowedDatabaseRecordsAsync(string name, ClusterOperationContext context, int start, int pageSize);
}
internal class Raven.Server.Web.System.Processors.Databases.AdminDatabasesHandlerProcessorForGetDatabaseRecord : AbstractHandlerProcessorForGetDatabaseRecord`1<ServerRequestHandler> {
    protected string DatabaseName { get; }
    public AdminDatabasesHandlerProcessorForGetDatabaseRecord(ServerRequestHandler requestHandler);
    protected virtual string get_DatabaseName();
}
internal class Raven.Server.Web.System.Processors.Databases.DatabasesHandlerProcessorForGet : AbstractDatabasesHandlerProcessorForAllowedDatabases`1<DatabasesInfo> {
    private static Logger Logger;
    public DatabasesHandlerProcessorForGet(RequestHandler requestHandler);
    private static DatabasesHandlerProcessorForGet();
    private bool GetNamesOnly();
    protected virtual ValueTask`1<RavenCommand`1<DatabasesInfo>> CreateCommandForNodeAsync(string nodeTag, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.Databases.DatabasesHandlerProcessorForGet/<HandleCurrentNodeAsync>d__4")]
protected virtual ValueTask HandleCurrentNodeAsync();
    internal static void FillNodesTopology(NodesTopology& nodesTopology, DatabaseTopology topology, RawDatabaseRecord databaseRecord, ClusterOperationContext context, ServerStore serverStore, HttpContext httpContext);
    private void WriteDatabaseInfo(string databaseName, RawDatabaseRecord rawDatabaseRecord, ClusterOperationContext context, AbstractBlittableJsonTextWriter writer);
    private static void SetNodeStatus(DatabaseTopology topology, string nodeTag, NodesTopology nodesTopology, Dictionary`2<string, NodeStatus> nodeStatuses);
    private static InternalReplication GetNode(string databaseName, ClusterTopology clusterTopology, string rehab, string mentor, PromotableTask& promotableTask);
    private static void WriteFaultedDatabaseInfo(string databaseName, NodesTopology nodesTopology, Exception exception, JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    private static NodeId GetNodeId(InternalReplication node, string responsible);
}
internal class Raven.Server.Web.System.Processors.Databases.DatabasesHandlerProcessorForGetRestorePoints : AbstractServerHandlerProxyReadProcessor`1<RestorePoints> {
    protected bool SupportsCurrentNode { get; }
    public DatabasesHandlerProcessorForGetRestorePoints(RequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    private PeriodicBackupConnectionType GetPeriodicBackupConnectionType();
    private ValueTask`1<BlittableJsonReaderObject> GetSettingsAsync(JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.Databases.DatabasesHandlerProcessorForGetRestorePoints/<CreateCommandForNodeAsync>d__5")]
protected virtual ValueTask`1<RavenCommand`1<RestorePoints>> CreateCommandForNodeAsync(string nodeTag, JsonOperationContext context);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.Databases.DatabasesHandlerProcessorForGetRestorePoints/<HandleCurrentNodeAsync>d__6")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<RestorePoints> command, JsonOperationContext context, OperationCancelToken token);
    private RestorePointsBase GetRestorePointsSource(TransactionOperationContext context, PeriodicBackupConnectionType connectionType, BlittableJsonReaderObject settings, String& path, CancellationToken token);
}
internal abstract class Raven.Server.Web.System.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForGetOngoingTask`3 : AbstractHandlerProxyReadProcessor`3<OngoingTask, TRequestHandler, TOperationContext> {
    private AbstractOngoingTasks`1<TSubscriptionConnectionsState> _ongoingTasks;
    protected bool SupportsCurrentNode { get; }
    protected AbstractOngoingTasksHandlerProcessorForGetOngoingTask`3(TRequestHandler requestHandler, AbstractOngoingTasks`1<TSubscriptionConnectionsState> ongoingTasks);
    protected virtual bool get_SupportsCurrentNode();
    protected Nullable`1<long> GetTaskId();
    protected string GetTaskName(Nullable`1<long> taskId);
    protected OngoingTaskType GetTaskType();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForGetOngoingTask`3/<HandleCurrentNodeAsync>d__7")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual RavenCommand`1<OngoingTask> CreateCommandForNode(string nodeTag);
}
internal abstract class Raven.Server.Web.System.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForGetOngoingTasks`3 : AbstractHandlerProxyReadProcessor`3<OngoingTasksResult, TRequestHandler, TOperationContext> {
    private AbstractOngoingTasks`1<TSubscriptionConnectionsState> _ongoingTasks;
    protected bool SupportsCurrentNode { get; }
    protected long SubscriptionsCount { get; }
    protected AbstractOngoingTasksHandlerProcessorForGetOngoingTasks`3(TRequestHandler requestHandler, AbstractOngoingTasks`1<TSubscriptionConnectionsState> ongoingTasks);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForGetOngoingTasks`3/<HandleCurrentNodeAsync>d__4")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual RavenCommand`1<OngoingTasksResult> CreateCommandForNode(string nodeTag);
    protected abstract virtual long get_SubscriptionsCount();
    public OngoingTasksResult GetOngoingTasksInternal();
}
internal abstract class Raven.Server.Web.System.Processors.OngoingTasks.AbstractOngoingTasksHandlerProcessorForGetPeriodicBackupTimers`2 : AbstractHandlerProxyReadProcessor`3<PeriodicBackupTimersResponse, TRequestHandler, TOperationContext> {
    protected AbstractOngoingTasksHandlerProcessorForGetPeriodicBackupTimers`2(TRequestHandler requestHandler);
    protected virtual RavenCommand`1<PeriodicBackupTimersResponse> CreateCommandForNode(string nodeTag);
}
internal class Raven.Server.Web.System.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetOngoingTask : AbstractOngoingTasksHandlerProcessorForGetOngoingTask`3<DatabaseRequestHandler, DocumentsOperationContext, SubscriptionConnectionsState> {
    public OngoingTasksHandlerProcessorForGetOngoingTask(DatabaseRequestHandler requestHandler);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<OngoingTask> command, OperationCancelToken token);
}
internal class Raven.Server.Web.System.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetOngoingTasks : AbstractOngoingTasksHandlerProcessorForGetOngoingTasks`3<DatabaseRequestHandler, DocumentsOperationContext, SubscriptionConnectionsState> {
    protected long SubscriptionsCount { get; }
    public OngoingTasksHandlerProcessorForGetOngoingTasks(DatabaseRequestHandler requestHandler);
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<OngoingTasksResult> command, OperationCancelToken token);
    protected virtual long get_SubscriptionsCount();
}
internal class Raven.Server.Web.System.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetPeriodicBackupTimers : AbstractOngoingTasksHandlerProcessorForGetPeriodicBackupTimers`2<DatabaseRequestHandler, DocumentsOperationContext> {
    protected bool SupportsCurrentNode { get; }
    public OngoingTasksHandlerProcessorForGetPeriodicBackupTimers(DatabaseRequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.OngoingTasks.OngoingTasksHandlerProcessorForGetPeriodicBackupTimers/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<PeriodicBackupTimersResponse> command, OperationCancelToken token);
}
internal class Raven.Server.Web.System.Processors.Stats.AdminStatsHandlerProcessorForGetServerStatistics : AbstractServerHandlerProxyReadProcessor`1<ServerStatistics> {
    protected bool SupportsCurrentNode { get; }
    public AdminStatsHandlerProcessorForGetServerStatistics(RequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.Stats.AdminStatsHandlerProcessorForGetServerStatistics/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual Task HandleRemoteNodeAsync(ProxyCommand`1<ServerStatistics> command, JsonOperationContext context, OperationCancelToken token);
    protected virtual ValueTask`1<RavenCommand`1<ServerStatistics>> CreateCommandForNodeAsync(string nodeTag, JsonOperationContext context);
}
internal class Raven.Server.Web.System.Processors.Studio.StudioDatabasesHandlerForGetDatabases : AbstractDatabasesHandlerProcessorForAllowedDatabases`1<StudioDatabasesInfo> {
    protected bool SupportsCurrentNode { get; }
    public StudioDatabasesHandlerForGetDatabases(RequestHandler requestHandler);
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.Studio.StudioDatabasesHandlerForGetDatabases/<HandleCurrentNodeAsync>d__3")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual ValueTask`1<RavenCommand`1<StudioDatabasesInfo>> CreateCommandForNodeAsync(string nodeTag, JsonOperationContext context);
    private void WriteStudioDatabaseInfo(RawDatabaseRecord record, ClusterOperationContext context, AbstractBlittableJsonTextWriter writer);
}
internal class Raven.Server.Web.System.Processors.Studio.StudioDatabasesHandlerForGetDatabasesState : AbstractDatabasesHandlerProcessorForAllowedDatabases`1<StudioDatabasesState> {
    private static Logger Logger;
    protected bool SupportsCurrentNode { get; }
    public StudioDatabasesHandlerForGetDatabasesState(RequestHandler requestHandler);
    private static StudioDatabasesHandlerForGetDatabasesState();
    protected virtual bool get_SupportsCurrentNode();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.Studio.StudioDatabasesHandlerForGetDatabasesState/<HandleCurrentNodeAsync>d__4")]
protected virtual ValueTask HandleCurrentNodeAsync();
    protected virtual ValueTask`1<RavenCommand`1<StudioDatabasesState>> CreateCommandForNodeAsync(string nodeTag, JsonOperationContext context);
    [IteratorStateMachineAttribute("Raven.Server.Web.System.Processors.Studio.StudioDatabasesHandlerForGetDatabasesState/<GetOrchestrators>d__6")]
private static IEnumerable`1<RawDatabaseRecord> GetOrchestrators(List`1<RawDatabaseRecord> records, string nodeTag);
    private void WriteStudioOrchestratorState(string databaseName, JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    private void WriteStudioDatabaseState(string databaseName, RawDatabaseRecord record, ClusterOperationContext context, AbstractBlittableJsonTextWriter writer);
    private static void WriteFaultedDatabaseState(string databaseName, Exception exception, JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    private static void WriteFaultedOrchestratorState(string databaseName, Exception exception, JsonOperationContext context, AbstractBlittableJsonTextWriter writer);
    [CompilerGeneratedAttribute]
private IEnumerable`1<RawDatabaseRecord> <HandleCurrentNodeAsync>b__4_1(RawDatabaseRecord x);
}
internal class Raven.Server.Web.System.Processors.Tcp.DatabaseTcpConnectionInfoHandlerProcessorForGet`1 : AbstractDatabaseHandlerProcessor`1<TOperationContext> {
    public DatabaseTcpConnectionInfoHandlerProcessorForGet`1(AbstractDatabaseRequestHandler`1<TOperationContext> requestHandler);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Processors.Tcp.DatabaseTcpConnectionInfoHandlerProcessorForGet`1/<ExecuteAsync>d__1")]
public virtual ValueTask ExecuteAsync();
    private bool CanConnectViaPublicClusterTcpUrl();
}
public class Raven.Server.Web.System.ServerWideTasksResult`1 : object {
    public List`1<T> Results;
    public sealed virtual DynamicJsonValue ToJson();
}
public class Raven.Server.Web.System.SetupHandler : ServerRequestHandler {
    private static string GeneralDomainRegistrationError;
    private static string DomainRegistrationServiceUnreachableError;
    private static SetupHandler();
    [RavenActionAttribute("/setup/alive", "GET", "4", "False", "False", "True", "0")]
public Task ServerAlive();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<DnsCertBridge>d__1")]
[RavenActionAttribute("/setup/dns-n-cert", "POST", "4", "False", "False", "True", "0")]
public Task DnsCertBridge();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<UserDomains>d__2")]
[RavenActionAttribute("/setup/user-domains", "POST", "4", "False", "False", "True", "0")]
public Task UserDomains();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<PopulateIps>d__3")]
[RavenActionAttribute("/setup/populate-ips", "POST", "4", "False", "False", "True", "0")]
public Task PopulateIps();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<GetSetupParameters>d__4")]
[RavenActionAttribute("/setup/parameters", "GET", "4", "False", "False", "True", "0")]
public Task GetSetupParameters();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<GetIps>d__5")]
[RavenActionAttribute("/setup/ips", "GET", "4", "False", "False", "True", "0")]
public Task GetIps();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<GetHosts>d__6")]
[RavenActionAttribute("/setup/hosts", "POST", "4", "False", "False", "True", "0")]
public Task GetHosts();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<SetupUnsecuredPackage>d__7")]
[RavenActionAttribute("/setup/unsecured/package", "POST", "4", "False", "False", "True", "0")]
public Task SetupUnsecuredPackage();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<SetupSecured>d__8")]
[RavenActionAttribute("/setup/secured", "POST", "4", "False", "False", "True", "0")]
public Task SetupSecured();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<SetupAgreement>d__9")]
[RavenActionAttribute("/setup/letsencrypt/agreement", "GET", "4", "False", "False", "True", "0")]
public Task SetupAgreement();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<SetupLetsEncrypt>d__10")]
[RavenActionAttribute("/setup/letsencrypt", "POST", "4", "False", "False", "True", "0")]
public Task SetupLetsEncrypt();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<ExtractInfoFromZip>d__11")]
[RavenActionAttribute("/setup/continue/extract", "POST", "4", "False", "False", "True", "0")]
public Task ExtractInfoFromZip();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<ContinueUnsecuredClusterSetup>d__12")]
[RavenActionAttribute("/setup/continue/unsecured", "POST", "4", "False", "False", "True", "0")]
public Task ContinueUnsecuredClusterSetup();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.SetupHandler/<ContinueClusterSetup>d__13")]
[RavenActionAttribute("/setup/continue", "POST", "4", "False", "False", "True", "0")]
public Task ContinueClusterSetup();
    [RavenActionAttribute("/setup/finish", "POST", "4", "False", "False", "True", "0")]
public Task SetupFinish();
    private void AssertOnlyInSetupMode();
}
public class Raven.Server.Web.System.ShardedAdminDatabaseHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.ShardedAdminDatabaseHandler/<AddNodeToOrchestratorTopology>d__0")]
[RavenActionAttribute("/admin/databases/orchestrator", "PUT", "1", "False", "False", "True", "0")]
public Task AddNodeToOrchestratorTopology();
    private static string FindFitNodeForDatabase(string databaseName, DatabaseTopology topology, bool isEncrypted, ClusterTopology clusterTopology, Dictionary`2<string, int> nodeToInstanceCount);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.ShardedAdminDatabaseHandler/<Delete>d__2")]
[RavenActionAttribute("/admin/databases/orchestrator", "DELETE", "1", "False", "False", "True", "0")]
public Task Delete();
    public static void AssertNotAShardDatabaseName(string name);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.ShardedAdminDatabaseHandler/<CreateNewShard>d__4")]
[RavenActionAttribute("/admin/databases/shard", "PUT", "1", "False", "False", "True", "0")]
public Task CreateNewShard();
    private int GetMaxShardNumber(RawShardingConfiguration config);
}
public class Raven.Server.Web.System.Sorters.AdminSortersHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Sorters.AdminSortersHandler/<Put>d__0")]
[RavenActionAttribute("/admin/sorters", "PUT", "1", "False", "False", "True", "0")]
public Task Put();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Sorters.AdminSortersHandler/<Delete>d__1")]
[RavenActionAttribute("/admin/sorters", "DELETE", "1", "False", "False", "True", "0")]
public Task Delete();
}
public class Raven.Server.Web.System.Sorters.SortersHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.Sorters.SortersHandler/<Get>d__0")]
[RavenActionAttribute("/sorters", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
}
public class Raven.Server.Web.System.StudioDatabasesHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.StudioDatabasesHandler/<Databases>d__0")]
[RavenActionAttribute("/studio-tasks/databases", "GET", "3", "1", "False", "False", "True", "0")]
public Task Databases();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.StudioDatabasesHandler/<GetDatabasesState>d__1")]
[RavenActionAttribute("/studio-tasks/databases/state", "GET", "3", "1", "False", "False", "True", "0")]
public Task GetDatabasesState();
}
public class Raven.Server.Web.System.StudioHandler : ServerRequestHandler {
    private static int PendingEntriesToProcess;
    private static ConcurrentDictionary`2<string, Lazy`1<CachedStaticFile>> StaticContentCache;
    private static ConcurrentQueue`1<string> EntriesToCompress;
    private static int _pendingEntriesToCompress;
    private static MultipleUseFlag CacheProcessingHappening;
    private static int BufferSize;
    private static FileSystemWatcher _fileWatcher;
    private static FileSystemWatcher _zipFileWatcher;
    public static string ZipFileName;
    private static string DefaultHstsValue;
    private static IList`1<string> HstsExcludedHosts;
    private static string _zipFilePath;
    private static long _zipFileLastChangeTicks;
    private static string ETagZipFileSource;
    private static string ETagFileSystemFileSource;
    private static ConcurrentSet`1<string> ZipFileEntries;
    private static MultipleUseFlag ZipFileProcessingHappening;
    private static MultipleUseFlag ZipFileInitialized;
    private static String[] ExtensionsToSkipCompression;
    private static Dictionary`2<string, string> FileExtensionToContentTypeMapping;
    private static Task _loadingFileToCache;
    private static String[] FileSystemLookupPaths;
    private static StudioHandler();
    private static Byte[] CompressFile(Byte[] rawMemory, CompressionLevel level);
    private static bool ShouldSkipCache(FileInfo file);
    private static bool ShouldSkipCompression(string filePath);
    [RavenActionAttribute("/favicon.ico", "GET", "4", "False", "False", "True", "0")]
public Task FavIcon();
    [RavenActionAttribute("/auth-error.html", "GET", "4", "False", "False", "True", "0")]
public Task StudioAuthError();
    [RavenActionAttribute("/eula/index.html", "GET", "4", "False", "False", "True", "0")]
public Task GetEulaIndexFile();
    [RavenActionAttribute("/eula/$", "GET", "4", "False", "False", "True", "0")]
public Task GetEulaFile();
    [RavenActionAttribute("/2fa/index.html", "GET", "4", "False", "False", "True", "0")]
public Task GetTwoFactorIndexFile();
    [RavenActionAttribute("/2fa/$", "GET", "4", "False", "False", "True", "0")]
public Task GetTwoFactorFile();
    [RavenActionAttribute("/wizard/index.html", "GET", "4", "False", "False", "True", "0")]
public Task GetSetupIndexFile();
    [RavenActionAttribute("/wizard/$", "GET", "4", "False", "False", "True", "0")]
public Task GetSetupFile();
    [RavenActionAttribute("/studio/index.html", "GET", "4", "False", "False", "True", "0")]
public Task GetStudioIndexFile();
    [RavenActionAttribute("/studio/$", "GET", "4", "False", "False", "True", "0")]
public Task GetStudioFile();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.StudioHandler/<GetStudioFileInternal>d__35")]
private Task GetStudioFileInternal(string serverRelativeFileName);
    private void SetupSecurityHeaders();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.StudioHandler/<LoadFilesIntoCache>d__37")]
private Task LoadFilesIntoCache();
    private void CacheCompress();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.StudioHandler/<ServeFromCache>d__39")]
private Task`1<bool> ServeFromCache(string serverRelativeFileName);
    private static CachedStaticFile BuildForCache(string cacheKey, string eTag, FileInfo fileInfo, Stream inputStream);
    private void AddPathsToCache(string basePath);
    private void ClearCache();
    private static void StartFileSystemWatcher(FileSystemWatcher watcher, FileSystemEventHandler createChangeDeleteHandler, RenamedEventHandler renameHandler);
    private bool ParseETag(String& hierarchyTag, Int64& fileVersion);
    private string GenerateETagFor(string hierarchyTag, int resourceId, long fileVersion);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.StudioHandler/<ServeFromZipFile>d__47")]
private Task`1<bool> ServeFromZipFile(string reportedBasePath, string serverRelativeFileName);
    private static void InitializeZipFileServing(string reportedBasePath);
    private static void ZipFileChangedEventHandler(object sender, FileSystemEventArgs e);
    private static void ReprocessZipFile();
    private static void UpdateZipFileLastChange();
    [RavenActionAttribute("/", "GET", "4", "False", "False", "True", "0")]
public Task RavenRoot();
    [CompilerGeneratedAttribute]
private void <GetStudioFileInternal>b__35_0();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <AddPathsToCache>b__41_0(object _, FileSystemEventArgs __);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <AddPathsToCache>b__41_1(object _, RenamedEventArgs __);
}
public class Raven.Server.Web.System.TcpConnectionInfoHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.TcpConnectionInfoHandler/<Get>d__0")]
[RavenActionAttribute("/info/tcp", "GET", "3", "1", "False", "False", "True", "0")]
public Task Get();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.TcpConnectionInfoHandler/<GetRemoteTaskTopology>d__1")]
[RavenActionAttribute("/info/remote-task/topology", "GET", "5", "False", "False", "True", "0")]
public Task GetRemoteTaskTopology();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.TcpConnectionInfoHandler/<GetRemoteTaskTcp>d__2")]
[RavenActionAttribute("/info/remote-task/tcp", "GET", "5", "False", "False", "True", "0")]
public Task GetRemoteTaskTcp();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.TcpConnectionInfoHandler/<AuthenticateAsync>d__3")]
public static ValueTask`1<bool> AuthenticateAsync(HttpContext httpContext, ServerStore serverStore, string database, string remoteTask);
    private List`1<string> GetResponsibleNodes(DatabaseTopology topology, string databaseGroupId, string mentorNode, bool pinToMentorNode);
}
public class Raven.Server.Web.System.TestConnectionHandler : ServerRequestHandler {
    [AsyncStateMachineAttribute("Raven.Server.Web.System.TestConnectionHandler/<TestConnection>d__0")]
[RavenActionAttribute("/admin/test-connection", "POST", "1", "False", "False", "True", "0")]
public Task TestConnection();
    [AsyncStateMachineAttribute("Raven.Server.Web.System.TestConnectionHandler/<ConnectToClientNodeAsync>d__1")]
public static Task ConnectToClientNodeAsync(RavenServer server, TcpConnectionInfo tcpConnectionInfo, TimeSpan timeout, Logger log, string database, NodeConnectionTestResult result, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Server.Web.System.TestConnectionHandler/<WriteOperationHeaderToRemote>d__2")]
private static ValueTask WriteOperationHeaderToRemote(AsyncBlittableJsonTextWriter writer, OperationTypes operation, string databaseName, string destinationServerId);
}
public class Raven.Server.Web.System.TestNodeConnectionCommand : RavenCommand`1<NodeConnectionTestResult> {
    private string _url;
    private string _database;
    private bool _bidirectional;
    public bool IsReadRequest { get; }
    public TestNodeConnectionCommand(string destination, string database, bool bidirectional);
    public virtual HttpRequestMessage CreateRequest(JsonOperationContext ctx, ServerNode node, String& url);
    public virtual void SetResponse(JsonOperationContext context, BlittableJsonReaderObject response, bool fromCache);
    public virtual bool get_IsReadRequest();
}
public static class Raven.Server.Web.System.UrlHelper : object {
    public static string TryGetLeftPart(string originalUrl);
}
