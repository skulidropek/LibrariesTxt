[ExtensionAttribute]
public static class Lextm.SharpSnmpLib.ByteTool : object {
    public static Byte[] ConvertDecimal(string description);
    public static Byte[] Convert(IEnumerable`1<char> description);
    public static string Convert(Byte[] buffer);
    internal static Byte[] ParseItems(ISnmpData item1, ISnmpData item2, ISnmpData item3, ISnmpData item4);
    internal static Byte[] ParseItems(ISnmpData item1, ISnmpData item2, ISnmpData item3, ISnmpData item4, ISnmpData item5, ISnmpData item6);
    internal static Byte[] ParseItems(IEnumerable`1<ISnmpData> items);
    internal static Byte[] GetRawBytes(IEnumerable`1<byte> orig, bool negative);
    public static Sequence PackMessage(Byte[] length, VersionCode version, ISegment header, ISegment parameters, ISnmpData data);
    [ExtensionAttribute]
internal static Byte[] WritePayloadLength(int length);
    [CompilerGeneratedAttribute]
internal static void <ParseItems>g__AppendBytesTo|3_0(ISnmpData item, MemoryStream result);
    [CompilerGeneratedAttribute]
internal static void <ParseItems>g__AppendBytesTo|4_0(ISnmpData item, MemoryStream result);
}
public class Lextm.SharpSnmpLib.Counter32 : object {
    private UInt32 _count;
    private Byte[] _length;
    private Byte[] _raw;
    public SnmpType TypeCode { get; }
    internal Counter32(Byte[] raw);
    [CLSCompliantAttribute("False")]
public Counter32(UInt32 value);
    public Counter32(long value);
    public Counter32(Tuple`2<int, Byte[]> length, Stream stream);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32();
    public virtual string ToString();
    internal Byte[] GetRaw();
    public sealed virtual bool Equals(Counter32 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Counter32 left, Counter32 right);
    public static bool op_Inequality(Counter32 left, Counter32 right);
    private static bool Equals(Counter32 left, Counter32 right);
    internal Byte[] GetLengthBytes();
}
public class Lextm.SharpSnmpLib.Counter64 : object {
    private ulong _count;
    private Byte[] _length;
    private Byte[] _raw;
    public SnmpType TypeCode { get; }
    internal Counter64(Byte[] raw);
    [CLSCompliantAttribute("False")]
public Counter64(ulong value);
    public Counter64(Tuple`2<int, Byte[]> length, Stream stream);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    [CLSCompliantAttribute("False")]
public ulong ToUInt64();
    public virtual string ToString();
    private Byte[] GetRaw();
    public sealed virtual bool Equals(Counter64 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Counter64 left, Counter64 right);
    public static bool op_Inequality(Counter64 left, Counter64 right);
    private static bool Equals(Counter64 left, Counter64 right);
}
public static class Lextm.SharpSnmpLib.DataFactory : object {
    public static ISnmpData CreateSnmpData(Byte[] buffer);
    public static ISnmpData CreateSnmpData(int type, Stream stream);
    public static ISnmpData CreateSnmpData(Byte[] buffer, int index, int count);
    public static ISnmpData CreateSnmpData(Stream stream);
}
public class Lextm.SharpSnmpLib.EndOfMibView : object {
    private Byte[] _length;
    public SnmpType TypeCode { get; }
    public EndOfMibView(Tuple`2<int, Byte[]> length, Stream stream);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(EndOfMibView other);
    public static bool op_Equality(EndOfMibView left, EndOfMibView right);
    public static bool op_Inequality(EndOfMibView left, EndOfMibView right);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual string ToString();
    private static bool Equals(EndOfMibView left, EndOfMibView right);
}
[DataContractAttribute]
public enum Lextm.SharpSnmpLib.ErrorCode : Enum {
    public int value__;
    public static ErrorCode NoError;
    public static ErrorCode TooBig;
    public static ErrorCode NoSuchName;
    public static ErrorCode BadValue;
    public static ErrorCode ReadOnly;
    public static ErrorCode GenError;
    public static ErrorCode NoAccess;
    public static ErrorCode WrongType;
    public static ErrorCode WrongLength;
    public static ErrorCode WrongEncoding;
    public static ErrorCode WrongValue;
    public static ErrorCode NoCreation;
    public static ErrorCode InconsistentValue;
    public static ErrorCode ResourceUnavailable;
    public static ErrorCode CommitFailed;
    public static ErrorCode UndoFailed;
    public static ErrorCode AuthorizationError;
    public static ErrorCode NotWritable;
    public static ErrorCode InconsistentName;
}
public class Lextm.SharpSnmpLib.Gauge32 : object {
    private Counter32 _count;
    public SnmpType TypeCode { get; }
    internal Gauge32(Byte[] raw);
    [CLSCompliantAttribute("False")]
public Gauge32(UInt32 value);
    public Gauge32(long value);
    public Gauge32(Tuple`2<int, Byte[]> length, Stream stream);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32();
    public virtual string ToString();
    public sealed virtual bool Equals(Gauge32 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Gauge32 left, Gauge32 right);
    public static bool op_Inequality(Gauge32 left, Gauge32 right);
    private static bool Equals(Gauge32 left, Gauge32 right);
}
[DataContractAttribute]
public enum Lextm.SharpSnmpLib.GenericCode : Enum {
    public int value__;
    public static GenericCode ColdStart;
    public static GenericCode WarmStart;
    public static GenericCode LinkDown;
    public static GenericCode LinkUp;
    public static GenericCode AuthenticationFailure;
    public static GenericCode EgpNeighborLoss;
    public static GenericCode EnterpriseSpecific;
}
public class Lextm.SharpSnmpLib.GetBulkRequestPdu : object {
    private Byte[] _raw;
    private Sequence _varbindSection;
    private Byte[] _length;
    [CompilerGeneratedAttribute]
private Integer32 <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Variable> <Variables>k__BackingField;
    public Integer32 RequestId { get; private set; }
    public Integer32 ErrorStatus { get; private set; }
    public Integer32 ErrorIndex { get; private set; }
    public List`1<Variable> Variables { get; private set; }
    public SnmpType TypeCode { get; }
    public GetBulkRequestPdu(int requestId, int nonRepeaters, int maxRepetitions, List`1<Variable> variables);
    public GetBulkRequestPdu(Tuple`2<int, Byte[]> length, Stream stream);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_RequestId();
    [CompilerGeneratedAttribute]
private void set_RequestId(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorStatus();
    [CompilerGeneratedAttribute]
private void set_ErrorStatus(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorIndex();
    [CompilerGeneratedAttribute]
private void set_ErrorIndex(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<Variable> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(List`1<Variable> value);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.GetNextRequestPdu : object {
    private Sequence _varbindSection;
    private Byte[] _length;
    private Byte[] _raw;
    [CompilerGeneratedAttribute]
private Integer32 <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Variable> <Variables>k__BackingField;
    public Integer32 RequestId { get; private set; }
    public Integer32 ErrorStatus { get; private set; }
    public Integer32 ErrorIndex { get; private set; }
    public List`1<Variable> Variables { get; private set; }
    public SnmpType TypeCode { get; }
    public GetNextRequestPdu(int requestId, List`1<Variable> variables);
    public GetNextRequestPdu(Tuple`2<int, Byte[]> length, Stream stream);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_RequestId();
    [CompilerGeneratedAttribute]
private void set_RequestId(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorStatus();
    [CompilerGeneratedAttribute]
private void set_ErrorStatus(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorIndex();
    [CompilerGeneratedAttribute]
private void set_ErrorIndex(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<Variable> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(List`1<Variable> value);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public sealed virtual void Dispose();
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.GetRequestPdu : object {
    private Sequence _varbindSection;
    private Byte[] _length;
    private Byte[] _raw;
    [CompilerGeneratedAttribute]
private Integer32 <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Variable> <Variables>k__BackingField;
    public Integer32 RequestId { get; private set; }
    public Integer32 ErrorStatus { get; private set; }
    public Integer32 ErrorIndex { get; private set; }
    public List`1<Variable> Variables { get; private set; }
    public SnmpType TypeCode { get; }
    public GetRequestPdu(int requestId, List`1<Variable> variables);
    public GetRequestPdu(Tuple`2<int, Byte[]> length, Stream stream);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_RequestId();
    [CompilerGeneratedAttribute]
private void set_RequestId(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorStatus();
    [CompilerGeneratedAttribute]
private void set_ErrorStatus(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorIndex();
    [CompilerGeneratedAttribute]
private void set_ErrorIndex(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<Variable> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(List`1<Variable> value);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public sealed virtual void Dispose();
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Header : object {
    private Integer32 _messageId;
    private Integer32 _maxSize;
    private OctetString _flags;
    private Integer32 _securityModel;
    private static Integer32 DefaultSecurityModel;
    private static Integer32 DefaultMaxMessageSize;
    private static Header EmptyHeader;
    private Sequence _container;
    public static int MaxMessageSize;
    [CompilerGeneratedAttribute]
private Levels <SecurityLevel>k__BackingField;
    public static Header Empty { get; }
    public Levels SecurityLevel { get; private set; }
    public int MessageId { get; }
    public int MaxSize { get; }
    public Header(int messageId);
    public Header(ISnmpData data);
    public Header(Integer32 messageId, Integer32 maxMessageSize, Levels securityLevel);
    private static Header();
    public static Header get_Empty();
    [CompilerGeneratedAttribute]
public Levels get_SecurityLevel();
    [CompilerGeneratedAttribute]
private void set_SecurityLevel(Levels value);
    public int get_MessageId();
    public sealed virtual Sequence ToSequence();
    public sealed virtual ISnmpData GetData(VersionCode version);
    public virtual string ToString();
    public int get_MaxSize();
}
[ExtensionAttribute]
public static class Lextm.SharpSnmpLib.Helper : object {
    [ExtensionAttribute]
public static IPAddress ToIPAddress(IP ip);
    [ExtensionAttribute]
public static PhysicalAddress ToPhysicalAddress(OctetString address);
}
public class Lextm.SharpSnmpLib.InformRequestPdu : object {
    private UInt32[] _timeId;
    private UInt32[] _enterpriseId;
    private Sequence _varbindSection;
    private TimeTicks _time;
    private Byte[] _length;
    private Byte[] _raw;
    [CompilerGeneratedAttribute]
private Integer32 <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Variable> <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectIdentifier <Enterprise>k__BackingField;
    public Integer32 RequestId { get; private set; }
    public Integer32 ErrorStatus { get; }
    public Integer32 ErrorIndex { get; }
    public List`1<Variable> Variables { get; private set; }
    public SnmpType TypeCode { get; }
    public ObjectIdentifier Enterprise { get; private set; }
    [CLSCompliantAttribute("False")]
public UInt32 TimeStamp { get; }
    [CLSCompliantAttribute("False")]
public InformRequestPdu(int requestId, ObjectIdentifier enterprise, UInt32 time, List`1<Variable> variables);
    public InformRequestPdu(int requestId);
    public InformRequestPdu(Tuple`2<int, Byte[]> length, Stream stream);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_RequestId();
    [CompilerGeneratedAttribute]
private void set_RequestId(Integer32 value);
    public sealed virtual Integer32 get_ErrorStatus();
    public sealed virtual Integer32 get_ErrorIndex();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<Variable> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(List`1<Variable> value);
    public sealed virtual SnmpType get_TypeCode();
    [CompilerGeneratedAttribute]
public ObjectIdentifier get_Enterprise();
    [CompilerGeneratedAttribute]
private void set_Enterprise(ObjectIdentifier value);
    public UInt32 get_TimeStamp();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.Integer32 : object {
    private int _int;
    private Byte[] _length;
    public static Integer32 Zero;
    private Byte[] _raw;
    public SnmpType TypeCode { get; }
    internal Integer32(Byte[] raw);
    public Integer32(int value);
    public Integer32(Tuple`2<int, Byte[]> length, Stream stream);
    private static Integer32();
    public int ToInt32();
    public ErrorCode ToErrorCode();
    public virtual string ToString();
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Integer32 other);
    public static bool op_Equality(Integer32 left, Integer32 right);
    public static bool op_Inequality(Integer32 left, Integer32 right);
    private static bool Equals(Integer32 left, Integer32 right);
}
public class Lextm.SharpSnmpLib.IP : object {
    private Byte[] _ip;
    private Byte[] _length;
    private static int IPv4Length;
    public SnmpType TypeCode { get; }
    public IP(Byte[] ip);
    public IP(string ip);
    public IP(Tuple`2<int, Byte[]> length, Stream stream);
    private static int FromHex(char digit);
    private static bool IsHexDigit(char character);
    public Byte[] GetRaw();
    public virtual string ToString();
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IP other);
    public virtual int GetHashCode();
    public static bool op_Equality(IP left, IP right);
    public static bool op_Inequality(IP left, IP right);
    private static bool Equals(IP left, IP right);
}
public interface Lextm.SharpSnmpLib.ISegment {
    public abstract virtual ISnmpData GetData(VersionCode version);
    public abstract virtual Sequence ToSequence();
}
public interface Lextm.SharpSnmpLib.ISnmpData {
    public SnmpType TypeCode { get; }
    public abstract virtual SnmpType get_TypeCode();
    public abstract virtual void AppendBytesTo(Stream stream);
    public abstract virtual string ToString();
}
public interface Lextm.SharpSnmpLib.ISnmpPdu {
    public Integer32 RequestId { get; }
    public Integer32 ErrorStatus { get; }
    public Integer32 ErrorIndex { get; }
    public List`1<Variable> Variables { get; }
    public abstract virtual Integer32 get_RequestId();
    public abstract virtual Integer32 get_ErrorStatus();
    public abstract virtual Integer32 get_ErrorIndex();
    public abstract virtual List`1<Variable> get_Variables();
}
[FlagsAttribute]
[DataContractAttribute]
public enum Lextm.SharpSnmpLib.Levels : Enum {
    public int value__;
    public static Levels Authentication;
    public static Levels Privacy;
    public static Levels Reportable;
}
public class Lextm.SharpSnmpLib.MalformedPdu : object {
    public SnmpType TypeCode { get; }
    public Integer32 RequestId { get; }
    public Integer32 ErrorStatus { get; }
    public Integer32 ErrorIndex { get; }
    public List`1<Variable> Variables { get; }
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public sealed virtual Integer32 get_RequestId();
    public sealed virtual Integer32 get_ErrorStatus();
    public sealed virtual Integer32 get_ErrorIndex();
    public sealed virtual List`1<Variable> get_Variables();
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.Messaging.AgentFoundEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IPEndPoint <Agent>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    public IPEndPoint Agent { get; private set; }
    public Variable Variable { get; private set; }
    public AgentFoundEventArgs(IPEndPoint agent, Variable variable);
    [CompilerGeneratedAttribute]
public IPEndPoint get_Agent();
    [CompilerGeneratedAttribute]
private void set_Agent(IPEndPoint value);
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    [CompilerGeneratedAttribute]
private void set_Variable(Variable value);
}
internal static class Lextm.SharpSnmpLib.Messaging.AsyncHelper : object {
    private static TaskFactory s_myTaskFactory;
    private static AsyncHelper();
    public static TResult RunSync(Func`1<Task`1<TResult>> func);
    public static void RunSync(Func`1<Task> func);
}
public class Lextm.SharpSnmpLib.Messaging.Discoverer : object {
    private int _active;
    private int _bufferSize;
    private int _requestId;
    private static UserRegistry Empty;
    private List`1<Variable> _defaultVariables;
    private static int Active;
    private static int Inactive;
    [CompilerGeneratedAttribute]
private EventHandler`1<AgentFoundEventArgs> AgentFound;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExceptionRaisedEventArgs> ExceptionRaised;
    private static Discoverer();
    [CompilerGeneratedAttribute]
public void add_AgentFound(EventHandler`1<AgentFoundEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AgentFound(EventHandler`1<AgentFoundEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ExceptionRaised(EventHandler`1<ExceptionRaisedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExceptionRaised(EventHandler`1<ExceptionRaisedEventArgs> value);
    public void Discover(VersionCode version, IPEndPoint broadcastAddress, OctetString community, int interval);
    private void AsyncReceive(Socket socket);
    private void HandleException(Exception exception);
    private void HandleMessage(Byte[] buffer, int count, IPEndPoint remote);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Discoverer/<DiscoverAsync>d__17")]
public Task DiscoverAsync(VersionCode version, IPEndPoint broadcastAddress, OctetString community, int interval);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Discoverer/<ReceiveAsync>d__18")]
private Task ReceiveAsync(Socket socket);
}
public class Lextm.SharpSnmpLib.Messaging.Discovery : object {
    private ISnmpMessage _discovery;
    private static UserRegistry Empty;
    private static SecurityParameters DefaultSecurityParameters;
    public Discovery(int messageId, int requestId, int maxMessageSize);
    public Discovery(int messageId, int requestId, int maxMessageSize, SnmpType type);
    private static Discovery();
    public ReportMessage GetResponse(int timeout, IPEndPoint receiver);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Discovery/<GetResponseAsync>d__6")]
public Task`1<ReportMessage> GetResponseAsync(IPEndPoint receiver);
    public Byte[] ToBytes();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Lextm.SharpSnmpLib.Messaging.EndPointExtension : object {
    [ExtensionAttribute]
public static Socket GetSocket(EndPoint endpoint);
}
[DataContractAttribute]
public class Lextm.SharpSnmpLib.Messaging.ErrorException : OperationException {
    [CompilerGeneratedAttribute]
private ISnmpMessage <Body>k__BackingField;
    public ISnmpMessage Body { get; private set; }
    protected string Details { get; }
    public ErrorException(string message);
    public ErrorException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public ISnmpMessage get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(ISnmpMessage value);
    protected virtual string get_Details();
    public static ErrorException Create(string message, IPAddress agent, ISnmpMessage body);
}
public class Lextm.SharpSnmpLib.Messaging.ExceptionRaisedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; private set; }
    public ExceptionRaisedEventArgs(Exception ex);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
public class Lextm.SharpSnmpLib.Messaging.GetBulkRequestMessage : object {
    private Byte[] _bytes;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrivacyProvider <Privacy>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionCode <Version>k__BackingField;
    public Header Header { get; private set; }
    public IPrivacyProvider Privacy { get; private set; }
    public SecurityParameters Parameters { get; private set; }
    public Scope Scope { get; private set; }
    public VersionCode Version { get; private set; }
    public GetBulkRequestMessage(int requestId, VersionCode version, OctetString community, int nonRepeaters, int maxRepetitions, List`1<Variable> variables);
    [ObsoleteAttribute("Please use other overloading ones.")]
public GetBulkRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, int nonRepeaters, int maxRepetitions, List`1<Variable> variables, IPrivacyProvider privacy, ISnmpMessage report);
    public GetBulkRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, OctetString contextName, int nonRepeaters, int maxRepetitions, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, ISnmpMessage report);
    public GetBulkRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, int nonRepeaters, int maxRepetitions, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, ISnmpMessage report);
    internal GetBulkRequestMessage(VersionCode version, Header header, SecurityParameters parameters, Scope scope, IPrivacyProvider privacy, Byte[] length);
    [CompilerGeneratedAttribute]
public sealed virtual Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
    [CompilerGeneratedAttribute]
public sealed virtual IPrivacyProvider get_Privacy();
    [CompilerGeneratedAttribute]
private void set_Privacy(IPrivacyProvider value);
    public sealed virtual Byte[] ToBytes();
    [CompilerGeneratedAttribute]
public sealed virtual SecurityParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(SecurityParameters value);
    [CompilerGeneratedAttribute]
public sealed virtual Scope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(Scope value);
    [CompilerGeneratedAttribute]
public sealed virtual VersionCode get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(VersionCode value);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.Messaging.GetNextRequestMessage : object {
    private Byte[] _bytes;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrivacyProvider <Privacy>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionCode <Version>k__BackingField;
    public Header Header { get; private set; }
    public IPrivacyProvider Privacy { get; private set; }
    public SecurityParameters Parameters { get; private set; }
    public Scope Scope { get; private set; }
    public VersionCode Version { get; private set; }
    public GetNextRequestMessage(int requestId, VersionCode version, OctetString community, List`1<Variable> variables);
    [ObsoleteAttribute("Please use other overloading ones.")]
public GetNextRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, List`1<Variable> variables, IPrivacyProvider privacy, ISnmpMessage report);
    public GetNextRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, OctetString contextName, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, ISnmpMessage report);
    public GetNextRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, ISnmpMessage report);
    internal GetNextRequestMessage(VersionCode version, Header header, SecurityParameters parameters, Scope scope, IPrivacyProvider privacy, Byte[] length);
    [CompilerGeneratedAttribute]
public sealed virtual Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
    [CompilerGeneratedAttribute]
public sealed virtual IPrivacyProvider get_Privacy();
    [CompilerGeneratedAttribute]
private void set_Privacy(IPrivacyProvider value);
    public sealed virtual Byte[] ToBytes();
    [CompilerGeneratedAttribute]
public sealed virtual SecurityParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(SecurityParameters value);
    [CompilerGeneratedAttribute]
public sealed virtual Scope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(Scope value);
    [CompilerGeneratedAttribute]
public sealed virtual VersionCode get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(VersionCode value);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.Messaging.GetRequestMessage : object {
    private Byte[] _bytes;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrivacyProvider <Privacy>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionCode <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    public Header Header { get; private set; }
    public IPrivacyProvider Privacy { get; private set; }
    public VersionCode Version { get; private set; }
    public SecurityParameters Parameters { get; private set; }
    public Scope Scope { get; private set; }
    public GetRequestMessage(int requestId, VersionCode version, OctetString community, List`1<Variable> variables);
    [ObsoleteAttribute("Please use other overloading ones.")]
public GetRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, List`1<Variable> variables, IPrivacyProvider privacy, ISnmpMessage report);
    public GetRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, OctetString contextName, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, ISnmpMessage report);
    public GetRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, ISnmpMessage report);
    internal GetRequestMessage(VersionCode version, Header header, SecurityParameters parameters, Scope scope, IPrivacyProvider privacy, Byte[] length);
    [CompilerGeneratedAttribute]
public sealed virtual Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
    [CompilerGeneratedAttribute]
public sealed virtual IPrivacyProvider get_Privacy();
    [CompilerGeneratedAttribute]
private void set_Privacy(IPrivacyProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual VersionCode get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(VersionCode value);
    public sealed virtual Byte[] ToBytes();
    [CompilerGeneratedAttribute]
public sealed virtual SecurityParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(SecurityParameters value);
    [CompilerGeneratedAttribute]
public sealed virtual Scope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(Scope value);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.Messaging.InformRequestMessage : object {
    private Byte[] _bytes;
    [CompilerGeneratedAttribute]
private IPrivacyProvider <Privacy>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionCode <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectIdentifier <Enterprise>k__BackingField;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    public IPrivacyProvider Privacy { get; private set; }
    public VersionCode Version { get; private set; }
    [CLSCompliantAttribute("False")]
public UInt32 TimeStamp { get; private set; }
    public ObjectIdentifier Enterprise { get; private set; }
    public Header Header { get; private set; }
    public SecurityParameters Parameters { get; private set; }
    public Scope Scope { get; private set; }
    [CLSCompliantAttribute("False")]
public InformRequestMessage(int requestId, VersionCode version, OctetString community, ObjectIdentifier enterprise, UInt32 time, List`1<Variable> variables);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Please use other overloading ones.")]
public InformRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, ObjectIdentifier enterprise, UInt32 time, List`1<Variable> variables, IPrivacyProvider privacy, ISnmpMessage report);
    [CLSCompliantAttribute("False")]
public InformRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, ObjectIdentifier enterprise, UInt32 time, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, ISnmpMessage report);
    [CLSCompliantAttribute("False")]
public InformRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, OctetString contextName, ObjectIdentifier enterprise, UInt32 time, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, ISnmpMessage report);
    internal InformRequestMessage(VersionCode version, Header header, SecurityParameters parameters, Scope scope, IPrivacyProvider privacy, Byte[] length);
    [CompilerGeneratedAttribute]
public sealed virtual IPrivacyProvider get_Privacy();
    [CompilerGeneratedAttribute]
private void set_Privacy(IPrivacyProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual VersionCode get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(VersionCode value);
    [CompilerGeneratedAttribute]
public UInt32 get_TimeStamp();
    [CompilerGeneratedAttribute]
private void set_TimeStamp(UInt32 value);
    [CompilerGeneratedAttribute]
public ObjectIdentifier get_Enterprise();
    [CompilerGeneratedAttribute]
private void set_Enterprise(ObjectIdentifier value);
    [CompilerGeneratedAttribute]
public sealed virtual Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
    public sealed virtual Byte[] ToBytes();
    [CompilerGeneratedAttribute]
public sealed virtual SecurityParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(SecurityParameters value);
    [CompilerGeneratedAttribute]
public sealed virtual Scope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(Scope value);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public interface Lextm.SharpSnmpLib.Messaging.ISnmpMessage {
    public Header Header { get; }
    public SecurityParameters Parameters { get; }
    public Scope Scope { get; }
    public VersionCode Version { get; }
    public IPrivacyProvider Privacy { get; }
    public abstract virtual Header get_Header();
    public abstract virtual SecurityParameters get_Parameters();
    public abstract virtual Scope get_Scope();
    public abstract virtual Byte[] ToBytes();
    public abstract virtual VersionCode get_Version();
    public abstract virtual IPrivacyProvider get_Privacy();
}
public class Lextm.SharpSnmpLib.Messaging.MalformedMessage : object {
    private static Scope DefaultScope;
    [CompilerGeneratedAttribute]
private ISnmpData <EncryptedScope>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    public ISnmpData EncryptedScope { get; public set; }
    public SecurityParameters Parameters { get; private set; }
    public Scope Scope { get; private set; }
    public Header Header { get; private set; }
    public VersionCode Version { get; }
    public IPrivacyProvider Privacy { get; }
    [ObsoleteAttribute("Please use the new overloading constructor.")]
public MalformedMessage(int messageId, OctetString user);
    public MalformedMessage(int messageId, OctetString user, ISnmpData data);
    private static MalformedMessage();
    [CompilerGeneratedAttribute]
public ISnmpData get_EncryptedScope();
    [CompilerGeneratedAttribute]
public void set_EncryptedScope(ISnmpData value);
    [CompilerGeneratedAttribute]
public sealed virtual SecurityParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(SecurityParameters value);
    [CompilerGeneratedAttribute]
public sealed virtual Scope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(Scope value);
    [CompilerGeneratedAttribute]
public sealed virtual Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
    public sealed virtual Byte[] ToBytes();
    public sealed virtual VersionCode get_Version();
    public sealed virtual IPrivacyProvider get_Privacy();
    public virtual string ToString();
    public sealed virtual void Dispose();
}
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Please use Messenger class instead.")]
public class Lextm.SharpSnmpLib.Messaging.Manager : object {
    private static int DefaultPort;
    private object _locker;
    private int _timeout;
    private VersionCode _version;
    [CompilerGeneratedAttribute]
private int <MaxRepetitions>k__BackingField;
    public VersionCode DefaultVersion { get; public set; }
    public int Timeout { get; public set; }
    public int MaxRepetitions { get; public set; }
    public VersionCode get_DefaultVersion();
    public void set_DefaultVersion(VersionCode value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public Variable GetSingle(IPEndPoint endpoint, string community, Variable variable);
    public Variable GetSingle(string address, string community, Variable variable);
    public Variable GetSingle(IPAddress address, string community, Variable variable);
    public IList`1<Variable> Get(IPEndPoint endpoint, string community, List`1<Variable> variables);
    public IList`1<Variable> Get(string address, string community, List`1<Variable> variables);
    public IList`1<Variable> Get(IPAddress address, string community, List`1<Variable> variables);
    public Variable SetSingle(IPEndPoint endpoint, string community, Variable variable);
    public Variable SetSingle(IPAddress address, string community, Variable variable);
    public Variable SetSingle(string address, string community, Variable variable);
    public IList`1<Variable> Set(IPEndPoint endpoint, string community, List`1<Variable> variables);
    public IList`1<Variable> Set(string address, string community, List`1<Variable> variables);
    public IList`1<Variable> Set(IPAddress address, string community, List`1<Variable> variables);
    public Variable[0...,0...] GetTable(IPEndPoint endpoint, string community, ObjectIdentifier table);
    [CompilerGeneratedAttribute]
public int get_MaxRepetitions();
    [CompilerGeneratedAttribute]
public void set_MaxRepetitions(int value);
    public Variable[0...,0...] GetTable(IPAddress address, string community, ObjectIdentifier table);
    public Variable[0...,0...] GetTable(string address, string community, ObjectIdentifier table);
    public virtual string ToString();
}
public static class Lextm.SharpSnmpLib.Messaging.MessageFactory : object {
    public static IList`1<ISnmpMessage> ParseMessages(IEnumerable`1<char> bytes, UserRegistry registry);
    public static IList`1<ISnmpMessage> ParseMessages(Byte[] buffer, UserRegistry registry);
    public static IList`1<ISnmpMessage> ParseMessages(Byte[] buffer, int index, int length, UserRegistry registry);
    private static ISnmpMessage ParseMessage(int first, Stream stream, UserRegistry registry);
}
[DataContractAttribute]
public class Lextm.SharpSnmpLib.Messaging.MessageFactoryException : SnmpException {
    private Byte[] _bytes;
    public MessageFactoryException(string message);
    public MessageFactoryException(string message, Exception inner);
    public Byte[] GetBytes();
    public void SetBytes(Byte[] value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Lextm.SharpSnmpLib.Messaging.Messenger : object {
    private static Lazy`1<NumberGenerator> RequestCounterFullRange;
    private static Lazy`1<NumberGenerator> RequestCounterPositive;
    [CompilerGeneratedAttribute]
private static bool <UseFullRange>k__BackingField;
    private static NumberGenerator MessageCounter;
    private static ObjectIdentifier IdUnsupportedSecurityLevel;
    private static ObjectIdentifier IdNotInTimeWindow;
    private static ObjectIdentifier IdUnknownSecurityName;
    private static ObjectIdentifier IdUnknownEngineID;
    private static ObjectIdentifier IdAuthenticationFailure;
    private static ObjectIdentifier IdDecryptionError;
    [CompilerGeneratedAttribute]
private static int <MaxMessageSize>k__BackingField;
    private static NumberGenerator RequestCounter { get; }
    public static bool UseFullRange { get; public set; }
    public static int NextRequestId { get; }
    public static int NextMessageId { get; }
    public static int MaxMessageSize { get; public set; }
    [ObsoleteAttribute("Please use GetNextDiscovery")]
public static Discovery NextDiscovery { get; }
    public static ObjectIdentifier DecryptionError { get; }
    public static ObjectIdentifier AuthenticationFailure { get; }
    public static ObjectIdentifier UnknownEngineId { get; }
    public static ObjectIdentifier UnknownSecurityName { get; }
    public static ObjectIdentifier NotInTimeWindow { get; }
    public static ObjectIdentifier UnsupportedSecurityLevel { get; }
    private static Messenger();
    private static NumberGenerator get_RequestCounter();
    [CompilerGeneratedAttribute]
public static bool get_UseFullRange();
    [CompilerGeneratedAttribute]
public static void set_UseFullRange(bool value);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<GetAsync>d__15")]
public static Task`1<IList`1<Variable>> GetAsync(VersionCode version, IPEndPoint endpoint, OctetString community, List`1<Variable> variables);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<SetAsync>d__16")]
public static Task`1<IList`1<Variable>> SetAsync(VersionCode version, IPEndPoint endpoint, OctetString community, List`1<Variable> variables);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<WalkAsync>d__17")]
public static Task`1<int> WalkAsync(VersionCode version, IPEndPoint endpoint, OctetString community, ObjectIdentifier table, IList`1<Variable> list, WalkMode mode);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<HasNextAsync>d__18")]
private static Task`1<Tuple`2<bool, Variable>> HasNextAsync(VersionCode version, IPEndPoint endpoint, OctetString community, Variable seed);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<BulkWalkAsync>d__19")]
[ObsoleteAttribute("Please use other overloading ones.")]
public static Task`1<int> BulkWalkAsync(VersionCode version, IPEndPoint endpoint, OctetString community, ObjectIdentifier table, IList`1<Variable> list, int maxRepetitions, WalkMode mode, IPrivacyProvider privacy, ISnmpMessage report);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<BulkWalkAsync>d__20")]
public static Task`1<int> BulkWalkAsync(VersionCode version, IPEndPoint endpoint, OctetString community, OctetString contextName, ObjectIdentifier table, IList`1<Variable> list, int maxRepetitions, WalkMode mode, IPrivacyProvider privacy, ISnmpMessage report);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<SendTrapV1Async>d__21")]
[CLSCompliantAttribute("False")]
public static Task SendTrapV1Async(EndPoint receiver, IPAddress agent, OctetString community, ObjectIdentifier enterprise, GenericCode generic, int specific, UInt32 timestamp, List`1<Variable> variables);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<SendTrapV2Async>d__22")]
[CLSCompliantAttribute("False")]
public static Task SendTrapV2Async(int requestId, VersionCode version, EndPoint receiver, OctetString community, ObjectIdentifier enterprise, UInt32 timestamp, List`1<Variable> variables);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<SendInformAsync>d__23")]
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Please use other overloading ones.")]
public static Task SendInformAsync(int requestId, VersionCode version, IPEndPoint receiver, OctetString community, ObjectIdentifier enterprise, UInt32 timestamp, List`1<Variable> variables, IPrivacyProvider privacy, ISnmpMessage report);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<SendInformAsync>d__24")]
[CLSCompliantAttribute("False")]
public static Task SendInformAsync(int requestId, VersionCode version, IPEndPoint receiver, OctetString community, OctetString contextName, ObjectIdentifier enterprise, UInt32 timestamp, List`1<Variable> variables, IPrivacyProvider privacy, ISnmpMessage report);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<BulkHasNextAsync>d__25")]
[ObsoleteAttribute("Please use other overloading ones.")]
private static Task`1<Tuple`3<bool, IList`1<Variable>, ISnmpMessage>> BulkHasNextAsync(VersionCode version, IPEndPoint receiver, OctetString community, Variable seed, int maxRepetitions, IPrivacyProvider privacy, ISnmpMessage report);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.Messenger/<BulkHasNextAsync>d__26")]
private static Task`1<Tuple`3<bool, IList`1<Variable>, ISnmpMessage>> BulkHasNextAsync(VersionCode version, IPEndPoint receiver, OctetString community, OctetString contextName, Variable seed, int maxRepetitions, IPrivacyProvider privacy, ISnmpMessage report);
    public static IList`1<Variable> Get(VersionCode version, IPEndPoint endpoint, OctetString community, List`1<Variable> variables, int timeout);
    public static IList`1<Variable> Set(VersionCode version, IPEndPoint endpoint, OctetString community, List`1<Variable> variables, int timeout);
    public static int Walk(VersionCode version, IPEndPoint endpoint, OctetString community, ObjectIdentifier table, IList`1<Variable> list, int timeout, WalkMode mode);
    private static bool HasNext(VersionCode version, IPEndPoint endpoint, OctetString community, Variable seed, int timeout, Variable& next);
    [ObsoleteAttribute("Please use other overloading ones.")]
public static int BulkWalk(VersionCode version, IPEndPoint endpoint, OctetString community, ObjectIdentifier table, IList`1<Variable> list, int timeout, int maxRepetitions, WalkMode mode, IPrivacyProvider privacy, ISnmpMessage report);
    public static int BulkWalk(VersionCode version, IPEndPoint endpoint, OctetString community, OctetString contextName, ObjectIdentifier table, IList`1<Variable> list, int timeout, int maxRepetitions, WalkMode mode, IPrivacyProvider privacy, ISnmpMessage report);
    [CLSCompliantAttribute("False")]
public static void SendTrapV1(EndPoint receiver, IPAddress agent, OctetString community, ObjectIdentifier enterprise, GenericCode generic, int specific, UInt32 timestamp, List`1<Variable> variables);
    [CLSCompliantAttribute("False")]
public static void SendTrapV2(int requestId, VersionCode version, EndPoint receiver, OctetString community, ObjectIdentifier enterprise, UInt32 timestamp, List`1<Variable> variables);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Please use other overloading ones.")]
public static void SendInform(int requestId, VersionCode version, IPEndPoint receiver, OctetString community, ObjectIdentifier enterprise, UInt32 timestamp, List`1<Variable> variables, int timeout, IPrivacyProvider privacy, ISnmpMessage report);
    [CLSCompliantAttribute("False")]
public static void SendInform(int requestId, VersionCode version, IPEndPoint receiver, OctetString community, OctetString contextName, ObjectIdentifier enterprise, UInt32 timestamp, List`1<Variable> variables, int timeout, IPrivacyProvider privacy, ISnmpMessage report);
    [ObsoleteAttribute("Please use other overloading ones.")]
private static bool BulkHasNext(VersionCode version, IPEndPoint receiver, OctetString community, Variable seed, int timeout, int maxRepetitions, IList`1& next, IPrivacyProvider privacy, ISnmpMessage& report);
    private static bool BulkHasNext(VersionCode version, IPEndPoint receiver, OctetString community, OctetString contextName, Variable seed, int timeout, int maxRepetitions, IList`1& next, IPrivacyProvider privacy, ISnmpMessage& report);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This method only works for a few scenarios. Might be replaced by new methods in the future. If it does not work for you, parse WALK result on your own.")]
public static Variable[0...,0...] GetTable(VersionCode version, IPEndPoint endpoint, OctetString community, ObjectIdentifier table, int timeout, int maxRepetitions);
    public static int get_NextRequestId();
    public static int get_NextMessageId();
    [CompilerGeneratedAttribute]
public static int get_MaxMessageSize();
    [CompilerGeneratedAttribute]
public static void set_MaxMessageSize(int value);
    public static Discovery get_NextDiscovery();
    public static ObjectIdentifier get_DecryptionError();
    public static ObjectIdentifier get_AuthenticationFailure();
    public static ObjectIdentifier get_UnknownEngineId();
    public static ObjectIdentifier get_UnknownSecurityName();
    public static ObjectIdentifier get_NotInTimeWindow();
    public static ObjectIdentifier get_UnsupportedSecurityLevel();
    public static Discovery GetNextDiscovery(SnmpType type);
    [ExtensionAttribute]
public static string GetErrorMessage(ObjectIdentifier id);
}
public class Lextm.SharpSnmpLib.Messaging.NumberGenerator : object {
    private object _root;
    private int _salt;
    private int _min;
    private int _max;
    public int NextId { get; }
    public NumberGenerator(int min, int max);
    public int get_NextId();
    internal void SetSalt(int value);
}
[DataContractAttribute]
public class Lextm.SharpSnmpLib.Messaging.PortInUseException : SnmpException {
    [CompilerGeneratedAttribute]
private IPEndPoint <Endpoint>k__BackingField;
    public IPEndPoint Endpoint { get; public set; }
    public PortInUseException(string message);
    public PortInUseException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public IPEndPoint get_Endpoint();
    [CompilerGeneratedAttribute]
public void set_Endpoint(IPEndPoint value);
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Messaging.ReportMessage : object {
    private Byte[] _bytes;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionCode <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrivacyProvider <Privacy>k__BackingField;
    public Header Header { get; private set; }
    public SecurityParameters Parameters { get; private set; }
    public Scope Scope { get; private set; }
    public VersionCode Version { get; private set; }
    public IPrivacyProvider Privacy { get; private set; }
    public ReportMessage(VersionCode version, Header header, SecurityParameters parameters, Scope scope, IPrivacyProvider privacy, Byte[] length);
    [CompilerGeneratedAttribute]
public sealed virtual Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
    [CompilerGeneratedAttribute]
public sealed virtual SecurityParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(SecurityParameters value);
    [CompilerGeneratedAttribute]
public sealed virtual Scope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(Scope value);
    [CompilerGeneratedAttribute]
public sealed virtual VersionCode get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(VersionCode value);
    public sealed virtual Byte[] ToBytes();
    [CompilerGeneratedAttribute]
public sealed virtual IPrivacyProvider get_Privacy();
    [CompilerGeneratedAttribute]
private void set_Privacy(IPrivacyProvider value);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.Messaging.ResponseMessage : object {
    private Byte[] _bytes;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrivacyProvider <Privacy>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionCode <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    private bool _disposed;
    public Header Header { get; private set; }
    public IPrivacyProvider Privacy { get; private set; }
    public ErrorCode ErrorStatus { get; }
    public int ErrorIndex { get; }
    public VersionCode Version { get; private set; }
    public SecurityParameters Parameters { get; private set; }
    public Scope Scope { get; private set; }
    public ResponseMessage(int requestId, VersionCode version, OctetString community, ErrorCode error, int index, List`1<Variable> variables);
    public ResponseMessage(VersionCode version, Header header, SecurityParameters parameters, Scope scope, IPrivacyProvider privacy, bool needAuthentication, Byte[] length);
    [CompilerGeneratedAttribute]
public sealed virtual Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
    [CompilerGeneratedAttribute]
public sealed virtual IPrivacyProvider get_Privacy();
    [CompilerGeneratedAttribute]
private void set_Privacy(IPrivacyProvider value);
    public ErrorCode get_ErrorStatus();
    public int get_ErrorIndex();
    [CompilerGeneratedAttribute]
public sealed virtual VersionCode get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(VersionCode value);
    [CompilerGeneratedAttribute]
public sealed virtual SecurityParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(SecurityParameters value);
    [CompilerGeneratedAttribute]
public sealed virtual Scope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(Scope value);
    public sealed virtual void Dispose();
    public sealed virtual Byte[] ToBytes();
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Messaging.SetRequestMessage : object {
    private Byte[] _bytes;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrivacyProvider <Privacy>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionCode <Version>k__BackingField;
    public Header Header { get; private set; }
    public IPrivacyProvider Privacy { get; private set; }
    public SecurityParameters Parameters { get; private set; }
    public Scope Scope { get; private set; }
    public VersionCode Version { get; private set; }
    public SetRequestMessage(int requestId, VersionCode version, OctetString community, List`1<Variable> variables);
    public SetRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, List`1<Variable> variables, IPrivacyProvider privacy, ISnmpMessage report);
    public SetRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, OctetString contextName, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, ISnmpMessage report);
    [ObsoleteAttribute("Please use other overloading ones.")]
public SetRequestMessage(VersionCode version, int messageId, int requestId, OctetString userName, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, ISnmpMessage report);
    internal SetRequestMessage(VersionCode version, Header header, SecurityParameters parameters, Scope scope, IPrivacyProvider privacy, Byte[] length);
    [CompilerGeneratedAttribute]
public sealed virtual Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
    [CompilerGeneratedAttribute]
public sealed virtual IPrivacyProvider get_Privacy();
    [CompilerGeneratedAttribute]
private void set_Privacy(IPrivacyProvider value);
    public virtual string ToString();
    public sealed virtual Byte[] ToBytes();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual SecurityParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(SecurityParameters value);
    [CompilerGeneratedAttribute]
public sealed virtual Scope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(Scope value);
    [CompilerGeneratedAttribute]
public sealed virtual VersionCode get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(VersionCode value);
}
[ExtensionAttribute]
public static class Lextm.SharpSnmpLib.Messaging.SnmpMessageExtension : object {
    public static bool IsRunningOnMono { get; }
    public static bool IsRunningOnWindows { get; }
    public static bool IsRunningOnMac { get; }
    public static bool IsRunningOnIOS { get; }
    [ExtensionAttribute]
public static SnmpType TypeCode(ISnmpMessage message);
    [ExtensionAttribute]
public static IList`1<Variable> Variables(ISnmpMessage message);
    [ExtensionAttribute]
public static int RequestId(ISnmpMessage message);
    [ExtensionAttribute]
public static int MessageId(ISnmpMessage message);
    [ExtensionAttribute]
public static ISnmpPdu Pdu(ISnmpMessage message);
    [ExtensionAttribute]
public static OctetString Community(ISnmpMessage message);
    [ExtensionAttribute]
public static void Send(ISnmpMessage message, EndPoint manager);
    [ExtensionAttribute]
public static void Send(ISnmpMessage message, EndPoint manager, Socket socket);
    [ExtensionAttribute]
public static ISnmpMessage GetResponse(ISnmpMessage request, int timeout, IPEndPoint receiver, UserRegistry registry);
    [ExtensionAttribute]
public static ISnmpMessage GetResponse(ISnmpMessage request, int timeout, IPEndPoint receiver);
    [ExtensionAttribute]
public static ISnmpMessage GetResponse(ISnmpMessage request, int timeout, IPEndPoint receiver, Socket udpSocket);
    [ExtensionAttribute]
public static ISnmpMessage GetResponse(ISnmpMessage request, int timeout, IPEndPoint receiver, UserRegistry registry, Socket udpSocket);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.SnmpMessageExtension/<SendAsync>d__12")]
[ExtensionAttribute]
public static Task SendAsync(ISnmpMessage message, EndPoint manager);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.SnmpMessageExtension/<SendAsync>d__13")]
[ExtensionAttribute]
public static Task SendAsync(ISnmpMessage message, EndPoint manager, Socket socket);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.SnmpMessageExtension/<GetResponseAsync>d__14")]
[ExtensionAttribute]
public static Task`1<ISnmpMessage> GetResponseAsync(ISnmpMessage request, IPEndPoint receiver, UserRegistry registry);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.SnmpMessageExtension/<GetResponseAsync>d__15")]
[ExtensionAttribute]
public static Task`1<ISnmpMessage> GetResponseAsync(ISnmpMessage request, IPEndPoint receiver);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.SnmpMessageExtension/<GetResponseAsync>d__16")]
[ExtensionAttribute]
public static Task`1<ISnmpMessage> GetResponseAsync(ISnmpMessage request, IPEndPoint receiver, Socket udpSocket);
    [AsyncStateMachineAttribute("Lextm.SharpSnmpLib.Messaging.SnmpMessageExtension/<GetResponseAsync>d__17")]
[ExtensionAttribute]
public static Task`1<ISnmpMessage> GetResponseAsync(ISnmpMessage request, IPEndPoint receiver, UserRegistry registry, Socket udpSocket);
    public static bool get_IsRunningOnMono();
    public static bool get_IsRunningOnWindows();
    public static bool get_IsRunningOnMac();
    public static bool get_IsRunningOnIOS();
    [ExtensionAttribute]
internal static Sequence PackMessage(ISnmpMessage message, Byte[] length);
}
public class Lextm.SharpSnmpLib.Messaging.SocketAsyncEventArgsFactory : object {
    internal static string DisposedMessage;
    private object _root;
    private Queue`1<SocketAsyncEventArgs> _queue;
    public SocketAsyncEventArgs Create();
    internal void Reuse(SocketAsyncEventArgs args);
}
internal class Lextm.SharpSnmpLib.Messaging.SocketAwaitable : object {
    private static Action SENTINEL;
    internal bool m_wasCompleted;
    internal Action m_continuation;
    internal SocketAsyncEventArgs m_eventArgs;
    private bool _disposed;
    public bool IsCompleted { get; }
    public SocketAwaitable(SocketAsyncEventArgs eventArgs);
    private static SocketAwaitable();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Dispose(bool disposing);
    private void Completed(object sender, SocketAsyncEventArgs e);
    internal void Reset();
    public SocketAwaitable GetAwaiter();
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public int GetResult();
}
[ExtensionAttribute]
internal static class Lextm.SharpSnmpLib.Messaging.SocketExtension : object {
    internal static SocketAsyncEventArgsFactory EventArgsFactory;
    private static SocketExtension();
    [ExtensionAttribute]
public static SocketAwaitable ReceiveMessageFromAsync(Socket socket, SocketAwaitable awaitable);
    [ExtensionAttribute]
public static SocketAwaitable SendToAsync(Socket socket, SocketAwaitable awaitable);
}
[DataContractAttribute]
public class Lextm.SharpSnmpLib.Messaging.TimeoutException : OperationException {
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    public int Timeout { get; private set; }
    public TimeoutException(string message);
    public TimeoutException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public int get_Timeout();
    [CompilerGeneratedAttribute]
private void set_Timeout(int value);
    public virtual string ToString();
    public static TimeoutException Create(IPAddress agent, int timeout);
}
public class Lextm.SharpSnmpLib.Messaging.TrapV1Message : object {
    private ISnmpPdu _pdu;
    private Sequence _container;
    private Scope _scope;
    [CompilerGeneratedAttribute]
private UInt32 <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private OctetString <Community>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectIdentifier <Enterprise>k__BackingField;
    [CompilerGeneratedAttribute]
private IPAddress <AgentAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericCode <Generic>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Specific>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionCode <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityParameters <Parameters>k__BackingField;
    [CLSCompliantAttribute("False")]
public UInt32 TimeStamp { get; private set; }
    public OctetString Community { get; private set; }
    public ObjectIdentifier Enterprise { get; private set; }
    public IPAddress AgentAddress { get; private set; }
    public GenericCode Generic { get; private set; }
    public int Specific { get; private set; }
    public VersionCode Version { get; private set; }
    public Header Header { get; }
    public IPrivacyProvider Privacy { get; }
    public SecurityParameters Parameters { get; private set; }
    public Scope Scope { get; }
    [CLSCompliantAttribute("False")]
public TrapV1Message(VersionCode version, IPAddress agent, OctetString community, ObjectIdentifier enterprise, GenericCode generic, int specific, UInt32 time, List`1<Variable> variables);
    public TrapV1Message(Sequence body);
    [CompilerGeneratedAttribute]
public UInt32 get_TimeStamp();
    [CompilerGeneratedAttribute]
private void set_TimeStamp(UInt32 value);
    [CompilerGeneratedAttribute]
public OctetString get_Community();
    [CompilerGeneratedAttribute]
private void set_Community(OctetString value);
    [CompilerGeneratedAttribute]
public ObjectIdentifier get_Enterprise();
    [CompilerGeneratedAttribute]
private void set_Enterprise(ObjectIdentifier value);
    [CompilerGeneratedAttribute]
public IPAddress get_AgentAddress();
    [CompilerGeneratedAttribute]
private void set_AgentAddress(IPAddress value);
    [CompilerGeneratedAttribute]
public GenericCode get_Generic();
    [CompilerGeneratedAttribute]
private void set_Generic(GenericCode value);
    [CompilerGeneratedAttribute]
public int get_Specific();
    [CompilerGeneratedAttribute]
private void set_Specific(int value);
    [CompilerGeneratedAttribute]
public sealed virtual VersionCode get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(VersionCode value);
    public sealed virtual Header get_Header();
    public sealed virtual IPrivacyProvider get_Privacy();
    public sealed virtual Byte[] ToBytes();
    [CompilerGeneratedAttribute]
public sealed virtual SecurityParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(SecurityParameters value);
    public sealed virtual Scope get_Scope();
    public virtual string ToString();
    internal static Sequence PackMessage(VersionCode version, ISnmpData[] data);
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.Messaging.TrapV2Message : object {
    private Byte[] _bytes;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrivacyProvider <Privacy>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectIdentifier <Enterprise>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionCode <Version>k__BackingField;
    public Header Header { get; private set; }
    public IPrivacyProvider Privacy { get; private set; }
    public SecurityParameters Parameters { get; private set; }
    public Scope Scope { get; private set; }
    public ObjectIdentifier Enterprise { get; private set; }
    [CLSCompliantAttribute("False")]
public UInt32 TimeStamp { get; private set; }
    public VersionCode Version { get; private set; }
    [CLSCompliantAttribute("False")]
public TrapV2Message(int requestId, VersionCode version, OctetString community, ObjectIdentifier enterprise, UInt32 time, List`1<Variable> variables);
    [CLSCompliantAttribute("False")]
public TrapV2Message(VersionCode version, int messageId, int requestId, OctetString userName, ObjectIdentifier enterprise, UInt32 time, List`1<Variable> variables, IPrivacyProvider privacy, int maxMessageSize, OctetString engineId, int engineBoots, int engineTime);
    internal TrapV2Message(VersionCode version, Header header, SecurityParameters parameters, Scope scope, IPrivacyProvider privacy, Byte[] length);
    [CompilerGeneratedAttribute]
public sealed virtual Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
    [CompilerGeneratedAttribute]
public sealed virtual IPrivacyProvider get_Privacy();
    [CompilerGeneratedAttribute]
private void set_Privacy(IPrivacyProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual SecurityParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(SecurityParameters value);
    [CompilerGeneratedAttribute]
public sealed virtual Scope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(Scope value);
    public sealed virtual Byte[] ToBytes();
    [CompilerGeneratedAttribute]
public ObjectIdentifier get_Enterprise();
    [CompilerGeneratedAttribute]
private void set_Enterprise(ObjectIdentifier value);
    [CompilerGeneratedAttribute]
public UInt32 get_TimeStamp();
    [CompilerGeneratedAttribute]
private void set_TimeStamp(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual VersionCode get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(VersionCode value);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
[DataContractAttribute]
public enum Lextm.SharpSnmpLib.Messaging.WalkMode : Enum {
    public int value__;
    public static WalkMode Default;
    public static WalkMode WithinSubtree;
}
public class Lextm.SharpSnmpLib.NoSuchInstance : object {
    private Byte[] _length;
    public SnmpType TypeCode { get; }
    public NoSuchInstance(Tuple`2<int, Byte[]> length, Stream stream);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(NoSuchInstance other);
    public static bool op_Equality(NoSuchInstance left, NoSuchInstance right);
    public static bool op_Inequality(NoSuchInstance left, NoSuchInstance right);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual string ToString();
    private static bool Equals(NoSuchInstance left, NoSuchInstance right);
}
public class Lextm.SharpSnmpLib.NoSuchObject : object {
    private Byte[] _length;
    public SnmpType TypeCode { get; }
    public NoSuchObject(Tuple`2<int, Byte[]> length, Stream stream);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(NoSuchObject other);
    public static bool op_Equality(NoSuchObject left, NoSuchObject right);
    public static bool op_Inequality(NoSuchObject left, NoSuchObject right);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual string ToString();
    private static bool Equals(NoSuchObject left, NoSuchObject right);
}
public class Lextm.SharpSnmpLib.Null : object {
    private Byte[] _length;
    public SnmpType TypeCode { get; }
    public Null(Tuple`2<int, Byte[]> length, Stream stream);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Null other);
    public static bool op_Equality(Null left, Null right);
    public static bool op_Inequality(Null left, Null right);
    public virtual string ToString();
    private static bool Equals(Null left, Null right);
}
[TypeConverterAttribute("Lextm.SharpSnmpLib.ObjectIdentifierConverter")]
[DataContractAttribute]
public class Lextm.SharpSnmpLib.ObjectIdentifier : object {
    private UInt32[] _oid;
    private int _hashcode;
    private Byte[] _length;
    private Byte[] _raw;
    public SnmpType TypeCode { get; }
    public ObjectIdentifier(string text);
    [CLSCompliantAttribute("False")]
public ObjectIdentifier(UInt32[] id);
    internal ObjectIdentifier(Byte[] raw);
    public ObjectIdentifier(Tuple`2<int, Byte[]> length, Stream stream);
    [CLSCompliantAttribute("False")]
public UInt32[] ToNumerical();
    public int Compare(ObjectIdentifier other);
    public sealed virtual int CompareTo(ObjectIdentifier other);
    public virtual string ToString();
    [CLSCompliantAttribute("False")]
public static string Convert(UInt32[] numerical);
    [CLSCompliantAttribute("False")]
public static UInt32[] Convert(string dotted);
    public sealed virtual void AppendBytesTo(Stream stream);
    private Byte[] GetRaw();
    [IteratorStateMachineAttribute("Lextm.SharpSnmpLib.ObjectIdentifier/<ConvertToBytes>d__16")]
private static IEnumerable`1<byte> ConvertToBytes(UInt32 subIdentifier);
    public sealed virtual SnmpType get_TypeCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ObjectIdentifier other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public static bool op_Equality(ObjectIdentifier left, ObjectIdentifier right);
    public static bool op_Inequality(ObjectIdentifier left, ObjectIdentifier right);
    public static bool op_GreaterThan(ObjectIdentifier left, ObjectIdentifier right);
    public static bool op_LessThan(ObjectIdentifier left, ObjectIdentifier right);
    private static bool Equals(IComparable`1<ObjectIdentifier> left, ObjectIdentifier right);
    [CLSCompliantAttribute("False")]
public static ObjectIdentifier Create(UInt32[] numerical, UInt32 extra);
    [CLSCompliantAttribute("False")]
public static UInt32[] AppendTo(UInt32[] original, UInt32 extra);
}
public class Lextm.SharpSnmpLib.ObjectIdentifierConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.OctetString : object {
    private static OctetString EmptyString;
    private static Encoding _defaultEncoding;
    private Byte[] _raw;
    private Byte[] _length;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Encoding Encoding { get; private set; }
    public static OctetString Empty { get; }
    public SnmpType TypeCode { get; }
    public static Encoding DefaultEncoding { get; public set; }
    public OctetString(Tuple`2<int, Byte[]> length, Stream stream);
    public OctetString(Byte[] raw);
    public OctetString(string content, Encoding encoding);
    public OctetString(string content);
    public OctetString(Levels level);
    private static OctetString();
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
private void set_Encoding(Encoding value);
    public Byte[] GetRaw();
    public static OctetString get_Empty();
    public Levels ToLevels();
    public string ToHexString();
    public string ToString(Encoding encoding);
    public virtual string ToString();
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public sealed virtual bool Equals(OctetString other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(OctetString left, OctetString right);
    public static bool op_Inequality(OctetString left, OctetString right);
    public PhysicalAddress ToPhysicalAddress();
    public static Encoding get_DefaultEncoding();
    public static void set_DefaultEncoding(Encoding value);
    private static bool Equals(OctetString left, OctetString right);
    internal Byte[] GetLengthBytes();
    internal void SetLengthBytes(Byte[] bytes);
    public static bool IsNullOrEmpty(OctetString value);
}
public class Lextm.SharpSnmpLib.Opaque : object {
    private Byte[] _raw;
    private Byte[] _length;
    public SnmpType TypeCode { get; }
    internal Opaque(Byte[] raw);
    public Opaque(Tuple`2<int, Byte[]> length, Stream stream);
    public virtual string ToString();
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public Byte[] GetRaw();
    public sealed virtual bool Equals(Opaque other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Opaque left, Opaque right);
    public static bool op_Inequality(Opaque left, Opaque right);
    private static bool Equals(Opaque left, Opaque right);
}
[DataContractAttribute]
public class Lextm.SharpSnmpLib.OperationException : SnmpException {
    [CompilerGeneratedAttribute]
private IPAddress <Agent>k__BackingField;
    protected IPAddress Agent { get; protected set; }
    protected string Details { get; }
    public OperationException(string message);
    public OperationException(string message, Exception inner);
    [CompilerGeneratedAttribute]
protected IPAddress get_Agent();
    [CompilerGeneratedAttribute]
protected void set_Agent(IPAddress value);
    protected virtual string get_Details();
    public static OperationException Create(string message, IPAddress agent);
}
public static class Lextm.SharpSnmpLib.Pools : object {
    private static ObjectPool`1<List`1<Variable>> VariableListPool;
    private static ObjectPool`1<List`1<byte>> ByteListPool;
    private static Pools();
    public static List`1<byte> GetByteList();
    public static List`1<Variable> GetVariableList();
    public static void ReturnByteList(List`1<byte> list);
    public static void ReturnVariableList(List`1<Variable> list);
}
public class Lextm.SharpSnmpLib.ReportPdu : object {
    private Sequence _varbindSection;
    private Byte[] _length;
    private Byte[] _raw;
    [CompilerGeneratedAttribute]
private Integer32 <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Variable> <Variables>k__BackingField;
    public Integer32 RequestId { get; private set; }
    public Integer32 ErrorStatus { get; private set; }
    public Integer32 ErrorIndex { get; private set; }
    public List`1<Variable> Variables { get; private set; }
    public SnmpType TypeCode { get; }
    public ReportPdu(int requestId, ErrorCode errorStatus, int errorIndex, List`1<Variable> variables);
    public ReportPdu(Tuple`2<int, Byte[]> length, Stream stream);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_RequestId();
    [CompilerGeneratedAttribute]
private void set_RequestId(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorStatus();
    [CompilerGeneratedAttribute]
private void set_ErrorStatus(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorIndex();
    [CompilerGeneratedAttribute]
private void set_ErrorIndex(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<Variable> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(List`1<Variable> value);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.ResponsePdu : object {
    private Sequence _varbindSection;
    private Byte[] _length;
    private Byte[] _raw;
    [CompilerGeneratedAttribute]
private Integer32 <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Variable> <Variables>k__BackingField;
    private bool _disposed;
    public Integer32 RequestId { get; private set; }
    public Integer32 ErrorStatus { get; private set; }
    public Integer32 ErrorIndex { get; private set; }
    public List`1<Variable> Variables { get; private set; }
    public SnmpType TypeCode { get; }
    public ResponsePdu(int requestId, ErrorCode errorStatus, int errorIndex, List`1<Variable> variables);
    public ResponsePdu(Tuple`2<int, Byte[]> length, Stream stream);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_RequestId();
    [CompilerGeneratedAttribute]
private void set_RequestId(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorStatus();
    [CompilerGeneratedAttribute]
private void set_ErrorStatus(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorIndex();
    [CompilerGeneratedAttribute]
private void set_ErrorIndex(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<Variable> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(List`1<Variable> value);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.Scope : object {
    private Sequence _container;
    [CompilerGeneratedAttribute]
private ISnmpPdu <Pdu>k__BackingField;
    [CompilerGeneratedAttribute]
private OctetString <ContextName>k__BackingField;
    [CompilerGeneratedAttribute]
private OctetString <ContextEngineId>k__BackingField;
    public ISnmpPdu Pdu { get; private set; }
    public OctetString ContextName { get; private set; }
    public OctetString ContextEngineId { get; private set; }
    public Scope(Sequence data);
    public Scope(OctetString contextEngineId, OctetString contextName, ISnmpPdu pdu);
    public Scope(ISnmpPdu pdu);
    [CompilerGeneratedAttribute]
public ISnmpPdu get_Pdu();
    [CompilerGeneratedAttribute]
private void set_Pdu(ISnmpPdu value);
    public sealed virtual ISnmpData GetData(VersionCode version);
    [CompilerGeneratedAttribute]
public OctetString get_ContextName();
    [CompilerGeneratedAttribute]
private void set_ContextName(OctetString value);
    [CompilerGeneratedAttribute]
public OctetString get_ContextEngineId();
    [CompilerGeneratedAttribute]
private void set_ContextEngineId(OctetString value);
    public sealed virtual Sequence ToSequence();
}
public class Lextm.SharpSnmpLib.Security.AES192PrivacyProvider : AESPrivacyProviderBase {
    public AES192PrivacyProvider(OctetString phrase, IAuthenticationProvider auth);
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Security.AES256PrivacyProvider : AESPrivacyProviderBase {
    public AES256PrivacyProvider(OctetString phrase, IAuthenticationProvider auth);
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Security.AESPrivacyProvider : AESPrivacyProviderBase {
    public AESPrivacyProvider(OctetString phrase, IAuthenticationProvider auth);
    public virtual string ToString();
}
public abstract class Lextm.SharpSnmpLib.Security.AESPrivacyProviderBase : object {
    private SaltGenerator _salt;
    private OctetString _phrase;
    [CompilerGeneratedAttribute]
private IAuthenticationProvider <AuthenticationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private OctetString <EngineId>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<OctetString> <EngineIds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyBytes>k__BackingField;
    public static bool IsSupported { get; }
    public IAuthenticationProvider AuthenticationProvider { get; private set; }
    [ObsoleteAttribute("Use EngineIds instead.")]
public OctetString EngineId { get; public set; }
    public ICollection`1<OctetString> EngineIds { get; public set; }
    private static int PrivacyParametersLength { get; }
    private int MinimumKeyLength { get; }
    public int MaximumKeyLength { get; }
    public OctetString Salt { get; }
    public int KeyBytes { get; private set; }
    protected AESPrivacyProviderBase(int keyBytes, OctetString phrase, IAuthenticationProvider auth);
    public static bool get_IsSupported();
    [CompilerGeneratedAttribute]
public sealed virtual IAuthenticationProvider get_AuthenticationProvider();
    [CompilerGeneratedAttribute]
private void set_AuthenticationProvider(IAuthenticationProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual OctetString get_EngineId();
    [CompilerGeneratedAttribute]
public void set_EngineId(OctetString value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<OctetString> get_EngineIds();
    [CompilerGeneratedAttribute]
public void set_EngineIds(ICollection`1<OctetString> value);
    internal Byte[] Encrypt(Byte[] unencryptedData, Byte[] key, int engineBoots, int engineTime, Byte[] privacyParameters);
    internal Byte[] Decrypt(Byte[] encryptedData, Byte[] key, int engineBoots, int engineTime, Byte[] privacyParameters);
    private static int get_PrivacyParametersLength();
    private int get_MinimumKeyLength();
    public int get_MaximumKeyLength();
    public sealed virtual ISnmpData Decrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual ISnmpData Encrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual OctetString get_Salt();
    [CompilerGeneratedAttribute]
public int get_KeyBytes();
    [CompilerGeneratedAttribute]
private void set_KeyBytes(int value);
    public sealed virtual Byte[] PasswordToKey(Byte[] secret, Byte[] engineId);
    public Byte[] ExtendShortKey(Byte[] shortKey, Byte[] password, Byte[] engineID, IAuthenticationProvider authProtocol);
}
[DefaultMemberAttribute("Item")]
public class Lextm.SharpSnmpLib.Security.Cache`2 : object {
    private Dictionary`2<TKey, TValue> _dictionary;
    private Queue`1<TKey> _keyQueue;
    private int _capacity;
    public int Count { get; }
    public TValue Item { get; }
    public Cache`2(int initialCapacity);
    public int get_Count();
    public bool TryGetValue(TKey key, TValue& value);
    public bool ContainsKey(TKey key);
    public TValue get_Item(TKey key);
    public void Add(TKey key, TValue value);
    private void RemoveOldestElement();
    private bool IsCacheFull();
}
public class Lextm.SharpSnmpLib.Security.CryptoKeyCache : object {
    private static int CacheCapacity;
    private Cache`2<string, EngineIdCache> _cryptoCache;
    public CryptoKeyCache(int capacity);
    public bool TryGetCachedValue(Byte[] password, Byte[] engineId, Byte[]& cachedValue);
    public void AddValueToCache(Byte[] password, Byte[] engineId, Byte[] valueToCache);
    private static string Stringanize(Byte[] bytes);
}
[DataContractAttribute]
public class Lextm.SharpSnmpLib.Security.DecryptionException : SnmpException {
    private Byte[] _bytes;
    public DecryptionException(string message);
    public DecryptionException(string message, Exception inner);
    public Byte[] GetBytes();
    public void SetBytes(Byte[] value);
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Security.DefaultAuthenticationProvider : object {
    private static IAuthenticationProvider _instance;
    public static IAuthenticationProvider Instance { get; }
    public OctetString CleanDigest { get; }
    public int DigestLength { get; }
    public static IAuthenticationProvider get_Instance();
    public sealed virtual OctetString ComputeHash(VersionCode version, ISegment header, SecurityParameters parameters, ISnmpData data, IPrivacyProvider privacy, Byte[] length);
    public OctetString ComputeHash(Byte[] buffer, OctetString engineId);
    public sealed virtual OctetString get_CleanDigest();
    public sealed virtual Byte[] PasswordToKey(Byte[] password, Byte[] engineId);
    public sealed virtual int get_DigestLength();
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Security.DefaultPrivacyProvider : object {
    private static IPrivacyProvider _defaultInstance;
    [CompilerGeneratedAttribute]
private IAuthenticationProvider <AuthenticationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private OctetString <EngineId>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<OctetString> <EngineIds>k__BackingField;
    public static IPrivacyProvider DefaultPair { get; }
    public IAuthenticationProvider AuthenticationProvider { get; private set; }
    [ObsoleteAttribute("Use EngineIds instead.")]
public OctetString EngineId { get; public set; }
    public ICollection`1<OctetString> EngineIds { get; public set; }
    public OctetString Salt { get; }
    public DefaultPrivacyProvider(IAuthenticationProvider authentication);
    public static IPrivacyProvider get_DefaultPair();
    [CompilerGeneratedAttribute]
public sealed virtual IAuthenticationProvider get_AuthenticationProvider();
    [CompilerGeneratedAttribute]
private void set_AuthenticationProvider(IAuthenticationProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual OctetString get_EngineId();
    [CompilerGeneratedAttribute]
public void set_EngineId(OctetString value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<OctetString> get_EngineIds();
    [CompilerGeneratedAttribute]
public void set_EngineIds(ICollection`1<OctetString> value);
    public sealed virtual ISnmpData Decrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual ISnmpData Encrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual OctetString get_Salt();
    public sealed virtual Byte[] PasswordToKey(Byte[] secret, Byte[] engineId);
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Security.DESPrivacyProvider : object {
    private SaltGenerator _salt;
    private OctetString _phrase;
    [CompilerGeneratedAttribute]
private IAuthenticationProvider <AuthenticationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private OctetString <EngineId>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<OctetString> <EngineIds>k__BackingField;
    public static bool IsSupported { get; }
    public IAuthenticationProvider AuthenticationProvider { get; private set; }
    [ObsoleteAttribute("Use EngineIds instead.")]
public OctetString EngineId { get; public set; }
    public ICollection`1<OctetString> EngineIds { get; public set; }
    public static int PrivacyParametersLength { get; }
    public static int MinimumKeyLength { get; }
    public static int MaximumKeyLength { get; }
    public OctetString Salt { get; }
    public DESPrivacyProvider(OctetString phrase, IAuthenticationProvider auth);
    public static bool get_IsSupported();
    [CompilerGeneratedAttribute]
public sealed virtual IAuthenticationProvider get_AuthenticationProvider();
    [CompilerGeneratedAttribute]
private void set_AuthenticationProvider(IAuthenticationProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual OctetString get_EngineId();
    [CompilerGeneratedAttribute]
public void set_EngineId(OctetString value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<OctetString> get_EngineIds();
    [CompilerGeneratedAttribute]
public void set_EngineIds(ICollection`1<OctetString> value);
    public static Byte[] Encrypt(Byte[] unencryptedData, Byte[] key, Byte[] privacyParameters);
    public static Byte[] Decrypt(Byte[] encryptedData, Byte[] key, Byte[] privacyParameters);
    private static Byte[] GetIV(IList`1<byte> privacyKey, IList`1<byte> salt);
    private static Byte[] GetKey(Byte[] privacyPassword);
    public static int get_PrivacyParametersLength();
    public static int get_MinimumKeyLength();
    public static int get_MaximumKeyLength();
    public sealed virtual ISnmpData Decrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual ISnmpData Encrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual OctetString get_Salt();
    public sealed virtual Byte[] PasswordToKey(Byte[] secret, Byte[] engineId);
    public virtual string ToString();
}
public interface Lextm.SharpSnmpLib.Security.IAuthenticationProvider {
    public OctetString CleanDigest { get; }
    public int DigestLength { get; }
    public abstract virtual OctetString get_CleanDigest();
    public abstract virtual Byte[] PasswordToKey(Byte[] password, Byte[] engineId);
    public abstract virtual OctetString ComputeHash(VersionCode version, ISegment header, SecurityParameters parameters, ISnmpData data, IPrivacyProvider privacy, Byte[] length);
    public abstract virtual int get_DigestLength();
}
public interface Lextm.SharpSnmpLib.Security.IPrivacyProvider {
    public OctetString Salt { get; }
    public IAuthenticationProvider AuthenticationProvider { get; }
    [ObsoleteAttribute("Use EngineIds instead.")]
public OctetString EngineId { get; }
    public ICollection`1<OctetString> EngineIds { get; }
    public abstract virtual ISnmpData Encrypt(ISnmpData data, SecurityParameters parameters);
    public abstract virtual OctetString get_Salt();
    public abstract virtual ISnmpData Decrypt(ISnmpData data, SecurityParameters parameters);
    public abstract virtual IAuthenticationProvider get_AuthenticationProvider();
    public abstract virtual OctetString get_EngineId();
    public abstract virtual ICollection`1<OctetString> get_EngineIds();
    public abstract virtual Byte[] PasswordToKey(Byte[] secret, Byte[] engineId);
}
public class Lextm.SharpSnmpLib.Security.MD5AuthenticationProvider : object {
    private static int Md5KeyCacheCapacity;
    private static CryptoKeyCache Md5KeyCache;
    private static object Md5KeyCacheLock;
    private Byte[] _password;
    public OctetString CleanDigest { get; }
    public int DigestLength { get; }
    public MD5AuthenticationProvider(OctetString phrase);
    private static MD5AuthenticationProvider();
    public sealed virtual Byte[] PasswordToKey(Byte[] password, Byte[] engineId);
    private Byte[] _PasswordToKey(Byte[] password, Byte[] engineId);
    public sealed virtual OctetString get_CleanDigest();
    public sealed virtual OctetString ComputeHash(VersionCode version, ISegment header, SecurityParameters parameters, ISnmpData data, IPrivacyProvider privacy, Byte[] length);
    public sealed virtual int get_DigestLength();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Lextm.SharpSnmpLib.Security.PrivacyProviderExtension : object {
    [ExtensionAttribute]
public static Levels ToSecurityLevel(IPrivacyProvider privacy);
    [ExtensionAttribute]
public static ISnmpData GetScopeData(IPrivacyProvider privacy, Header header, SecurityParameters parameters, ISnmpData rawScopeData);
    [ExtensionAttribute]
public static void ComputeHash(IPrivacyProvider privacy, VersionCode version, Header header, SecurityParameters parameters, ISegment scope);
    [ExtensionAttribute]
public static bool VerifyHash(IPrivacyProvider privacy, VersionCode version, Header header, SecurityParameters parameters, ISnmpData scopeBytes, Byte[] length);
}
public class Lextm.SharpSnmpLib.Security.SaltGenerator : object {
    private object _root;
    private long _salt;
    internal long NextSalt { get; }
    internal void SetSalt(long salt);
    internal long get_NextSalt();
    public Byte[] GetSaltBytes();
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Security.SHA1AuthenticationProvider : object {
    private static int Sha1KeyCacheCapacity;
    private static CryptoKeyCache Sha1KeyCache;
    private static object Sha1KeyCacheLock;
    private Byte[] _password;
    public OctetString CleanDigest { get; }
    public int DigestLength { get; }
    public SHA1AuthenticationProvider(OctetString phrase);
    private static SHA1AuthenticationProvider();
    public sealed virtual Byte[] PasswordToKey(Byte[] password, Byte[] engineId);
    private Byte[] _PasswordToKey(Byte[] password, Byte[] engineId);
    public sealed virtual OctetString get_CleanDigest();
    public sealed virtual OctetString ComputeHash(VersionCode version, ISegment header, SecurityParameters parameters, ISnmpData data, IPrivacyProvider privacy, Byte[] length);
    public sealed virtual int get_DigestLength();
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Security.SHA256AuthenticationProvider : object {
    private static int Sha256KeyCacheCapacity;
    private static CryptoKeyCache Sha256KeyCache;
    private static object Sha256KeyCacheLock;
    private Byte[] _password;
    public OctetString CleanDigest { get; }
    public int DigestLength { get; }
    public SHA256AuthenticationProvider(OctetString phrase);
    private static SHA256AuthenticationProvider();
    public sealed virtual Byte[] PasswordToKey(Byte[] password, Byte[] engineId);
    private Byte[] _PasswordToKey(Byte[] password, Byte[] engineId);
    public sealed virtual OctetString get_CleanDigest();
    public sealed virtual OctetString ComputeHash(VersionCode version, ISegment header, SecurityParameters parameters, ISnmpData data, IPrivacyProvider privacy, Byte[] length);
    public sealed virtual int get_DigestLength();
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Security.TripleDESPrivacyProvider : object {
    private SaltGenerator _salt;
    private OctetString _phrase;
    [CompilerGeneratedAttribute]
private IAuthenticationProvider <AuthenticationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private OctetString <EngineId>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<OctetString> <EngineIds>k__BackingField;
    public IAuthenticationProvider AuthenticationProvider { get; private set; }
    [ObsoleteAttribute("Use EngineIds instead.")]
public OctetString EngineId { get; public set; }
    public ICollection`1<OctetString> EngineIds { get; public set; }
    public static int PrivacyParametersLength { get; }
    public static int MinimumKeyLength { get; }
    public static int MaximumKeyLength { get; }
    public OctetString Salt { get; }
    public TripleDESPrivacyProvider(OctetString phrase, IAuthenticationProvider auth);
    [CompilerGeneratedAttribute]
public sealed virtual IAuthenticationProvider get_AuthenticationProvider();
    [CompilerGeneratedAttribute]
private void set_AuthenticationProvider(IAuthenticationProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual OctetString get_EngineId();
    [CompilerGeneratedAttribute]
public void set_EngineId(OctetString value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<OctetString> get_EngineIds();
    [CompilerGeneratedAttribute]
public void set_EngineIds(ICollection`1<OctetString> value);
    public static Byte[] Encrypt(Byte[] unencryptedData, Byte[] key, Byte[] privacyParameters);
    public static Byte[] Decrypt(Byte[] encryptedData, Byte[] key, Byte[] privacyParameters);
    private static Byte[] GetIV(IList`1<byte> privacyKey, IList`1<byte> salt);
    private static Byte[] GetKey(Byte[] privacyPassword);
    public static int get_PrivacyParametersLength();
    public static int get_MinimumKeyLength();
    public static int get_MaximumKeyLength();
    public sealed virtual ISnmpData Decrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual ISnmpData Encrypt(ISnmpData data, SecurityParameters parameters);
    public sealed virtual OctetString get_Salt();
    public sealed virtual Byte[] PasswordToKey(Byte[] secret, Byte[] engineId);
    private Byte[] ExtendShortKey(Byte[] shortKey, Byte[] password, Byte[] engineID, IAuthenticationProvider authProtocol);
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Security.User : object {
    [CompilerGeneratedAttribute]
private OctetString <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrivacyProvider <Privacy>k__BackingField;
    public OctetString Name { get; private set; }
    public IPrivacyProvider Privacy { get; private set; }
    public User(OctetString name, IPrivacyProvider privacy);
    [CompilerGeneratedAttribute]
public OctetString get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(OctetString value);
    [CompilerGeneratedAttribute]
public IPrivacyProvider get_Privacy();
    [CompilerGeneratedAttribute]
private void set_Privacy(IPrivacyProvider value);
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.Security.UserRegistry : object {
    private IDictionary`2<OctetString, User> _users;
    public int Count { get; }
    public UserRegistry(User[] users);
    public int get_Count();
    public UserRegistry Add(OctetString userName, IPrivacyProvider privacy);
    public UserRegistry Add(User user);
    public IPrivacyProvider Find(OctetString userName);
    public virtual string ToString();
}
public class Lextm.SharpSnmpLib.SecurityParameters : object {
    [CompilerGeneratedAttribute]
private OctetString <EngineId>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <EngineBoots>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <EngineTime>k__BackingField;
    [CompilerGeneratedAttribute]
private OctetString <UserName>k__BackingField;
    private OctetString _authenticationParameters;
    private Byte[] _length;
    [CompilerGeneratedAttribute]
private OctetString <PrivacyParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInvalid>k__BackingField;
    public OctetString EngineId { get; private set; }
    public Integer32 EngineBoots { get; private set; }
    public Integer32 EngineTime { get; private set; }
    public OctetString UserName { get; private set; }
    public OctetString AuthenticationParameters { get; public set; }
    public OctetString PrivacyParameters { get; private set; }
    public bool IsInvalid { get; public set; }
    public SecurityParameters(OctetString parameters);
    public SecurityParameters(OctetString engineId, Integer32 engineBoots, Integer32 engineTime, OctetString userName, OctetString authenticationParameters, OctetString privacyParameters);
    [CompilerGeneratedAttribute]
public OctetString get_EngineId();
    [CompilerGeneratedAttribute]
private void set_EngineId(OctetString value);
    [CompilerGeneratedAttribute]
public Integer32 get_EngineBoots();
    [CompilerGeneratedAttribute]
private void set_EngineBoots(Integer32 value);
    [CompilerGeneratedAttribute]
public Integer32 get_EngineTime();
    [CompilerGeneratedAttribute]
private void set_EngineTime(Integer32 value);
    [CompilerGeneratedAttribute]
public OctetString get_UserName();
    [CompilerGeneratedAttribute]
private void set_UserName(OctetString value);
    public OctetString get_AuthenticationParameters();
    public void set_AuthenticationParameters(OctetString value);
    [CompilerGeneratedAttribute]
public OctetString get_PrivacyParameters();
    [CompilerGeneratedAttribute]
private void set_PrivacyParameters(OctetString value);
    public static SecurityParameters Create(OctetString userName);
    public sealed virtual Sequence ToSequence();
    public sealed virtual ISnmpData GetData(VersionCode version);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public bool get_IsInvalid();
    [CompilerGeneratedAttribute]
public void set_IsInvalid(bool value);
}
[DefaultMemberAttribute("Item")]
public class Lextm.SharpSnmpLib.Sequence : object {
    private List`1<ISnmpData> _list;
    private Byte[] _length;
    private Byte[] _buffer;
    public int Length { get; }
    public ISnmpData Item { get; }
    public SnmpType TypeCode { get; }
    public Sequence(Byte[] length);
    public Sequence(Byte[] length, ISnmpData item1);
    public Sequence(Byte[] length, ISnmpData item1, ISnmpData item2);
    public Sequence(Byte[] length, ISnmpData item1, ISnmpData item2, ISnmpData item3);
    public Sequence(Byte[] length, ISnmpData item1, ISnmpData item2, ISnmpData item3, ISnmpData item4);
    public Sequence(Byte[] length, ISnmpData item1, ISnmpData item2, ISnmpData item3, ISnmpData item4, ISnmpData item5);
    public Sequence(Byte[] length, ISnmpData item1, ISnmpData item2, ISnmpData item3, ISnmpData item4, ISnmpData item5, ISnmpData item6);
    public Sequence(Byte[] length, ISnmpData[] items);
    public Sequence(IEnumerable`1<ISnmpData> items);
    public Sequence(Tuple`2<int, Byte[]> length, Stream stream);
    public IEnumerator GetEnumerator();
    public int get_Length();
    public ISnmpData get_Item(int index);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public virtual string ToString();
    public Byte[] GetLengthBytes();
    [CompilerGeneratedAttribute]
private void <.ctor>g__AddItem|10_0(ISnmpData item);
}
public class Lextm.SharpSnmpLib.SetRequestPdu : object {
    private Sequence _varbindSection;
    private Byte[] _length;
    private Byte[] _raw;
    [CompilerGeneratedAttribute]
private Integer32 <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <ErrorIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Variable> <Variables>k__BackingField;
    public Integer32 RequestId { get; private set; }
    public Integer32 ErrorStatus { get; private set; }
    public Integer32 ErrorIndex { get; private set; }
    public List`1<Variable> Variables { get; private set; }
    public SnmpType TypeCode { get; }
    public SetRequestPdu(int requestId, List`1<Variable> variables);
    public SetRequestPdu(Tuple`2<int, Byte[]> length, Stream stream);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_RequestId();
    [CompilerGeneratedAttribute]
private void set_RequestId(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorStatus();
    [CompilerGeneratedAttribute]
private void set_ErrorStatus(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_ErrorIndex();
    [CompilerGeneratedAttribute]
private void set_ErrorIndex(Integer32 value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<Variable> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(List`1<Variable> value);
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Lextm.SharpSnmpLib.SnmpDataExtension : object {
    [ExtensionAttribute]
public static Byte[] ToBytes(ISnmpData data);
}
[DataContractAttribute]
public class Lextm.SharpSnmpLib.SnmpException : Exception {
    protected string Details { get; }
    public SnmpException(string message);
    public SnmpException(string message, Exception inner);
    public virtual string ToString();
    protected virtual string get_Details();
}
[DataContractAttribute]
public enum Lextm.SharpSnmpLib.SnmpType : Enum {
    public int value__;
    public static SnmpType EndMarker;
    public static SnmpType Integer32;
    public static SnmpType OctetString;
    public static SnmpType Null;
    public static SnmpType ObjectIdentifier;
    public static SnmpType Sequence;
    public static SnmpType IPAddress;
    public static SnmpType Counter32;
    public static SnmpType Gauge32;
    public static SnmpType TimeTicks;
    public static SnmpType Opaque;
    public static SnmpType NetAddress;
    public static SnmpType Counter64;
    public static SnmpType Unsigned32;
    public static SnmpType NoSuchObject;
    public static SnmpType NoSuchInstance;
    public static SnmpType EndOfMibView;
    public static SnmpType GetRequestPdu;
    public static SnmpType GetNextRequestPdu;
    public static SnmpType ResponsePdu;
    public static SnmpType SetRequestPdu;
    public static SnmpType TrapV1Pdu;
    public static SnmpType GetBulkRequestPdu;
    public static SnmpType InformRequestPdu;
    public static SnmpType TrapV2Pdu;
    public static SnmpType ReportPdu;
    public static SnmpType Unknown;
}
[ExtensionAttribute]
public static class Lextm.SharpSnmpLib.StreamExtension : object {
    [ExtensionAttribute]
internal static Tuple`2<int, Byte[]> ReadPayloadLength(Stream stream);
    [ExtensionAttribute]
internal static void IgnoreBytes(Stream stream, int length);
    [ExtensionAttribute]
internal static void AppendBytes(Stream stream, SnmpType typeCode, Byte[] length, Byte[] raw);
}
[DebuggerDisplayAttribute("{count} ({ToTimeSpan()})")]
public class Lextm.SharpSnmpLib.TimeTicks : object {
    private Counter32 _count;
    public SnmpType TypeCode { get; }
    [CLSCompliantAttribute("False")]
public TimeTicks(UInt32 count);
    public TimeTicks(TimeSpan span);
    internal TimeTicks(Byte[] raw);
    public TimeTicks(Tuple`2<int, Byte[]> length, Stream stream);
    [CLSCompliantAttribute("False")]
public UInt32 ToUInt32();
    public TimeSpan ToTimeSpan();
    public sealed virtual SnmpType get_TypeCode();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    public sealed virtual bool Equals(TimeTicks other);
    public static bool op_Equality(TimeTicks left, TimeTicks right);
    public static bool op_Inequality(TimeTicks left, TimeTicks right);
    public virtual string ToString();
    private static bool Equals(TimeTicks left, TimeTicks right);
}
public class Lextm.SharpSnmpLib.TrapV1Pdu : object {
    private Byte[] _raw;
    private Integer32 _generic;
    private Integer32 _specific;
    private Sequence _varbindSection;
    private Byte[] _length;
    [CompilerGeneratedAttribute]
private ObjectIdentifier <Enterprise>k__BackingField;
    [CompilerGeneratedAttribute]
private IP <AgentAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeTicks <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Variable> <Variables>k__BackingField;
    public Integer32 RequestId { get; }
    public Integer32 ErrorIndex { get; }
    public Integer32 ErrorStatus { get; }
    public SnmpType TypeCode { get; }
    public ObjectIdentifier Enterprise { get; private set; }
    public IP AgentAddress { get; private set; }
    public GenericCode Generic { get; }
    public int Specific { get; }
    public TimeTicks TimeStamp { get; private set; }
    public List`1<Variable> Variables { get; private set; }
    [CLSCompliantAttribute("False")]
public TrapV1Pdu(UInt32[] enterprise, IP agent, Integer32 generic, Integer32 specific, TimeTicks timestamp, List`1<Variable> variables);
    public TrapV1Pdu(ObjectIdentifier enterprise, IP agent, Integer32 generic, Integer32 specific, TimeTicks timestamp, List`1<Variable> variables);
    public TrapV1Pdu(Tuple`2<int, Byte[]> length, Stream stream);
    public sealed virtual Integer32 get_RequestId();
    public sealed virtual Integer32 get_ErrorIndex();
    public sealed virtual Integer32 get_ErrorStatus();
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    [CompilerGeneratedAttribute]
public ObjectIdentifier get_Enterprise();
    [CompilerGeneratedAttribute]
private void set_Enterprise(ObjectIdentifier value);
    [CompilerGeneratedAttribute]
public IP get_AgentAddress();
    [CompilerGeneratedAttribute]
private void set_AgentAddress(IP value);
    public GenericCode get_Generic();
    public int get_Specific();
    [CompilerGeneratedAttribute]
public TimeTicks get_TimeStamp();
    [CompilerGeneratedAttribute]
private void set_TimeStamp(TimeTicks value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<Variable> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(List`1<Variable> value);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.TrapV2Pdu : object {
    private UInt32[] _timeId;
    private UInt32[] _enterpriseId;
    private Sequence _varbindSection;
    private TimeTicks _time;
    private Byte[] _length;
    private Byte[] _raw;
    [CompilerGeneratedAttribute]
private List`1<Variable> <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private Integer32 <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectIdentifier <Enterprise>k__BackingField;
    public List`1<Variable> Variables { get; private set; }
    public Integer32 RequestId { get; private set; }
    public Integer32 ErrorStatus { get; }
    public Integer32 ErrorIndex { get; }
    public SnmpType TypeCode { get; }
    public ObjectIdentifier Enterprise { get; private set; }
    [CLSCompliantAttribute("False")]
public UInt32 TimeStamp { get; }
    [CLSCompliantAttribute("False")]
public TrapV2Pdu(int requestId, ObjectIdentifier enterprise, UInt32 time, List`1<Variable> variables);
    public TrapV2Pdu(Tuple`2<int, Byte[]> length, Stream stream);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<Variable> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(List`1<Variable> value);
    [CompilerGeneratedAttribute]
public sealed virtual Integer32 get_RequestId();
    [CompilerGeneratedAttribute]
private void set_RequestId(Integer32 value);
    public sealed virtual Integer32 get_ErrorStatus();
    public sealed virtual Integer32 get_ErrorIndex();
    public sealed virtual SnmpType get_TypeCode();
    public sealed virtual void AppendBytesTo(Stream stream);
    [CompilerGeneratedAttribute]
public ObjectIdentifier get_Enterprise();
    [CompilerGeneratedAttribute]
private void set_Enterprise(ObjectIdentifier value);
    public UInt32 get_TimeStamp();
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lextm.SharpSnmpLib.Variable : object {
    [CompilerGeneratedAttribute]
private ObjectIdentifier <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ISnmpData <Data>k__BackingField;
    public ObjectIdentifier Id { get; private set; }
    public ISnmpData Data { get; private set; }
    public Variable(ObjectIdentifier id);
    [CLSCompliantAttribute("False")]
public Variable(UInt32[] id);
    [CLSCompliantAttribute("False")]
public Variable(UInt32[] id, ISnmpData data);
    public Variable(ObjectIdentifier id, ISnmpData data);
    [CompilerGeneratedAttribute]
public ObjectIdentifier get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(ObjectIdentifier value);
    [CompilerGeneratedAttribute]
public ISnmpData get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(ISnmpData value);
    internal static List`1<Variable> Transform(Sequence varbindSection);
    internal static Sequence Transform(IList`1<Variable> variables);
    public virtual string ToString();
}
[DataContractAttribute]
public enum Lextm.SharpSnmpLib.VersionCode : Enum {
    public int value__;
    public static VersionCode V1;
    public static VersionCode V2;
    [ObsoleteAttribute("This version of SNMP is obsolete and replaced by v3.")]
public static VersionCode V2U;
    public static VersionCode V3;
}
