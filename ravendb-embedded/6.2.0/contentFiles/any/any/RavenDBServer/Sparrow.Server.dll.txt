public class Sparrow.Server.AsyncManualResetEvent : object {
    private TaskCompletionSource`1 modreq(System.Runtime.CompilerServices.IsVolatile) _tcs;
    private CancellationTokenSource _cts;
    private CancellationToken _token;
    private CancellationTokenRegistration _cancellationTokenRegistration;
    public bool IsSet { get; }
    public AsyncManualResetEvent(CancellationToken token);
    public Task`1<bool> WaitAsync();
    [AsyncStateMachineAttribute("Sparrow.Server.AsyncManualResetEvent/<WaitAsync>d__7")]
public Task`1<bool> WaitAsync(CancellationToken token);
    public bool get_IsSet();
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    public FrozenAwaiter GetFrozenAwaiter();
    public void SetException(Exception e);
    public void Set();
    public void Reset(bool force);
    public void SetAndResetAtomically();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
}
[IsReadOnlyAttribute]
public class Sparrow.Server.Binary.Bit : ValueType {
    public byte Value;
    public bool IsSet { get; }
    public Bit(byte value);
    public bool get_IsSet();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class Sparrow.Server.Binary.BitReader : ValueType {
    private int _length;
    private int _shift;
    private ReadOnlySpan`1<byte> _data;
    public int Length { get; }
    public BitReader(ReadOnlySpan`1<byte> data);
    public BitReader(ReadOnlySpan`1<byte> data, int length, int skipped);
    public int get_Length();
    public void Skip(int bits);
    public Bit Read();
}
public interface Sparrow.Server.Binary.IBitReader {
    public int Length { get; }
    public abstract virtual int get_Length();
    public abstract virtual Bit Read();
}
public class Sparrow.Server.Binary.TypedBitReader`1 : ValueType {
    private int _length;
    private int _shift;
    private T _data;
    public int Length { get; }
    public TypedBitReader`1(T data);
    public TypedBitReader`1(T data, int length, int skipped);
    public sealed virtual int get_Length();
    public void Skip(int bits);
    public sealed virtual Bit Read();
}
[DefaultMemberAttribute("Item")]
public class Sparrow.Server.ByteString : ValueType {
    internal ByteStringStorage* _pointer;
    public ByteStringType Flags { get; }
    public Byte* Ptr { get; }
    public bool IsMutable { get; }
    public bool IsExternal { get; }
    public int Length { get; }
    public int Size { get; }
    public bool HasValue { get; }
    public byte Item { get; }
    internal ByteString(ByteStringStorage* ptr);
    public ByteStringType get_Flags();
    [IsReadOnlyAttribute]
public Byte* get_Ptr();
    public void SetUserDefinedFlags(ByteStringType flags);
    [DoesNotReturnAttribute]
private void ThrowFlagsWithReservedBits();
    public bool get_IsMutable();
    public bool get_IsExternal();
    [IsReadOnlyAttribute]
public int get_Length();
    public int get_Size();
    [IsReadOnlyAttribute]
public bool get_HasValue();
    public byte get_Item(int index);
    public void CopyTo(int from, Byte* dest, int offset, int count);
    public void CopyTo(Span`1<byte> dest);
    public void CopyTo(Byte* dest);
    public void CopyTo(Byte[] dest);
    [IsReadOnlyAttribute]
[ConditionalAttribute("VALIDATE")]
internal void EnsureIsNotBadPointer();
    public void Clear();
    public void CopyTo(int from, Byte[] dest, int offset, int count);
    public virtual string ToString();
    public string ToString(UTF8Encoding encoding);
    public int IndexOf(byte c);
    public string Substring(int length);
    public void Truncate(int newSize);
    [DoesNotReturnAttribute]
private static void ThrowInvalidSize();
    public string ToString(Encoding encoding);
    [ObsoleteAttribute("This is a reference comparison. Use SliceComparer or ByteString.Match instead.", "True")]
public virtual bool Equals(object obj);
    public ulong GetContentHash();
    public virtual int GetHashCode();
    [ObsoleteAttribute("This is a reference comparison. Use SliceComparer or ByteString.Match instead.", "True")]
public static bool op_Equality(ByteString x, ByteString y);
    [ObsoleteAttribute("This is a reference comparison. Use SliceComparer or ByteString.Match instead.", "True")]
public static bool op_Inequality(ByteString x, ByteString y);
    [ObsoleteAttribute("This is a reference comparison. Use SliceComparer or ByteString.Match instead.", "True")]
public sealed virtual bool Equals(ByteString other);
    public bool Match(ByteString other);
    public bool Match(LazyStringValue other);
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<byte> ToReadOnlySpan();
    [IsReadOnlyAttribute]
public Span`1<byte> ToSpan();
    [IsReadOnlyAttribute]
public Span`1<T> ToSpan();
}
public class Sparrow.Server.ByteStringContext : ByteStringContext`1<ByteStringMemoryCache> {
    internal static int ExternalAlignedSize;
    public static int MinBlockSizeInBytes;
    public static int MaxAllocationBlockSizeInBytes;
    public static int DefaultAllocationBlockSizeInBytes;
    public static int MinReusableBlockSizeInBytes;
    private static ByteStringContext();
    public ByteStringContext(SharedMultipleUseFlag lowMemoryFlag, int allocationBlockSize);
}
public class Sparrow.Server.ByteStringContext`1 : object {
    private static long DefragmentationSegmentsThresholdInBytes;
    private static int MinNumberOfSegmentsToDefragment;
    public static TAllocator Allocator;
    [CompilerGeneratedAttribute]
private Action AllocationFailed;
    private static int LogMinBlockSize;
    private List`1<SegmentInformation<TAllocator>> _wholeSegments;
    private int _allocationBlockSize;
    internal long _totalAllocated;
    internal long _currentlyAllocated;
    private List`1<SegmentInformation<TAllocator>> _internalReadyToUseMemorySegments;
    private Int32[] _internalReusableStringPoolCount;
    private FastStack`1[] _internalReusableStringPool;
    private SegmentInformation<TAllocator> _internalCurrent;
    private static int ExternalFastPoolSize;
    private int _externalCurrentLeft;
    private int _externalFastPoolCount;
    private IntPtr[] _externalFastPool;
    private FastStack`1<IntPtr> _externalStringPool;
    private SegmentInformation<TAllocator> _externalCurrent;
    [ThreadStaticAttribute]
public static Char[] ToLowerTempBuffer;
    private bool _disposed;
    private SharedMultipleUseFlag _lowMemoryFlag;
    internal int NumberOfReadyToUseMemorySegments { get; }
    public ByteStringContext`1(SharedMultipleUseFlag lowMemoryFlag, int allocationBlockSize);
    private static ByteStringContext`1();
    [CompilerGeneratedAttribute]
public void add_AllocationFailed(Action value);
    [CompilerGeneratedAttribute]
public void remove_AllocationFailed(Action value);
    public void Wipe();
    public void Reset();
    internal int get_NumberOfReadyToUseMemorySegments();
    public void DefragmentSegments(bool force);
    public int GrowAllocation(ByteString& str, InternalScope& scope, int additionalSize);
    public InternalScope<TAllocator> Allocate(int length, Span`1& output);
    public IDisposable Allocate(int length, Memory`1& buffer);
    public InternalScope<TAllocator> Allocate(int length, ByteString& output);
    public InternalScope<TAllocator> AllocateDirect(int length, ByteString& output);
    public InternalScope<TAllocator> AllocateDirect(int length, ByteStringType type, ByteString& output);
    private static int GetPoolIndexForReuse(int size);
    private static int GetPoolIndexForReservation(int size);
    public virtual string ToString();
    private ByteString AllocateExternal(Byte* valuePtr, int size, ByteStringType type);
    private ByteString AllocateInternal(int length, ByteStringType type);
    private SegmentInformation<TAllocator> GetFromReadyToUseMemorySegments(int allocationUnit);
    private ByteString AllocateInternalUnlikely(int length, int allocationUnit, ByteStringType type);
    public void ToLowerCase(ByteString& str);
    private ByteString Create(Void* ptr, int length, int size, ByteStringType type);
    private ByteString AllocateWholeSegment(int length, ByteStringType type);
    public void ReleaseExternal(ByteString& value);
    public void Release(ByteString& value);
    private SegmentInformation<TAllocator> AllocateSegment(int size);
    [DoesNotReturnAttribute]
private void ThrowInvalidMemorySegmentOnAllocation();
    [DoesNotReturnAttribute]
private void ThrowObjectDisposed();
    private void AllocateExternalSegment(int size);
    public ByteString Skip(ByteString value, int bytesToSkip, ByteStringType type);
    public ByteString Slice(ByteString value, int offset, int size, ByteStringType type);
    public ByteString Clone(ByteString value, ByteStringType type);
    public InternalScope<TAllocator> From(string value, ByteString& str);
    public InternalScope<TAllocator> From(Char* value, int charCount, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(string value, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(ReadOnlySpan`1<char> value, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(ReadOnlySpan`1<char> value, byte endSeparator, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(string value, Encoding encoding, ByteString& str);
    public InternalScope<TAllocator> From(ReadOnlySpan`1<char> value, Encoding encoding, ByteString& str);
    public InternalScope<TAllocator> From(string value, Encoding encoding, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(ReadOnlySpan`1<char> value, Encoding encoding, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(ReadOnlySpan`1<byte> value, int offset, int count, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(ReadOnlySpan`1<byte> value, int offset, int count, ByteString& str);
    public InternalScope<TAllocator> From(ReadOnlySpan`1<byte> value, int size, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(ReadOnlySpan`1<byte> value, ByteString& str);
    public InternalScope<TAllocator> From(ReadOnlySpan`1<byte> value, int size, ByteString& str);
    public InternalScope<TAllocator> From(int value, ByteString& str);
    public InternalScope<TAllocator> From(int value, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(long value, ByteString& str);
    public InternalScope<TAllocator> From(long value, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(short value, ByteString& str);
    public InternalScope<TAllocator> From(short value, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(byte value, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(byte value, ByteString& str);
    public InternalScope<TAllocator> From(Byte* valuePtr, int size, ByteString& str);
    public InternalScope<TAllocator> From(Byte* valuePtr, int size, ByteStringType type, ByteString& str);
    public InternalScope<TAllocator> From(Byte* valuePtr, int size, byte endSeparator, ByteStringType type, ByteString& str);
    public ExternalScope<TAllocator> FromPtr(Byte* valuePtr, int size, ByteStringType type, ByteString& str);
    [ConditionalAttribute("VALIDATE")]
private void PrepareForValidation();
    [ConditionalAttribute("VALIDATE")]
private void RegisterForValidation(Void* _);
    [ConditionalAttribute("VALIDATE")]
private void RegisterForValidation(ByteString _);
    [ConditionalAttribute("VALIDATE")]
private void ValidateAndUnregister(ByteString _);
    public sealed virtual void Dispose();
    private void ReleaseSegment(SegmentInformation<TAllocator> segment);
    [CompilerGeneratedAttribute]
internal static void <AllocateInternal>g__ThrowAllocationLengthIsInvalid|39_0(<>c__DisplayClass39_0& );
}
public class Sparrow.Server.ByteStringDirectAllocator : ValueType {
    public sealed virtual UnmanagedGlobalSegment Allocate(int size, Action allocationFailure);
    public sealed virtual void Free(UnmanagedGlobalSegment memory);
}
public class Sparrow.Server.ByteStringMemoryCache : ValueType {
    private static LightWeightThreadLocal`1<StackHeader`1<UnmanagedGlobalSegment>> SegmentsPool;
    private static SharedMultipleUseFlag LowMemoryFlag;
    private static LowMemoryHandler LowMemoryHandlerInstance;
    public static NativeMemoryCleaner`2<StackHeader`1<UnmanagedGlobalSegment>, UnmanagedGlobalSegment> Cleaner;
    [ThreadStaticAttribute]
private static int _minSize;
    private static ByteStringMemoryCache();
    public sealed virtual UnmanagedGlobalSegment Allocate(int size, Action allocationFailure);
    public sealed virtual void Free(UnmanagedGlobalSegment memory);
    [DoesNotReturnAttribute]
private static void ThrowInvalidMemorySegment();
    public static void CleanForCurrentThread();
}
internal class Sparrow.Server.ByteStringStorage : ValueType {
    public ByteStringType Flags;
    public int Length;
    public Byte* Ptr;
    public int Size;
    public ulong GetContentHash();
}
[FlagsAttribute]
public enum Sparrow.Server.ByteStringType : Enum {
    public byte value__;
    public static ByteStringType Immutable;
    public static ByteStringType Mutable;
    public static ByteStringType External;
    public static ByteStringType Disposed;
    public static ByteStringType Reserved2;
    public static ByteStringType UserDefined1;
    public static ByteStringType UserDefined2;
    public static ByteStringType UserDefined3;
    public static ByteStringType UserDefined4;
    public static ByteStringType ByteStringMask;
    public static ByteStringType UserDefinedMask;
}
public class Sparrow.Server.ByteStringValidationException : Exception {
    public ByteStringValidationException(string message);
    public ByteStringValidationException(string message, Exception inner);
}
public class Sparrow.Server.Collections.AsyncQueue`1 : object {
    private ConcurrentQueue`1<T> _inner;
    private AsyncManualResetEvent _event;
    public int Count { get; }
    public bool IsEmpty { get; }
    public AsyncQueue`1(CancellationToken token);
    public int get_Count();
    public bool get_IsEmpty();
    public void AddIfEmpty(T item);
    public void Enqueue(T item);
    public bool TryDequeue(T& result);
    public T[] GetAll();
    [AsyncStateMachineAttribute("Sparrow.Server.Collections.AsyncQueue`1/<DequeueAsync>d__11")]
public Task`1<T> DequeueAsync();
    [AsyncStateMachineAttribute("Sparrow.Server.Collections.AsyncQueue`1/<TryDequeueAsync>d__12")]
public Task`1<Tuple`2<bool, T>> TryDequeueAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("Sparrow.Server.Collections.AsyncQueue`1/<TryDequeueOfTypeAsync>d__13`1")]
public Task`1<Tuple`2<bool, TValue>> TryDequeueOfTypeAsync(TimeSpan timeout);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class Sparrow.Server.Collections.Persistent.BinaryTree`1 : ValueType {
    private static int ValueMask;
    private static int HasValueMask;
    private static ushort Invalid;
    private Span`1<byte> _storage;
    private Span`1<Node<T>> _nodes;
    private ushort FreeNodes { get; private set; }
    public int MaxNodes { get; }
    public int AvailableNodes { get; }
    public int MemoryUsed { get; }
    public BinaryTree`1(Span`1<byte> storage);
    private ushort get_FreeNodes();
    private void set_FreeNodes(ushort value);
    public int get_MaxNodes();
    public int get_AvailableNodes();
    public int get_MemoryUsed();
    public static BinaryTree`1<T> Create(Span`1<byte> storage);
    public static BinaryTree`1<T> Open(Span`1<byte> storage);
    public void Initialize();
    public void Add(BitReader& key, T value);
    public void Add(UInt32 key, int length, T value);
    public bool Find(BitReader& key, T& value);
    [IsReadOnlyAttribute]
public int FindCommonPrefix(Byte& key, int lengthInBits, int currentBit, T& value);
    [IsReadOnlyAttribute]
public bool FindCommonPrefix(BitReader& key, T& value);
}
public class Sparrow.Server.Collections.SmallSet`2 : object {
    private static int Invalid;
    private int _length;
    private TKey[] _keys;
    private TValue[] _values;
    private Dictionary`2<TKey, TValue> _overflowStorage;
    private int _currentIdx;
    public SmallSet`2(int size);
    public void Add(TKey key, TValue value);
    private int FindKey(TKey key);
    private int RequestWritableBucket();
    public bool TryGetValue(TKey key, TValue& value);
    public void Clear();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <TryGetValue>g__TryGetValueFromOverflowUnlikely|10_0(TValue& value, <>c__DisplayClass10_0& );
}
public class Sparrow.Server.Collections.WeakSmallSet`2 : object {
    private static int Invalid;
    private int _length;
    private TKey[] _keys;
    private TValue[] _values;
    private int _currentIdx;
    public WeakSmallSet`2(int size);
    public void Add(TKey key, TValue value);
    private int FindKey(TKey key);
    private int RequestWritableBucket();
    public bool TryGetValue(TKey key, TValue& value);
    public void Clear();
    public sealed virtual void Dispose();
}
public class Sparrow.Server.Compression.AdaptiveMemoryEncoderState : object {
    private Byte[] _encodingBuffer;
    private Byte[] _decodingBuffer;
    private int _size;
    public Span`1<byte> EncodingTable { get; }
    public Span`1<byte> DecodingTable { get; }
    public bool CanGrow { get; }
    public AdaptiveMemoryEncoderState(int size);
    public sealed virtual Span`1<byte> get_EncodingTable();
    public sealed virtual Span`1<byte> get_DecodingTable();
    public sealed virtual bool get_CanGrow();
    public sealed virtual void Grow(int minimumSize);
    public sealed virtual void Dispose();
}
internal class Sparrow.Server.Compression.Code : ValueType {
    public int Value;
    public sbyte Length;
}
public class Sparrow.Server.Compression.Encoder3Gram`1 : ValueType {
    private TEncoderState _state;
    private int _entries;
    private static ReadOnlySpan`1<byte> EncodingTailTable { get; }
    private static ReadOnlySpan`1<byte> EncodingTailMaskTable { get; }
    public int NumberOfEntries { get; public set; }
    public int MemoryUse { get; }
    public int MaxBitSequenceLength { get; public set; }
    public int MinBitSequenceLength { get; public set; }
    private Span`1<Interval3Gram> EncodingTable { get; }
    public Encoder3Gram`1(TEncoderState state);
    public static int GetDictionarySize(TEncoderState& state);
    public static int GetEntriesTableSize(TEncoderState& state);
    public void Train(TSampleEnumerator& enumerator, int dictionarySize);
    public void EncodeBatch(TSampleEnumerator& data, Span`1<int> outputSizes, TOutputEnumerator& outputBuffers);
    public void DecodeBatch(TSampleEnumerator& data, Span`1<int> outputSize, TOutputEnumerator& outputBuffers);
    private static ReadOnlySpan`1<byte> get_EncodingTailTable();
    private static ReadOnlySpan`1<byte> get_EncodingTailMaskTable();
    public void DecodeBatch(ReadOnlySpan`1<int> dataBits, TSampleEnumerator& data, Span`1<int> outputSize, TOutputEnumerator& outputBuffers);
    public sealed virtual int Encode(ReadOnlySpan`1<byte> key, Span`1<byte> outputBuffer);
    public sealed virtual int Decode(ReadOnlySpan`1<byte> data, Span`1<byte> outputBuffer);
    [SkipLocalsInitAttribute]
public sealed virtual int Decode(int bits, ReadOnlySpan`1<byte> data, Span`1<byte> outputBuffer);
    public int get_NumberOfEntries();
    public void set_NumberOfEntries(int value);
    private static int ReadNumberOfEntries(TEncoderState& encoderState);
    public int get_MemoryUse();
    public sealed virtual int get_MaxBitSequenceLength();
    public void set_MaxBitSequenceLength(int value);
    public sealed virtual int get_MinBitSequenceLength();
    public void set_MinBitSequenceLength(int value);
    private Span`1<Interval3Gram> get_EncodingTable();
    private Interval3Gram& GetEncodingTablePtr();
    private void BuildDictionary(FastList`1& symbolCodeList);
    private static int Lookup(UInt32 symbolValue, Interval3Gram& tablePtr, int numberOfEntries, Code& code);
    private int Lookup(BitReader& reader, Span`1& symbol, Interval3Gram* table, BinaryTree`1& tree, Boolean& endsWithNull);
    public sealed virtual void Dispose();
    private sealed virtual override void Sparrow.Server.Compression.IEncoderAlgorithm.Train(TSampleEnumerator& modreq(System.Runtime.InteropServices.InAttribute) enumerator, int dictionarySize);
    private sealed virtual override void Sparrow.Server.Compression.IEncoderAlgorithm.EncodeBatch(TSampleEnumerator& modreq(System.Runtime.InteropServices.InAttribute) data, Span`1<int> outputSizes, TOutputEnumerator& modreq(System.Runtime.InteropServices.InAttribute) outputBuffer);
    private sealed virtual override void Sparrow.Server.Compression.IEncoderAlgorithm.DecodeBatch(TSampleEnumerator& modreq(System.Runtime.InteropServices.InAttribute) data, Span`1<int> outputSize, TOutputEnumerator& modreq(System.Runtime.InteropServices.InAttribute) outputBuffer);
    private sealed virtual override void Sparrow.Server.Compression.IEncoderAlgorithm.DecodeBatch(ReadOnlySpan`1<int> bits, TSampleEnumerator& modreq(System.Runtime.InteropServices.InAttribute) data, Span`1<int> outputSize, TOutputEnumerator& modreq(System.Runtime.InteropServices.InAttribute) outputBuffer);
}
internal class Sparrow.Server.Compression.Encoder3GramSymbolSelector`1 : object {
    private FastList`1<int> _intervalFrequencies;
    private FastList`1<Symbol> _intervalPrefixes;
    private FastList`1<Symbol> _intervalBoundaries;
    private FastList`1<SymbolFrequency> _mostFrequentSymbols;
    private static int GramSize;
    private Dictionary`2<int, int> _frequencyMap;
    public FastList`1<SymbolFrequency> SelectSymbols(TSampleEnumerator keys, int dictionarySize, FastList`1<SymbolFrequency> symbolFrequenciesList);
    private void CountIntervalFreq(TSampleEnumerator keys, FastList`1<int> intervalFrequencies, FastList`1<Symbol> intervalPrefixes, FastList`1<Symbol> intervalBoundaries);
    private int BinarySearch(int key, FastList`1<Symbol> intervalBoundaries);
    private void FillInGap(FastList`1<SymbolFrequency> mostFrequentSymbols, FastList`1<Symbol> intervalPrefixes, FastList`1<Symbol> intervalBoundaries);
    private int CommonPrefix(Span`1<byte> commonStr, ReadOnlySpan`1<byte> str1, ReadOnlySpan`1<byte> str2);
    private void FillInSingleChar(int start, int last, FastList`1<Symbol> intervalPrefixes, FastList`1<Symbol> intervalBoundaries);
    private void PickMostFreqSymbols(int dictionarySize, FastList`1<SymbolFrequency> mostFrequentSymbols, Dictionary`2<int, int> frequencyMap);
    private void CountSymbolFrequency(TSampleEnumerator keys);
}
public class Sparrow.Server.Compression.HopeEncoder`1 : object {
    private TAlgorithm _encoder;
    private bool _isTrained;
    private int _maxSequenceLength;
    private int _maxSequenceLengthMultiplier;
    private int _minSequenceLength;
    private int _minSequenceLengthMultiplier;
    public HopeEncoder`1(TAlgorithm encoder);
    public void Train(TSampleEnumerator& enumerator, int dictionarySize);
    public void Encode(TSource& inputBuffers, TDestination& outputBuffers, Span`1<int> outputSizes);
    public void Decode(TSource& inputBuffers, TDestination& outputBuffers, Span`1<int> outputSizes);
    [SkipLocalsInitAttribute]
public int Encode(ReadOnlySpan`1& data, Span`1& outputBuffer);
    private int EncodeEscapedUnlikely(ReadOnlySpan`1& data, Span`1& outputBuffer);
    public int Decode(ReadOnlySpan`1& data, Span`1& outputBuffer);
    public int Decode(int bits, ReadOnlySpan`1& data, Span`1& outputBuffer);
    public int GetMaxEncodingBytes(int keySize);
    public int GetMaxDecodingBytes(int keySize);
    [DoesNotReturnAttribute]
private static void ThrowInvalidOperationWithoutTrainedDictionary();
    public sealed virtual void Dispose();
}
internal class Sparrow.Server.Compression.HuTuckerCodeAssigner : object {
    private FastList`1<int> _cachedNodeIndexList;
    private FastList`1<SymbolFrequency> _symbolsList;
    private FastList`1<int> _codeLengthList;
    private FastList`1<Node> _nodesList;
    private Node _root;
    public FastList`1<SymbolCode> AssignCodes(FastList`1<SymbolFrequency> frequency, FastList`1<SymbolCode> symbolCodeList);
    private Code Lookup(int idx);
    private void BuildBinaryTree();
    private int GetMaxCodeLen();
    private void GenerateOptimalCode();
    private void Clear();
}
public interface Sparrow.Server.Compression.IEncoderAlgorithm {
    public int MaxBitSequenceLength { get; }
    public int MinBitSequenceLength { get; }
    public abstract virtual int get_MaxBitSequenceLength();
    public abstract virtual int get_MinBitSequenceLength();
    public abstract virtual void Train(TSampleEnumerator& modreq(System.Runtime.InteropServices.InAttribute) enumerator, int dictionarySize);
    public abstract virtual void EncodeBatch(TSampleEnumerator& modreq(System.Runtime.InteropServices.InAttribute) data, Span`1<int> outputSizes, TOutputEnumerator& modreq(System.Runtime.InteropServices.InAttribute) outputBuffer);
    public abstract virtual void DecodeBatch(TSampleEnumerator& modreq(System.Runtime.InteropServices.InAttribute) data, Span`1<int> outputSize, TOutputEnumerator& modreq(System.Runtime.InteropServices.InAttribute) outputBuffer);
    public abstract virtual void DecodeBatch(ReadOnlySpan`1<int> bits, TSampleEnumerator& modreq(System.Runtime.InteropServices.InAttribute) data, Span`1<int> outputSize, TOutputEnumerator& modreq(System.Runtime.InteropServices.InAttribute) outputBuffer);
    public abstract virtual int Encode(ReadOnlySpan`1<byte> data, Span`1<byte> outputBuffer);
    public abstract virtual int Decode(ReadOnlySpan`1<byte> data, Span`1<byte> outputBuffer);
    public abstract virtual int Decode(int bits, ReadOnlySpan`1<byte> data, Span`1<byte> outputBuffer);
}
public interface Sparrow.Server.Compression.IEncoderState {
    public bool CanGrow { get; }
    public Span`1<byte> EncodingTable { get; }
    public Span`1<byte> DecodingTable { get; }
    public abstract virtual bool get_CanGrow();
    public abstract virtual void Grow(int minimumSize);
    public abstract virtual Span`1<byte> get_EncodingTable();
    public abstract virtual Span`1<byte> get_DecodingTable();
}
internal class Sparrow.Server.Compression.Interval3Gram : ValueType {
    public UInt32 BufferAndLength;
    [FixedBufferAttribute("System.Byte", "3")]
public <KeyBuffer>e__FixedBuffer KeyBuffer;
    public byte _prefixAndKeyLength;
    public Code Code;
    public byte PrefixLength { get; public set; }
    public byte KeyLength { get; public set; }
    public byte get_PrefixLength();
    public void set_PrefixLength(byte value);
    public byte get_KeyLength();
    public void set_KeyLength(byte value);
}
[IsReadOnlyAttribute]
public class Sparrow.Server.Compression.NativeMemoryEncoderState : ValueType {
    private Byte* _buffer;
    private int _size;
    public Span`1<byte> EncodingTable { get; }
    public Span`1<byte> DecodingTable { get; }
    public bool CanGrow { get; }
    public NativeMemoryEncoderState(Byte* buffer, int size);
    public sealed virtual Span`1<byte> get_EncodingTable();
    public sealed virtual Span`1<byte> get_DecodingTable();
    public sealed virtual bool get_CanGrow();
    public sealed virtual void Grow(int minimumSize);
    public sealed virtual void Dispose();
}
internal class Sparrow.Server.Compression.Symbol : ValueType {
    private UInt32 _startKey;
    private byte _length;
    public UInt32 StartKeyAsInt { get; }
    public Span`1<byte> StartKey { get; }
    public int Length { get; }
    public Symbol(ReadOnlySpan`1& startKey);
    public UInt32 get_StartKeyAsInt();
    public Span`1<byte> get_StartKey();
    public int get_Length();
    public virtual string ToString();
}
internal class Sparrow.Server.Compression.SymbolCode : ValueType {
    private UInt32 _startKey;
    public int Length;
    public Code Code;
    public Span`1<byte> StartKey { get; }
    public SymbolCode(ReadOnlySpan`1& startKey, Code& code);
    public Span`1<byte> get_StartKey();
    public virtual string ToString();
}
internal class Sparrow.Server.Compression.SymbolFrequency : ValueType {
    private UInt32 _startKey;
    public int Frequency;
    public int Length;
    public ReadOnlySpan`1<byte> StartKey { get; }
    public SymbolFrequency(ReadOnlySpan`1& startKey, int frequency);
    public ReadOnlySpan`1<byte> get_StartKey();
    public virtual string ToString();
}
public class Sparrow.Server.ContentionLoggingLocker : object {
    private Logger _logger;
    private string _name;
    private object _locker;
    private bool _lockTaken;
    public ContentionLoggingLocker(Logger logger, string name);
    public Release Lock(string caller, int line);
}
internal static class Sparrow.Server.Debugging.DebugStuff : object {
    public static void Attach();
}
internal class Sparrow.Server.Debugging.ElectricFencedMemory : object {
    public static ElectricFencedMemory Instance;
    private static ElectricFencedMemory();
    public Byte* Allocate(int size);
    public void Free(Byte* p);
}
internal static class Sparrow.Server.Debugging.PosixElectricFencedMemory : object {
    public static long usage;
    public static Byte* Allocate(int size);
    public static void Free(Byte* p);
}
internal static class Sparrow.Server.Debugging.Win32ElectricFencedMemory : object {
    public static Byte* Allocate(int size);
    public static void Free(Byte* p);
}
public class Sparrow.Server.Exceptions.DiskFullException : IOException {
    public string DirectoryPath;
    public long CurrentFreeSpace;
    public DiskFullException(string filePath, long requestedFileSize, Nullable`1<long> freeSpace, string msg);
    public DiskFullException(string message);
    public DiskFullException(string message, Exception exception);
}
[ExtensionAttribute]
public static class Sparrow.Server.Extensions.RavenDateTimeExtensions : object {
    [ExtensionAttribute]
public static InternalScope<ByteStringMemoryCache> GetDefaultRavenFormat(DateTime dt, ByteStringContext context, ByteString& value, bool isUtc);
    public static DateTime Max(DateTime dt1, DateTime dt2);
}
[ExtensionAttribute]
public static class Sparrow.Server.Extensions.TcpExtensions : object {
    public static IPGlobalProperties GetIPGlobalPropertiesSafely();
    [ExtensionAttribute]
public static TcpConnectionInformation[] GetActiveTcpConnectionsSafely(IPGlobalProperties properties);
    [ExtensionAttribute]
public static TcpStatistics GetTcpIPv4StatisticsSafely(IPGlobalProperties properties);
    [ExtensionAttribute]
public static TcpStatistics GetTcpIPv6StatisticsSafely(IPGlobalProperties properties);
    [ExtensionAttribute]
public static Nullable`1<long> GetConnectionsAcceptedSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetConnectionsInitiatedSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetCumulativeConnectionsSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetCurrentConnectionsSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetErrorsReceivedSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetFailedConnectionAttemptsSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetMaximumConnectionsSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetMaximumTransmissionTimeoutSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetMinimumTransmissionTimeoutSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetResetConnectionsSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetResetsSentSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetSegmentsReceivedSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetSegmentsResentSafely(TcpStatistics statistics);
    [ExtensionAttribute]
public static Nullable`1<long> GetSegmentsSentSafely(TcpStatistics statistics);
}
[ExtensionAttribute]
public static class Sparrow.Server.Format : object {
    [ExtensionAttribute]
public static string ToBase64Unpadded(Guid guid);
    public static string ToBase64Unpadded(Span`1<byte> bytes);
}
internal static class Sparrow.Server.Global.Constants : object {
}
public interface Sparrow.Server.IByteStringAllocator {
    public abstract virtual UnmanagedGlobalSegment Allocate(int size, Action allocationFailure);
    public abstract virtual void Free(UnmanagedGlobalSegment memory);
}
public class Sparrow.Server.IoChange : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterItem <MeterItem>k__BackingField;
    public string Key { get; }
    public string FileName { get; public set; }
    public MeterItem MeterItem { get; public set; }
    public string get_Key();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public MeterItem get_MeterItem();
    [CompilerGeneratedAttribute]
public void set_MeterItem(MeterItem value);
}
public class Sparrow.Server.IoChangesNotifications : object {
    [CompilerGeneratedAttribute]
private Action`1<IoChange> OnIoChange;
    public bool DisableIoMetrics;
    [CompilerGeneratedAttribute]
public void add_OnIoChange(Action`1<IoChange> value);
    [CompilerGeneratedAttribute]
public void remove_OnIoChange(Action`1<IoChange> value);
    public void RaiseNotifications(string fileName, MeterItem meterItem);
}
[ExtensionAttribute]
internal static class Sparrow.Server.Json.Sync.JsonOperationContextSyncExtensions : object {
    [ExtensionAttribute]
internal static void Write(SyncJsonOperationContext syncContext, Stream stream, BlittableJsonReaderObject json);
    [ExtensionAttribute]
public static BlittableJsonReaderObject ReadForDisk(SyncJsonOperationContext syncContext, Stream stream, string documentId);
    [ExtensionAttribute]
public static BlittableJsonReaderObject ReadForMemory(SyncJsonOperationContext syncContext, Stream stream, string documentId);
    [ExtensionAttribute]
public static BlittableJsonReaderObject ReadForMemory(SyncJsonOperationContext syncContext, string jsonString, string documentId);
    private static BlittableJsonReaderObject ParseToMemory(SyncJsonOperationContext syncContext, Stream stream, string debugTag, UsageMode mode, IBlittableDocumentModifier modifier);
    [ExtensionAttribute]
public static BlittableJsonReaderObject ParseToMemory(SyncJsonOperationContext syncContext, Stream stream, string debugTag, UsageMode mode, MemoryBuffer bytes, IBlittableDocumentModifier modifier);
}
public static class Sparrow.Server.LowMemory.CheckPageFileOnHdd : object {
    private static Logger Log;
    private static string PageFileName;
    private static UInt32 GENERIC_READ;
    private static UInt32 GENERIC_WRITE;
    private static UInt32 FILE_SHARE_READ;
    private static UInt32 FILE_SHARE_WRITE;
    private static UInt32 OPEN_EXISTING;
    private static UInt32 FILE_ATTRIBUTE_NORMAL;
    private static UInt32 FILE_DEVICE_MASS_STORAGE;
    private static UInt32 IOCTL_STORAGE_BASE;
    private static UInt32 FILE_DEVICE_CONTROLLER;
    private static UInt32 IOCTL_SCSI_BASE;
    private static UInt32 METHOD_BUFFERED;
    private static UInt32 FILE_ANY_ACCESS;
    private static UInt32 FILE_READ_ACCESS;
    private static UInt32 FILE_WRITE_ACCESS;
    private static UInt32 IOCTL_VOLUME_BASE;
    private static UInt32 StorageDeviceSeekPenaltyProperty;
    private static UInt32 PropertyStandardQuery;
    private static UInt32 ATA_FLAGS_DATA_IN;
    private static UInt32 FORMAT_MESSAGE_FROM_SYSTEM;
    private static IntPtr INVALID_HANDLE_VALUE;
    private static CheckPageFileOnHdd();
    public static string WindowsIsSwappingOnHddInsteadOfSsd();
    private static RavenDriveType GetDriveType(UInt32 physicalDriveNumber);
    private static IntPtr CreateFileW(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    private static UInt32 CTL_CODE(UInt32 DeviceType, UInt32 Function, UInt32 Method, UInt32 Access);
    private static bool DeviceIoControl(IntPtr hDevice, UInt32 dwIoControlCode, STORAGE_PROPERTY_QUERY& lpInBuffer, UInt32 nInBufferSize, DEVICE_SEEK_PENALTY_DESCRIPTOR& lpOutBuffer, UInt32 nOutBufferSize, UInt32& lpBytesReturned, IntPtr lpOverlapped);
    private static bool DeviceIoControl(IntPtr hDevice, UInt32 dwIoControlCode, ATAIdentifyDeviceQuery& lpInBuffer, UInt32 nInBufferSize, ATAIdentifyDeviceQuery& lpOutBuffer, UInt32 nOutBufferSize, UInt32& lpBytesReturned, IntPtr lpOverlapped);
    private static UInt32 FormatMessage(UInt32 dwFlags, IntPtr lpSource, UInt32 dwMessageId, UInt32 dwLanguageId, StringBuilder lpBuffer, UInt32 nSize, IntPtr Arguments);
    private static RavenDriveType HasNoSeekPenalty(string sDrive);
    private static RavenDriveType HasNominalMediaRotationRate(string sDrive);
    private static string GetErrorMessage(int code);
    private static bool DeviceIoControl(IntPtr hDevice, UInt32 dwIoControlCode, IntPtr lpInBuffer, UInt32 nInBufferSize, VOLUME_DISK_EXTENTS& lpOutBuffer, UInt32 nOutBufferSize, UInt32& lpBytesReturned, IntPtr lpOverlapped);
    public static Nullable`1<UInt32> GetPhysicalDriveNumber(string driveLetter);
    public static string PosixIsSwappingOnHddInsteadOfSsd();
    [CompilerGeneratedAttribute]
internal static bool <PosixIsSwappingOnHddInsteadOfSsd>g__TryFindDisk|41_2(string deviceName, String& disk, <>c__DisplayClass41_0& );
}
public class Sparrow.Server.LowMemory.EarlyOutOfMemoryException : SystemException {
    [CompilerGeneratedAttribute]
private Nullable`1<MemoryInfoResult> <MemoryInfo>k__BackingField;
    public Nullable`1<MemoryInfoResult> MemoryInfo { get; }
    public EarlyOutOfMemoryException(string message, MemoryInfoResult memoryInfo);
    public EarlyOutOfMemoryException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public Nullable`1<MemoryInfoResult> get_MemoryInfo();
}
internal class Sparrow.Server.LowMemory.LowMemoryMonitor : AbstractLowMemoryMonitor {
    private SmapsReader _smapsReader;
    private Byte[][] _buffers;
    public virtual MemoryInfoResult GetMemoryInfoOnce();
    public virtual MemoryInfoResult GetMemoryInfo(bool extended);
    public virtual bool IsEarlyOutOfMemory(MemoryInfoResult memInfo, Size& commitChargeThreshold);
    public virtual DirtyMemoryState GetDirtyMemoryState();
    public virtual void AssertNotAboutToRunOutOfMemory();
    public virtual void Dispose();
}
public static class Sparrow.Server.LowMemory.MemoryInformation : object {
    private static Logger Logger;
    private static Byte[] VmRss;
    private static Byte[] VmSwap;
    private static Byte[] MemAvailable;
    private static Byte[] MemFree;
    private static Byte[] MemTotal;
    private static Byte[] SwapTotal;
    private static Byte[] Committed_AS;
    private static int ProcessId;
    public static Size TotalPhysicalMemory;
    private static bool _failedToGetAvailablePhysicalMemory;
    private static MemoryInfoResult FailedResult;
    public static bool DisableEarlyOutOfMemoryCheck;
    public static bool EnableEarlyOutOfMemoryCheck;
    public static bool EnableEarlyOutOfMemoryChecks;
    private static float _minimumFreeCommittedMemoryPercentage;
    private static Size _maxFreeCommittedMemoryToKeep;
    private static Size _lowMemoryCommitLimitInMb;
    internal static ConcurrentSet`1<StrongReference`1<Func`1<long>>> DirtyMemoryObjects;
    private static bool _reportedQueryJobObjectFailure;
    private static MemoryInformation();
    public static void SetFreeCommittedMemory(float minimumFreeCommittedMemoryPercentage, Size maxFreeCommittedMemoryToKeep, Size lowMemoryCommitLimitInMb);
    public static void AssertNotAboutToRunOutOfMemory();
    internal static bool IsEarlyOutOfMemory(MemoryInfoResult memInfo, Size& commitChargeThreshold);
    private static bool IsEarlyOutOfMemoryInternal(MemoryInfoResult memInfo, bool earlyOutOfMemoryWarning, Size& commitChargeThreshold);
    [DoesNotReturnAttribute]
private static void ThrowInsufficientMemory(MemoryInfoResult memInfo);
    public static bool QueryInformationJobObject(IntPtr hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, Void* lpJobObjectInformation, int cbJobObjectInformationLength, Int32& lpReturnLength);
    public static bool GlobalMemoryStatusEx(MemoryStatusEx* lpBuffer);
    public static bool GetPhysicallyInstalledSystemMemory(Int64& totalMemoryInKb);
    public static ValueTuple`2<long, long> GetMemoryUsageFromProcStatus();
    internal static MemoryInfoResult GetMemoryInformationUsingOneTimeSmapsReader();
    private static bool GetFromProcMemInfo(SmapsReader smapsReader, ProcMemInfoResults& procMemInfoResults);
    internal static MemoryInfoResult GetMemoryInfo(SmapsReader smapsReader, bool extended);
    public static long GetTotalScratchAllocatedMemoryInBytes();
    private static MemoryInfoResult GetMemoryInfoLinux(SmapsReader smapsReader, bool extended);
    private static MemoryInfoResult GetMemoryInfoMacOs(Process process, bool extended);
    private static MemoryInfoResult GetMemoryInfoWindows(Process process, bool extended);
    public static long GetSharedCleanInBytes(Process process);
    private static long GetTotalMapped(FileMappingInfo fileMappingInfo);
    public static long GetWorkingSetInBytes();
    internal static DirtyMemoryState GetDirtyMemoryState();
    [CompilerGeneratedAttribute]
internal static Size <IsEarlyOutOfMemoryInternal>g__GetMinCommittedToKeep|25_0(Size currentValue, <>c__DisplayClass25_0& );
}
public class Sparrow.Server.Meters.DatabasePerformanceMetrics : object {
    private PerformanceMetrics _buffer;
    public PerformanceMetrics Buffer { get; }
    public DatabasePerformanceMetrics(MetricType type, int currentBufferSize, int summaryBufferSize);
    public PerformanceMetrics get_Buffer();
    public DurationMeasurement MeterPerformanceRate();
}
internal class Sparrow.Server.Meters.GeneralWaitPerformanceMetrics : PerformanceMetrics {
    public GeneralWaitPerformanceMetrics(int currentBufferSize, int summaryBufferSize);
    protected virtual void Mark(long counter, long commandsCounter, DateTime start, DateTime end);
    public virtual DynamicJsonValue ToJson();
    [IteratorStateMachineAttribute("Sparrow.Server.Meters.GeneralWaitPerformanceMetrics/<GetCurrentItems>d__3")]
private IEnumerable`1<MeterItem> GetCurrentItems();
    private List`1<MeterItem> GetRecentMetrics();
    protected virtual void MarkInternalWindowStart();
    protected virtual void MarkInternalWindowEnd();
}
public class Sparrow.Server.Meters.IoMeterBuffer : object {
    private MeterItem[] _buffer;
    private int _bufferPos;
    private SummerizedItem[] _summerizedBuffer;
    private int _summerizedPos;
    public IoMeterBuffer(int metricsBufferSize, int summaryBufferSize);
    [IteratorStateMachineAttribute("Sparrow.Server.Meters.IoMeterBuffer/<GetSummerizedItems>d__7")]
public IEnumerable`1<SummerizedItem> GetSummerizedItems();
    [IteratorStateMachineAttribute("Sparrow.Server.Meters.IoMeterBuffer/<GetCurrentItems>d__8")]
public IEnumerable`1<MeterItem> GetCurrentItems();
    public void RemoveUntil(long ticks);
    internal void Mark(DurationMeasurement& item);
}
public class Sparrow.Server.Meters.IoMetrics : object {
    private ConcurrentDictionary`2<string, FileIoMetrics> _fileMetrics;
    private ConcurrentQueue`1<string> _closedFiles;
    private IoChangesNotifications _ioChanges;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SummaryBufferSize>k__BackingField;
    public int BufferSize { get; }
    public int SummaryBufferSize { get; }
    public IEnumerable`1<FileIoMetrics> Files { get; }
    public IoMetrics(int currentBufferSize, int summaryBufferSize, IoChangesNotifications ioChanges);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public int get_SummaryBufferSize();
    public IEnumerable`1<FileIoMetrics> get_Files();
    public void FileClosed(string filename);
    public DurationMeasurement MeterIoRate(string fileName, MeterType type, long size);
}
public abstract class Sparrow.Server.Meters.PerformanceMetrics : object {
    protected MeterItem[] Buffer;
    protected long BufferPos;
    private SummerizedItem[] _summerizedBuffer;
    private long _summerizedPos;
    protected MetricType Type;
    protected PerformanceMetrics(int currentBufferSize, int summaryBufferSize);
    protected void StoreInSummarizeItem(MeterItem meterItem, int adjustedTail);
    protected void AddHistoryStats(IEnumerable`1<SummerizedItem> history, PerformanceMetricsStats stats);
    [IteratorStateMachineAttribute("Sparrow.Server.Meters.PerformanceMetrics/<GetSummerizedItems>d__13")]
protected IEnumerable`1<SummerizedItem> GetSummerizedItems();
    protected abstract virtual void MarkInternalWindowStart();
    protected abstract virtual void MarkInternalWindowEnd();
    protected abstract virtual void Mark(long counter, long commandsCounter, DateTime start, DateTime end);
    public abstract virtual DynamicJsonValue ToJson();
}
internal class Sparrow.Server.Meters.TransactionPerformanceMetrics : PerformanceMetrics {
    private InternalWindowDuration _lastState;
    private InternalWindowDuration _tail;
    public TransactionPerformanceMetrics(int currentBufferSize, int summaryBufferSize);
    protected virtual void MarkInternalWindowStart();
    protected virtual void MarkInternalWindowEnd();
    protected virtual void Mark(long counter, long commandsCounter, DateTime start, DateTime end);
    public virtual DynamicJsonValue ToJson();
    [IteratorStateMachineAttribute("Sparrow.Server.Meters.TransactionPerformanceMetrics/<GetCurrentItems>d__10")]
private IEnumerable`1<TransactionMeterItem> GetCurrentItems();
    private List`1<TransactionMeterItem> GetRecentMetrics();
}
public static class Sparrow.Server.Platform.Pal : object {
    public static SystemInformation SysInfo;
    public static int PAL_VER;
    private static string LIBRVNPAL;
    private static Pal();
    public static FailCodes rvn_write_header(string filename, Void* header, int size, Int32& errorCode);
    public static FailCodes rvn_write_header(Byte* filename, Void* header, int size, Int32& errorCode);
    public static int rvn_get_error_string(int errorCode, Void* sb, int capacity, Int32& specialErrnoCodes);
    public static FailCodes rvn_create_and_mmap64_file(string filename, long initialFileSize, MmapOptions flags, SafeMmapHandle& handle, Void*& baseAddress, Int64& actualFileSize, Int32& errorCode);
    public static FailCodes rvn_create_and_mmap64_file(Byte* filename, long initialFileSize, MmapOptions flags, SafeMmapHandle& handle, Void*& baseAddress, Int64& actualFileSize, Int32& errorCode);
    public static FailCodes rvn_prefetch_virtual_memory(Void* virtualAddress, long length, Int32& errorCode);
    private static FailCodes rvn_get_system_information(SystemInformation& systemInformation, Int32& errorCode);
    public static FailCodes rvn_memory_sync(Void* address, long size, Int32& errorCode);
    public static FailCodes rvn_mmap_dispose_handle(IntPtr handle, Int32& errorCode);
    public static FailCodes rvn_unmap(MmapOptions flags, Void* address, long size, Int32& errorCode);
    public static FailCodes rvn_prefetch_ranges(PrefetchRanges* list, int count, Int32& errorCode);
    public static FailCodes rvn_protect_range(Void* start, long size, ProtectRange protection, Int32& errorCode);
    public static FailCodes rvn_allocate_more_space(long newLengthAfterAdjustment, SafeMmapHandle handle, Void*& newAddress, Int32& errorCode);
    public static FailCodes rvn_open_journal_for_writes(string filename, JournalMode mode, long requiredSize, DurabilityMode supportDurability, SafeJournalHandle& handle, Int64& actualSize, Int32& errorCode);
    public static FailCodes rvn_open_journal_for_writes(Byte* fileName, JournalMode mode, long requiredSize, DurabilityMode supportDurability, SafeJournalHandle& handle, Int64& actualSize, Int32& errorCode);
    public static FailCodes rvn_close_journal(IntPtr handle, Int32& errorCode);
    public static FailCodes rvn_write_journal(SafeJournalHandle handle, Void* buffer, long size, long offset, Int32& errorCode);
    public static FailCodes rvn_read_journal(SafeJournalHandle handle, Void* buffer, long requiredSize, long offset, Int64& actualSize, Int32& errorCode);
    public static FailCodes rvn_truncate_journal(SafeJournalHandle handle, long size, Int32& errorCode);
    public static FailCodes rvn_get_path_disk_space(string filename, UInt64& totalFreeSizeInBytes, UInt64& totalSizeInBytes, Int32& errorCode);
    public static FailCodes rvn_get_path_disk_space(Byte* path, UInt64& totalFreeSizeInBytes, UInt64& totalSizeInBytes, Int32& errorCode);
    public static FailCodes rvn_open_journal_for_reads(string filename, SafeJournalHandle& handle, Int32& errorCode);
    public static FailCodes rvn_open_journal_for_reads(Byte* fileNameFullPath, SafeJournalHandle& handle, Int32& errorCode);
    public static int rvn_discard_virtual_memory(Void* address, long size, Int32& errorCode);
    public static FailCodes rvn_test_storage_durability(string tempFilename, Int32& errorCode);
    public static FailCodes rvn_test_storage_durability(Byte* tempFilename, Int32& errorCode);
    public static int rvn_get_pal_ver();
    public static long rvn_get_current_thread_id();
    [CompilerGeneratedAttribute]
internal static string <.cctor>g__ToWin7DllName|2_0(string name);
}
public class Sparrow.Server.Platform.PalDefinitions : object {
    public static int AllocationGranularity;
}
public static class Sparrow.Server.Platform.PalFlags : object {
}
public static class Sparrow.Server.Platform.PalHelper : object {
    private static int ERROR_WRITE_PROTECT;
    public static string ErrorMediaIsWriteProtectedHintMessage;
    [DoesNotReturnAttribute]
public static void ThrowLastError(FailCodes rc, int lastError, string msg);
    public static string GetNativeErrorString(int lastError, string msg, ErrnoSpecialCodes& errnoSpecialCodes);
}
public static class Sparrow.Server.Platform.PlatformSpecific : object {
}
public abstract class Sparrow.Server.Platform.Posix.CGroup : object {
    protected static Logger Logger;
    public static string PROC_SELF_CGROUP_FILENAME;
    public static string PROC_MOUNTINFO_FILENAME;
    public static string PROC_CGROUPS_FILENAME;
    private static string MEMORY_CONTROLLER_NAME;
    private Lazy`1<CachedPath> _groupPathForMemory;
    private static Regex FindHierarchyMountReg;
    private static Regex FindControllerGroupsAvailability;
    protected string MemoryLimitFileName { get; }
    protected string MemoryUsageFileName { get; }
    protected string MaxMemoryUsageFileName { get; }
    private static CGroup();
    protected abstract virtual string get_MemoryLimitFileName();
    protected abstract virtual string get_MemoryUsageFileName();
    protected abstract virtual string get_MaxMemoryUsageFileName();
    public virtual Nullable`1<long> GetMaxMemoryUsage();
    public Nullable`1<long> GetPhysicalMemoryUsage();
    public Nullable`1<long> GetPhysicalMemoryLimit();
    private Lazy`1<CachedPath> GetGroupPathForMemory();
    private Lazy`1<CachedPath> CreateNewLazyCachedPath();
    private static bool CheckLimitValues(string textValue, Nullable`1& value);
    protected Nullable`1<long> ReadValue(string file, CheckSpecialValues checkSpecialValues, bool retry);
    private string FindCGroupPathForMemory();
    protected abstract virtual string FindCGroupPathForMemoryInternal();
    [IteratorStateMachineAttribute("Sparrow.Server.Platform.Posix.CGroup/<FindHierarchyMount>d__24")]
protected static IEnumerable`1<Match> FindHierarchyMount();
    protected static string CombinePaths(string mountRoot, string mountPath, string pathForSubsystem);
    private bool IsControllerGroupsAvailable(string subsysName);
    private static Nullable`1<long> ReadMemoryValueFromFile(string fileName, CheckSpecialValues checkSpecialValues);
    public bool ForTestIsControllerMemoryGroupsAvailable();
    public string ForTestFindCGroupPathForMemory();
    [CompilerGeneratedAttribute]
private CachedPath <CreateNewLazyCachedPath>b__18_0();
}
public class Sparrow.Server.Platform.Posix.CGroupException : Exception {
    public CGroupException(string message);
}
public static class Sparrow.Server.Platform.Posix.CGroupHelper : object {
    public static CGroup CGroup;
    private static CGroupHelper();
    private static CGroup GetCGroup();
}
public class Sparrow.Server.Platform.Posix.CGroupV1 : CGroup {
    private static Regex FindCGroupPathForSubsystemReg;
    protected string MemoryLimitFileName { get; }
    protected string MemoryUsageFileName { get; }
    protected string MaxMemoryUsageFileName { get; }
    private static CGroupV1();
    protected virtual string get_MemoryLimitFileName();
    protected virtual string get_MemoryUsageFileName();
    protected virtual string get_MaxMemoryUsageFileName();
    protected virtual string FindCGroupPathForMemoryInternal();
    private static string FindCGroupPath(Predicate`1<IEnumerable`1<string>> isSubSystem);
    private static void FindHierarchyMount(Predicate`1<IEnumerable`1<string>> isSubSystem, String& mountRoot, String& mountPath);
    private static string FindCGroupPathForSubsystem(Predicate`1<IEnumerable`1<string>> isSubSystem);
}
public class Sparrow.Server.Platform.Posix.CGroupV2 : CGroup {
    private bool _hasMemoryPeakFile;
    private static Regex FindCGroupPathForSubsystemReg;
    protected string MemoryLimitFileName { get; }
    protected string MemoryUsageFileName { get; }
    protected string MaxMemoryUsageFileName { get; }
    private static CGroupV2();
    protected virtual string get_MemoryLimitFileName();
    protected virtual string get_MemoryUsageFileName();
    protected virtual string get_MaxMemoryUsageFileName();
    protected virtual string FindCGroupPathForMemoryInternal();
    private static string FindCGroupPath();
    private static void FindHierarchyMount(String& mountRoot, String& mountPath);
    private static string FindCGroupPathForSubsystem();
    public virtual Nullable`1<long> GetMaxMemoryUsage();
}
public enum Sparrow.Server.Platform.Posix.Errno : Enum {
    public int value__;
    public static Errno NONE;
    public static Errno EPERM;
    public static Errno ENOENT;
    public static Errno ESRCH;
    public static Errno EINTR;
    public static Errno EIO;
    public static Errno ENXIO;
    public static Errno E2BIG;
    public static Errno ENOEXEC;
    public static Errno EBADF;
    public static Errno ECHILD;
    public static Errno EAGAIN;
    public static Errno ENOMEM;
    public static Errno EACCES;
    public static Errno EFAULT;
    public static Errno ENOTBLK;
    public static Errno EBUSY;
    public static Errno EEXIST;
    public static Errno EXDEV;
    public static Errno ENODEV;
    public static Errno ENOTDIR;
    public static Errno EISDIR;
    public static Errno EINVAL;
    public static Errno ENFILE;
    public static Errno EMFILE;
    public static Errno ENOTTY;
    public static Errno ETXTBSY;
    public static Errno EFBIG;
    public static Errno ENOSPC;
    public static Errno ESPIPE;
    public static Errno EROFS;
    public static Errno EMLINK;
    public static Errno EPIPE;
    public static Errno EDOM;
    public static Errno ERANGE;
    public static Errno EDEADLK;
    public static Errno ENAMETOOLONG;
    public static Errno ENOLCK;
    public static Errno ENOSYS;
    public static Errno ENOTEMPTY;
    public static Errno ELOOP;
    public static Errno EWOULDBLOCK;
    public static Errno ENOMSG;
    public static Errno EIDRM;
    public static Errno ECHRNG;
    public static Errno EL2NSYNC;
    public static Errno EL3HLT;
    public static Errno EL3RST;
    public static Errno ELNRNG;
    public static Errno EUNATCH;
    public static Errno ENOCSI;
    public static Errno EL2HLT;
    public static Errno EBADE;
    public static Errno EBADR;
    public static Errno EXFULL;
    public static Errno ENOANO;
    public static Errno EBADRQC;
    public static Errno EBADSLT;
    public static Errno EDEADLOCK;
    public static Errno EBFONT;
    public static Errno ENOSTR;
    public static Errno ENODATA;
    public static Errno ETIME;
    public static Errno ENOSR;
    public static Errno ENONET;
    public static Errno ENOPKG;
    public static Errno EREMOTE;
    public static Errno ENOLINK;
    public static Errno EADV;
    public static Errno ESRMNT;
    public static Errno ECOMM;
    public static Errno EPROTO;
    public static Errno EMULTIHOP;
    public static Errno EDOTDOT;
    public static Errno EBADMSG;
    public static Errno EOVERFLOW;
    public static Errno ENOTUNIQ;
    public static Errno EBADFD;
    public static Errno EREMCHG;
    public static Errno ELIBACC;
    public static Errno ELIBBAD;
    public static Errno ELIBSCN;
    public static Errno ELIBMAX;
    public static Errno ELIBEXEC;
    public static Errno EILSEQ;
    public static Errno ERESTART;
    public static Errno ESTRPIPE;
    public static Errno EUSERS;
    public static Errno ENOTSOCK;
    public static Errno EDESTADDRREQ;
    public static Errno EMSGSIZE;
    public static Errno EPROTOTYPE;
    public static Errno ENOPROTOOPT;
    public static Errno EPROTONOSUPPORT;
    public static Errno ESOCKTNOSUPPORT;
    public static Errno EOPNOTSUPP;
    public static Errno EPFNOSUPPORT;
    public static Errno EAFNOSUPPORT;
    public static Errno EADDRINUSE;
    public static Errno EADDRNOTAVAIL;
    public static Errno ENETDOWN;
    public static Errno ENETUNREACH;
    public static Errno ENETRESET;
    public static Errno ECONNABORTED;
    public static Errno ECONNRESET;
    public static Errno ENOBUFS;
    public static Errno EISCONN;
    public static Errno ENOTCONN;
    public static Errno ESHUTDOWN;
    public static Errno ETOOMANYREFS;
    public static Errno ETIMEDOUT;
    public static Errno ECONNREFUSED;
    public static Errno EHOSTDOWN;
    public static Errno EHOSTUNREACH;
    public static Errno EALREADY;
    public static Errno EINPROGRESS;
    public static Errno ESTALE;
    public static Errno EUCLEAN;
    public static Errno ENOTNAM;
    public static Errno ENAVAIL;
    public static Errno EISNAM;
    public static Errno EREMOTEIO;
    public static Errno EDQUOT;
    public static Errno ENOMEDIUM;
    public static Errno EMEDIUMTYPE;
    public static Errno ECANCELED;
    public static Errno ENOKEY;
    public static Errno EKEYEXPIRED;
    public static Errno EKEYREVOKED;
    public static Errno EKEYREJECTED;
    public static Errno EOWNERDEAD;
    public static Errno ENOTRECOVERABLE;
    public static Errno EPROCLIM;
    public static Errno EBADRPC;
    public static Errno ERPCMISMATCH;
    public static Errno EPROGUNAVAIL;
    public static Errno EPROGMISMATCH;
    public static Errno EPROCUNAVAIL;
    public static Errno EFTYPE;
    public static Errno EAUTH;
    public static Errno ENEEDAUTH;
    public static Errno EPWROFF;
    public static Errno EDEVERR;
    public static Errno EBADEXEC;
    public static Errno EBADARCH;
    public static Errno ESHLIBVERS;
    public static Errno EBADMACHO;
    public static Errno ENOATTR;
    public static Errno ENOPOLICY;
}
[FlagsAttribute]
public enum Sparrow.Server.Platform.Posix.FcntlCommands : Enum {
    public int value__;
    public static FcntlCommands F_NOCACHE;
    public static FcntlCommands F_FULLFSYNC;
}
[FlagsAttribute]
public enum Sparrow.Server.Platform.Posix.FilePermissions : Enum {
    public ushort value__;
    public static FilePermissions S_ISUID;
    public static FilePermissions S_ISGID;
    public static FilePermissions S_ISVTX;
    public static FilePermissions S_IRUSR;
    public static FilePermissions S_IWUSR;
    public static FilePermissions S_IXUSR;
    public static FilePermissions S_IRGRP;
    public static FilePermissions S_IWGRP;
    public static FilePermissions S_IXGRP;
    public static FilePermissions S_IROTH;
    public static FilePermissions S_IWOTH;
    public static FilePermissions S_IXOTH;
    public static FilePermissions S_IRWXG;
    public static FilePermissions S_IRWXU;
    public static FilePermissions S_IRWXO;
    public static FilePermissions ACCESSPERMS;
    public static FilePermissions ALLPERMS;
    public static FilePermissions DEFFILEMODE;
    public static FilePermissions S_IFMT;
    public static FilePermissions S_IFDIR;
    public static FilePermissions S_IFCHR;
    public static FilePermissions S_IFBLK;
    public static FilePermissions S_IFREG;
    public static FilePermissions S_IFIFO;
    public static FilePermissions S_IFLNK;
    public static FilePermissions S_IFSOCK;
}
public class Sparrow.Server.Platform.Posix.fsid_t : ValueType {
    public int val1;
    public int val2;
}
public class Sparrow.Server.Platform.Posix.Iovec : ValueType {
    public IntPtr iov_base;
    public UIntPtr iov_len;
}
internal interface Sparrow.Server.Platform.Posix.ISmapsReaderResultAction {
    public abstract virtual void Add(SmapsReaderResults results);
}
internal static class Sparrow.Server.Platform.Posix.KernelVirtualFileSystemUtils : object {
    private static Logger Logger;
    private static ConcurrentSet`1<string> IsOldFileAlert;
    private static ConcurrentSet`1<string> MissingCgroupFiles;
    private static KernelVirtualFileSystemUtils();
    public static Nullable`1<long> ReadNumberFromCgroupFile(string fileName);
    public static int ReadNumberOfCoresFromCgroupFile(string filename);
    public static ValueTuple`2[] ReadSwapInformationFromSwapsFile();
    public static ValueTuple`2[] ReadSwapInformationFromSwapsFile(string filename);
    public static long ReadNumberFromFile(string filename);
    public static HashSet`1<string> GetAllDisksFromPartitionsFile();
    public static string ReadLineFromFile(string path, string filter);
}
public enum Sparrow.Server.Platform.Posix.macOS.CpuState : Enum {
    public int value__;
    public static CpuState CPU_STATE_USER;
    public static CpuState CPU_STATE_SYSTEM;
    public static CpuState CPU_STATE_IDLE;
    public static CpuState CPU_STATE_NICE;
    public static CpuState CPU_STATE_MAX;
}
internal enum Sparrow.Server.Platform.Posix.macOS.CtkHwIdentifiers : Enum {
    public int value__;
    public static CtkHwIdentifiers HW_MACHINE;
    public static CtkHwIdentifiers HW_MODEL;
    public static CtkHwIdentifiers HW_NCPU;
    public static CtkHwIdentifiers HW_BYTEORDER;
    public static CtkHwIdentifiers HW_PHYSMEM;
    public static CtkHwIdentifiers HW_USERMEM;
    public static CtkHwIdentifiers HW_PAGESIZE;
    public static CtkHwIdentifiers HW_DISKNAMES;
    public static CtkHwIdentifiers HW_DISKSTATS;
    public static CtkHwIdentifiers HW_EPOCH;
    public static CtkHwIdentifiers HW_FLOATINGPT;
    public static CtkHwIdentifiers HW_MACHINE_ARCH;
    public static CtkHwIdentifiers HW_VECTORUNIT;
    public static CtkHwIdentifiers HW_BUS_FREQ;
    public static CtkHwIdentifiers HW_CPU_FREQ;
    public static CtkHwIdentifiers HW_CACHELINE;
    public static CtkHwIdentifiers HW_L1ICACHESIZE;
    public static CtkHwIdentifiers HW_L1DCACHESIZE;
    public static CtkHwIdentifiers HW_L2SETTINGS;
    public static CtkHwIdentifiers HW_L2CACHESIZE;
    public static CtkHwIdentifiers HW_L3SETTINGS;
    public static CtkHwIdentifiers HW_L3CACHESIZE;
    public static CtkHwIdentifiers HW_TB_FREQ;
    public static CtkHwIdentifiers HW_MEMSIZE;
    public static CtkHwIdentifiers HW_AVAILCPU;
    public static CtkHwIdentifiers HW_MAXID;
}
internal enum Sparrow.Server.Platform.Posix.macOS.CtlVmIdentifiers : Enum {
    public int value__;
    public static CtlVmIdentifiers VM_METER;
    public static CtlVmIdentifiers VM_LOADAVG;
    public static CtlVmIdentifiers VM_MACHFACTOR;
    public static CtlVmIdentifiers VM_SWAPUSAGE;
    public static CtlVmIdentifiers VM_MAXID;
}
internal enum Sparrow.Server.Platform.Posix.macOS.Flavor : Enum {
    public int value__;
    public static Flavor HOST_LOAD_INFO;
    public static Flavor HOST_VM_INFO;
    public static Flavor HOST_CPU_LOAD_INFO;
    public static Flavor HOST_VM_INFO64;
    public static Flavor HOST_EXTMOD_INFO64;
    public static Flavor HOST_EXPIRED_TASK_INFO;
}
public class Sparrow.Server.Platform.Posix.macOS.host_cpu_load_info : ValueType {
    [FixedBufferAttribute("System.UInt32", "4")]
public <cpu_ticks>e__FixedBuffer cpu_ticks;
}
internal static class Sparrow.Server.Platform.Posix.macOS.macSyscall : object {
    private static string Pthread;
    private static string LIBC_6;
    public static int sysctl(Int32[] name, UInt32 nameLen, Void* oldP, Int32* oldLenP, Void* newP, UIntPtr newLen);
    public static int mach_host_self();
    public static int host_page_size(int machHost, UInt32* pageSize);
    public static int host_statistics64(int machHost, int flavor, Void* hostInfoT, Int32* hostInfoCount);
    public static int proc_pidinfo(int pid, int flavor, ulong arg, Void* buffer, int bufferSize);
    public static ulong pthread_self();
}
internal enum Sparrow.Server.Platform.Posix.macOS.TopLevelIdentifiers : Enum {
    public int value__;
    public static TopLevelIdentifiers CTL_UNSPEC;
    public static TopLevelIdentifiers CTL_KERN;
    public static TopLevelIdentifiers CTL_VM;
    public static TopLevelIdentifiers CTL_VFS;
    public static TopLevelIdentifiers CTL_NET;
    public static TopLevelIdentifiers CTL_DEBUG;
    public static TopLevelIdentifiers CTL_HW;
    public static TopLevelIdentifiers CTL_MACHDEP;
    public static TopLevelIdentifiers CTL_USER;
    public static TopLevelIdentifiers CTL_MAXID;
}
internal class Sparrow.Server.Platform.Posix.macOS.vm_statistics64 : ValueType {
    private UInt32 free_count;
    private UInt32 active_count;
    private UInt32 inactive_count;
    private UInt32 wire_count;
    private ulong zero_fill_count;
    private ulong reactivations;
    private ulong pageins;
    private ulong pageouts;
    private ulong faults;
    private ulong cow_faults;
    private ulong lookups;
    private ulong hits;
    private ulong purges;
    private UInt32 purgeable_count;
    private UInt32 speculative_count;
    public UInt32 FreePagesCount { get; }
    public UInt32 ActivePagesCount { get; }
    public UInt32 InactivePagesCount { get; }
    public UInt32 WirePagesCount { get; }
    public UInt32 get_FreePagesCount();
    public UInt32 get_ActivePagesCount();
    public UInt32 get_InactivePagesCount();
    public UInt32 get_WirePagesCount();
}
internal class Sparrow.Server.Platform.Posix.macOS.xsw_usage : ValueType {
    public ulong xsu_total;
    public ulong xsu_avail;
    public ulong xsu_used;
    public UInt32 xsu_pagesize;
    public bool xsu_encrypted;
}
[FlagsAttribute]
public enum Sparrow.Server.Platform.Posix.MAdvFlags : Enum {
    public int value__;
    public static MAdvFlags MADV_NORMAL;
    public static MAdvFlags MADV_RANDOM;
    public static MAdvFlags MADV_SEQUENTIAL;
    public static MAdvFlags MADV_WILLNEED;
    public static MAdvFlags MADV_DONTNEED;
    public static MAdvFlags MADV_FREE;
    public static MAdvFlags MADV_ACCESS_DEFAULT;
    public static MAdvFlags MADV_ACCESS_LWP;
    public static MAdvFlags MADV_ACCESS_MANY;
}
[FlagsAttribute]
public enum Sparrow.Server.Platform.Posix.MmapFlags : Enum {
    public int value__;
    public static MmapFlags MAP_SHARED;
    public static MmapFlags MAP_PRIVATE;
    public static MmapFlags MAP_TYPE;
    public static MmapFlags MAP_FIXED;
    public static MmapFlags MAP_FILE;
    public static MmapFlags MAP_ANONYMOUS;
    public static MmapFlags MAP_ANON;
    public static MmapFlags MAP_GROWSDOWN;
    public static MmapFlags MAP_DENYWRITE;
    public static MmapFlags MAP_EXECUTABLE;
    public static MmapFlags MAP_LOCKED;
    public static MmapFlags MAP_NORESERVE;
    public static MmapFlags MAP_POPULATE;
    public static MmapFlags MAP_NONBLOCK;
}
[FlagsAttribute]
public enum Sparrow.Server.Platform.Posix.MmapProts : Enum {
    public int value__;
    public static MmapProts PROT_READ;
    public static MmapProts PROT_WRITE;
    public static MmapProts PROT_EXEC;
    public static MmapProts PROT_NONE;
    public static MmapProts PROT_GROWSDOWN;
    public static MmapProts PROT_GROWSUP;
}
public enum Sparrow.Server.Platform.Posix.MsyncFlags : Enum {
    public int value__;
    public static MsyncFlags MS_ASYNC;
    public static MsyncFlags MS_SYNC;
    public static MsyncFlags MS_INVALIDATE;
}
[FlagsAttribute]
public enum Sparrow.Server.Platform.Posix.OpenFlags : Enum {
    public int value__;
    public static OpenFlags O_RDONLY;
    public static OpenFlags O_WRONLY;
    public static OpenFlags O_RDWR;
}
public class Sparrow.Server.Platform.Posix.PerPlatformValues : object {
}
public static class Sparrow.Server.Platform.Posix.PosixMemoryQueryMethods : object {
    public static bool WillCauseHardPageFault(Byte* address, long length);
}
public enum Sparrow.Server.Platform.Posix.Prio : Enum {
    public int value__;
    public static Prio PROCESS;
    public static Prio PGRP;
    public static Prio USER;
}
[FlagsAttribute]
public enum Sparrow.Server.Platform.Posix.ProtFlag : Enum {
    public int value__;
    public static ProtFlag PROT_NONE;
    public static ProtFlag PROT_READ;
    public static ProtFlag PROT_WRITE;
    public static ProtFlag PROT_EXEC;
}
internal class Sparrow.Server.Platform.Posix.SmapsReader : object {
    public static int BufferSize;
    private Byte[][] _smapsBuffer;
    private SmapsReaderResults _smapsReaderResults;
    private Byte[] _rwsBytes;
    private Byte[] _sizeBytes;
    private Byte[] _swapBytes;
    private Byte[] _rssBytes;
    private Byte[] _sharedCleanBytes;
    private Byte[] _sharedDirtyBytes;
    private Byte[] _privateCleanBytes;
    private Byte[] _privateDirtyBytes;
    private Byte[] _lockedBytes;
    private Byte[] _tempBufferBytes;
    private Int32[] _endOfBuffer;
    private int _currentBuffer;
    public SmapsReader(Byte[][] smapsBuffer);
    private int ReadFromFile(Stream fileStream, int bufferIndex);
    public static string GetSmapsPath(int pid);
    public SmapsReadResult`1<T> CalculateMemUsageFromSmaps();
    public SmapsReadResult`1<T> CalculateMemUsageFromSmaps(Stream fileStream, int pid);
    [DoesNotReturnAttribute]
private static void ThrowOnNullString();
    [DoesNotReturnAttribute]
private void ThrowNotRwsTermAfterLockedTerm(SearchState state, Byte[] term, int processId);
    [DoesNotReturnAttribute]
private void ThrowNotContainsValidValue(Byte[] term, int processId);
    [DoesNotReturnAttribute]
private void ThrowNotContainsKbValue(Byte[] term, int processId, string addtionalInfo);
}
internal class Sparrow.Server.Platform.Posix.SmapsReaderJsonResults : ValueType {
    private DynamicJsonArray _dja;
    public sealed virtual void Add(SmapsReaderResults results);
    public DynamicJsonArray ReturnResults();
}
internal class Sparrow.Server.Platform.Posix.SmapsReaderNoAllocResults : ValueType {
    public sealed virtual void Add(SmapsReaderResults results);
}
internal class Sparrow.Server.Platform.Posix.SmapsReaderResults : object {
    public string ResultString;
    public long Size;
    public long Rss;
    public long SharedClean;
    public long SharedDirty;
    public long PrivateClean;
    public long PrivateDirty;
    public long Swap;
}
public class Sparrow.Server.Platform.Posix.statfs : ValueType {
    public UInt32 f_type;
    public UInt32 f_bsize;
    public ulong f_blocks;
    public ulong f_bfree;
    public ulong f_bavail;
    public ulong f_files;
    public ulong f_ffree;
    public fsid_t f_fsid;
    public UInt32 f_namelen;
    public UInt32 f_frsize;
    public UInt32 f_flags;
    public UInt32[] f_spare1;
}
public class Sparrow.Server.Platform.Posix.Statx : ValueType {
    public UInt32 stx_mask;
    public UInt32 stx_blksize;
    public ulong stx_attributes;
    public UInt32 stx_nlink;
    public UInt32 stx_uid;
    public UInt32 stx_gid;
    public ushort stx_mode;
    [FixedBufferAttribute("System.UInt16", "1")]
private <__statx_pad1>e__FixedBuffer __statx_pad1;
    public ulong stx_ino;
    public ulong stx_size;
    public ulong stx_blocks;
    public ulong stx_attributes_mask;
    public statx_timestamp stx_atime;
    public statx_timestamp stx_btime;
    public statx_timestamp stx_ctime;
    public statx_timestamp stx_mtime;
    public UInt32 stx_rdev_major;
    public UInt32 stx_rdev_minor;
    public UInt32 stx_dev_major;
    public UInt32 stx_dev_minor;
    [FixedBufferAttribute("System.UInt64", "14")]
private <__spare2>e__FixedBuffer __spare2;
}
public class Sparrow.Server.Platform.Posix.statx_timestamp : ValueType {
    public long tv_sec;
    public UInt32 tv_nsec;
    private int __reserved;
}
public static class Sparrow.Server.Platform.Posix.Syscall : object {
    private static string LIBC_6;
    public static int PR_SET_PTRACER;
    private static Nullable`1<long> _pageSize;
    public static long PageSize { get; }
    public static long syscall0(long number);
    public static int sched_setaffinity(int pid, IntPtr cpusetsize, UInt64& cpuset);
    public static int readlink(string path, Byte* buffer, int bufferSize);
    public static int mkdir(string filename, ushort mode);
    public static int close(int fd);
    public static IntPtr pread(int fd, IntPtr buf, UIntPtr count, UIntPtr offset);
    public static long pread(int fd, Void* buf, ulong count, long offset);
    public static int posix_fallocate64(int fd, long offset, long len);
    public static int msync(IntPtr start, UIntPtr len, MsyncFlags flags);
    private static IntPtr mmap64_posix(IntPtr start, UIntPtr length, MmapProts prot, MmapFlags flags, int fd, long offset);
    private static IntPtr mmap64_mac(IntPtr start, UIntPtr length, MmapProts prot, MmapFlags flags, int fd, long offset);
    public static IntPtr mmap64(IntPtr start, UIntPtr length, MmapProts prot, MmapFlags flags, int fd, long offset);
    public static int munmap(IntPtr start, UIntPtr length);
    public static int posix_memalign(Byte** pPtr, IntPtr allignment, IntPtr count);
    public static void free(IntPtr ptr);
    public static int unlink(string filename);
    public static int mincore(Void* addr, IntPtr length, Char* vec);
    public static int flock(int fd, FLockOperations operation);
    public static int open(string pathname, OpenFlags flags, FilePermissions mode);
    public static int fcntl(int fd, FcntlCommands cmd, IntPtr args);
    public static int FSync(int fd);
    private static int fsync(int fd);
    private static int readlink(string path, Byte* buf, UIntPtr bufsiz);
    public static IntPtr read(int fd, IntPtr buf, UIntPtr count);
    public static long read(int fd, Void* buf, ulong count);
    private static IntPtr pwrite64(int fd, IntPtr buf, UIntPtr count, long offset);
    private static IntPtr pwrite(int fd, IntPtr buf, UIntPtr count, IntPtr offset);
    public static long pwrite(int fd, Void* buf, ulong count, long offset);
    public static IntPtr write(int fd, IntPtr buf, ulong count);
    public static long write(int fd, Void* buf, ulong count);
    public static long sysconf(int name, Errno defaultError);
    public static long sysconf(int name);
    public static int madvise(IntPtr addr, UIntPtr length, MAdvFlags madvFlags);
    public static int ftruncate(int fd, IntPtr size);
    public static long lseek64_posix(int fd, long offset, WhenceFlags whence);
    public static long lseek64_mac(int fd, long offset, WhenceFlags whence);
    public static long lseek64(int fd, long offset, WhenceFlags whence);
    public static int mprotect(IntPtr start, IntPtr size, ProtFlag protFlag);
    public static int prctl(int option, UIntPtr arg2, UIntPtr arg3, UIntPtr arg4, UIntPtr arg5);
    public static int statx(int fd, string filename, int flags, UInt32 mask, Statx& buf);
    public static int statfs(string path, statfs& buf);
    public static void PwriteOrThrow(int fd, Byte* buffer, ulong count, long offset, string file, string debug);
    public static int AllocateFileSpace(int fd, long size, string file, Boolean& usingWrite);
    public static long get_PageSize();
    public static void ThrowLastError(int lastError, string msg);
    public static void FsyncDirectoryFor(string file);
    public static bool CheckSyncDirectoryAllowed(string filepath);
    private static int ReadLinkOrThrow(string path, Byte* pBuff, int buffSize);
    public static int SyncDirectory(string file, bool isRealPath);
    public static string ErrorNumberToStatusCode(int result);
}
public enum Sparrow.Server.Platform.Posix.SysconfName : Enum {
    public int value__;
    public static SysconfName _SC_ARG_MAX;
    public static SysconfName _SC_CHILD_MAX;
    public static SysconfName _SC_CLK_TCK;
    public static SysconfName _SC_NGROUPS_MAX;
    public static SysconfName _SC_OPEN_MAX;
    public static SysconfName _SC_STREAM_MAX;
    public static SysconfName _SC_TZNAME_MAX;
    public static SysconfName _SC_JOB_CONTROL;
    public static SysconfName _SC_SAVED_IDS;
    public static SysconfName _SC_REALTIME_SIGNALS;
    public static SysconfName _SC_PRIORITY_SCHEDULING;
    public static SysconfName _SC_TIMERS;
    public static SysconfName _SC_ASYNCHRONOUS_IO;
    public static SysconfName _SC_PRIORITIZED_IO;
    public static SysconfName _SC_SYNCHRONIZED_IO;
    public static SysconfName _SC_FSYNC;
    public static SysconfName _SC_MAPPED_FILES;
    public static SysconfName _SC_MEMLOCK;
    public static SysconfName _SC_MEMLOCK_RANGE;
    public static SysconfName _SC_MEMORY_PROTECTION;
    public static SysconfName _SC_MESSAGE_PASSING;
    public static SysconfName _SC_SEMAPHORES;
    public static SysconfName _SC_SHARED_MEMORY_OBJECTS;
    public static SysconfName _SC_AIO_LISTIO_MAX;
    public static SysconfName _SC_AIO_MAX;
    public static SysconfName _SC_AIO_PRIO_DELTA_MAX;
    public static SysconfName _SC_DELAYTIMER_MAX;
    public static SysconfName _SC_MQ_OPEN_MAX;
    public static SysconfName _SC_MQ_PRIO_MAX;
    public static SysconfName _SC_VERSION;
    public static SysconfName _SC_PAGESIZE;
    public static SysconfName _SC_RTSIG_MAX;
    public static SysconfName _SC_SEM_NSEMS_MAX;
    public static SysconfName _SC_SEM_VALUE_MAX;
    public static SysconfName _SC_SIGQUEUE_MAX;
    public static SysconfName _SC_TIMER_MAX;
    public static SysconfName _SC_BC_BASE_MAX;
    public static SysconfName _SC_BC_DIM_MAX;
    public static SysconfName _SC_BC_SCALE_MAX;
    public static SysconfName _SC_BC_STRING_MAX;
    public static SysconfName _SC_COLL_WEIGHTS_MAX;
    public static SysconfName _SC_EQUIV_CLASS_MAX;
    public static SysconfName _SC_EXPR_NEST_MAX;
    public static SysconfName _SC_LINE_MAX;
    public static SysconfName _SC_RE_DUP_MAX;
    public static SysconfName _SC_CHARCLASS_NAME_MAX;
    public static SysconfName _SC_2_VERSION;
    public static SysconfName _SC_2_C_BIND;
    public static SysconfName _SC_2_C_DEV;
    public static SysconfName _SC_2_FORT_DEV;
    public static SysconfName _SC_2_FORT_RUN;
    public static SysconfName _SC_2_SW_DEV;
    public static SysconfName _SC_2_LOCALEDEF;
    public static SysconfName _SC_PII;
    public static SysconfName _SC_PII_XTI;
    public static SysconfName _SC_PII_SOCKET;
    public static SysconfName _SC_PII_INTERNET;
    public static SysconfName _SC_PII_OSI;
    public static SysconfName _SC_POLL;
    public static SysconfName _SC_SELECT;
    public static SysconfName _SC_UIO_MAXIOV;
    public static SysconfName _SC_IOV_MAX;
    public static SysconfName _SC_PII_INTERNET_STREAM;
    public static SysconfName _SC_PII_INTERNET_DGRAM;
    public static SysconfName _SC_PII_OSI_COTS;
    public static SysconfName _SC_PII_OSI_CLTS;
    public static SysconfName _SC_PII_OSI_M;
    public static SysconfName _SC_T_IOV_MAX;
    public static SysconfName _SC_THREADS;
    public static SysconfName _SC_THREAD_SAFE_FUNCTIONS;
    public static SysconfName _SC_GETGR_R_SIZE_MAX;
    public static SysconfName _SC_GETPW_R_SIZE_MAX;
    public static SysconfName _SC_LOGIN_NAME_MAX;
    public static SysconfName _SC_TTY_NAME_MAX;
    public static SysconfName _SC_THREAD_DESTRUCTOR_ITERATIONS;
    public static SysconfName _SC_THREAD_KEYS_MAX;
    public static SysconfName _SC_THREAD_STACK_MIN;
    public static SysconfName _SC_THREAD_THREADS_MAX;
    public static SysconfName _SC_THREAD_ATTR_STACKADDR;
    public static SysconfName _SC_THREAD_ATTR_STACKSIZE;
    public static SysconfName _SC_THREAD_PRIORITY_SCHEDULING;
    public static SysconfName _SC_THREAD_PRIO_INHERIT;
    public static SysconfName _SC_THREAD_PRIO_PROTECT;
    public static SysconfName _SC_THREAD_PROCESS_SHARED;
    public static SysconfName _SC_NPROCESSORS_CONF;
    public static SysconfName _SC_NPROCESSORS_ONLN;
    public static SysconfName _SC_PHYS_PAGES;
    public static SysconfName _SC_AVPHYS_PAGES;
    public static SysconfName _SC_ATEXIT_MAX;
    public static SysconfName _SC_PASS_MAX;
    public static SysconfName _SC_XOPEN_VERSION;
    public static SysconfName _SC_XOPEN_XCU_VERSION;
    public static SysconfName _SC_XOPEN_UNIX;
    public static SysconfName _SC_XOPEN_CRYPT;
    public static SysconfName _SC_XOPEN_ENH_I18N;
    public static SysconfName _SC_XOPEN_SHM;
    public static SysconfName _SC_2_CHAR_TERM;
    public static SysconfName _SC_2_C_VERSION;
    public static SysconfName _SC_2_UPE;
    public static SysconfName _SC_XOPEN_XPG2;
    public static SysconfName _SC_XOPEN_XPG3;
    public static SysconfName _SC_XOPEN_XPG4;
    public static SysconfName _SC_CHAR_BIT;
    public static SysconfName _SC_CHAR_MAX;
    public static SysconfName _SC_CHAR_MIN;
    public static SysconfName _SC_INT_MAX;
    public static SysconfName _SC_INT_MIN;
    public static SysconfName _SC_LONG_BIT;
    public static SysconfName _SC_WORD_BIT;
    public static SysconfName _SC_MB_LEN_MAX;
    public static SysconfName _SC_NZERO;
    public static SysconfName _SC_SSIZE_MAX;
    public static SysconfName _SC_SCHAR_MAX;
    public static SysconfName _SC_SCHAR_MIN;
    public static SysconfName _SC_SHRT_MAX;
    public static SysconfName _SC_SHRT_MIN;
    public static SysconfName _SC_UCHAR_MAX;
    public static SysconfName _SC_UINT_MAX;
    public static SysconfName _SC_ULONG_MAX;
    public static SysconfName _SC_USHRT_MAX;
    public static SysconfName _SC_NL_ARGMAX;
    public static SysconfName _SC_NL_LANGMAX;
    public static SysconfName _SC_NL_MSGMAX;
    public static SysconfName _SC_NL_NMAX;
    public static SysconfName _SC_NL_SETMAX;
    public static SysconfName _SC_NL_TEXTMAX;
    public static SysconfName _SC_XBS5_ILP32_OFF32;
    public static SysconfName _SC_XBS5_ILP32_OFFBIG;
    public static SysconfName _SC_XBS5_LP64_OFF64;
    public static SysconfName _SC_XBS5_LPBIG_OFFBIG;
    public static SysconfName _SC_XOPEN_LEGACY;
    public static SysconfName _SC_XOPEN_REALTIME;
    public static SysconfName _SC_XOPEN_REALTIME_THREADS;
    public static SysconfName _SC_ADVISORY_INFO;
    public static SysconfName _SC_BARRIERS;
    public static SysconfName _SC_BASE;
    public static SysconfName _SC_C_LANG_SUPPORT;
    public static SysconfName _SC_C_LANG_SUPPORT_R;
    public static SysconfName _SC_CLOCK_SELECTION;
    public static SysconfName _SC_CPUTIME;
    public static SysconfName _SC_THREAD_CPUTIME;
    public static SysconfName _SC_DEVICE_IO;
    public static SysconfName _SC_DEVICE_SPECIFIC;
    public static SysconfName _SC_DEVICE_SPECIFIC_R;
    public static SysconfName _SC_FD_MGMT;
    public static SysconfName _SC_FIFO;
    public static SysconfName _SC_PIPE;
    public static SysconfName _SC_FILE_ATTRIBUTES;
    public static SysconfName _SC_FILE_LOCKING;
    public static SysconfName _SC_FILE_SYSTEM;
    public static SysconfName _SC_MONOTONIC_CLOCK;
    public static SysconfName _SC_MULTI_PROCESS;
    public static SysconfName _SC_SINGLE_PROCESS;
    public static SysconfName _SC_NETWORKING;
    public static SysconfName _SC_READER_WRITER_LOCKS;
    public static SysconfName _SC_SPIN_LOCKS;
    public static SysconfName _SC_REGEXP;
    public static SysconfName _SC_REGEX_VERSION;
    public static SysconfName _SC_SHELL;
    public static SysconfName _SC_SIGNALS;
    public static SysconfName _SC_SPAWN;
    public static SysconfName _SC_SPORADIC_SERVER;
    public static SysconfName _SC_THREAD_SPORADIC_SERVER;
    public static SysconfName _SC_SYSTEM_DATABASE;
    public static SysconfName _SC_SYSTEM_DATABASE_R;
    public static SysconfName _SC_TIMEOUTS;
    public static SysconfName _SC_TYPED_MEMORY_OBJECTS;
    public static SysconfName _SC_USER_GROUPS;
    public static SysconfName _SC_USER_GROUPS_R;
    public static SysconfName _SC_2_PBS;
    public static SysconfName _SC_2_PBS_ACCOUNTING;
    public static SysconfName _SC_2_PBS_LOCATE;
    public static SysconfName _SC_2_PBS_MESSAGE;
    public static SysconfName _SC_2_PBS_TRACK;
    public static SysconfName _SC_SYMLOOP_MAX;
    public static SysconfName _SC_STREAMS;
    public static SysconfName _SC_2_PBS_CHECKPOINT;
    public static SysconfName _SC_V6_ILP32_OFF32;
    public static SysconfName _SC_V6_ILP32_OFFBIG;
    public static SysconfName _SC_V6_LP64_OFF64;
    public static SysconfName _SC_V6_LPBIG_OFFBIG;
    public static SysconfName _SC_HOST_NAME_MAX;
    public static SysconfName _SC_TRACE;
    public static SysconfName _SC_TRACE_EVENT_FILTER;
    public static SysconfName _SC_TRACE_INHERIT;
    public static SysconfName _SC_TRACE_LOG;
    public static SysconfName _SC_LEVEL1_ICACHE_SIZE;
    public static SysconfName _SC_LEVEL1_ICACHE_ASSOC;
    public static SysconfName _SC_LEVEL1_ICACHE_LINESIZE;
    public static SysconfName _SC_LEVEL1_DCACHE_SIZE;
    public static SysconfName _SC_LEVEL1_DCACHE_ASSOC;
    public static SysconfName _SC_LEVEL1_DCACHE_LINESIZE;
    public static SysconfName _SC_LEVEL2_CACHE_SIZE;
    public static SysconfName _SC_LEVEL2_CACHE_ASSOC;
    public static SysconfName _SC_LEVEL2_CACHE_LINESIZE;
    public static SysconfName _SC_LEVEL3_CACHE_SIZE;
    public static SysconfName _SC_LEVEL3_CACHE_ASSOC;
    public static SysconfName _SC_LEVEL3_CACHE_LINESIZE;
    public static SysconfName _SC_LEVEL4_CACHE_SIZE;
    public static SysconfName _SC_LEVEL4_CACHE_ASSOC;
    public static SysconfName _SC_LEVEL4_CACHE_LINESIZE;
}
public class Sparrow.Server.Platform.Posix.sysinfo_t : ValueType {
    public long uptime;
    [FixedBufferAttribute("System.UInt64", "3")]
public <loads>e__FixedBuffer loads;
    public ulong totalram;
    public ulong freeram;
    public ulong sharedram;
    public ulong bufferram;
    public ulong totalswap;
    public ulong freeswap;
    public ushort procs;
    public ulong totalhigh;
    public ulong freehigh;
    public UInt32 mem_unit;
    public ulong AvailableRam { get; }
    public ulong TotalRam { get; }
    public ulong TotalSwap { get; }
    public ulong get_AvailableRam();
    public ulong get_TotalRam();
    public ulong get_TotalSwap();
}
public class Sparrow.Server.Platform.Posix.sysinfo_t_32bit : ValueType {
    public int uptime;
    [FixedBufferAttribute("System.UInt32", "3")]
public <loads>e__FixedBuffer loads;
    public UInt32 totalram;
    public UInt32 freeram;
    public UInt32 sharedram;
    public UInt32 bufferram;
    public UInt32 totalswap;
    public UInt32 freeswap;
    public ushort procs;
    public UInt32 totalhigh;
    public UInt32 freehigh;
    public UInt32 mem_unit;
    [FixedBufferAttribute("System.Char", "8")]
public <_f>e__FixedBuffer _f;
    public ulong AvailableRam { get; }
    public ulong TotalRam { get; }
    public ulong TotalSwap { get; }
    public ulong get_AvailableRam();
    public ulong get_TotalRam();
    public ulong get_TotalSwap();
}
public class Sparrow.Server.Platform.Posix.UnidentifiedCGroup : CGroup {
    private string _errorMessage;
    private DateTime _lastLog;
    protected string MemoryLimitFileName { get; }
    protected string MemoryUsageFileName { get; }
    protected string MaxMemoryUsageFileName { get; }
    public UnidentifiedCGroup(string errorMessage);
    protected virtual string get_MemoryLimitFileName();
    protected virtual string get_MemoryUsageFileName();
    protected virtual string get_MaxMemoryUsageFileName();
    protected virtual string FindCGroupPathForMemoryInternal();
}
[FlagsAttribute]
public enum Sparrow.Server.Platform.Posix.WhenceFlags : Enum {
    public int value__;
    public static WhenceFlags SEEK_SET;
    public static WhenceFlags SEEK_CUR;
    public static WhenceFlags SEEK_END;
}
public class Sparrow.Server.Platform.SafeJournalHandle : SafeHandle {
    public FailCodes FailCode;
    public int ErrorNo;
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
public class Sparrow.Server.Platform.SafeMmapHandle : SafeHandle {
    public FailCodes FailCode;
    public int ErrorNo;
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[FlagsAttribute]
public enum Sparrow.Server.Platform.Win32.ThreadAccess : Enum {
    public int value__;
    public static ThreadAccess Terminate;
    public static ThreadAccess SuspendResume;
    public static ThreadAccess GetContext;
    public static ThreadAccess SetContext;
    public static ThreadAccess SetInformation;
    public static ThreadAccess QueryInformation;
    public static ThreadAccess SetThreadToken;
    public static ThreadAccess Impersonate;
    public static ThreadAccess DirectImpersonation;
}
public static class Sparrow.Server.Platform.Win32.Win32MemoryProtectMethods : object {
    public static Byte* VirtualAlloc(Byte* lpAddress, UIntPtr dwSize, AllocationType flAllocationType, MemoryProtection flProtect);
    public static bool VirtualProtect(Byte* lpAddress, UIntPtr dwSize, MemoryProtection flNewProtect, MemoryProtection& lpflOldProtect);
    public static bool VirtualFree(Byte* lpAddress, UIntPtr dwSize, FreeType dwFreeType);
    public static int VirtualQuery(Byte* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, UIntPtr dwLength);
    public static int VirtualQueryEx(IntPtr hProcess, Byte* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, UIntPtr dwLength);
    public static int GetMappedFileName(IntPtr hProcess, Void* lpv, Byte* lpFilename, UInt32 nSize);
}
public static class Sparrow.Server.Platform.Win32.Win32MemoryQueryMethods : object {
    private static Byte[][] RelevantFilesPostFixes;
    private static UnmanagedBuffersPool BuffersPool;
    private static Nullable`1<UInt32> _pageSize;
    public static UInt32 PageSize { get; }
    private static Win32MemoryQueryMethods();
    private static IntPtr GetCurrentProcess();
    private static bool QueryWorkingSetEx(IntPtr hProcess, Byte* pv, UInt32 cb);
    public static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    public static UInt32 get_PageSize();
    private static string GetEncodedFilename(IntPtr processHandle, MEMORY_BASIC_INFORMATION& memoryBasicInformation);
    public static ValueTuple`2<long, DynamicJsonArray> GetMaps();
    public static bool WillCauseHardPageFault(Byte* address, long length);
    public static UInt32 AddressWillCauseHardPageFault(Byte* address, long length, bool performCount);
}
public static class Sparrow.Server.Platform.Win32.Win32ThreadsMethods : object {
    public static UInt32 GetCurrentThreadId();
    public static IntPtr OpenThread(ThreadAccess desiredAccess, bool inheritHandle, UInt32 threadId);
    public static bool CloseHandle(IntPtr handle);
    public static IntPtr GetCurrentThread();
}
public interface Sparrow.Server.Strings.IStringDistance {
    public abstract virtual float GetDistance(ReadOnlySpan`1<byte> target, ReadOnlySpan`1<byte> other);
}
public class Sparrow.Server.Strings.JaroWinklerDistance : ValueType {
    private float _threshold;
    public static float Threshold;
    public JaroWinklerDistance(float threshold);
    public sealed virtual float GetDistance(ReadOnlySpan`1<byte> target, ReadOnlySpan`1<byte> other);
    private static Int32[] Matches(string s1, string s2);
}
public class Sparrow.Server.Strings.LevenshteinDistance : ValueType {
    public static ArrayPool`1<int> MatchesPool;
    private static LevenshteinDistance();
    public sealed virtual float GetDistance(ReadOnlySpan`1<byte> target, ReadOnlySpan`1<byte> other);
}
public class Sparrow.Server.Strings.NGramDistance : ValueType {
    public static int DefaultNGramSize;
    private int _n;
    public NGramDistance(int n);
    public sealed virtual float GetDistance(ReadOnlySpan`1<byte> input, ReadOnlySpan`1<byte> other);
}
public class Sparrow.Server.Strings.NoStringDistance : ValueType {
    public sealed virtual float GetDistance(ReadOnlySpan`1<byte> target, ReadOnlySpan`1<byte> other);
}
[ExtensionAttribute]
public static class Sparrow.Server.Strings.StringsExtensions : object {
    [ExtensionAttribute]
public static bool IsEqualConstant(ReadOnlySpan`1<byte> constant, Byte* ptr);
    [ExtensionAttribute]
public static bool IsEqualConstant(ReadOnlySpan`1<byte> constant, Byte* ptr, int size);
}
public class Sparrow.Server.Threading.AsyncGuard : object {
    private UInt64[] _coreMarkers;
    private int _mask;
    private ManualResetEvent _event;
    private bool _locked;
    private static ulong WriterLockMask;
    public bool TryEnter(Int32& idx);
    public void Exit(int idx);
    public void CloseAndLock();
    public sealed virtual void Dispose();
}
public class Sparrow.Server.UnmanagedGlobalSegment : PooledItem {
    public Byte* Segment;
    public int Size;
    private ThreadStats _thread;
    public UnmanagedGlobalSegment(int size);
    protected virtual override void Finalize();
    public virtual void Dispose();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Sparrow.Server.UnmanagedSpan`1 : ValueType {
    public T* Address;
    public int Length;
    public T& Item { get; }
    public UnmanagedSpan`1(Void* address, int length);
    public UnmanagedSpan`1(UnmanagedSpan`1<T> pointer, int length);
    public UnmanagedSpan`1(UnmanagedPointer pointer, int length);
    public UnmanagedSpan`1<T> Slice(int offset);
    public UnmanagedSpan`1<T> Slice(int position, int length);
    public T& get_Item(int idx);
    public T* GetAsPtr(int idx);
    public Span`1<T> ToSpan();
    public ReadOnlySpan`1<T> ToReadOnlySpan();
    public static UnmanagedSpan`1<T> op_Addition(UnmanagedSpan`1<T> pointer, int offset);
    public static Span`1<T> op_Implicit(UnmanagedSpan`1<T> pointer);
    public static ReadOnlySpan`1<T> op_Implicit(UnmanagedSpan`1<T> pointer);
}
internal class Sparrow.Server.Utils.BackupStream : Stream {
    private Stream _inner;
    private Byte[] _b;
    private bool _hasRead;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BackupStream(Stream inner, Byte[] b);
    public virtual void Flush();
    public virtual int Read(Span`1<byte> buffer);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual ValueTask DisposeAsync();
    protected virtual void Dispose(bool disposing);
    private void FillBuffer(Span`1<byte> buffer);
    private void FillBuffer(Byte[] buffer, int offset);
}
public class Sparrow.Server.Utils.Base64 : object {
    private static ReadOnlySpan`1<byte> Base64Table { get; }
    public static int FromBase64_ComputeResultLength(Char* inputPtr, int inputLength);
    public static int FromBase64_Decode(Char* startInputPtr, int inputLength, Byte* startDestPtr, int destLength);
    public static int CalculateAndValidateOutputLength(int inputLength);
    public static int ConvertToBase64Array(Char* outChars, Byte* inData, int offset, int length);
    private static ReadOnlySpan`1<byte> get_Base64Table();
    public static int ConvertToBase64ArrayUnpadded(Char* outChars, Byte* inData, int offset, int length);
    public static int ConvertToBase64ArrayUnpadded(ReadOnlySpan`1<char> outChars, Byte* inData, int offset, int length);
    public static int ConvertToBase64ArrayUnpadded(ReadOnlySpan`1<char> outChars, Span`1<byte> inData, int offset, int length);
}
public class Sparrow.Server.Utils.DiffApplier : object {
    public Byte* Diff;
    public Byte* Destination;
    public long DiffSize;
    public long Size;
    public void Apply(bool isNewDiff);
    private void AssertInvalidSize(long start, long count);
    private void AssertInvalidDiffSize(long pos, long count);
}
public class Sparrow.Server.Utils.DiffPages : object {
    public Byte* Output;
    public long OutputSize;
    [CompilerGeneratedAttribute]
private bool <IsDiff>k__BackingField;
    public bool IsDiff { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsDiff();
    [CompilerGeneratedAttribute]
private void set_IsDiff(bool value);
    public void ComputeDiff(Void* originalBuffer, Void* modifiedBuffer, int size);
    public void ComputeNew(Void* modifiedBuffer, int size);
    private void WriteDiffNonZeroes(long start, long count, Byte* modified);
    private void WriteDiffAllZeroes(long start, long count);
    private void CopyFullBuffer(Byte* modified, int size);
}
public class Sparrow.Server.Utils.DiskSpaceResult : DriveInfoBase {
    [CompilerGeneratedAttribute]
private string <VolumeLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <TotalFreeSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <TotalSize>k__BackingField;
    public string VolumeLabel { get; public set; }
    public Size TotalFreeSpace { get; public set; }
    public Size TotalSize { get; public set; }
    [CompilerGeneratedAttribute]
public string get_VolumeLabel();
    [CompilerGeneratedAttribute]
public void set_VolumeLabel(string value);
    [CompilerGeneratedAttribute]
public Size get_TotalFreeSpace();
    [CompilerGeneratedAttribute]
public void set_TotalFreeSpace(Size value);
    [CompilerGeneratedAttribute]
public Size get_TotalSize();
    [CompilerGeneratedAttribute]
public void set_TotalSize(Size value);
}
internal abstract class Sparrow.Server.Utils.DiskStatsGetter.DiskStatsGetter`1 : object {
    private TimeSpan _minInterval;
    private TimeSpan _maxWait;
    private ConcurrentDictionary`2<string, DiskStatsCache<T>> _previousInfo;
    protected DiskStatsGetter`1(TimeSpan minInterval);
    public sealed virtual DiskStatsResult Get(string drive);
    [AsyncStateMachineAttribute("Sparrow.Server.Utils.DiskStatsGetter.DiskStatsGetter`1/<GetAsync>d__5")]
public sealed virtual Task`1<DiskStatsResult> GetAsync(string drive);
    private GetStatsResult<T> GetStats(object o);
    private GetStatsResult<T> CalculateStats(object o);
    protected abstract virtual DiskStatsResult CalculateStats(T currentInfo, State<T> state);
    protected abstract virtual T GetDiskInfo(string path);
    public abstract virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Sparrow.Server.Utils.DiskStatsGetter.DiskStatsResult : object {
    [CompilerGeneratedAttribute]
private double <IoReadOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IoWriteOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <ReadThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <WriteThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <QueueLength>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public double IoReadOperations { get; public set; }
    public double IoWriteOperations { get; public set; }
    public Size ReadThroughput { get; public set; }
    public Size WriteThroughput { get; public set; }
    public Nullable`1<long> QueueLength { get; public set; }
    [CompilerGeneratedAttribute]
protected DiskStatsResult(DiskStatsResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public double get_IoReadOperations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IoReadOperations(double value);
    [CompilerGeneratedAttribute]
public double get_IoWriteOperations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IoWriteOperations(double value);
    [CompilerGeneratedAttribute]
public Size get_ReadThroughput();
    [CompilerGeneratedAttribute]
public void set_ReadThroughput(Size value);
    [CompilerGeneratedAttribute]
public Size get_WriteThroughput();
    [CompilerGeneratedAttribute]
public void set_WriteThroughput(Size value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_QueueLength();
    [CompilerGeneratedAttribute]
public void set_QueueLength(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(DiskStatsResult left, DiskStatsResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(DiskStatsResult left, DiskStatsResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(DiskStatsResult other);
    [CompilerGeneratedAttribute]
public virtual DiskStatsResult <Clone>$();
}
public interface Sparrow.Server.Utils.DiskStatsGetter.IDiskStatsGetter {
    public abstract virtual DiskStatsResult Get(string drive);
    public abstract virtual Task`1<DiskStatsResult> GetAsync(string drive);
}
internal interface Sparrow.Server.Utils.DiskStatsGetter.IDiskStatsRawResult {
    public DateTime Time { get; }
    public abstract virtual DateTime get_Time();
}
[SupportedOSPlatformAttribute("linux")]
internal class Sparrow.Server.Utils.DiskStatsGetter.LinuxDiskStatsGetter : DiskStatsGetter`1<LinuxDiskStatsRawResult> {
    private static Logger Logger;
    public LinuxDiskStatsGetter(TimeSpan minInterval);
    private static LinuxDiskStatsGetter();
    protected virtual DiskStatsResult CalculateStats(LinuxDiskStatsRawResult currentInfo, State<LinuxDiskStatsRawResult> state);
    protected virtual LinuxDiskStatsRawResult GetDiskInfo(string path);
    private static ValueTuple`2<ulong, ulong> GetDiskMajorMinor(string path);
    private static LinuxDiskStatsRawResult ReadParse(string statPath);
    private static int ReadAllInto(string path, Span`1<byte> remainedToRead);
    private static int Parse(Span`1<byte> content, Span`1<long> values);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Sparrow.Server.Utils.DiskStatsGetter.LinuxDiskStatsRawResult : object {
    [CompilerGeneratedAttribute]
private long <IoReadOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private long <IoWriteOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReadSectors>k__BackingField;
    [CompilerGeneratedAttribute]
private long <WriteSectors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <QueueLength>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public long IoReadOperations { get; public set; }
    public long IoWriteOperations { get; public set; }
    public long ReadSectors { get; public set; }
    public long WriteSectors { get; public set; }
    public Nullable`1<long> QueueLength { get; public set; }
    public DateTime Time { get; public set; }
    [CompilerGeneratedAttribute]
protected LinuxDiskStatsRawResult(LinuxDiskStatsRawResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public long get_IoReadOperations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IoReadOperations(long value);
    [CompilerGeneratedAttribute]
public long get_IoWriteOperations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IoWriteOperations(long value);
    [CompilerGeneratedAttribute]
public long get_ReadSectors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReadSectors(long value);
    [CompilerGeneratedAttribute]
public long get_WriteSectors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WriteSectors(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_QueueLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QueueLength(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Time();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Time(DateTime value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(LinuxDiskStatsRawResult left, LinuxDiskStatsRawResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(LinuxDiskStatsRawResult left, LinuxDiskStatsRawResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(LinuxDiskStatsRawResult other);
    [CompilerGeneratedAttribute]
public virtual LinuxDiskStatsRawResult <Clone>$();
}
internal class Sparrow.Server.Utils.DiskStatsGetter.NotImplementedDiskStatsGetter : object {
    public sealed virtual DiskStatsResult Get(string drive);
    public sealed virtual Task`1<DiskStatsResult> GetAsync(string drive);
    public sealed virtual void Dispose();
}
[SupportedOSPlatformAttribute("windows")]
internal class Sparrow.Server.Utils.DiskStatsGetter.WindowsDiskStatsGetter : DiskStatsGetter`1<WindowsDiskStatsRawResult> {
    private static Logger Logger;
    private static string DiskCategory;
    private CountersPerDisk _countersPerDisk;
    public WindowsDiskStatsGetter(TimeSpan minInterval);
    private static WindowsDiskStatsGetter();
    protected virtual DiskStatsResult CalculateStats(WindowsDiskStatsRawResult currentInfo, State<WindowsDiskStatsRawResult> state);
    private static double ComputeCounterValue(CounterSample oldSample, CounterSample newSample);
    protected virtual WindowsDiskStatsRawResult GetDiskInfo(string path);
    public virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Sparrow.Server.Utils.DiskStatsGetter.WindowsDiskStatsRawResult : object {
    [CompilerGeneratedAttribute]
private CounterSample <IoReadOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterSample <IoWriteOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterSample <ReadThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterSample <WriteThroughput>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterSample <QueueLength>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public CounterSample IoReadOperations { get; public set; }
    public CounterSample IoWriteOperations { get; public set; }
    public CounterSample ReadThroughput { get; public set; }
    public CounterSample WriteThroughput { get; public set; }
    public CounterSample QueueLength { get; public set; }
    public DateTime Time { get; public set; }
    [CompilerGeneratedAttribute]
protected WindowsDiskStatsRawResult(WindowsDiskStatsRawResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CounterSample get_IoReadOperations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IoReadOperations(CounterSample value);
    [CompilerGeneratedAttribute]
public CounterSample get_IoWriteOperations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IoWriteOperations(CounterSample value);
    [CompilerGeneratedAttribute]
public CounterSample get_ReadThroughput();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReadThroughput(CounterSample value);
    [CompilerGeneratedAttribute]
public CounterSample get_WriteThroughput();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WriteThroughput(CounterSample value);
    [CompilerGeneratedAttribute]
public CounterSample get_QueueLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QueueLength(CounterSample value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_Time();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Time(DateTime value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(WindowsDiskStatsRawResult left, WindowsDiskStatsRawResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(WindowsDiskStatsRawResult left, WindowsDiskStatsRawResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(WindowsDiskStatsRawResult other);
    [CompilerGeneratedAttribute]
public virtual WindowsDiskStatsRawResult <Clone>$();
}
public static class Sparrow.Server.Utils.DiskUtils : object {
    private static Logger Logger;
    public static short WindowsMaxPath;
    public static int LinuxMaxPath;
    private static UInt32 FILE_READ_EA;
    private static UInt32 FILE_FLAG_BACKUP_SEMANTICS;
    private static IntPtr INVALID_HANDLE_VALUE;
    private static DiskUtils();
    public static DiskSpaceResult GetDiskSpaceInfo(string pathToCheck, DriveInfoBase driveInfoBase);
    private static string GetVolumeLabel(string path);
    public static DriveInfoBase GetDriveInfo(string path, DriveInfo[] drivesInfo, String& realPath);
    private static string GetDriveName(string path, DriveInfo[] drivesInfo, String& realPath);
    public static string WindowsGetDriveName(string path, String& realPath);
    private static string GetPosixRealPath(string path);
    private static string GetRootMountString(DriveInfo[] drivesInfo, string filePath);
    private static string GetWindowsRealPathByPath(string path);
    private static string GetWindowsRealPathByHandle(IntPtr handle);
    internal static IDiskStatsGetter GetOsDiskUsageCalculator(TimeSpan minInterval);
    private static IntPtr CreateFile(string filename, UInt32 access, FileShare share, IntPtr securityAttributes, FileMode creationDisposition, UInt32 flagsAndAttributes, IntPtr templateFile);
    private static bool CloseHandle(IntPtr hObject);
    private static UInt32 GetFinalPathNameByHandle(IntPtr hFile, Char* buffer, UInt32 bufferLength, UInt32 dwFlags);
    [CompilerGeneratedAttribute]
internal static bool <GetWindowsRealPathByHandle>g__GetPath|11_0(UInt32 bufferSize, String& outputPath, <>c__DisplayClass11_0& );
}
public class Sparrow.Server.Utils.DisposableScope : object {
    private LinkedList`1<IDisposable> _disposables;
    private int _delayedDispose;
    public void EnsureDispose(IDisposable toDispose);
    public sealed virtual void Dispose();
    public IDisposable Delay();
}
public class Sparrow.Server.Utils.DriveInfoBase : object {
    [CompilerGeneratedAttribute]
private string <DriveName>k__BackingField;
    public string DriveName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DriveName();
    [CompilerGeneratedAttribute]
public void set_DriveName(string value);
}
internal class Sparrow.Server.Utils.EchoStream : Stream {
    [CompilerGeneratedAttribute]
private bool <CanTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WriteTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopyBufferOnWrite>k__BackingField;
    private object _lock;
    private BlockingCollection`1<Byte[]> _buffers;
    private int _maxQueueDepth;
    private Byte[] m_buffer;
    private int m_offset;
    private int m_count;
    private bool m_Closed;
    private long _length;
    private long _position;
    private Task _task;
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CopyBufferOnWrite { get; public set; }
    public bool DataAvailable { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public EchoStream(int maxQueueDepth);
    [CompilerGeneratedAttribute]
public virtual bool get_CanTimeout();
    [CompilerGeneratedAttribute]
public virtual int get_ReadTimeout();
    [CompilerGeneratedAttribute]
public virtual void set_ReadTimeout(int value);
    [CompilerGeneratedAttribute]
public virtual int get_WriteTimeout();
    [CompilerGeneratedAttribute]
public virtual void set_WriteTimeout(int value);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    [CompilerGeneratedAttribute]
public bool get_CopyBufferOnWrite();
    [CompilerGeneratedAttribute]
public void set_CopyBufferOnWrite(bool value);
    public virtual void Close();
    public bool get_DataAvailable();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    internal void TaskToWatch(Task task);
    public virtual int ReadByte();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void CopyTo(Stream destination, int bufferSize);
    [AsyncStateMachineAttribute("Sparrow.Server.Utils.EchoStream/<CopyToAsync>d__54")]
public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private void AssertTask();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <TaskToWatch>b__48_0(Task _);
}
public class Sparrow.Server.Utils.GrowableBuffer`1 : ValueType {
    private TGrowth _growthCalculator;
    private ByteStringContext _context;
    private ByteString _buffer;
    private int _count;
    public bool IsInitialized;
    public int Count { get; }
    public Span`1<long> Results { get; }
    public bool HasEmptySpace { get; }
    public int get_Count();
    public Span`1<long> GetSpace();
    public Span`1<long> get_Results();
    public bool get_HasEmptySpace();
    public void AddUsage(Int32& count);
    public void Truncate(Int32& newCount);
    public void Init(ByteStringContext context, Int64& initialSize);
    private void Grow();
    public sealed virtual void Dispose();
}
public interface Sparrow.Server.Utils.IBufferGrowth {
    public abstract virtual int GetInitialSize(Int64& modreq(System.Runtime.InteropServices.InAttribute) initialSize);
    public abstract virtual int GetNewSize(Int32& modreq(System.Runtime.InteropServices.InAttribute) currentSizeInBytes);
    public abstract virtual bool GrowingThresholdExceed(Int32& modreq(System.Runtime.InteropServices.InAttribute) count, Int32& modreq(System.Runtime.InteropServices.InAttribute) sizeInBytes);
}
[IsReadOnlyAttribute]
public class Sparrow.Server.Utils.Progressive : ValueType {
    public int GetNewSize(Int32& currentSizeInBytes);
    public bool GrowingThresholdExceed(Int32& count, Int32& sizeInBytes);
    public int GetInitialSize(Int64& initialSize);
    private sealed virtual override int Sparrow.Server.Utils.IBufferGrowth.GetInitialSize(Int64& modreq(System.Runtime.InteropServices.InAttribute) initialSize);
    private sealed virtual override int Sparrow.Server.Utils.IBufferGrowth.GetNewSize(Int32& modreq(System.Runtime.InteropServices.InAttribute) currentSizeInBytes);
    private sealed virtual override bool Sparrow.Server.Utils.IBufferGrowth.GrowingThresholdExceed(Int32& modreq(System.Runtime.InteropServices.InAttribute) count, Int32& modreq(System.Runtime.InteropServices.InAttribute) sizeInBytes);
}
[ComVisibleAttribute("True")]
public class Sparrow.Server.Utils.ReusableStringReader : TextReader {
    private string _s;
    private int _pos;
    private int _length;
    public int Length { get; }
    public ReusableStringReader(string s);
    public int get_Length();
    protected virtual void Dispose(bool disposing);
    public void Reset();
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual string ReadToEnd();
    public virtual string ReadLine();
    [DoesNotReturnAttribute]
private void ThrowReaderClosed();
    [ComVisibleAttribute("False")]
public virtual Task`1<string> ReadLineAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<string> ReadToEndAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
}
internal static class Sparrow.Server.Utils.Sorting : object {
    public static int SortAndRemoveDuplicates(Span`1<T> values, Span`1<W> items);
    public static int SortAndRemoveDuplicates(Span`1<T> values);
    public static int SortAndRemoveDuplicates(T* bufferBasePtr, W* itemsBasePtr, int count);
    public static int SortAndRemoveDuplicates(T* bufferBasePtr, int count);
}
public static class Sparrow.Server.Utils.SpecialChars : object {
    public static byte RecordSeparator;
    public static byte LuceneRecordSeparator;
}
internal class Sparrow.Server.Utils.StrongReference`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
public static class Sparrow.Server.Utils.TaskExecutor : object {
    private static Runner Instance;
    private static TaskExecutor();
    public static void CompleteAndReplace(TaskCompletionSource`1& task);
    public static void CompleteReplaceAndExecute(TaskCompletionSource`1& task, Action act);
    public static void Complete(TaskCompletionSource`1<object> task);
    public static void Execute(WaitCallback callback, object state);
}
public static class Sparrow.Server.Utils.ThreadNames : object {
    public static ConcurrentDictionary`2<long, string> FullThreadNames;
    private static ThreadNames();
    public static string GetNameToUse(ThreadInfo threadInfo);
    public static void AddFullThreadName(long id, string fullName);
    public static void RemoveFullThreadName(long id);
    public static ThreadInfo ForElector(string threadName, string source);
    public static ThreadInfo ForEtlProcess(string threadName, string tag, string name);
    public static ThreadInfo ForIndex(string threadName, string idxName, string dbName);
    public static ThreadInfo ForUploadBackupFile(string threadName, string dbName, string targetName, string taskName);
    public static ThreadInfo ForDeleteBackupFile(string threadName, string dbName, string targetName, string taskName);
    public static ThreadInfo ForBackupTask(string threadName, string dbName, string taskName);
    public static ThreadInfo ForIncomingReplication(string threadName, string dbName, string sourceDbName);
    public static ThreadInfo ForOutgoingReplication(string threadName, string databaseName, string destination, bool pullReplicationAsHub);
    public static ThreadInfo ForTransactionMerging(string threadName, string name);
    public static ThreadInfo ForCandidate(string threadName, string engineTag);
    public static ThreadInfo ForCandidateAmbassador(string threadName, string engineTag, string tag);
    public static ThreadInfo ForFollower(string threadName, string connection, long term);
    public static ThreadInfo ForFollowerAmbassador(string threadName, string tag, string term);
    public static ThreadInfo ForConsensusLeader(string threadName, string engineTag, long term);
    public static ThreadInfo ForHeartbeatsSupervisor(string threadName, string serverNodeTag, string clusterTag, long term);
    public static ThreadInfo ForHeartbeatsWorker(string threadName, string leader, long term);
    public static ThreadInfo ForClusterObserver(string threadName, long term);
    public static ThreadInfo ForClusterMaintenanceSetupTask(string threadName);
    public static ThreadInfo ForUpdateTopologyChangeNotificationTask(string threadName);
    public static ThreadInfo ForBackup(string threadName, string backupName, string databaseName);
    public static ThreadInfo ForCpuCreditsMonitoring(string threadName);
    public static ThreadInfo ForPullReplicationAsSink(string threadName, string destinationDatabase, string destinationUrl);
    public static ThreadInfo ForQueueSinkProcess(string threadName, string tag, string name);
    public static ThreadInfo ForClusterTransactions(string threadName, string databaseName);
}
public class Sparrow.Server.Utils.UnguardedDisposableScope : object {
    private LinkedList`1<IDisposable> _disposables;
    private int _delayedDispose;
    public void EnsureDispose(IDisposable toDispose);
    public sealed virtual void Dispose();
    public IDisposable Delay();
}
internal class Sparrow.Server.Utils.VxSort.Avx2VectorizedSort : ValueType {
    private Void* _startPtr;
    private Void* _endPtr;
    private Byte* _tempPtr;
    private int _tempLength;
    internal static ReadOnlySpan`1<byte> perm_table_64 { get; }
    internal static ReadOnlySpan`1<byte> perm_table_32 { get; }
    public Avx2VectorizedSort(Void* start, Void* end, Byte* buffer, int bufferSize);
    private static Double* align_left_scalar_uncommon(Double* read_left, double pivot, Double*& tmp_left, Double*& tmp_right);
    private static Double* align_right_scalar_uncommon(Double* readRight, double pivot, Double*& tmpLeft, Double*& tmpRight);
    private static void align_vectorized(Double* left, Double* right, int leftAlign, int rightAlign, Vector256`1& p, Byte* pBase, Double*& readLeft, Double*& readRight, Double*& tmpStartLeft, Double*& tmpLeft, Double*& tmpStartRight, Double*& tmpRight);
    private static void partition_block(Vector256`1<double> dataVec, Vector256`1<double> p, Byte* pBase, Double*& left, Double*& right);
    private static void LoadAndPartition1Vectors(Double* dataPtr, Vector256`1<double> P, Byte* pBase, Double*& writeLeftPtr, Double*& writeRightPtr);
    private static void LoadAndPartition4Vectors(Double* dataPtr, Vector256`1<double> P, Byte* pBase, Double*& writeLeftPtr, Double*& writeRightPtr);
    private static void LoadAndPartition8Vectors(Double* dataPtr, Vector256`1<double> P, Byte* pBase, Double*& writeLeftPtr, Double*& writeRightPtr);
    [SkipLocalsInitAttribute]
private Double* vectorized_partition_8(Double* left, Double* right, long hint);
    private static void Swap(Double* left, Double* right);
    private static void SwapIfGreater(Double* leftPtr, Double* rightPtr);
    private static void SwapIfGreater3(Double*& leftPtr, Double*& middlePtr, Double*& rightPtr);
    private static void down_heap(long i, long n, Double* lo);
    private static void heap_sort(Double* lo, Double* hi);
    internal void sort(Double* left, Double* right, double left_hint, double right_hint, long hint, int depth_limit);
    private static Single* align_left_scalar_uncommon(Single* read_left, float pivot, Single*& tmp_left, Single*& tmp_right);
    private static Single* align_right_scalar_uncommon(Single* readRight, float pivot, Single*& tmpLeft, Single*& tmpRight);
    private static void align_vectorized(Single* left, Single* right, int leftAlign, int rightAlign, Vector256`1& p, Byte* pBase, Single*& readLeft, Single*& readRight, Single*& tmpStartLeft, Single*& tmpLeft, Single*& tmpStartRight, Single*& tmpRight);
    private static void partition_block(Vector256`1<float> dataVec, Vector256`1<float> p, Byte* pBase, Single*& left, Single*& right);
    private static void LoadAndPartition1Vectors(Single* dataPtr, Vector256`1<float> P, Byte* pBase, Single*& writeLeftPtr, Single*& writeRightPtr);
    private static void LoadAndPartition4Vectors(Single* dataPtr, Vector256`1<float> P, Byte* pBase, Single*& writeLeftPtr, Single*& writeRightPtr);
    private static void LoadAndPartition8Vectors(Single* dataPtr, Vector256`1<float> P, Byte* pBase, Single*& writeLeftPtr, Single*& writeRightPtr);
    [SkipLocalsInitAttribute]
private Single* vectorized_partition_8(Single* left, Single* right, long hint);
    private static void Swap(Single* left, Single* right);
    private static void SwapIfGreater(Single* leftPtr, Single* rightPtr);
    private static void SwapIfGreater3(Single*& leftPtr, Single*& middlePtr, Single*& rightPtr);
    private static void down_heap(long i, long n, Single* lo);
    private static void heap_sort(Single* lo, Single* hi);
    internal void sort(Single* left, Single* right, float left_hint, float right_hint, long hint, int depth_limit);
    internal static ReadOnlySpan`1<byte> get_perm_table_64();
    internal static ReadOnlySpan`1<byte> get_perm_table_32();
    private static Int32* align_left_scalar_uncommon(Int32* read_left, int pivot, Int32*& tmp_left, Int32*& tmp_right);
    private static Int32* align_right_scalar_uncommon(Int32* readRight, int pivot, Int32*& tmpLeft, Int32*& tmpRight);
    private static void align_vectorized(Int32* left, Int32* right, int leftAlign, int rightAlign, Vector256`1& p, Byte* pBase, Int32*& readLeft, Int32*& readRight, Int32*& tmpStartLeft, Int32*& tmpLeft, Int32*& tmpStartRight, Int32*& tmpRight);
    private static void partition_block(Vector256`1<int> dataVec, Vector256`1<int> p, Byte* pBase, Int32*& left, Int32*& right);
    private static void LoadAndPartition1Vectors(Int32* dataPtr, Vector256`1<int> P, Byte* pBase, Int32*& writeLeftPtr, Int32*& writeRightPtr);
    private static void LoadAndPartition4Vectors(Int32* dataPtr, Vector256`1<int> P, Byte* pBase, Int32*& writeLeftPtr, Int32*& writeRightPtr);
    private static void LoadAndPartition8Vectors(Int32* dataPtr, Vector256`1<int> P, Byte* pBase, Int32*& writeLeftPtr, Int32*& writeRightPtr);
    [SkipLocalsInitAttribute]
private Int32* vectorized_partition_8(Int32* left, Int32* right, long hint);
    private static void Swap(Int32* left, Int32* right);
    private static void SwapIfGreater(Int32* leftPtr, Int32* rightPtr);
    private static void SwapIfGreater3(Int32*& leftPtr, Int32*& middlePtr, Int32*& rightPtr);
    private static void down_heap(long i, long n, Int32* lo);
    private static void heap_sort(Int32* lo, Int32* hi);
    internal void sort(Int32* left, Int32* right, int left_hint, int right_hint, long hint, int depth_limit);
    private static Int64* align_left_scalar_uncommon(Int64* read_left, long pivot, Int64*& tmp_left, Int64*& tmp_right);
    private static Int64* align_right_scalar_uncommon(Int64* readRight, long pivot, Int64*& tmpLeft, Int64*& tmpRight);
    private static void align_vectorized(Int64* left, Int64* right, int leftAlign, int rightAlign, Vector256`1& p, Byte* pBase, Int64*& readLeft, Int64*& readRight, Int64*& tmpStartLeft, Int64*& tmpLeft, Int64*& tmpStartRight, Int64*& tmpRight);
    private static void partition_block(Vector256`1<long> dataVec, Vector256`1<long> p, Byte* pBase, Int64*& left, Int64*& right);
    private static void LoadAndPartition1Vectors(Int64* dataPtr, Vector256`1<long> P, Byte* pBase, Int64*& writeLeftPtr, Int64*& writeRightPtr);
    private static void LoadAndPartition4Vectors(Int64* dataPtr, Vector256`1<long> P, Byte* pBase, Int64*& writeLeftPtr, Int64*& writeRightPtr);
    private static void LoadAndPartition8Vectors(Int64* dataPtr, Vector256`1<long> P, Byte* pBase, Int64*& writeLeftPtr, Int64*& writeRightPtr);
    [SkipLocalsInitAttribute]
private Int64* vectorized_partition_8(Int64* left, Int64* right, long hint);
    private static void Swap(Int64* left, Int64* right);
    private static void SwapIfGreater(Int64* leftPtr, Int64* rightPtr);
    private static void SwapIfGreater3(Int64*& leftPtr, Int64*& middlePtr, Int64*& rightPtr);
    private static void down_heap(long i, long n, Int64* lo);
    private static void heap_sort(Int64* lo, Int64* hi);
    [SkipLocalsInitAttribute]
private static Vector256`1<int> pack_vectorized(Vector256`1<long> baseVec, Vector256`1<long> d1, Vector256`1<long> d2);
    private static void Pack(Void* mem, int len, long base);
    [SkipLocalsInitAttribute]
private static void unpack_vectorized(Vector256`1<long> baseVec, Vector256`1<int> d0, Vector256`1& u0, Vector256`1& u1);
    private static void Unpack(Void* mem, int len, long base);
    internal void sort(Int64* left, Int64* right, long left_hint, long right_hint, long hint, int depth_limit);
    private static UInt32* align_left_scalar_uncommon(UInt32* read_left, UInt32 pivot, UInt32*& tmp_left, UInt32*& tmp_right);
    private static UInt32* align_right_scalar_uncommon(UInt32* readRight, UInt32 pivot, UInt32*& tmpLeft, UInt32*& tmpRight);
    private static void align_vectorized(UInt32* left, UInt32* right, int leftAlign, int rightAlign, Vector256`1& p, Byte* pBase, UInt32*& readLeft, UInt32*& readRight, UInt32*& tmpStartLeft, UInt32*& tmpLeft, UInt32*& tmpStartRight, UInt32*& tmpRight);
    private static void partition_block(Vector256`1<UInt32> dataVec, Vector256`1<UInt32> p, Byte* pBase, UInt32*& left, UInt32*& right);
    private static void LoadAndPartition1Vectors(UInt32* dataPtr, Vector256`1<UInt32> P, Byte* pBase, UInt32*& writeLeftPtr, UInt32*& writeRightPtr);
    private static void LoadAndPartition4Vectors(UInt32* dataPtr, Vector256`1<UInt32> P, Byte* pBase, UInt32*& writeLeftPtr, UInt32*& writeRightPtr);
    private static void LoadAndPartition8Vectors(UInt32* dataPtr, Vector256`1<UInt32> P, Byte* pBase, UInt32*& writeLeftPtr, UInt32*& writeRightPtr);
    [SkipLocalsInitAttribute]
private UInt32* vectorized_partition_8(UInt32* left, UInt32* right, long hint);
    private static void Swap(UInt32* left, UInt32* right);
    private static void SwapIfGreater(UInt32* leftPtr, UInt32* rightPtr);
    private static void SwapIfGreater3(UInt32*& leftPtr, UInt32*& middlePtr, UInt32*& rightPtr);
    private static void down_heap(long i, long n, UInt32* lo);
    private static void heap_sort(UInt32* lo, UInt32* hi);
    internal void sort(UInt32* left, UInt32* right, UInt32 left_hint, UInt32 right_hint, long hint, int depth_limit);
    private static UInt64* align_left_scalar_uncommon(UInt64* read_left, ulong pivot, UInt64*& tmp_left, UInt64*& tmp_right);
    private static UInt64* align_right_scalar_uncommon(UInt64* readRight, ulong pivot, UInt64*& tmpLeft, UInt64*& tmpRight);
    private static void align_vectorized(UInt64* left, UInt64* right, int leftAlign, int rightAlign, Vector256`1& p, Byte* pBase, UInt64*& readLeft, UInt64*& readRight, UInt64*& tmpStartLeft, UInt64*& tmpLeft, UInt64*& tmpStartRight, UInt64*& tmpRight);
    private static void partition_block(Vector256`1<ulong> dataVec, Vector256`1<ulong> p, Byte* pBase, UInt64*& left, UInt64*& right);
    private static void LoadAndPartition1Vectors(UInt64* dataPtr, Vector256`1<ulong> P, Byte* pBase, UInt64*& writeLeftPtr, UInt64*& writeRightPtr);
    private static void LoadAndPartition4Vectors(UInt64* dataPtr, Vector256`1<ulong> P, Byte* pBase, UInt64*& writeLeftPtr, UInt64*& writeRightPtr);
    private static void LoadAndPartition8Vectors(UInt64* dataPtr, Vector256`1<ulong> P, Byte* pBase, UInt64*& writeLeftPtr, UInt64*& writeRightPtr);
    [SkipLocalsInitAttribute]
private UInt64* vectorized_partition_8(UInt64* left, UInt64* right, long hint);
    private static void Swap(UInt64* left, UInt64* right);
    private static void SwapIfGreater(UInt64* leftPtr, UInt64* rightPtr);
    private static void SwapIfGreater3(UInt64*& leftPtr, UInt64*& middlePtr, UInt64*& rightPtr);
    private static void down_heap(long i, long n, UInt64* lo);
    private static void heap_sort(UInt64* lo, UInt64* hi);
    [SkipLocalsInitAttribute]
private static Vector256`1<UInt32> pack_vectorized(Vector256`1<ulong> baseVec, Vector256`1<ulong> d1, Vector256`1<ulong> d2);
    private static void Pack(Void* mem, int len, ulong base);
    [SkipLocalsInitAttribute]
private static void unpack_vectorized(Vector256`1<ulong> baseVec, Vector256`1<UInt32> d0, Vector256`1& u0, Vector256`1& u1);
    private static void Unpack(Void* mem, int len, ulong base);
    internal void sort(UInt64* left, UInt64* right, ulong left_hint, ulong right_hint, long hint, int depth_limit);
}
public static class Sparrow.Server.Utils.VxSort.BitonicSort : object {
    public static ReadOnlySpan`1<byte> mask_table_4 { get; }
    public static ReadOnlySpan`1<byte> mask_table_8 { get; }
    private static void sort_01v_alt(Double* ptr, int remainder);
    private static void sort_02v_alt(Double* ptr, int remainder);
    private static void sort_03v_alt(Double* ptr, int remainder);
    private static void sort_04v_alt(Double* ptr, int remainder);
    private static void sort_05v_alt(Double* ptr, int remainder);
    private static void sort_06v_alt(Double* ptr, int remainder);
    private static void sort_07v_alt(Double* ptr, int remainder);
    private static void sort_08v_alt(Double* ptr, int remainder);
    private static void sort_09v_alt(Double* ptr, int remainder);
    private static void sort_10v_alt(Double* ptr, int remainder);
    private static void sort_11v_alt(Double* ptr, int remainder);
    private static void sort_12v_alt(Double* ptr, int remainder);
    private static void sort_13v_alt(Double* ptr, int remainder);
    private static void sort_14v_alt(Double* ptr, int remainder);
    private static void sort_15v_alt(Double* ptr, int remainder);
    private static void sort_16v_alt(Double* ptr, int remainder);
    private static void sort_17v_alt(Double* ptr, int remainder);
    private static void sort_18v_alt(Double* ptr, int remainder);
    private static void sort_19v_alt(Double* ptr, int remainder);
    private static void sort_20v_alt(Double* ptr, int remainder);
    public static void Sort(Double* ptr, int length);
    private static void sort_01v_alt(Single* ptr, int remainder);
    private static void sort_02v_alt(Single* ptr, int remainder);
    private static void sort_03v_alt(Single* ptr, int remainder);
    private static void sort_04v_alt(Single* ptr, int remainder);
    private static void sort_05v_alt(Single* ptr, int remainder);
    private static void sort_06v_alt(Single* ptr, int remainder);
    private static void sort_07v_alt(Single* ptr, int remainder);
    private static void sort_08v_alt(Single* ptr, int remainder);
    private static void sort_09v_alt(Single* ptr, int remainder);
    private static void sort_10v_alt(Single* ptr, int remainder);
    private static void sort_11v_alt(Single* ptr, int remainder);
    private static void sort_12v_alt(Single* ptr, int remainder);
    private static void sort_13v_alt(Single* ptr, int remainder);
    private static void sort_14v_alt(Single* ptr, int remainder);
    private static void sort_15v_alt(Single* ptr, int remainder);
    private static void sort_16v_alt(Single* ptr, int remainder);
    private static void sort_17v_alt(Single* ptr, int remainder);
    private static void sort_18v_alt(Single* ptr, int remainder);
    private static void sort_19v_alt(Single* ptr, int remainder);
    private static void sort_20v_alt(Single* ptr, int remainder);
    public static void Sort(Single* ptr, int length);
    public static ReadOnlySpan`1<byte> get_mask_table_4();
    public static ReadOnlySpan`1<byte> get_mask_table_8();
    public static int MaxBitonicLength();
    private static void sort_01v_alt(Int32* ptr, int remainder);
    private static void sort_02v_alt(Int32* ptr, int remainder);
    private static void sort_03v_alt(Int32* ptr, int remainder);
    private static void sort_04v_alt(Int32* ptr, int remainder);
    private static void sort_05v_alt(Int32* ptr, int remainder);
    private static void sort_06v_alt(Int32* ptr, int remainder);
    private static void sort_07v_alt(Int32* ptr, int remainder);
    private static void sort_08v_alt(Int32* ptr, int remainder);
    private static void sort_09v_alt(Int32* ptr, int remainder);
    private static void sort_10v_alt(Int32* ptr, int remainder);
    private static void sort_11v_alt(Int32* ptr, int remainder);
    private static void sort_12v_alt(Int32* ptr, int remainder);
    private static void sort_13v_alt(Int32* ptr, int remainder);
    private static void sort_14v_alt(Int32* ptr, int remainder);
    private static void sort_15v_alt(Int32* ptr, int remainder);
    private static void sort_16v_alt(Int32* ptr, int remainder);
    private static void sort_17v_alt(Int32* ptr, int remainder);
    private static void sort_18v_alt(Int32* ptr, int remainder);
    private static void sort_19v_alt(Int32* ptr, int remainder);
    private static void sort_20v_alt(Int32* ptr, int remainder);
    public static void Sort(Int32* ptr, int length);
    private static void sort_01v_alt(Int64* ptr, int remainder);
    private static void sort_02v_alt(Int64* ptr, int remainder);
    private static void sort_03v_alt(Int64* ptr, int remainder);
    private static void sort_04v_alt(Int64* ptr, int remainder);
    private static void sort_05v_alt(Int64* ptr, int remainder);
    private static void sort_06v_alt(Int64* ptr, int remainder);
    private static void sort_07v_alt(Int64* ptr, int remainder);
    private static void sort_08v_alt(Int64* ptr, int remainder);
    private static void sort_09v_alt(Int64* ptr, int remainder);
    private static void sort_10v_alt(Int64* ptr, int remainder);
    private static void sort_11v_alt(Int64* ptr, int remainder);
    private static void sort_12v_alt(Int64* ptr, int remainder);
    private static void sort_13v_alt(Int64* ptr, int remainder);
    private static void sort_14v_alt(Int64* ptr, int remainder);
    private static void sort_15v_alt(Int64* ptr, int remainder);
    private static void sort_16v_alt(Int64* ptr, int remainder);
    private static void sort_17v_alt(Int64* ptr, int remainder);
    private static void sort_18v_alt(Int64* ptr, int remainder);
    private static void sort_19v_alt(Int64* ptr, int remainder);
    private static void sort_20v_alt(Int64* ptr, int remainder);
    public static void Sort(Int64* ptr, int length);
    private static void sort_01v_alt(UInt32* ptr, int remainder);
    private static void sort_02v_alt(UInt32* ptr, int remainder);
    private static void sort_03v_alt(UInt32* ptr, int remainder);
    private static void sort_04v_alt(UInt32* ptr, int remainder);
    private static void sort_05v_alt(UInt32* ptr, int remainder);
    private static void sort_06v_alt(UInt32* ptr, int remainder);
    private static void sort_07v_alt(UInt32* ptr, int remainder);
    private static void sort_08v_alt(UInt32* ptr, int remainder);
    private static void sort_09v_alt(UInt32* ptr, int remainder);
    private static void sort_10v_alt(UInt32* ptr, int remainder);
    private static void sort_11v_alt(UInt32* ptr, int remainder);
    private static void sort_12v_alt(UInt32* ptr, int remainder);
    private static void sort_13v_alt(UInt32* ptr, int remainder);
    private static void sort_14v_alt(UInt32* ptr, int remainder);
    private static void sort_15v_alt(UInt32* ptr, int remainder);
    private static void sort_16v_alt(UInt32* ptr, int remainder);
    private static void sort_17v_alt(UInt32* ptr, int remainder);
    private static void sort_18v_alt(UInt32* ptr, int remainder);
    private static void sort_19v_alt(UInt32* ptr, int remainder);
    private static void sort_20v_alt(UInt32* ptr, int remainder);
    public static void Sort(UInt32* ptr, int length);
    private static void sort_01v_alt(UInt64* ptr, int remainder);
    private static void sort_02v_alt(UInt64* ptr, int remainder);
    private static void sort_03v_alt(UInt64* ptr, int remainder);
    private static void sort_04v_alt(UInt64* ptr, int remainder);
    private static void sort_05v_alt(UInt64* ptr, int remainder);
    private static void sort_06v_alt(UInt64* ptr, int remainder);
    private static void sort_07v_alt(UInt64* ptr, int remainder);
    private static void sort_08v_alt(UInt64* ptr, int remainder);
    private static void sort_09v_alt(UInt64* ptr, int remainder);
    private static void sort_10v_alt(UInt64* ptr, int remainder);
    private static void sort_11v_alt(UInt64* ptr, int remainder);
    private static void sort_12v_alt(UInt64* ptr, int remainder);
    private static void sort_13v_alt(UInt64* ptr, int remainder);
    private static void sort_14v_alt(UInt64* ptr, int remainder);
    private static void sort_15v_alt(UInt64* ptr, int remainder);
    private static void sort_16v_alt(UInt64* ptr, int remainder);
    private static void sort_17v_alt(UInt64* ptr, int remainder);
    private static void sort_18v_alt(UInt64* ptr, int remainder);
    private static void sort_19v_alt(UInt64* ptr, int remainder);
    private static void sort_20v_alt(UInt64* ptr, int remainder);
    public static void Sort(UInt64* ptr, int length);
}
public static class Sparrow.Server.Utils.VxSort.Sort : object {
    private static int FloorLog2(UInt32 n);
    private static int FloorLog2PlusOne(UInt32 n);
    public static void Run(T[] array);
    public static void Run(Span`1<T> array);
    public static void Run(T* start, int count);
    [SkipLocalsInitAttribute]
public static void Run(T* left, T* right);
}
