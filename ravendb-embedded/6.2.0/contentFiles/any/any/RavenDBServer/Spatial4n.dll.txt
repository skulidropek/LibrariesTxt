[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Context.Nts.NtsSpatialContext : SpatialContext {
    [ObsoleteAttribute("Use Geo static property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public static NtsSpatialContext GEO;
    protected GeometryFactory m_geometryFactory;
    protected bool m_allowMultiOverlap;
    protected bool m_useNtsPoint;
    protected bool m_useNtsLineString;
    public static NtsSpatialContext Geo { get; }
    public bool AllowMultiOverlap { get; }
    [ObsoleteAttribute("Use AllowMultiOverlap property instead. This property will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public bool IsAllowMultiOverlap { get; }
    public bool UseNtsPoint { get; }
    public bool UseNtsLineString { get; }
    public GeometryFactory GeometryFactory { get; }
    public NtsSpatialContext(NtsSpatialContextFactory factory);
    private static NtsSpatialContext();
    public static NtsSpatialContext get_Geo();
    private static NtsSpatialContext LoadGeo();
    public virtual bool get_AllowMultiOverlap();
    public virtual bool get_IsAllowMultiOverlap();
    public virtual double NormX(double x);
    public virtual double NormY(double y);
    public virtual string ToString(IShape shape);
    public virtual IGeometry GetGeometryFrom(IShape shape);
    public virtual bool get_UseNtsPoint();
    public virtual IPoint MakePoint(double x, double y);
    public virtual bool get_UseNtsLineString();
    public virtual IShape MakeLineString(IList`1<IPoint> points);
    public virtual NtsGeometry MakeShape(IGeometry geom, bool dateline180Check, bool allowMultiOverlap);
    public virtual NtsGeometry MakeShape(IGeometry geom);
    public virtual GeometryFactory get_GeometryFactory();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Context.Nts.NtsSpatialContextFactory : SpatialContextFactory {
    [CompilerGeneratedAttribute]
private static PrecisionModel <DefaultPrecisionModel>k__BackingField;
    [ObsoleteAttribute("Use DefaultPrecisionModel property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
protected static PrecisionModel defaultPrecisionModel;
    [ObsoleteAttribute("Use PrecisionModel property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public PrecisionModel precisionModel;
    [ObsoleteAttribute("Use SRID property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public int srid;
    [ObsoleteAttribute("Use CoordinateSequenceFactory property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public ICoordinateSequenceFactory coordinateSequenceFactory;
    [ObsoleteAttribute("Use DatelineRule property instead. This property will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public DatelineRule datelineRule;
    [ObsoleteAttribute("Use ValidationRule property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public ValidationRule validationRule;
    [ObsoleteAttribute("Use AutoIndex property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public bool autoIndex;
    [ObsoleteAttribute("Use AllowMultiOverlap property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public bool allowMultiOverlap;
    [ObsoleteAttribute("Use UseNtsPoint property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public bool useNtsPoint;
    [ObsoleteAttribute("Use UseNtsLineString property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public bool useNtsLineString;
    protected static PrecisionModel DefaultPrecisionModel { get; }
    public PrecisionModel PrecisionModel { get; public set; }
    public int SRID { get; public set; }
    public ICoordinateSequenceFactory CoordinateSequenceFactory { get; public set; }
    public DatelineRule DatelineRule { get; public set; }
    public ValidationRule ValidationRule { get; public set; }
    public bool AutoIndex { get; public set; }
    public bool AllowMultiOverlap { get; public set; }
    public bool UseNtsPoint { get; public set; }
    public bool UseNtsLineString { get; public set; }
    public GeometryFactory GeometryFactory { get; }
    private static NtsSpatialContextFactory();
    [CompilerGeneratedAttribute]
protected static PrecisionModel get_DefaultPrecisionModel();
    public PrecisionModel get_PrecisionModel();
    public void set_PrecisionModel(PrecisionModel value);
    public int get_SRID();
    public void set_SRID(int value);
    public ICoordinateSequenceFactory get_CoordinateSequenceFactory();
    public void set_CoordinateSequenceFactory(ICoordinateSequenceFactory value);
    public DatelineRule get_DatelineRule();
    public void set_DatelineRule(DatelineRule value);
    public ValidationRule get_ValidationRule();
    public void set_ValidationRule(ValidationRule value);
    public bool get_AutoIndex();
    public void set_AutoIndex(bool value);
    public bool get_AllowMultiOverlap();
    public void set_AllowMultiOverlap(bool value);
    public bool get_UseNtsPoint();
    public void set_UseNtsPoint(bool value);
    public bool get_UseNtsLineString();
    public void set_UseNtsLineString(bool value);
    protected virtual void Init(IDictionary`2<string, string> args, Assembly assembly);
    public virtual GeometryFactory get_GeometryFactory();
    public virtual SpatialContext CreateSpatialContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Context.SpatialContext : object {
    [ObsoleteAttribute("Use Geo static property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public static SpatialContext GEO;
    private bool geo;
    private IDistanceCalculator calculator;
    private IRectangle worldBounds;
    private WktShapeParser wktShapeParser;
    private BinaryCodec binaryCodec;
    private bool normWrapLongitude;
    public static SpatialContext Geo { get; }
    [ObsoleteAttribute("Use DistanceCalculator property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public IDistanceCalculator DistCalc { get; }
    public IDistanceCalculator DistanceCalculator { get; }
    public IRectangle WorldBounds { get; }
    public bool IsNormWrapLongitude { get; }
    public bool IsGeo { get; }
    public WktShapeParser WktShapeParser { get; }
    public BinaryCodec BinaryCodec { get; }
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public SpatialContext(bool geo, IDistanceCalculator calculator, IRectangle worldBounds);
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public SpatialContext(bool geo);
    public SpatialContext(SpatialContextFactory factory);
    private static SpatialContext();
    public static SpatialContext get_Geo();
    [NullableContextAttribute("2")]
private static SpatialContextFactory InitFromLegacyConstructor(bool geo, IDistanceCalculator calculator, IRectangle worldBounds);
    public virtual IDistanceCalculator get_DistCalc();
    public virtual IDistanceCalculator get_DistanceCalculator();
    public virtual double CalcDistance(IPoint p, double x2, double y2);
    public virtual double CalcDistance(IPoint p, IPoint p2);
    public virtual IRectangle get_WorldBounds();
    public virtual bool get_IsNormWrapLongitude();
    public virtual bool get_IsGeo();
    public virtual double NormX(double x);
    public virtual double NormY(double y);
    public virtual void VerifyX(double x);
    public virtual void VerifyY(double y);
    public virtual IPoint MakePoint(double x, double y);
    public virtual IRectangle MakeRectangle(IPoint lowerLeft, IPoint upperRight);
    public virtual IRectangle MakeRectangle(double minX, double maxX, double minY, double maxY);
    public virtual ICircle MakeCircle(double x, double y, double distance);
    public virtual ICircle MakeCircle(IPoint point, double distance);
    public virtual IShape MakeLineString(IList`1<IPoint> points);
    public virtual IShape MakeBufferedLineString(IList`1<IPoint> points, double buf);
    public virtual ShapeCollection MakeCollection(IList`1<IShape> coll);
    public virtual WktShapeParser get_WktShapeParser();
    public virtual IShape ReadShapeFromWkt(string wkt);
    public virtual BinaryCodec get_BinaryCodec();
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public virtual IShape ReadShape(string value);
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public virtual string ToString(IShape shape);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Context.SpatialContextFactory : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IDictionary`2<string, string> args;
    [NullableAttribute("2")]
protected Assembly assembly;
    [ObsoleteAttribute("Use IsGeo property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public bool geo;
    [NullableAttribute("2")]
[ObsoleteAttribute("Use DistanceCalculator property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public IDistanceCalculator distCalc;
    [NullableAttribute("2")]
[ObsoleteAttribute("Use WorldBounds property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public IRectangle worldBounds;
    [ObsoleteAttribute("Use NormWrapLongitude property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public bool normWrapLongitude;
    [ObsoleteAttribute("Use WktShapeParserType property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public Type wktShapeParserClass;
    [ObsoleteAttribute("Use BinaryCodecType property instead. This field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public Type binaryCodecClass;
    public bool IsGeo { get; public set; }
    [NullableAttribute("2")]
public IDistanceCalculator DistanceCalculator { get; public set; }
    [NullableAttribute("2")]
public IRectangle WorldBounds { get; public set; }
    public bool NormWrapLongitude { get; public set; }
    public Type WktShapeParserType { get; public set; }
    public Type BinaryCodecType { get; public set; }
    public bool get_IsGeo();
    public void set_IsGeo(bool value);
    [NullableContextAttribute("2")]
public IDistanceCalculator get_DistanceCalculator();
    [NullableContextAttribute("2")]
public void set_DistanceCalculator(IDistanceCalculator value);
    [NullableContextAttribute("2")]
public IRectangle get_WorldBounds();
    [NullableContextAttribute("2")]
public void set_WorldBounds(IRectangle value);
    public bool get_NormWrapLongitude();
    public void set_NormWrapLongitude(bool value);
    public Type get_WktShapeParserType();
    public void set_WktShapeParserType(Type value);
    public Type get_BinaryCodecType();
    public void set_BinaryCodecType(Type value);
    public static SpatialContext MakeSpatialContext(IDictionary`2<string, string> args);
    public static SpatialContext MakeSpatialContext(IDictionary`2<string, string> args, Assembly assembly);
    protected virtual void Init(IDictionary`2<string, string> args, Assembly assembly);
    protected virtual void Init(IDictionary`2<string, string> args);
    protected virtual void InitField(string name);
    protected virtual bool InitProperty(string name);
    protected virtual void InitCalculator();
    protected virtual void InitWorldBounds();
    [ObsoleteAttribute("Use CreateSpatialContext() instead.")]
[EditorBrowsableAttribute("1")]
protected internal virtual SpatialContext NewSpatialContext();
    public virtual SpatialContext CreateSpatialContext();
    public virtual WktShapeParser MakeWktShapeParser(SpatialContext ctx);
    public virtual BinaryCodec MakeBinaryCodec(SpatialContext ctx);
    private T MakeClassInstance(Type clazz, Object[] ctorArgs);
}
[ObsoleteAttribute("Use Spatial4n.Context.Nts.NtsSpatialContext instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Context.Nts.NtsSpatialContext : SpatialContext {
    public static NtsSpatialContext GEO;
    protected GeometryFactory m_geometryFactory;
    protected bool m_allowMultiOverlap;
    protected bool m_useNtsPoint;
    protected bool m_useNtsLineString;
    public bool IsAllowMultiOverlap { get; }
    public bool UseNtsPoint { get; }
    public bool UseNtsLineString { get; }
    public GeometryFactory GeometryFactory { get; }
    private static NtsSpatialContext();
    public NtsSpatialContext(NtsSpatialContextFactory factory);
    public virtual bool get_IsAllowMultiOverlap();
    public virtual double NormX(double x);
    public virtual double NormY(double y);
    public virtual string ToString(IShape shape);
    public virtual IGeometry GetGeometryFrom(IShape shape);
    public virtual bool get_UseNtsPoint();
    public virtual IPoint MakePoint(double x, double y);
    public virtual bool get_UseNtsLineString();
    public virtual IShape MakeLineString(IList`1<IPoint> points);
    public virtual NtsGeometry MakeShape(IGeometry geom, bool dateline180Check, bool allowMultiOverlap);
    public virtual NtsGeometry MakeShape(IGeometry geom);
    public virtual GeometryFactory get_GeometryFactory();
    public virtual string ToString();
}
[ObsoleteAttribute("Use Spatial4n.Context.Nts.NtsSpatialContextFactory instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Context.Nts.NtsSpatialContextFactory : SpatialContextFactory {
    protected static PrecisionModel defaultPrecisionModel;
    public PrecisionModel precisionModel;
    public int srid;
    public ICoordinateSequenceFactory coordinateSequenceFactory;
    public DatelineRule datelineRule;
    public ValidationRule validationRule;
    public bool autoIndex;
    public bool allowMultiOverlap;
    public bool useNtsPoint;
    public bool useNtsLineString;
    public GeometryFactory GeometryFactory { get; }
    private static NtsSpatialContextFactory();
    protected virtual void Init(IDictionary`2<string, string> args);
    public virtual GeometryFactory get_GeometryFactory();
    protected internal virtual SpatialContext NewSpatialContext();
}
[ObsoleteAttribute("Use Spatial4n.Context.SpatialContext instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Context.SpatialContext : object {
    public static SpatialContext GEO;
    private bool geo;
    private IDistanceCalculator calculator;
    private IRectangle worldBounds;
    private WktShapeParser wktShapeParser;
    private BinaryCodec binaryCodec;
    private bool normWrapLongitude;
    public IDistanceCalculator DistCalc { get; }
    public IRectangle WorldBounds { get; }
    public bool IsNormWrapLongitude { get; }
    public bool IsGeo { get; }
    public WktShapeParser WktShapeParser { get; }
    public BinaryCodec BinaryCodec { get; }
    [ObsoleteAttribute]
public SpatialContext(bool geo, IDistanceCalculator calculator, IRectangle worldBounds);
    [ObsoleteAttribute]
public SpatialContext(bool geo);
    public SpatialContext(SpatialContextFactory factory);
    private static SpatialContext();
    private static SpatialContextFactory InitFromLegacyConstructor(bool geo, IDistanceCalculator calculator, IRectangle worldBounds);
    public virtual IDistanceCalculator get_DistCalc();
    public virtual double CalcDistance(IPoint p, double x2, double y2);
    public virtual double CalcDistance(IPoint p, IPoint p2);
    public virtual IRectangle get_WorldBounds();
    public virtual bool get_IsNormWrapLongitude();
    public virtual bool get_IsGeo();
    public virtual double NormX(double x);
    public virtual double NormY(double y);
    public virtual void VerifyX(double x);
    public virtual void VerifyY(double y);
    public virtual IPoint MakePoint(double x, double y);
    public virtual IRectangle MakeRectangle(IPoint lowerLeft, IPoint upperRight);
    public virtual IRectangle MakeRectangle(double minX, double maxX, double minY, double maxY);
    public virtual ICircle MakeCircle(double x, double y, double distance);
    public virtual ICircle MakeCircle(IPoint point, double distance);
    public virtual IShape MakeLineString(IList`1<IPoint> points);
    public virtual IShape MakeBufferedLineString(IList`1<IPoint> points, double buf);
    public virtual ShapeCollection MakeCollection(IList`1<IShape> coll);
    public virtual WktShapeParser get_WktShapeParser();
    public virtual IShape ReadShapeFromWkt(string wkt);
    public virtual BinaryCodec get_BinaryCodec();
    [ObsoleteAttribute]
public virtual IShape ReadShape(string value);
    [ObsoleteAttribute]
public virtual string ToString(IShape shape);
    public virtual string ToString();
}
[ObsoleteAttribute("Use Spatial4n.Context.SpatialContextFactory instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Context.SpatialContextFactory : object {
    protected IDictionary`2<string, string> args;
    public bool geo;
    public IDistanceCalculator distCalc;
    public IRectangle worldBounds;
    public bool normWrapLongitude;
    public Type wktShapeParserClass;
    public Type binaryCodecClass;
    public static SpatialContext MakeSpatialContext(IDictionary`2<string, string> args);
    protected virtual void Init(IDictionary`2<string, string> args);
    protected virtual void InitField(string name);
    protected virtual void InitCalculator();
    protected virtual void InitWorldBounds();
    protected internal virtual SpatialContext NewSpatialContext();
    public virtual WktShapeParser MakeWktShapeParser(SpatialContext ctx);
    public virtual BinaryCodec MakeBinaryCodec(SpatialContext ctx);
    private T MakeClassInstance(Type clazz, Object[] ctorArgs);
}
[ObsoleteAttribute("Use Spatial4n.Distance.AbstractDistanceCalculator instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public abstract class Spatial4n.Core.Distance.AbstractDistanceCalculator : object {
    public virtual double Distance(IPoint from, IPoint to);
    public virtual bool Within(IPoint from, double toX, double toY, double distance);
    public virtual string ToString();
    public abstract virtual double Distance(IPoint from, double toX, double toY);
    public abstract virtual IPoint PointOnBearing(IPoint from, double distDEG, double bearingDEG, SpatialContext ctx, IPoint reuse);
    public abstract virtual IRectangle CalcBoxByDistFromPt(IPoint from, double distDEG, SpatialContext ctx, IRectangle reuse);
    public abstract virtual double CalcBoxByDistFromPt_yHorizAxisDEG(IPoint from, double distDEG, SpatialContext ctx);
    public abstract virtual double Area(IRectangle rect);
    public abstract virtual double Area(ICircle circle);
}
[ObsoleteAttribute("Use Spatial4n.Distance.CartesianDistanceCalculator instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Distance.CartesianDistCalc : AbstractDistanceCalculator {
    private bool squared;
    public CartesianDistCalc(bool squared);
    public virtual double Distance(IPoint from, double toX, double toY);
    public virtual bool Within(IPoint from, double toX, double toY, double distance);
    public virtual IPoint PointOnBearing(IPoint from, double distDEG, double bearingDEG, SpatialContext ctx, IPoint reuse);
    public virtual IRectangle CalcBoxByDistFromPt(IPoint from, double distDEG, SpatialContext ctx, IRectangle reuse);
    public virtual double CalcBoxByDistFromPt_yHorizAxisDEG(IPoint from, double distDEG, SpatialContext ctx);
    public virtual double Area(IRectangle rect);
    public virtual double Area(ICircle circle);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[ObsoleteAttribute("Use Spatial4n.Distance.DistanceUtils instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static class Spatial4n.Core.Distance.DistanceUtils : object {
    [ObsoleteAttribute]
public static double DEG_45_AS_RADS;
    [ObsoleteAttribute]
public static double SIN_45_AS_RADS;
    public static double DEG_90_AS_RADS;
    public static double DEG_180_AS_RADS;
    [ObsoleteAttribute]
public static double DEG_225_AS_RADS;
    [ObsoleteAttribute]
public static double DEG_270_AS_RADS;
    public static double DEGREES_TO_RADIANS;
    public static double RADIANS_TO_DEGREES;
    public static double KM_TO_MILES;
    public static double MILES_TO_KM;
    public static double EARTH_MEAN_RADIUS_KM;
    public static double EARTH_EQUATORIAL_RADIUS_KM;
    public static double DEG_TO_KM;
    public static double KM_TO_DEG;
    public static double EARTH_MEAN_RADIUS_MI;
    public static double EARTH_EQUATORIAL_RADIUS_MI;
    private static DistanceUtils();
    [ObsoleteAttribute]
public static double VectorDistance(Double[] vec1, Double[] vec2, double power);
    [ObsoleteAttribute]
public static double VectorDistance(Double[] vec1, Double[] vec2, double power, double oneOverPower);
    [ObsoleteAttribute]
public static Double[] VectorBoxCorner(Double[] center, Double[] result, double distance, bool upperRight);
    public static IPoint PointOnBearingRAD(double startLat, double startLon, double distanceRAD, double bearingRAD, SpatialContext ctx, IPoint reuse);
    public static double NormLonDEG(double lon_deg);
    public static double NormLatDEG(double lat_deg);
    public static IRectangle CalcBoxByDistFromPtDEG(double lat, double lon, double distDEG, SpatialContext ctx, IRectangle reuse);
    public static double CalcBoxByDistFromPt_deltaLonDEG(double lat, double lon, double distDEG);
    public static double CalcBoxByDistFromPt_latHorizAxisDEG(double lat, double lon, double distDEG);
    public static double CalcLonDegreesAtLat(double lat, double dist);
    [ObsoleteAttribute]
public static double DistSquaredCartesian(Double[] vec1, Double[] vec2);
    public static double DistHaversineRAD(double lat1, double lon1, double lat2, double lon2);
    public static double DistLawOfCosinesRAD(double lat1, double lon1, double lat2, double lon2);
    public static double DistVincentyRAD(double lat1, double lon1, double lat2, double lon2);
    public static double Dist2Degrees(double dist, double radius);
    public static double Degrees2Dist(double degrees, double radius);
    public static double Dist2Radians(double dist, double radius);
    public static double Radians2Dist(double radians, double radius);
    public static double ToRadians(double degrees);
    public static double ToDegrees(double radians);
}
[ObsoleteAttribute("Use Spatial4n.Distance.GeodesicSphereDistanceCalculator instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public abstract class Spatial4n.Core.Distance.GeodesicSphereDistCalc : AbstractDistanceCalculator {
    private double radiusDEG;
    public virtual IPoint PointOnBearing(IPoint from, double distDEG, double bearingDEG, SpatialContext ctx, IPoint reuse);
    public virtual IRectangle CalcBoxByDistFromPt(IPoint from, double distDEG, SpatialContext ctx, IRectangle reuse);
    public virtual double CalcBoxByDistFromPt_yHorizAxisDEG(IPoint from, double distDEG, SpatialContext ctx);
    public virtual double Area(IRectangle rect);
    public virtual double Area(ICircle circle);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual double Distance(IPoint from, double toX, double toY);
    protected abstract virtual double DistanceLatLonRAD(double lat1, double lon1, double lat2, double lon2);
}
[ObsoleteAttribute("Use Spatial4n.Distance.IDistanceCalculator instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public interface Spatial4n.Core.Distance.IDistanceCalculator {
    public abstract virtual double Distance(IPoint from, IPoint to);
    public abstract virtual double Distance(IPoint from, double toX, double toY);
    public abstract virtual bool Within(IPoint from, double toX, double toY, double distance);
    public abstract virtual IPoint PointOnBearing(IPoint from, double distDEG, double bearingDEG, SpatialContext ctx, IPoint reuse);
    public abstract virtual IRectangle CalcBoxByDistFromPt(IPoint from, double distDEG, SpatialContext ctx, IRectangle reuse);
    public abstract virtual double CalcBoxByDistFromPt_yHorizAxisDEG(IPoint from, double distDEG, SpatialContext ctx);
    public abstract virtual double Area(IRectangle rect);
    public abstract virtual double Area(ICircle circle);
}
[ObsoleteAttribute("Use Spatial4n.Exceptions.InvalidShapeException instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Exceptions.InvalidShapeException : RuntimeException {
    public InvalidShapeException(string reason);
    public InvalidShapeException(string reason, Exception exception);
    protected InvalidShapeException(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("Use Spatial4n.Exceptions.ParseException instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Exceptions.ParseException : Exception {
    [CompilerGeneratedAttribute]
private int <ErrorOffset>k__BackingField;
    public int ErrorOffset { get; private set; }
    public ParseException(string message, int errorOffset);
    protected ParseException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public int get_ErrorOffset();
    [CompilerGeneratedAttribute]
private void set_ErrorOffset(int value);
}
[ObsoleteAttribute("Use Spatial4n.Exceptions.RuntimeException instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Exceptions.RuntimeException : Exception {
    public RuntimeException(string message);
    public RuntimeException(string message, Exception innerException);
    protected RuntimeException(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("Use Spatial4n.IO.BinaryCodec instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.IO.BinaryCodec : object {
    protected SpatialContext ctx;
    public BinaryCodec(SpatialContext ctx, SpatialContextFactory factory);
    public virtual IShape ReadShape(BinaryReader dataInput);
    public virtual void WriteShape(BinaryWriter dataOutput, IShape s);
    protected virtual IShape ReadShapeByTypeIfSupported(BinaryReader dataInput, ShapeType type);
    protected virtual bool WriteShapeByTypeIfSupported(BinaryWriter dataOutput, IShape s);
    protected virtual bool WriteShapeByTypeIfSupported(BinaryWriter dataOutput, IShape s, ShapeType type);
    protected virtual ShapeType TypeForShape(IShape s);
    protected virtual double ReadDim(BinaryReader dataInput);
    protected virtual void WriteDim(BinaryWriter dataOutput, double v);
    public virtual IPoint ReadPoint(BinaryReader dataInput);
    public virtual void WritePoint(BinaryWriter dataOutput, IPoint pt);
    public virtual IRectangle ReadRect(BinaryReader dataInput);
    public virtual void WriteRect(BinaryWriter dataOutput, IRectangle r);
    public virtual ICircle ReadCircle(BinaryReader dataInput);
    public virtual void WriteCircle(BinaryWriter dataOutput, ICircle c);
    public virtual ShapeCollection ReadCollection(BinaryReader dataInput);
    public virtual void WriteCollection(BinaryWriter dataOutput, ShapeCollection col);
}
[ObsoleteAttribute("Use Spatial4n.IO.LegacyShapeReadWriterFormat instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.IO.LegacyShapeReadWriterFormat : object {
    public static string WriteShape(IShape shape);
    public static string WriteShape(IShape shape, string numberFormat);
    public static IShape ReadShapeOrNull(string str, SpatialContext ctx);
    private static IPoint ReadLatCommaLonPoint(string value, SpatialContext ctx);
}
[ObsoleteAttribute("Use Spatial4n.IO.Nts.DatelineRule instead. This enum will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public enum Spatial4n.Core.IO.Nts.DatelineRule : Enum {
    public int value__;
    public static DatelineRule None;
    public static DatelineRule Width180;
    public static DatelineRule CcwRect;
}
[ObsoleteAttribute("Use Spatial4n.IO.Nts.NtsBinaryCodec instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.IO.Nts.NtsBinaryCodec : BinaryCodec {
    protected bool useFloat;
    private static int wkbXDR;
    public NtsBinaryCodec(NtsSpatialContext ctx, NtsSpatialContextFactory factory);
    protected virtual double ReadDim(BinaryReader dataInput);
    protected virtual void WriteDim(BinaryWriter dataOutput, double v);
    protected virtual ShapeType TypeForShape(IShape s);
    protected virtual IShape ReadShapeByTypeIfSupported(BinaryReader dataInput, ShapeType type);
    protected virtual bool WriteShapeByTypeIfSupported(BinaryWriter dataOutput, IShape s, ShapeType type);
    public virtual IShape ReadNtsGeom(BinaryReader dataInput);
    public virtual void WriteNtsGeom(BinaryWriter dataOutput, IShape s);
}
[ObsoleteAttribute("Use Spatial4n.IO.Nts.NtsWktReaderShapeParser instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.IO.Nts.NtsWKTReaderShapeParser : NtsWktShapeParser {
    public NtsWKTReaderShapeParser(NtsSpatialContext ctx, NtsSpatialContextFactory factory);
    public virtual IShape ParseIfSupported(string wktString);
    protected virtual IShape ParseIfSupported(string str, WKTReader reader);
    protected virtual void CheckCoordinates(IGeometry geom);
}
[ObsoleteAttribute("Use Spatial4n.IO.Nts.NtsWktShapeParser instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.IO.Nts.NtsWktShapeParser : WktShapeParser {
    protected NtsSpatialContext m_ctx;
    protected DatelineRule m_datelineRule;
    protected ValidationRule m_validationRule;
    protected bool m_autoIndex;
    public ValidationRule ValidationRule { get; }
    public bool IsAutoValidate { get; }
    public bool IsAutoIndex { get; }
    public DatelineRule DatelineRule { get; }
    public NtsWktShapeParser(NtsSpatialContext ctx, NtsSpatialContextFactory factory);
    public virtual ValidationRule get_ValidationRule();
    public virtual bool get_IsAutoValidate();
    public virtual bool get_IsAutoIndex();
    public virtual DatelineRule get_DatelineRule();
    protected internal virtual IShape ParseShapeByType(State state, string shapeType);
    protected virtual IShape ParseLineStringShape(State state);
    protected virtual IShape ParsePolygonShape(State state);
    protected virtual IRectangle MakeRectFromPoly(IGeometry geometry);
    protected virtual IPolygon Polygon(State state);
    protected virtual IShape ParseMulitPolygonShape(State state);
    protected virtual IList`1<Coordinate[]> CoordinateSequenceList(State state);
    protected virtual Coordinate[] CoordinateSequence(State state);
    protected virtual Coordinate Coordinate(State state);
    protected virtual double NormDist(double v);
    protected virtual NtsGeometry MakeShapeFromGeometry(IGeometry geometry);
}
[ObsoleteAttribute("Use Spatial4n.IO.Nts.ValidationRule instead. This enum will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public enum Spatial4n.Core.IO.Nts.ValidationRule : Enum {
    public int value__;
    public static ValidationRule None;
    public static ValidationRule Error;
    public static ValidationRule RepairConvexHull;
    public static ValidationRule RepairBuffer0;
}
[ObsoleteAttribute("Use Spatial4n.IO.ParseUtils instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static class Spatial4n.Core.IO.ParseUtils : object {
    public static String[] ParsePoint(String[] _out, string externalVal, int dimension);
    public static Double[] ParsePointDouble(Double[] out, string externalVal, int dimension);
    public static Double[] ParseLatitudeLongitude(string latLonStr);
    public static Double[] ParseLatitudeLongitude(Double[] outLatLon, string latLonStr);
}
[ObsoleteAttribute("Use Spatial4n.IO.WktShapeParser instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.IO.WktShapeParser : object {
    protected SpatialContext m_ctx;
    public SpatialContext Ctx { get; }
    public WktShapeParser(SpatialContext ctx, SpatialContextFactory factory);
    public virtual SpatialContext get_Ctx();
    public virtual IShape Parse(string wktString);
    public virtual IShape ParseIfSupported(string wktString);
    protected internal virtual State NewState(string wktString);
    protected internal virtual IShape ParseShapeByType(State state, string shapeType);
    protected virtual IShape ParseBufferShape(State state);
    protected virtual double NormDist(double v);
    protected virtual IShape ParsePointShape(State state);
    protected virtual IShape ParseMultiPointShape(State state);
    protected virtual IShape ParseEnvelopeShape(State state);
    protected virtual IShape ParseLineStringShape(State state);
    protected virtual IShape ParseMultiLineStringShape(State state);
    protected virtual IShape ParseGeometryCollectionShape(State state);
    protected virtual IShape Shape(State state);
    protected virtual IList`1<IPoint> PointList(State state);
    protected virtual IPoint Point(State state);
}
[ObsoleteAttribute("Use Spatial4n.Shapes.ICircle instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public interface Spatial4n.Core.Shapes.ICircle {
    public double Radius { get; }
    public abstract virtual void Reset(double x, double y, double radiusDEG);
    public abstract virtual double get_Radius();
}
[ObsoleteAttribute("Use Spatial4n.Shapes.BufferedLine instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.Impl.BufferedLine : object {
    private IPoint pA;
    private IPoint pB;
    private double buf;
    private IRectangle bbox;
    private InfBufLine linePrimary;
    private InfBufLine linePerp;
    public bool IsEmpty { get; }
    public IRectangle BoundingBox { get; }
    public bool HasArea { get; }
    public IPoint Center { get; }
    public IPoint A { get; }
    public IPoint B { get; }
    public double Buf { get; }
    public InfBufLine LinePrimary { get; }
    public InfBufLine LinePerp { get; }
    public BufferedLine(IPoint pA, IPoint pB, double buf, SpatialContext ctx);
    public virtual bool get_IsEmpty();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public static double ExpandBufForLongitudeSkew(IPoint pA, IPoint pB, double buf);
    public virtual SpatialRelation Relate(IShape other);
    public virtual SpatialRelation Relate(IRectangle r);
    public virtual bool Contains(IPoint p);
    public virtual IRectangle get_BoundingBox();
    public virtual bool get_HasArea();
    public virtual double GetArea(SpatialContext ctx);
    public virtual IPoint get_Center();
    public virtual IPoint get_A();
    public virtual IPoint get_B();
    public virtual double get_Buf();
    public virtual InfBufLine get_LinePrimary();
    public virtual InfBufLine get_LinePerp();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[ObsoleteAttribute("Use Spatial4n.Shapes.BufferedLineString instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.Impl.BufferedLineString : object {
    private ShapeCollection segments;
    private double buf;
    public bool IsEmpty { get; }
    public ShapeCollection Segments { get; }
    public double Buf { get; }
    public bool HasArea { get; }
    public IPoint Center { get; }
    public IRectangle BoundingBox { get; }
    public IList`1<IPoint> Points { get; }
    public BufferedLineString(IList`1<IPoint> points, double buf, SpatialContext ctx);
    public BufferedLineString(IList`1<IPoint> points, double buf, bool expandBufForLongitudeSkew, SpatialContext ctx);
    public virtual bool get_IsEmpty();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual ShapeCollection get_Segments();
    public virtual double get_Buf();
    public virtual double GetArea(SpatialContext ctx);
    public virtual SpatialRelation Relate(IShape other);
    public virtual bool get_HasArea();
    public virtual IPoint get_Center();
    public virtual IRectangle get_BoundingBox();
    public virtual string ToString();
    public virtual IList`1<IPoint> get_Points();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[ObsoleteAttribute("Use Spatial4n.Shapes.Circle instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.Impl.Circle : object {
    protected SpatialContext ctx;
    protected IPoint point;
    protected double radiusDEG;
    protected IRectangle enclosingBox;
    public bool IsEmpty { get; }
    public IPoint Center { get; }
    public double Radius { get; }
    public bool HasArea { get; }
    public IRectangle BoundingBox { get; }
    protected double YAxis { get; }
    protected double XAxis { get; }
    public Circle(IPoint p, double radiusDEG, SpatialContext ctx);
    public virtual void Reset(double x, double y, double radiusDEG);
    public virtual bool get_IsEmpty();
    public virtual IPoint get_Center();
    public virtual double get_Radius();
    public virtual double GetArea(SpatialContext ctx);
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual bool Contains(double x, double y);
    public virtual bool get_HasArea();
    public virtual IRectangle get_BoundingBox();
    public virtual SpatialRelation Relate(IShape other);
    public virtual SpatialRelation Relate(IPoint point);
    public virtual SpatialRelation Relate(IRectangle r);
    protected virtual SpatialRelation RelateRectanglePhase2(IRectangle r, SpatialRelation bboxSect);
    protected virtual double get_YAxis();
    protected virtual double get_XAxis();
    public virtual SpatialRelation Relate(ICircle circle);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool Equals(ICircle thiz, object o);
    public virtual int GetHashCode();
    public static int GetHashCode(ICircle thiz);
}
[ObsoleteAttribute("Use Spatial4n.Shapes.GeoCircle instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.Impl.GeoCircle : Circle {
    private GeoCircle inverseCircle;
    private double horizAxisY;
    protected double YAxis { get; }
    public GeoCircle(IPoint p, double radiusDEG, SpatialContext ctx);
    public virtual void Reset(double x, double y, double radiusDEG);
    private void Init();
    protected virtual double get_YAxis();
    protected virtual SpatialRelation RelateRectanglePhase2(IRectangle r, SpatialRelation bboxSect);
    private SpatialRelation RelateRectangleCircleWrapsPole(IRectangle r, SpatialContext ctx);
    private int NumCornersIntersect(IRectangle r);
    public virtual string ToString();
    private static double Ulp(double value);
}
[ObsoleteAttribute("Use Spatial4n.Shapes.InfBufLine instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.Impl.InfBufLine : object {
    private double slope;
    private double intercept;
    private double buf;
    private double distDenomInv;
    private static Int32[] oppositeQuad;
    public double Slope { get; }
    public double Intercept { get; }
    public double Buf { get; }
    public double DistDenomInv { get; }
    internal InfBufLine(double slope, IPoint point, double buf);
    private static InfBufLine();
    internal virtual SpatialRelation Relate(IRectangle r, IPoint prC, IPoint scratch);
    internal virtual bool Contains(IPoint p);
    public virtual double DistanceUnbuffered(IPoint c);
    public virtual int Quadrant(IPoint c);
    public static void CornerByQuadrant(IRectangle r, int cornerQuad, IPoint output);
    public virtual double get_Slope();
    public virtual double get_Intercept();
    public virtual double get_Buf();
    public virtual double get_DistDenomInv();
    public virtual string ToString();
}
[ObsoleteAttribute("Use Spatial4n.Shapes.Point instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.Impl.Point : object {
    private SpatialContext ctx;
    private double x;
    private double y;
    public bool IsEmpty { get; }
    public double X { get; }
    public double Y { get; }
    public IRectangle BoundingBox { get; }
    public IPoint Center { get; }
    public bool HasArea { get; }
    public Point(double x, double y, SpatialContext ctx);
    public virtual bool get_IsEmpty();
    public virtual void Reset(double x, double y);
    public virtual double get_X();
    public virtual double get_Y();
    public virtual IRectangle get_BoundingBox();
    public virtual IPoint get_Center();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual SpatialRelation Relate(IShape other);
    public virtual bool get_HasArea();
    public virtual double GetArea(SpatialContext ctx);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public static bool Equals(IPoint thiz, object o);
    public virtual int GetHashCode();
    public static int GetHashCode(IPoint thiz);
}
[ObsoleteAttribute("This class is for internal use only. It will be removed from the public API in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.Impl.Range : object {
    protected double m_min;
    protected double m_max;
    public double Min { get; }
    public double Max { get; }
    public double Width { get; }
    public double Center { get; }
    public Range(double min, double max);
    public static Range XRange(IRectangle rect, SpatialContext ctx);
    public static Range YRange(IRectangle rect, SpatialContext ctx);
    public virtual double get_Min();
    public virtual double get_Max();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual double get_Width();
    public virtual bool Contains(double v);
    public virtual double get_Center();
    public virtual Range ExpandTo(Range other);
    public virtual double DeltaLen(Range other);
}
[ObsoleteAttribute("Use Spatial4n.Shapes.Rectangle instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.Impl.Rectangle : object {
    private SpatialContext ctx;
    private double minX;
    private double maxX;
    private double minY;
    private double maxY;
    public bool IsEmpty { get; }
    public bool HasArea { get; }
    public bool CrossesDateLine { get; }
    public double Height { get; }
    public double Width { get; }
    public double MaxX { get; }
    public double MaxY { get; }
    public double MinX { get; }
    public double MinY { get; }
    public IRectangle BoundingBox { get; }
    public IPoint Center { get; }
    public Rectangle(double minX, double maxX, double minY, double maxY, SpatialContext ctx);
    public Rectangle(IPoint lowerLeft, IPoint upperRight, SpatialContext ctx);
    public Rectangle(IRectangle r, SpatialContext ctx);
    public virtual void Reset(double minX, double maxX, double minY, double maxY);
    public virtual bool get_IsEmpty();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual bool get_HasArea();
    public virtual double GetArea(SpatialContext ctx);
    public virtual bool get_CrossesDateLine();
    public virtual double get_Height();
    public virtual double get_Width();
    public virtual double get_MaxX();
    public virtual double get_MaxY();
    public virtual double get_MinX();
    public virtual double get_MinY();
    public virtual IRectangle get_BoundingBox();
    public virtual SpatialRelation Relate(IShape other);
    public virtual SpatialRelation Relate(IPoint point);
    public virtual SpatialRelation Relate(IRectangle rect);
    private static SpatialRelation Relate_Range(double int_min, double int_max, double ext_min, double ext_max);
    public virtual SpatialRelation RelateYRange(double ext_minY, double ext_maxY);
    public virtual SpatialRelation RelateXRange(double ext_minX, double ext_maxX);
    public virtual string ToString();
    public virtual IPoint get_Center();
    public virtual bool Equals(object obj);
    public static bool Equals(IRectangle thiz, object o);
    public virtual int GetHashCode();
    public static int GetHashCode(IRectangle thiz);
}
[ObsoleteAttribute("Use Spatial4n.Shapes.IPoint instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public interface Spatial4n.Core.Shapes.IPoint {
    public double X { get; }
    public double Y { get; }
    public abstract virtual void Reset(double x, double y);
    public abstract virtual double get_X();
    public abstract virtual double get_Y();
}
[ObsoleteAttribute("Use Spatial4n.Shapes.IRectangle instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public interface Spatial4n.Core.Shapes.IRectangle {
    public double Width { get; }
    public double Height { get; }
    public double MinX { get; }
    public double MinY { get; }
    public double MaxX { get; }
    public double MaxY { get; }
    public bool CrossesDateLine { get; }
    public abstract virtual void Reset(double minX, double maxX, double minY, double maxY);
    public abstract virtual double get_Width();
    public abstract virtual double get_Height();
    public abstract virtual double get_MinX();
    public abstract virtual double get_MinY();
    public abstract virtual double get_MaxX();
    public abstract virtual double get_MaxY();
    public abstract virtual bool get_CrossesDateLine();
    public abstract virtual SpatialRelation RelateYRange(double minY, double maxY);
    public abstract virtual SpatialRelation RelateXRange(double minX, double maxX);
}
[ObsoleteAttribute("Use Spatial4n.Shapes.IShape instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public interface Spatial4n.Core.Shapes.IShape {
    public IRectangle BoundingBox { get; }
    public bool HasArea { get; }
    public IPoint Center { get; }
    public bool IsEmpty { get; }
    public abstract virtual SpatialRelation Relate(IShape other);
    public abstract virtual IRectangle get_BoundingBox();
    public abstract virtual bool get_HasArea();
    public abstract virtual double GetArea(SpatialContext ctx);
    public abstract virtual IPoint get_Center();
    public abstract virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool Equals(object other);
}
[ObsoleteAttribute("Use Spatial4n.Shapes.Nts.NtsGeometry instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.Nts.NtsGeometry : object {
    public static string SYSPROP_ASSERT_VALIDATE;
    private IGeometry geom;
    private bool _hasArea;
    private IRectangle bbox;
    protected NtsSpatialContext ctx;
    protected IPreparedGeometry preparedGeometry;
    protected bool validated;
    public bool IsEmpty { get; }
    public bool HasArea { get; }
    public IRectangle BoundingBox { get; }
    public IPoint Center { get; }
    public IGeometry Geometry { get; }
    public NtsGeometry(IGeometry geom, NtsSpatialContext ctx, bool dateline180Check, bool allowMultiOverlap);
    private static NtsGeometry();
    private bool AssertValidate();
    public virtual void Validate();
    public virtual void Index();
    public virtual bool get_IsEmpty();
    protected virtual IRectangle ComputeGeoBBox(IGeometry geoms);
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual bool get_HasArea();
    public virtual double GetArea(SpatialContext ctx);
    public virtual IRectangle get_BoundingBox();
    public virtual IPoint get_Center();
    public virtual SpatialRelation Relate(IShape other);
    public virtual SpatialRelation Relate(IPoint pt);
    public virtual SpatialRelation Relate(IRectangle rectangle);
    public virtual SpatialRelation Relate(ICircle circle);
    public virtual SpatialRelation Relate(NtsGeometry ntsGeometry);
    protected virtual SpatialRelation Relate(IGeometry oGeom);
    public static SpatialRelation IntersectionMatrixToSpatialRelation(IntersectionMatrix matrix);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual IGeometry get_Geometry();
    private static int UnwrapDateline(IGeometry geom);
    private static int UnwrapDateline(Polygon poly);
    private static int UnwrapDateline(LineString lineString);
    private static void ShiftGeomByX(IGeometry geom, int xShift);
    private static IGeometry UnionGeometryCollection(IGeometry geom);
    private static IGeometry CutUnwrappedGeomInto360(IGeometry geom);
}
[ObsoleteAttribute("Use Spatial4n.Shapes.Nts.NtsPoint instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.Nts.NtsPoint : object {
    private SpatialContext ctx;
    private IPoint pointGeom;
    private bool empty;
    public IPoint Geometry { get; }
    public bool IsEmpty { get; }
    public IPoint Center { get; }
    public bool HasArea { get; }
    public IRectangle BoundingBox { get; }
    public double X { get; }
    public double Y { get; }
    public NtsPoint(IPoint pointGeom, SpatialContext ctx);
    public virtual IPoint get_Geometry();
    public virtual bool get_IsEmpty();
    public virtual IPoint get_Center();
    public virtual bool get_HasArea();
    public virtual double GetArea(SpatialContext ctx);
    public virtual IRectangle get_BoundingBox();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual SpatialRelation Relate(IShape other);
    public virtual double get_X();
    public virtual double get_Y();
    public virtual void Reset(double x, double y);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("Use Spatial4n.Shapes.ShapeCollection instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Core.Shapes.ShapeCollection : object {
    protected IList`1<IShape> m_shapes;
    protected IRectangle m_bbox;
    public IList`1<IShape> Shapes { get; }
    public IShape Item { get; }
    public int Count { get; }
    public IRectangle BoundingBox { get; }
    public IPoint Center { get; }
    public bool HasArea { get; }
    public bool IsReadOnly { get; }
    public bool IsEmpty { get; }
    public ShapeCollection(IList`1<IShape> shapes, SpatialContext ctx);
    protected virtual IRectangle ComputeBoundingBox(ICollection`1<IShape> shapes, SpatialContext ctx);
    public virtual IList`1<IShape> get_Shapes();
    public virtual IShape get_Item(int index);
    public virtual int get_Count();
    public virtual IRectangle get_BoundingBox();
    public virtual IPoint get_Center();
    public virtual bool get_HasArea();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual SpatialRelation Relate(IShape other);
    protected virtual bool RelateContainsShortCircuits();
    protected static bool ComputeMutualDisjoint(IList`1<IShape> shapes);
    public virtual double GetArea(SpatialContext ctx);
    public virtual string ToString();
    public virtual bool Equals(object o);
    private bool ValueEquals(ShapeCollection other);
    public virtual int GetHashCode();
    public sealed virtual void Add(IShape item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(IShape item);
    public sealed virtual void CopyTo(IShape[] array, int arrayIndex);
    public sealed virtual bool Remove(IShape item);
    public sealed virtual IEnumerator`1<IShape> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool get_IsReadOnly();
    public virtual bool get_IsEmpty();
}
[ObsoleteAttribute("Use Spatial4n.Shapes.SpatialRelation instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public enum Spatial4n.Core.Shapes.SpatialRelation : Enum {
    public int value__;
    public static SpatialRelation NOT_SET;
    public static SpatialRelation WITHIN;
    public static SpatialRelation CONTAINS;
    public static SpatialRelation DISJOINT;
    public static SpatialRelation INTERSECTS;
}
[ExtensionAttribute]
[ObsoleteAttribute("Use Spatial4n.Shapes.SpatialRelationExtensions instead. This will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static class Spatial4n.Core.Shapes.SpatialRelationComparators : object {
    [ExtensionAttribute]
public static SpatialRelation Transpose(SpatialRelation sr);
    [ExtensionAttribute]
public static SpatialRelation Combine(SpatialRelation this, SpatialRelation other);
    [ExtensionAttribute]
public static bool Intersects(SpatialRelation this);
    [ExtensionAttribute]
public static SpatialRelation Inverse(SpatialRelation this);
}
[ObsoleteAttribute("Use Spatial4n.Util.GeohashUtils instead. This class will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static class Spatial4n.Core.Util.GeohashUtils : object {
    private static Char[] BASE_32;
    private static Int32[] BASE_32_IDX;
    public static int MAX_PRECISION;
    private static Int32[] BITS;
    private static Double[] hashLenToLatHeight;
    private static Double[] hashLenToLonWidth;
    private static GeohashUtils();
    public static string EncodeLatLon(double latitude, double longitude);
    public static string EncodeLatLon(double latitude, double longitude, int precision);
    public static IPoint Decode(string geohash, SpatialContext ctx);
    public static IRectangle DecodeBoundary(string geohash, SpatialContext ctx);
    public static String[] GetSubGeohashes(string baseGeohash);
    public static Double[] LookupDegreesSizeForHashLen(int hashLen);
    public static int LookupHashLenForWidthHeight(double lonErr, double latErr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Spatial4n.Distance.AbstractDistanceCalculator : object {
    public virtual double Distance(IPoint from, IPoint to);
    public virtual bool Within(IPoint from, double toX, double toY, double distance);
    public virtual string ToString();
    public abstract virtual double Distance(IPoint from, double toX, double toY);
    public abstract virtual IPoint PointOnBearing(IPoint from, double distDEG, double bearingDEG, SpatialContext ctx, IPoint reuse);
    public abstract virtual IRectangle CalcBoxByDistFromPt(IPoint from, double distDEG, SpatialContext ctx, IRectangle reuse);
    public abstract virtual double CalcBoxByDistFromPt_yHorizAxisDEG(IPoint from, double distDEG, SpatialContext ctx);
    public abstract virtual double Area(IRectangle rect);
    public abstract virtual double Area(ICircle circle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Distance.CartesianDistanceCalculator : AbstractDistanceCalculator {
    private bool squared;
    public CartesianDistanceCalculator(bool squared);
    public virtual double Distance(IPoint from, double toX, double toY);
    public virtual bool Within(IPoint from, double toX, double toY, double distance);
    public virtual IPoint PointOnBearing(IPoint from, double distDEG, double bearingDEG, SpatialContext ctx, IPoint reuse);
    public virtual IRectangle CalcBoxByDistFromPt(IPoint from, double distDEG, SpatialContext ctx, IRectangle reuse);
    public virtual double CalcBoxByDistFromPt_yHorizAxisDEG(IPoint from, double distDEG, SpatialContext ctx);
    public virtual double Area(IRectangle rect);
    public virtual double Area(ICircle circle);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Spatial4n.Distance.DistanceUtils : object {
    public static double Degrees90AsRadians;
    public static double Degrees180AsRadians;
    public static double DegreesToRadians;
    public static double RadiansToDegrees;
    public static double KilometersToMiles;
    public static double MilesToKilometers;
    public static double EarthMeanRadiusKilometers;
    public static double EarthEquatorialRadiusKilometers;
    public static double DegreesToKilometers;
    public static double KilometersToDegrees;
    public static double EarthMeanRadiusMiles;
    public static double EarthEquatorialRadiusMiles;
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public static double DEG_45_AS_RADS;
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public static double SIN_45_AS_RADS;
    [ObsoleteAttribute("Use None instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double DEG_90_AS_RADS;
    [ObsoleteAttribute("Use None instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double DEG_180_AS_RADS;
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public static double DEG_225_AS_RADS;
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public static double DEG_270_AS_RADS;
    [ObsoleteAttribute("Use DegreesToRadians instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double DEGREES_TO_RADIANS;
    [ObsoleteAttribute("Use RadiansToDegrees instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double RADIANS_TO_DEGREES;
    [ObsoleteAttribute("Use KilometersToMiles instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double KM_TO_MILES;
    [ObsoleteAttribute("Use MilesToKilometers instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double MILES_TO_KM;
    [ObsoleteAttribute("Use EarthMeanRadiusKilometers instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double EARTH_MEAN_RADIUS_KM;
    [ObsoleteAttribute("Use EarthEquatorialRadiusKilometers instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double EARTH_EQUATORIAL_RADIUS_KM;
    [ObsoleteAttribute("Use DegreesToKilometers instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double DEG_TO_KM;
    [ObsoleteAttribute("Use KilometersToDegrees instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double KM_TO_DEG;
    [ObsoleteAttribute("Use EarthMeanRadiusMiles instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double EARTH_MEAN_RADIUS_MI;
    [ObsoleteAttribute("Use EarthEquatorialRadiusMiles instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static double EARTH_EQUATORIAL_RADIUS_MI;
    private static DistanceUtils();
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public static double VectorDistance(Double[] vec1, Double[] vec2, double power);
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public static double VectorDistance(Double[] vec1, Double[] vec2, double power, double oneOverPower);
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public static Double[] VectorBoxCorner(Double[] center, Double[] result, double distance, bool upperRight);
    public static IPoint PointOnBearingRAD(double startLat, double startLon, double distanceRAD, double bearingRAD, SpatialContext ctx, IPoint reuse);
    public static double NormLonDEG(double lon_deg);
    public static double NormLatDEG(double lat_deg);
    public static IRectangle CalcBoxByDistFromPtDEG(double lat, double lon, double distDEG, SpatialContext ctx, IRectangle reuse);
    public static double CalcBoxByDistFromPt_deltaLonDEG(double lat, double lon, double distDEG);
    public static double CalcBoxByDistFromPt_latHorizAxisDEG(double lat, double lon, double distDEG);
    public static double CalcLonDegreesAtLat(double lat, double dist);
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public static double DistSquaredCartesian(Double[] vec1, Double[] vec2);
    public static double DistHaversineRAD(double lat1, double lon1, double lat2, double lon2);
    public static double DistLawOfCosinesRAD(double lat1, double lon1, double lat2, double lon2);
    public static double DistVincentyRAD(double lat1, double lon1, double lat2, double lon2);
    public static double Dist2Degrees(double dist, double radius);
    public static double Degrees2Dist(double degrees, double radius);
    public static double Dist2Radians(double dist, double radius);
    public static double Radians2Dist(double radians, double radius);
    public static double ToRadians(double degrees);
    public static double ToDegrees(double radians);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Spatial4n.Distance.GeodesicSphereDistanceCalculator : AbstractDistanceCalculator {
    private double radiusDEG;
    public virtual IPoint PointOnBearing(IPoint from, double distDEG, double bearingDEG, SpatialContext ctx, IPoint reuse);
    public virtual IRectangle CalcBoxByDistFromPt(IPoint from, double distDEG, SpatialContext ctx, IRectangle reuse);
    public virtual double CalcBoxByDistFromPt_yHorizAxisDEG(IPoint from, double distDEG, SpatialContext ctx);
    public virtual double Area(IRectangle rect);
    public virtual double Area(ICircle circle);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual double Distance(IPoint from, double toX, double toY);
    protected abstract virtual double DistanceLatLonRAD(double lat1, double lon1, double lat2, double lon2);
}
[NullableContextAttribute("1")]
public interface Spatial4n.Distance.IDistanceCalculator {
    public abstract virtual double Distance(IPoint from, IPoint to);
    public abstract virtual double Distance(IPoint from, double toX, double toY);
    public abstract virtual bool Within(IPoint from, double toX, double toY, double distance);
    public abstract virtual IPoint PointOnBearing(IPoint from, double distDEG, double bearingDEG, SpatialContext ctx, IPoint reuse);
    public abstract virtual IRectangle CalcBoxByDistFromPt(IPoint from, double distDEG, SpatialContext ctx, IRectangle reuse);
    public abstract virtual double CalcBoxByDistFromPt_yHorizAxisDEG(IPoint from, double distDEG, SpatialContext ctx);
    public abstract virtual double Area(IRectangle rect);
    public abstract virtual double Area(ICircle circle);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Spatial4n.Exceptions.InvalidShapeException : RuntimeException {
    public InvalidShapeException(string reason);
    public InvalidShapeException(string reason, Exception exception);
    [NullableContextAttribute("1")]
protected InvalidShapeException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Spatial4n.Exceptions.ParseException : Exception {
    [CompilerGeneratedAttribute]
private int <ErrorOffset>k__BackingField;
    public int ErrorOffset { get; private set; }
    public ParseException(string message, int errorOffset);
    public ParseException(string message, int errorOffset, Exception innerException);
    [NullableContextAttribute("1")]
protected ParseException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public int get_ErrorOffset();
    [CompilerGeneratedAttribute]
private void set_ErrorOffset(int value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Spatial4n.Exceptions.RuntimeException : Exception {
    public RuntimeException(string message);
    public RuntimeException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected RuntimeException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.IO.BinaryCodec : object {
    protected SpatialContext ctx;
    public BinaryCodec(SpatialContext ctx, SpatialContextFactory factory);
    public virtual IShape ReadShape(BinaryReader dataInput);
    public virtual void WriteShape(BinaryWriter dataOutput, IShape s);
    protected virtual IShape ReadShapeByTypeIfSupported(BinaryReader dataInput, ShapeType type);
    protected virtual bool WriteShapeByTypeIfSupported(BinaryWriter dataOutput, IShape s);
    protected virtual bool WriteShapeByTypeIfSupported(BinaryWriter dataOutput, IShape s, ShapeType type);
    [NullableContextAttribute("2")]
protected virtual ShapeType TypeForShape(IShape s);
    protected virtual double ReadDim(BinaryReader dataInput);
    protected virtual void WriteDim(BinaryWriter dataOutput, double v);
    public virtual IPoint ReadPoint(BinaryReader dataInput);
    public virtual void WritePoint(BinaryWriter dataOutput, IPoint pt);
    public virtual IRectangle ReadRect(BinaryReader dataInput);
    public virtual void WriteRect(BinaryWriter dataOutput, IRectangle r);
    public virtual ICircle ReadCircle(BinaryReader dataInput);
    public virtual void WriteCircle(BinaryWriter dataOutput, ICircle c);
    public virtual ShapeCollection ReadCollection(BinaryReader dataInput);
    public virtual void WriteCollection(BinaryWriter dataOutput, ShapeCollection col);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute]
public static class Spatial4n.IO.LegacyShapeReadWriterFormat : object {
    public static string WriteShape(IShape shape);
    public static string WriteShape(IShape shape, string numberFormat);
    public static IShape ReadShapeOrNull(string str, SpatialContext ctx);
    private static IPoint ReadLatCommaLonPoint(string value, SpatialContext ctx);
}
public enum Spatial4n.IO.Nts.DatelineRule : Enum {
    public int value__;
    public static DatelineRule None;
    public static DatelineRule Width180;
    public static DatelineRule CounterClockwiseRectangle;
    [ObsoleteAttribute("Use CounterClockwiseRectangle instead. This value will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static DatelineRule CcwRect;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.IO.Nts.NtsBinaryCodec : BinaryCodec {
    protected bool useFloat;
    public NtsBinaryCodec(NtsSpatialContext ctx, NtsSpatialContextFactory factory);
    protected virtual double ReadDim(BinaryReader dataInput);
    protected virtual void WriteDim(BinaryWriter dataOutput, double v);
    [NullableContextAttribute("2")]
protected virtual ShapeType TypeForShape(IShape s);
    protected virtual IShape ReadShapeByTypeIfSupported(BinaryReader dataInput, ShapeType type);
    protected virtual bool WriteShapeByTypeIfSupported(BinaryWriter dataOutput, IShape s, ShapeType type);
    public virtual IShape ReadNtsGeom(BinaryReader dataInput);
    public virtual void WriteNtsGeom(BinaryWriter dataOutput, IShape s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.IO.Nts.NtsWktReaderShapeParser : NtsWktShapeParser {
    public NtsWktReaderShapeParser(NtsSpatialContext ctx, NtsSpatialContextFactory factory);
    public virtual IShape ParseIfSupported(string wktString);
    protected virtual IShape ParseIfSupported(string str, WKTReader reader);
    protected virtual void CheckCoordinates(IGeometry geom);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.IO.Nts.NtsWktShapeParser : WktShapeParser {
    protected NtsSpatialContext m_ctx;
    protected DatelineRule m_datelineRule;
    protected ValidationRule m_validationRule;
    protected bool m_autoIndex;
    public ValidationRule ValidationRule { get; }
    public bool AutoValidate { get; }
    [ObsoleteAttribute("Use AutoValidate property instead. This property will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public bool IsAutoValidate { get; }
    public bool AutoIndex { get; }
    [ObsoleteAttribute("Use AutoIndex property instead. This property will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public bool IsAutoIndex { get; }
    public DatelineRule DatelineRule { get; }
    public NtsWktShapeParser(NtsSpatialContext ctx, NtsSpatialContextFactory factory);
    public virtual ValidationRule get_ValidationRule();
    public virtual bool get_AutoValidate();
    public virtual bool get_IsAutoValidate();
    public virtual bool get_AutoIndex();
    public virtual bool get_IsAutoIndex();
    public virtual DatelineRule get_DatelineRule();
    protected virtual IShape ParseShapeByType(State state, string shapeType);
    protected virtual IShape ParseLineStringShape(State state);
    protected virtual IShape ParsePolygonShape(State state);
    protected virtual IRectangle MakeRectFromPoly(IGeometry geometry);
    protected virtual IPolygon Polygon(State state);
    protected virtual IShape ParseMulitPolygonShape(State state);
    protected virtual IList`1<Coordinate[]> CoordinateSequenceList(State state);
    protected virtual Coordinate[] CoordinateSequence(State state);
    protected virtual Coordinate Coordinate(State state);
    protected virtual double NormDist(double v);
    protected virtual NtsGeometry MakeShapeFromGeometry(IGeometry geometry);
}
public enum Spatial4n.IO.Nts.ValidationRule : Enum {
    public int value__;
    public static ValidationRule None;
    public static ValidationRule Error;
    public static ValidationRule RepairConvexHull;
    public static ValidationRule RepairBuffer0;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Not useful; see https://github.com/spatial4j/spatial4j/issues/19")]
[EditorBrowsableAttribute("1")]
public static class Spatial4n.IO.ParseUtils : object {
    public static String[] ParsePoint(String[] output, string externalVal, int dimension);
    public static Double[] ParsePointDouble(Double[] output, string externalVal, int dimension);
    public static Double[] ParseLatitudeLongitude(string latLonStr);
    public static Double[] ParseLatitudeLongitude(Double[] outLatLon, string latLonStr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.IO.WktShapeParser : object {
    protected SpatialContext m_ctx;
    public SpatialContext Ctx { get; }
    public WktShapeParser(SpatialContext ctx, SpatialContextFactory factory);
    public virtual SpatialContext get_Ctx();
    public virtual IShape Parse(string wktString);
    public virtual IShape ParseIfSupported(string wktString);
    protected internal virtual State NewState(string wktString);
    protected virtual IShape ParseShapeByType(State state, string shapeType);
    protected virtual IShape ParseBufferShape(State state);
    protected virtual double NormDist(double v);
    protected virtual IShape ParsePointShape(State state);
    protected virtual IShape ParseMultiPointShape(State state);
    protected virtual IShape ParseEnvelopeShape(State state);
    protected virtual IShape ParseLineStringShape(State state);
    protected virtual IShape ParseMultiLineStringShape(State state);
    protected virtual IShape ParseGeometryCollectionShape(State state);
    protected virtual IShape Shape(State state);
    protected virtual IList`1<IPoint> PointList(State state);
    protected virtual IPoint Point(State state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Shapes.BufferedLine : object {
    private IPoint pA;
    private IPoint pB;
    private double buf;
    private IRectangle bbox;
    private InfBufLine linePrimary;
    private InfBufLine linePerp;
    public bool IsEmpty { get; }
    public IRectangle BoundingBox { get; }
    public bool HasArea { get; }
    public IPoint Center { get; }
    public IPoint A { get; }
    public IPoint B { get; }
    public double Buf { get; }
    [ObsoleteAttribute("This property will be removed from the public API in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public InfBufLine LinePrimary { get; }
    [ObsoleteAttribute("This property will be removed from the public API in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public InfBufLine LinePerp { get; }
    public BufferedLine(IPoint pA, IPoint pB, double buf, SpatialContext ctx);
    public virtual bool get_IsEmpty();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public static double ExpandBufForLongitudeSkew(IPoint pA, IPoint pB, double buf);
    public virtual SpatialRelation Relate(IShape other);
    public virtual SpatialRelation Relate(IRectangle r);
    public virtual bool Contains(IPoint p);
    public virtual IRectangle get_BoundingBox();
    public virtual bool get_HasArea();
    [NullableContextAttribute("2")]
public virtual double GetArea(SpatialContext ctx);
    public virtual IPoint get_Center();
    public virtual IPoint get_A();
    public virtual IPoint get_B();
    public virtual double get_Buf();
    public virtual InfBufLine get_LinePrimary();
    public virtual InfBufLine get_LinePerp();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Shapes.BufferedLineString : object {
    private ShapeCollection segments;
    private double buf;
    public bool IsEmpty { get; }
    public ShapeCollection Segments { get; }
    public double Buf { get; }
    public bool HasArea { get; }
    public IPoint Center { get; }
    public IRectangle BoundingBox { get; }
    public IList`1<IPoint> Points { get; }
    public BufferedLineString(IList`1<IPoint> points, double buf, SpatialContext ctx);
    public BufferedLineString(IList`1<IPoint> points, double buf, bool expandBufForLongitudeSkew, SpatialContext ctx);
    public virtual bool get_IsEmpty();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual ShapeCollection get_Segments();
    public virtual double get_Buf();
    [NullableContextAttribute("2")]
public virtual double GetArea(SpatialContext ctx);
    public virtual SpatialRelation Relate(IShape other);
    public virtual bool get_HasArea();
    public virtual IPoint get_Center();
    public virtual IRectangle get_BoundingBox();
    public virtual string ToString();
    public virtual IList`1<IPoint> get_Points();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Shapes.Circle : object {
    protected SpatialContext ctx;
    protected IPoint point;
    protected double radiusDEG;
    protected IRectangle enclosingBox;
    public bool IsEmpty { get; }
    public IPoint Center { get; }
    public double Radius { get; }
    public bool HasArea { get; }
    public IRectangle BoundingBox { get; }
    protected double YAxis { get; }
    protected double XAxis { get; }
    public Circle(IPoint p, double radiusDEG, SpatialContext ctx);
    public virtual void Reset(double x, double y, double radiusDEG);
    public virtual bool get_IsEmpty();
    public virtual IPoint get_Center();
    public virtual double get_Radius();
    [NullableContextAttribute("2")]
public virtual double GetArea(SpatialContext ctx);
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual bool Contains(double x, double y);
    public virtual bool get_HasArea();
    public virtual IRectangle get_BoundingBox();
    public virtual SpatialRelation Relate(IShape other);
    public virtual SpatialRelation Relate(IPoint point);
    public virtual SpatialRelation Relate(IRectangle r);
    protected virtual SpatialRelation RelateRectanglePhase2(IRectangle r, SpatialRelation bboxSect);
    protected virtual double get_YAxis();
    protected virtual double get_XAxis();
    public virtual SpatialRelation Relate(ICircle circle);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool Equals(ICircle thiz, object o);
    public virtual int GetHashCode();
    public static int GetHashCode(ICircle thiz);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Shapes.GeoCircle : Circle {
    [NullableAttribute("2")]
private GeoCircle inverseCircle;
    private double horizAxisY;
    protected double YAxis { get; }
    public GeoCircle(IPoint p, double radiusDEG, SpatialContext ctx);
    public virtual void Reset(double x, double y, double radiusDEG);
    private void Init();
    protected virtual double get_YAxis();
    protected virtual SpatialRelation RelateRectanglePhase2(IRectangle r, SpatialRelation bboxSect);
    private SpatialRelation RelateRectangleCircleWrapsPole(IRectangle r, SpatialContext ctx);
    private int NumCornersIntersect(IRectangle r);
    public virtual string ToString();
    private static double Ulp(double value);
}
public interface Spatial4n.Shapes.ICircle {
    public double Radius { get; }
    public abstract virtual void Reset(double x, double y, double radiusDEG);
    public abstract virtual double get_Radius();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This class will be removed from the public API in 0.5.0. Please open an issue on GitHub if you depend on it.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Shapes.InfBufLine : object {
    private double slope;
    private double intercept;
    private double buf;
    private double distDenomInv;
    private static Int32[] oppositeQuad;
    public double Slope { get; }
    public double Intercept { get; }
    public double Buf { get; }
    public double DistDenomInv { get; }
    internal InfBufLine(double slope, IPoint point, double buf);
    private static InfBufLine();
    internal virtual SpatialRelation Relate(IRectangle r, IPoint prC, IPoint scratch);
    internal virtual bool Contains(IPoint p);
    public virtual double DistanceUnbuffered(IPoint c);
    public virtual int Quadrant(IPoint c);
    public static void CornerByQuadrant(IRectangle r, int cornerQuad, IPoint output);
    public virtual double get_Slope();
    public virtual double get_Intercept();
    public virtual double get_Buf();
    public virtual double get_DistDenomInv();
    public virtual string ToString();
}
public interface Spatial4n.Shapes.IPoint {
    public double X { get; }
    public double Y { get; }
    public abstract virtual void Reset(double x, double y);
    public abstract virtual double get_X();
    public abstract virtual double get_Y();
}
public interface Spatial4n.Shapes.IRectangle {
    public double Width { get; }
    public double Height { get; }
    public double MinX { get; }
    public double MinY { get; }
    public double MaxX { get; }
    public double MaxY { get; }
    public bool CrossesDateLine { get; }
    public abstract virtual void Reset(double minX, double maxX, double minY, double maxY);
    public abstract virtual double get_Width();
    public abstract virtual double get_Height();
    public abstract virtual double get_MinX();
    public abstract virtual double get_MinY();
    public abstract virtual double get_MaxX();
    public abstract virtual double get_MaxY();
    public abstract virtual bool get_CrossesDateLine();
    public abstract virtual SpatialRelation RelateYRange(double minY, double maxY);
    public abstract virtual SpatialRelation RelateXRange(double minX, double maxX);
}
[NullableContextAttribute("1")]
public interface Spatial4n.Shapes.IShape {
    public IRectangle BoundingBox { get; }
    public bool HasArea { get; }
    public IPoint Center { get; }
    public bool IsEmpty { get; }
    public abstract virtual SpatialRelation Relate(IShape other);
    public abstract virtual IRectangle get_BoundingBox();
    public abstract virtual bool get_HasArea();
    [NullableContextAttribute("2")]
public abstract virtual double GetArea(SpatialContext ctx);
    public abstract virtual IPoint get_Center();
    public abstract virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public abstract virtual bool get_IsEmpty();
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(object other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Shapes.Nts.NtsGeometry : object {
    [ObsoleteAttribute("Set AssertValidate to true or false rather than configuring an environment variable. This static field will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static string SYSPROP_ASSERT_VALIDATE;
    [CompilerGeneratedAttribute]
private static bool <AssertValidate>k__BackingField;
    private IGeometry geom;
    private bool _hasArea;
    private IRectangle bbox;
    protected NtsSpatialContext ctx;
    [NullableAttribute("2")]
protected IPreparedGeometry preparedGeometry;
    protected bool validated;
    public static bool AssertValidate { get; public set; }
    public bool IsEmpty { get; }
    public bool HasArea { get; }
    public IRectangle BoundingBox { get; }
    public IPoint Center { get; }
    public IGeometry Geometry { get; }
    public NtsGeometry(IGeometry geom, NtsSpatialContext ctx, bool dateline180Check, bool allowMultiOverlap);
    private static NtsGeometry();
    [CompilerGeneratedAttribute]
public static bool get_AssertValidate();
    [CompilerGeneratedAttribute]
public static void set_AssertValidate(bool value);
    private void DoAssertValidate();
    public virtual void Validate();
    public virtual void Index();
    public virtual bool get_IsEmpty();
    protected virtual IRectangle ComputeGeoBBox(IGeometry geoms);
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual bool get_HasArea();
    [NullableContextAttribute("2")]
public virtual double GetArea(SpatialContext ctx);
    public virtual IRectangle get_BoundingBox();
    public virtual IPoint get_Center();
    public virtual SpatialRelation Relate(IShape other);
    public virtual SpatialRelation Relate(IPoint pt);
    public virtual SpatialRelation Relate(IRectangle rectangle);
    public virtual SpatialRelation Relate(ICircle circle);
    public virtual SpatialRelation Relate(NtsGeometry ntsGeometry);
    protected virtual SpatialRelation Relate(IGeometry oGeom);
    public static SpatialRelation IntersectionMatrixToSpatialRelation(IntersectionMatrix matrix);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual IGeometry get_Geometry();
    private static int UnwrapDateline(IGeometry geom);
    private static int UnwrapDateline(Polygon poly);
    private static int UnwrapDateline(ILineString lineString);
    private static void ShiftGeomByX(IGeometry geom, int xShift);
    private static IGeometry UnionGeometryCollection(IGeometry geom);
    private static IGeometry CutUnwrappedGeomInto360(IGeometry geom);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Shapes.Nts.NtsPoint : object {
    private SpatialContext ctx;
    private IPoint pointGeom;
    private bool empty;
    public IPoint Geometry { get; }
    public bool IsEmpty { get; }
    public IPoint Center { get; }
    public bool HasArea { get; }
    public IRectangle BoundingBox { get; }
    public double X { get; }
    public double Y { get; }
    public NtsPoint(IPoint pointGeom, SpatialContext ctx);
    public virtual IPoint get_Geometry();
    public virtual bool get_IsEmpty();
    public virtual IPoint get_Center();
    public virtual bool get_HasArea();
    [NullableContextAttribute("2")]
public virtual double GetArea(SpatialContext ctx);
    public virtual IRectangle get_BoundingBox();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual SpatialRelation Relate(IShape other);
    public virtual double get_X();
    public virtual double get_Y();
    public virtual void Reset(double x, double y);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Shapes.Point : object {
    [NullableAttribute("2")]
private SpatialContext ctx;
    private double x;
    private double y;
    public bool IsEmpty { get; }
    public double X { get; }
    public double Y { get; }
    public IRectangle BoundingBox { get; }
    public IPoint Center { get; }
    public bool HasArea { get; }
    [NullableContextAttribute("2")]
public Point(double x, double y, SpatialContext ctx);
    public virtual bool get_IsEmpty();
    public virtual void Reset(double x, double y);
    public virtual double get_X();
    public virtual double get_Y();
    public virtual IRectangle get_BoundingBox();
    public virtual IPoint get_Center();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual SpatialRelation Relate(IShape other);
    public virtual bool get_HasArea();
    [NullableContextAttribute("2")]
public virtual double GetArea(SpatialContext ctx);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public static bool Equals(IPoint thiz, object o);
    public virtual int GetHashCode();
    public static int GetHashCode(IPoint thiz);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This class is for internal use only. It will be removed from the public API in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public class Spatial4n.Shapes.Range : object {
    protected double m_min;
    protected double m_max;
    public double Min { get; }
    public double Max { get; }
    public double Width { get; }
    public double Center { get; }
    public Range(double min, double max);
    public static Range XRange(IRectangle rect, SpatialContext ctx);
    public static Range YRange(IRectangle rect, SpatialContext ctx);
    public virtual double get_Min();
    public virtual double get_Max();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual double get_Width();
    public virtual bool Contains(double v);
    public virtual double get_Center();
    public virtual Range ExpandTo(Range other);
    public virtual double DeltaLen(Range other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Spatial4n.Shapes.Rectangle : object {
    [NullableAttribute("2")]
private SpatialContext ctx;
    private double minX;
    private double maxX;
    private double minY;
    private double maxY;
    public bool IsEmpty { get; }
    public bool HasArea { get; }
    public bool CrossesDateLine { get; }
    public double Height { get; }
    public double Width { get; }
    public double MaxX { get; }
    public double MaxY { get; }
    public double MinX { get; }
    public double MinY { get; }
    public IRectangle BoundingBox { get; }
    public IPoint Center { get; }
    [NullableContextAttribute("2")]
public Rectangle(double minX, double maxX, double minY, double maxY, SpatialContext ctx);
    public Rectangle(IPoint lowerLeft, IPoint upperRight, SpatialContext ctx);
    public Rectangle(IRectangle r, SpatialContext ctx);
    public virtual void Reset(double minX, double maxX, double minY, double maxY);
    public virtual bool get_IsEmpty();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual bool get_HasArea();
    [NullableContextAttribute("2")]
public virtual double GetArea(SpatialContext ctx);
    public virtual bool get_CrossesDateLine();
    public virtual double get_Height();
    public virtual double get_Width();
    public virtual double get_MaxX();
    public virtual double get_MaxY();
    public virtual double get_MinX();
    public virtual double get_MinY();
    public virtual IRectangle get_BoundingBox();
    public virtual SpatialRelation Relate(IShape other);
    public virtual SpatialRelation Relate(IPoint point);
    public virtual SpatialRelation Relate(IRectangle rect);
    private static SpatialRelation Relate_Range(double int_min, double int_max, double ext_min, double ext_max);
    public virtual SpatialRelation RelateYRange(double ext_minY, double ext_maxY);
    public virtual SpatialRelation RelateXRange(double ext_minX, double ext_maxX);
    public virtual string ToString();
    public virtual IPoint get_Center();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool Equals(IRectangle thiz, object o);
    public virtual int GetHashCode();
    public static int GetHashCode(IRectangle thiz);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Spatial4n.Shapes.ShapeCollection : object {
    protected IList`1<IShape> m_shapes;
    protected IRectangle m_bbox;
    public IList`1<IShape> Shapes { get; }
    public IShape Item { get; }
    public int Count { get; }
    public IRectangle BoundingBox { get; }
    public IPoint Center { get; }
    public bool HasArea { get; }
    public bool IsReadOnly { get; }
    public bool IsEmpty { get; }
    public ShapeCollection(IList`1<IShape> shapes, SpatialContext ctx);
    protected virtual IRectangle ComputeBoundingBox(ICollection`1<IShape> shapes, SpatialContext ctx);
    public virtual IList`1<IShape> get_Shapes();
    public virtual IShape get_Item(int index);
    public virtual int get_Count();
    public virtual IRectangle get_BoundingBox();
    public virtual IPoint get_Center();
    public virtual bool get_HasArea();
    public virtual IShape GetBuffered(double distance, SpatialContext ctx);
    public virtual SpatialRelation Relate(IShape other);
    protected virtual bool RelateContainsShortCircuits();
    protected static bool ComputeMutualDisjoint(IList`1<IShape> shapes);
    [NullableContextAttribute("2")]
public virtual double GetArea(SpatialContext ctx);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    private bool ValueEquals(ShapeCollection other);
    public virtual int GetHashCode();
    public sealed virtual void Add(IShape item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(IShape item);
    public sealed virtual void CopyTo(IShape[] array, int arrayIndex);
    public sealed virtual bool Remove(IShape item);
    public sealed virtual IEnumerator`1<IShape> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool get_IsReadOnly();
    public virtual bool get_IsEmpty();
}
public enum Spatial4n.Shapes.SpatialRelation : Enum {
    public int value__;
    public static SpatialRelation None;
    [ObsoleteAttribute("Use None instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static SpatialRelation NOT_SET;
    public static SpatialRelation Within;
    [ObsoleteAttribute("Use Within instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public static SpatialRelation WITHIN;
    public static SpatialRelation Contains;
    [ObsoleteAttribute("Use Contains instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public static SpatialRelation CONTAINS;
    public static SpatialRelation Disjoint;
    [ObsoleteAttribute("Use Disjoint instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public static SpatialRelation DISJOINT;
    public static SpatialRelation Intersects;
    [ObsoleteAttribute("Use Intersects instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public static SpatialRelation INTERSECTS;
}
[ExtensionAttribute]
public static class Spatial4n.Shapes.SpatialRelationExtensions : object {
    [ExtensionAttribute]
public static SpatialRelation Transpose(SpatialRelation relation);
    [ExtensionAttribute]
public static SpatialRelation Combine(SpatialRelation relation, SpatialRelation other);
    [ExtensionAttribute]
public static bool Intersects(SpatialRelation relation);
    [ExtensionAttribute]
public static SpatialRelation Inverse(SpatialRelation relation);
}
internal static class Spatial4n.Util.CollectionUtils : object {
    [NullableContextAttribute("1")]
public static ReadOnlyCollection`1<T> EmptyList();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Spatial4n.Util.GeohashUtils : object {
    private static Char[] Base32;
    private static Int32[] Base32Index;
    public static int MaxPrecision;
    [ObsoleteAttribute("Use MaxPrecision instead. This const will be removed in 0.5.0.")]
[EditorBrowsableAttribute("1")]
public static int MAX_PRECISION;
    private static Int32[] Bits;
    private static Double[] hashLenToLatHeight;
    private static Double[] hashLenToLonWidth;
    private static GeohashUtils();
    private static Int32[] LoadBase32Index();
    public static string EncodeLatLon(double latitude, double longitude);
    public static string EncodeLatLon(double latitude, double longitude, int precision);
    public static IPoint Decode(string geohash, SpatialContext ctx);
    public static IRectangle DecodeBoundary(string geohash, SpatialContext ctx);
    public static String[] GetSubGeohashes(string baseGeohash);
    public static Double[] LookupDegreesSizeForHashLen(int hashLen);
    public static int LookupHashLenForWidthHeight(double lonErr, double latErr);
    private static Double[] LoadHashLenToLatHeight();
    private static Double[] LoadHashLenToLonWidth();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
