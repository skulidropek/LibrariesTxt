[SkipLocalsInitAttribute]
public class Voron.Data.BTrees.FoundTreePageDescriptor : ValueType {
    public static int MaxCursorPath;
    public static int MaxKeyStorage;
    public TreePage Page;
    public long Number;
    [FixedBufferAttribute("System.Int64", "8")]
public <PathSequence>e__FixedBuffer PathSequence;
    [FixedBufferAttribute("System.Byte", "256")]
public <KeyStorage>e__FixedBuffer KeyStorage;
    public SliceOptions FirstKeyOptions;
    public SliceOptions LastKeyOptions;
    public int PathLength;
    public int FirstKeyLength;
    public int LastKeyLength;
    public Span`1<byte> FirstKey { get; }
    public Span`1<byte> LastKey { get; }
    public ReadOnlySpan`1<long> Cursor { get; }
    public Span`1<byte> get_FirstKey();
    public Span`1<byte> get_LastKey();
    public ReadOnlySpan`1<long> get_Cursor();
}
public interface Voron.Data.BTrees.IPrepareForCommit {
    public abstract virtual void PrepareForCommit();
}
[ExtensionAttribute]
public static class Voron.Data.BTrees.IteratorExtensions : object {
    [IteratorStateMachineAttribute("Voron.Data.BTrees.IteratorExtensions/<DumpValues>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<string> DumpValues(IIterator self);
    [ExtensionAttribute]
public static bool ValidateCurrentKey(T self, LowLevelTransaction tx, TreeNodeHeader* node);
}
public class Voron.Data.BTrees.ParentPageAction : object {
    private TreePage _currentPage;
    private TreePage _parentPage;
    private Tree _tree;
    private TreeCursor _cursor;
    private LowLevelTransaction _tx;
    [CompilerGeneratedAttribute]
private TreePage <ParentOfAddedPageRef>k__BackingField;
    public TreePage ParentOfAddedPageRef { get; private set; }
    public ParentPageAction(TreePage parentPage, TreePage currentPage, Tree tree, TreeCursor cursor, LowLevelTransaction tx);
    [CompilerGeneratedAttribute]
public TreePage get_ParentOfAddedPageRef();
    [CompilerGeneratedAttribute]
private void set_ParentOfAddedPageRef(TreePage value);
    public Byte* AddSeparator(Slice separator, long pageRefNumber, Nullable`1<int> nodePos);
    private static void EnsureValidLastSearchPosition(TreePage page, long referencedPageNumber, int originalLastSearchPosition);
}
[SkipLocalsInitAttribute]
public class Voron.Data.BTrees.RecentlyFoundTreePages : object {
    public static int CacheSize;
    private Vector512`1<long> _pageNumberCache;
    private Vector256`1<UInt32> _pageGenerationCache;
    private UInt32 _current;
    private UInt32 _currentGeneration;
    private FoundTreePageDescriptor[] _pageDescriptors;
    private int Compare(ReadOnlySpan`1<byte> x1, ReadOnlySpan`1<byte> y1);
    public bool TryFind(Slice key, FoundTreePageDescriptor& foundPage);
    public bool TryFind(SliceOptions keyOption, ReadOnlySpan`1<byte> key, FoundTreePageDescriptor& foundPage);
    private UInt32 FindMatchingByGeneration(UInt32 generation);
    private UInt32 FindMatchingByPageNumber(long pageNumber);
    public void Reset(long num);
    public void Clear();
    public void Add(TreePage page, SliceOptions firstKeyOption, ReadOnlySpan`1<byte> firstKey, SliceOptions lastKeyOption, ReadOnlySpan`1<byte> lastKey, ReadOnlySpan`1<long> cursorPath);
}
[FlagsAttribute]
public enum Voron.Data.BTrees.StreamPageFlags : Enum {
    public byte value__;
    public static StreamPageFlags None;
    public static StreamPageFlags First;
    public static StreamPageFlags Reserved1;
    public static StreamPageFlags Reserved2;
}
public class Voron.Data.BTrees.StreamPageHeader : ValueType {
    public static int SizeOf;
    public long PageNumber;
    public PageFlags Flags;
    public StreamPageFlags StreamPageFlags;
    public long StreamNextPageNumber;
    public long ChunkSize;
    private static StreamPageHeader();
}
public class Voron.Data.BTrees.Tree : object {
    internal DecompressedPagesCache DecompressionsCache;
    private int _directAddUsage;
    private TreeMutableState _state;
    private static ObjectPool`1<RecentlyFoundTreePages> FoundPagesPool;
    private RecentlyFoundTreePages _recentlyFoundPages;
    private Dictionary`2<Slice, FixedSizeTree> _fixedSizeTrees;
    private Dictionary`2<Slice, FixedSizeTree`1<double>> _fixedSizeTreesForDouble;
    private SliceSmallSet`1<IPrepareForCommit> _prepareLocator;
    [CompilerGeneratedAttribute]
private Action`2<long, PageFlags> PageModified;
    [CompilerGeneratedAttribute]
private Action`2<long, PageFlags> PageFreed;
    [CompilerGeneratedAttribute]
private Slice <Name>k__BackingField;
    private LowLevelTransaction _llt;
    private Transaction _tx;
    public bool IsIndexTree;
    private NewPageAllocator _newPageAllocator;
    [CompilerGeneratedAttribute]
private bool <HasNewPageAllocator>k__BackingField;
    [ThreadStaticAttribute]
private static FastList`1<long> CursorPathBuffer;
    [CompilerGeneratedAttribute]
private bool <IsMultiValueTree>k__BackingField;
    private static int MaxNumberOfPagerPerChunk;
    [ThreadStaticAttribute]
private static Byte[] _localBuffer;
    public Slice Name { get; private set; }
    public TreeMutableState State { get; }
    public LowLevelTransaction Llt { get; }
    public bool IsLeafCompressionSupported { get; }
    public bool HasNewPageAllocator { get; private set; }
    public bool IsMultiValueTree { get; public set; }
    private Tree(LowLevelTransaction llt, Transaction tx, TreeRootHeader& header, Slice name, bool isIndexTree, NewPageAllocator newPageAllocator);
    private Tree(LowLevelTransaction llt, Transaction tx, Slice name, bool isIndexTree, NewPageAllocator newPageAllocator);
    public Tree(LowLevelTransaction llt, Transaction tx, Slice name, TreeMutableState state);
    private static Tree();
    public void InitializeCompression();
    private bool TryCompressPageNodes(Slice key, int len, TreePage page);
    public DecompressedLeafPage DecompressPage(TreePage p, DecompressionUsage usage, bool skipCache);
    private DecompressedLeafPage DecompressFromBuffer(DecompressionUsage usage, DecompressionInput& input);
    private DecompressedLeafPage ReuseCachedPage(DecompressedLeafPage cached, DecompressionUsage usage, DecompressionInput& input);
    private void HandleUncompressedNodes(DecompressedLeafPage decompressedPage, TreePage p, DecompressionUsage usage);
    private void HandleTombstone(DecompressedLeafPage decompressedPage, Slice nodeKey, DecompressionUsage usage);
    private void DeleteOnCompressedPage(TreePage page, Slice keyToDelete, TreeCursorConstructor& cursorConstructor);
    public DecompressedReadResult ReadDecompressed(Slice key);
    [CompilerGeneratedAttribute]
public void add_PageModified(Action`2<long, PageFlags> value);
    [CompilerGeneratedAttribute]
public void remove_PageModified(Action`2<long, PageFlags> value);
    [CompilerGeneratedAttribute]
public void add_PageFreed(Action`2<long, PageFlags> value);
    [CompilerGeneratedAttribute]
public void remove_PageFreed(Action`2<long, PageFlags> value);
    [CompilerGeneratedAttribute]
public Slice get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(Slice value);
    public TreeMutableState get_State();
    public LowLevelTransaction get_Llt();
    public bool get_IsLeafCompressionSupported();
    [CompilerGeneratedAttribute]
public bool get_HasNewPageAllocator();
    [CompilerGeneratedAttribute]
private void set_HasNewPageAllocator(bool value);
    public static Tree Open(LowLevelTransaction llt, Transaction tx, Slice name, TreeRootHeader& header, bool isIndexTree, NewPageAllocator newPageAllocator);
    public static Tree Create(LowLevelTransaction llt, Transaction tx, Slice name, TreeFlags flags, RootObjectType type, bool isIndexTree, NewPageAllocator newPageAllocator);
    [DoesNotReturnAttribute]
private static void ThrowCannotCreateTreeInReadTx();
    [DoesNotReturnAttribute]
private static void ThrowInvalidTreeCreateType();
    internal void RecordNewPage(TreePage p, int num);
    internal void RecordFreedPage(TreePage p, int num);
    public long Increment(Slice key, long delta);
    public Nullable`1<long> ReadInt64(Slice key);
    public Nullable`1<int> ReadInt32(Slice key);
    public Nullable`1<T> ReadStructure(Slice key);
    public void Add(Slice key, byte value);
    public void Add(Slice key, long value);
    public void Add(Slice key, int value);
    public void Add(Slice key, Stream value);
    private static void ValidateValueLength(Stream value);
    [DoesNotReturnAttribute]
private static void ThrowValueTooLarge();
    [DoesNotReturnAttribute]
private static void ThrowNullReferenceException();
    public void Add(Slice key, ReadOnlySpan`1<byte> value);
    public void Add(Slice key, Slice value);
    public static int CalcSizeOfEmbeddedEntry(int keySize, int entrySize);
    public DirectAddScope DirectAdd(Slice key, int len, Byte*& ptr);
    public DirectAddScope DirectAdd(Slice key, int len, TreeNodeFlags nodeType, Byte*& ptr);
    [DoesNotReturnAttribute]
private static void ThrowConcurrencyException();
    private static void ThrowUnknownNodeTypeAddOperation(TreeNodeFlags nodeType);
    [DoesNotReturnAttribute]
private static void ThrowInvalidKeySize(Slice key);
    private void ThrowCannotAddInReadTx();
    public TreePage ModifyPage(TreePage page);
    public TreePage ModifyPage(long pageNumber);
    public bool ShouldGoToOverflowPage(int len);
    private long WriteToOverflowPages(int overflowSize, Byte*& dataPos);
    internal void RemoveLeafNode(TreePage page);
    [ConditionalAttribute("VALIDATE")]
public void DebugValidateTree(long rootPageNumber);
    public void ValidateTree_Forced(long rootPageNumber);
    internal TreePage GetReadOnlyTreePage(long pageNumber);
    internal Page GetReadOnlyPage(long pageNumber);
    internal TreePage GetWriteableTreePage(long pageNumber);
    internal TreePage FindPageFor(Slice key, TreeNodeHeader*& node);
    internal TreePage FindPageFor(Slice key, TreeNodeHeader*& node, TreeCursorConstructor& cursor, bool allowCompressed);
    private TreePage SearchForPage(Slice key, TreeNodeHeader*& node);
    private int SetLastSearchPosition(Slice key, TreePage p, Boolean& leftmostPage, Boolean& rightmostPage);
    private TreePage SearchForPage(Slice key, bool allowCompressed, TreeCursorConstructor& cursorConstructor, TreeNodeHeader*& node, bool addToRecentlyFoundPages);
    [DoesNotReturnAttribute]
private static void ThrowOnCompressedPage(TreePage p);
    private void AddToRecentlyFoundPages(FastList`1<long> c, TreePage p, bool leftmostPage, bool rightmostPage);
    [SkipLocalsInitAttribute]
private void AddToRecentlyFoundPages(TreeCursor c, TreePage p, bool leftmostPage, bool rightmostPage);
    private bool TryUseRecentTransactionPage(Slice key, TreePage& page, TreeNodeHeader*& node);
    private bool TryUseRecentTransactionPage(Slice key, TreeCursorConstructor& cursor, TreePage& page, TreeNodeHeader*& node);
    internal TreePage NewPage(TreePageFlags flags, long nearbyPage);
    private static TreePage PrepareTreePage(TreePageFlags flags, int num, Page newPage);
    internal void FreePage(TreePage p);
    [DoesNotReturnAttribute]
public static void ThrowAttemptToFreeIndexPageToFreeSpaceHandling(Slice treeName, long pageNumber);
    [DoesNotReturnAttribute]
public static void ThrowAttemptToFreePageToNewPageAllocator(Slice treeName, long pageNumber);
    public void Delete(Slice key);
    public TreeIterator Iterate(bool prefetch);
    public ReadResult Read(Slice key);
    public bool Exists(Slice key);
    public int GetDataSize(Slice key);
    public int GetDataSize(TreeNodeHeader* node);
    public void RemoveEmptyDecompressedPage(DecompressedLeafPage emptyPage);
    public long GetParentPageOf(TreePage page);
    internal Byte* DirectRead(Slice key);
    public List`1<long> AllPages();
    public virtual string ToString();
    internal void PrepareForCommit();
    [ConditionalAttribute("DEBUG")]
internal void AssertNotDisposed();
    private bool TryOverwriteOverflowPages(TreeNodeHeader* updatedNode, int len, Byte*& pos);
    public void ClearPagesCache();
    public CompactTree CompactTreeFor(string key);
    public CompactTree CompactTreeFor(Slice key);
    public Lookup`1<TKey> LookupFor(Slice key);
    public FixedSizeTree FixedTreeFor(Slice key, byte valSize);
    public FixedSizeTree`1<double> FixedTreeForDouble(Slice key, byte valSize);
    public long DeleteFixedTreeFor(Slice key, byte valSize);
    [ConditionalAttribute("DEBUG")]
public void DebugRenderAndShow();
    public Byte* DirectAccessFromHeader(TreeNodeHeader* node);
    public Slice GetData(TreeNodeHeader* node);
    public ValueReader GetValueReaderFromHeader(TreeNodeHeader* node);
    public void Rename(Slice newName);
    internal void SetNewPageAllocator(NewPageAllocator newPageAllocator);
    internal void DebugValidateBranchReferences();
    public void Forget(Slice name);
    public long Increment(string key, long delta);
    public void Add(string key, Stream value);
    public void Add(string key, Byte[] value);
    public void Add(string key, string value);
    public DirectAddScope DirectAdd(string key, int len, Byte*& ptr);
    public DirectAddScope DirectAdd(string key, int len, TreeNodeFlags nodeType, Byte*& ptr);
    public void Delete(string key);
    public ReadResult Read(string key);
    public bool Exists(string key);
    public void MultiAdd(string key, string value);
    public void MultiAdd(string key, Slice value);
    public void MultiAdd(Slice key, string value);
    public void MultiDelete(string key, string value);
    public void MultiDelete(Slice key, string value);
    public void MultiDelete(string key, Slice value);
    public IIterator MultiRead(string key);
    public long DeleteFixedTreeFor(string key, byte valSize);
    public FixedSizeTree FixedTreeFor(string key, byte valSize);
    public FixedSizeTree`1<TVal> FixedSizeTree(Tree fieldsTree, Slice fieldName, byte valSize);
    public long GetLookupRootPage(Slice name);
    public Dictionary`2<long, string> GetFieldsRootPages();
    [CompilerGeneratedAttribute]
public bool get_IsMultiValueTree();
    [CompilerGeneratedAttribute]
public void set_IsMultiValueTree(bool value);
    public void MultiAdd(Slice key, Slice value);
    private void ExpandMultiTreeNestedPageSize(Slice key, Slice value, Byte* nestedPagePtr, ushort newSize, int currentSize);
    private void MultiAddOnNewValue(Slice key, Slice value, int maxNodeSize);
    public void MultiDelete(Slice key, Slice value);
    public long MultiCount(Slice key);
    public IIterator MultiRead(Slice key);
    private Tree OpenMultiValueTree(Slice key, TreeNodeHeader* item);
    private bool TryOverwriteDataOrMultiValuePageRefNode(TreeNodeHeader* updatedNode, int len, TreeNodeFlags requestedNodeType, Byte*& pos);
    private void EnsureNestedPagePointer(TreePage page, TreeNodeHeader* currentItem, TreePage& nestedPage, Byte*& nestedPagePtr);
    public void AddStream(string key, Stream stream, string tag, Nullable`1<int> initialNumberOfPagesPerChunk);
    public void AddStream(Slice key, Stream stream, Nullable`1<Slice> tag, Nullable`1<int> initialNumberOfPagesPerChunk);
    public VoronStream ReadStream(string key);
    public VoronStream ReadStream(Slice key);
    public ChunkDetails[] ReadTreeChunks(Slice key, FixedSizeTree& tree);
    public bool StreamExist(Slice key);
    public int TouchStream(Slice key);
    public Nullable`1<StreamInfo> GetStreamInfoForReporting(Slice key, String& tag);
    public StreamInfo* GetStreamInfo(Slice key, bool writable);
    private bool TryGetLastChunkDetailsForStream(Slice key, ChunkDetails& lastChunk);
    internal FixedSizeTree GetStreamChunksTree(Slice key);
    public int DeleteStream(string key);
    public ValueTuple`2<int, long> DeleteStream(Slice key);
    internal List`1<long> GetStreamPages(FixedSizeTree chunksTree, StreamInfo* info);
    public string GetStreamTag(Slice key);
    public InternalScope<ByteStringMemoryCache> GetStreamTag(Slice key, Slice& tag);
    public string GetStreamTag(string key);
    private string GetStreamTag(StreamInfo* info);
    [DoesNotReturnAttribute]
private void ThrowStreamSizeMismatch(Slice name, long totalChunksSize, StreamInfo* info);
    [CompilerGeneratedAttribute]
private void <DebugValidateBranchReferences>g__Validate|126_0(TreePage pageRef, Slice refKey, <>c__DisplayClass126_0& );
    [CompilerGeneratedAttribute]
private bool <GetStreamInfoForReporting>g__CanRemovePage|175_0(long pageNumber, <>c__DisplayClass175_0& );
    [CompilerGeneratedAttribute]
private void <GetStreamInfoForReporting>g__RemovePage|175_1(<>c__DisplayClass175_0& );
}
public class Voron.Data.BTrees.TreeCursor : object {
    private static ObjectPool`1<TreeCursorState> _pagesByNumPool;
    private bool _anyOverrides;
    private TreeCursorState _state;
    public FastStack`1<TreePage> Pages { get; }
    public TreePage ParentPage { get; }
    public TreePage CurrentPage { get; }
    public int PageCount { get; }
    private static TreeCursor();
    public FastStack`1<TreePage> get_Pages();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public void Update(FastStack`1<TreePage> stack, TreePage newVal);
    public TreePage get_ParentPage();
    public TreePage get_CurrentPage();
    public int get_PageCount();
    public void Push(TreePage p);
    public TreePage Pop();
}
public class Voron.Data.BTrees.TreeCursorConstructor : ValueType {
    private Tree _tree;
    private LowLevelTransaction _llt;
    private Int64[] _cursorPath;
    private long _lastFoundPageNumber;
    private TreePage _pageCopy;
    private TreeCursor _current;
    public TreeCursorConstructor(TreeCursor cursor);
    public TreeCursorConstructor(LowLevelTransaction llt, Tree tree, TreePage pageCopy, Int64[] cursorPath, long lastFoundPageNumber);
    public TreeCursor Build(Slice key);
}
[FlagsAttribute]
public enum Voron.Data.BTrees.TreeFlags : Enum {
    public byte value__;
    public static TreeFlags None;
    public static TreeFlags MultiValue;
    public static TreeFlags FixedSizeTrees;
    public static TreeFlags MultiValueTrees;
    public static TreeFlags LeafsCompressed;
    public static TreeFlags Streams;
    public static TreeFlags CompactTrees;
    public static TreeFlags Lookups;
}
public class Voron.Data.BTrees.TreeIterator : object {
    private Tree _tree;
    private LowLevelTransaction _tx;
    private bool _prefetch;
    private TreeCursor _cursor;
    private TreePage _currentPage;
    private bool _disposed;
    private DecompressedLeafPage _decompressedPage;
    [CompilerGeneratedAttribute]
private Action`1<IIterator> OnDisposal;
    private Slice _currentKey;
    private Slice _currentInternalKey;
    private ExternalScope<ByteStringMemoryCache> _prevKeyScope;
    private bool _requireValidation;
    private Slice _requiredPrefix;
    private Slice _maxKey;
    public Slice CurrentKey { get; }
    public TreeNodeHeader* Current { get; }
    public bool DoRequireValidation { get; }
    public Slice RequiredPrefix { get; }
    public Slice MaxKey { get; public set; }
    public TreeIterator(Tree tree, LowLevelTransaction tx, bool prefetch);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnDisposal(Action`1<IIterator> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnDisposal(Action`1<IIterator> value);
    public sealed virtual int GetCurrentDataSize();
    public sealed virtual bool Seek(Slice key);
    public sealed virtual Slice get_CurrentKey();
    public TreeNodeHeader* get_Current();
    public sealed virtual bool MovePrev();
    private void MaybePrefetchPagesReferencedBy(TreePage page);
    public sealed virtual bool MoveNext();
    public sealed virtual bool Skip(long count);
    public sealed virtual ValueReader CreateReaderForCurrent();
    public sealed virtual void Dispose();
    public sealed virtual bool get_DoRequireValidation();
    public sealed virtual Slice get_RequiredPrefix();
    public sealed virtual void SetRequiredPrefix(Slice prefix);
    public sealed virtual Slice get_MaxKey();
    public sealed virtual void set_MaxKey(Slice value);
    private void DecompressedCurrentPage();
}
public class Voron.Data.BTrees.TreeMutableState : object {
    private TreeRootHeader _header;
    private bool _stateIsModified;
    private LowLevelTransaction _tx;
    [IsReadOnlyAttribute]
public TreeRootHeader& modreq(System.Runtime.InteropServices.InAttribute) Header { get; }
    public bool IsModified { get; }
    public TreeMutableState(LowLevelTransaction tx);
    internal TreeMutableState(LowLevelTransaction tx, TreeMutableState state);
    internal TreeMutableState(LowLevelTransaction tx, TreeRootHeader& header);
    public TreeRootHeader& modreq(System.Runtime.InteropServices.InAttribute) get_Header();
    public bool get_IsModified();
    internal TreeRootHeader& Modify();
    [DoesNotReturnAttribute]
private static void ThrowCanOnlyModifyInWriteTransaction();
    public void CopyTo(TreeRootHeader* header);
    public void CopyTo(TreeRootHeader& header);
    public TreeMutableState Clone();
    public virtual string ToString();
}
[FlagsAttribute]
public enum Voron.Data.BTrees.TreeNodeFlags : Enum {
    public byte value__;
    public static TreeNodeFlags Data;
    public static TreeNodeFlags PageRef;
    public static TreeNodeFlags MultiValuePageRef;
    public static TreeNodeFlags CompressionTombstone;
    public static TreeNodeFlags NewOnly;
}
public class Voron.Data.BTrees.TreeNodeHeader : ValueType {
    public static int SizeOf;
    private static int NodeTypeSizeOf;
    public int DataSize;
    public long PageNumber;
    public TreeNodeFlags Flags;
    public ushort KeySize;
    public int GetNodeSize();
    public static string ToDebugString(TreeNodeHeader* node);
    public static InternalScope<ByteStringMemoryCache> ToSlice(ByteStringContext context, TreeNodeHeader* node, ByteStringType type, Slice& str);
    public static ExternalScope<ByteStringMemoryCache> ToSlicePtr(ByteStringContext context, TreeNodeHeader* node, Slice& slice);
    public static ExternalScope<ByteStringMemoryCache> ToSlicePtr(ByteStringContext context, TreeNodeHeader* node, ByteStringType type, Slice& slice);
    public static ValueReader Reader(LowLevelTransaction tx, TreeNodeHeader* node);
    public static ExternalScope<ByteStringMemoryCache> GetData(LowLevelTransaction tx, TreeNodeHeader* node, Slice& slice);
    public static ReadOnlySpan`1<byte> GetKeyAsSpan(TreeNodeHeader* node);
    public static Byte* GetKeyPtr(TreeNodeHeader* node, Int32& size);
}
public class Voron.Data.BTrees.TreePage : object {
    public int PageSize;
    public Byte* Base;
    public int LastMatch;
    public int LastSearchPosition;
    public bool Dirty;
    private TreePageHeader* Header { get; }
    public long PageNumber { get; public set; }
    public TreePageFlags TreeFlags { get; public set; }
    public ushort Lower { get; public set; }
    public ushort Upper { get; public set; }
    public int OverflowSize { get; public set; }
    public UInt16* KeysOffsets { get; }
    public bool IsLeaf { get; }
    public bool IsBranch { get; }
    public bool IsOverflow { get; }
    public bool IsCompressed { get; }
    public CompressedNodesHeader* CompressionHeader { get; }
    public ushort NumberOfEntries { get; }
    public int SizeLeft { get; }
    public int SizeUsed { get; }
    public int LastSearchPositionOrLastEntry { get; }
    public int PageMaxSpace { get; }
    public PageFlags Flags { get; public set; }
    public TreePage(Byte* basePtr, int pageSize);
    public static void Initialize(Byte* ptr, int pageSize);
    private TreePageHeader* get_Header();
    public long get_PageNumber();
    public void set_PageNumber(long value);
    public TreePageFlags get_TreeFlags();
    public void set_TreeFlags(TreePageFlags value);
    public ushort get_Lower();
    public void set_Lower(ushort value);
    public ushort get_Upper();
    public void set_Upper(ushort value);
    public int get_OverflowSize();
    public void set_OverflowSize(int value);
    public UInt16* get_KeysOffsets();
    public TreeNodeHeader* Search(LowLevelTransaction tx, Slice key);
    [DoesNotReturnAttribute]
private void ThrowNotSupportedException();
    public TreeNodeHeader* GetNode(int n);
    public bool get_IsLeaf();
    public bool get_IsBranch();
    public bool get_IsOverflow();
    public bool get_IsCompressed();
    public CompressedNodesHeader* get_CompressionHeader();
    public ushort get_NumberOfEntries();
    public void RemoveNode(int index);
    public Byte* AddPageRefNode(int index, Slice key, long pageNumber);
    public Byte* AddDataNode(int index, Slice key, int dataSize);
    public Byte* AddMultiValueNode(int index, Slice key, int dataSize);
    public void AddCompressionTombstoneNode(int index, Slice key);
    public void ChangeImplicitRefPageNode(long implicitRefPageNumber);
    private TreeNodeHeader* CreateNode(int index, Slice key, TreeNodeFlags flags, int len);
    internal void CopyNodeDataToEndOfPage(TreeNodeHeader* other, Slice key);
    private TreeNodeHeader* AllocateNewNode(int index, int nodeSize);
    public int get_SizeLeft();
    public int get_SizeUsed();
    public int get_LastSearchPositionOrLastEntry();
    public void Truncate(LowLevelTransaction tx, int i);
    public int NodePositionFor(LowLevelTransaction tx, Slice key);
    public int NodePositionReferencing(long pageNumber);
    public virtual string ToString();
    public string Dump();
    public bool HasSpaceFor(LowLevelTransaction tx, int len);
    internal void Defrag(LowLevelTransaction tx);
    private bool HasSpaceFor(int len);
    public bool HasSpaceFor(LowLevelTransaction tx, Slice key, int len);
    private bool HasSpaceFor(Slice key, int len);
    public int GetRequiredSpace(Slice key, int len);
    public int get_PageMaxSpace();
    public PageFlags get_Flags();
    public void set_Flags(PageFlags value);
    public Scope<ByteStringMemoryCache> GetNodeKey(LowLevelTransaction tx, int nodeNumber, Slice& result);
    public Scope<ByteStringMemoryCache> GetNodeKey(LowLevelTransaction tx, int nodeNumber, ByteStringType type, Slice& result);
    public void GetNodeKey(int nodeNumber, ReadOnlySpan`1& result);
    public string DebugView(LowLevelTransaction tx);
    [ConditionalAttribute("VALIDATE")]
public void DebugValidate(Tree tree, long root);
    public bool UseMoreSizeThan(int len);
    public int CalcSizeUsed();
    public int CalcSizeLeft();
    public void EnsureHasSpaceFor(LowLevelTransaction tx, Slice key, int len);
}
[FlagsAttribute]
public enum Voron.Data.BTrees.TreePageFlags : Enum {
    public byte value__;
    public static TreePageFlags None;
    public static TreePageFlags Branch;
    public static TreePageFlags Leaf;
    public static TreePageFlags Value;
}
public class Voron.Data.BTrees.TreePageHeader : ValueType {
    public static int SizeOf;
    public long PageNumber;
    public int OverflowSize;
    public PageFlags Flags;
    public TreePageFlags TreeFlags;
    public ushort Lower;
    public ushort Upper;
}
public class Voron.Data.BTrees.TreePageIterator : object {
    private Slice _treeKey;
    private Tree _parent;
    private TreePage _page;
    private LowLevelTransaction _tx;
    private Slice _currentKey;
    private Slice _currentInternalKey;
    private ExternalScope<ByteStringMemoryCache> _prevScopeDispose;
    private bool _disposed;
    private bool _requireValidation;
    private Slice _requiredPrefix;
    private Slice _maxKey;
    [CompilerGeneratedAttribute]
private Action`1<IIterator> OnDisposal;
    public TreeNodeHeader* Current { get; }
    public Slice CurrentKey { get; }
    public bool DoRequireValidation { get; }
    public Slice RequiredPrefix { get; }
    public Slice MaxKey { get; public set; }
    public TreePageIterator(LowLevelTransaction tx, Slice treeKey, Tree parent, TreePage page);
    public sealed virtual void Dispose();
    public sealed virtual bool Seek(Slice key);
    public TreeNodeHeader* get_Current();
    public sealed virtual Slice get_CurrentKey();
    public sealed virtual int GetCurrentDataSize();
    public sealed virtual bool get_DoRequireValidation();
    public sealed virtual Slice get_RequiredPrefix();
    public sealed virtual void SetRequiredPrefix(Slice prefix);
    public sealed virtual Slice get_MaxKey();
    public sealed virtual void set_MaxKey(Slice value);
    public sealed virtual bool MoveNext();
    public sealed virtual bool MovePrev();
    public sealed virtual bool Skip(long count);
    [DoesNotReturnAttribute]
private static void ThrowSkipTooBig(long count);
    private bool TrySetPosition();
    public sealed virtual ValueReader CreateReaderForCurrent();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnDisposal(Action`1<IIterator> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnDisposal(Action`1<IIterator> value);
}
public class Voron.Data.BTrees.TreePageSplitter : object {
    private static DecompressionUsage WriteDecompressionUsage;
    private TreeCursor _cursor;
    private bool _splittingOnDecompressed;
    private int _len;
    private Slice _newKey;
    private TreeNodeFlags _nodeType;
    private long _pageNumber;
    private LowLevelTransaction _tx;
    private Tree _tree;
    private TreePage _page;
    private TreePage _parentPage;
    private DecompressedLeafPage _pageDecompressed;
    public TreePageSplitter(LowLevelTransaction tx, Tree tree, Slice newKey, int len, long pageNumber, TreeNodeFlags nodeType, TreeCursor cursor, bool splittingOnDecompressed);
    private FreeSpaceHandlingDisabler DisableFreeSpaceUsageIfSplittingRootTree();
    public Byte* Execute();
    private void RecompressPageIfNeeded(bool wasModified);
    private Byte* OptimizedOnlyMoveNewValueToTheRightPage(TreePage rightPage);
    private Byte* AddNodeToPage(TreePage page, int index, Slice alreadyPreparedNewKey);
    private Byte* SplitPageInHalf(TreePage rightPage);
    private void RemoveBranchWithOneEntry(TreePage page, TreePage parentPage);
    private Byte* InsertNewKey(TreePage p);
    private Byte* AddSeparatorToParentPage(long pageRefNumber, Slice separatorKey, TreePage& parentOfPageRef);
    private int AdjustSplitPosition(int currentIndex, int splitIndex, TreePage rightPage, Boolean& toRight);
    private string GatherDetailedDebugInfo(TreePage rightPage, Slice currentKey, Slice seperatorKey, int currentIndex, int splitIndex, bool toRight);
}
public class Voron.Data.BTrees.TreeRebalancer : object {
    private LowLevelTransaction _tx;
    private Tree _tree;
    private TreeCursor _cursor;
    public TreeRebalancer(LowLevelTransaction tx, Tree tree, TreeCursor cursor);
    private FreeSpaceHandlingDisabler DisableFreeSpaceUsageIfSplittingRootTree();
    public TreePage Execute(TreePage page);
    private void RemoveBranchWithOneEntry(TreePage page, TreePage parentPage);
    private bool TryMergePages(TreePage parentPage, TreePage left, TreePage right);
    private TreePage SetupMoveOrMerge(TreePage page, TreePage parentPage);
    private void MoveLeafNode(TreePage parentPage, TreePage from, TreePage to);
    private void AddSeparatorToParentPage(TreePage childPage, TreePage parentPage, long pageNumber, Slice seperatorKey, int separatorKeyPosition);
    private void MoveBranchNode(TreePage parentPage, TreePage from, TreePage to);
    private ActualKeyScope GetActualKey(TreePage page, int pos, Slice& slice);
    private ActualKeyScope GetActualKey(TreePage page, int pos, TreeNodeHeader*& node, Slice& key);
    private void RebalanceRoot(TreePage page);
}
public class Voron.Data.BTrees.TreeRootHeader : ValueType {
    public RootObjectType RootObjectType;
    public TreeFlags Flags;
    public long RootPageNumber;
    public long BranchPages;
    public long LeafPages;
    public long OverflowPages;
    public long PageCount;
    public long NumberOfEntries;
    public int Depth;
}
internal class Voron.Data.BTrees.TreeSizeOf : object {
    public static int LeafEntry(int pageMaxSpace, Slice key, int len);
    public static int BranchEntry(Slice key);
    public static int NodeEntry(int pageMaxSpace, Slice key, int len);
    public static int NodeEntry(TreeNodeHeader* other);
    public static int NodeEntryWithAnotherKey(TreeNodeHeader* other, Slice key);
}
public class Voron.Data.CompactTrees.CompactKey : object {
    public static CompactKey NullInstance;
    [ThreadStaticAttribute]
private static ArrayPool`1<byte> StoragePool;
    [ThreadStaticAttribute]
private static ArrayPool`1<long> KeyMappingPool;
    private LowLevelTransaction _owner;
    private static int MappingTableSize;
    private static int MappingTableMask;
    private Int64[] _keyMappingCache;
    private Byte[] _storage;
    private int _currentIdx;
    private int _decodedKeyIdx;
    private int _currentKeyIdx;
    private int _lastKeyMappingItem;
    public int MaxLength;
    public long Dictionary;
    private static int Invalid;
    public bool IsValid { get; }
    private static CompactKey();
    private Int64& KeyMappingCache(int i);
    private Int64& KeyMappingCacheIndex(int i);
    public void Initialize(LowLevelTransaction tx);
    public void Reset();
    public bool get_IsValid();
    public ReadOnlySpan`1<byte> EncodedWithCurrent(Int32& lengthInBits);
    public ReadOnlySpan`1<byte> EncodedWith(long dictionaryId, Int32& lengthInBits);
    [SkipLocalsInitAttribute]
private void DecodeFromEncodedForm();
    public ReadOnlySpan`1<byte> Decoded();
    private void UnlikelyGrowStorage(int maxSize);
    public void Set(ReadOnlySpan`1<byte> key);
    public void Set(int keyLengthInBits, ReadOnlySpan`1<byte> key, long dictionaryId);
    public void Set(int keyLengthInBits, Byte* keyPtr, long dictionaryId);
    public void Set(int keyLengthInBits, Byte& keyRef, long dictionaryId);
    private int SelectBucketForRead(long dictionaryId);
    private int SelectBucketForWrite();
    public void ChangeDictionary(long dictionaryId);
    public int CompareEncodedWithCurrent(Byte* nextEntryPtr, int nextEntryLengthInBits);
    public int CompareEncodedWithCurrent(Byte& nextEntryRef, int nextEntryLengthInBits);
    public int CompareEncodedWith(Byte& nextEntryRef, int nextEntryLengthInBits, long dictionaryId);
    public sealed virtual void Dispose();
    public int Compare(CompactKey value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
[SkipLocalsInitAttribute]
private int <EncodedWith>g__EncodeFromDecodedForm|22_0(<>c__DisplayClass22_0& );
}
public class Voron.Data.CompactTrees.CompactKeyCacheScope : ValueType {
    private LowLevelTransaction _llt;
    private CompactKey _key;
    public CompactKey Key { get; }
    public CompactKeyCacheScope(LowLevelTransaction tx);
    public CompactKeyCacheScope(LowLevelTransaction tx, ReadOnlySpan`1<byte> key, long dictionaryId);
    public CompactKey get_Key();
    public sealed virtual void Dispose();
}
public class Voron.Data.CompactTrees.CompactTree : object {
    internal Lookup`1<CompactKeyLookup> _inner;
    public Slice Name { get; }
    public long DictionaryId { get; }
    public long NumberOfEntries { get; }
    public long RootPage { get; }
    public long BranchPages { get; }
    public long LeafPages { get; }
    public CompactTree(Lookup`1<CompactKeyLookup> inner);
    public Slice get_Name();
    public long get_DictionaryId();
    public long get_NumberOfEntries();
    public long get_RootPage();
    public long get_BranchPages();
    public long get_LeafPages();
    public void Add(string key, long value);
    public void Add(ReadOnlySpan`1<byte> key, long value);
    public long AddAfterTryGetNext(CompactKeyLookup& lookup, long value);
    public void SetAfterTryGetNext(CompactKeyLookup& lookup, long value);
    public long Add(CompactKey key, long value);
    public sealed virtual void PrepareForCommit();
    private void AssertValueAndKeySize(CompactKey key, long value);
    public static CompactTree InternalCreate(Tree parent, Slice name);
    public static bool HasDictionary(LowLevelTransaction llt);
    public static long GetDictionaryId(LowLevelTransaction llt);
    public bool TryGetValue(string key, Int64& value);
    public bool TryGetValue(ReadOnlySpan`1<byte> key, Int64& value);
    public bool TryGetValue(CompactKey key, Int64& value);
    public bool TryGetTermContainerId(CompactKey key, Int64& value);
    public bool TryGetValue(CompactKey key, Int64& termContainerId, Int64& value);
    public bool TryRemove(string key, Int64& oldValue);
    public bool TryRemove(Slice key, Int64& oldValue);
    public bool TryRemove(ReadOnlySpan`1<byte> key, Int64& oldValue);
    public bool TryRemove(CompactKeyLookup key, Int64& oldValue);
    public bool TryRemoveExistingValue(CompactKeyLookup& key, Int64& oldValue);
    public void InitializeStateForTryGetNextValue();
    public bool TryGetNextValue(CompactKey key, Int64& termContainerId, Int64& value, CompactKeyLookup& lookup);
    public void BulkUpdateSet(CompactKeyLookup& key, long value, long pageNum, int offset, Int32& adjustment);
    public TreeStructureChanged<CompactKeyLookup> CheckTreeStructureChanges();
    public bool BulkUpdateRemove(CompactKeyLookup& key, long pageNum, int offset, Int32& adjustment, Int64& oldValue);
    public int BulkUpdateStart(Span`1<CompactKeyLookup> keys, Span`1<long> values, Span`1<int> offsets, Int64& pageNum);
    public List`1<long> AllPages();
    public List`1<ValueTuple`2<string, long>> AllEntriesIn(long p);
    public void VerifyStructure();
    public void VerifyOrderOfElements();
    public void Render();
    private static int DictionaryOrder(ReadOnlySpan`1<byte> s1, ReadOnlySpan`1<byte> s2);
    private ValueTuple`2<int, int> FuzzySearchInCurrentPage(CompactKey& key, PageRef<CompactKeyLookup> pageRef);
    private void FuzzySearchPageAndPushNext(CompactKey key, PageRef<CompactKeyLookup> pageRef);
    private void FuzzyFindPageFor(ReadOnlySpan`1<byte> key);
    public FuzzyIterator FuzzyIterate(Slice fuzzyKey, float distance);
    public Iterator`1<ForwardIterator<CompactKeyLookup>> Iterate();
    public Iterator`1<TDirection> Iterate();
    public TDirection IterateValues();
    [CompilerGeneratedAttribute]
private ValueTuple`2<string, long> <AllEntriesIn>b__42_0(ValueTuple`2<CompactKeyLookup, long> x);
}
public class Voron.Data.CompactTrees.PersistentDictionary : object {
    public static int MaxDictionaryEntriesForTraining;
    public static string DictionaryKey;
    public long DictionaryId;
    private HopeEncoder`1<Encoder3Gram`1<AdaptiveMemoryEncoderState>> _encoder;
    public static int MinSamplesToTrain;
    public static int MaxDictionaryEntries;
    private static int DefaultDictionaryTableSize;
    private static int DefaultAllocationSizeForTable;
    public PersistentDictionary(Page page);
    public static long CreateDefault(LowLevelTransaction llt);
    public static bool TryCreate(LowLevelTransaction llt, TKeys1 trainEnumerator, PersistentDictionary& dictionary);
    public static void VerifyTable(Page page);
    public void Decode(int keyLengthInBits, ReadOnlySpan`1<byte> key, Span`1& decodedKey);
    public void Encode(ReadOnlySpan`1<byte> key, Span`1& encodedKey, Int32& encodedKeyLengthInBits);
    public int GetMaxEncodingBytes(int keyLength);
    public int GetMaxDecodingBytes(int keyLength);
}
public class Voron.Data.CompactTrees.PersistentDictionaryHeader : ValueType {
    public static int SizeOf;
    public ulong TableHash;
    public int TableSize;
    public long CurrentId;
    public long Reserved;
    public virtual string ToString();
}
public class Voron.Data.CompactTrees.PersistentDictionaryLocator : object {
    private Object[] _cache;
    private int _andMask;
    public PersistentDictionaryLocator(int cacheSize);
    public bool TryGet(long dictionaryId, PersistentDictionary& dictionary);
    public void Set(long pageNumber, PersistentDictionary dictionary);
}
public class Voron.Data.CompactTrees.PersistentDictionaryRootHeader : ValueType {
    public RootObjectType RootObjectType;
    public long PageNumber;
}
public class Voron.Data.Compression.CompressedNodesHeader : ValueType {
    public static int SizeOf;
    public ushort SectionSize;
    public ushort CompressedSize;
    public ushort UncompressedSize;
    public ushort NumberOfCompressedEntries;
}
public class Voron.Data.Compression.CompressionResult : object {
    public TreePage CompressedPage;
    public Byte* CompressionOutputPtr;
    public CompressedNodesHeader Header;
    public bool InvalidateFromCache;
}
public class Voron.Data.Compression.DecompressedLeafPage : TreePage {
    private bool _disposed;
    public TreePage Original;
    private IDisposable _disposable;
    public bool Cached;
    public DecompressionUsage Usage;
    public DecompressedLeafPage(Byte* basePtr, int pageSize, DecompressionUsage usage, TreePage original, IDisposable disposable);
    public sealed virtual void Dispose();
    public void CopyToOriginal(LowLevelTransaction tx, bool defragRequired, bool wasModified, Tree tree);
    private void SplitPage(LowLevelTransaction tx, Tree tree);
    [DoesNotReturnAttribute]
private static void ThrowCouldNotCompressEmptyDecompressedPage(long pageNumber);
}
public class Voron.Data.Compression.DecompressedPagesCache : object {
    public static int Size;
    private DecompressedLeafPage[] _cache;
    private int _current;
    public bool TryGet(long pageNumber, DecompressionUsage usage, DecompressedLeafPage& decompressed);
    public void Add(DecompressedLeafPage decompressed);
    public void Invalidate(long pageNumber, DecompressionUsage usage);
    public sealed virtual void Dispose();
    public bool TryFindPageForReading(Slice key, LowLevelTransaction tx, DecompressedLeafPage& result);
}
public class Voron.Data.Compression.DecompressedReadResult : ReadResult {
    private DecompressedLeafPage _page;
    public DecompressedReadResult(ValueReader reader, DecompressedLeafPage page);
    public sealed virtual void Dispose();
}
public class Voron.Data.Compression.DecompressionBuffersPool : object {
    private object _expandPoolLock;
    private object _decompressionPagerLock;
    private StorageEnvironmentOptions _options;
    private ConcurrentQueue`1[] _pool;
    private long _decompressionPagerCounter;
    private long _lastUsedPage;
    private PagerInfo _compressionPager;
    private bool _initialized;
    private long _currentlyUsedBytes;
    private ImmutableAppendOnlyList`1<PagerInfo> _oldPagers;
    private long _maxNumberOfPagesInScratchBufferPool;
    private ScratchSpaceUsageMonitor _scratchSpaceMonitor;
    private DisposeOnce`1<SingleAttempt> _disposeOnceRunner;
    internal int NumberOfScratchFiles { get; }
    public DecompressionBuffersPool(StorageEnvironmentOptions options);
    internal int get_NumberOfScratchFiles();
    private AbstractPager CreateDecompressionPager(long initialSize);
    public DecompressedLeafPage GetPage(LowLevelTransaction tx, int pageSize, DecompressionUsage usage, TreePage original);
    public IDisposable GetTemporaryPage(LowLevelTransaction tx, int pageSize, Byte*& tmp);
    [DoesNotReturnAttribute]
private static void ThrowPageSizeTooBig(int pageSize);
    [DoesNotReturnAttribute]
private void ThrowInvalidPageSize(int pageSize);
    private void EnsureInitialized();
    private int GetTempPagesPoolIndex(int pageSize);
    public sealed virtual void Dispose();
    public int Cleanup();
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_0();
    [CompilerGeneratedAttribute]
private void <GetTemporaryPage>g__CreateNewBuffersPager|17_0(long size);
}
public enum Voron.Data.Compression.DecompressionUsage : Enum {
    public int value__;
    public static DecompressionUsage Read;
    public static DecompressionUsage Write;
}
public class Voron.Data.Compression.LeafPageCompressor : object {
    public static IDisposable TryGetCompressedTempPage(LowLevelTransaction tx, TreePage page, CompressionResult& result, bool defrag);
    public static void CopyToPage(CompressionResult compressed, TreePage dest);
    [DoesNotReturnAttribute]
private static void ThrowNullCompressionOutputButNonEmptyPage(TreePage page);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
public class Voron.Data.Containers.Container : ValueType {
    private static Slice AllPagesTreeName;
    private static Slice FreePagesTreeName;
    private static int MinimumAdditionalFreeSpaceToConsider;
    private static int NumberOfReservedEntries;
    private Page _page;
    public static int MaxSizeInsideContainerPage;
    public ContainerPageHeader& Header { get; }
    private static Container();
    public Container(Page page);
    public ContainerPageHeader& get_Header();
    private ItemMetadata& MetadataFor(int pos);
    private ItemMetadata& MetadataFor();
    public string Dump();
    private bool HasEntries();
    public int SpaceUsed();
    public static long Create(LowLevelTransaction llt);
    private static Page AllocateContainerPage(LowLevelTransaction llt);
    private void Defrag(LowLevelTransaction llt);
    public static long Allocate(LowLevelTransaction llt, long containerId, int size, Span`1& allocatedSpace);
    public static long Allocate(LowLevelTransaction llt, long containerId, int size, long pageLevelMetadata, Span`1& allocatedSpace);
    private long Allocate(int size, int pos, Span`1& allocatedSpace);
    private static long IndexToOffset(int pos);
    private static int OffsetToIndex(long offset);
    private static Container MoveToNextPage(LowLevelTransaction llt, long containerId, long pageLevelMetadata, Container container, int size);
    private static bool SearchForFreeListPage(LowLevelTransaction llt, Container rootContainer, TransactionState txState, long pageLevelMetadata, int size, Container& maybe);
    private static bool PageMetadataMatch(Container maybe, long pageLevelMetadata);
    public static List`1<long> GetAllIds(LowLevelTransaction llt, long containerId);
    public static int GetEntriesInto(long containerId, Int32& offset, Page page, Span`1<long> ids, Int32& itemsLeftOnCurrentPage);
    private Span`1<byte> GetItem(int pos);
    public static void AddToFreeList(LowLevelTransaction llt, Container& rootContainer, long pageNum, long pageLevelMetadata);
    public static void RemoveFromFreeList(LowLevelTransaction llt, Container& rootContainer, long pageNum);
    public static void AddToAllPagesList(LowLevelTransaction llt, Container& rootContainer, long pageNum);
    public static void RemoveFromAllPagesList(LowLevelTransaction llt, Container& rootContainer, long pageNum, long pageLevelMetadata);
    private bool HasEnoughSpaceFor(int reqSize);
    private ValueTuple`2<int, int> GetRequiredSizeAndPosition(int size);
    private static int ComputeRequiredSize(int size);
    public static void Delete(LowLevelTransaction llt, long containerId, long id);
    private long GetNextFreePage();
    private void UpdateNextFreePage(long nextFreePage);
    private void UpdateNumberOfEntries(int change);
    public long GetNumberOfEntries();
    public static Span`1<byte> GetMutable(LowLevelTransaction llt, long id);
    public static void Get(LowLevelTransaction llt, long id, Item& item);
    public static Span`1<byte> GetReadOnly(LowLevelTransaction llt, long id);
    public static Item Get(LowLevelTransaction llt, long id);
    public static Item MaybeGetFromSamePage(LowLevelTransaction llt, Page& page, long id);
    [ConditionalAttribute("DEBUG")]
private void ValidatePage();
    public static void GetAll(LowLevelTransaction llt, Span`1<long> ids, UnmanagedSpan* spans, long missingValue, PageLocator pageCache);
    public static ValueTuple`2<Lookup`1<Int64LookupKey>, Lookup`1<Int64LookupKey>> GetPagesFor(LowLevelTransaction tx, long containerId);
    public static ForwardIterator<Int64LookupKey> GetAllPagesIterator(LowLevelTransaction tx, long containerId);
    [CompilerGeneratedAttribute]
internal static long <Allocate>g__AllocateOverflowPageUnlikely|21_0(Container rootContainer, Span`1& allocatedSpace, <>c__DisplayClass21_0& );
}
public class Voron.Data.Containers.ContainerPageHeader : ValueType {
    public long PageNumber;
    public ushort NumberOfOffsets;
    public ushort FloorOfData;
    public PageFlags Flags;
    public ExtendedPageType ContainerFlags;
    [FixedBufferAttribute("System.Byte", "2")]
private <Reserved>e__FixedBuffer Reserved;
    public long PageLevelMetadata;
    public int NumberOfOverflowPages;
    public static int FreeListOffset;
    public static int AllPagesOffset;
    public static int NumberOfEntriesOffset;
    public static int NextFreePageOffset;
    public int CeilingOfOffsets { get; }
    public int get_CeilingOfOffsets();
}
public class Voron.Data.Containers.ContainerRootHeader : ValueType {
    public RootObjectType RootObjectType;
    public long ContainerId;
}
public class Voron.Data.Containers.ContainerState : ValueType {
    public RootObjectType RootObjectType;
    public long RootPage;
    public long NumberOfPages;
    public long NumberOfOverfowPages;
    public long NumberOfEntries;
    public long FreeListPage;
    public long AllPagesListPage;
}
public class Voron.Data.EmptyIterator : object {
    [CompilerGeneratedAttribute]
private Action`1<IIterator> OnDisposal;
    [CompilerGeneratedAttribute]
private Slice <MaxKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Slice <RequiredPrefix>k__BackingField;
    public bool DoRequireValidation { get; }
    public Slice CurrentKey { get; }
    public TreeNodeHeader* Current { get; }
    public Slice MaxKey { get; public set; }
    public Slice RequiredPrefix { get; }
    public sealed virtual bool Seek(Slice key);
    public sealed virtual bool get_DoRequireValidation();
    public sealed virtual Slice get_CurrentKey();
    public sealed virtual int GetCurrentDataSize();
    public sealed virtual bool Skip(long count);
    public sealed virtual ValueReader CreateReaderForCurrent();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnDisposal(Action`1<IIterator> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnDisposal(Action`1<IIterator> value);
    [IteratorStateMachineAttribute("Voron.Data.EmptyIterator/<DumpValues>d__11")]
public IEnumerable`1<string> DumpValues();
    public TreeNodeHeader* get_Current();
    [CompilerGeneratedAttribute]
public sealed virtual Slice get_MaxKey();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MaxKey(Slice value);
    [CompilerGeneratedAttribute]
public sealed virtual Slice get_RequiredPrefix();
    public sealed virtual void SetRequiredPrefix(Slice prefix);
    public sealed virtual bool MoveNext();
    public sealed virtual bool MovePrev();
    public sealed virtual void Dispose();
}
public class Voron.Data.Fixed.FixedSizeTree : FixedSizeTree`1<long> {
    public FixedSizeTree(LowLevelTransaction tx, Tree parent, Slice treeName, ushort valSize, bool clone, bool isIndexTree, NewPageAllocator newPageAllocator);
}
public class Voron.Data.Fixed.FixedSizeTree`1 : object {
    internal static int BranchEntrySize;
    private LowLevelTransaction _tx;
    private Tree _parent;
    private Slice _treeName;
    private ushort _valSize;
    private bool _isIndexTree;
    private int _entrySize;
    private int _maxEmbeddedEntries;
    private NewPageAllocator _newPageAllocator;
    private FastStack`1<FixedSizeTreePage`1<TVal>> _cursor;
    private int _changes;
    private int _lastMatch;
    private int _directAddUsage;
    [CompilerGeneratedAttribute]
private bool <FreeSpaceTree>k__BackingField;
    public LowLevelTransaction Llt { get; }
    internal Nullable`1<RootObjectType> Type { get; }
    public bool HasNewPageAllocator { get; }
    public Slice Name { get; }
    public long NumberOfEntries { get; }
    public long PageCount { get; }
    public bool FreeSpaceTree { get; public set; }
    public Tree Parent { get; }
    public ushort ValueSize { get; }
    public int Depth { get; }
    private static FixedSizeTree`1();
    public FixedSizeTree`1(LowLevelTransaction tx, Tree parent, Slice treeName, ushort valSize, bool clone, bool isIndexTree, NewPageAllocator newPageAllocator);
    public LowLevelTransaction get_Llt();
    internal Nullable`1<RootObjectType> get_Type();
    public bool get_HasNewPageAllocator();
    public static ushort GetValueSize(LowLevelTransaction tx, Tree parent, Slice treeName);
    public void RepurposeInstance(Slice treeName, bool clone);
    [DoesNotReturnAttribute]
private void ThrowInvalidFixedSizeTreeSize(Embedded* header);
    [DoesNotReturnAttribute]
private static void ThrowInvalidFixedSizeTree(Slice treeName, Embedded* header);
    [DoesNotReturnAttribute]
private static void ThrowInvalidFixedTreeValueSize();
    public Int64[] Debug(FixedSizeTreePage`1<TVal> p);
    public static Int64[] Debug(FixedSizeTreePage`1<TVal> p, int entrySize);
    public Slice get_Name();
    public static Int64[] Debug(Byte* p, int entries, int size);
    public bool Add(TVal key);
    public bool Add(TVal key, Slice val);
    public bool Add(TVal key, Byte[] val);
    public bool Add(TVal key, long val);
    public DirectAddScope<TVal> DirectAdd(TVal key, Boolean& isNew, Byte*& ptr);
    [DoesNotReturnAttribute]
private void ThrowInvalidFixedSizeTreeType();
    private Byte* AddLargeEntry(TVal key, Boolean& isNew);
    [ConditionalAttribute("VALIDATE")]
private void ValidateTree();
    public void ValidateTree_Forced();
    internal FixedSizeTreePage`1<TVal> GetReadOnlyPage(long pageNumber);
    private FixedSizeTreePage`1<TVal> FindPageFor(TVal key);
    private FixedSizeTreePage`1<TVal> NewPage(FixedSizeTreePageFlags flags, long nearbyPage);
    private void FreePage(long pageNumber, bool modifyPageCount);
    private FixedSizeTreePage`1<TVal> ModifyPage(FixedSizeTreePage`1<TVal> page);
    private FixedSizeTreePage`1<TVal> PageSplit(FixedSizeTreePage`1<TVal> page, TVal key);
    private void AddLeafKey(FixedSizeTreePage`1<TVal> page, int position, TVal key);
    private void AddSeparatorToParentPage(FixedSizeTreePage`1<TVal> parentPage, int position, TVal key, long pageNum);
    private Byte* AddEmbeddedEntry(TVal key, Boolean& isNew);
    private ushort CopyEmbeddedContentToTempPage(TVal key, Byte* tmpPtr, Boolean& isNew, Int32& newSize, Int32& srcCopyStart);
    private Byte* AddNewEntry(TVal key);
    private void BinarySearch(FixedSizeTreePage`1<TVal> page, TVal val);
    private int BinarySearch(Byte* p, int len, TVal val, int size);
    public List`1<long> AllPages();
    public bool Contains(TVal key);
    public DeletionResult<TVal> Delete(TVal key);
    public DeletionResult<TVal> DeleteRange(TVal start, TVal end);
    private long DeleteRangeEmbedded(TVal start, TVal end);
    private long DeleteRangeLarge(TVal start, TVal end);
    private FixedSizeTreePage`1<TVal> GetNextLeafPage();
    private int RemoveRangeFromPage(FixedSizeTreePage`1<TVal> page, TVal rangeEnd);
    private bool RemoveEntirePage(FixedSizeTreePage`1<TVal> page);
    private DeletionResult<TVal> RemoveLargeEntry(TVal key);
    private FixedSizeTreePage`1<TVal> RebalancePage(FixedSizeTreePage`1<TVal> page);
    private FixedSizeTreePage`1<TVal> RebalanceRootPage(FixedSizeTreePage`1<TVal> page);
    private DeletionResult<TVal> RemoveEmbeddedEntry(TVal key);
    public Byte* ReadPtr(TVal key, Int32& size);
    public ExternalScope<ByteStringMemoryCache> Read(TVal key, Slice& slice);
    public IFixedSizeIterator<TVal> Iterate(bool prefetch);
    public long get_NumberOfEntries();
    public long get_PageCount();
    [CompilerGeneratedAttribute]
public bool get_FreeSpaceTree();
    [CompilerGeneratedAttribute]
public void set_FreeSpaceTree(bool value);
    public Tree get_Parent();
    public ushort get_ValueSize();
    public int get_Depth();
    [ConditionalAttribute("DEBUG")]
public void DebugRenderAndShow();
    private DirectAddScope ModifyLargeHeader(Large*& largeHeader);
    public virtual string ToString();
    public long GetNumberOfEntriesAfter(TVal value, Int64& totalCount, Stopwatch overallDuration);
    private long GetRemainingNumberOfEntriesFor(FixedSizeTreePage`1<TVal> page, int depth, int maxDepth, RemainingNumberOfEntriesState& state);
    private long EstimateRemainingEntriesFor(FixedSizeTreePage`1<TVal> page, int depth, int maxDepth, RemainingNumberOfEntriesState& state);
    internal void SetNewPageAllocator(NewPageAllocator newPageAllocator);
}
public class Voron.Data.Fixed.FixedSizeTreeEntry : ValueType {
    private long _key;
    public Byte* Value;
    public long PageNumber;
    public TVal GetKey();
    public void SetKey(TVal value);
}
public class Voron.Data.Fixed.FixedSizeTreeHeader : object {
}
public class Voron.Data.Fixed.FixedSizeTreePage`1 : object {
    private Byte* _ptr;
    private int _entrySize;
    private int _pageSize;
    public int LastMatch;
    public int LastSearchPosition;
    public bool Dirty;
    private FixedSizeTreePageHeader* Header { get; }
    public long PageNumber { get; public set; }
    public FixedSizeTreePageFlags FixedTreeFlags { get; public set; }
    public int PageSize { get; }
    public bool IsLeaf { get; }
    public bool IsBranch { get; }
    public int PageMaxSpace { get; }
    public ushort NumberOfEntries { get; public set; }
    public ushort StartPosition { get; public set; }
    public ushort ValueSize { get; public set; }
    public Byte* Pointer { get; }
    public PageFlags Flags { get; public set; }
    public FixedSizeTreePage`1(Byte* b, int entrySize, int pageSize);
    private FixedSizeTreePageHeader* get_Header();
    public long get_PageNumber();
    public void set_PageNumber(long value);
    public FixedSizeTreePageFlags get_FixedTreeFlags();
    public void set_FixedTreeFlags(FixedSizeTreePageFlags value);
    public int get_PageSize();
    public bool get_IsLeaf();
    public bool get_IsBranch();
    public int get_PageMaxSpace();
    public ushort get_NumberOfEntries();
    public void set_NumberOfEntries(ushort value);
    public ushort get_StartPosition();
    public void set_StartPosition(ushort value);
    public ushort get_ValueSize();
    public void set_ValueSize(ushort value);
    public Byte* get_Pointer();
    public virtual string ToString();
    public PageFlags get_Flags();
    public void set_Flags(PageFlags value);
    public void SetKey(TVal key, int position);
    public TVal GetKey(int position);
    internal FixedSizeTreeEntry* GetEntry(int position);
    public static FixedSizeTreeEntry* GetEntry(Byte* p, int position, int size);
    public void ResetStartPosition();
    public void RemoveEntry(int pos);
}
[FlagsAttribute]
public enum Voron.Data.Fixed.FixedSizeTreePageFlags : Enum {
    public byte value__;
    public static FixedSizeTreePageFlags None;
    public static FixedSizeTreePageFlags Branch;
    public static FixedSizeTreePageFlags Leaf;
    public static FixedSizeTreePageFlags Value;
}
public class Voron.Data.Fixed.FixedSizeTreePageHeader : ValueType {
    public static int SizeOf;
    public long PageNumber;
    public ushort StartPosition;
    public ushort NumberOfEntries;
    public PageFlags Flags;
    public FixedSizeTreePageFlags TreeFlags;
    public ushort ValueSize;
}
public interface Voron.Data.IIterator {
    public bool DoRequireValidation { get; }
    public Slice CurrentKey { get; }
    public Slice RequiredPrefix { get; }
    public Slice MaxKey { get; public set; }
    public abstract virtual bool get_DoRequireValidation();
    public abstract virtual Slice get_CurrentKey();
    public abstract virtual Slice get_RequiredPrefix();
    public abstract virtual Slice get_MaxKey();
    public abstract virtual void set_MaxKey(Slice value);
    public abstract virtual bool Seek(Slice key);
    public abstract virtual bool MoveNext();
    public abstract virtual bool MovePrev();
    public abstract virtual bool Skip(long count);
    public abstract virtual void SetRequiredPrefix(Slice prefix);
    public abstract virtual ValueReader CreateReaderForCurrent();
    public abstract virtual int GetCurrentDataSize();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnDisposal(Action`1<IIterator> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnDisposal(Action`1<IIterator> value);
}
public class Voron.Data.Lookups.DoubleLookupKey : ValueType {
    public double Value;
    public static long MinValue { get; }
    public DoubleLookupKey(double value);
    public sealed virtual void Reset();
    public sealed virtual long ToLong();
    public static DoubleLookupKey op_Implicit(double d);
    public virtual string ToString();
    public static override T FromLong(long l);
    public static override long get_MinValue();
    public sealed virtual void Init(Lookup`1<T> parent);
    public sealed virtual int CompareTo(Lookup`1<T> parent, long l);
    public sealed virtual bool IsEqual(T k);
    public sealed virtual void OnNewKeyAddition(Lookup`1<T> parent);
    public sealed virtual void OnKeyRemoval(Lookup`1<T> parent);
    public sealed virtual string ToString(Lookup`1<T> parent);
    public sealed virtual int CompareTo(T l);
}
public interface Voron.Data.Lookups.ILookupIterator {
    public bool IsForward { get; }
    public virtual bool get_IsForward();
    public abstract virtual void Init(T parent);
    public abstract virtual void Reset();
    public abstract virtual int Fill(Span`1<long> results, long lastId, bool includeMax);
    public abstract virtual bool Skip(long count);
    public abstract virtual bool MoveNext(Int64& value);
    public abstract virtual bool MoveNext(TLookupKey& key, Int64& value, Boolean& hasPreviousValue);
    public abstract virtual void Seek(TLookupKey key);
}
public interface Voron.Data.Lookups.ILookupKey {
    public static long MinValue { get; }
    public abstract virtual void Reset();
    public abstract virtual long ToLong();
    public static abstract virtual T FromLong(long l);
    public static abstract virtual long get_MinValue();
    public abstract virtual void Init(Lookup`1<T> parent);
    public abstract virtual int CompareTo(Lookup`1<T> parent, long l);
    public abstract virtual int CompareTo(T l);
    public abstract virtual bool IsEqual(T k);
    public abstract virtual void OnNewKeyAddition(Lookup`1<T> parent);
    public abstract virtual void OnKeyRemoval(Lookup`1<T> parent);
    public abstract virtual string ToString(Lookup`1<T> parent);
}
public class Voron.Data.Lookups.Int64LookupKey : ValueType {
    public long Value;
    public static long MinValue { get; }
    public Int64LookupKey(long value);
    public sealed virtual void Reset();
    public sealed virtual long ToLong();
    public static Int64LookupKey op_Implicit(long v);
    public static override T FromLong(long l);
    public static override long get_MinValue();
    public sealed virtual void Init(Lookup`1<T> parent);
    public sealed virtual int CompareTo(Lookup`1<T> parent, long l);
    public sealed virtual int CompareTo(T l);
    public sealed virtual bool IsEqual(T k);
    public sealed virtual void OnNewKeyAddition(Lookup`1<T> parent);
    public sealed virtual void OnKeyRemoval(Lookup`1<T> parent);
    public sealed virtual string ToString(Lookup`1<T> parent);
    public virtual string ToString();
}
public class Voron.Data.Lookups.Lookup`1 : object {
    private static int EncodingBufferSize;
    private LowLevelTransaction _llt;
    private LookupState _state;
    private int _treeStructureVersion;
    private IteratorCursorState<TLookupKey> _internalCursor;
    [CompilerGeneratedAttribute]
private Slice <Name>k__BackingField;
    private Tree _parent;
    public Slice Name { get; }
    public long NumberOfEntries { get; }
    public LookupState& State { get; }
    public LowLevelTransaction Llt { get; }
    private Lookup`1(Slice name, Tree parent);
    private static int EncodeEntry(LookupPageHeader* header, long keyData, long val, Byte* buffer);
    private static long ZigZag(long diff);
    private static int DecodeEntry(CursorState& state, int pos, Int64& keyData, Int64& val);
    private static int DecodeEntry(LookupPageHeader* header, int pos, Int64& keyData, Int64& val);
    private static int DecodeEntry(LookupPageHeader* header, Byte* buffer, Int64& keyData, Int64& val);
    private static long Unzag(long l, long baseline);
    private static int GetEntryBuffer(CursorState& state, int pos, Byte*& buffer);
    private static int GetEntryBuffer(LookupPageHeader* p, int pos, Byte*& buffer);
    private static int GetEntrySize(CursorState& state, int pos);
    private static int GetEntrySize(Byte* buffer);
    internal static long GetKeyData(CursorState& state, int pos);
    private static long GetKeyData(LookupPageHeader* header, Byte* buffer);
    private static long ReadBackward(Byte* b, int len);
    private static long GetValue(CursorState& state, int pos);
    public static int GetKeyAndValue(CursorState& state, int pos, Int64& key, Int64& value);
    public static Lookup`1<TLookupKey> Open(LowLevelTransaction llt, LookupState state);
    [CompilerGeneratedAttribute]
public Slice get_Name();
    public long get_NumberOfEntries();
    public LookupState& get_State();
    public LowLevelTransaction get_Llt();
    public static Lookup`1<TLookupKey> InternalCreate(Tree parent, Slice name, long dictionaryId, long termsContainerId);
    public static void Create(LowLevelTransaction llt, LookupState& state, long dictionaryId, long termsContainerId);
    public sealed virtual void PrepareForCommit();
    public bool TryGetValue(TLookupKey key, Int64& value);
    public bool TryGetTermContainerId(TLookupKey key, Int64& value);
    public bool TryGetValue(TLookupKey& key, Int64& value);
    public bool TryRemove(TLookupKey key);
    public bool TryRemove(TLookupKey& key);
    public bool TryRemove(TLookupKey key, Int64& value);
    public bool TryRemove(TLookupKey& key, Int64& value);
    public bool TryRemoveExistingValue(TLookupKey& key, Int64& value);
    private void RemoveFromPage(bool allowRecurse, int pos, bool isExplicitRemove);
    private bool RemoveFromPage(TLookupKey& key, bool allowRecurse, bool isExplicitRemove);
    private void RemoveEntryFromPage(CursorState& state, TLookupKey& key, int pos, bool isExplicitRemove, Int64& value);
    [ConditionalAttribute("DEBUG")]
private void VerifySizeOfFullCursor();
    private bool MaybeMergeEntries(CursorState& destinationState);
    [SkipLocalsInitAttribute]
private bool TryMoveAllEntries(LookupPageHeader* destination, LookupPageHeader* source);
    private ValueTuple`2<long, long> GetFirstActualKeyAndValue(LookupPageHeader* src);
    private void RemovePageFromParent(CursorState& destinationState, CursorState& parent);
    private void FreePageFor(CursorState& stateToKeep, CursorState& stateToDelete, CursorState& parent);
    private void DecrementPageNumbers(CursorState& state);
    public void Add(TLookupKey& key, long value);
    public void AddAfterTryGetNext(TLookupKey& key, long value);
    public void SetAfterTryGetNext(TLookupKey& key, long value);
    public void AddOrSetAfterGetNext(TLookupKey& key, long value);
    public void Add(TLookupKey key, long value);
    [SkipLocalsInitAttribute]
private void AddToPage(TLookupKey& key, long value, bool searchForKeyOnSplit);
    private void AddEntryToPage(CursorState& state, int requiredSize, Byte* entryBufferPtr, bool isUpdate);
    private void SplitPage(TLookupKey& currentCauseForSplit, long valueForSplit);
    private TLookupKey SplitPageEncodedEntries(TLookupKey& causeForSplit, Page page, long valueForSplit, CursorState& state);
    private static int FindPositionToSplitPageInHalfBasedOfEntriesSize(CursorState& state, CursorState& newPageState);
    [ConditionalAttribute("DEBUG")]
private static void VerifySizeOf(CursorState& p, bool isRoot);
    private void CreateRootPage(TLookupKey& k, long v);
    private void InsertToStack(CursorState& newPageState);
    private static void DefragPage(LowLevelTransaction llt, CursorState& state);
    public List`1<ValueTuple`2<TLookupKey, long>> AllEntriesIn(long p);
    public List`1<long> AllPages();
    private void FindPageFor(TLookupKey& key, IteratorCursorState& cstate);
    private void FindPageFor(IteratorCursorState& cstate, CursorState& state, TLookupKey& key);
    private void PopPage(IteratorCursorState& cstate);
    private void PushPage(long nextPage, IteratorCursorState& cstate);
    private void SearchInCurrentPage(TLookupKey& key, CursorState& state);
    private void SearchInCurrentPage(TLookupKey& key, CursorState& state, int bot, int length);
    [ConditionalAttribute("DEBUG")]
public void Render(int steps);
    public void GetFor(Span`1<long> keys, Span`1<long> terms, long missingValue);
    public PageRef<TLookupKey> GetPageRef();
    public void InitializeCursorState();
    public int BulkUpdateStart(Span`1<TLookupKey> keys, Span`1<long> values, Span`1<int> offsets, Int64& pageNum);
    public TreeStructureChanged<TLookupKey> CheckTreeStructureChanges();
    public void BulkUpdateSet(TLookupKey& key, long value, long pageNum, int offset, Int32& adjustment);
    public bool BulkUpdateRemove(TLookupKey& key, long pageNum, int offset, Int32& adjustment, Int64& oldValue);
    private Nullable`1<long> CurrentPageLimit();
    public bool TryGetNextValue(TLookupKey& key, Int64& value);
    private bool KeyShouldBeInCurrentPage(TLookupKey& key, CursorState& state);
    public void VerifyStructure();
    private void VerifyStructure(CursorState<TLookupKey> state, TLookupKey& previous);
    public TDirection Iterate();
    public ForwardIterator<TLookupKey> Iterate();
    private bool GoToNextPage(IteratorCursorState& cstate);
    private bool GoToPreviousPage(IteratorCursorState& cstate);
    [CompilerGeneratedAttribute]
internal static bool <TryMoveAllEntries>g__AddBufferToPage|51_0(Byte* buffer, int requiredSize, UInt16& entry, <>c__DisplayClass51_0& );
    [CompilerGeneratedAttribute]
private void <AllPages>g__Add|71_0(long p, <>c__DisplayClass71_0& );
    [CompilerGeneratedAttribute]
private long <GetFor>g__SearchNextPage|79_0(CursorState& state, TLookupKey& key, <>c__DisplayClass79_0& );
    [CompilerGeneratedAttribute]
private ValueTuple`2<int, int> <BulkUpdateStart>g__ExponentialSearchPlacement|83_0(TLookupKey& curKey, CursorState& state, int last);
}
[FlagsAttribute]
public enum Voron.Data.Lookups.LookupPageFlags : Enum {
    public byte value__;
    public static LookupPageFlags None;
    public static LookupPageFlags Branch;
    public static LookupPageFlags Leaf;
}
public class Voron.Data.Lookups.LookupPageHeader : ValueType {
    public static int SizeOf;
    public long PageNumber;
    public ushort Lower;
    public ushort Upper;
    public PageFlags Flags;
    public LookupPageFlags PageFlags;
    public ushort FreeSpace;
    public long KeysBase;
    public long ValuesBase;
    public int NumberOfEntries { get; }
    public bool IsBranch { get; }
    public bool IsLeaf { get; }
    public int get_NumberOfEntries();
    public bool get_IsBranch();
    public bool get_IsLeaf();
}
public class Voron.Data.Lookups.LookupState : ValueType {
    public RootObjectType RootObjectType;
    [FixedBufferAttribute("System.Byte", "7")]
public <Reserved>e__FixedBuffer Reserved;
    public long RootPage;
    public long NumberOfEntries;
    public long BranchPages;
    public long LeafPages;
    public long DictionaryId;
    public long TermsContainerId;
    public long PageCount { get; }
    public long get_PageCount();
    public virtual string ToString();
    public void CopyTo(LookupState* header);
}
public class Voron.Data.PostingLists.PostingList : object {
    public Slice Name;
    private LowLevelTransaction _llt;
    private PostingListState _state;
    private UnmanagedSpan`1<PostingListCursorState> _stk;
    private int _pos;
    private int _len;
    private InternalScope<ByteStringMemoryCache> _scope;
    private ContextBoundNativeList`1<long> _additions;
    private ContextBoundNativeList`1<long> _removals;
    public PostingListState State { get; }
    internal LowLevelTransaction Llt { get; }
    public PostingList(LowLevelTransaction llt, Slice name, PostingListState& state);
    public PostingListState get_State();
    internal LowLevelTransaction get_Llt();
    public static void Create(LowLevelTransaction tx, PostingListState& state);
    public static void Create(LowLevelTransaction tx, PostingListState& state, FastPForEncoder encoder);
    public List`1<long> DumpAllValues();
    public void Add(long value);
    public void Remove(long value);
    [ConditionalAttribute("DEBUG")]
public void Render();
    private void ResizeCursorState();
    private PostingListCursorState* FindSmallestValue();
    [ConditionalAttribute("DEBUG")]
public void Verify();
    [ConditionalAttribute("DEBUG")]
private void VerifyPage(PostingListCursorState s, long min, long maxExclusive);
    private static void ValidateValues(long pageNumber, long min, long maxExclusive, List`1<long> values);
    private void FindPageFor(long value);
    private void PopPage();
    private void PushPage(long nextPage);
    public Iterator Iterate();
    public List`1<long> AllPages();
    public sealed virtual void Dispose();
    public void PrepareForCommit();
    private void UpdateList(Int64* additions, int additionsCount, Int64* removals, int removalsCount, FastPForEncoder encoder, ContextBoundNativeList`1& tempList, FastPForDecoder& decoder);
    private static int GetSiblingIndex(PostingListCursorState& parent);
    private void MergeSiblingsAtParent();
    private void AddNewPageForTheExtras(FastPForEncoder encoder);
    private long NextParentLimit();
    private void AddToParentPage(long separator, long newPage);
    private void SplitBranchPage(long key, long value);
    private void InsertToStack(PostingListCursorState newPageState);
    private PostingListBranchPage CreateRootPage();
    public static long Update(LowLevelTransaction transactionLowLevelTransaction, PostingListState& postingListState, Int64* additions, int additionsCount, Int64* removals, int removalsCount, FastPForEncoder encoder, ContextBoundNativeList`1& tempList, FastPForDecoder& decoder);
    public static void SortEntriesAndRemoveDuplicatesAndRemovals(ContextBoundNativeList`1& list);
    [CompilerGeneratedAttribute]
private void <AllPages>g__AddPage|30_0(Page p, <>c__DisplayClass30_0& );
}
[IsReadOnlyAttribute]
public class Voron.Data.PostingLists.PostingListBranchPage : ValueType {
    private Page _page;
    public static int MinNumberOfValuesBeforeMerge;
    public long First { get; }
    public long Last { get; }
    public PostingListBranchPageHeader* Header { get; }
    private Span`1<ushort> Positions { get; }
    private UInt16* PositionsPtr { get; }
    private int FreeSpace { get; }
    private Span`1<byte> Span { get; }
    public int SpaceUsed { get; }
    public PostingListBranchPage(Page page);
    public long get_First();
    public long get_Last();
    public void Init();
    public PostingListBranchPageHeader* get_Header();
    private Span`1<ushort> get_Positions();
    private UInt16* get_PositionsPtr();
    private int get_FreeSpace();
    private Span`1<byte> get_Span();
    public int get_SpaceUsed();
    private void Defrag(LowLevelTransaction tx);
    public List`1<ValueTuple`2<long, long>> GetDebugOutput();
    public Iterator Iterate();
    public ValueTuple`3<long, int, int> SearchPage(long key);
    public ValueTuple`2<long, long> GetByIndex(int index);
    public long GetPageByIndex(int index);
    public bool TryGetValue(long key, Int64& value);
    public void Remove(long key);
    public bool TryAdd(LowLevelTransaction tx, long key, long page);
    private ValueTuple`2<int, int> SearchInPage(long key);
    public List`1<long> GetAllChildPages();
}
public class Voron.Data.PostingLists.PostingListBranchPageHeader : ValueType {
    public long PageNumber;
    public int Reserved;
    public PageFlags Flags;
    public ExtendedPageType SetFlags;
    public ushort NumberOfEntries;
    public ushort Upper;
}
public class Voron.Data.PostingLists.PostingListCursorState : ValueType {
    public Page Page;
    public int LastMatch;
    public int LastSearchPosition;
    public PostingListLeafPageHeader* LeafHeader { get; }
    public PostingListBranchPageHeader* BranchHeader { get; }
    public bool IsLeaf { get; }
    public PostingListCursorState(Page page);
    public PostingListLeafPageHeader* get_LeafHeader();
    public PostingListBranchPageHeader* get_BranchHeader();
    public bool get_IsLeaf();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class Voron.Data.PostingLists.PostingListLeafPage : ValueType {
    public static int MinimumSizeOfBuffer;
    private Page _page;
    public PostingListLeafPageHeader* Header { get; }
    public int SpaceUsed { get; }
    public PostingListLeafPage(Page page);
    public static int GetNextValidBufferSize(int size);
    public PostingListLeafPageHeader* get_Header();
    public int get_SpaceUsed();
    public static void InitLeaf(PostingListLeafPageHeader* header);
    public void Update(LowLevelTransaction tx, FastPForEncoder encoder, ContextBoundNativeList`1& tempList, Int64*& additions, Int32& additionsCount, Int64*& removals, Int32& removalsCount, long maxValidValue);
    public int AppendToNewPage(LowLevelTransaction llt, FastPForEncoder encoder);
    private int ReadAllEntries(ByteStringContext context, Int64* existing, int capacity);
    public List`1<long> GetDebugOutput();
    public void SetIterator(Iterator& it);
    public static bool TryMerge(LowLevelTransaction llt, ByteStringContext allocator, FastPForDecoder& fastPForDecoder, PostingListLeafPageHeader* dest, PostingListLeafPageHeader* first, PostingListLeafPageHeader* second);
}
public class Voron.Data.PostingLists.PostingListLeafPageHeader : ValueType {
    public long PageNumber;
    public int NumberOfEntries;
    public PageFlags Flags;
    public ExtendedPageType PostingListFlags;
    public ushort SizeUsed;
}
public class Voron.Data.PostingLists.PostingListState : ValueType {
    public RootObjectType RootObjectType;
    [FixedBufferAttribute("System.Byte", "3")]
public <Reserved>e__FixedBuffer Reserved;
    public int Depth;
    public long RootPage;
    public int BranchPages;
    public int LeafPages;
    public long NumberOfEntries;
    public virtual string ToString();
}
public class Voron.Data.RawData.ActiveRawDataSmallSection : RawDataSection {
    [CompilerGeneratedAttribute]
private Transaction <tx>P;
    public ActiveRawDataSmallSection(Transaction tx, long pageNumber);
    public bool TryAllocate(int size, Int64& id);
    public string DebugDump(RawDataSmallPageHeader* pageHeader);
    private RawDataSmallPageHeader* DefragPage(RawDataSmallPageHeader* pageHeader);
    public static ActiveRawDataSmallSection Create(Transaction tx, string owner, byte tableType, Nullable`1<ushort> sizeInPages);
    public static ActiveRawDataSmallSection Create(Transaction transaction, Slice owner, byte tableType, Nullable`1<ushort> sizeInPages);
    private static ushort GetNumberOfPagesInSmallSection(LowLevelTransaction tx);
    public bool IsOwned(long id);
}
public class Voron.Data.RawData.DataMovedDelegate : MulticastDelegate {
    public DataMovedDelegate(object object, IntPtr method);
    public virtual void Invoke(long previousId, long newId, Byte* data, int size, bool compressed);
    public virtual IAsyncResult BeginInvoke(long previousId, long newId, Byte* data, int size, bool compressed, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Voron.Data.RawData.RawDataOverflowPageHeader : ValueType {
    public static int SizeOf;
    public long PageNumber;
    public PageFlags Flags;
    public RawDataPageFlags RawDataFlags;
    public ulong SectionOwnerHash;
    public byte TableType;
    private static RawDataOverflowPageHeader();
}
[FlagsAttribute]
public enum Voron.Data.RawData.RawDataPageFlags : Enum {
    public byte value__;
    public static RawDataPageFlags None;
    public static RawDataPageFlags Header;
    public static RawDataPageFlags Small;
    public static RawDataPageFlags Large;
}
public class Voron.Data.RawData.RawDataSection : object {
    protected static ushort ReservedHeaderSpace;
    protected LowLevelTransaction _llt;
    public static int MaxItemSize;
    protected RawDataSmallSectionPageHeader* _sectionHeader;
    [CompilerGeneratedAttribute]
private long <PageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private DataMovedDelegate DataMoved;
    public long PageNumber { get; }
    public int AllocatedSize { get; }
    public ulong SectionOwnerHash { get; }
    public int Size { get; }
    public int NumberOfPages { get; }
    public UInt16* AvailableSpace { get; }
    public int NumberOfEntries { get; }
    public int OverheadSize { get; }
    public double Density { get; }
    public RawDataSection(LowLevelTransaction tx, long pageNumber);
    [CompilerGeneratedAttribute]
public long get_PageNumber();
    public int get_AllocatedSize();
    public ulong get_SectionOwnerHash();
    public int get_Size();
    public int get_NumberOfPages();
    public UInt16* get_AvailableSpace();
    public List`1<long> GetAllIdsInSectionContaining(long id);
    public List`1<long> GetAllIdsInSection();
    public void FillAllIdsInPage(long pageNumber, List`1<long> ids);
    public int get_NumberOfEntries();
    public int get_OverheadSize();
    public double get_Density();
    public bool Contains(long id);
    public bool TryWrite(long id, Byte* data, int size, bool compressed);
    public bool TryWriteDirect(long id, int size, bool compressed, Byte*& writePos);
    public Byte* DirectRead(long id, Int32& size, Boolean& compressed);
    public static Byte* DirectRead(LowLevelTransaction tx, long id, Int32& size, Boolean& compressed);
    public static RawDataEntrySizes* GetRawDataEntrySizeFor(LowLevelTransaction tx, long id);
    public static long GetSectionPageNumber(LowLevelTransaction tx, long id);
    public void DeleteSection(long sectionPageNumber);
    public RawDataSection Free(long id);
    [CompilerGeneratedAttribute]
public void add_DataMoved(DataMovedDelegate value);
    [CompilerGeneratedAttribute]
public void remove_DataMoved(DataMovedDelegate value);
    public virtual string ToString();
    protected void EnsureHeaderModified();
    protected RawDataSmallPageHeader* ModifyPage(RawDataSmallPageHeader* pageHeader);
    [DoesNotReturnAttribute]
private static void ThrowReadOnlyTransaction(long id);
    [DoesNotReturnAttribute]
protected static void ThrowInvalidPage(long id);
    protected static RawDataSmallPageHeader* PageHeaderFor(LowLevelTransaction tx, long pageNumber);
    protected virtual void OnDataMoved(long previousId, long newid, Byte* data, int size, bool compressed);
    internal void FreeRawDataSectionPages();
}
public class Voron.Data.RawData.RawDataSmallPageHeader : ValueType {
    public static int SizeOf;
    public long PageNumber;
    public ushort NumberOfEntries;
    public ushort NextAllocation;
    public PageFlags Flags;
    public RawDataPageFlags RawDataFlags;
    public ushort PageNumberInSection;
    public ulong SectionOwnerHash;
    public byte TableType;
    private static RawDataSmallPageHeader();
}
public class Voron.Data.RawData.RawDataSmallSectionPageHeader : ValueType {
    public long PageNumber;
    public int NumberOfEntries;
    public PageFlags Flags;
    public RawDataPageFlags RawDataFlags;
    public ushort LastUsedPage;
    public int AllocatedSize;
    public ushort NumberOfPages;
    public ulong SectionOwnerHash;
    public byte TableType;
}
public class Voron.Data.RootHeader : ValueType {
    public RootObjectType RootObjectType;
}
public enum Voron.Data.RootObjectType : Enum {
    public byte value__;
    public static RootObjectType None;
    public static RootObjectType VariableSizeTree;
    public static RootObjectType EmbeddedFixedSizeTree;
    public static RootObjectType FixedSizeTree;
    public static RootObjectType ObsoleteValue;
    public static RootObjectType Table;
    public static RootObjectType Lookup;
    public static RootObjectType Set;
    public static RootObjectType Container;
    public static RootObjectType PersistentDictionary;
}
public class Voron.Data.Tables.CompressionDictionaryInfo : ValueType {
    public byte ExpectedCompressionRatio;
}
public class Voron.Data.Tables.NewPageAllocator : object {
    private LowLevelTransaction _llt;
    private Tree _parentTree;
    internal static Slice AllocationStorage;
    internal static Slice AllocationStorageSize;
    private int _numberOfPagesToAllocate;
    private static byte BitmapSize;
    internal static int NumberOfPagesInSection;
    public static string AllocationStorageName;
    public static string AllocationStorageSizeName;
    private static NewPageAllocator();
    public NewPageAllocator(LowLevelTransaction llt, Tree parentTree);
    public void Create();
    private Page AllocateMoreSpace(FixedSizeTree fst);
    private int ComputeNumberOfPagesToAllocate();
    [DoesNotReturnAttribute]
private static void ThrowInvalidExistingBuffer();
    public Page AllocateSinglePage(long nearbyPage);
    private static bool TryMoveNextCyclic(IFixedSizeIterator<long> it, long startPage);
    private void SetValue(FixedSizeTree fst, long pageNumber, int positionInBitmap);
    private void UnsetValue(FixedSizeTree fst, long pageNumber, int positionInBitmap);
    [DoesNotReturnAttribute]
private static void ThrowInvalidNewBuffer();
    public void FreePage(long pageNumber);
    public Report GetNumberOfPreAllocatedFreePages();
    public List`1<long> AllPages();
    internal FixedSizeTree GetAllocationStorageFst();
    [DoesNotReturnAttribute]
private static void ThrowInvalidPageReleased(long pageNumber);
    [DoesNotReturnAttribute]
private static void ThrowInvalidEmptySectionState(long pageNumber);
    public static void MaybePrefetchSections(Tree parentTree, LowLevelTransaction llt);
}
[AttributeUsageAttribute("64")]
public class Voron.Data.Tables.StorageIndexEntryKeyGeneratorAttribute : Attribute {
}
public class Voron.Data.Tables.Table : object {
    private bool _forGlobalReadsOnly;
    private TableSchema _schema;
    internal Transaction _tx;
    private EventHandler`1<InvalidOperationException> _onCorruptedDataHandler;
    private Tree _tableTree;
    private ActiveRawDataSmallSection _activeDataSmallSection;
    private FixedSizeTree _inactiveSections;
    private FixedSizeTree _activeCandidateSection;
    private Dictionary`2<Slice, Tree> _treesBySliceCache;
    private Dictionary`2<Slice, Dictionary`2<Slice, FixedSizeTree>> _fixedSizeTreeCache;
    public Slice Name;
    private byte _tableType;
    private Nullable`1<int> _currentCompressionDictionaryId;
    private TableSchemaStatsReference _stats;
    private NewPageAllocator _tablePageAllocator;
    private NewPageAllocator _globalPageAllocator;
    private TestingStuff _forTestingPurposes;
    public long NumberOfEntries { get; }
    public NewPageAllocator TablePageAllocator { get; }
    private NewPageAllocator GlobalPageAllocator { get; }
    public FixedSizeTree InactiveSections { get; }
    public FixedSizeTree ActiveCandidateSection { get; }
    internal int CurrentCompressionDictionaryId { get; internal set; }
    public ActiveRawDataSmallSection ActiveDataSmallSection { get; }
    private static ReadOnlySpan`1<byte> LookupTable { get; }
    public Table(TableSchema schema, Slice name, Transaction tx, Tree tableTree, TableSchemaStatsReference stats, byte tableType, bool doSchemaValidation);
    public Table(TableSchema schema, Transaction tx, EventHandler`1<InvalidOperationException> onCorruptedDataHandler);
    public long get_NumberOfEntries();
    public NewPageAllocator get_TablePageAllocator();
    private NewPageAllocator get_GlobalPageAllocator();
    public FixedSizeTree get_InactiveSections();
    public FixedSizeTree get_ActiveCandidateSection();
    internal int get_CurrentCompressionDictionaryId();
    internal void set_CurrentCompressionDictionaryId(int value);
    public ActiveRawDataSmallSection get_ActiveDataSmallSection();
    private void OnDataMoved(long previousId, long newId, Byte* data, int size, bool compressed);
    public bool ReadByKey(Slice key, TableValueReader& reader);
    public bool Read(ByteStringContext context, FixedSizeKeyIndexDef index, long value, TableValueReader& reader);
    public bool VerifyKeyExists(Slice key);
    private bool TryFindIdFromPrimaryKey(Slice key, Int64& id);
    private Byte* DirectReadRaw(long id, Int32& size, Boolean& compressed);
    public void DirectRead(long id, TableValueReader& tvr);
    public Byte* DirectRead(long id, Int32& size);
    private Byte* DirectReadDecompress(long id, Byte* directRead, Int32& size);
    public int GetSize(long id);
    private static ReadOnlySpan`1<byte> get_LookupTable();
    private static int GetDecompressedSize(Span`1<byte> buffer);
    internal static InternalScope<ByteStringMemoryCache> DecompressValue(Transaction tx, Byte* ptr, int size, ByteString& buffer);
    public ValueTuple`2<int, bool> GetInfoFor(long id);
    public long Update(long id, TableValueBuilder builder, bool forceUpdate);
    [ConditionalAttribute("DEBUG")]
private void AssertNoReferenceToThisPage(TableValueBuilder builder, long id);
    [ConditionalAttribute("DEBUG")]
private void AssertNoReferenceToOldData(TableValueBuilder builder, Byte* oldData, int oldDataSize);
    public bool IsOwned(long id);
    public void Delete(long id);
    private void ReleaseNearlyEmptySection(long id, long sectionPageNumber);
    [DoesNotReturnAttribute]
private void ThrowNotOwned(long id);
    [DoesNotReturnAttribute]
private void ThrowInvalidAttemptToRemoveValueFromIndexAndNotFindingIt(long id, Slice indexDefName);
    private void DeleteValueFromIndex(long id, TableValueReader& value);
    public void AssertValidFixedSizeTrees();
    public long Insert(TableValueBuilder builder);
    private Page AllocatePageForLargeValue(int size, bool compressed);
    private long AllocateFromAnotherSection(int itemSize);
    [DoesNotReturnAttribute]
private void ThrowBadWriter(int size, long id, bool compressed);
    [DoesNotReturnAttribute]
private void ThrowBadAllocation(int size);
    private void UpdateValuesFromIndex(long id, TableValueReader& oldVer, TableValueBuilder newVer, bool forceUpdate);
    private void AddValueToDynamicIndex(long id, DynamicKeyIndexDef dynamicKeyIndexDef, Tree indexTree, Slice newVal, TreeNodeFlags flags);
    private void RemoveValueFromDynamicIndex(long id, DynamicKeyIndexDef dynamicKeyIndexDef, Tree tree, Slice val);
    internal long Insert(TableValueReader& reader);
    private void InsertIndexValuesFor(long id, TableValueReader& value);
    [DoesNotReturnAttribute]
private void ThrowInvalidDuplicateFixedSizeTreeKey(long key, FixedSizeKeyIndexDef indexDef);
    public FixedSizeTree GetFixedSizeTree(FixedSizeKeyIndexDef indexDef);
    internal FixedSizeTree GetFixedSizeTree(Tree parent, Slice name, ushort valSize, bool isGlobal, bool isIndexTree);
    private void CreateNewActiveSection();
    private bool TryFindMatchFromCandidateSections(int size, Int64& id);
    internal Tree GetTree(Slice name, bool isIndexTree);
    internal Tree GetTree(AbstractTreeIndexDef idx);
    public bool DeleteByKey(Slice key);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<GetSecondaryIndexForValue>d__77")]
private IEnumerable`1<TableValueHolder> GetSecondaryIndexForValue(Tree tree, Slice value, AbstractTreeIndexDef index);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<GetBackwardSecondaryIndexForValue>d__78")]
private IEnumerable`1<TableValueHolder> GetBackwardSecondaryIndexForValue(Tree tree, Slice value, AbstractTreeIndexDef index);
    private void ReadById(long id, TableValueReader& reader);
    public long GetNumberOfEntriesAfter(FixedSizeKeyIndexDef index, long afterValue, Int64& totalCount, Stopwatch overallDuration);
    public long GetNumberOfEntriesFor(FixedSizeKeyIndexDef index);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<SeekForwardFrom>d__82")]
public IEnumerable`1<SeekResult> SeekForwardFrom(AbstractTreeIndexDef index, Slice value, long skip, bool startsWith);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<SeekForwardFromPrefix>d__83")]
public IEnumerable`1<SeekResult> SeekForwardFromPrefix(AbstractTreeIndexDef index, Slice start, Slice prefix, long skip);
    public TableValueHolder SeekOneForwardFromPrefix(AbstractTreeIndexDef index, Slice value);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<SeekBackwardFrom>d__85")]
public IEnumerable`1<SeekResult> SeekBackwardFrom(AbstractTreeIndexDef index, Nullable`1<Slice> prefix, Slice last, long skip);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<SeekBackwardFrom>d__86")]
public IEnumerable`1<SeekResult> SeekBackwardFrom(AbstractTreeIndexDef index, Slice prefix, Slice last);
    public TableValueHolder SeekOneBackwardFrom(AbstractTreeIndexDef index, Slice prefix, Slice last);
    public long GetCountOfMatchesFor(AbstractTreeIndexDef index, Slice value);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<SeekByPrefix>d__89")]
public IEnumerable`1<SeekResult> SeekByPrefix(DynamicKeyIndexDef def, Slice requiredPrefix, Slice startAfter, long skip);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<SeekByPrimaryKeyPrefix>d__90")]
public IEnumerable`1<ValueTuple`2<Slice, TableValueHolder>> SeekByPrimaryKeyPrefix(Slice requiredPrefix, Slice startAfter, long skip);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<SeekByPrimaryKey>d__91")]
public IEnumerable`1<TableValueHolder> SeekByPrimaryKey(Slice value, long skip);
    public bool SeekOneBackwardByPrimaryKeyPrefix(Slice prefix, Slice value, TableValueReader& reader, bool excludeValueFromSeek);
    public void DeleteByPrimaryKey(Slice value, Func`2<TableValueHolder, bool> deletePredicate);
    public TableValueHolder ReadFirst(FixedSizeKeyIndexDef index);
    public bool SeekOnePrimaryKey(Slice slice, TableValueReader& reader);
    public bool SeekOnePrimaryKeyPrefix(Slice slice, TableValueReader& reader);
    public bool SeekOnePrimaryKeyWithPrefix(Slice prefix, Slice value, TableValueReader& reader);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<IterateForDictionaryTraining>d__99")]
public IEnumerable`1<ValueTuple`2<long, TableValueHolder>> IterateForDictionaryTraining(FixedSizeKeyIndexDef index, long skip, long seek);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<SeekForwardFrom>d__100")]
public IEnumerable`1<TableValueHolder> SeekForwardFrom(FixedSizeKeyIndexDef index, long key, long skip);
    public TableValueHolder ReadLast(FixedSizeKeyIndexDef index);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<SeekBackwardFromLast>d__102")]
public IEnumerable`1<TableValueHolder> SeekBackwardFromLast(FixedSizeKeyIndexDef index, long skip);
    [IteratorStateMachineAttribute("Voron.Data.Tables.Table/<SeekBackwardFrom>d__103")]
public IEnumerable`1<TableValueHolder> SeekBackwardFrom(FixedSizeKeyIndexDef index, long key, long skip);
    public bool HasEntriesGreaterThanStartAndLowerThanOrEqualToEnd(FixedSizeKeyIndexDef index, long start, long end);
    private void GetTableValueReader(IFixedSizeIterator<long> it, TableValueReader& reader);
    private void GetTableValueReader(IIterator it, TableValueReader& reader);
    public bool Set(TableValueBuilder builder, bool forceUpdate);
    public long DeleteBackwardFrom(FixedSizeKeyIndexDef index, long value, long numberOfEntriesToDelete);
    public bool FindByIndex(FixedSizeKeyIndexDef index, long value, TableValueReader& reader);
    public bool DeleteByIndex(FixedSizeKeyIndexDef index, long value);
    public bool DeleteByPrimaryKeyPrefix(Slice startSlice, Action`1<TableValueHolder> beforeDelete, Func`2<TableValueHolder, bool> shouldAbort);
    public long DeleteForwardFrom(AbstractTreeIndexDef index, Slice value, bool startsWith, long numberOfEntriesToDelete, Action`1<TableValueHolder> beforeDelete, Func`2<TableValueHolder, bool> shouldAbort);
    public bool DeleteForwardUpToPrefix(Slice startSlice, long upToIndex, long numberOfEntriesToDelete);
    [DoesNotReturnAttribute]
private static void ThrowNonNegativeNumberOfEntriesToDelete();
    public void PrepareForCommit();
    [ConditionalAttribute("DEBUG")]
private void AssertValidIndexes();
    [DoesNotReturnAttribute]
private void ThrowInconsistentItemsCountInIndexes(string indexName, long expectedSize, long actualSize);
    [ConditionalAttribute("VALIDATE")]
internal void AssertValidTable();
    public TableReport GetReport(bool includeDetails, StorageReportGenerator generatorInstance);
    [ConditionalAttribute("DEBUG")]
private void AssertWritableTable();
    public ReturnTableValueBuilderToCache Allocate(TableValueBuilder& builder);
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
private int <IterateForDictionaryTraining>g__ReadChunked|99_0(IFixedSizeIterator<long> it, ByteString chunk, Boolean& hasMore, <>c__DisplayClass99_0& );
    [CompilerGeneratedAttribute]
private long <IterateForDictionaryTraining>g__GetTableValueReader|99_1(ByteString chunk, long index, TableValueReader& reader, <>c__DisplayClass99_0& );
}
public class Voron.Data.Tables.TableReport : object {
    private StorageReportGenerator _storageGenerator;
    [CompilerGeneratedAttribute]
private List`1<TreeReport> <Structure>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TreeReport> <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private PreAllocatedBuffersReport <PreAllocatedBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DataSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocatedSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UsedSizeInBytes>k__BackingField;
    public List`1<TreeReport> Structure { get; }
    public List`1<TreeReport> Indexes { get; }
    public PreAllocatedBuffersReport PreAllocatedBuffers { get; public set; }
    public string Name { get; public set; }
    public long NumberOfEntries { get; public set; }
    public long DataSizeInBytes { get; private set; }
    public string DataSizeHumane { get; }
    public long AllocatedSpaceInBytes { get; private set; }
    public string AllocatedSpaceHumane { get; }
    public long UsedSizeInBytes { get; private set; }
    public string UsedSizeHumane { get; }
    public TableReport(long allocatedSpaceInBytes, long usedSizeInBytes, bool calculateExactSizes, StorageReportGenerator generator);
    public void AddStructure(FixedSizeTree fst, bool includeDetails);
    public void AddStructure(Tree tree, bool includeDetails);
    private void AddStructure(TreeReport report, int pageSize, bool includeDetails);
    public void AddIndex(FixedSizeTree fst, bool includeDetails);
    public void AddIndex(Tree tree, bool includeDetails);
    private void AddIndex(TreeReport report, int pageSize, bool includeDetails);
    public void AddData(RawDataSection section, bool includeDetails);
    public void AddPreAllocatedBuffers(NewPageAllocator tablePageAllocator, bool includeDetails);
    [CompilerGeneratedAttribute]
public List`1<TreeReport> get_Structure();
    [CompilerGeneratedAttribute]
public List`1<TreeReport> get_Indexes();
    [CompilerGeneratedAttribute]
public PreAllocatedBuffersReport get_PreAllocatedBuffers();
    [CompilerGeneratedAttribute]
public void set_PreAllocatedBuffers(PreAllocatedBuffersReport value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_NumberOfEntries();
    [CompilerGeneratedAttribute]
public void set_NumberOfEntries(long value);
    [CompilerGeneratedAttribute]
public long get_DataSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_DataSizeInBytes(long value);
    public string get_DataSizeHumane();
    [CompilerGeneratedAttribute]
public long get_AllocatedSpaceInBytes();
    [CompilerGeneratedAttribute]
private void set_AllocatedSpaceInBytes(long value);
    public string get_AllocatedSpaceHumane();
    [CompilerGeneratedAttribute]
public long get_UsedSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_UsedSizeInBytes(long value);
    public string get_UsedSizeHumane();
}
public class Voron.Data.Tables.TableSchema : object {
    public static Slice ActiveSectionSlice;
    public static Slice InactiveSectionSlice;
    public static Slice ActiveCandidateSectionSlice;
    public static Slice StatsSlice;
    public static Slice SchemasSlice;
    public static Slice PkSlice;
    public static Slice CompressionDictionariesSlice;
    public static Slice CurrentCompressionDictionaryIdSlice;
    private IndexDef _primaryKey;
    private bool _compressed;
    public FixedSizeKeyIndexDef CompressedEtagSourceIndex;
    private Dictionary`2<Slice, IndexDef> _commonIndexes;
    private Dictionary`2<Slice, DynamicKeyIndexDef> _dynamicKeyIndexes;
    private Dictionary`2<Slice, FixedSizeKeyIndexDef> _fixedSizeIndexes;
    [CompilerGeneratedAttribute]
private byte <TableType>k__BackingField;
    public byte TableType { get; public set; }
    public IndexDef Key { get; }
    public Dictionary`2<Slice, IndexDef> Indexes { get; }
    public Dictionary`2<Slice, FixedSizeKeyIndexDef> FixedSizeIndexes { get; }
    public Dictionary`2<Slice, DynamicKeyIndexDef> DynamicKeyIndexes { get; }
    public bool Compressed { get; public set; }
    private static TableSchema();
    [CompilerGeneratedAttribute]
public byte get_TableType();
    [CompilerGeneratedAttribute]
public void set_TableType(byte value);
    public IndexDef get_Key();
    public Dictionary`2<Slice, IndexDef> get_Indexes();
    public Dictionary`2<Slice, FixedSizeKeyIndexDef> get_FixedSizeIndexes();
    public Dictionary`2<Slice, DynamicKeyIndexDef> get_DynamicKeyIndexes();
    public TableSchema CompressValues(FixedSizeKeyIndexDef etagSource, bool compress);
    public bool get_Compressed();
    public void set_Compressed(bool value);
    public TableSchema DefineIndex(IndexDef index);
    public TableSchema DefineIndex(DynamicKeyIndexDef index);
    public TableSchema DefineFixedSizeIndex(FixedSizeKeyIndexDef index);
    public TableSchema DefineKey(IndexDef index);
    public void Create(Transaction tx, string name, Nullable`1<ushort> sizeInPages);
    public void Create(Transaction tx, Slice name, Nullable`1<ushort> sizeInPages);
    internal void SerializeSchemaIntoTableTree(Tree tableTree);
    internal Byte[] SerializeSchema();
    public static TableSchema ReadFrom(ByteStringContext context, Byte* location, int size);
    private static void ReadTreeIndexDefinition(ByteStringContext context, TableSchema schema, Byte* currentPtr, int currentSize);
    public void Validate(TableSchema actual);
}
public class Voron.Data.Tables.TableSchemaStats : ValueType {
    public long NumberOfEntries;
    public long OverflowPageCount;
}
public class Voron.Data.Tables.TableSchemaStatsReference : object {
    [CompilerGeneratedAttribute]
private long <NumberOfEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OverflowPageCount>k__BackingField;
    public long NumberOfEntries { get; public set; }
    public long OverflowPageCount { get; public set; }
    [CompilerGeneratedAttribute]
public long get_NumberOfEntries();
    [CompilerGeneratedAttribute]
public void set_NumberOfEntries(long value);
    [CompilerGeneratedAttribute]
public long get_OverflowPageCount();
    [CompilerGeneratedAttribute]
public void set_OverflowPageCount(long value);
}
public class Voron.Data.Tables.TableValueBuilder : object {
    private FastList`1<PtrSize> _values;
    private int _elementSize;
    private bool _isDirty;
    private int _size;
    private TableValueCompressor Compression;
    public int ElementSize { get; }
    public int Size { get; }
    public int RawSize { get; }
    public int Count { get; }
    public bool Compressed { get; }
    public bool CompressionTried { get; }
    public int get_ElementSize();
    public int get_Size();
    public int get_RawSize();
    public int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Reset();
    public int SizeOf(int index);
    public Scope<ByteStringMemoryCache> SliceFromLocation(ByteStringContext context, int index, Slice& slice);
    public void Add(T value);
    public void Add(Slice buffer);
    public void Add(Void* pointer, int size);
    private void Add(PtrSize& ptr);
    [DoesNotReturnAttribute]
private void ThrowSizeCannotBeNegative(string argument);
    public void CopyTo(Byte* ptr);
    public bool TryCompression(Table table, TableSchema schema);
    public bool TryCompression(Table table, TableSchema schema, Byte*& ptr, Int32& size);
    public bool get_Compressed();
    public bool get_CompressionTried();
    public TableValueReader CreateReader(Byte* pos);
}
public class Voron.Data.Tables.TableValueCompressor : object {
    private static int OverheadSize;
    internal static string CompressionRecoveryExtension;
    public static string CompressionRecoveryExtensionGlob;
    private TableValueBuilder _builder;
    public bool Compressed;
    public ByteString CompressedBuffer;
    public ByteString RawBuffer;
    private InternalScope<ByteStringMemoryCache> _compressedScope;
    public InternalScope<ByteStringMemoryCache> RawScope;
    public bool CompressionTried;
    private static Logger Logger;
    public static Byte[] EncryptionContext;
    public bool IsValid { get; }
    public int Size { get; }
    public TableValueCompressor(TableValueBuilder builder);
    private static TableValueCompressor();
    public bool get_IsValid();
    public int get_Size();
    public TableValueReader CreateReader(Byte* pos);
    public bool TryCompression(Table table, TableSchema schema);
    private bool ShouldRetrain(FixedSizeTree etagTree);
    private byte GetCompressionRatio(int compressed, int raw);
    public int WriteVariableSizeIntInReverse(Byte* buffer, int value);
    private void MaybeTrainCompressionDictionary(Table table, FixedSizeTree etagsTree);
    private static void RecreateRecoveryDictionaries(IPagerLevelTransactionState obj);
    internal bool ShouldReplaceDictionary(Transaction tx, CompressionDictionary newDic);
    public void CopyTo(Byte* ptr);
    public void DiscardCompressedData();
    public void Reset();
    [CompilerGeneratedAttribute]
internal static void <RecreateRecoveryDictionaries>g__AppendNewDictionaryEntries|23_0(int lastWritten, ZipArchive zip, <>c__DisplayClass23_0& , <>c__DisplayClass23_1& );
    [CompilerGeneratedAttribute]
internal static void <RecreateRecoveryDictionaries>g__EncryptDictionary|23_1(int dicId, Span`1<byte> data, ZipArchive zip, <>c__DisplayClass23_0& , <>c__DisplayClass23_1& );
}
[IsReadOnlyAttribute]
public class Voron.Data.Tables.TableValueReader : ValueType {
    public long Id;
    public Byte* Pointer;
    public int Size;
    private int _offset;
    private int _elementSize;
    public int Count { get; }
    public TableValueReader(Byte* ptr, int size);
    public TableValueReader(long id, Byte* ptr, int size);
    public int get_Count();
    public long ReadLong(int index);
    public string ReadString(int index);
    public string ReadStringWithPrefix(int index, int bytesToSkip);
    public Byte* Read(int index, Int32& size);
    [DoesNotReturnAttribute]
private void ThrowInvalidElementSize();
    [DoesNotReturnAttribute]
private static void ThrowIndexOutOfRange();
}
public class Voron.Data.VoronStream : Stream {
    [CompilerGeneratedAttribute]
private Slice <Name>k__BackingField;
    private ChunkDetails[] _chunksDetails;
    private Int64[] _chunksOffsets;
    private bool _encrypted;
    private long _position;
    private int _index;
    private LowLevelTransaction _llt;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    private Page _lastPage;
    public Slice Name { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public VoronStream(Slice name, ChunkDetails[] chunksDetails, LowLevelTransaction llt);
    [CompilerGeneratedAttribute]
public Slice get_Name();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    [CompilerGeneratedAttribute]
public virtual long get_Length();
    public virtual string ToString();
    public void UpdateCurrentTransaction(Transaction tx);
    [DoesNotReturnAttribute]
private void ThrowTransactionIsNull();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void UpdateLastPageIfNeeded(long pageNumber);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [DoesNotReturnAttribute]
private static void ThrowWhenValueIsEqualOrLessZero(long position);
}
public class Voron.DataIntegrityErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string Message { get; private set; }
    public Exception Exception { get; private set; }
    internal DataIntegrityErrorEventArgs(string message, Exception exception);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
public class Voron.Debugging.ActiveTransaction : object {
    public long Id;
    public TransactionFlags Flags;
    public bool AsyncCommit;
    public virtual string ToString();
}
public class Voron.Debugging.CommitStats : object {
    public int NumberOfModifiedPages;
    public int NumberOf4KbsWrittenToDisk;
}
public class Voron.Debugging.DataFileReport : object {
    [CompilerGeneratedAttribute]
private long <AllocatedSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UsedSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FreeSpaceInBytes>k__BackingField;
    public long AllocatedSpaceInBytes { get; public set; }
    public long UsedSpaceInBytes { get; public set; }
    public long FreeSpaceInBytes { get; public set; }
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public long get_AllocatedSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_AllocatedSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_UsedSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_UsedSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_FreeSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_FreeSpaceInBytes(long value);
}
public class Voron.Debugging.DebugStuff : object {
    private static string css;
    [ConditionalAttribute("DEBUG")]
public static void RenderAndShow_FixedSizeTree(LowLevelTransaction tx, FixedSizeTree`1<TVal> fst);
    private static Task DumpFixedSizeTreeToStreamAsync(LowLevelTransaction tx, FixedSizeTree`1<TVal> fst, TextWriter writer, Slice name, Tree tree);
    [AsyncStateMachineAttribute("Voron.Debugging.DebugStuff/<RenderLargeFixedSizeTreeAsync>d__3`1")]
private static Task RenderLargeFixedSizeTreeAsync(LargeFixedSizeTreeSafe tree, LowLevelTransaction tx, FixedSizeTree`1<TVal> fst, TextWriter writer);
    [AsyncStateMachineAttribute("Voron.Debugging.DebugStuff/<RenderEmbeddedFixedSizeTreeAsync>d__4")]
private static Task RenderEmbeddedFixedSizeTreeAsync(EmbeddedFixedSizeTreeSafe tree, TextWriter writer);
    private static Task RenderEmptyFixedSizeTreeAsync(TextWriter writer);
    private static void RenderHtmlTreeView(Action`1<TextWriter> action);
    [AsyncStateMachineAttribute("Voron.Debugging.DebugStuff/<RenderFixedSizeTreePageAsync>d__7`1")]
private static Task RenderFixedSizeTreePageAsync(LowLevelTransaction tx, FixedSizeTreePage`1<TVal> page, TextWriter sw, LargeFixedSizeTreeSafe tree, string text, bool open);
    [ConditionalAttribute("DEBUG")]
public static void RenderAndShow(Lookup`1<TKey> tree, int steps, string message);
    [ConditionalAttribute("DEBUG")]
public static void RenderAndShow(CompactTree tree, string message);
    [ConditionalAttribute("DEBUG")]
public static void RenderAndShowTCompactTree(Lookup`1<TKey> tree, int steps, long startPageNumber, string headerData);
    private static void RenderPageInternal(Lookup`1<TKey> tree, int steps, Page page, TextWriter sw, string text, bool open);
    private static long GetFixedSizeTreeKey(FixedSizeTreePage`1<TVal> page, LargeFixedSizeTreeSafe tree, int i);
    private static long GetFixedSizeTreePageNumber(FixedSizeTreePage`1<TVal> page, int i);
    private static FixedSizeTreePage`1<TVal> CreateFixedSizeTreePage(Page page, LargeFixedSizeTreeSafe tree);
    [ConditionalAttribute("DEBUG")]
public static void RenderAndShow(PostingList tree);
    [ConditionalAttribute("DEBUG")]
public static void RenderAndShowTCompactTree(PostingList tree, long startPageNumber, string headerData);
    private static void RenderPageInternal(PostingList tree, Page page, TextWriter sw, string text, bool open);
    [ConditionalAttribute("DEBUG")]
public static void RenderAndShow(Tree tree, bool decompress);
    [ConditionalAttribute("DEBUG")]
public static void RenderAndShowTree(Tree tree, long startPageNumber, string headerData, bool decompress);
    public static Task DumpTreeToStreamAsync(Tree tree, Stream stream);
    public static Task DumpFixedSizedTreeToStreamAsync(LowLevelTransaction tx, FixedSizeTree tree, Stream stream);
    [AsyncStateMachineAttribute("Voron.Debugging.DebugStuff/<WriteHtmlAsync>d__22")]
private static Task WriteHtmlAsync(TextWriter sw, Func`2<TextWriter, Task> action);
    private static Task RenderPageAsync(Tree tree, TreePage page, TextWriter sw, string text, bool open, bool decompress);
    [AsyncStateMachineAttribute("Voron.Debugging.DebugStuff/<RenderPageInternalAsync>d__24")]
private static Task RenderPageInternalAsync(Tree tree, TreePageSafe page, TextWriter sw, string text, bool open, bool decompress);
}
public class Voron.Debugging.DetailedReportInput : object {
    public long NumberOfAllocatedPages;
    public long NumberOfFreePages;
    public long NextPageNumber;
    public List`1<Tree> Trees;
    public List`1<FixedSizeTree> FixedSizeTrees;
    public List`1<JournalFile> Journals;
    [CompilerGeneratedAttribute]
private JournalFile[] <FlushedJournals>k__BackingField;
    public List`1<Table> Tables;
    public Dictionary`2<Slice, long> Containers;
    public List`1<PostingList> PostingLists;
    public List`1<PersistentDictionaryRootHeader> PersistentDictionaries;
    public List`1<Lookup`1<Int64LookupKey>> NumericLookups;
    public List`1<Lookup`1<CompactKeyLookup>> TextualLookups;
    [CompilerGeneratedAttribute]
private bool <IncludeDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private VoronPathSetting <TempPath>k__BackingField;
    [CompilerGeneratedAttribute]
private VoronPathSetting <JournalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastFlushedTransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastFlushedJournalId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalWrittenButUnsyncedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <TotalEncryptionBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private InMemoryStorageState <InMemoryStorageState>k__BackingField;
    public JournalFile[] FlushedJournals { get; public set; }
    public bool IncludeDetails { get; public set; }
    public VoronPathSetting TempPath { get; public set; }
    public VoronPathSetting JournalPath { get; public set; }
    public long LastFlushedTransactionId { get; public set; }
    public long LastFlushedJournalId { get; public set; }
    public long TotalWrittenButUnsyncedBytes { get; public set; }
    public Size TotalEncryptionBufferSize { get; public set; }
    public InMemoryStorageState InMemoryStorageState { get; public set; }
    [CompilerGeneratedAttribute]
public JournalFile[] get_FlushedJournals();
    [CompilerGeneratedAttribute]
public void set_FlushedJournals(JournalFile[] value);
    [CompilerGeneratedAttribute]
public bool get_IncludeDetails();
    [CompilerGeneratedAttribute]
public void set_IncludeDetails(bool value);
    [CompilerGeneratedAttribute]
public VoronPathSetting get_TempPath();
    [CompilerGeneratedAttribute]
public void set_TempPath(VoronPathSetting value);
    [CompilerGeneratedAttribute]
public VoronPathSetting get_JournalPath();
    [CompilerGeneratedAttribute]
public void set_JournalPath(VoronPathSetting value);
    [CompilerGeneratedAttribute]
public long get_LastFlushedTransactionId();
    [CompilerGeneratedAttribute]
public void set_LastFlushedTransactionId(long value);
    [CompilerGeneratedAttribute]
public long get_LastFlushedJournalId();
    [CompilerGeneratedAttribute]
public void set_LastFlushedJournalId(long value);
    [CompilerGeneratedAttribute]
public long get_TotalWrittenButUnsyncedBytes();
    [CompilerGeneratedAttribute]
public void set_TotalWrittenButUnsyncedBytes(long value);
    [CompilerGeneratedAttribute]
public Size get_TotalEncryptionBufferSize();
    [CompilerGeneratedAttribute]
public void set_TotalEncryptionBufferSize(Size value);
    [CompilerGeneratedAttribute]
public InMemoryStorageState get_InMemoryStorageState();
    [CompilerGeneratedAttribute]
public void set_InMemoryStorageState(InMemoryStorageState value);
}
public class Voron.Debugging.DetailedStorageReport : object {
    [CompilerGeneratedAttribute]
private InMemoryStorageState <InMemoryState>k__BackingField;
    [CompilerGeneratedAttribute]
private DataFileReport <DataFile>k__BackingField;
    [CompilerGeneratedAttribute]
private JournalsReport <Journals>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TempBufferReport> <TempBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TreeReport> <Trees>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TableReport> <Tables>k__BackingField;
    [CompilerGeneratedAttribute]
private PreAllocatedBuffersReport <PreAllocatedBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TotalEncryptionBufferSize>k__BackingField;
    public InMemoryStorageState InMemoryState { get; public set; }
    public DataFileReport DataFile { get; public set; }
    public JournalsReport Journals { get; public set; }
    public List`1<TempBufferReport> TempBuffers { get; public set; }
    public List`1<TreeReport> Trees { get; public set; }
    public List`1<TableReport> Tables { get; public set; }
    public PreAllocatedBuffersReport PreAllocatedBuffers { get; public set; }
    public string TotalEncryptionBufferSize { get; public set; }
    [CompilerGeneratedAttribute]
public InMemoryStorageState get_InMemoryState();
    [CompilerGeneratedAttribute]
public void set_InMemoryState(InMemoryStorageState value);
    [CompilerGeneratedAttribute]
public DataFileReport get_DataFile();
    [CompilerGeneratedAttribute]
public void set_DataFile(DataFileReport value);
    [CompilerGeneratedAttribute]
public JournalsReport get_Journals();
    [CompilerGeneratedAttribute]
public void set_Journals(JournalsReport value);
    [CompilerGeneratedAttribute]
public List`1<TempBufferReport> get_TempBuffers();
    [CompilerGeneratedAttribute]
public void set_TempBuffers(List`1<TempBufferReport> value);
    [CompilerGeneratedAttribute]
public List`1<TreeReport> get_Trees();
    [CompilerGeneratedAttribute]
public void set_Trees(List`1<TreeReport> value);
    [CompilerGeneratedAttribute]
public List`1<TableReport> get_Tables();
    [CompilerGeneratedAttribute]
public void set_Tables(List`1<TableReport> value);
    [CompilerGeneratedAttribute]
public PreAllocatedBuffersReport get_PreAllocatedBuffers();
    [CompilerGeneratedAttribute]
public void set_PreAllocatedBuffers(PreAllocatedBuffersReport value);
    [CompilerGeneratedAttribute]
public string get_TotalEncryptionBufferSize();
    [CompilerGeneratedAttribute]
public void set_TotalEncryptionBufferSize(string value);
}
public class Voron.Debugging.EnvironmentStats : object {
    public long FreePagesOverhead;
    public long RootPages;
    public long UnallocatedPagesAtEndOfFile;
    public long UsedDataFileSizeInBytes;
    public long AllocatedDataFileSizeInBytes;
    public long NextWriteTransactionId;
}
public class Voron.Debugging.InMemoryStorageState : object {
    [CompilerGeneratedAttribute]
private long <CurrentReadTransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NextWriteTransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PossibleOldestReadTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ActiveTransaction> <ActiveTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private FlushStateDetails <FlushState>k__BackingField;
    [CompilerGeneratedAttribute]
private SyncStateDetails <SyncState>k__BackingField;
    public long CurrentReadTransactionId { get; public set; }
    public long NextWriteTransactionId { get; public set; }
    public long PossibleOldestReadTransaction { get; public set; }
    public List`1<ActiveTransaction> ActiveTransactions { get; public set; }
    public FlushStateDetails FlushState { get; public set; }
    public SyncStateDetails SyncState { get; public set; }
    [CompilerGeneratedAttribute]
public long get_CurrentReadTransactionId();
    [CompilerGeneratedAttribute]
public void set_CurrentReadTransactionId(long value);
    [CompilerGeneratedAttribute]
public long get_NextWriteTransactionId();
    [CompilerGeneratedAttribute]
public void set_NextWriteTransactionId(long value);
    [CompilerGeneratedAttribute]
public long get_PossibleOldestReadTransaction();
    [CompilerGeneratedAttribute]
public void set_PossibleOldestReadTransaction(long value);
    [CompilerGeneratedAttribute]
public List`1<ActiveTransaction> get_ActiveTransactions();
    [CompilerGeneratedAttribute]
public void set_ActiveTransactions(List`1<ActiveTransaction> value);
    [CompilerGeneratedAttribute]
public FlushStateDetails get_FlushState();
    [CompilerGeneratedAttribute]
public void set_FlushState(FlushStateDetails value);
    [CompilerGeneratedAttribute]
public SyncStateDetails get_SyncState();
    [CompilerGeneratedAttribute]
public void set_SyncState(SyncStateDetails value);
}
public class Voron.Debugging.JournalReport : object {
    [CompilerGeneratedAttribute]
private long <Number>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocatedSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Available4Kbs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Flushed>k__BackingField;
    public long Number { get; public set; }
    public long AllocatedSpaceInBytes { get; public set; }
    public long Available4Kbs { get; public set; }
    public long LastTransaction { get; public set; }
    public bool Flushed { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Number();
    [CompilerGeneratedAttribute]
public void set_Number(long value);
    [CompilerGeneratedAttribute]
public long get_AllocatedSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_AllocatedSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_Available4Kbs();
    [CompilerGeneratedAttribute]
public void set_Available4Kbs(long value);
    [CompilerGeneratedAttribute]
public long get_LastTransaction();
    [CompilerGeneratedAttribute]
public void set_LastTransaction(long value);
    [CompilerGeneratedAttribute]
public bool get_Flushed();
    [CompilerGeneratedAttribute]
public void set_Flushed(bool value);
}
public class Voron.Debugging.JournalsReport : object {
    [CompilerGeneratedAttribute]
private long <LastFlushedJournal>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalWrittenButUnsyncedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastFlushedTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<JournalReport> <Journals>k__BackingField;
    public long LastFlushedJournal { get; public set; }
    public long TotalWrittenButUnsyncedBytes { get; public set; }
    public long LastFlushedTransaction { get; public set; }
    public List`1<JournalReport> Journals { get; public set; }
    [CompilerGeneratedAttribute]
public long get_LastFlushedJournal();
    [CompilerGeneratedAttribute]
public void set_LastFlushedJournal(long value);
    [CompilerGeneratedAttribute]
public long get_TotalWrittenButUnsyncedBytes();
    [CompilerGeneratedAttribute]
public void set_TotalWrittenButUnsyncedBytes(long value);
    [CompilerGeneratedAttribute]
public long get_LastFlushedTransaction();
    [CompilerGeneratedAttribute]
public void set_LastFlushedTransaction(long value);
    [CompilerGeneratedAttribute]
public List`1<JournalReport> get_Journals();
    [CompilerGeneratedAttribute]
public void set_Journals(List`1<JournalReport> value);
}
public class Voron.Debugging.MultiValuesReport : object {
    [CompilerGeneratedAttribute]
private long <NumberOfEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BranchPages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LeafPages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OverflowPages>k__BackingField;
    public long NumberOfEntries { get; public set; }
    public long PageCount { get; public set; }
    public long BranchPages { get; public set; }
    public long LeafPages { get; public set; }
    public long OverflowPages { get; public set; }
    [CompilerGeneratedAttribute]
public long get_NumberOfEntries();
    [CompilerGeneratedAttribute]
public void set_NumberOfEntries(long value);
    [CompilerGeneratedAttribute]
public long get_PageCount();
    [CompilerGeneratedAttribute]
public void set_PageCount(long value);
    [CompilerGeneratedAttribute]
public long get_BranchPages();
    [CompilerGeneratedAttribute]
public void set_BranchPages(long value);
    [CompilerGeneratedAttribute]
public long get_LeafPages();
    [CompilerGeneratedAttribute]
public void set_LeafPages(long value);
    [CompilerGeneratedAttribute]
public long get_OverflowPages();
    [CompilerGeneratedAttribute]
public void set_OverflowPages(long value);
}
public class Voron.Debugging.PreAllocatedBuffersReport : object {
    [CompilerGeneratedAttribute]
private long <AllocatedSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PreAllocatedBuffersSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfPreAllocatedPages>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeReport <AllocationTree>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OriginallyAllocatedSpaceInBytes>k__BackingField;
    public long AllocatedSpaceInBytes { get; public set; }
    public long PreAllocatedBuffersSpaceInBytes { get; public set; }
    public long NumberOfPreAllocatedPages { get; public set; }
    public TreeReport AllocationTree { get; public set; }
    public long OriginallyAllocatedSpaceInBytes { get; public set; }
    [CompilerGeneratedAttribute]
public long get_AllocatedSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_AllocatedSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_PreAllocatedBuffersSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_PreAllocatedBuffersSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfPreAllocatedPages();
    [CompilerGeneratedAttribute]
public void set_NumberOfPreAllocatedPages(long value);
    [CompilerGeneratedAttribute]
public TreeReport get_AllocationTree();
    [CompilerGeneratedAttribute]
public void set_AllocationTree(TreeReport value);
    [CompilerGeneratedAttribute]
public long get_OriginallyAllocatedSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_OriginallyAllocatedSpaceInBytes(long value);
}
public class Voron.Debugging.ReportInput : object {
    public List`1<JournalFile> Journals;
    [CompilerGeneratedAttribute]
private JournalFile[] <FlushedJournals>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfAllocatedPages>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfFreePages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NextPageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfTrees>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfTables>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfSets>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfContainers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfPersistentDictionaries>k__BackingField;
    [CompilerGeneratedAttribute]
private VoronPathSetting <TempPath>k__BackingField;
    [CompilerGeneratedAttribute]
private VoronPathSetting <JournalPath>k__BackingField;
    public JournalFile[] FlushedJournals { get; public set; }
    public long NumberOfAllocatedPages { get; public set; }
    public int NumberOfFreePages { get; public set; }
    public long NextPageNumber { get; public set; }
    public int CountOfTrees { get; public set; }
    public int CountOfTables { get; public set; }
    public int CountOfSets { get; public set; }
    public int CountOfContainers { get; public set; }
    public int CountOfPersistentDictionaries { get; public set; }
    public VoronPathSetting TempPath { get; public set; }
    public VoronPathSetting JournalPath { get; public set; }
    [CompilerGeneratedAttribute]
public JournalFile[] get_FlushedJournals();
    [CompilerGeneratedAttribute]
public void set_FlushedJournals(JournalFile[] value);
    [CompilerGeneratedAttribute]
public long get_NumberOfAllocatedPages();
    [CompilerGeneratedAttribute]
public void set_NumberOfAllocatedPages(long value);
    [CompilerGeneratedAttribute]
public int get_NumberOfFreePages();
    [CompilerGeneratedAttribute]
public void set_NumberOfFreePages(int value);
    [CompilerGeneratedAttribute]
public long get_NextPageNumber();
    [CompilerGeneratedAttribute]
public void set_NextPageNumber(long value);
    [CompilerGeneratedAttribute]
public int get_CountOfTrees();
    [CompilerGeneratedAttribute]
public void set_CountOfTrees(int value);
    [CompilerGeneratedAttribute]
public int get_CountOfTables();
    [CompilerGeneratedAttribute]
public void set_CountOfTables(int value);
    [CompilerGeneratedAttribute]
public int get_CountOfSets();
    [CompilerGeneratedAttribute]
public void set_CountOfSets(int value);
    [CompilerGeneratedAttribute]
public int get_CountOfContainers();
    [CompilerGeneratedAttribute]
public void set_CountOfContainers(int value);
    [CompilerGeneratedAttribute]
public int get_CountOfPersistentDictionaries();
    [CompilerGeneratedAttribute]
public void set_CountOfPersistentDictionaries(int value);
    [CompilerGeneratedAttribute]
public VoronPathSetting get_TempPath();
    [CompilerGeneratedAttribute]
public void set_TempPath(VoronPathSetting value);
    [CompilerGeneratedAttribute]
public VoronPathSetting get_JournalPath();
    [CompilerGeneratedAttribute]
public void set_JournalPath(VoronPathSetting value);
}
public class Voron.Debugging.SizeReport : object {
    [CompilerGeneratedAttribute]
private long <DataFileInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <JournalsInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TempBuffersInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TempRecyclableJournalsInBytes>k__BackingField;
    public long DataFileInBytes { get; public set; }
    public long JournalsInBytes { get; public set; }
    public long TempBuffersInBytes { get; public set; }
    public long TempRecyclableJournalsInBytes { get; public set; }
    [CompilerGeneratedAttribute]
public long get_DataFileInBytes();
    [CompilerGeneratedAttribute]
public void set_DataFileInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_JournalsInBytes();
    [CompilerGeneratedAttribute]
public void set_JournalsInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_TempBuffersInBytes();
    [CompilerGeneratedAttribute]
public void set_TempBuffersInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_TempRecyclableJournalsInBytes();
    [CompilerGeneratedAttribute]
public void set_TempRecyclableJournalsInBytes(long value);
}
public class Voron.Debugging.StorageReport : object {
    [CompilerGeneratedAttribute]
private DataFileReport <DataFile>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<JournalReport> <Journals>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TempBufferReport> <TempFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfTrees>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfTables>k__BackingField;
    public DataFileReport DataFile { get; public set; }
    public List`1<JournalReport> Journals { get; public set; }
    public List`1<TempBufferReport> TempFiles { get; public set; }
    public int CountOfTrees { get; public set; }
    public int CountOfTables { get; public set; }
    [CompilerGeneratedAttribute]
public DataFileReport get_DataFile();
    [CompilerGeneratedAttribute]
public void set_DataFile(DataFileReport value);
    [CompilerGeneratedAttribute]
public List`1<JournalReport> get_Journals();
    [CompilerGeneratedAttribute]
public void set_Journals(List`1<JournalReport> value);
    [CompilerGeneratedAttribute]
public List`1<TempBufferReport> get_TempFiles();
    [CompilerGeneratedAttribute]
public void set_TempFiles(List`1<TempBufferReport> value);
    [CompilerGeneratedAttribute]
public int get_CountOfTrees();
    [CompilerGeneratedAttribute]
public void set_CountOfTrees(int value);
    [CompilerGeneratedAttribute]
public int get_CountOfTables();
    [CompilerGeneratedAttribute]
public void set_CountOfTables(int value);
}
public class Voron.Debugging.StorageReportGenerator : object {
    private LowLevelTransaction _tx;
    private StreamDetails _skippedStreamsDetailsEntry;
    public static string SkippedStreamsDetailsName;
    [CompilerGeneratedAttribute]
private Action`2<PostingList, TreeReport> HandlePostingListDetails;
    public StorageReportGenerator(LowLevelTransaction tx);
    public StorageReport Generate(ReportInput input);
    [CompilerGeneratedAttribute]
public void add_HandlePostingListDetails(Action`2<PostingList, TreeReport> value);
    [CompilerGeneratedAttribute]
public void remove_HandlePostingListDetails(Action`2<PostingList, TreeReport> value);
    public DetailedStorageReport Generate(DetailedReportInput input);
    private DataFileReport GenerateDataFileReport(long numberOfAllocatedPages, long numberOfFreePages, long nextPageNumber);
    private List`1<JournalReport> GenerateJournalsReport(List`1<JournalFile> journals, JournalFile[] flushedJournals);
    public static List`1<TempBufferReport> GenerateTempBuffersReport(VoronPathSetting tempPath, VoronPathSetting journalPath);
    public static TreeReport GetReport(FixedSizeTree fst, bool includeDetails);
    public TreeReport GetReport(PostingList postingList, bool includeDetails);
    public TreeReport GetReport(Lookup`1<Int64LookupKey> lookup, bool includeDetails);
    public TreeReport GetReport(Lookup`1<CompactKeyLookup> lookup, bool includeDetails);
    public TreeReport GetContainerReport(string name, long page, bool includeDetails);
    public TreeReport GetReport(Tree tree, bool includeDetails);
    private StreamsReport CreateStreamsReport(Tree tree, bool includeDetails);
    private static MultiValuesReport CreateMultiValuesReport(Tree tree);
    public static PreAllocatedBuffersReport GetReport(NewPageAllocator preAllocatedBuffers, bool includeDetails);
    public static Dictionary`2<int, int> GatherBalanceDistribution(Tree tree);
    private static void GatherBalanceDistribution(Tree tree, TreePage page, Dictionary`2<int, int> histogram, int depth);
    public static List`1<double> GetPageDensities(Tree tree);
    public static List`1<double> GetPageDensities(PostingList postingList);
    public static List`1<double> GetLookupPageDensities(LowLevelTransaction llt, List`1<long> allPages);
    private static List`1<double> GetPageDensities(FixedSizeTree tree);
    private static TreePage GetNestedMultiValuePage(Tree tree, Byte* nestedPagePtr, TreeNodeHeader* currentNode);
    public static long PagesToBytes(long pageCount);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GenerateTempBuffersReport>g__GetFiles|11_2(string path, string searchPattern);
}
public class Voron.Debugging.StreamDetails : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfAllocatedPages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocatedSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeReport <ChunksTree>k__BackingField;
    public string Name { get; public set; }
    public long Length { get; public set; }
    public int Version { get; public set; }
    public long NumberOfAllocatedPages { get; public set; }
    public long AllocatedSpaceInBytes { get; public set; }
    public TreeReport ChunksTree { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(long value);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public long get_NumberOfAllocatedPages();
    [CompilerGeneratedAttribute]
public void set_NumberOfAllocatedPages(long value);
    [CompilerGeneratedAttribute]
public long get_AllocatedSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_AllocatedSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public TreeReport get_ChunksTree();
    [CompilerGeneratedAttribute]
public void set_ChunksTree(TreeReport value);
}
public class Voron.Debugging.StreamsReport : object {
    [CompilerGeneratedAttribute]
private List`1<StreamDetails> <Streams>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfStreams>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalNumberOfAllocatedPages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocatedSpaceInBytes>k__BackingField;
    public List`1<StreamDetails> Streams { get; public set; }
    public long NumberOfStreams { get; public set; }
    public long TotalNumberOfAllocatedPages { get; public set; }
    public long AllocatedSpaceInBytes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<StreamDetails> get_Streams();
    [CompilerGeneratedAttribute]
public void set_Streams(List`1<StreamDetails> value);
    [CompilerGeneratedAttribute]
public long get_NumberOfStreams();
    [CompilerGeneratedAttribute]
public void set_NumberOfStreams(long value);
    [CompilerGeneratedAttribute]
public long get_TotalNumberOfAllocatedPages();
    [CompilerGeneratedAttribute]
public void set_TotalNumberOfAllocatedPages(long value);
    [CompilerGeneratedAttribute]
public long get_AllocatedSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_AllocatedSpaceInBytes(long value);
}
public class Voron.Debugging.TempBufferReport : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocatedSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private TempBufferType <Type>k__BackingField;
    public string Name { get; public set; }
    public long AllocatedSpaceInBytes { get; public set; }
    public TempBufferType Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_AllocatedSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_AllocatedSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public TempBufferType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TempBufferType value);
}
public enum Voron.Debugging.TempBufferType : Enum {
    public int value__;
    public static TempBufferType Scratch;
    public static TempBufferType RecyclableJournal;
}
public class Voron.Debugging.TreeReport : object {
    [CompilerGeneratedAttribute]
private RootObjectType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BranchPages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LeafPages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OverflowPages>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Density>k__BackingField;
    [CompilerGeneratedAttribute]
private MultiValuesReport <MultiValues>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocatedSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UsedSpaceInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamsReport <Streams>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, int> <BalanceHistogram>k__BackingField;
    public RootObjectType Type { get; public set; }
    public string Name { get; public set; }
    public long PageCount { get; public set; }
    public long NumberOfEntries { get; public set; }
    public long BranchPages { get; public set; }
    public long LeafPages { get; public set; }
    public long OverflowPages { get; public set; }
    public int Depth { get; public set; }
    public double Density { get; public set; }
    public MultiValuesReport MultiValues { get; public set; }
    public long AllocatedSpaceInBytes { get; public set; }
    public long UsedSpaceInBytes { get; public set; }
    public StreamsReport Streams { get; public set; }
    public Dictionary`2<int, int> BalanceHistogram { get; internal set; }
    [CompilerGeneratedAttribute]
public RootObjectType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(RootObjectType value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_PageCount();
    [CompilerGeneratedAttribute]
public void set_PageCount(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfEntries();
    [CompilerGeneratedAttribute]
public void set_NumberOfEntries(long value);
    [CompilerGeneratedAttribute]
public long get_BranchPages();
    [CompilerGeneratedAttribute]
public void set_BranchPages(long value);
    [CompilerGeneratedAttribute]
public long get_LeafPages();
    [CompilerGeneratedAttribute]
public void set_LeafPages(long value);
    [CompilerGeneratedAttribute]
public long get_OverflowPages();
    [CompilerGeneratedAttribute]
public void set_OverflowPages(long value);
    [CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(int value);
    [CompilerGeneratedAttribute]
public double get_Density();
    [CompilerGeneratedAttribute]
public void set_Density(double value);
    [CompilerGeneratedAttribute]
public MultiValuesReport get_MultiValues();
    [CompilerGeneratedAttribute]
public void set_MultiValues(MultiValuesReport value);
    [CompilerGeneratedAttribute]
public long get_AllocatedSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_AllocatedSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_UsedSpaceInBytes();
    [CompilerGeneratedAttribute]
public void set_UsedSpaceInBytes(long value);
    [CompilerGeneratedAttribute]
public StreamsReport get_Streams();
    [CompilerGeneratedAttribute]
public void set_Streams(StreamsReport value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, int> get_BalanceHistogram();
    [CompilerGeneratedAttribute]
internal void set_BalanceHistogram(Dictionary`2<int, int> value);
}
public class Voron.DriveInfoByPath : object {
    [CompilerGeneratedAttribute]
private DriveInfoBase <BasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private DriveInfoBase <JournalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DriveInfoBase <TempPath>k__BackingField;
    public DriveInfoBase BasePath { get; public set; }
    public DriveInfoBase JournalPath { get; public set; }
    public DriveInfoBase TempPath { get; public set; }
    [CompilerGeneratedAttribute]
public DriveInfoBase get_BasePath();
    [CompilerGeneratedAttribute]
public void set_BasePath(DriveInfoBase value);
    [CompilerGeneratedAttribute]
public DriveInfoBase get_JournalPath();
    [CompilerGeneratedAttribute]
public void set_JournalPath(DriveInfoBase value);
    [CompilerGeneratedAttribute]
public DriveInfoBase get_TempPath();
    [CompilerGeneratedAttribute]
public void set_TempPath(DriveInfoBase value);
}
public class Voron.Exceptions.CatastrophicFailureNotification : object {
    private Action`4<Guid, string, Exception, string> _catastrophicFailure;
    private bool _raised;
    public CatastrophicFailureNotification(Action`4<Guid, string, Exception, string> catastrophicFailureHandler);
    public void RaiseNotificationOnce(Guid environmentId, string environmentPath, Exception e, string stacktrace);
}
public class Voron.Exceptions.IncreasingDataFileInCopyOnWriteModeException : Exception {
    [CompilerGeneratedAttribute]
private string <DataFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RequestedSize>k__BackingField;
    public string DataFilePath { get; }
    public long RequestedSize { get; }
    public IncreasingDataFileInCopyOnWriteModeException(string dataFilePath, long requestedSize);
    [CompilerGeneratedAttribute]
public string get_DataFilePath();
    [CompilerGeneratedAttribute]
public long get_RequestedSize();
}
public class Voron.Exceptions.InvalidFixedSizeTree : Exception {
    public InvalidFixedSizeTree(string message);
    public InvalidFixedSizeTree(string message, Exception inner);
}
public class Voron.Exceptions.InvalidJournalException : Exception {
    [CompilerGeneratedAttribute]
private long <Number>k__BackingField;
    public long Number { get; }
    public InvalidJournalException(string message, Exception innerException);
    public InvalidJournalException(string message, JournalInfo journalInfo);
    public InvalidJournalException(long number, string path, JournalInfo journalInfo);
    public InvalidJournalException(long number, JournalInfo journalInfo);
    [CompilerGeneratedAttribute]
public long get_Number();
}
public class Voron.Exceptions.InvalidJournalFlushRequestException : Exception {
    public InvalidJournalFlushRequestException(string message);
    public InvalidJournalFlushRequestException(string message, Exception inner);
}
public class Voron.Exceptions.PageCompressedException : Exception {
    public PageCompressedException(string message);
    public PageCompressedException(string message, Exception inner);
}
public class Voron.Exceptions.QuotaException : Exception {
    public QuotaException(string message);
    public QuotaException(string message, Exception inner);
}
public class Voron.Exceptions.SchemaErrorException : Exception {
    public SchemaErrorException(string message);
    public SchemaErrorException(string message, Exception inner);
    public static void Raise(StorageEnvironment env, string message);
}
public class Voron.Exceptions.VoronConcurrencyErrorException : VoronErrorException {
    public VoronConcurrencyErrorException(string message);
    public VoronConcurrencyErrorException(string message, Exception inner);
}
public class Voron.Exceptions.VoronErrorException : Exception {
    public VoronErrorException(string message);
    public VoronErrorException(string message, Exception inner);
}
public class Voron.Exceptions.VoronUnrecoverableErrorException : Exception {
    protected VoronUnrecoverableErrorException(string message);
    private VoronUnrecoverableErrorException(string message, Exception inner);
    public static void Raise(LowLevelTransaction tx, string message);
    [DoesNotReturnAttribute]
public static void Raise(StorageEnvironment env, string message);
    public static void Raise(StorageEnvironmentOptions options, string message);
    public static void Raise(StorageEnvironment env, string message, Exception inner);
    public static void Raise(StorageEnvironmentOptions options, string message, Exception inner);
    public static void Raise(string message, Exception inner);
}
public enum Voron.ExtendedPageType : Enum {
    public byte value__;
    public static ExtendedPageType None;
    public static ExtendedPageType PostingListLeaf;
    public static ExtendedPageType PostingListBranch;
    public static ExtendedPageType Container;
    public static ExtendedPageType ContainerOverflow;
}
public class Voron.Global.Constants : object {
    public static int CurrentVersion;
    public static ulong MagicMarker;
    public static ulong TransactionHeaderMarker;
    public static string RootTreeName;
    public static Slice RootTreeNameSlice;
    public static string MetadataTreeName;
    public static Slice MetadataTreeNameSlice;
    public static string DatabaseFilename;
    public static Slice DatabaseFilenameSlice;
    private static Constants();
    public static void Assert(Func`1<bool> condition, Func`1<string> reason);
}
public class Voron.GlobalFlushingBehavior : object {
    private static string FlushingThreadName;
    public static int NumberOfConcurrentSyncsPerPhysicalDrive;
    internal static Lazy`1<GlobalFlushingBehavior> GlobalFlusher;
    private ManualResetEventSlim _flushWriterEvent;
    private int _lowNumberOfFlushingResources;
    private SemaphoreSlim _concurrentFlushesAvailable;
    private ConcurrentQueue`1<EnvSyncReq> _maybeNeedToFlush;
    private ConcurrentDictionary`2<IndirectReference, EnvSyncReq> _envsToSync;
    private ConcurrentDictionary`2<UInt32, MountPointInfo> _mountPoints;
    private Logger _log;
    private TestingStuff _forTestingPurposes;
    public bool HasLowNumberOfFlushingResources { get; }
    private static GlobalFlushingBehavior();
    public bool get_HasLowNumberOfFlushingResources();
    private void VoronEnvironmentFlushing();
    private void SyncEnvironments(bool force);
    private void SyncAllEnvironmentsInMountPoint(object mt);
    private void SyncEnvironment(EnvSyncReq req);
    private void FlushEnvironments(HashSet`1<StorageEnvironment> avoidDuplicates);
    public void MaybeFlushEnvironment(StorageEnvironment env);
    public void SuggestSyncEnvironment(StorageEnvironment env);
    private void AddEnvironmentSyncRequest(StorageEnvironment env, bool required);
    public void ForceSyncEnvironment(StorageEnvironment env);
    internal TestingStuff ForTestingPurposesOnly();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <FlushEnvironments>b__18_0(object env);
}
public class Voron.GlobalPrefetchingBehavior : object {
    private static string PrefetchingThreadName;
    internal static Lazy`1<GlobalPrefetchingBehavior> GlobalPrefetcher;
    private Logger _log;
    public BlockingCollection`1<PrefetchRanges> CommandQueue;
    private static GlobalPrefetchingBehavior();
    private void VoronPrefetcher();
}
public static class Voron.Impl.Backup.BackupMethods : object {
    public static string Filename;
    public static FullBackup Full;
    public static IncrementalBackup Incremental;
    private static BackupMethods();
}
public class Voron.Impl.Backup.BackupZipArchive : object {
    private ZipArchive _zipArchive;
    private SnapshotBackupCompressionAlgorithm _compressionAlgorithm;
    private CompressionLevel _compressionLevel;
    private CompressionLevel _compressionLevelForZipEntry;
    public BackupZipArchive(ZipArchive zipArchive, SnapshotBackupCompressionAlgorithm compressionAlgorithm, CompressionLevel compressionLevel);
    public BackupZipArchiveEntry CreateEntry(string entryName);
    private static CompressionLevel GetCompressionLevelForZipEntry(SnapshotBackupCompressionAlgorithm compressionAlgorithm, CompressionLevel compressionLevel);
}
public class Voron.Impl.Backup.BackupZipArchiveEntry : object {
    private ZipArchiveEntry _zipEntry;
    private SnapshotBackupCompressionAlgorithm _compressionAlgorithm;
    private CompressionLevel _compressionLevel;
    public BackupZipArchiveEntry(ZipArchiveEntry zipEntry, SnapshotBackupCompressionAlgorithm compressionAlgorithm, CompressionLevel compressionLevel);
    public Stream Open();
}
public class Voron.Impl.Backup.FullBackup : object {
    public void ToFile(StorageEnvironment env, VoronPathSetting backupPath, SnapshotBackupCompressionAlgorithm compressionAlgorithm, CompressionLevel compressionLevel, Action`1<ValueTuple`2<string, int>> infoNotify);
    public void ToFile(IEnumerable`1<StorageEnvironmentInformation> envs, ZipArchive archive, SnapshotBackupCompressionAlgorithm compressionAlgorithm, CompressionLevel compressionLevel, Action`1<ValueTuple`2<string, int>> infoNotify, CancellationToken cancellationToken);
    private static void Backup(StorageEnvironment env, SnapshotBackupCompressionAlgorithm compressionAlgorithm, CompressionLevel compressionLevel, AbstractPager dataPager, ZipArchive zipArchive, string basePath, DataCopier copier, Action`1<ValueTuple`2<string, int>> infoNotify, CancellationToken cancellationToken);
    public void Restore(VoronPathSetting backupPath, VoronPathSetting voronDataDir, VoronPathSetting journalDir, Action`1<string> onProgress, CancellationToken cancellationToken);
    public void Restore(IEnumerable`1<ZipArchiveEntry> entries, VoronPathSetting voronDataDir, VoronPathSetting journalDir, Action`1<string> onProgress, CancellationToken cancellationToken);
    internal static Stream GetDecompressionStream(Stream stream);
}
public class Voron.Impl.Backup.IncrementalBackup : object {
    public long ToFile(StorageEnvironment env, string backupPath, CompressionLevel compression, Action`1<string> infoNotify, Action backupStarted);
    public long ToFile(IEnumerable`1<StorageEnvironmentInformation> envs, string backupPath, CompressionLevel compression, Action`1<string> infoNotify, Action backupStarted);
    private static long Incremental_Backup(StorageEnvironment env, CompressionLevel compression, Action`1<string> infoNotify, Action backupStarted, ZipArchive package, string basePath, DataCopier copier);
    internal static JournalFile GetJournalFile(StorageEnvironment env, long journalNum, IncrementalBackupInfo backupInfo, JournalInfo journalInfo);
    public void Restore(StorageEnvironmentOptions options, IEnumerable`1<string> backupPaths);
    public void Restore(string outPath, IEnumerable`1<string> backupPaths, Action`1<StorageEnvironmentOptions> configure);
    private void Restore(StorageEnvironment env, string singleBackupFile);
    private void Restore(StorageEnvironment env, IEnumerable`1<ZipArchiveEntry> entries);
    private static void Restore(StorageEnvironment env, IEnumerable`1<ZipArchiveEntry> entries, VoronPathSetting tempDir, List`1<IDisposable> toDispose, LowLevelTransaction txw);
}
public class Voron.Impl.Backup.IncrementalBackupInfo : ValueType {
    public long LastBackedUpJournal;
    public long LastBackedUpJournalPage;
    public long LastCreatedJournal;
}
[ExtensionAttribute]
public static class Voron.Impl.Backup.StreamExtensions : object {
    private static int DefaultBufferSize;
    [ExtensionAttribute]
public static void CopyTo(Stream source, Stream destination, Action`1<int> onProgress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Voron.Impl.Backup.StreamExtensions/<CopyToAsync>d__2")]
[ExtensionAttribute]
public static Task CopyToAsync(Stream source, Stream destination, Action`1<int> onProgress, CancellationToken cancellationToken);
}
public static class Voron.Impl.Compaction.StorageCompaction : object {
    public static string CannotCompactBecauseOfIncrementalBackup;
    public static void Execute(StorageEnvironmentOptions srcOptions, DirectoryStorageEnvironmentOptions compactOptions, Action`1<StorageCompactionProgress> progressReport, Action`2<string, TableSchema> modifyTableSchema, CancellationToken token);
    private static void CopyTrees(StorageEnvironment existingEnv, StorageEnvironment compactedEnv, Action`2<string, TableSchema> modifyTableSchema, Action`1<StorageCompactionProgress> progressReport, CancellationToken token);
    private static long CopyFixedSizeTreeFromRoot(StorageEnvironment compactedEnv, Action`1<StorageCompactionProgress> progressReport, Transaction txr, TreeIterator rootIterator, string treeName, long copiedTrees, long totalTreesCount, TransactionPersistentContext context, CancellationToken token);
    private static void CopyFixedSizeTree(FixedSizeTree fst, Func`2<Transaction, FixedSizeTree> createDestinationTree, StorageEnvironment compactedEnv, TransactionPersistentContext context, Action`1<long> onEntriesCopiedProgress, Action onAllEntriesCopied, CancellationToken token);
    private static long CopyVariableSizeTree(StorageEnvironment compactedEnv, Action`1<StorageCompactionProgress> progressReport, Transaction txr, string treeName, long copiedTrees, long totalTreesCount, TransactionPersistentContext context, CancellationToken token);
    private static long CopyTableTree(StorageEnvironment compactedEnv, Action`2<string, TableSchema> modifyTableSchema, Action`1<StorageCompactionProgress> progressReport, Transaction txr, string treeName, long copiedTrees, long totalTreesCount, TransactionPersistentContext context, CancellationToken token);
    private static ValueTuple`2<long, int> GetNumberOfEntries(Transaction txr2, string treeName, TableSchema schema);
    private static TableSchema GetTableSchema(Transaction txr, string treeName, Action`2<string, TableSchema> modifyTableSchema);
    private static bool ShouldCloseTxFor32Bit(long transactionSize, StorageEnvironment env);
    private static void ReportIfNeeded(Stopwatch sp, long globalProgress, long globalTotal, long objectProgress, long objectTotal, Action`1<StorageCompactionProgress> progressReport, string message, string treeName);
    private static void Report(long globalProgress, long globalTotal, long objectProgress, long objectTotal, Action`1<StorageCompactionProgress> progressReport, string message, string treeName);
}
public class Voron.Impl.Compaction.StorageCompactionProgress : object {
    public string TreeName;
    public long TreeProgress;
    public long TreeTotal;
    public long GlobalProgress;
    public long GlobalTotal;
    public string Message;
}
public class Voron.Impl.EncryptionBuffersPool : object {
    private object _locker;
    public static EncryptionBuffersPool Instance;
    private static Logger Logger;
    private static int MaxNumberOfPagesToCache;
    private MultipleUseFlag _isLowMemory;
    private MultipleUseFlag _isExtremelyLowMemory;
    private PerCoreContainer`1[] _items;
    private CountingConcurrentStack`1[] _globalStacks;
    private Timer _cleanupTimer;
    private long _generation;
    public bool Disabled;
    private long _currentlyInUseBytes;
    private int _maxNumberOfAllocationsToKeepInGlobalStackPerSlot;
    private Int64[] _numberOfAllocationsDisposedInGlobalStacks;
    private DateTime[] _lastPerCoreCleanups;
    private TimeSpan _perCoreCleanupInterval;
    private DateTime[] _lastGlobalStackRebuilds;
    private TimeSpan _globalStackRebuildInterval;
    internal TestingStuff ForTestingPurposes;
    public long Generation { get; }
    public EncryptionBuffersPool(bool registerLowMemory, bool registerCleanup);
    private static EncryptionBuffersPool();
    public long get_Generation();
    public Byte* Get(int numberOfPages, Int64& size, ThreadStats& thread);
    public Byte* Get(CryptoPager pager, int numberOfPages, Int64& size, ThreadStats& thread);
    public void Return(Byte* ptr, long size, ThreadStats allocatingThread, long generation);
    public void Return(CryptoPager pager, Byte* ptr, long size, ThreadStats allocatingThread, long generation);
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    public EncryptionBufferStats GetStats();
    private void Cleanup(object _);
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
internal static void <LowMemory>g__ClearStack|25_0(CountingConcurrentStack`1<NativeAllocation> stack);
}
public class Voron.Impl.EncryptionBufferStats : object {
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AllocationInfo> <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalPoolSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentlyInUseSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalNumberOfItems>k__BackingField;
    public bool Disabled { get; public set; }
    public List`1<AllocationInfo> Details { get; private set; }
    public long TotalPoolSize { get; public set; }
    public long CurrentlyInUseSize { get; public set; }
    public Size CurrentlyInUseSizeHumane { get; }
    public Size TotalPoolSizeHumane { get; }
    public long TotalNumberOfItems { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public List`1<AllocationInfo> get_Details();
    [CompilerGeneratedAttribute]
private void set_Details(List`1<AllocationInfo> value);
    [CompilerGeneratedAttribute]
public long get_TotalPoolSize();
    [CompilerGeneratedAttribute]
public void set_TotalPoolSize(long value);
    [CompilerGeneratedAttribute]
public long get_CurrentlyInUseSize();
    [CompilerGeneratedAttribute]
public void set_CurrentlyInUseSize(long value);
    public Size get_CurrentlyInUseSizeHumane();
    public Size get_TotalPoolSizeHumane();
    [CompilerGeneratedAttribute]
public long get_TotalNumberOfItems();
    [CompilerGeneratedAttribute]
public void set_TotalNumberOfItems(long value);
    public sealed virtual DynamicJsonValue ToJson();
}
[ExtensionAttribute]
public static class Voron.Impl.Extensions.ConcurrentQueueExtensions : object {
    [ExtensionAttribute]
public static T Peek(ConcurrentQueue`1<T> self);
    [ExtensionAttribute]
public static ConcurrentQueue`1<T> Reduce(ConcurrentQueue`1<T> queue, int size);
}
public class Voron.Impl.FileHeaders.FileHeader : ValueType {
    public static int HashOffset;
    public ulong MagicMarker;
    public int Version;
    public long HeaderRevision;
    public long TransactionId;
    public long LastPageNumber;
    public TreeRootHeader Root;
    public JournalInfo Journal;
    public IncrementalBackupInfo IncrementalBackup;
    public int PageSize;
    public ulong Hash;
    private static FileHeader();
    public virtual string ToString();
}
public class Voron.Impl.FileHeaders.GetDataFromHeaderAction`1 : MulticastDelegate {
    public GetDataFromHeaderAction`1(object object, IntPtr method);
    public virtual T Invoke(FileHeader* ptr);
    public virtual IAsyncResult BeginInvoke(FileHeader* ptr, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
public class Voron.Impl.FileHeaders.HeaderAccessor : object {
    private StorageEnvironment _env;
    private ReaderWriterLockSlim _locker;
    private long _revision;
    private FileHeader* _theHeader;
    private Byte* _headerPtr;
    internal static String[] HeaderFileNames;
    public HeaderAccessor(StorageEnvironment env);
    private static HeaderAccessor();
    public bool Initialize();
    public FileHeader CopyHeader();
    public T Get(GetDataFromHeaderAction`1<T> action);
    public void Modify(ModifyHeaderAction modifyAction);
    private void FillInEmptyHeader(FileHeader* header);
    private bool IsEmptyHeader(FileHeader* header);
    public static ulong CalculateFileHeaderHash(FileHeader* header);
    public static bool ValidHash(FileHeader* header);
    public JournalInfo CopyHeaders(BackupZipArchive package, DataCopier copier, StorageEnvironmentOptions envOptions, string basePath);
    public sealed virtual void Dispose();
}
public class Voron.Impl.FileHeaders.ModifyHeaderAction : MulticastDelegate {
    public ModifyHeaderAction(object object, IntPtr method);
    public virtual void Invoke(FileHeader* ptr);
    public virtual IAsyncResult BeginInvoke(FileHeader* ptr, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Voron.Impl.FreeSpace.FreeSpaceHandling : object {
    private static Slice FreeSpaceKey;
    private FreeSpaceHandlingDisabler _disableStatus;
    private FreeSpaceRecursiveCallGuard _guard;
    internal static int NumberOfPagesInSection;
    [CompilerGeneratedAttribute]
private Action`1<long> PageFreed;
    private static FreeSpaceHandling();
    public static bool IsFreeSpaceTreeName(string name);
    [CompilerGeneratedAttribute]
public void add_PageFreed(Action`1<long> value);
    [CompilerGeneratedAttribute]
public void remove_PageFreed(Action`1<long> value);
    public sealed virtual Nullable`1<long> TryAllocateFromFreeSpace(LowLevelTransaction tx, int num);
    private Nullable`1<long> TryFindLargeValue(LowLevelTransaction tx, FixedSizeTree freeSpaceTree, IFixedSizeIterator<long> it, int num);
    private Nullable`1<long> TryFindSmallValue(LowLevelTransaction tx, FixedSizeTree freeSpaceTree, IFixedSizeIterator<long> it, int num);
    private bool TryFindContinuousRange(LowLevelTransaction tx, FixedSizeTree freeSpaceTree, IFixedSizeIterator<long> it, int num, StreamBitArray current, long currentSectionId, Nullable`1& page);
    private static bool TryFindSmallValueMergingTwoSections(LowLevelTransaction tx, FixedSizeTree freeSpacetree, long currentSectionId, int num, StreamBitArray current, Nullable`1& result);
    public sealed virtual List`1<long> AllPages(LowLevelTransaction tx);
    public sealed virtual void FreePage(LowLevelTransaction tx, long pageNumber);
    public sealed virtual long GetFreePagesOverhead(LowLevelTransaction tx);
    [IteratorStateMachineAttribute("Voron.Impl.FreeSpace.FreeSpaceHandling/<GetFreePagesOverheadPages>d__19")]
public sealed virtual IEnumerable`1<long> GetFreePagesOverheadPages(LowLevelTransaction tx);
    public sealed virtual FreeSpaceHandlingDisabler Disable();
    private static FixedSizeTree GetFreeSpaceTree(LowLevelTransaction tx);
}
public class Voron.Impl.FreeSpace.FreeSpaceHandlingDisabler : object {
    public int DisableCount;
    public sealed virtual void Dispose();
}
public class Voron.Impl.FreeSpace.FreeSpaceRecursiveCallGuard : object {
    private FreeSpaceHandling _freeSpaceHandling;
    public bool IsProcessingFixedSizeTree;
    private LowLevelTransaction _tx;
    public List`1<long> PagesFreed;
    public FreeSpaceRecursiveCallGuard(FreeSpaceHandling freeSpaceHandling);
    public IDisposable Enter(LowLevelTransaction tx);
    public sealed virtual void Dispose();
}
public interface Voron.Impl.FreeSpace.IFreeSpaceHandling {
    public abstract virtual Nullable`1<long> TryAllocateFromFreeSpace(LowLevelTransaction tx, int num);
    public abstract virtual List`1<long> AllPages(LowLevelTransaction tx);
    public abstract virtual void FreePage(LowLevelTransaction tx, long pageNumber);
    public abstract virtual long GetFreePagesOverhead(LowLevelTransaction tx);
    public abstract virtual IEnumerable`1<long> GetFreePagesOverheadPages(LowLevelTransaction tx);
    public abstract virtual FreeSpaceHandlingDisabler Disable();
}
[DefaultMemberAttribute("Item")]
public class Voron.Impl.FreeSpace.StreamBitArray : object {
    private Int32[] _inner;
    [CompilerGeneratedAttribute]
private int <SetCount>k__BackingField;
    private static Int32[] MultiplyDeBruijnBitPosition;
    public int SetCount { get; private set; }
    public bool Item { get; public set; }
    public StreamBitArray(ValueReader reader);
    private static StreamBitArray();
    [CompilerGeneratedAttribute]
public int get_SetCount();
    [CompilerGeneratedAttribute]
private void set_SetCount(int value);
    public int FirstSetBit();
    private static int HighestBitSet(int v);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public bool Get(int index);
    public void Set(int index, bool value);
    public int GetEndRangeCount();
    public bool HasStartRangeCount(int max);
    public Stream ToStream();
    private Byte[] ToBuffer();
    public InternalScope<ByteStringMemoryCache> ToSlice(ByteStringContext context, Slice& str);
    public InternalScope<ByteStringMemoryCache> ToSlice(ByteStringContext context, ByteStringType type, Slice& str);
}
public interface Voron.Impl.IPagerLevelTransactionState {
    public Dictionary`2<AbstractPager, TransactionState> PagerTransactionState32Bits { get; public set; }
    public Dictionary`2<AbstractPager, CryptoTransactionState> CryptoPagerTransactionState { get; public set; }
    public Size AdditionalMemoryUsageSize { get; }
    public StorageEnvironment Environment { get; }
    public bool IsWriteTransaction { get; }
    public abstract virtual Dictionary`2<AbstractPager, TransactionState> get_PagerTransactionState32Bits();
    public abstract virtual void set_PagerTransactionState32Bits(Dictionary`2<AbstractPager, TransactionState> value);
    public abstract virtual Dictionary`2<AbstractPager, CryptoTransactionState> get_CryptoPagerTransactionState();
    public abstract virtual void set_CryptoPagerTransactionState(Dictionary`2<AbstractPager, CryptoTransactionState> value);
    public abstract virtual Size get_AdditionalMemoryUsageSize();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnDispose(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnDispose(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeCommitFinalization(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeCommitFinalization(Action`1<IPagerLevelTransactionState> value);
    public abstract virtual void EnsurePagerStateReference(PagerState& state);
    public abstract virtual StorageEnvironment get_Environment();
    public abstract virtual bool get_IsWriteTransaction();
}
public class Voron.Impl.Journal.CompressedPagesResult : ValueType {
    public Byte* Base;
    public int NumberOf4Kbs;
    public int NumberOfUncompressedPages;
    public Nullable`1<UpdatePageTranslationTableAndUnusedPagesAction> UpdatePageTranslationTableAndUnusedPages;
}
public interface Voron.Impl.Journal.IJournalCompressionBufferCryptoHandler {
    public abstract virtual void ZeroCompressionBuffer(IPagerLevelTransactionState tx);
}
public interface Voron.Impl.Journal.IJournalWriter {
    public int NumberOfAllocated4Kb { get; }
    public bool Disposed { get; }
    public bool DeleteOnClose { get; public set; }
    public VoronPathSetting FileName { get; }
    public abstract virtual void Write(long posBy4Kb, Byte* p, int numberOf4Kb);
    public abstract virtual int get_NumberOfAllocated4Kb();
    public abstract virtual bool get_Disposed();
    public abstract virtual bool get_DeleteOnClose();
    public abstract virtual void set_DeleteOnClose(bool value);
    public abstract virtual AbstractPager CreatePager();
    public abstract virtual void Read(Byte* buffer, long numOfBytes, long offsetInFile);
    public abstract virtual void Truncate(long size);
    public abstract virtual void AddRef();
    public abstract virtual bool Release();
    public abstract virtual VoronPathSetting get_FileName();
}
public class Voron.Impl.Journal.JournalFile : object {
    private StorageEnvironment _env;
    private IJournalWriter _journalWriter;
    private long _writePosIn4Kb;
    internal List`1<TransactionHeader> _transactionHeaders;
    private PageTable _pageTranslationTable;
    private HashSet`1<PagePosition> _unusedPagesHashSetPool;
    private FastList`1<PagePosition> _unusedPages;
    private ContentionLoggingLocker _locker2;
    private Logger _logger;
    [CompilerGeneratedAttribute]
private long <Number>k__BackingField;
    private static ObjectPool`2<FastList`1<PagePosition>, ResetBehavior<PagePosition>> _scratchPagesPositionsPool;
    internal long WritePosIn4KbPosition { get; }
    public long Number { get; }
    public long Available4Kbs { get; }
    public Size JournalSize { get; }
    internal IJournalWriter JournalWriter { get; }
    public PageTable PageTranslationTable { get; }
    unknown bool DeleteOnClose {public set; }
    public JournalFile(StorageEnvironment env, IJournalWriter journalWriter, long journalNumber);
    private static JournalFile();
    public virtual string ToString();
    internal long get_WritePosIn4KbPosition();
    [CompilerGeneratedAttribute]
public long get_Number();
    public long get_Available4Kbs();
    public Size get_JournalSize();
    internal IJournalWriter get_JournalWriter();
    public PageTable get_PageTranslationTable();
    public void Release();
    public void AddRef();
    public sealed virtual void Dispose();
    public JournalSnapshot GetSnapshot();
    public void SetLastReadTxHeader(long maxTransactionId, TransactionHeader& lastReadTxHeader);
    public void Write(long posBy4Kb, Byte* p, int numberOf4Kbs);
    private static void MathFailure(int numberOf4Kbs);
    public UpdatePageTranslationTableAndUnusedPagesAction Write(LowLevelTransaction tx, CompressedPagesResult pages);
    private void UpdatePageTranslationTable(LowLevelTransaction tx, HashSet`1<PagePosition> unused, Dictionary`2<long, PagePosition> ptt);
    public void InitFrom(JournalReader journalReader, List`1<TransactionHeader> transactionHeaders);
    public void set_DeleteOnClose(bool value);
    public void FreeScratchPagesOlderThan(LowLevelTransaction tx, long lastSyncedTransactionId);
}
public class Voron.Impl.Journal.JournalInfo : ValueType {
    public static int NumberOfReservedBytes;
    public long CurrentJournal;
    public long LastSyncedJournal;
    public long LastSyncedTransactionId;
    [FixedBufferAttribute("System.Byte", "3")]
public <Reserved>e__FixedBuffer Reserved;
    public JournalInfoFlags Flags;
}
[FlagsAttribute]
public enum Voron.Impl.Journal.JournalInfoFlags : Enum {
    public byte value__;
    public static JournalInfoFlags None;
    public static JournalInfoFlags IgnoreMissingLastSyncJournal;
}
public class Voron.Impl.Journal.JournalReader : object {
    private AbstractPager _journalPager;
    private AbstractPager _dataPager;
    private AbstractPager _recoveryPager;
    private HashSet`1<long> _modifiedPages;
    private JournalInfo _journalInfo;
    private FileHeader _currentFileHeader;
    private long _readAt4Kb;
    private DiffApplier _diffApplier;
    private long _journalPagerNumberOfAllocated4Kb;
    private List`1<EncryptionBuffer> _encryptionBuffers;
    private TransactionHeader* _firstValidTransactionHeader;
    private Nullable`1<long> _firstSkippedTx;
    private Nullable`1<long> _lastSkippedTx;
    private bool _skippedLastTx;
    [CompilerGeneratedAttribute]
private bool <RequireHeaderUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionHeader* <LastTransactionHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<AbstractPager, TransactionState> <Voron.Impl.IPagerLevelTransactionState.PagerTransactionState32Bits>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<AbstractPager, CryptoTransactionState> <Voron.Impl.IPagerLevelTransactionState.CryptoPagerTransactionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IPagerLevelTransactionState> OnDispose;
    [CompilerGeneratedAttribute]
private Action`1<IPagerLevelTransactionState> BeforeCommitFinalization;
    public bool RequireHeaderUpdate { get; private set; }
    public long Next4Kb { get; }
    public TransactionHeader* LastTransactionHeader { get; private set; }
    private Dictionary`2<AbstractPager, TransactionState> Voron.Impl.IPagerLevelTransactionState.PagerTransactionState32Bits { get; private set; }
    private Dictionary`2<AbstractPager, CryptoTransactionState> Voron.Impl.IPagerLevelTransactionState.CryptoPagerTransactionState { get; private set; }
    public Size AdditionalMemoryUsageSize { get; }
    private StorageEnvironment Voron.Impl.IPagerLevelTransactionState.Environment { get; }
    private bool Voron.Impl.IPagerLevelTransactionState.IsWriteTransaction { get; }
    public JournalReader(AbstractPager journalPager, AbstractPager dataPager, AbstractPager recoveryPager, HashSet`1<long> modifiedPages, JournalInfo journalInfo, FileHeader currentFileHeader, TransactionHeader* previous);
    [CompilerGeneratedAttribute]
public bool get_RequireHeaderUpdate();
    [CompilerGeneratedAttribute]
private void set_RequireHeaderUpdate(bool value);
    public long get_Next4Kb();
    [CompilerGeneratedAttribute]
public TransactionHeader* get_LastTransactionHeader();
    [CompilerGeneratedAttribute]
private void set_LastTransactionHeader(TransactionHeader* value);
    public bool ReadOneTransactionToDataFile(StorageEnvironmentOptions options);
    private void SkipCurrentTransaction(TransactionHeader* current);
    private bool IsAlreadySyncTransaction(TransactionHeader* current);
    private static long GetTransactionSizeIn4Kb(TransactionHeader* current);
    [DoesNotReturnAttribute]
private void ThrowInvalidChecksumOnPageFromJournal(long pageNumber, TransactionHeader* current, ulong expectedChecksum, ulong checksum, PageHeader* pageHeader);
    public List`1<TransactionHeader> RecoverAndValidate(StorageEnvironmentOptions options);
    public void ZeroRecoveryBufferIfNeeded(IPagerLevelTransactionState tx, StorageEnvironmentOptions options);
    private void DecryptTransaction(Byte* page, StorageEnvironmentOptions options);
    private bool TryReadAndValidateHeader(StorageEnvironmentOptions options, ReadExpectation readExpectation, TransactionHeader*& current);
    private bool CanIgnoreDataIntegrityErrorBecauseTxWasSynced(TransactionHeader* currentTx, StorageEnvironmentOptions options);
    private bool IsOldTransactionFromRecycledJournal(TransactionHeader* currentTx);
    private TransactionHeader* EnsureTransactionMapped(TransactionHeader* current, long pageNumber, long positionInsidePage);
    private bool ValidatePagesHash(StorageEnvironmentOptions options, TransactionHeader* current);
    public virtual string ToString();
    public sealed virtual void Dispose();
    private static int GetNumberOfPagesFor(long size);
    private static long GetNumberOf4KbFor(long size);
    [CompilerGeneratedAttribute]
private sealed virtual override Dictionary`2<AbstractPager, TransactionState> Voron.Impl.IPagerLevelTransactionState.get_PagerTransactionState32Bits();
    [CompilerGeneratedAttribute]
private sealed virtual override void Voron.Impl.IPagerLevelTransactionState.set_PagerTransactionState32Bits(Dictionary`2<AbstractPager, TransactionState> value);
    [CompilerGeneratedAttribute]
private sealed virtual override Dictionary`2<AbstractPager, CryptoTransactionState> Voron.Impl.IPagerLevelTransactionState.get_CryptoPagerTransactionState();
    [CompilerGeneratedAttribute]
private sealed virtual override void Voron.Impl.IPagerLevelTransactionState.set_CryptoPagerTransactionState(Dictionary`2<AbstractPager, CryptoTransactionState> value);
    public sealed virtual Size get_AdditionalMemoryUsageSize();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnDispose(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnDispose(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeCommitFinalization(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeCommitFinalization(Action`1<IPagerLevelTransactionState> value);
    private sealed virtual override void Voron.Impl.IPagerLevelTransactionState.EnsurePagerStateReference(PagerState& state);
    private sealed virtual override StorageEnvironment Voron.Impl.IPagerLevelTransactionState.get_Environment();
    private sealed virtual override bool Voron.Impl.IPagerLevelTransactionState.get_IsWriteTransaction();
    private string AddSkipTxInfoDetails();
    [CompilerGeneratedAttribute]
private void <TryReadAndValidateHeader>g__AssertValidLastPageNumber|34_0(TransactionHeader* transactionHeader, <>c__DisplayClass34_0& );
}
public class Voron.Impl.Journal.JournalSnapshot : object {
    public long Number;
    public PageTable PageTranslationTable;
    public long Available4Kbs;
    public long LastTransaction;
    public JournalFile FileInstance;
    public long WritePosIn4KbPosition;
    public sealed virtual int CompareTo(JournalSnapshot other);
}
public class Voron.Impl.Journal.JournalWriter : object {
    private static int ERROR_WORKING_SET_QUOTA;
    private SingleUseFlag _disposed;
    private StorageEnvironmentOptions _options;
    private SafeJournalHandle _writeHandle;
    private Logger _log;
    private SafeJournalHandle _readHandle;
    private int _refs;
    private bool _workingSetQuotaLogged;
    [CompilerGeneratedAttribute]
private int <NumberOfAllocated4Kb>k__BackingField;
    [CompilerGeneratedAttribute]
private VoronPathSetting <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteOnClose>k__BackingField;
    public int NumberOfAllocated4Kb { get; }
    public bool Disposed { get; }
    public VoronPathSetting FileName { get; }
    public bool DeleteOnClose { get; public set; }
    public JournalWriter(StorageEnvironmentOptions options, VoronPathSetting filename, long size, JournalMode mode);
    [CompilerGeneratedAttribute]
public sealed virtual int get_NumberOfAllocated4Kb();
    public sealed virtual bool get_Disposed();
    [CompilerGeneratedAttribute]
public sealed virtual VoronPathSetting get_FileName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DeleteOnClose();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DeleteOnClose(bool value);
    public sealed virtual void Write(long posBy4Kb, Byte* p, int numberOf4Kb);
    public sealed virtual AbstractPager CreatePager();
    public sealed virtual void Read(Byte* buffer, long numOfBytes, long offsetInFile);
    public sealed virtual void Truncate(long size);
    public sealed virtual void AddRef();
    public sealed virtual bool Release();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
private void <Read>g__EnsureValidResult|23_0(<>c__DisplayClass23_0& );
}
public class Voron.Impl.Journal.RecoveryOverflowDetector : object {
    private long _minPageChecked;
    private long _minPageOverlappedByAnotherPage;
    public bool IsOverlappingAnotherPage(long pageNumber, int numberOfPages);
    public void SetPageChecked(long pageNumber);
}
public class Voron.Impl.Journal.TransactionHeader : ValueType {
    public static int SizeOf;
    public static int NonceOffset;
    public static int MacOffset;
    public static int NonceSize;
    public ulong HeaderMarker;
    public long TransactionId;
    public long NextPageNumber;
    public long LastPageNumber;
    public int PageCount;
    public TransactionPersistenceModeFlags Flags;
    public ulong Hash;
    public TreeRootHeader Root;
    public TransactionMarker TxMarker;
    public bool Reserved2;
    public long CompressedSize;
    public long UncompressedSize;
    public long TimeStampTicksUtc;
    [FixedBufferAttribute("System.Byte", "16")]
public <Reserved>e__FixedBuffer Reserved;
    [FixedBufferAttribute("System.Byte", "24")]
public <Nonce>e__FixedBuffer Nonce;
    [FixedBufferAttribute("System.Byte", "16")]
public <Mac>e__FixedBuffer Mac;
    private static TransactionHeader();
    public virtual string ToString();
}
public class Voron.Impl.Journal.TransactionHeaderPageInfo : ValueType {
    public long PageNumber;
    public long Size;
    public bool IsNewDiff;
    public long DiffSize;
}
[FlagsAttribute]
public enum Voron.Impl.Journal.TransactionMarker : Enum {
    public byte value__;
    public static TransactionMarker None;
    public static TransactionMarker Commit;
}
public class Voron.Impl.Journal.WriteAheadJournal : object {
    private StorageEnvironment _env;
    private AbstractPager _dataPager;
    private long _currentJournalFileSize;
    private DateTime _lastFile;
    private long _journalIndex;
    private JournalApplicator _journalApplicator;
    private ImmutableAppendOnlyList`1<JournalFile> _files;
    internal JournalFile CurrentFile;
    private HeaderAccessor _headerAccessor;
    private AbstractPager _compressionPager;
    private long _compressionPagerCounter;
    private DiffPages _diffPage;
    private Logger _logger;
    private List`1<JournalSnapshot> _snapshotCache;
    private object _writeLock;
    private int _maxNumberOfPagesRequiredForCompressionBuffer;
    internal ThreadStats CurrentFlushingInProgressHolder;
    private DisposeOnce`1<SingleAttempt> _disposeRunner;
    private static int _pagesIn1Mb;
    internal static Byte[] Context;
    private DateTime _lastCompressionBufferReduceCheck;
    private CompressionAccelerationStats _lastCompressionAccelerationInfo;
    private bool _is32Bit;
    private TestingStuff _forTestingPurposes;
    public ImmutableAppendOnlyList`1<JournalFile> Files { get; }
    public JournalApplicator Applicator { get; }
    public WriteAheadJournal(StorageEnvironment env);
    private static WriteAheadJournal();
    public ImmutableAppendOnlyList`1<JournalFile> get_Files();
    public JournalApplicator get_Applicator();
    private JournalFile NextFile(int numberOf4Kbs);
    public bool RecoverDatabase(TransactionHeader* txHeader, Action`2<LogMode, string> addToInitLog);
    private void CleanupNewerInvalidJournalFiles(long lastSyncedJournal);
    private void RecoverCurrentJournalSize(AbstractPager pager, Boolean& isMoreThanMaxFileSize);
    public Nullable`1<Page> ReadPage(LowLevelTransaction tx, long pageNumber, Dictionary`2<int, PagerState> scratchPagerStates);
    public Nullable`1<T> ReadPageHeaderForDebug(LowLevelTransaction tx, long pageNumber, Dictionary`2<int, PagerState> scratchPagerStates);
    public bool PageExists(LowLevelTransaction tx, long pageNumber);
    public sealed virtual void Dispose();
    public JournalInfo GetCurrentJournalInfo();
    public List`1<JournalSnapshot> GetSnapshots();
    public void UpdateCacheForJournalSnapshots();
    [ConditionalAttribute("DEBUG")]
private static void ValidateNoDuplicateJournals(List`1<JournalSnapshot> items);
    public CompressedPagesResult WriteToJournal(LowLevelTransaction tx);
    private CompressedPagesResult PrepareToWriteToJournal(LowLevelTransaction tx, IPagerLevelTransactionState tempEncCompressionPagerTxState);
    private static int AdjustPagesRequiredFor32Bits(int pagesRequired);
    private void EncryptTransaction(Byte* fullTxBuffer);
    public void TruncateJournal();
    private AbstractPager CreateCompressionPager(long initialSize);
    private void ReduceSizeOfCompressionBufferIfNeeded(bool forceReduce);
    public sealed virtual void ZeroCompressionBuffer(IPagerLevelTransactionState tx);
    private bool ShouldReduceSizeOfCompressionPager(long maxSize, bool forceReduce);
    public void TryReduceSizeOfCompressionBufferIfNeeded();
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
private void <.ctor>b__18_0();
}
public class Voron.Impl.LowLevelTransaction : object {
    public AbstractPager DataPager;
    private StorageEnvironment _env;
    private long _id;
    private ByteStringContext _allocator;
    internal PageLocator _pageLocator;
    private bool _disposeAllocator;
    internal long DecompressedBufferBytes;
    internal TestingStuff _forTestingPurposes;
    public object ImmutableExternalState;
    private Tree _root;
    public bool FlushedToJournal;
    private long _numberOfModifiedPages;
    private WriteAheadJournal _journal;
    internal List`1<JournalSnapshot> JournalSnapshots;
    [CompilerGeneratedAttribute]
private Dictionary`2<AbstractPager, TransactionState> <Voron.Impl.IPagerLevelTransactionState.PagerTransactionState32Bits>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<AbstractPager, CryptoTransactionState> <Voron.Impl.IPagerLevelTransactionState.CryptoPagerTransactionState>k__BackingField;
    private HashSet`1<long> _dirtyPages;
    private Stack`1<long> _pagesToFreeOnCommit;
    private Dictionary`2<long, PageFromScratchBuffer> _scratchPagesTable;
    private HashSet`1<PagerState> _pagerStates;
    private Dictionary`2<int, PagerState> _scratchPagerStates;
    [CompilerGeneratedAttribute]
private Action`1<IPagerLevelTransactionState> BeforeCommitFinalization;
    [CompilerGeneratedAttribute]
private Action`1<LowLevelTransaction> LastChanceToReadFromWriteTransactionBeforeCommit;
    [CompilerGeneratedAttribute]
private Action`1<IPagerLevelTransactionState> OnDispose;
    [CompilerGeneratedAttribute]
private Action`1<IPagerLevelTransactionState> OnRollBack;
    [CompilerGeneratedAttribute]
private Action`1<LowLevelTransaction> AfterCommitWhenNewTransactionsPrevented;
    private IFreeSpaceHandling _freeSpaceHandling;
    internal FixedSizeTree _freeSpaceTree;
    private TransactionHeader _txHeader;
    private HashSet`1<PageFromScratchBuffer> _transactionPages;
    private HashSet`1<long> _freedPages;
    private List`1<PageFromScratchBuffer> _unusedScratchPages;
    private StorageEnvironmentState _state;
    private CommitStats _requestedCommitStats;
    private Nullable`1<UpdatePageTranslationTableAndUnusedPagesAction> _updatePageTranslationTableAndUnusedPages;
    [CompilerGeneratedAttribute]
private TransactionPersistentContext <PersistentContext>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Committed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RolledBack>k__BackingField;
    private static TransactionHeader TxHeaderInitializerTemplate;
    private static int InvalidScratchFile;
    private PagerStateCacheItem _lastScratchFileUsed;
    private TxState _txState;
    [CompilerGeneratedAttribute]
private ThreadStats <CurrentTransactionHolder>k__BackingField;
    private UnguardedDisposableScope _disposableScope;
    private static ObjectPool`1<CompactKey> _sharedCompactKeyPool;
    internal Task`1<bool> AsyncCommit;
    private LowLevelTransaction _asyncCommitNextTransaction;
    private static Task`1<bool> NoWriteToJournalRequiredTask;
    private PagerState _lastState;
    internal bool FlushInProgressLockTaken;
    internal ImmutableAppendOnlyList`1<JournalFile> JournalFiles;
    internal bool AlreadyAllowedDisposeWithLazyTransactionRunning;
    public DateTime TxStartTime;
    public bool IsCloned;
    internal Nullable`1<long> LocalPossibleOldestReadTransaction;
    internal Node ActiveTransactionNode;
    public Transaction Transaction;
    public Tree RootObjects { get; }
    public long NumberOfModifiedPages { get; }
    private bool Voron.Impl.IPagerLevelTransactionState.IsWriteTransaction { get; }
    private Dictionary`2<AbstractPager, TransactionState> Voron.Impl.IPagerLevelTransactionState.PagerTransactionState32Bits { get; private set; }
    private Dictionary`2<AbstractPager, CryptoTransactionState> Voron.Impl.IPagerLevelTransactionState.CryptoPagerTransactionState { get; private set; }
    public Size TransactionSize { get; }
    public Size AdditionalMemoryUsageSize { get; }
    internal TransactionHeader& TransactionHeader { get; }
    public TransactionPersistentContext PersistentContext { get; }
    public TransactionFlags Flags { get; }
    public StorageEnvironment Environment { get; }
    public long Id { get; }
    public bool Committed { get; private set; }
    public bool RolledBack { get; private set; }
    public StorageEnvironmentState State { get; }
    public ByteStringContext Allocator { get; }
    public ulong Hash { get; }
    public bool IsValid { get; }
    public bool IsDisposed { get; }
    public ThreadStats CurrentTransactionHolder { get; public set; }
    public PageLocator PageLocator { get; }
    public LowLevelTransaction(LowLevelTransaction previous, TransactionPersistentContext transactionPersistentContext, ByteStringContext allocator);
    private LowLevelTransaction(LowLevelTransaction previous, TransactionPersistentContext persistentContext, long txId);
    public LowLevelTransaction(StorageEnvironment env, long id, TransactionPersistentContext transactionPersistentContext, TransactionFlags flags, IFreeSpaceHandling freeSpaceHandling, ByteStringContext context);
    private static LowLevelTransaction();
    public Tree get_RootObjects();
    public long get_NumberOfModifiedPages();
    private sealed virtual override bool Voron.Impl.IPagerLevelTransactionState.get_IsWriteTransaction();
    [CompilerGeneratedAttribute]
private sealed virtual override Dictionary`2<AbstractPager, TransactionState> Voron.Impl.IPagerLevelTransactionState.get_PagerTransactionState32Bits();
    [CompilerGeneratedAttribute]
private sealed virtual override void Voron.Impl.IPagerLevelTransactionState.set_PagerTransactionState32Bits(Dictionary`2<AbstractPager, TransactionState> value);
    [CompilerGeneratedAttribute]
private sealed virtual override Dictionary`2<AbstractPager, CryptoTransactionState> Voron.Impl.IPagerLevelTransactionState.get_CryptoPagerTransactionState();
    [CompilerGeneratedAttribute]
private sealed virtual override void Voron.Impl.IPagerLevelTransactionState.set_CryptoPagerTransactionState(Dictionary`2<AbstractPager, CryptoTransactionState> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeCommitFinalization(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeCommitFinalization(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public void add_LastChanceToReadFromWriteTransactionBeforeCommit(Action`1<LowLevelTransaction> value);
    [CompilerGeneratedAttribute]
public void remove_LastChanceToReadFromWriteTransactionBeforeCommit(Action`1<LowLevelTransaction> value);
    public Size get_TransactionSize();
    public sealed virtual Size get_AdditionalMemoryUsageSize();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnDispose(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnDispose(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public void add_OnRollBack(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public void remove_OnRollBack(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public void add_AfterCommitWhenNewTransactionsPrevented(Action`1<LowLevelTransaction> value);
    [CompilerGeneratedAttribute]
public void remove_AfterCommitWhenNewTransactionsPrevented(Action`1<LowLevelTransaction> value);
    internal TransactionHeader& get_TransactionHeader();
    [CompilerGeneratedAttribute]
public TransactionPersistentContext get_PersistentContext();
    [CompilerGeneratedAttribute]
public TransactionFlags get_Flags();
    public sealed virtual StorageEnvironment get_Environment();
    public long get_Id();
    [CompilerGeneratedAttribute]
public bool get_Committed();
    [CompilerGeneratedAttribute]
private void set_Committed(bool value);
    [CompilerGeneratedAttribute]
public bool get_RolledBack();
    [CompilerGeneratedAttribute]
private void set_RolledBack(bool value);
    public StorageEnvironmentState get_State();
    public ByteStringContext get_Allocator();
    public ulong get_Hash();
    private void CopyPagerStatesFromPreviousTx(LowLevelTransaction previous);
    [ConditionalAttribute("DEBUG")]
private void EnsureNoDuplicateTransactionId(long id);
    internal void EnsureNoDuplicateTransactionId_Forced(long id);
    internal void UpdateRootsIfNeeded(Tree root);
    private void InitializeRoots();
    private void InitTransactionHeader();
    internal HashSet`1<PageFromScratchBuffer> GetTransactionPages();
    internal List`1<PageFromScratchBuffer> GetUnusedScratchPages();
    internal HashSet`1<long> GetFreedPagesNumbers();
    internal Page ModifyPage(long num);
    private Page ModifyPageInternal(long num);
    [ConditionalAttribute("DEBUG")]
private void ZeroPageHeaderChecksumToEnsureNoUseOfCryptoReservedSpace(Byte* page);
    public Page GetPage(long pageNumber);
    public Page GetPageWithoutCache(long pageNumber);
    private Page GetPageInternal(long pageNumber);
    public T GetPageHeaderForDebug(long pageNumber);
    public void TryReleasePage(long pageNumber);
    private void ThrowObjectDisposed();
    public Page AllocatePage(int numberOfPages, Nullable`1<long> pageNumber, Nullable`1<Page> previousPage, bool zeroPage);
    [ConditionalAttribute("DEBUG")]
private void EnsureNotCurrentlyHoldingRootObjectsOpen();
    public Page AllocateOverflowRawPage(long overflowSize, Int32& numberOfPages, Nullable`1<long> pageNumber, Nullable`1<Page> previousPage, bool zeroPage);
    private Page AllocatePage(int numberOfPages, long pageNumber, Nullable`1<Page> previousVersion, bool zeroPage);
    [DoesNotReturnAttribute]
private void ThrowQuotaExceededException(long pageNumber, Nullable`1<long> maxAvailablePageNumber);
    internal void BreakLargeAllocationToSeparatePages(long pageNumber);
    internal void ShrinkOverflowPage(long pageNumber, int newSize, TreeMutableState treeState);
    [ConditionalAttribute("DEBUG")]
public void VerifyNoDuplicateScratchPages();
    public bool get_IsValid();
    public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
public ThreadStats get_CurrentTransactionHolder();
    [CompilerGeneratedAttribute]
public void set_CurrentTransactionHolder(ThreadStats value);
    public PageLocator get_PageLocator();
    internal void RegisterDisposable(T disposable);
    public sealed virtual void Dispose();
    public void MarkTransactionAsFailed();
    internal void FreePageOnCommit(long pageNumber);
    internal void DiscardScratchModificationOn(long pageNumber);
    public void FreePage(long pageNumber);
    public CompactKey AcquireCompactKey();
    public void ReleaseCompactKey(CompactKey& key);
    internal void PrepareForCommit();
    public void Commit();
    public LowLevelTransaction BeginAsyncCommitAndStartNewTransaction(TransactionPersistentContext persistentContext);
    [DoesNotReturnAttribute]
private static void ThrowAsyncCommitAlreadyCalled();
    [DoesNotReturnAttribute]
private static void ThrowReadTransactionCannotDoAsyncCommit();
    public void EndAsyncCommit();
    [DoesNotReturnAttribute]
private static void ThrowInvalidAsyncEndWithoutBegin();
    private bool WriteToJournalIsRequired();
    private void CommitStage2_WriteToJournal();
    private void CommitStage1_CompleteTransaction();
    [DoesNotReturnAttribute]
private static void ThrowNextPageNumberCannotBeSmallerOrEqualThanOne(string caller);
    private void CommitStage3_DisposeTransactionResources();
    [DoesNotReturnAttribute]
private static void ThrowAlreadyRolledBack();
    [DoesNotReturnAttribute]
private static void ThrowAlreadyCommitted();
    [ConditionalAttribute("DEBUG")]
private void EnsureDisposeOfWriteTxIsOnTheSameThreadThatCreatedIt();
    public void Rollback();
    public void RetrieveCommitStats(CommitStats& stats);
    public string GetTxState();
    public sealed virtual void EnsurePagerStateReference(PagerState& state);
    internal void OnAfterCommitWhenNewTransactionsPrevented();
    [ConditionalAttribute("DEBUG")]
private void ValidateOverflowPagesRemoval();
    [ConditionalAttribute("DEBUG")]
private void TrackOverflowPageRemoval(long pageId);
    [ConditionalAttribute("VALIDATE_PAGES")]
private void ValidateAllPages();
    [ConditionalAttribute("VALIDATE_PAGES")]
private void ValidateReadOnlyPages();
    [ConditionalAttribute("VALIDATE_PAGES")]
private void TrackWritablePage(Page page);
    [ConditionalAttribute("VALIDATE_PAGES")]
private void TrackReadOnlyPage(Page page);
    [ConditionalAttribute("VALIDATE_PAGES")]
private void UntrackPage(long pageNumber);
    [ConditionalAttribute("VALIDATE_PAGES")]
private void TrackDirtyPage(long page);
    [ConditionalAttribute("VALIDATE_PAGES")]
private void UntrackDirtyPage(long page);
    internal TestingStuff ForTestingPurposesOnly();
    internal PersistentDictionary GetEncodingDictionary(long dictionaryId);
    public InternalScope<ByteStringMemoryCache> GetTempPage(int pageSize, TreePage& page);
    public bool IsDirty(long p);
    [CompilerGeneratedAttribute]
private bool <BeginAsyncCommitAndStartNewTransaction>b__148_0();
}
public class Voron.Impl.PagePosition : object {
    public long TransactionId;
    public long JournalNumber;
    public long ScratchPage;
    public int ScratchNumber;
    public bool IsFreedPageMarker;
    public bool UnusedInPTT;
    public PagePosition(long scratchPos, long transactionId, long journalNumber, int scratchNumber, bool isFreedPageMarker);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Voron.Impl.PagePositionEqualityComparer : object {
    public static PagePositionEqualityComparer Instance;
    private static PagePositionEqualityComparer();
    public sealed virtual bool Equals(PagePosition x, PagePosition y);
    public sealed virtual int GetHashCode(PagePosition obj);
}
[ExtensionAttribute]
public static class Voron.Impl.PagerLevelTransactionState : object {
    [ExtensionAttribute]
public static Size GetTotal32BitsMappedSize(IPagerLevelTransactionState self);
}
public class Voron.Impl.PagerState : object {
    private AbstractPager _pager;
    public bool DisposeFileOnDispose;
    private static byte EvenPrefetchCountMask;
    private static byte EvenPrefetchMaskShift;
    private static byte OddPrefetchCountMask;
    private static byte AlreadyPrefetch;
    private int _prefetchSegmentSize;
    private int _prefetchResetThreshold;
    private int _segmentShift;
    private int _refreshCounter;
    private Byte[] _prefetchTable;
    private int _refs;
    public MemoryMappedFile File;
    public AllocationInfo[] AllocationInfos;
    public bool DiscardOnTxCopy;
    public Byte* MapBase;
    internal bool _released;
    public AbstractPager CurrentPager { get; }
    public PagerState(AbstractPager pager, long prefetchSegmentSize, long prefetchResetThreshold, AllocationInfo allocationInfo);
    public void Release();
    private void ReleaseInternal();
    public void AddRef();
    [DoesNotReturnAttribute]
internal void ThrowInvalidPagerState();
    [ConditionalAttribute("VALIDATE")]
public void DebugVerify(long size);
    public AbstractPager get_CurrentPager();
    private int GetSegmentState(long segment);
    private void SetSegmentState(long segment, int state);
    public bool ShouldPrefetchSegment(long pageNumber, Void*& virtualAddress, Int64& sizeInBytes);
    public void CheckResetPrefetchTable();
    public void CopyPrefetchState(PagerState olderInstance);
    public void DiscardDataOnDisk();
}
public abstract class Voron.Impl.Paging.AbstractPager : object {
    public Logger Log;
    private StorageEnvironmentOptions _options;
    public static ConcurrentDictionary`2<string, UInt32> PhysicalDrivePerMountCache;
    protected static object WorkingSetIncreaseLocker;
    private long _increaseSize;
    private DateTime _lastIncrease;
    private object _pagerStateModificationLocker;
    public bool UsePageProtection;
    private MultipleUseFlag _lowMemoryFlag;
    protected bool CanPrefetchAhead;
    public Action`1<PagerState> PagerStateChanged;
    public Func`1<long> AllocatedInBytesFunc;
    private string _debugInfo;
    public static int PageMaxSpace;
    [CompilerGeneratedAttribute]
private VoronPathSetting <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageMinSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteOnClose>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NodeMaxSize>k__BackingField;
    public static int RequiredSpaceForNewNode;
    protected PagerState _pagerState;
    [CompilerGeneratedAttribute]
private long <NumberOfAllocatedPages>k__BackingField;
    public UInt32 UniquePhysicalDriveId;
    protected DisposeOnce`1<SingleAttempt> DisposeOnceRunner;
    public bool LockMemory;
    public bool DoNotConsiderMemoryLockFailureAsCatastrophicError;
    private static long IncreaseByPowerOf2Threshold;
    public static int MaxKeySize;
    public Lazy`1<bool> CanPrefetch;
    protected int MinIncreaseSize { get; }
    protected int MaxIncreaseSize { get; }
    public PagerState PagerState { get; }
    public string DebugInfo { get; }
    public VoronPathSetting FileName { get; protected set; }
    public StorageEnvironmentOptions Options { get; }
    public int PageMinSpace { get; private set; }
    public bool DeleteOnClose { get; public set; }
    public int NodeMaxSize { get; private set; }
    public long NumberOfAllocatedPages { get; protected set; }
    public long TotalAllocationSize { get; }
    public bool Disposed { get; }
    protected AbstractPager(StorageEnvironmentOptions options, bool canPrefetchAhead, bool usePageProtection);
    private static AbstractPager();
    protected int get_MinIncreaseSize();
    protected int get_MaxIncreaseSize();
    public long GetAllocatedInBytes();
    public void SetPagerState(PagerState newState);
    protected void Lock(Byte* address, long sizeToLock, TransactionState state);
    public virtual bool ShouldLockMemoryAtPagerLevel();
    protected void TryHandleFailureToLockMemory(Byte* addressToLock, long sizeToLock);
    internal PagerState GetPagerStateAndAddRefAtomically();
    public PagerState get_PagerState();
    public string get_DebugInfo();
    [CompilerGeneratedAttribute]
public VoronPathSetting get_FileName();
    [CompilerGeneratedAttribute]
protected void set_FileName(VoronPathSetting value);
    public StorageEnvironmentOptions get_Options();
    [CompilerGeneratedAttribute]
public int get_PageMinSpace();
    [CompilerGeneratedAttribute]
private void set_PageMinSpace(int value);
    [CompilerGeneratedAttribute]
public bool get_DeleteOnClose();
    [CompilerGeneratedAttribute]
public void set_DeleteOnClose(bool value);
    [CompilerGeneratedAttribute]
public int get_NodeMaxSize();
    [CompilerGeneratedAttribute]
private void set_NodeMaxSize(int value);
    [CompilerGeneratedAttribute]
public virtual long get_NumberOfAllocatedPages();
    [CompilerGeneratedAttribute]
protected virtual void set_NumberOfAllocatedPages(long value);
    public abstract virtual long get_TotalAllocationSize();
    protected abstract virtual string GetSourceName();
    private Byte* AcquirePagePointerInternal(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    public virtual Byte* AcquirePagePointer(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    public virtual Byte* AcquirePagePointerForNewPage(IPagerLevelTransactionState tx, long pageNumber, int numberOfPages, PagerState pagerState);
    public virtual T AcquirePagePointerHeaderForDebug(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    public virtual void BreakLargeAllocationToSeparatePages(IPagerLevelTransactionState tx, long valuePositionInScratchBuffer, long actualNumberOfAllocatedScratchPages);
    public abstract virtual void Sync(long totalUnsynced);
    public PagerState EnsureContinuous(long requestedPageNumber, int numberOfPages);
    [ConditionalAttribute("VALIDATE")]
internal virtual void ProtectPageRange(Byte* start, ulong size, bool force);
    [ConditionalAttribute("VALIDATE")]
internal virtual void UnprotectPageRange(Byte* start, ulong size, bool force);
    public bool get_Disposed();
    protected abstract virtual void DisposeInternal();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected internal abstract virtual PagerState AllocateMorePages(long newLength);
    private long GetNewLength(long current, long minRequested);
    private static long GetNearestFileSize(long neededSize);
    public abstract virtual string ToString();
    [DoesNotReturnAttribute]
public void ThrowAlreadyDisposedException();
    [DoesNotReturnAttribute]
protected void ThrowOnInvalidPageNumber(long pageNumber);
    [DoesNotReturnAttribute]
public static void ThrowIncreasingDataFileInCopyOnWriteModeException(string dataFilePath, long requestedSize);
    public virtual void ReleaseAllocationInfo(Byte* baseAddress, long size);
    public static bool IsKeySizeValid(int keySize);
    protected virtual bool CanPrefetchQuery();
    public void MaybePrefetchMemory(long pageNumber, int pagesToPrefetch);
    public void MaybePrefetchMemory(T pagesToPrefetch);
    public virtual void DiscardPages(long pageNumber, int numberOfPages);
    public virtual void DiscardWholeFile();
    public void TryPrefetchingWholeFile();
    public virtual bool EnsureMapped(IPagerLevelTransactionState tx, long page, int numberOfPages);
    public abstract virtual int CopyPage(I4KbBatchWrites destwI4KbBatchWrites, long p, PagerState pagerState);
    protected int CopyPageImpl(I4KbBatchWrites destwI4KbBatchWrites, long p, PagerState pagerState);
    public virtual I4KbBatchWrites BatchWriter();
    public virtual Byte* AcquireRawPagePointer(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    public virtual void TryReleasePage(IPagerLevelTransactionState tx, long page);
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    [CompilerGeneratedAttribute]
private void <.ctor>b__33_0();
}
public class Voron.Impl.Paging.CryptoPager : AbstractPager {
    private static Byte[] Context;
    [CompilerGeneratedAttribute]
private AbstractPager <Inner>k__BackingField;
    private Byte[] _masterKey;
    private static ulong MacLen;
    private EncryptionBuffersPool _encryptionBuffersPool;
    public AbstractPager Inner { get; }
    public long TotalAllocationSize { get; }
    public long NumberOfAllocatedPages { get; }
    public CryptoPager(AbstractPager inner);
    private static CryptoPager();
    [CompilerGeneratedAttribute]
public AbstractPager get_Inner();
    public virtual long get_TotalAllocationSize();
    public virtual long get_NumberOfAllocatedPages();
    protected virtual string GetSourceName();
    public virtual void Sync(long totalUnsynced);
    protected internal virtual PagerState AllocateMorePages(long newLength);
    public virtual string ToString();
    public virtual void ReleaseAllocationInfo(Byte* baseAddress, long size);
    public virtual void DiscardPages(long pageNumber, int numberOfPages);
    public virtual void DiscardWholeFile();
    protected virtual bool CanPrefetchQuery();
    public virtual int CopyPage(I4KbBatchWrites destwI4KbBatchWrites, long p, PagerState pagerState);
    internal virtual void ProtectPageRange(Byte* start, ulong size, bool force);
    internal virtual void UnprotectPageRange(Byte* start, ulong size, bool force);
    public virtual Byte* AcquirePagePointerForNewPage(IPagerLevelTransactionState tx, long pageNumber, int numberOfPages, PagerState pagerState);
    public virtual Byte* AcquirePagePointer(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    public virtual T AcquirePagePointerHeaderForDebug(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    public virtual void TryReleasePage(IPagerLevelTransactionState tx, long page);
    [ConditionalAttribute("DEBUG")]
private void AssertCopyWontExceedPagerFile(int toCopy, long startPageNumberToCopy);
    public virtual void BreakLargeAllocationToSeparatePages(IPagerLevelTransactionState tx, long valuePositionInScratchBuffer, long actualNumberOfAllocatedScratchPages);
    private EncryptionBuffer GetBufferAndAddToTxState(long pageNumber, CryptoTransactionState state, int numberOfPages);
    private CryptoTransactionState GetTransactionState(IPagerLevelTransactionState tx);
    [ConditionalAttribute("DEBUG")]
private void Debug_VerifyDidNotChanged(IPagerLevelTransactionState tx, long pageNumber, EncryptionBuffer buffer);
    private void TxOnCommit(IPagerLevelTransactionState tx);
    private void TxOnDispose(IPagerLevelTransactionState tx);
    internal static bool CanReturnBuffer(EncryptionBuffer buffer);
    internal void ReturnBuffer(EncryptionBuffer buffer);
    private int EncryptPage(PageHeader* page);
    private void DecryptPage(PageHeader* page);
    protected virtual void DisposeInternal();
    public virtual I4KbBatchWrites BatchWriter();
    public virtual Byte* AcquireRawPagePointer(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_0(PagerState state);
}
[DefaultMemberAttribute("Item")]
public class Voron.Impl.Paging.CryptoTransactionState : object {
    private Dictionary`2<long, EncryptionBuffer> _loadedBuffers;
    private long _totalCryptoBufferSize;
    public long TotalCryptoBufferSize { get; }
    public EncryptionBuffer Item { get; public set; }
    public long get_TotalCryptoBufferSize();
    public void SetBuffers(Dictionary`2<long, EncryptionBuffer> loadedBuffers);
    public bool TryGetValue(long pageNumber, EncryptionBuffer& value);
    public bool RemoveBuffer(long pageNumber);
    public EncryptionBuffer get_Item(long index);
    public void set_Item(long index, EncryptionBuffer value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<long, EncryptionBuffer>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Voron.Impl.Paging.EncryptionBuffer : object {
    public static UIntPtr HashSize;
    public static int HashSizeInt;
    public Byte* Pointer;
    public long Size;
    public Nullable`1<long> OriginalSize;
    public long Generation;
    public ThreadStats AllocatingThread;
    public bool SkipOnTxCommit;
    public bool ExcessStorageFromAllocationBreakup;
    public bool Modified;
    public int Usages;
    public bool CanRelease { get; }
    public EncryptionBuffer(EncryptionBuffersPool pool);
    private static EncryptionBuffer();
    public bool get_CanRelease();
    public void AddRef();
    public void ReleaseRef();
}
public interface Voron.Impl.Paging.I4KbBatchWrites {
    public abstract virtual void Write(long posBy4Kbs, int numberOf4Kbs, Byte* source);
}
public class Voron.Impl.Paging.LoadedPage : object {
    public Byte* Pointer;
    public int NumberOfPages;
    public long StartPage;
}
public class Voron.Impl.Paging.MappedAddresses : object {
    public string File;
    public IntPtr Address;
    public long StartPage;
    public long Size;
    public int Usages;
}
public class Voron.Impl.Paging.RvnMemoryMapPager : AbstractPager {
    private long _totalAllocationSize;
    private Logger _logger;
    private SafeMmapHandle _handle;
    public long TotalAllocationSize { get; }
    public RvnMemoryMapPager(StorageEnvironmentOptions options, VoronPathSetting file, Nullable`1<long> initialFileSize, bool canPrefetchAhead, bool usePageProtection, bool deleteOnClose);
    public virtual long get_TotalAllocationSize();
    public virtual int CopyPage(I4KbBatchWrites destwI4KbBatchWrites, long p, PagerState pagerState);
    public virtual string ToString();
    protected virtual string GetSourceName();
    protected virtual bool CanPrefetchQuery();
    public virtual Byte* AcquirePagePointer(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    public virtual void Sync(long totalUnsynced);
    public virtual void ReleaseAllocationInfo(Byte* baseAddress, long size);
    protected virtual void DisposeInternal();
    private long NearestSizeToPageSize(long size);
    protected internal virtual PagerState AllocateMorePages(long newLength);
    internal virtual void ProtectPageRange(Byte* start, ulong size, bool force);
    internal virtual void UnprotectPageRange(Byte* start, ulong size, bool force);
}
public class Voron.Impl.Paging.Simple4KbBatchWrites : object {
    private AbstractPager _abstractPager;
    private PagerState _pagerState;
    public Simple4KbBatchWrites(AbstractPager abstractPager);
    public sealed virtual void Write(long posBy4Kbs, int numberOf4Kbs, Byte* source);
    public sealed virtual void Dispose();
}
public class Voron.Impl.Paging.TempPagerTransaction : object {
    private bool _isWriteTransaction;
    [CompilerGeneratedAttribute]
private Dictionary`2<AbstractPager, TransactionState> <PagerTransactionState32Bits>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<AbstractPager, CryptoTransactionState> <CryptoPagerTransactionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IPagerLevelTransactionState> OnDispose;
    [CompilerGeneratedAttribute]
private Action`1<IPagerLevelTransactionState> BeforeCommitFinalization;
    private bool Voron.Impl.IPagerLevelTransactionState.IsWriteTransaction { get; }
    public Dictionary`2<AbstractPager, TransactionState> PagerTransactionState32Bits { get; public set; }
    public Dictionary`2<AbstractPager, CryptoTransactionState> CryptoPagerTransactionState { get; public set; }
    public Size AdditionalMemoryUsageSize { get; }
    public StorageEnvironment Environment { get; }
    public TempPagerTransaction(bool isWriteTransaction);
    public sealed virtual void Dispose();
    private sealed virtual override bool Voron.Impl.IPagerLevelTransactionState.get_IsWriteTransaction();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<AbstractPager, TransactionState> get_PagerTransactionState32Bits();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PagerTransactionState32Bits(Dictionary`2<AbstractPager, TransactionState> value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<AbstractPager, CryptoTransactionState> get_CryptoPagerTransactionState();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CryptoPagerTransactionState(Dictionary`2<AbstractPager, CryptoTransactionState> value);
    public sealed virtual Size get_AdditionalMemoryUsageSize();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnDispose(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnDispose(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeCommitFinalization(Action`1<IPagerLevelTransactionState> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeCommitFinalization(Action`1<IPagerLevelTransactionState> value);
    public sealed virtual void EnsurePagerStateReference(PagerState& state);
    public sealed virtual StorageEnvironment get_Environment();
}
public class Voron.Impl.Paging.TransactionState : object {
    public Dictionary`2<long, LoadedPage> LoadedPages;
    public List`1<MappedAddresses> AddressesToUnload;
    public long TotalLoadedSize;
}
[ExtensionAttribute]
public static class Voron.Impl.Paging.VirtualPagerLegacyExtensions : object {
    [ExtensionAttribute]
public static Byte* AcquirePagePointerWithOverflowHandling(AbstractPager pager, T tx, long pageNumber, PagerState pagerState);
    [ExtensionAttribute]
public static Byte* AcquirePagePointerWithOverflowHandling(AbstractPager pager, T tx, long pageNumber);
    public static int GetNumberOfOverflowPages(long overflowSize);
    public static int GetNumberOfPages(PageHeader* header);
}
public class Voron.Impl.Paging.Windows32BitsMemoryMapPager : AbstractPager {
    private Win32NativeFileAttributes _fileAttributes;
    private ConcurrentDictionary`2<long, ConcurrentSet`1<MappedAddresses>> _globalMapping;
    private long _totalMapped;
    private int _concurrentTransactions;
    private ReaderWriterLockSlim _globalMemory;
    public static int AllocationGranularity;
    private static int NumberOfPagesInAllocationGranularity;
    private FileInfo _fileInfo;
    private FileStream _fileStream;
    private SafeFileHandle _handle;
    private MemoryMappedFileAccess _memoryMappedFileAccess;
    private NativeFileMapAccessType _mmFileAccessType;
    private long _totalAllocationSize;
    private IntPtr _hFileMappingObject;
    private long _fileStreamLength;
    public long TotalAllocationSize { get; }
    public Windows32BitsMemoryMapPager(StorageEnvironmentOptions options, VoronPathSetting file, Nullable`1<long> initialFileSize, Win32NativeFileAttributes fileAttributes, Win32NativeFileAccess access, bool usePageProtection);
    [DoesNotReturnAttribute]
private static void ThrowNotSupportedOption(string file);
    public virtual long get_TotalAllocationSize();
    private long NearestSizeToAllocationGranularity(long size);
    public virtual bool EnsureMapped(IPagerLevelTransactionState tx, long pageNumber, int numberOfPages);
    public virtual int CopyPage(I4KbBatchWrites destI4KbBatchWrites, long pageNumber, PagerState pagerState);
    public virtual bool ShouldLockMemoryAtPagerLevel();
    private void LockMemory32Bits(Byte* address, long sizeToLock, TransactionState state);
    private void UnlockMemory32Bits(Byte* address, long sizeToUnlock);
    public virtual I4KbBatchWrites BatchWriter();
    public virtual void DiscardPages(long pageNumber, int numberOfPages);
    public virtual void DiscardWholeFile();
    public virtual Byte* AcquirePagePointerForNewPage(IPagerLevelTransactionState tx, long pageNumber, int numberOfPages, PagerState pagerState);
    public virtual Byte* AcquirePagePointer(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    private LoadedPage MapPages(TransactionState state, long startPage, long size);
    private LoadedPage AddMappingToTransaction(TransactionState state, long startPage, long size, MappedAddresses mappedAddresses);
    [DoesNotReturnAttribute]
private void ThrowInvalidMappingRequested(long startPage, long size);
    private TransactionState GetTransactionState(IPagerLevelTransactionState tx);
    private PagerState CreatePagerState();
    private void TxOnOnDispose(IPagerLevelTransactionState lowLevelTransaction);
    private void CleanupMemory(TransactionState txState);
    public virtual void Sync(long totalUnsynced);
    protected virtual string GetSourceName();
    protected internal virtual PagerState AllocateMorePages(long newLength);
    public virtual string ToString();
    protected virtual bool CanPrefetchQuery();
    protected virtual void DisposeInternal();
}
public class Voron.Impl.Scratch.AllocatedPageInScratchBuffer : object {
    [CompilerGeneratedAttribute]
private int <ScratchFileNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PositionInScratchBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfPages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ScratchPageNumber>k__BackingField;
    public int ScratchFileNumber { get; public set; }
    public long PositionInScratchBuffer { get; public set; }
    public long Size { get; public set; }
    public int NumberOfPages { get; public set; }
    public long ScratchPageNumber { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ScratchFileNumber();
    [CompilerGeneratedAttribute]
public void set_ScratchFileNumber(int value);
    [CompilerGeneratedAttribute]
public long get_PositionInScratchBuffer();
    [CompilerGeneratedAttribute]
public void set_PositionInScratchBuffer(long value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(long value);
    [CompilerGeneratedAttribute]
public int get_NumberOfPages();
    [CompilerGeneratedAttribute]
public void set_NumberOfPages(int value);
    [CompilerGeneratedAttribute]
public long get_ScratchPageNumber();
    [CompilerGeneratedAttribute]
public void set_ScratchPageNumber(long value);
}
public interface Voron.Impl.Scratch.IScratchSpaceMonitor {
    public abstract virtual void Increase(long allocatedScratchSpaceInBytes);
    public abstract virtual void Decrease(long releasedScratchSpaceInBytes);
}
public class Voron.Impl.Scratch.MostAvailableFreePagesBySize : object {
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ValidAfterTransactionId>k__BackingField;
    public long Size { get; public set; }
    public long ValidAfterTransactionId { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(long value);
    [CompilerGeneratedAttribute]
public long get_ValidAfterTransactionId();
    [CompilerGeneratedAttribute]
public void set_ValidAfterTransactionId(long value);
}
public class Voron.Impl.Scratch.PageFromScratchBuffer : object {
    public int ScratchFileNumber;
    public long PositionInScratchBuffer;
    public long Size;
    public int NumberOfPages;
    public Nullable`1<Page> PreviousVersion;
    public long ScratchPageNumber;
    public PageFromScratchBuffer(int scratchFileNumber, long positionInScratchBuffer, long size, int numberOfPages);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Voron.Impl.Scratch.PageFromScratchBufferEqualityComparer : object {
    public static PageFromScratchBufferEqualityComparer Instance;
    private static PageFromScratchBufferEqualityComparer();
    public sealed virtual bool Equals(PageFromScratchBuffer x, PageFromScratchBuffer y);
    public sealed virtual int GetHashCode(PageFromScratchBuffer obj);
}
public class Voron.Impl.Scratch.ScratchBufferFile : object {
    private AbstractPager _scratchPager;
    private int _scratchNumber;
    private Dictionary`2<long, LinkedList`1<PendingPage>> _freePagesBySize;
    private Dictionary`2<long, LinkedList`1<long>> _freePagesBySizeAvailableImmediately;
    private Dictionary`2<long, PageFromScratchBuffer> _allocatedPages;
    private DisposeOnce`1<SingleAttempt> _disposeOnceRunner;
    private long _allocatedPagesCount;
    private long _lastUsedPage;
    private long _txIdAfterWhichLatestFreePagesBecomeAvailable;
    private StrongReference`1<Func`1<long>> _strongRefToAllocateInBytesFunc;
    [CompilerGeneratedAttribute]
private ScratchFileDebugInfo <DebugInfo>k__BackingField;
    public long LastUsedPage { get; }
    public PagerState PagerState { get; }
    internal AbstractPager Pager { get; }
    public int Number { get; }
    public int NumberOfAllocations { get; }
    public long Size { get; }
    public long NumberOfAllocatedPages { get; }
    public long AllocatedPagesCount { get; }
    public long TxIdAfterWhichLatestFreePagesBecomeAvailable { get; }
    public ScratchFileDebugInfo DebugInfo { get; }
    public bool IsDisposed { get; }
    public ScratchBufferFile(AbstractPager scratchPager, int scratchNumber);
    public long get_LastUsedPage();
    private void ClearDictionaries();
    public void Reset();
    public PagerState get_PagerState();
    internal AbstractPager get_Pager();
    public int get_Number();
    public int get_NumberOfAllocations();
    public long get_Size();
    public long get_NumberOfAllocatedPages();
    public long get_AllocatedPagesCount();
    public long get_TxIdAfterWhichLatestFreePagesBecomeAvailable();
    [CompilerGeneratedAttribute]
public ScratchFileDebugInfo get_DebugInfo();
    public PageFromScratchBuffer Allocate(LowLevelTransaction tx, int numberOfPages, int sizeToAllocate);
    public bool TryGettingFromAllocatedBuffer(LowLevelTransaction tx, int numberOfPages, long size, PageFromScratchBuffer& result);
    public bool HasActivelyUsedBytes(long oldestActiveTransaction);
    public void Free(long pageNumber, Nullable`1<long> txId);
    internal void Free(long page, long asOfTxId);
    [DoesNotReturnAttribute]
private static void ThrowInvalidFreeOfUnusedPage(long page);
    public int CopyPage(I4KbBatchWrites destI4KbBatchWrites, long p, PagerState pagerState);
    public Page ReadPage(LowLevelTransaction tx, long p, PagerState pagerState);
    public T ReadPageHeaderForDebug(LowLevelTransaction tx, long p, PagerState pagerState);
    public Byte* AcquirePagePointerWithOverflowHandling(IPagerLevelTransactionState tx, long p, PagerState pagerState);
    public Byte* AcquirePagePointerForNewPage(LowLevelTransaction tx, long p, int numberOfPages);
    public sealed virtual void Dispose();
    public bool get_IsDisposed();
    public void BreakLargeAllocationToSeparatePages(IPagerLevelTransactionState tx, PageFromScratchBuffer value);
    private static void InvalidAttemptToBreakupPageThatWasntAllocated(PageFromScratchBuffer value);
    public void EnsureMapped(LowLevelTransaction tx, long p, int numberOfPages);
    public PageFromScratchBuffer ShrinkOverflowPage(PageFromScratchBuffer value, int newNumberOfPages);
    private static void InvalidAttemptToShrinkPageThatWasntAllocated(PageFromScratchBuffer value);
    [CompilerGeneratedAttribute]
private long <.ctor>b__13_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_1();
}
public class Voron.Impl.Scratch.ScratchBufferPool : object {
    private StorageEnvironment _env;
    private StorageEnvironmentOptions _options;
    internal ScratchBufferItem _current;
    private int _currentScratchNumber;
    private Dictionary`2<int, PagerState> _pagerStatesAllScratchesCache;
    private ConcurrentDictionary`2<int, ScratchBufferItem> _scratchBuffers;
    private LinkedList`1<ScratchBufferItem> _recycleArea;
    private DisposeOnce`1<ExceptionRetry> _disposeOnceRunner;
    private long _lastLowMemoryEventTicks;
    private long _lowMemoryIntervalTicks;
    private MultipleUseFlag _lowMemoryFlag;
    private ScratchSpaceUsageMonitor _scratchSpaceMonitor;
    private Logger _logger;
    [CompilerGeneratedAttribute]
private TimeSpan <RecycledScratchFileTimeout>k__BackingField;
    internal TestingStuff _forTestingPurposes;
    public long NumberOfScratchBuffers { get; }
    internal TimeSpan RecycledScratchFileTimeout { get; internal set; }
    public ScratchBufferPool(StorageEnvironment env);
    public long get_NumberOfScratchBuffers();
    [CompilerGeneratedAttribute]
internal TimeSpan get_RecycledScratchFileTimeout();
    [CompilerGeneratedAttribute]
internal void set_RecycledScratchFileTimeout(TimeSpan value);
    public Dictionary`2<int, PagerState> GetPagerStatesOfAllScratches();
    public void UpdateCacheForPagerStatesOfAllScratches();
    internal long GetNumberOfAllocations(int scratchNumber);
    private ScratchBufferItem NextFile(long minSize, Nullable`1<long> requestedSize);
    public PageFromScratchBuffer Allocate(LowLevelTransaction tx, int numberOfPages);
    public void Free(LowLevelTransaction tx, int scratchNumber, long page, Nullable`1<long> txId);
    private void TryRecycleScratchFile(ScratchBufferItem scratch);
    public sealed virtual void Dispose();
    public int CopyPage(I4KbBatchWrites destI4KbBatchWrites, int scratchNumber, long p, PagerState pagerState);
    public Page ReadPage(LowLevelTransaction tx, int scratchNumber, long p, PagerState pagerState);
    public T ReadPageHeaderForDebug(LowLevelTransaction tx, int scratchNumber, long p, PagerState pagerState);
    public PageFromScratchBuffer ShrinkOverflowPage(PageFromScratchBuffer value, int newNumberOfPages);
    public Byte* AcquirePagePointerForNewPage(LowLevelTransaction tx, int scratchNumber, long p, int numberOfPages);
    public Byte* AcquirePagePointerWithOverflowHandling(IPagerLevelTransactionState tx, int scratchNumber, long p, PagerState pagerState);
    internal ScratchBufferItem GetScratchBufferFile(int scratchNumber);
    private void AddScratchBufferFile(ScratchBufferItem scratch);
    private int RemoveInactiveScratches(ScratchBufferItem except, bool updateCacheBeforeDisposingScratch);
    [DoesNotReturnAttribute]
private static void ThrowUnableToRemoveScratch(ScratchBufferItem scratchBufferItem);
    public void BreakLargeAllocationToSeparatePages(LowLevelTransaction tx, PageFromScratchBuffer value);
    public long GetAvailablePagesCount();
    public void Cleanup();
    internal TestingStuff ForTestingPurposesOnly();
    private int RemoveInactiveRecycledScratches();
    public void EnsureMapped(LowLevelTransaction tx, int scratchNumber, long positionInScratchBuffer, int numberOfPages);
    public ScratchBufferPoolInfo InfoForDebug(long oldestActiveTransaction);
    private bool IsLowMemory();
    public sealed virtual void LowMemory(LowMemorySeverity lowMemorySeverity);
    public sealed virtual void LowMemoryOver();
    [CompilerGeneratedAttribute]
private void <.ctor>b__15_0();
}
public class Voron.Impl.Scratch.ScratchBufferPoolInfo : object {
    [CompilerGeneratedAttribute]
private long <OldestActiveTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfScratchFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentFileNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentFileSizeInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PerScratchFileSizeLimitInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ScratchFileUsage> <ScratchFilesUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CurrentUtcTime>k__BackingField;
    public long OldestActiveTransaction { get; public set; }
    public int NumberOfScratchFiles { get; public set; }
    public int CurrentFileNumber { get; public set; }
    public long CurrentFileSizeInMB { get; public set; }
    public long PerScratchFileSizeLimitInMB { get; public set; }
    public List`1<ScratchFileUsage> ScratchFilesUsage { get; public set; }
    public DateTime CurrentUtcTime { get; public set; }
    [CompilerGeneratedAttribute]
public long get_OldestActiveTransaction();
    [CompilerGeneratedAttribute]
public void set_OldestActiveTransaction(long value);
    [CompilerGeneratedAttribute]
public int get_NumberOfScratchFiles();
    [CompilerGeneratedAttribute]
public void set_NumberOfScratchFiles(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentFileNumber();
    [CompilerGeneratedAttribute]
public void set_CurrentFileNumber(int value);
    [CompilerGeneratedAttribute]
public long get_CurrentFileSizeInMB();
    [CompilerGeneratedAttribute]
public void set_CurrentFileSizeInMB(long value);
    [CompilerGeneratedAttribute]
public long get_PerScratchFileSizeLimitInMB();
    [CompilerGeneratedAttribute]
public void set_PerScratchFileSizeLimitInMB(long value);
    [CompilerGeneratedAttribute]
public List`1<ScratchFileUsage> get_ScratchFilesUsage();
    [CompilerGeneratedAttribute]
public void set_ScratchFilesUsage(List`1<ScratchFileUsage> value);
    [CompilerGeneratedAttribute]
public DateTime get_CurrentUtcTime();
    [CompilerGeneratedAttribute]
public void set_CurrentUtcTime(DateTime value);
}
public class Voron.Impl.Scratch.ScratchFileUsage : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeInKB>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfAllocations>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocatedPagesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TxIdAfterWhichLatestFreePagesBecomeAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MostAvailableFreePagesBySize> <MostAvailableFreePages>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AllocatedPageInScratchBuffer> <First10AllocatedPages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInRecycleArea>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastResetTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfResets>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastFreeTime>k__BackingField;
    public string Name { get; public set; }
    public long SizeInKB { get; public set; }
    public int NumberOfAllocations { get; public set; }
    public long AllocatedPagesCount { get; public set; }
    public long TxIdAfterWhichLatestFreePagesBecomeAvailable { get; public set; }
    public bool CanBeDeleted { get; public set; }
    public List`1<MostAvailableFreePagesBySize> MostAvailableFreePages { get; public set; }
    public List`1<AllocatedPageInScratchBuffer> First10AllocatedPages { get; public set; }
    public bool IsInRecycleArea { get; public set; }
    public Nullable`1<DateTime> LastResetTime { get; public set; }
    public int NumberOfResets { get; public set; }
    public Nullable`1<DateTime> LastFreeTime { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_SizeInKB();
    [CompilerGeneratedAttribute]
public void set_SizeInKB(long value);
    [CompilerGeneratedAttribute]
public int get_NumberOfAllocations();
    [CompilerGeneratedAttribute]
public void set_NumberOfAllocations(int value);
    [CompilerGeneratedAttribute]
public long get_AllocatedPagesCount();
    [CompilerGeneratedAttribute]
public void set_AllocatedPagesCount(long value);
    [CompilerGeneratedAttribute]
public long get_TxIdAfterWhichLatestFreePagesBecomeAvailable();
    [CompilerGeneratedAttribute]
public void set_TxIdAfterWhichLatestFreePagesBecomeAvailable(long value);
    [CompilerGeneratedAttribute]
public bool get_CanBeDeleted();
    [CompilerGeneratedAttribute]
public void set_CanBeDeleted(bool value);
    [CompilerGeneratedAttribute]
public List`1<MostAvailableFreePagesBySize> get_MostAvailableFreePages();
    [CompilerGeneratedAttribute]
public void set_MostAvailableFreePages(List`1<MostAvailableFreePagesBySize> value);
    [CompilerGeneratedAttribute]
public List`1<AllocatedPageInScratchBuffer> get_First10AllocatedPages();
    [CompilerGeneratedAttribute]
public void set_First10AllocatedPages(List`1<AllocatedPageInScratchBuffer> value);
    [CompilerGeneratedAttribute]
public bool get_IsInRecycleArea();
    [CompilerGeneratedAttribute]
public void set_IsInRecycleArea(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastResetTime();
    [CompilerGeneratedAttribute]
public void set_LastResetTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public int get_NumberOfResets();
    [CompilerGeneratedAttribute]
public void set_NumberOfResets(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastFreeTime();
    [CompilerGeneratedAttribute]
public void set_LastFreeTime(Nullable`1<DateTime> value);
}
public class Voron.Impl.Scratch.ScratchSpaceChangedDelegate : MulticastDelegate {
    public ScratchSpaceChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(long scratchSpaceChangeInBytes);
    public virtual IAsyncResult BeginInvoke(long scratchSpaceChangeInBytes, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Voron.Impl.Scratch.ScratchSpaceUsageMonitor : object {
    private ScratchSpaceChangedDelegate _increase;
    private ScratchSpaceChangedDelegate _decrease;
    public long ScratchSpaceInBytes;
    public void AddMonitor(IScratchSpaceMonitor monitor);
    public sealed virtual void Increase(long allocatedScratchSpaceInBytes);
    public sealed virtual void Decrease(long releasedScratchSpaceInBytes);
    public sealed virtual void Dispose();
}
public class Voron.Impl.SliceSmallSet`1 : object {
    private static PerCoreContainer`1<ArrayPoolContainer<TValue>> PerCoreArrayPools;
    private ArrayPoolContainer<TValue> _perCorePools;
    private static int Invalid;
    private int _length;
    private Int32[] _keySizes;
    private UInt64[] _keyHashes;
    private Slice[] _keys;
    private TValue[] _values;
    private Dictionary`2<Slice, TValue> _overflowStorage;
    private int _currentIdx;
    public IEnumerable`1<TValue> Values { get; }
    public SliceSmallSet`1(int size);
    private static SliceSmallSet`1();
    public IEnumerable`1<TValue> get_Values();
    [IteratorStateMachineAttribute("Voron.Impl.SliceSmallSet`1/<ReturnValues>d__14")]
private IEnumerable`1<TValue> ReturnValues();
    public void Add(Slice key, TValue value);
    private int FindKey(Slice key);
    private int RequestWritableBucket();
    public bool TryGetValue(Slice key, TValue& value);
    public void Clear();
    public sealed virtual void Dispose();
    public void Remove(Slice name);
}
public class Voron.Impl.StorageEnvironmentState : object {
    [CompilerGeneratedAttribute]
private TreeMutableState <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NextPageNumber>k__BackingField;
    public TreeMutableState Root { get; private set; }
    public long NextPageNumber { get; private set; }
    private StorageEnvironmentState(TreeMutableState root, long nextPageNumber);
    public StorageEnvironmentState(long nextPage);
    [CompilerGeneratedAttribute]
public TreeMutableState get_Root();
    [CompilerGeneratedAttribute]
private void set_Root(TreeMutableState value);
    [CompilerGeneratedAttribute]
public long get_NextPageNumber();
    [CompilerGeneratedAttribute]
private void set_NextPageNumber(long value);
    public void Initialize(TreeMutableState rootObjectsState);
    public void UpdateNextPage(long nextPage);
    public StorageEnvironmentState Clone();
}
public class Voron.Impl.Transaction : object {
    public object Owner;
    private Dictionary`2<long, TransactionState> _containers;
    private Dictionary`2<Slice, PostingList> _postingLists;
    private Dictionary`2<TableKey, Table> _tables;
    private Dictionary`2<Slice, TableSchemaStatsReference> _tableSchemaStats;
    private Dictionary`2<Slice, Tree> _trees;
    private Dictionary`2<Slice, FixedSizeTree> _globalFixedSizeTree;
    [CompilerGeneratedAttribute]
private Action`1<Transaction> OnBeforeCommit;
    private LowLevelTransaction _lowLevelTransaction;
    private Dictionary`2<Tuple`2<Tree, Slice>, Tree> _multiValueTrees;
    private Dictionary`2<long, ByteString> _cachedDecompressedBuffersByStorageId;
    public LowLevelTransaction LowLevelTransaction { get; }
    public ByteStringContext Allocator { get; }
    public IEnumerable`1<Tree> Trees { get; }
    public IEnumerable`1<Table> Tables { get; }
    public bool IsWriteTransaction { get; }
    internal Dictionary`2<long, ByteString> CachedDecompressedBuffersByStorageId { get; }
    public Transaction(LowLevelTransaction lowLevelTransaction);
    public LowLevelTransaction get_LowLevelTransaction();
    public ByteStringContext get_Allocator();
    public IEnumerable`1<Tree> get_Trees();
    public IEnumerable`1<Table> get_Tables();
    public bool get_IsWriteTransaction();
    [CompilerGeneratedAttribute]
public void add_OnBeforeCommit(Action`1<Transaction> value);
    [CompilerGeneratedAttribute]
public void remove_OnBeforeCommit(Action`1<Transaction> value);
    internal Dictionary`2<long, ByteString> get_CachedDecompressedBuffersByStorageId();
    private void EnsureTrees();
    public Tree ReadTree(string treeName, RootObjectType type, bool isIndexTree, NewPageAllocator newPageAllocator);
    public Tree ReadTree(Slice treeName, RootObjectType type, bool isIndexTree, NewPageAllocator newPageAllocator);
    [DoesNotReturnAttribute]
private static void ThrowInvalidTreeType(Slice treeName, RootObjectType type, TreeRootHeader* header);
    public void Commit();
    public Transaction BeginAsyncCommitAndStartNewTransaction(TransactionPersistentContext persistentContext);
    [DoesNotReturnAttribute]
private static void ThrowInvalidAsyncCommitOnRead();
    public void EndAsyncCommit();
    public long OpenContainer(string name);
    public Lookup`1<TKey> LookupFor(string name);
    public Lookup`1<TKey> LookupFor(Slice name);
    public long OpenContainer(Slice name);
    public PostingList OpenPostingList(string name);
    public PostingList OpenPostingList(Slice name);
    public Table OpenTable(TableSchema schema, string name);
    public Table OpenTable(TableSchema schema, Slice name);
    internal void PrepareForCommit();
    internal void AddMultiValueTree(Tree tree, Slice key, Tree mvTree);
    internal bool TryGetMultiValueTree(Tree tree, Slice key, Tree& mvTree);
    internal bool TryRemoveMultiValueTree(Tree parentTree, Slice key);
    internal void AddTree(string name, Tree tree);
    internal void AddTree(Slice name, Tree tree);
    public void DeleteTree(string name);
    public void DeleteFixedTree(string name);
    public void DeleteFixedTree(FixedSizeTree tree, bool isInRoot);
    public void DeleteTree(Slice name);
    private void DeleteTree(Tree tree, bool isInRoot);
    public void RenameTree(string fromName, string toName);
    public void RenameTree(Slice fromName, Slice toName);
    public Tree CreateTree(string name, RootObjectType type, TreeFlags flags, bool isIndexTree, NewPageAllocator newPageAllocator);
    public Tree CreateTree(Slice name, RootObjectType type, TreeFlags flags, bool isIndexTree, NewPageAllocator newPageAllocator);
    public sealed virtual void Dispose();
    public CompactTree CompactTreeFor(string treeName);
    public CompactTree CompactTreeFor(Slice treeName);
    public FixedSizeTree FixedTreeFor(string treeName);
    public FixedSizeTree FixedTreeFor(string treeName, ushort valSize);
    public FixedSizeTree FixedTreeFor(Slice treeName);
    public FixedSizeTree FixedTreeFor(Slice treeName, ushort valSize);
    public RootObjectType GetRootObjectType(Slice name);
    public FixedSizeTree GetGlobalFixedSizeTree(Slice name, ushort valSize, bool isIndexTree, NewPageAllocator newPageAllocator);
    [ConditionalAttribute("DEBUG")]
public static void DebugDisposeReaderAfterTransaction(Transaction tx, BlittableJsonReaderObject reader);
    public void DeleteTable(string name);
    public void ForgetAbout(Int64& storageId);
    public void Forget(Slice name);
    public TransactionState GetContainerState(long containerId);
}
internal class Voron.Impl.TreeAndSliceComparer : object {
    public sealed virtual bool Equals(Tuple`2<Tree, Slice> x, Tuple`2<Tree, Slice> y);
    public sealed virtual int GetHashCode(Tuple`2<Tree, Slice> obj);
}
public class Voron.NonDurabilitySupportEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Details>k__BackingField;
    public string Message { get; private set; }
    public Exception Exception { get; private set; }
    public string Details { get; private set; }
    internal NonDurabilitySupportEventArgs(string message, Exception exception, string details);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public string get_Details();
    [CompilerGeneratedAttribute]
private void set_Details(string value);
}
internal class Voron.NonDurableFileSystemException : Exception {
    public NonDurableFileSystemException(string message);
    public NonDurableFileSystemException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class Voron.Page : ValueType {
    public Byte* Pointer;
    public bool IsValid { get; }
    public Byte* DataPointer { get; }
    public long PageNumber { get; public set; }
    public bool IsOverflow { get; }
    public int OverflowSize { get; public set; }
    public PageFlags Flags { get; public set; }
    public Page(Byte* pointer);
    public Span`1<byte> AsSpan();
    public Span`1<byte> AsSpan(int offset, int length);
    public Span`1<T> AsSpan(int offset, int length);
    public Span`1<T> AsSpan(int length);
    public bool get_IsValid();
    public Byte* get_DataPointer();
    public long get_PageNumber();
    public void set_PageNumber(long value);
    public bool get_IsOverflow();
    public int get_OverflowSize();
    public void set_OverflowSize(int value);
    public PageFlags get_Flags();
    public void set_Flags(PageFlags value);
    public void CopyTo(Page& dest);
}
[FlagsAttribute]
public enum Voron.PageFlags : Enum {
    public byte value__;
    public static PageFlags Single;
    public static PageFlags Overflow;
    public static PageFlags VariableSizeTreePage;
    public static PageFlags FixedSizeTreePage;
    public static PageFlags Stream;
    public static PageFlags RawData;
    public static PageFlags Compressed;
    public static PageFlags Other;
}
public class Voron.PageHeader : ValueType {
    public static int ChecksumOffset;
    public static int NonceOffset;
    public static int MacOffset;
    public static int SizeOf;
    public long PageNumber;
    public int OverflowSize;
    public PageFlags Flags;
    [FixedBufferAttribute("System.Byte", "9")]
public <Reserved1>e__FixedBuffer Reserved1;
    public ulong Checksum;
    [FixedBufferAttribute("System.Byte", "16")]
public <Nonce>e__FixedBuffer Nonce;
    [FixedBufferAttribute("System.Byte", "16")]
public <Mac>e__FixedBuffer Mac;
    private static PageHeader();
}
public class Voron.PageHeaderUnion : ValueType {
    public PageHeader PageHeader;
    public FixedSizeTreePageHeader FixedSizeTreePageHeader;
    public TreePageHeader TreePageHeader;
}
public class Voron.PageLocator : object {
    private static long Invalid;
    private ushort _generation;
    private PageData[] _cache;
    private static UInt32 CacheSize;
    private static UInt32 CacheMask;
    public bool TryGetReadOnlyPage(long pageNumber, Page& page);
    public bool TryGetWritablePage(long pageNumber, Page& page);
    public void Renew();
    public void Reset(long pageNumber);
    public void SetReadable(Page page);
    public void SetWritable(Page page);
}
public class Voron.Platform.Posix.Posix32BitsMemoryMapPager : PosixAbstractPager {
    private StorageEnvironmentOptions _options;
    private bool _isSyncDirAllowed;
    private bool _copyOnWriteMode;
    private ConcurrentDictionary`2<long, ConcurrentSet`1<MappedAddresses>> _globalMapping;
    private long _totalMapped;
    private int _concurrentTransactions;
    private ReaderWriterLockSlim _globalMemory;
    private long _totalAllocationSize;
    public static int AllocationGranularity;
    private static int NumberOfPagesInAllocationGranularity;
    public long TotalAllocationSize { get; }
    public Posix32BitsMemoryMapPager(StorageEnvironmentOptions options, VoronPathSetting file, Nullable`1<long> initialFileSize, bool usePageProtection);
    public virtual long get_TotalAllocationSize();
    [DoesNotReturnAttribute]
private static void ThrowNotSupportedOption(string file);
    private long NearestSizeToAllocationGranularity(long size);
    private long GetFileSize();
    public virtual bool EnsureMapped(IPagerLevelTransactionState tx, long pageNumber, int numberOfPages);
    public virtual int CopyPage(I4KbBatchWrites destI4KbBatchWrites, long pageNumber, PagerState pagerState);
    public virtual I4KbBatchWrites BatchWriter();
    public virtual void DiscardPages(long pageNumber, int numberOfPages);
    public virtual void DiscardWholeFile();
    public virtual Byte* AcquirePagePointerForNewPage(IPagerLevelTransactionState tx, long pageNumber, int numberOfPages, PagerState pagerState);
    public virtual Byte* AcquirePagePointer(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    private LoadedPage MapPages(TransactionState state, long startPage, long size);
    private LoadedPage AddMappingToTransaction(TransactionState state, long startPage, long size, MappedAddresses mappedAddresses);
    [DoesNotReturnAttribute]
private void ThrowInvalidMappingRequested(long startPage, long size);
    private TransactionState GetTransactionState(IPagerLevelTransactionState tx);
    private void TxOnOnDispose(IPagerLevelTransactionState lowLevelTransaction);
    private void CleanupMemory(TransactionState txState);
    public virtual void Sync(long totalUnsynced);
    protected virtual string GetSourceName();
    protected internal virtual PagerState AllocateMorePages(long newLength);
    public virtual string ToString();
    protected virtual bool CanPrefetchQuery();
}
public abstract class Voron.Platform.Posix.PosixAbstractPager : AbstractPager {
    internal int _fd;
    private bool _supportsUnmapping;
    private Logger _log;
    protected PosixAbstractPager(StorageEnvironmentOptions options, bool canPrefetchAhead, bool usePageProtection, bool supportsUnmapping);
    public virtual int CopyPage(I4KbBatchWrites destwI4KbBatchWrites, long p, PagerState pagerState);
    public virtual Byte* AcquirePagePointer(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    public virtual void ReleaseAllocationInfo(Byte* baseAddress, long size);
    protected virtual void DisposeInternal();
}
public static class Voron.Platform.Posix.PosixHelper : object {
    public static void AllocateFileSpace(StorageEnvironmentOptions options, int fd, long size, string file);
    public static string GetFileSystemOfPath(string path);
    public static bool TryReadFileHeader(FileHeader* header, VoronPathSetting path);
    public static string FixLinuxPath(string path);
    public static void EnsurePathExists(string file);
}
public class Voron.Platform.Posix.PosixTempMemoryMapPager : PosixAbstractPager {
    private StorageEnvironmentOptions _options;
    public long SysPageSize;
    private long _totalAllocationSize;
    public long TotalAllocationSize { get; }
    public PosixTempMemoryMapPager(StorageEnvironmentOptions options, VoronPathSetting file, Nullable`1<long> initialFileSize);
    public virtual long get_TotalAllocationSize();
    protected virtual bool CanPrefetchQuery();
    private long NearestSizeToPageSize(long size);
    protected virtual string GetSourceName();
    protected internal virtual PagerState AllocateMorePages(long newLength);
    private PagerState CreatePagerState();
    public virtual void Sync(long totalUnsynced);
    public virtual string ToString();
}
public class Voron.Platform.Win32.Win32Helper : object {
    public static bool TryReadFileHeader(FileHeader* header, VoronPathSetting path);
}
public static class Voron.Platform.Win32.Win32MemoryMapNativeMethods : object {
    public static IntPtr CreateFileMapping(IntPtr hFile, IntPtr lpFileMappingAttributes, FileMapProtection flProtect, UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, string lpName);
    public static bool UnmapViewOfFile(Byte* lpBaseAddress);
    public static Byte* MapViewOfFileEx(IntPtr hFileMappingObject, NativeFileMapAccessType dwDesiredAccess, UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow, UIntPtr dwNumberOfBytesToMap, Byte* lpBaseAddress);
    public static bool FlushFileBuffers(SafeFileHandle hFile);
    public static bool FlushViewOfFile(Byte* lpBaseAddress, IntPtr dwNumberOfBytesToFlush);
}
[FlagsAttribute]
public enum Voron.Platform.Win32.Win32NativeFileAccess : Enum {
    public UInt32 value__;
    public static Win32NativeFileAccess AccessSystemSecurity;
    public static Win32NativeFileAccess MaximumAllowed;
    public static Win32NativeFileAccess Delete;
    public static Win32NativeFileAccess ReadControl;
    public static Win32NativeFileAccess WriteDAC;
    public static Win32NativeFileAccess WriteOwner;
    public static Win32NativeFileAccess Synchronize;
    public static Win32NativeFileAccess StandardRightsRequired;
    public static Win32NativeFileAccess StandardRightsRead;
    public static Win32NativeFileAccess StandardRightsWrite;
    public static Win32NativeFileAccess StandardRightsExecute;
    public static Win32NativeFileAccess StandardRightsAll;
    public static Win32NativeFileAccess SpecificRightsAll;
    public static Win32NativeFileAccess FILE_READ_DATA;
    public static Win32NativeFileAccess FILE_LIST_DIRECTORY;
    public static Win32NativeFileAccess FILE_WRITE_DATA;
    public static Win32NativeFileAccess FILE_ADD_FILE;
    public static Win32NativeFileAccess FILE_APPEND_DATA;
    public static Win32NativeFileAccess FILE_ADD_SUBDIRECTORY;
    public static Win32NativeFileAccess FILE_CREATE_PIPE_INSTANCE;
    public static Win32NativeFileAccess FILE_READ_EA;
    public static Win32NativeFileAccess FILE_WRITE_EA;
    public static Win32NativeFileAccess FILE_EXECUTE;
    public static Win32NativeFileAccess FILE_TRAVERSE;
    public static Win32NativeFileAccess FILE_DELETE_CHILD;
    public static Win32NativeFileAccess FILE_READ_ATTRIBUTES;
    public static Win32NativeFileAccess FILE_WRITE_ATTRIBUTES;
    public static Win32NativeFileAccess GenericRead;
    public static Win32NativeFileAccess GenericWrite;
    public static Win32NativeFileAccess GenericExecute;
    public static Win32NativeFileAccess GenericAll;
    public static Win32NativeFileAccess SPECIFIC_RIGHTS_ALL;
    public static Win32NativeFileAccess FILE_ALL_ACCESS;
    public static Win32NativeFileAccess FILE_GENERIC_READ;
    public static Win32NativeFileAccess FILE_GENERIC_WRITE;
    public static Win32NativeFileAccess FILE_GENERIC_EXECUTE;
}
[FlagsAttribute]
public enum Voron.Platform.Win32.Win32NativeFileAttributes : Enum {
    public UInt32 value__;
    public static Win32NativeFileAttributes None;
    public static Win32NativeFileAttributes Readonly;
    public static Win32NativeFileAttributes Hidden;
    public static Win32NativeFileAttributes System;
    public static Win32NativeFileAttributes Directory;
    public static Win32NativeFileAttributes Archive;
    public static Win32NativeFileAttributes Device;
    public static Win32NativeFileAttributes Normal;
    public static Win32NativeFileAttributes Temporary;
    public static Win32NativeFileAttributes SparseFile;
    public static Win32NativeFileAttributes ReparsePoint;
    public static Win32NativeFileAttributes Compressed;
    public static Win32NativeFileAttributes Offline;
    public static Win32NativeFileAttributes NotContentIndexed;
    public static Win32NativeFileAttributes Encrypted;
    public static Win32NativeFileAttributes Write_Through;
    public static Win32NativeFileAttributes Overlapped;
    public static Win32NativeFileAttributes NoBuffering;
    public static Win32NativeFileAttributes RandomAccess;
    public static Win32NativeFileAttributes SequentialScan;
    public static Win32NativeFileAttributes DeleteOnClose;
    public static Win32NativeFileAttributes BackupSemantics;
    public static Win32NativeFileAttributes PosixSemantics;
    public static Win32NativeFileAttributes OpenReparsePoint;
    public static Win32NativeFileAttributes OpenNoRecall;
    public static Win32NativeFileAttributes FirstPipeInstance;
}
public enum Voron.Platform.Win32.Win32NativeFileCreationDisposition : Enum {
    public UInt32 value__;
    public static Win32NativeFileCreationDisposition New;
    public static Win32NativeFileCreationDisposition CreateAlways;
    public static Win32NativeFileCreationDisposition OpenExisting;
    public static Win32NativeFileCreationDisposition OpenAlways;
    public static Win32NativeFileCreationDisposition TruncateExisting;
}
public enum Voron.Platform.Win32.Win32NativeFileErrors : Enum {
    public int value__;
    public static Win32NativeFileErrors ERROR_FILE_NOT_FOUND;
    public static Win32NativeFileErrors ERROR_DISK_FULL;
    public static Win32NativeFileErrors ERROR_NOT_READY;
    public static Win32NativeFileErrors ERROR_SHARING_VIOLATION;
    public static Win32NativeFileErrors ERROR_LOCK_VIOLATION;
    public static Win32NativeFileErrors ERROR_HANDLE_DISK_FULL;
}
public static class Voron.Platform.Win32.Win32NativeFileMethods : object {
    public static int ErrorIOPending;
    public static int ErrorSuccess;
    public static int ErrorHandleEof;
    public static int ErrorInvalidHandle;
    public static bool WriteFileGather(SafeFileHandle hFile, FileSegmentElement* aSegmentArray, UInt32 nNumberOfBytesToWrite, IntPtr lpReserved, NativeOverlapped* lpOverlapped);
    public static bool GetOverlappedResult(SafeFileHandle hFile, NativeOverlapped* lpOverlapped, UInt32& lpNumberOfBytesTransferred, bool bWait);
    public static bool SetFilePointerEx(SafeFileHandle hFile, long liDistanceToMove, IntPtr lpNewFilePointer, Win32NativeFileMoveMethod dwMoveMethod);
    public static bool WriteFileEx(SafeFileHandle hFile, Byte* lpBuffer, UInt32 nNumberOfBytesToWrite, NativeOverlapped* lpOverlapped, WriteFileCompletionDelegate lpCompletionRoutine);
    public static bool WriteFile(SafeFileHandle hFile, Byte* lpBuffer, int nNumberOfBytesToWrite, IntPtr lpNumberOfBytesWritten, NativeOverlapped* lpOverlapped);
    public static bool WriteFile(SafeFileHandle hFile, Byte* lpBuffer, int nNumberOfBytesToWrite, Int32& lpNumberOfBytesWritten, NativeOverlapped* lpOverlapped);
    public static bool ReadFile(SafeFileHandle hFile, Byte* pBuffer, int numBytesToRead, Int32& pNumberOfBytesRead, NativeOverlapped* lpOverlapped);
    public static SafeFileHandle CreateFile(string lpFileName, Win32NativeFileAccess dwDesiredAccess, Win32NativeFileShare dwShareMode, IntPtr lpSecurityAttributes, Win32NativeFileCreationDisposition dwCreationDisposition, Win32NativeFileAttributes dwFlagsAndAttributes, IntPtr hTemplateFile);
    public static bool CloseHandle(IntPtr hObject);
    private static bool SetEndOfFile(SafeFileHandle hFile);
    public static bool FlushFileBuffers(SafeFileHandle hFile);
    public static void SetFileLength(SafeFileHandle fileHandle, long length, string filePath);
}
public enum Voron.Platform.Win32.Win32NativeFileMoveMethod : Enum {
    public UInt32 value__;
    public static Win32NativeFileMoveMethod Begin;
    public static Win32NativeFileMoveMethod Current;
    public static Win32NativeFileMoveMethod End;
}
[FlagsAttribute]
public enum Voron.Platform.Win32.Win32NativeFileShare : Enum {
    public UInt32 value__;
    public static Win32NativeFileShare None;
    public static Win32NativeFileShare Read;
    public static Win32NativeFileShare Write;
    public static Win32NativeFileShare Delete;
}
public static class Voron.Platform.Win32.Win32NativeMethods : object {
    public static UInt32 SleepEx(UInt32 dwMilliseconds, bool bAlertable);
    public static UInt32 WaitForSingleObjectEx(IntPtr hHandle, int dwMilliseconds, bool bAlertable);
    public static void SetLastError(UInt32 dwErrCode);
    public static bool DeviceIoControl(IntPtr hDevice, UInt32 IoControlCode, IntPtr InMediaRemoval, UInt32 InBufferSize, IntPtr OutBuffer, int OutBufferSize, Int32& BytesReturned, IntPtr Overlapped);
    public static IntPtr CreateFile(string FileName, UInt32 DesiredAccess, UInt32 ShareMode, IntPtr lpSecurityAttributes, UInt32 CreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    public static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    public static bool CloseHandle(IntPtr hObject);
}
public class Voron.Platform.Win32.WindowsMemoryMapPager : AbstractPager {
    public static int AllocationGranularity;
    private long _totalAllocationSize;
    private FileInfo _fileInfo;
    private FileStream _fileStream;
    private SafeFileHandle _handle;
    private Win32NativeFileAttributes _fileAttributes;
    private Win32NativeFileAccess _access;
    private MemoryMappedFileAccess _memoryMappedFileAccess;
    private bool _copyOnWriteMode;
    private Logger _logger;
    public long TotalAllocationSize { get; }
    public WindowsMemoryMapPager(StorageEnvironmentOptions options, VoronPathSetting file, Nullable`1<long> initialFileSize, Win32NativeFileAttributes fileAttributes, Win32NativeFileAccess access, bool usePageProtection);
    public virtual long get_TotalAllocationSize();
    public virtual Byte* AcquirePagePointer(IPagerLevelTransactionState tx, long pageNumber, PagerState pagerState);
    public static UInt32 GetPhysicalDriveId(string drive);
    private long NearestSizeToAllocationGranularity(long size);
    protected internal virtual PagerState AllocateMorePages(long newLength);
    private PagerState CreatePagerState();
    protected virtual string GetSourceName();
    public virtual void Sync(long totalUnsynced);
    public virtual string ToString();
    protected virtual void DisposeInternal();
    public virtual void ReleaseAllocationInfo(Byte* baseAddress, long size);
    public virtual int CopyPage(I4KbBatchWrites destwI4KbBatchWrites, long p, PagerState pagerState);
    internal virtual void ProtectPageRange(Byte* start, ulong size, bool force);
    internal virtual void UnprotectPageRange(Byte* start, ulong size, bool force);
}
public class Voron.ReadResult : object {
    [CompilerGeneratedAttribute]
private ValueReader <Reader>k__BackingField;
    public ValueReader Reader { get; private set; }
    public ReadResult(ValueReader reader);
    [CompilerGeneratedAttribute]
public ValueReader get_Reader();
    [CompilerGeneratedAttribute]
private void set_Reader(ValueReader value);
}
public class Voron.RecoverableFailureEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <FailureMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <EnvironmentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnvironmentPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string FailureMessage { get; }
    public Guid EnvironmentId { get; }
    public string EnvironmentPath { get; }
    public Exception Exception { get; }
    internal RecoverableFailureEventArgs(string failureMessage, Guid environmentId, string environmentPath, Exception exception);
    [CompilerGeneratedAttribute]
public string get_FailureMessage();
    [CompilerGeneratedAttribute]
public Guid get_EnvironmentId();
    [CompilerGeneratedAttribute]
public string get_EnvironmentPath();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public class Voron.RecoveryErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string Message { get; private set; }
    public Exception Exception { get; private set; }
    internal RecoveryErrorEventArgs(string message, Exception exception);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
public interface Voron.Schema.IVoronSchemaUpdate {
    public abstract virtual bool Update(int currentVersion, StorageEnvironmentOptions options, HeaderAccessor headerAccessor, Int32& versionAfterUpgrade);
}
public class Voron.Schema.SchemaUpgradeTransactions : object {
    private StorageEnvironment _env;
    [CompilerGeneratedAttribute]
private Transaction <Read>k__BackingField;
    [CompilerGeneratedAttribute]
private Transaction <Write>k__BackingField;
    public Transaction Read { get; private set; }
    public Transaction Write { get; private set; }
    public SchemaUpgradeTransactions(StorageEnvironment env);
    [CompilerGeneratedAttribute]
public Transaction get_Read();
    [CompilerGeneratedAttribute]
private void set_Read(Transaction value);
    [CompilerGeneratedAttribute]
public Transaction get_Write();
    [CompilerGeneratedAttribute]
private void set_Write(Transaction value);
    public void OpenRead();
    private void OpenWrite();
    public void Commit();
    public void Renew();
    public sealed virtual void Dispose();
}
public class Voron.Schema.Updates.From22 : object {
    public sealed virtual bool Update(int currentVersion, StorageEnvironmentOptions options, HeaderAccessor headerAccessor, Int32& versionAfterUpgrade);
}
public class Voron.Schema.VoronSchemaUpdater : object {
    private HeaderAccessor _headerAccessor;
    private StorageEnvironmentOptions _options;
    public VoronSchemaUpdater(HeaderAccessor headerAccessor, StorageEnvironmentOptions options);
    public void Update();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
public class Voron.Slice : ValueType {
    public ByteString Content;
    public bool HasValue { get; }
    public int Size { get; }
    public SliceOptions Options { get; }
    public byte Item { get; public set; }
    public Slice(SliceOptions options, ByteString content);
    public Slice(ByteString content);
    public static ReadOnlySpan`1<byte> op_Implicit(Slice x);
    public static Span`1<byte> op_Explicit(Slice x);
    public bool get_HasValue();
    [IsReadOnlyAttribute]
public int get_Size();
    public SliceOptions get_Options();
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    [IsReadOnlyAttribute]
public Slice Clone(ByteStringContext context, ByteStringType type);
    public Slice Skip(ByteStringContext context, int bytesToSkip, ByteStringType type);
    public void CopyTo(Span`1<byte> buffer);
    public void CopyTo(int from, Byte* dest, int offset, int count);
    public void CopyTo(Byte* dest);
    public void CopyTo(Byte[] dest);
    public void CopyTo(int from, Byte[] dest, int offset, int count);
    public bool Contains(Slice other);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, ReadOnlySpan`1<char> value, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, string value, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, ReadOnlySpan`1<char> value, ByteStringType type, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, string value, ByteStringType type, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, string value, byte endSeparator, ByteStringType type, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, ReadOnlySpan`1<char> value, byte endSeparator, ByteStringType type, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, ReadOnlySpan`1<byte> value, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, ReadOnlySpan`1<byte> value, ByteStringType type, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, ReadOnlySpan`1<byte> value, int offset, int count, ByteStringType type, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, Byte* value, int size, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, Span`1<byte> value, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, LazyStringValue value, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, Byte* value, int size, ByteStringType type, Slice& str);
    public static InternalScope<ByteStringMemoryCache> From(ByteStringContext context, Byte* value, int size, byte endSeparator, Slice& str);
    public static ExternalScope<ByteStringMemoryCache> External(ByteStringContext context, ByteString value, int offset, int size, Slice& slice);
    public static ExternalScope<ByteStringMemoryCache> External(ByteStringContext context, ByteString value, int size, Slice& slice);
    public static ExternalScope<ByteStringMemoryCache> External(ByteStringContext context, ByteString value, Slice& slice);
    public static ExternalScope<ByteStringMemoryCache> External(ByteStringContext context, Byte* value, int size, Slice& slice);
    public static ExternalScope<ByteStringMemoryCache> External(ByteStringContext context, Slice value, int size, Slice& slice);
    public static ExternalScope<ByteStringMemoryCache> External(ByteStringContext context, LazyStringValue value, Slice& slice);
    public static ExternalScope<ByteStringMemoryCache> External(ByteStringContext context, Byte* value, int size, ByteStringType type, Slice& slice);
    public void Release(ByteStringContext context);
    public ValueReader CreateReader();
    public long ReadInt64();
    public double ReadDouble();
    public virtual int GetHashCode();
    public virtual string ToString();
    [IsReadOnlyAttribute]
public Span`1<byte> AsSpan();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<byte> AsReadOnlySpan();
}
public class Voron.SliceComparer : object {
    public static SliceComparer Instance;
    private static SliceComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<Voron.Slice>.Compare(Slice x, Slice y);
    public static int Compare(Slice x, Slice y);
    public static int CompareInline(Slice x, Slice y);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<Voron.Slice>.Equals(Slice x, Slice y);
    public static bool AreEqual(Slice x, Slice y);
    public static bool Equals(Slice x, Slice y);
    public static bool EqualsInline(Slice x, Slice y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<Voron.Slice>.GetHashCode(Slice obj);
    public static bool StartWith(Slice value, Slice prefix);
}
[ExtensionAttribute]
public static class Voron.SliceExtensions : object {
    [ExtensionAttribute]
public static bool StartWith(Slice s1, ReadOnlySpan`1<byte> s2);
    [ExtensionAttribute]
public static bool EndsWith(Slice s1, ReadOnlySpan`1<byte> s2);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<byte> first, ReadOnlySpan`1<byte> second);
}
public enum Voron.SliceOptions : Enum {
    public byte value__;
    public static SliceOptions Key;
    public static SliceOptions BeforeAllKeys;
    public static SliceOptions AfterAllKeys;
}
public static class Voron.Slices : object {
    private static ByteStringContext SharedSliceContent;
    public static Slice AfterAllKeys;
    public static Slice BeforeAllKeys;
    public static Slice Empty;
    private static Slices();
}
public class Voron.SliceStructComparer : ValueType {
    public static SliceStructComparer Instance;
    private static SliceStructComparer();
    public sealed virtual int Compare(Slice x, Slice y);
    public sealed virtual bool Equals(Slice x, Slice y);
    public sealed virtual int GetHashCode(Slice obj);
}
public class Voron.StorageEnvironment : object {
    internal CompressionDictionariesHolder CompressionDictionariesHolder;
    internal IndirectReference SelfReference;
    private static ByteStringContext _staticContext;
    private StorageEnvironmentOptions _options;
    public ActiveTransactions ActiveTransactions;
    private AbstractPager _dataPager;
    internal WriteTransactionPool WriteTransactionPool;
    private WriteAheadJournal _journal;
    internal SemaphoreSlim _transactionWriter;
    internal ThreadStats _currentWriteTransactionHolder;
    private AsyncManualResetEvent _writeTransactionRunning;
    internal ThreadHoppingReaderWriterLock FlushInProgressLock;
    private ReaderWriterLockSlim _txCreation;
    private CountdownEvent _envDispose;
    private long _transactionsCounter;
    private IFreeSpaceHandling _freeSpaceHandling;
    private HeaderAccessor _headerAccessor;
    private DecompressionBuffersPool _decompressionBuffers;
    private CancellationTokenSource _cancellationTokenSource;
    private ScratchBufferPool _scratchBufferPool;
    private EndOfDiskSpaceEvent _endOfDiskSpace;
    private int _idleFlushTimerFailures;
    private Task _idleFlushTimer;
    internal DateTime LastFlushTime;
    public DateTime LastWorkTime;
    public bool Disposed;
    private Logger _log;
    public static int MaxConcurrentFlushes;
    public int TimeToSyncAfterFlushInSec;
    [CompilerGeneratedAttribute]
private Guid <DbId>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageEnvironmentState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Action OnLogsApplied;
    internal Int64[] _validPagesAfterLoad;
    internal long _lastValidPageAfterLoad;
    [CompilerGeneratedAttribute]
private bool <IsNew>k__BackingField;
    public static int Base64IdLength;
    [CompilerGeneratedAttribute]
private string <Base64Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<LowLevelTransaction> NewTransactionCreated;
    [CompilerGeneratedAttribute]
private Action`1<LowLevelTransaction> AfterCommitWhenNewTransactionsPrevented;
    internal TestingStuff _forTestingPurposes;
    [CompilerGeneratedAttribute]
private PersistentDictionaryLocator <DictionaryLocator>k__BackingField;
    public Guid DbId { get; public set; }
    public StorageEnvironmentState State { get; private set; }
    public bool IsNew { get; }
    public ScratchBufferPool ScratchBufferPool { get; }
    public string Base64Id { get; }
    public IFreeSpaceHandling FreeSpaceHandling { get; }
    public HeaderAccessor HeaderAccessor { get; }
    public long NextPageNumber { get; }
    public StorageEnvironmentOptions Options { get; }
    public WriteAheadJournal Journal { get; }
    public DecompressionBuffersPool DecompressionBuffers { get; }
    public long CurrentReadTransactionId { get; }
    public long NextWriteTransactionId { get; }
    public CancellationToken Token { get; }
    internal bool IsInPreventNewTransactionsMode { get; }
    internal PersistentDictionaryLocator DictionaryLocator { get; }
    public StorageEnvironment(StorageEnvironmentOptions options);
    private static StorageEnvironment();
    public void SuggestSyncDataFile();
    public void ForceSyncDataFile();
    public static IDisposable GetStaticContext(ByteStringContext& ctx);
    [CompilerGeneratedAttribute]
public Guid get_DbId();
    [CompilerGeneratedAttribute]
public void set_DbId(Guid value);
    [CompilerGeneratedAttribute]
public StorageEnvironmentState get_State();
    [CompilerGeneratedAttribute]
private void set_State(StorageEnvironmentState value);
    [CompilerGeneratedAttribute]
public void add_OnLogsApplied(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnLogsApplied(Action value);
    [CompilerGeneratedAttribute]
public bool get_IsNew();
    protected virtual override void Finalize();
    [AsyncStateMachineAttribute("Voron.StorageEnvironment/<IdleFlushTimer>d__51")]
private static Task IdleFlushTimer(WeakReference`1<StorageEnvironment> weakRef, CancellationToken token);
    [AsyncStateMachineAttribute("Voron.StorageEnvironment/<IdleFlushTimerInternal>d__52")]
private static Task`1<Nullable`1<bool>> IdleFlushTimerInternal(WeakReference`1<StorageEnvironment> weakRef);
    public ScratchBufferPool get_ScratchBufferPool();
    private void LoadExistingDatabase();
    private void UpgradeSchemaIfRequired();
    private void UpgradeSchema(int schemaVersionVal, UpgraderDelegate upgrader);
    [DoesNotReturnAttribute]
private void ThrowSchemaUpgradeRequired(int schemaVersionVal, string message);
    public void FillBase64Id(Guid databaseGuidId);
    [CompilerGeneratedAttribute]
public string get_Base64Id();
    private void CreateNewDatabase();
    public IFreeSpaceHandling get_FreeSpaceHandling();
    public HeaderAccessor get_HeaderAccessor();
    public long get_NextPageNumber();
    public StorageEnvironmentOptions get_Options();
    public WriteAheadJournal get_Journal();
    public DecompressionBuffersPool get_DecompressionBuffers();
    public sealed virtual void Dispose();
    private void MoveEnvironmentToDisposeState();
    [DoesNotReturnAttribute]
private void ThrowInvalidDisposeDuringActiveTransactions(List`1<ActiveTransaction> activeTxs);
    public Transaction ReadTransaction(TransactionPersistentContext transactionPersistentContext, ByteStringContext context);
    public Transaction ReadTransaction(ByteStringContext context);
    public Transaction CloneReadTransaction(Transaction previous, TransactionPersistentContext transactionPersistentContext, ByteStringContext context);
    public Transaction WriteTransaction(TransactionPersistentContext transactionPersistentContext, ByteStringContext context, Nullable`1<TimeSpan> timeout);
    public Transaction WriteTransaction(ByteStringContext context, Nullable`1<TimeSpan> timeout);
    internal LowLevelTransaction NewLowLevelTransaction(TransactionPersistentContext transactionPersistentContext, TransactionFlags flags, ByteStringContext context, Nullable`1<TimeSpan> timeout);
    internal void InvokeNewTransactionCreated(LowLevelTransaction tx);
    internal void InvokeAfterCommitWhenNewTransactionsPrevented(LowLevelTransaction tx);
    [ConditionalAttribute("DEBUG")]
private void ThrowOnWriteTransactionOpenedByTheSameThread();
    internal void IncrementUsageOnNewTransaction();
    internal void DecrementUsageOnTransactionCreationFailure();
    [DoesNotReturnAttribute]
private void ThrowCurrentlyDisposing();
    [DoesNotReturnAttribute]
private void ThrowCommittedAndFlushedTransactionNotFoundInActiveOnes(LowLevelTransaction llt);
    internal void WriteTransactionStarted();
    private void ThrowOnTimeoutWaitingForWriteTxLock(TimeSpan wait);
    [DoesNotReturnAttribute]
private void ThrowOnTimeoutWaitingForReadFlushingInProgressLock(TimeSpan wait);
    public long get_CurrentReadTransactionId();
    public long get_NextWriteTransactionId();
    public CancellationToken get_Token();
    public long PossibleOldestReadTransaction(LowLevelTransaction tx);
    internal ExitWriteLock PreventNewTransactions();
    internal bool get_IsInPreventNewTransactionsMode();
    internal bool TryPreventNewTransactions(TimeSpan timeout, IDisposable& exitWriteLock);
    [CompilerGeneratedAttribute]
public void add_NewTransactionCreated(Action`1<LowLevelTransaction> value);
    [CompilerGeneratedAttribute]
public void remove_NewTransactionCreated(Action`1<LowLevelTransaction> value);
    [CompilerGeneratedAttribute]
public void add_AfterCommitWhenNewTransactionsPrevented(Action`1<LowLevelTransaction> value);
    [CompilerGeneratedAttribute]
public void remove_AfterCommitWhenNewTransactionsPrevented(Action`1<LowLevelTransaction> value);
    internal void TransactionAfterCommit(LowLevelTransaction tx);
    internal void TransactionCompleted(LowLevelTransaction tx);
    public SizeReport GenerateSizeReport(bool includeTempBuffers);
    private long GetNumberOfAllocatedPages();
    public StorageReport GenerateReport(Transaction tx);
    public DetailedStorageReport GenerateDetailedReport(Transaction tx, bool includeDetails);
    public Dictionary`2<long, string> GetPageOwners(Transaction tx, Func`2<PostingList, List`1<long>> onPostingList);
    public DetailedReportInput CreateDetailedReportInput(Transaction tx, bool includeDetails);
    public InMemoryStorageState GetInMemoryStorageState(LowLevelTransaction tx);
    private Size GetTotalCryptoBufferSize();
    public EnvironmentStats Stats();
    internal void BackgroundFlushWritesToDataFile();
    public void FlushLogToDataFile();
    internal void HandleDataDiskFullException(DiskFullException exception);
    public void ValidateInMemoryPageChecksum(long pageNumber, PageHeader* current);
    public void ValidatePageChecksum(long pageNumber, PageHeader* current);
    private void UnlikelyValidatePage(long pageNumber, PageHeader* current, long index, long old, long bitToSet);
    [DoesNotReturnAttribute]
private static void ThrowInvalidPageNumber(long pageNumber, PageHeader* current);
    [DoesNotReturnAttribute]
private void ThrowInvalidChecksum(long pageNumber, PageHeader* current, ulong checksum);
    public static ulong CalculatePageChecksum(Byte* ptr, long pageNumber, UInt64& expectedChecksum);
    public static ulong CalculatePageChecksum(Byte* ptr, long pageNumber, PageFlags flags, int overflowSize);
    public void Cleanup(bool tryCleanupRecycledJournals);
    public void CleanupMappedMemory();
    public virtual string ToString();
    public void LogsApplied();
    public void ResetLastWorkTime();
    internal void AllowDisposeWithLazyTransactionRunning(LowLevelTransaction tx);
    [DoesNotReturnAttribute]
private static void ThrowSimulateFailureOnDbCreation();
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
internal PersistentDictionaryLocator get_DictionaryLocator();
    public PersistentDictionary CreateEncodingDictionary(Page dictionaryPage);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <NewLowLevelTransaction>b__85_0();
    [CompilerGeneratedAttribute]
internal static void <GetPageOwners>g__RegisterPages|120_0(List`1<long> allPages, string name, <>c__DisplayClass120_0& );
    [CompilerGeneratedAttribute]
internal static Tree <GetPageOwners>g__GetTableTree|120_1(Tree tableTree, TableSchema tableSchema, Slice treeName, <>c__DisplayClass120_0& );
    [CompilerGeneratedAttribute]
internal static void <GetPageOwners>g__RegisterTableSection|120_2(Tree tableTree, string name, Slice sectionName, <>c__DisplayClass120_0& );
    [CompilerGeneratedAttribute]
internal static void <GetPageOwners>g__RegisterContainer|120_3(long container, string name, <>c__DisplayClass120_0& );
    [CompilerGeneratedAttribute]
internal static void <GetPageOwners>g__RegisterLookup|120_4(Lookup`1<Int64LookupKey> numeric, string name, <>c__DisplayClass120_0& );
}
public abstract class Voron.StorageEnvironmentOptions : object {
    public static string RecyclableJournalFileNamePrefix;
    private ExceptionDispatchInfo _catastrophicFailure;
    private string _catastrophicFailureStack;
    [ThreadStaticAttribute]
private static bool _skipCatastrophicFailureAssertion;
    private CatastrophicFailureNotification _catastrophicFailureNotification;
    private ConcurrentSet`1<CryptoPager> _activeCryptoPagers;
    [CompilerGeneratedAttribute]
private VoronPathSetting <TempPath>k__BackingField;
    [CompilerGeneratedAttribute]
private VoronPathSetting <JournalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IoMetrics <IoMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateNewDatabaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private LazyWithExceptionRetry`1<DriveInfoByPath> <DriveInfoByPath>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<RecoveryErrorEventArgs> OnRecoveryError;
    [CompilerGeneratedAttribute]
private EventHandler`1<NonDurabilitySupportEventArgs> OnNonDurableFileSystemError;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataIntegrityErrorEventArgs> OnIntegrityErrorOfAlreadySyncedData;
    [CompilerGeneratedAttribute]
private EventHandler`1<RecoverableFailureEventArgs> OnRecoverableFailure;
    private long _reuseCounter;
    private long _lastReusedJournalCountOnSync;
    private bool _forceUsing32BitsPager;
    public bool EnablePrefetching;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <InitialFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageEncryptionOptions <Encryption>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UpgraderDelegate <SchemaUpgrader>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Transaction> <OnVersionReadingTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<StorageEnvironment> <BeforeSchemaUpgrade>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<StorageEnvironment> <AfterDatabaseCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private ScratchSpaceUsageMonitor <ScratchSpaceUsage>k__BackingField;
    public TimeSpan LongRunningFlushingWarning;
    [CompilerGeneratedAttribute]
private bool <OwnsPagers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ManualFlushing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncrementalBackupEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxNumberOfPagesInJournalBeforeFlush>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IdleFlushTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxStorageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopyOnWriteMode>k__BackingField;
    protected bool Disposed;
    private long _initialLogFileSize;
    private long _maxLogFileSize;
    [CompilerGeneratedAttribute]
private Func`2<string, bool> <ShouldUseKeyPrefix>k__BackingField;
    public Action`2<LogMode, string> AddToInitLog;
    [CompilerGeneratedAttribute]
private Action`1<StorageEnvironmentOptions> OnDirectoryInitialize;
    public bool DoNotConsiderMemoryLockFailureAsCatastrophicError;
    [CompilerGeneratedAttribute]
private DurabilityMode <SupportDurabilityFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DisposeWaitTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PrefetchSegmentSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PrefetchResetThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SyncJournalsCountThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SimulateFailureOnDbCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ManualSyncing>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IgnoreInvalidJournalErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipChecksumValidationOnDatabaseLoading>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfRecyclableJournals>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DiscardVirtualMemory>k__BackingField;
    private Logger _log;
    private SortedList`2<long, string> _journalsForReuse;
    private int _timeToSyncAfterFlushInSec;
    public long CompressTxAboveSizeInBytes;
    private Guid _environmentId;
    private long _maxScratchBufferSize;
    internal TestingStuff ForTestingPurposes;
    public VoronPathSetting TempPath { get; }
    public VoronPathSetting JournalPath { get; private set; }
    public IoMetrics IoMetrics { get; public set; }
    public bool GenerateNewDatabaseId { get; public set; }
    public LazyWithExceptionRetry`1<DriveInfoByPath> DriveInfoByPath { get; private set; }
    public bool ForceUsing32BitsPager { get; public set; }
    public Nullable`1<long> InitialFileSize { get; public set; }
    public long MaxLogFileSize { get; public set; }
    public long InitialLogFileSize { get; public set; }
    public StorageEncryptionOptions Encryption { get; }
    public int PageSize { get; }
    public int SchemaVersion { get; public set; }
    public UpgraderDelegate SchemaUpgrader { get; public set; }
    public Action`1<Transaction> OnVersionReadingTransaction { get; public set; }
    public Action`1<StorageEnvironment> BeforeSchemaUpgrade { get; public set; }
    public Action`1<StorageEnvironment> AfterDatabaseCreation { get; public set; }
    public ScratchSpaceUsageMonitor ScratchSpaceUsage { get; }
    public long MaxScratchBufferSize { get; public set; }
    public bool OwnsPagers { get; public set; }
    public bool ManualFlushing { get; public set; }
    public bool IncrementalBackupEnabled { get; public set; }
    public AbstractPager DataPager { get; }
    public long MaxNumberOfPagesInJournalBeforeFlush { get; public set; }
    public int IdleFlushTimeout { get; public set; }
    public Nullable`1<long> MaxStorageSize { get; public set; }
    public VoronPathSetting BasePath { get; }
    internal bool CopyOnWriteMode { get; internal set; }
    public Func`2<string, bool> ShouldUseKeyPrefix { get; public set; }
    public bool IsCatastrophicFailureSet { get; }
    public static bool RunningOnPosix { get; }
    public bool RunningOn32Bits { get; }
    public DurabilityMode SupportDurabilityFlags { get; public set; }
    public TimeSpan DisposeWaitTime { get; public set; }
    public int TimeToSyncAfterFlushInSec { get; public set; }
    public long PrefetchSegmentSize { get; public set; }
    public long PrefetchResetThreshold { get; public set; }
    public long SyncJournalsCountThreshold { get; public set; }
    internal bool SimulateFailureOnDbCreation { get; internal set; }
    internal bool ManualSyncing { get; internal set; }
    public Nullable`1<bool> IgnoreInvalidJournalErrors { get; public set; }
    public bool IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions { get; public set; }
    public bool SkipChecksumValidationOnDatabaseLoading { get; public set; }
    public int MaxNumberOfRecyclableJournals { get; public set; }
    public bool DiscardVirtualMemory { get; public set; }
    protected StorageEnvironmentOptions(VoronPathSetting tempPath, IoChangesNotifications ioChangesNotifications, CatastrophicFailureNotification catastrophicFailureNotification);
    [CompilerGeneratedAttribute]
public VoronPathSetting get_TempPath();
    [CompilerGeneratedAttribute]
public VoronPathSetting get_JournalPath();
    [CompilerGeneratedAttribute]
private void set_JournalPath(VoronPathSetting value);
    [CompilerGeneratedAttribute]
public IoMetrics get_IoMetrics();
    [CompilerGeneratedAttribute]
public void set_IoMetrics(IoMetrics value);
    [CompilerGeneratedAttribute]
public bool get_GenerateNewDatabaseId();
    [CompilerGeneratedAttribute]
public void set_GenerateNewDatabaseId(bool value);
    [CompilerGeneratedAttribute]
public LazyWithExceptionRetry`1<DriveInfoByPath> get_DriveInfoByPath();
    [CompilerGeneratedAttribute]
private void set_DriveInfoByPath(LazyWithExceptionRetry`1<DriveInfoByPath> value);
    [CompilerGeneratedAttribute]
public void add_OnRecoveryError(EventHandler`1<RecoveryErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnRecoveryError(EventHandler`1<RecoveryErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnNonDurableFileSystemError(EventHandler`1<NonDurabilitySupportEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnNonDurableFileSystemError(EventHandler`1<NonDurabilitySupportEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnIntegrityErrorOfAlreadySyncedData(EventHandler`1<DataIntegrityErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnIntegrityErrorOfAlreadySyncedData(EventHandler`1<DataIntegrityErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnRecoverableFailure(EventHandler`1<RecoverableFailureEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OnRecoverableFailure(EventHandler`1<RecoverableFailureEventArgs> value);
    public void SetLastReusedJournalCountOnSync(long journalNum);
    public abstract virtual string ToString();
    public bool get_ForceUsing32BitsPager();
    public void set_ForceUsing32BitsPager(bool value);
    internal DisposableAction DisableOnRecoveryErrorHandler();
    public void InvokeRecoveryError(object sender, string message, Exception e);
    internal DisposableAction DisableOnIntegrityErrorOfAlreadySyncedDataHandler();
    public void InvokeIntegrityErrorOfAlreadySyncedData(object sender, string message, Exception e);
    public void InvokeNonDurableFileSystemError(object sender, string message, Exception e, string details);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_InitialFileSize();
    [CompilerGeneratedAttribute]
public void set_InitialFileSize(Nullable`1<long> value);
    public long get_MaxLogFileSize();
    public void set_MaxLogFileSize(long value);
    public long get_InitialLogFileSize();
    public void set_InitialLogFileSize(long value);
    [DoesNotReturnAttribute]
private static void ThrowInitialLogFileSizeOutOfRange();
    [CompilerGeneratedAttribute]
public StorageEncryptionOptions get_Encryption();
    public int get_PageSize();
    [CompilerGeneratedAttribute]
public int get_SchemaVersion();
    [CompilerGeneratedAttribute]
public void set_SchemaVersion(int value);
    [CompilerGeneratedAttribute]
public UpgraderDelegate get_SchemaUpgrader();
    [CompilerGeneratedAttribute]
public void set_SchemaUpgrader(UpgraderDelegate value);
    [CompilerGeneratedAttribute]
public Action`1<Transaction> get_OnVersionReadingTransaction();
    [CompilerGeneratedAttribute]
public void set_OnVersionReadingTransaction(Action`1<Transaction> value);
    [CompilerGeneratedAttribute]
public Action`1<StorageEnvironment> get_BeforeSchemaUpgrade();
    [CompilerGeneratedAttribute]
public void set_BeforeSchemaUpgrade(Action`1<StorageEnvironment> value);
    [CompilerGeneratedAttribute]
public Action`1<StorageEnvironment> get_AfterDatabaseCreation();
    [CompilerGeneratedAttribute]
public void set_AfterDatabaseCreation(Action`1<StorageEnvironment> value);
    [CompilerGeneratedAttribute]
public ScratchSpaceUsageMonitor get_ScratchSpaceUsage();
    public long get_MaxScratchBufferSize();
    public void set_MaxScratchBufferSize(long value);
    [CompilerGeneratedAttribute]
public bool get_OwnsPagers();
    [CompilerGeneratedAttribute]
public void set_OwnsPagers(bool value);
    [CompilerGeneratedAttribute]
public bool get_ManualFlushing();
    [CompilerGeneratedAttribute]
public void set_ManualFlushing(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncrementalBackupEnabled();
    [CompilerGeneratedAttribute]
public void set_IncrementalBackupEnabled(bool value);
    public abstract virtual AbstractPager get_DataPager();
    [CompilerGeneratedAttribute]
public long get_MaxNumberOfPagesInJournalBeforeFlush();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfPagesInJournalBeforeFlush(long value);
    [CompilerGeneratedAttribute]
public int get_IdleFlushTimeout();
    [CompilerGeneratedAttribute]
public void set_IdleFlushTimeout(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxStorageSize();
    [CompilerGeneratedAttribute]
public void set_MaxStorageSize(Nullable`1<long> value);
    public abstract virtual VoronPathSetting get_BasePath();
    [CompilerGeneratedAttribute]
internal bool get_CopyOnWriteMode();
    [CompilerGeneratedAttribute]
internal void set_CopyOnWriteMode(bool value);
    public abstract virtual IJournalWriter CreateJournalWriter(long journalNumber, long journalSize);
    public abstract virtual VoronPathSetting GetJournalPath(long journalNumber);
    [CompilerGeneratedAttribute]
public Func`2<string, bool> get_ShouldUseKeyPrefix();
    [CompilerGeneratedAttribute]
public void set_ShouldUseKeyPrefix(Func`2<string, bool> value);
    [CompilerGeneratedAttribute]
public void add_OnDirectoryInitialize(Action`1<StorageEnvironmentOptions> value);
    [CompilerGeneratedAttribute]
public void remove_OnDirectoryInitialize(Action`1<StorageEnvironmentOptions> value);
    public void SetCatastrophicFailure(ExceptionDispatchInfo exception);
    public void InvokeRecoverableFailure(string failureMessage, Exception e);
    public bool get_IsCatastrophicFailureSet();
    internal void AssertNoCatastrophicFailure();
    public IDisposable SkipCatastrophicFailureAssertion();
    public static StorageEnvironmentOptions CreateMemoryOnly(string name, string tempPath, IoChangesNotifications ioChangesNotifications, CatastrophicFailureNotification catastrophicFailureNotification);
    public static StorageEnvironmentOptions CreateMemoryOnly();
    public static StorageEnvironmentOptions ForPath(string path, string tempPath, string journalPath, IoChangesNotifications ioChangesNotifications, CatastrophicFailureNotification catastrophicFailureNotification);
    public static StorageEnvironmentOptions ForPath(string path);
    private static string GetTempPath(string basePath);
    public static string JournalName(long number);
    public static string RecyclableJournalName(long number);
    public static string JournalRecoveryName(long number);
    public static string ScratchBufferName(long number);
    public sealed virtual void Dispose();
    public void NullifyHandlers();
    protected abstract virtual void Disposing();
    public abstract virtual bool JournalExists(long number);
    public abstract virtual bool TryDeleteJournal(long number);
    public abstract virtual bool ReadHeader(string filename, FileHeader* header);
    public abstract virtual void WriteHeader(string filename, FileHeader* header);
    public abstract virtual AbstractPager CreateScratchPager(string name, long initialSize);
    public abstract virtual AbstractPager CreateTemporaryBufferPager(string name, long initialSize);
    public abstract virtual AbstractPager OpenJournalPager(long journalNumber, JournalInfo journalInfo);
    public abstract virtual AbstractPager OpenPager(VoronPathSetting filename);
    public static bool get_RunningOnPosix();
    public bool get_RunningOn32Bits();
    [CompilerGeneratedAttribute]
public DurabilityMode get_SupportDurabilityFlags();
    [CompilerGeneratedAttribute]
public void set_SupportDurabilityFlags(DurabilityMode value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DisposeWaitTime();
    [CompilerGeneratedAttribute]
public void set_DisposeWaitTime(TimeSpan value);
    public int get_TimeToSyncAfterFlushInSec();
    public void set_TimeToSyncAfterFlushInSec(int value);
    [CompilerGeneratedAttribute]
public long get_PrefetchSegmentSize();
    [CompilerGeneratedAttribute]
public void set_PrefetchSegmentSize(long value);
    [CompilerGeneratedAttribute]
public long get_PrefetchResetThreshold();
    [CompilerGeneratedAttribute]
public void set_PrefetchResetThreshold(long value);
    [CompilerGeneratedAttribute]
public long get_SyncJournalsCountThreshold();
    [CompilerGeneratedAttribute]
public void set_SyncJournalsCountThreshold(long value);
    [CompilerGeneratedAttribute]
internal bool get_SimulateFailureOnDbCreation();
    [CompilerGeneratedAttribute]
internal void set_SimulateFailureOnDbCreation(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ManualSyncing();
    [CompilerGeneratedAttribute]
internal void set_ManualSyncing(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IgnoreInvalidJournalErrors();
    [CompilerGeneratedAttribute]
public void set_IgnoreInvalidJournalErrors(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions();
    [CompilerGeneratedAttribute]
public void set_IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipChecksumValidationOnDatabaseLoading();
    [CompilerGeneratedAttribute]
public void set_SkipChecksumValidationOnDatabaseLoading(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfRecyclableJournals();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfRecyclableJournals(int value);
    [CompilerGeneratedAttribute]
public bool get_DiscardVirtualMemory();
    [CompilerGeneratedAttribute]
public void set_DiscardVirtualMemory(bool value);
    public abstract virtual void TryStoreJournalForReuse(VoronPathSetting filename);
    public abstract virtual int GetNumberOfJournalsForReuse();
    private void TryDelete(string file);
    public void TryCleanupRecycledJournals();
    public void SetEnvironmentId(Guid environmentId);
    public void InvokeOnDirectoryInitialize();
    public void SetDurability();
    public void TrackCryptoPager(CryptoPager cryptoPager);
    public void UntrackCryptoPager(CryptoPager cryptoPager);
    internal TestingStuff ForTestingPurposesOnly();
    [CompilerGeneratedAttribute]
private void <.ctor>b__139_1(Guid id, string path, Exception e, string stacktrace);
    [CompilerGeneratedAttribute]
private void <AssertNoCatastrophicFailure>g__AssertNoCatastrophicFailureUnlikely|144_0();
}
public class Voron.StorageEnvironmentWithType : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageEnvironmentType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageEnvironment <Environment>k__BackingField;
    public Nullable`1<DateTime> LastIndexQueryTime;
    public string Name { get; public set; }
    public StorageEnvironmentType Type { get; public set; }
    public StorageEnvironment Environment { get; public set; }
    public StorageEnvironmentWithType(string name, StorageEnvironmentType type, StorageEnvironment environment);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public StorageEnvironmentType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(StorageEnvironmentType value);
    [CompilerGeneratedAttribute]
public StorageEnvironment get_Environment();
    [CompilerGeneratedAttribute]
public void set_Environment(StorageEnvironment value);
}
public enum Voron.TransactionFlags : Enum {
    public int value__;
    public static TransactionFlags Read;
    public static TransactionFlags ReadWrite;
}
[FlagsAttribute]
public enum Voron.TransactionPersistenceModeFlags : Enum {
    public int value__;
    public static TransactionPersistenceModeFlags Encrypted;
}
public class Voron.TransactionPersistentContext : object {
    private bool _longLivedTransaction;
    private Stack`1<PageLocator> _pageLocators;
    public bool LongLivedTransactions { get; public set; }
    public TransactionPersistentContext(bool longLivedTransactions);
    public bool get_LongLivedTransactions();
    public void set_LongLivedTransactions(bool value);
    public PageLocator AllocatePageLocator(LowLevelTransaction tx);
    public void FreePageLocator(PageLocator locator);
}
public class Voron.UpgraderDelegate : MulticastDelegate {
    public UpgraderDelegate(object object, IntPtr method);
    public virtual bool Invoke(SchemaUpgradeTransactions transactions, int currentVersion, Int32& versionAfterUpgrade);
    public virtual IAsyncResult BeginInvoke(SchemaUpgradeTransactions transactions, int currentVersion, Int32& versionAfterUpgrade, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Int32& versionAfterUpgrade, IAsyncResult result);
}
public class Voron.Util.ActiveTransactions : object {
    private RacyConcurrentBag _activeTxs;
    private long _oldestTransaction;
    public long OldestTransaction { get; }
    internal List`1<ActiveTransaction> AllTransactions { get; }
    internal List`1<LowLevelTransaction> AllTransactionsInstances { get; }
    public long get_OldestTransaction();
    public void Add(LowLevelTransaction tx);
    public void ForceRecheckingOldestTransactionByFlusherThread();
    public bool TryRemove(LowLevelTransaction tx);
    internal List`1<ActiveTransaction> get_AllTransactions();
    internal List`1<LowLevelTransaction> get_AllTransactionsInstances();
    public bool Contains(LowLevelTransaction tx);
}
[DefaultMemberAttribute("Item")]
public class Voron.Util.ContextBoundNativeList`1 : ValueType {
    private ByteStringContext _ctx;
    public bool HasContext;
    public NativeList`1<T> Inner;
    public T* RawItems { get; }
    public int Capacity { get; }
    public int Count { get; public set; }
    public bool IsValid { get; }
    public T& Item { get; }
    public ContextBoundNativeList`1(ByteStringContext ctx, int requestedSize);
    public T* get_RawItems();
    public int get_Capacity();
    public int get_Count();
    public void set_Count(int value);
    public bool get_IsValid();
    [IsReadOnlyAttribute]
public Span`1<T> ToSpan();
    public T& get_Item(int index);
    public bool TryAdd(T& l);
    public void Add(T& l);
    public void AddUnsafe(T& l);
    public T& AddByRefUnsafe();
    public void AddRange(ReadOnlySpan`1<T> range);
    public void AddRangeUnsafe(ReadOnlySpan`1<T> range);
    public void AddRangeUnsafe(T* range, int count);
    public void Shrink(int newSize);
    public void Initialize(int count);
    public void Grow(int addition);
    public int CopyTo(Span`1<T> destination, int startFrom);
    public void CopyTo(Span`1<T> destination, int startFrom, int count);
    [IsReadOnlyAttribute]
public void Sort();
    public void EnsureCapacityFor(int additionalItems);
    public bool HasCapacityFor(int itemsToAdd);
    public void ResetAndEnsureCapacity(int size);
    public sealed virtual void Dispose();
    public void Clear();
    public Enumerator<T> GetEnumerator();
}
public class Voron.Util.Conversion.BigEndianBitConverter : EndianBitConverter {
    public Endianness Endianness { get; }
    public virtual bool IsLittleEndian();
    public virtual Endianness get_Endianness();
    protected virtual void CopyBytesImpl(long value, int bytes, Byte[] buffer, int index);
    protected virtual long FromBytes(Byte[] value, int startIndex, int bytesToConvert);
    protected virtual long FromBytes(Byte* value, int bytesToConvert);
}
public abstract class Voron.Util.Conversion.EndianBitConverter : object {
    private static LittleEndianBitConverter little;
    private static BigEndianBitConverter big;
    public Endianness Endianness { get; }
    public static LittleEndianBitConverter Little { get; }
    public static BigEndianBitConverter Big { get; }
    private static EndianBitConverter();
    public abstract virtual bool IsLittleEndian();
    public abstract virtual Endianness get_Endianness();
    public static LittleEndianBitConverter get_Little();
    public static BigEndianBitConverter get_Big();
    public long DoubleToInt64Bits(double value);
    public double Int64BitsToDouble(long value);
    public int SingleToInt32Bits(float value);
    public float Int32BitsToSingle(int value);
    public bool ToBoolean(Byte[] value, int startIndex);
    public char ToChar(Byte[] value, int startIndex);
    public double ToDouble(Byte[] value, int startIndex);
    public float ToSingle(Byte[] value, int startIndex);
    public short ToInt16(Byte[] value, int startIndex);
    public int ToInt32(Byte[] value, int startIndex);
    public long ToInt64(Byte[] value, int startIndex);
    public long ToInt64(Byte* value);
    public ushort ToUInt16(Byte[] value, int startIndex);
    public UInt32 ToUInt32(Byte[] value, int startIndex);
    public ulong ToUInt64(Byte[] value, int startIndex);
    private static void CheckByteArgument(Byte[] value, int startIndex, int bytesRequired);
    private long CheckedFromBytes(Byte[] value, int startIndex, int bytesToConvert);
    protected abstract virtual long FromBytes(Byte[] value, int startIndex, int bytesToConvert);
    protected abstract virtual long FromBytes(Byte* value, int bytesToConvert);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static string ToString(Byte[] value, int startIndex, int length);
    public decimal ToDecimal(Byte[] value, int startIndex);
    public Byte[] GetBytes(decimal value);
    public void CopyBytes(decimal value, Byte[] buffer, int index);
    private Byte[] GetBytes(long value, int bytes);
    public Byte[] GetBytes(bool value);
    public Byte[] GetBytes(char value);
    public Byte[] GetBytes(double value);
    public Byte[] GetBytes(short value);
    public Byte[] GetBytes(int value);
    public Byte[] GetBytes(long value);
    public Byte[] GetBytes(float value);
    public Byte[] GetBytes(ushort value);
    public Byte[] GetBytes(UInt32 value);
    public Byte[] GetBytes(ulong value);
    private void CopyBytes(long value, int bytes, Byte[] buffer, int index);
    protected abstract virtual void CopyBytesImpl(long value, int bytes, Byte[] buffer, int index);
    public void CopyBytes(bool value, Byte[] buffer, int index);
    public void CopyBytes(char value, Byte[] buffer, int index);
    public void CopyBytes(double value, Byte[] buffer, int index);
    public void CopyBytes(short value, Byte[] buffer, int index);
    public void CopyBytes(int value, Byte[] buffer, int index);
    public void CopyBytes(long value, Byte[] buffer, int index);
    public void CopyBytes(float value, Byte[] buffer, int index);
    public void CopyBytes(ushort value, Byte[] buffer, int index);
    public void CopyBytes(UInt32 value, Byte[] buffer, int index);
    public void CopyBytes(ulong value, Byte[] buffer, int index);
}
public enum Voron.Util.Conversion.Endianness : Enum {
    public int value__;
    public static Endianness LittleEndian;
    public static Endianness BigEndian;
}
public class Voron.Util.Conversion.LittleEndianBitConverter : EndianBitConverter {
    public Endianness Endianness { get; }
    public virtual bool IsLittleEndian();
    public virtual Endianness get_Endianness();
    protected virtual void CopyBytesImpl(long value, int bytes, Byte[] buffer, int index);
    protected virtual long FromBytes(Byte[] value, int startIndex, int bytesToConvert);
    protected virtual long FromBytes(Byte* value, int bytesToConvert);
}
public class Voron.Util.DataCopier : object {
    private Byte[] _buffer;
    public DataCopier(int bufferSize);
    public void ToStream(Byte* ptr, long count, Stream output);
    public void ToStream(AbstractPager src, long startPage, long numberOfPages, Stream output, Action`1<string> infoNotify, CancellationToken cancellationToken);
    public void ToStream(StorageEnvironment env, JournalFile journal, long start4Kb, long numberOf4KbsToCopy, Stream output, Action`1<string> infoNotify, CancellationToken cancellationToken);
}
public class Voron.Util.DisposableAction : object {
    private Action _action;
    public DisposableAction(Action action);
    public sealed virtual void Dispose();
}
public class Voron.Util.EndOfDiskSpaceEvent : object {
    private long _availableSpaceWhenEventOccurred;
    private string _path;
    private ExceptionDispatchInfo _edi;
    public EndOfDiskSpaceEvent(string path, long availableSpaceWhenEventOccurred, ExceptionDispatchInfo edi);
    public void AssertCanContinueWriting();
}
[DefaultMemberAttribute("Item")]
public class Voron.Util.ImmutableAppendOnlyList`1 : object {
    private T[] _values;
    private int _head;
    private int _count;
    public static ImmutableAppendOnlyList`1<T> Empty;
    public T Item { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    private ImmutableAppendOnlyList`1(T[] values, int head, int count);
    private static ImmutableAppendOnlyList`1();
    public static ImmutableAppendOnlyList`1<T> CreateFrom(IEnumerable`1<T> items);
    public static ImmutableAppendOnlyList`1<T> Create(int initialCapacity);
    public sealed virtual T get_Item(int itemIndex);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    [IteratorStateMachineAttribute("Voron.Util.ImmutableAppendOnlyList`1/<GetEnumerator>d__14")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ImmutableAppendOnlyList`1<T> Append(T item);
    public ImmutableAppendOnlyList`1<T> AppendRange(IEnumerable`1<T> items);
    public ImmutableAppendOnlyList`1<T> RemoveFront(int nToRemove);
    public ImmutableAppendOnlyList`1<T> RemoveFront(int nToRemove, List`1<T> removed);
    public ImmutableAppendOnlyList`1<T> RemoveWhile(Predicate`1<T> shouldRemove, List`1<T> removed);
    private T[] GrowTo(int newLength);
    private static void CopyArray(IEnumerable`1<T> source, T[] dest, int destOffset, int count);
    private static void CopyList(IEnumerable`1<T> source, T[] dest, int destOffset, int count);
    private static void CopyEnumerable(IEnumerable`1<T> source, T[] dest, int destOffset, int count);
}
[DefaultMemberAttribute("Item")]
public class Voron.Util.NativeList`1 : ValueType {
    private ByteString _storage;
    public int Count;
    public T* RawItems { get; }
    public int Capacity { get; }
    public bool IsValid { get; }
    public T& Item { get; }
    public T* get_RawItems();
    public int get_Capacity();
    [IsReadOnlyAttribute]
public Span`1<T> ToSpan();
    public bool get_IsValid();
    public T& get_Item(int index);
    public bool TryAdd(T& l);
    public bool TryAddRange(ReadOnlySpan`1<T> values);
    public void Add(ByteStringContext ctx, T value);
    public void InitializeWithValue(ByteStringContext allocator, T value, int count);
    public void AddRangeUnsafe(ReadOnlySpan`1<T> range);
    public void AddRangeUnsafe(T* items, int count);
    public void AddUnsafe(T& l);
    public T& AddByRefUnsafe();
    public void Shrink(int newSize);
    public void Initialize(ByteStringContext ctx, int count);
    public void Grow(ByteStringContext ctx, int addition);
    [IsReadOnlyAttribute]
public void Sort();
    public void EnsureCapacityFor(ByteStringContext allocator, int additionalItems);
    public bool HasCapacityFor(int itemsToAdd);
    public void ResetAndEnsureCapacity(ByteStringContext ctx, int size);
    public int CopyTo(Span`1<T> destination, int startFrom);
    public void CopyTo(Span`1<T> destination, int startFrom, int count);
    public void Dispose(ByteStringContext ctx);
    public void Clear();
    public Enumerator<T> GetEnumerator();
}
public class Voron.Util.PageTable : object {
    private ConcurrentDictionary`2<long, PagesBuffer> _values;
    private SortedList`2<long, Dictionary`2<long, PagePosition>> _transactionPages;
    private long _maxSeenTransaction;
    public bool IsEmpty { get; }
    public void Clear();
    public bool get_IsEmpty();
    public void SetItems(LowLevelTransaction tx, Dictionary`2<long, PagePosition> items);
    private void UpdateMaxSeenTxId(LowLevelTransaction tx);
    public void RemoveKeysWhereAllPagesOlderThan(long lastSyncedTransactionId, FastList`1<PagePosition> unusedPages);
    public bool TryGetValue(LowLevelTransaction tx, long page, PagePosition& value);
    public long MaxTransactionId();
    public long GetLastSeenTransactionId();
    public List`1<Dictionary`2<long, PagePosition>> GetModifiedPagesForTransactionRange(long minTxInclusive, long maxTxInclusive);
}
public static class Voron.Util.PFor.BitPacking : object {
    public static int UnpackSegmented(Byte* inputBuf, int count, UInt32* outputBuf, UInt32 bit);
    public static int PackSegmented(UInt32* inputBuf, int length, Byte* outputBuf, UInt32 bit);
    public static int RequireSizeSegmented(int len, int bits);
}
public class Voron.Util.PFor.FastPForBufferedReader : ValueType {
    private Int64* _buffer;
    private int _bufferIdx;
    private int _usedBuffer;
    private ByteStringContext _allocator;
    public FastPForDecoder Decoder;
    private InternalScope<ByteStringMemoryCache> _bufferScope;
    private static int InternalBufferSize;
    public bool IsValid { get; }
    public bool WasInitialized { get; }
    public FastPForBufferedReader(ByteStringContext allocator);
    public FastPForBufferedReader(ByteStringContext allocator, Byte* p, int len);
    public bool get_IsValid();
    public bool get_WasInitialized();
    public void Init(Byte* p, int len);
    public int Fill(Int64* matches, int count);
    public sealed virtual void Dispose();
}
public class Voron.Util.PFor.FastPForDecoder : ValueType {
    private static int PrefixSizeBits;
    private ByteStringContext _allocator;
    private Byte* _input;
    private Byte* _metadata;
    private Byte* _end;
    private UInt32* _exceptions;
    [FixedBufferAttribute("System.Int32", "33")]
private <_exceptionOffsets>e__FixedBuffer _exceptionOffsets;
    private int _prefixShiftAmount;
    private ushort _sharedPrefix;
    private InternalScope<ByteStringMemoryCache> _exceptionsScope;
    private Vector256`1<long> _prev;
    private ByteString _buffer;
    public bool IsValid { get; }
    private int NumberOfIntegersInBuffer { get; }
    public FastPForDecoder(ByteStringContext allocator);
    public bool get_IsValid();
    private int get_NumberOfIntegersInBuffer();
    public void MarkInvalid();
    public void Init(Byte* input, int size);
    private void GrowAllocation(int sizeInElements);
    [SkipLocalsInitAttribute]
public int Read(Int64* output, int outputCount);
    public sealed virtual void Dispose();
    public static long ReadStart(Byte* p);
    [CompilerGeneratedAttribute]
internal static Vector256`1<ulong> <Read>g__GetDeltaHighBits|20_1(Int32& index, <>c__DisplayClass20_0& , <>c__DisplayClass20_1& );
    [CompilerGeneratedAttribute]
internal static void <Read>g__PrefixSumAndStoreToOutput|20_0(Vector256`1<ulong> curUl, Vector256`1& prev, <>c__DisplayClass20_0& );
}
public class Voron.Util.PFor.FastPForEncoder : object {
    public static byte VarIntBatchMarker;
    public static byte BiggerThanMaxMarker;
    private ByteStringContext _allocator;
    internal static int PrefixSizeBits;
    private Int64* _entries;
    private Byte* _entriesOutput;
    private long _entriesOutputSize;
    private int _count;
    private int _offset;
    private ushort _sharedPrefix;
    private List`1[] _exceptions;
    private Int32[] _exceptionsStart;
    private List`1<byte> _metadata;
    private int _metadataPos;
    private InternalScope<ByteStringMemoryCache> _entriesOutputScope;
    public bool Done { get; }
    public long NextValueToEncode { get; }
    public FastPForEncoder(ByteStringContext allocator);
    [ConditionalAttribute("DEBUG")]
private static void AssertIsSorted(Int64* entries, int count);
    public int Encode(Int64* entries, int count);
    public static int ComputeVarIntDeltaSize(long previous, Int64* buffer, int count);
    public bool get_Done();
    public ValueTuple`2<int, int> Write(Byte* output, int outputSize);
    public long get_NextValueToEncode();
    private int WriteLastBatchAsVarIntDelta(int count, Byte* output, int outputSize);
    private int ProcessBlock(UInt32* currentEntries);
    private static ValueTuple`3<int, int, int> FindBestBitWidths(UInt32* entries);
    private ushort RemoveSharedPrefix();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Encode>g__HandleDeltaGreaterThanMax|17_0(int batchOffset, Vector256`1<long> delta);
    [CompilerGeneratedAttribute]
private bool <Write>g__BufferWillOverflow|21_0(int additionalSize, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
private ushort <RemoveSharedPrefix>g__NoSharedPrefix|27_0();
}
public interface Voron.Util.PFor.ISimdTransform {
    public abstract virtual Vector256`1<UInt32> Encode(Vector256`1<UInt32> curr, Vector256`1& prev);
    public abstract virtual Vector256`1<UInt32> Decode(Vector256`1<UInt32> curr, Vector256`1& prev);
}
public class Voron.Util.PFor.MaskEntries : ValueType {
    private Vector256`1<UInt32> _mask;
    public MaskEntries(UInt32 mask);
    public sealed virtual Vector256`1<UInt32> Decode(Vector256`1<UInt32> curr, Vector256`1& prev);
    public sealed virtual Vector256`1<UInt32> Encode(Vector256`1<UInt32> curr, Vector256`1& prev);
}
public class Voron.Util.PFor.NoTransform : ValueType {
    public sealed virtual Vector256`1<UInt32> Decode(Vector256`1<UInt32> curr, Vector256`1& prev);
    public sealed virtual Vector256`1<UInt32> Encode(Vector256`1<UInt32> curr, Vector256`1& prev);
}
public class Voron.Util.PFor.PForHeader : ValueType {
    public long Baseline;
    public UInt32 ExceptionsBitmap;
    public ushort MetadataOffset;
    public ushort ExceptionsOffset;
    public ushort SharedPrefix;
}
public static class Voron.Util.PFor.ScalarBitPacking : object {
    public static void MaskedPack32(Int32* input, Int32* output, int bit);
    private static void fastpack0(Int32* input, Int32* output);
    private static void fastpack1(Int32* input, Int32* output);
    private static void fastpack10(Int32* input, Int32* output);
    private static void fastpack11(Int32* input, Int32* output);
    private static void fastpack12(Int32* input, Int32* output);
    private static void fastpack13(Int32* input, Int32* output);
    private static void fastpack14(Int32* input, Int32* output);
    private static void fastpack15(Int32* input, Int32* output);
    private static void fastpack16(Int32* input, Int32* output);
    private static void fastpack17(Int32* input, Int32* output);
    private static void fastpack18(Int32* input, Int32* output);
    private static void fastpack19(Int32* input, Int32* output);
    private static void fastpack2(Int32* input, Int32* output);
    private static void fastpack20(Int32* input, Int32* output);
    private static void fastpack21(Int32* input, Int32* output);
    private static void fastpack22(Int32* input, Int32* output);
    private static void fastpack23(Int32* input, Int32* output);
    private static void fastpack24(Int32* input, Int32* output);
    private static void fastpack25(Int32* input, Int32* output);
    private static void fastpack26(Int32* input, Int32* output);
    private static void fastpack27(Int32* input, Int32* output);
    private static void fastpack28(Int32* input, Int32* output);
    private static void fastpack29(Int32* input, Int32* output);
    private static void fastpack3(Int32* input, Int32* output);
    private static void fastpack30(Int32* input, Int32* output);
    private static void fastpack31(Int32* input, Int32* output);
    private static void fastpack32(Int32* input, Int32* output);
    private static void fastpack4(Int32* input, Int32* output);
    private static void fastpack5(Int32* input, Int32* output);
    private static void fastpack6(Int32* input, Int32* output);
    private static void fastpack7(Int32* input, Int32* output);
    private static void fastpack8(Int32* input, Int32* output);
    private static void fastpack9(Int32* input, Int32* output);
    public static void Pack32(Int32* input, Int32* output, int bit);
    private static void fastpackwithoutmask0(Int32* input, Int32* output);
    private static void fastpackwithoutmask1(Int32* input, Int32* output);
    private static void fastpackwithoutmask10(Int32* input, Int32* output);
    private static void fastpackwithoutmask11(Int32* input, Int32* output);
    private static void fastpackwithoutmask12(Int32* input, Int32* output);
    private static void fastpackwithoutmask13(Int32* input, Int32* output);
    private static void fastpackwithoutmask14(Int32* input, Int32* output);
    private static void fastpackwithoutmask15(Int32* input, Int32* output);
    private static void fastpackwithoutmask16(Int32* input, Int32* output);
    private static void fastpackwithoutmask17(Int32* input, Int32* output);
    private static void fastpackwithoutmask18(Int32* input, Int32* output);
    private static void fastpackwithoutmask19(Int32* input, Int32* output);
    private static void fastpackwithoutmask2(Int32* input, Int32* output);
    private static void fastpackwithoutmask20(Int32* input, Int32* output);
    private static void fastpackwithoutmask21(Int32* input, Int32* output);
    private static void fastpackwithoutmask22(Int32* input, Int32* output);
    private static void fastpackwithoutmask23(Int32* input, Int32* output);
    private static void fastpackwithoutmask24(Int32* input, Int32* output);
    private static void fastpackwithoutmask25(Int32* input, Int32* output);
    private static void fastpackwithoutmask26(Int32* input, Int32* output);
    private static void fastpackwithoutmask27(Int32* input, Int32* output);
    private static void fastpackwithoutmask28(Int32* input, Int32* output);
    private static void fastpackwithoutmask29(Int32* input, Int32* output);
    private static void fastpackwithoutmask3(Int32* input, Int32* output);
    private static void fastpackwithoutmask30(Int32* input, Int32* output);
    private static void fastpackwithoutmask31(Int32* input, Int32* output);
    private static void fastpackwithoutmask32(Int32* input, Int32* output);
    private static void fastpackwithoutmask4(Int32* input, Int32* output);
    private static void fastpackwithoutmask5(Int32* input, Int32* output);
    private static void fastpackwithoutmask6(Int32* input, Int32* output);
    private static void fastpackwithoutmask7(Int32* input, Int32* output);
    private static void fastpackwithoutmask8(Int32* input, Int32* output);
    private static void fastpackwithoutmask9(Int32* input, Int32* output);
    public static void Unpack32(Int32* input, Int32* output, int bit);
    private static void fastunpack0(Int32* input, Int32* output);
    private static void fastunpack1(Int32* input, Int32* output);
    private static void fastunpack10(Int32* input, Int32* output);
    private static void fastunpack11(Int32* input, Int32* output);
    private static void fastunpack12(Int32* input, Int32* output);
    private static void fastunpack13(Int32* input, Int32* output);
    private static void fastunpack14(Int32* input, Int32* output);
    private static void fastunpack15(Int32* input, Int32* output);
    private static void fastunpack16(Int32* input, Int32* output);
    private static void fastunpack17(Int32* input, Int32* output);
    private static void fastunpack18(Int32* input, Int32* output);
    private static void fastunpack19(Int32* input, Int32* output);
    private static void fastunpack2(Int32* input, Int32* output);
    private static void fastunpack20(Int32* input, Int32* output);
    private static void fastunpack21(Int32* input, Int32* output);
    private static void fastunpack22(Int32* input, Int32* output);
    private static void fastunpack23(Int32* input, Int32* output);
    private static void fastunpack24(Int32* input, Int32* output);
    private static void fastunpack25(Int32* input, Int32* output);
    private static void fastunpack26(Int32* input, Int32* output);
    private static void fastunpack27(Int32* input, Int32* output);
    private static void fastunpack28(Int32* input, Int32* output);
    private static void fastunpack29(Int32* input, Int32* output);
    private static void fastunpack3(Int32* input, Int32* output);
    private static void fastunpack30(Int32* input, Int32* output);
    private static void fastunpack31(Int32* input, Int32* output);
    private static void fastunpack32(Int32* input, Int32* output);
    private static void fastunpack4(Int32* input, Int32* output);
    private static void fastunpack5(Int32* input, Int32* output);
    private static void fastunpack6(Int32* input, Int32* output);
    private static void fastunpack7(Int32* input, Int32* output);
    private static void fastunpack8(Int32* input, Int32* output);
    private static void fastunpack9(Int32* input, Int32* output);
}
public class Voron.Util.PFor.SimdBitPacking`1 : ValueType {
    public static int PackSmall(UInt32 initValue, Span`1<UInt32> inputBuf, Span`1<byte> outputBuf, UInt32 bit, TSimdDiff transform);
    public static int UnpackSmall(UInt32 initValue, Span`1<byte> inputBuf, int length, Span`1<UInt32> outputBuf, UInt32 bit, TSimdDiff transform);
    public static int UnpackSmall(UInt32 initValue, Byte* inputBuf, int length, UInt32* outputBuf, UInt32 bit, TSimdDiff tranform);
    public static int PackSmall(UInt32 initValue, UInt32* inputBuf, int length, Byte* outputBuf, UInt32 bit, TSimdDiff tranform);
    public static void Unpack256(UInt32 initValue, Span`1<byte> inputBuf, Span`1<UInt32> output, UInt32 bit, TSimdDiff transform);
    public static void Unpack256(UInt32 initValue, Byte* inputBuf, UInt32* outputBuf, UInt32 bit, TSimdDiff transform);
    public static void Pack256(UInt32 initValue, Span`1<UInt32> inputBuf, Span`1<byte> output, UInt32 bit, TSimdDiff transform);
    public static void Pack256(UInt32 initValue, UInt32* inputBuf, Byte* outputBuf, UInt32 bit, TSimdDiff transform);
    public static UInt32 FindMaxBits(UInt32 initValue, Span`1<UInt32> data);
    public static UInt32 FindMaxBits(UInt32 initValue, UInt32* data, int len);
}
public class Voron.Util.PtrSize : ValueType {
    private static UInt32 ValueMask;
    public Byte* Ptr;
    public ulong Value;
    private UInt32 InternalSize;
    public int Size { get; }
    public bool IsValue { get; }
    private PtrSize(ulong value, UInt32 size);
    private PtrSize(Byte* ptr, UInt32 size);
    public int get_Size();
    public bool get_IsValue();
    public static PtrSize Create(T value);
    [DoesNotReturnAttribute]
private static void ThrowNotSupportedException();
    public static PtrSize Create(Void* ptr, int size);
}
public class Voron.Util.RacyConcurrentBag : object {
    private Node[] _array;
    private int _inUse;
    private int _growthFactor;
    private static LowLevelTransaction InvalidLowLevelTransaction;
    private MultipleUseFlag _compactionInProgress;
    public RacyConcurrentBag(int growthFactor);
    private static RacyConcurrentBag();
    [IteratorStateMachineAttribute("Voron.Util.RacyConcurrentBag/<Select>d__5`1")]
public IEnumerable`1<T> Select(Func`2<LowLevelTransaction, T> func);
    public List`1<LowLevelTransaction> ToList();
    public bool Remove(LowLevelTransaction tx);
    public void Add(LowLevelTransaction item);
    public long ScanOldest();
}
public class Voron.Util.Settings.MemoryVoronPathSetting : VoronPathSetting {
}
public abstract class Voron.Util.Settings.PathSettingBase`1 : object {
    protected PathSettingBase`1<T> _baseDataDir;
    protected string _path;
    protected string _fullPath;
    public string FullPath { get; }
    protected PathSettingBase`1(string path, PathSettingBase`1<T> baseDataDir);
    public static void ValidatePath(string path);
    public string get_FullPath();
    public abstract virtual T Combine(string path);
    public abstract virtual T Combine(T path);
    public string ToFullPath();
    public virtual string ToString();
    protected bool Equals(PathSettingBase`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Voron.Util.Settings.PathUtil : object {
    public static string ToFullPath(string inputPath, string baseDataDirFullPath);
    public static bool IsSubDirectory(string userPath, string rootPath);
}
public class Voron.Util.Settings.VoronPathSetting : PathSettingBase`1<VoronPathSetting> {
    public VoronPathSetting(string path, string baseDataDir);
    public virtual VoronPathSetting Combine(string path);
    public virtual VoronPathSetting Combine(VoronPathSetting path);
}
internal class Voron.Util.Simd.SimdPacking`1 : ValueType {
    public static Vector256`1<UInt32> iunpackFOR0(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR0(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR1(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR2(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR3(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR4(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR5(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR6(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR7(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR8(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR9(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR10(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR11(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR12(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR13(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR14(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR15(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR16(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR17(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR18(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR19(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR20(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR21(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR22(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR23(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR24(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR25(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR26(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR27(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR28(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR29(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR30(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR31(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void ipackFOR32(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR1(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR2(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR3(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR4(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR5(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR6(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR7(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR8(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR9(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR10(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR11(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR12(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR13(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR14(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR15(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR16(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR17(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR18(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR19(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR20(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR21(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR22(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR23(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR24(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR25(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR26(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR27(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR28(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR29(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR30(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR31(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
    public static void iunpackFOR32(Vector256`1<UInt32> initOffset, Vector256`1* input, Vector256`1* output, TTransform simdTransform);
}
public static class Voron.Util.TableValueReaderUtils : object {
    public static TableValueReader EmptyReader;
    private static TableValueReaderUtils();
}
public class Voron.Util.ThreadHoppingReaderWriterLock : object {
    private static UInt32 ReaderMask;
    private static int WriterMarker;
    private int _waiters;
    private SpinLock _readWaitLock;
    private ManualResetEventSlim _readerWait;
    private AutoResetEvent _writerWait;
    private int _writeLockOwnerThreadId;
    internal TestingStuff ForTestingPurposes;
    public bool IsWriteLockHeld { get; }
    public void EnterWriteLock();
    public bool get_IsWriteLockHeld();
    public void ExitWriteLock();
    public void ExitReadLock();
    public bool TryEnterReadLock(TimeSpan timeout);
    public bool TryEnterReadLock(int timeout);
    private bool TryEnterReadLockSlow(int timeout);
    private bool TryEnterReadLockCore();
    [DoesNotReturnAttribute]
private static void ThrowTooManyReaders(ulong waiters);
    [DoesNotReturnAttribute]
private static void ThrowInvalidWriteLockRelease();
    internal TestingStuff ForTestingPurposesOnly();
}
[ExtensionAttribute]
public static class Voron.Util.Utils : object {
    [ExtensionAttribute]
public static T[] Concat(T[] array, T next);
    [ExtensionAttribute]
public static T[] Concat(List`1<T> array, T next);
}
public class Voron.ValueReader : ValueType {
    [ThreadStaticAttribute]
private static Byte[] _tmpBuf;
    private int _pos;
    private int _len;
    [CompilerGeneratedAttribute]
private Byte* <Base>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Byte* Base { get; }
    public int Length { get; }
    public ValueReader(Byte* val, int len);
    private static ValueReader();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte* get_Base();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Length();
    public void Reset();
    public Stream AsStream();
    public int Read(Byte[] buffer, int offset, int count);
    public void Skip(int size);
    public int Read(Byte* buffer, int count);
    public int ReadLittleEndianInt32();
    public T ReadStructure();
    public long ReadLittleEndianInt64();
    public int ReadBigEndianInt32();
    public byte ReadByte();
    public long ReadBigEndianInt64();
    private Byte[] EnsureTempBuffer(int size);
    public string ReadString(int length);
    public string ToStringValue();
    public virtual string ToString();
    public ArraySegment`1<byte> ReadBytes(int length);
    public void CopyTo(Stream stream);
    public int CompareTo(ValueReader other);
    public InternalScope<ByteStringMemoryCache> AsSlice(ByteStringContext context, Slice& str);
    public Span`1<byte> AsSpan();
}
