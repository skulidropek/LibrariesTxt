[CompilerGeneratedAttribute]
internal static class Costura.AssemblyLoader : object {
    private static Dictionary`2<string, bool> nullCache;
    private static Dictionary`2<string, string> assemblyNames;
    private static Dictionary`2<string, string> symbolNames;
    private static Dictionary`2<string, object> currentlyLoading;
    private static object Locker;
    private static AssemblyLoader();
    public static Assembly ResolveAssembly(string assemblyName);
    private static string CultureToString(CultureInfo culture);
    private static Assembly ReadExistingAssembly(AssemblyName name);
    private static void CopyTo(Stream source, Stream destination);
    private static Stream LoadStream(string fullname);
    private static Stream LoadStream(Dictionary`2<string, string> resourceNames, string name);
    private static Byte[] ReadStream(Stream stream);
    private static Assembly ReadFromEmbeddedResources(Dictionary`2<string, string> assemblyNames, Dictionary`2<string, string> symbolNames, AssemblyName requestedAssemblyName);
    public static void Attach();
}
internal interface ProcessedByFody {
}
public class Raven.Abstractions.Cluster.ClusterInformation : object {
    public static ClusterInformation NotInCluster;
    [CompilerGeneratedAttribute]
private bool <IsInCluster>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WithClusterFailoverHeader>k__BackingField;
    public bool IsInCluster { get; public set; }
    public bool IsLeader { get; public set; }
    public bool WithClusterFailoverHeader { get; public set; }
    public ClusterInformation(bool isInCluster, bool isLeader, bool withClusterFailoverHeader);
    private static ClusterInformation();
    [CompilerGeneratedAttribute]
public bool get_IsInCluster();
    [CompilerGeneratedAttribute]
public void set_IsInCluster(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLeader();
    [CompilerGeneratedAttribute]
public void set_IsLeader(bool value);
    [CompilerGeneratedAttribute]
public bool get_WithClusterFailoverHeader();
    [CompilerGeneratedAttribute]
public void set_WithClusterFailoverHeader(bool value);
    protected bool Equals(ClusterInformation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Raven.Abstractions.Commands.DeleteCommandData : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionInformation <TransactionInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <AdditionalData>k__BackingField;
    public string Key { get; public set; }
    public string Method { get; }
    public Etag Etag { get; public set; }
    public TransactionInformation TransactionInformation { get; public set; }
    public RavenJObject Metadata { get; }
    public RavenJObject AdditionalData { get; public set; }
    [CompilerGeneratedAttribute]
public virtual string get_Key();
    [CompilerGeneratedAttribute]
public virtual void set_Key(string value);
    public sealed virtual string get_Method();
    [CompilerGeneratedAttribute]
public virtual Etag get_Etag();
    [CompilerGeneratedAttribute]
public virtual void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public sealed virtual TransactionInformation get_TransactionInformation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TransactionInformation(TransactionInformation value);
    public sealed virtual RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public sealed virtual RavenJObject get_AdditionalData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AdditionalData(RavenJObject value);
    public sealed virtual RavenJObject ToJson();
}
public interface Raven.Abstractions.Commands.ICommandData {
    public string Key { get; }
    public string Method { get; }
    public Etag Etag { get; }
    public TransactionInformation TransactionInformation { get; public set; }
    public RavenJObject Metadata { get; }
    public RavenJObject AdditionalData { get; public set; }
    public abstract virtual string get_Key();
    public abstract virtual string get_Method();
    public abstract virtual Etag get_Etag();
    public abstract virtual TransactionInformation get_TransactionInformation();
    public abstract virtual void set_TransactionInformation(TransactionInformation value);
    public abstract virtual RavenJObject get_Metadata();
    public abstract virtual RavenJObject get_AdditionalData();
    public abstract virtual void set_AdditionalData(RavenJObject value);
    public abstract virtual RavenJObject ToJson();
}
public class Raven.Abstractions.Commands.PatchCommandData : object {
    [CompilerGeneratedAttribute]
private PatchRequest[] <Patches>k__BackingField;
    [CompilerGeneratedAttribute]
private PatchRequest[] <PatchesIfMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipPatchIfEtagMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionInformation <TransactionInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <AdditionalData>k__BackingField;
    public PatchRequest[] Patches { get; public set; }
    public PatchRequest[] PatchesIfMissing { get; public set; }
    public bool SkipPatchIfEtagMismatch { get; public set; }
    public string Key { get; public set; }
    public string Method { get; }
    public Etag Etag { get; public set; }
    public TransactionInformation TransactionInformation { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public RavenJObject AdditionalData { get; public set; }
    [CompilerGeneratedAttribute]
public PatchRequest[] get_Patches();
    [CompilerGeneratedAttribute]
public void set_Patches(PatchRequest[] value);
    [CompilerGeneratedAttribute]
public PatchRequest[] get_PatchesIfMissing();
    [CompilerGeneratedAttribute]
public void set_PatchesIfMissing(PatchRequest[] value);
    [CompilerGeneratedAttribute]
public bool get_SkipPatchIfEtagMismatch();
    [CompilerGeneratedAttribute]
public void set_SkipPatchIfEtagMismatch(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    public sealed virtual string get_Method();
    [CompilerGeneratedAttribute]
public sealed virtual Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public sealed virtual TransactionInformation get_TransactionInformation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TransactionInformation(TransactionInformation value);
    [CompilerGeneratedAttribute]
public sealed virtual RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public sealed virtual RavenJObject get_AdditionalData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AdditionalData(RavenJObject value);
    public sealed virtual RavenJObject ToJson();
}
public class Raven.Abstractions.Commands.PutCommandData : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionInformation <TransactionInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <AdditionalData>k__BackingField;
    public string Key { get; public set; }
    public string Method { get; }
    public Etag Etag { get; public set; }
    public RavenJObject Document { get; public set; }
    public TransactionInformation TransactionInformation { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public RavenJObject AdditionalData { get; public set; }
    [CompilerGeneratedAttribute]
public virtual string get_Key();
    [CompilerGeneratedAttribute]
public virtual void set_Key(string value);
    public sealed virtual string get_Method();
    [CompilerGeneratedAttribute]
public virtual Etag get_Etag();
    [CompilerGeneratedAttribute]
public virtual void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public virtual RavenJObject get_Document();
    [CompilerGeneratedAttribute]
public virtual void set_Document(RavenJObject value);
    [CompilerGeneratedAttribute]
public sealed virtual TransactionInformation get_TransactionInformation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TransactionInformation(TransactionInformation value);
    [CompilerGeneratedAttribute]
public virtual RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public virtual void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public sealed virtual RavenJObject get_AdditionalData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AdditionalData(RavenJObject value);
    public sealed virtual RavenJObject ToJson();
}
public class Raven.Abstractions.Commands.ScriptedPatchCommandData : object {
    [CompilerGeneratedAttribute]
private ScriptedPatchRequest <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptedPatchRequest <PatchIfMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionInformation <TransactionInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugMode>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <AdditionalData>k__BackingField;
    public ScriptedPatchRequest Patch { get; public set; }
    public ScriptedPatchRequest PatchIfMissing { get; public set; }
    public string Key { get; public set; }
    public string Method { get; }
    public Etag Etag { get; public set; }
    public TransactionInformation TransactionInformation { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public bool DebugMode { get; public set; }
    public RavenJObject AdditionalData { get; public set; }
    [CompilerGeneratedAttribute]
public ScriptedPatchRequest get_Patch();
    [CompilerGeneratedAttribute]
public void set_Patch(ScriptedPatchRequest value);
    [CompilerGeneratedAttribute]
public ScriptedPatchRequest get_PatchIfMissing();
    [CompilerGeneratedAttribute]
public void set_PatchIfMissing(ScriptedPatchRequest value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    public sealed virtual string get_Method();
    [CompilerGeneratedAttribute]
public sealed virtual Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public sealed virtual TransactionInformation get_TransactionInformation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TransactionInformation(TransactionInformation value);
    [CompilerGeneratedAttribute]
public sealed virtual RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public bool get_DebugMode();
    [CompilerGeneratedAttribute]
public void set_DebugMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual RavenJObject get_AdditionalData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AdditionalData(RavenJObject value);
    public sealed virtual RavenJObject ToJson();
}
public class Raven.Abstractions.Connection.CompressedContent : HttpContent {
    private HttpContent originalContent;
    private string encodingType;
    public HttpContent OriginalContent { get; }
    public CompressedContent(HttpContent content, string encodingType);
    public HttpContent get_OriginalContent();
    protected virtual bool TryComputeLength(Int64& length);
    [AsyncStateMachineAttribute("Raven.Abstractions.Connection.CompressedContent/<SerializeToStreamAsync>d__6")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual void Dispose(bool disposing);
}
public class Raven.Abstractions.Connection.CompressedStringContent : HttpContent {
    private string data;
    private bool disableRequestCompression;
    public CompressedStringContent(string data, bool disableRequestCompression, string contentType);
    [AsyncStateMachineAttribute("Raven.Abstractions.Connection.CompressedStringContent/<SerializeToStreamAsync>d__3")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
}
public class Raven.Abstractions.Connection.CountingStream : Stream {
    private Stream inner;
    private Action`1<long> updateNumberOfWrittenBytes;
    private long numberOfWrittenBytes;
    private long numberOfReadBytes;
    private long position;
    public long NumberOfWrittenBytes { get; }
    public long NumberOfReadBytes { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CountingStream(Stream inner);
    public CountingStream(Stream inner, Action`1<long> updateNumberOfWrittenBytes);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Raven.Abstractions.Connection.CountingStream/<ReadAsync>d__11")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Raven.Abstractions.Connection.CountingStream/<WriteAsync>d__13")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public long get_NumberOfWrittenBytes();
    public long get_NumberOfReadBytes();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class Raven.Abstractions.Connection.ErrorResponseException : Exception {
    private HttpResponseMessage response;
    [CompilerGeneratedAttribute]
private string <ResponseString>k__BackingField;
    public HttpResponseMessage Response { get; }
    public HttpStatusCode StatusCode { get; }
    public string ResponseString { get; private set; }
    public Etag Etag { get; }
    public ErrorResponseException(ErrorResponseException e, string message);
    public ErrorResponseException(HttpResponseMessage response, string msg, Exception exception);
    public ErrorResponseException(HttpResponseMessage response, string msg, string responseString, Exception inner);
    protected ErrorResponseException(SerializationInfo info, StreamingContext context);
    public HttpResponseMessage get_Response();
    public HttpStatusCode get_StatusCode();
    public static ErrorResponseException FromResponseMessage(HttpResponseMessage response, bool readErrorString);
    [CompilerGeneratedAttribute]
public string get_ResponseString();
    [CompilerGeneratedAttribute]
private void set_ResponseString(string value);
    public Etag get_Etag();
    public static ErrorResponseException FromException(TaskCanceledException e);
    public static ErrorResponseException FromException(HttpRequestException e);
}
public class Raven.Abstractions.Connection.HttpRavenRequest : object {
    private string url;
    private HttpMethod httpMethod;
    private Action`2<RavenConnectionStringOptions, HttpWebRequest> configureRequest;
    private Func`3<RavenConnectionStringOptions, WebResponse, Action`1<HttpWebRequest>> handleUnauthorizedResponse;
    private RavenConnectionStringOptions connectionStringOptions;
    private Nullable`1<bool> allowWriteStreamBuffering;
    private HttpWebRequest webRequest;
    private Stream postedStream;
    private RavenJToken postedToken;
    private Byte[] postedData;
    private bool writeBson;
    [CompilerGeneratedAttribute]
private long <NumberOfBytesWrittenCompressed>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfBytesWrittenUncompressed>k__BackingField;
    public long NumberOfBytesWrittenCompressed { get; private set; }
    public long NumberOfBytesWrittenUncompressed { get; private set; }
    public HttpWebRequest WebRequest { get; public set; }
    public HttpRavenRequest(string url, HttpMethod httpMethod, Action`2<RavenConnectionStringOptions, HttpWebRequest> configureRequest, Func`3<RavenConnectionStringOptions, WebResponse, Action`1<HttpWebRequest>> handleUnauthorizedResponse, RavenConnectionStringOptions connectionStringOptions, Nullable`1<bool> allowWriteStreamBuffering);
    [CompilerGeneratedAttribute]
public long get_NumberOfBytesWrittenCompressed();
    [CompilerGeneratedAttribute]
private void set_NumberOfBytesWrittenCompressed(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfBytesWrittenUncompressed();
    [CompilerGeneratedAttribute]
private void set_NumberOfBytesWrittenUncompressed(long value);
    public HttpWebRequest get_WebRequest();
    public void set_WebRequest(HttpWebRequest value);
    private HttpWebRequest CreateRequest();
    public void Write(Stream streamToWrite);
    public void Write(RavenJToken ravenJToken);
    public void Write(Byte[] data);
    public void WriteBson(RavenJToken ravenJToken);
    private void WriteToken(WebRequest httpWebRequest);
    public T ExecuteRequest();
    public void ExecuteRequest(Action`1<TextReader> action);
    public void ExecuteRequest(Action`1<Stream> action);
    public void ExecuteRequest();
    public void ExecuteRequest(CancellationToken cancellationToken);
    private void SendRequestToServer(Action`1<WebResponse> action);
    private bool HandleUnauthorizedResponse(WebResponse unauthorizedResponse);
    private void RecreateWebRequest(Action`1<HttpWebRequest> action);
    [CompilerGeneratedAttribute]
private void <Write>b__24_0(long l);
    [CompilerGeneratedAttribute]
private void <Write>b__24_1(long l);
    [CompilerGeneratedAttribute]
private void <Write>b__26_0(long l);
    [CompilerGeneratedAttribute]
private void <Write>b__26_1(long l);
    [CompilerGeneratedAttribute]
private void <WriteToken>b__28_0(long l);
    [CompilerGeneratedAttribute]
private void <WriteToken>b__28_1(long l);
    [CompilerGeneratedAttribute]
private void <ExecuteRequest>b__33_0();
}
[ObsoleteAttribute]
public class Raven.Abstractions.Connection.HttpRavenRequestFactory : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RequestTimeoutInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    private ConcurrentDictionary`2<Tuple`2<string, string>, AbstractAuthenticator> authenticators;
    private static bool setSecurityProtocol;
    public Nullable`1<int> RequestTimeoutInMs { get; public set; }
    public X509Certificate2 Certificate { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RequestTimeoutInMs();
    [CompilerGeneratedAttribute]
public void set_RequestTimeoutInMs(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(X509Certificate2 value);
    public void ConfigureRequest(RavenConnectionStringOptions options, HttpWebRequest request);
    private static Tuple`2<string, string> GetCacheKey(RavenConnectionStringOptions options);
    public HttpRavenRequest Create(string url, HttpMethod httpMethod, RavenConnectionStringOptions connectionStringOptions, Nullable`1<bool> allowWriteStreamBuffering);
    private Action`1<HttpWebRequest> HandleUnauthorizedResponse(RavenConnectionStringOptions options, WebResponse webResponse);
    public static IDisposable Expect100Continue(string url);
}
public class Raven.Abstractions.Connection.HttpRequestHelper : object {
    public static void WriteDataToRequest(HttpWebRequest req, string data, bool disableCompression);
    public static void CopyHeaders(HttpWebRequest src, HttpWebRequest dest);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Connection.HttpResponseHeadersExtensions : object {
    [ExtensionAttribute]
public static string GetFirstValue(HttpHeaders headers, string name);
    [ExtensionAttribute]
public static String[] GetAllValues(HttpHeaders headers, string name);
}
public class Raven.Abstractions.Connection.JsonContent : HttpContent {
    private static Encoding DefaultEncoding;
    [CompilerGeneratedAttribute]
private RavenJToken <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Jsonp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOutputHumanReadable>k__BackingField;
    public RavenJToken Data { get; public set; }
    public string Jsonp { get; public set; }
    public bool IsOutputHumanReadable { get; public set; }
    public JsonContent(RavenJToken data);
    private static JsonContent();
    [CompilerGeneratedAttribute]
public RavenJToken get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(RavenJToken value);
    [CompilerGeneratedAttribute]
public string get_Jsonp();
    [CompilerGeneratedAttribute]
public void set_Jsonp(string value);
    [CompilerGeneratedAttribute]
public bool get_IsOutputHumanReadable();
    [CompilerGeneratedAttribute]
public void set_IsOutputHumanReadable(bool value);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    private bool HasNoData();
    protected virtual bool TryComputeLength(Int64& length);
    public JsonContent WithRequest(HttpRequestMessage request);
}
public static class Raven.Abstractions.Connection.OAuthHelper : object {
    [ThreadStaticAttribute]
private static IHashEncryptor sha1;
    public static string Hash(string data);
    public static string EncryptAsymmetric(Byte[] exponent, Byte[] modulus, string data);
    private static Byte[] AddEncryptedKeyAndIv(Byte[] exponent, Byte[] modulus, Byte[] key, Byte[] iv);
    public static Dictionary`2<string, string> ParseDictionary(string data);
    public static string DictionaryToString(Dictionary`2<string, string> data);
    public static Byte[] ParseBytes(string data);
    public static string BytesToString(Byte[] data);
}
public class Raven.Abstractions.Connection.OperationCredentials : object {
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    public ICredentials Credentials { get; private set; }
    public string ApiKey { get; private set; }
    public OperationCredentials(string apiKey, ICredentials credentials);
    [CompilerGeneratedAttribute]
public ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
private void set_Credentials(ICredentials value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
private void set_ApiKey(string value);
    public bool HasCredentials();
    protected bool Equals(OperationCredentials other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.Connection.WebRequestEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private HttpClient <Client>k__BackingField;
    [CompilerGeneratedAttribute]
private WebRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationCredentials <Credentials>k__BackingField;
    public HttpClient Client { get; public set; }
    public WebRequest Request { get; public set; }
    public OperationCredentials Credentials { get; public set; }
    [CompilerGeneratedAttribute]
public HttpClient get_Client();
    [CompilerGeneratedAttribute]
public void set_Client(HttpClient value);
    [CompilerGeneratedAttribute]
public WebRequest get_Request();
    [CompilerGeneratedAttribute]
public void set_Request(WebRequest value);
    [CompilerGeneratedAttribute]
public OperationCredentials get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(OperationCredentials value);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Connection.WebResponseExtensions : object {
    [ExtensionAttribute]
public static Stream GetResponseStreamWithHttpDecompression(WebResponse response);
    [AsyncStateMachineAttribute("Raven.Abstractions.Connection.WebResponseExtensions/<GetResponseStreamWithHttpDecompression>d__1")]
[ExtensionAttribute]
public static Task`1<Stream> GetResponseStreamWithHttpDecompression(HttpResponseMessage response);
}
public class Raven.Abstractions.Counters.Counter : object {
    [CompilerGeneratedAttribute]
private List`1<ServerValue> <ServerValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <LocalServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <LastUpdateByServer>k__BackingField;
    public List`1<ServerValue> ServerValues { get; private set; }
    public Guid LocalServerId { get; public set; }
    public Guid LastUpdateByServer { get; public set; }
    public long Total { get; }
    public long NumOfServers { get; }
    [CompilerGeneratedAttribute]
public List`1<ServerValue> get_ServerValues();
    [CompilerGeneratedAttribute]
private void set_ServerValues(List`1<ServerValue> value);
    [CompilerGeneratedAttribute]
public Guid get_LocalServerId();
    [CompilerGeneratedAttribute]
public void set_LocalServerId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_LastUpdateByServer();
    [CompilerGeneratedAttribute]
public void set_LastUpdateByServer(Guid value);
    public long get_Total();
    public long get_NumOfServers();
}
public class Raven.Abstractions.Counters.CounterBackupRequest : object {
    [CompilerGeneratedAttribute]
private string <BackupLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterStorageDocument <CounterDocument>k__BackingField;
    public string BackupLocation { get; public set; }
    public CounterStorageDocument CounterDocument { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BackupLocation();
    [CompilerGeneratedAttribute]
public void set_BackupLocation(string value);
    [CompilerGeneratedAttribute]
public CounterStorageDocument get_CounterDocument();
    [CompilerGeneratedAttribute]
public void set_CounterDocument(CounterStorageDocument value);
}
public class Raven.Abstractions.Counters.CounterChange : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Delta>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReset>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<object> <Done>k__BackingField;
    public string Name { get; public set; }
    public string Group { get; public set; }
    public long Delta { get; public set; }
    public bool IsReset { get; public set; }
    [JsonIgnoreAttribute]
public TaskCompletionSource`1<object> Done { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public long get_Delta();
    [CompilerGeneratedAttribute]
public void set_Delta(long value);
    [CompilerGeneratedAttribute]
public bool get_IsReset();
    [CompilerGeneratedAttribute]
public void set_IsReset(bool value);
    [CompilerGeneratedAttribute]
public TaskCompletionSource`1<object> get_Done();
    [CompilerGeneratedAttribute]
public void set_Done(TaskCompletionSource`1<object> value);
}
public class Raven.Abstractions.Counters.CounterDestinationStats : object {
    public int FailureCountInternal;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastHeartbeatReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastReplicatedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastReplicatedLastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastSuccessTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastFailureTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastError>k__BackingField;
    public string Url { get; public set; }
    public Nullable`1<DateTime> LastHeartbeatReceived { get; public set; }
    public long LastReplicatedEtag { get; public set; }
    public Nullable`1<DateTime> LastReplicatedLastModified { get; public set; }
    public Nullable`1<DateTime> LastSuccessTimestamp { get; public set; }
    public Nullable`1<DateTime> LastFailureTimestamp { get; public set; }
    public int FailureCount { get; }
    public string LastError { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastHeartbeatReceived();
    [CompilerGeneratedAttribute]
public void set_LastHeartbeatReceived(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public long get_LastReplicatedEtag();
    [CompilerGeneratedAttribute]
public void set_LastReplicatedEtag(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastReplicatedLastModified();
    [CompilerGeneratedAttribute]
public void set_LastReplicatedLastModified(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastSuccessTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastSuccessTimestamp(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastFailureTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastFailureTimestamp(Nullable`1<DateTime> value);
    public int get_FailureCount();
    [CompilerGeneratedAttribute]
public string get_LastError();
    [CompilerGeneratedAttribute]
public void set_LastError(string value);
}
public class Raven.Abstractions.Counters.CounterGroup : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public string Name { get; public set; }
    public long Count { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(long value);
}
public class Raven.Abstractions.Counters.CounterNameGroupPair : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    public string Name { get; public set; }
    public string Group { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
}
public class Raven.Abstractions.Counters.CounterReplicationDestination : object {
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterStorageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    public string ServerUrl { get; public set; }
    public string CounterStorageName { get; public set; }
    public string CounterStorageUrl { get; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string Domain { get; public set; }
    public string ApiKey { get; public set; }
    public bool Disabled { get; public set; }
    [JsonIgnoreAttribute]
public ICredentials Credentials { get; }
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
public void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_CounterStorageName();
    [CompilerGeneratedAttribute]
public void set_CounterStorageName(string value);
    public string get_CounterStorageUrl();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    public ICredentials get_Credentials();
    protected bool Equals(CounterReplicationDestination other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.Counters.CounterRestoreRequest : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BackupLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RestoreToLocation>k__BackingField;
    public string Id { get; public set; }
    public string BackupLocation { get; public set; }
    public string RestoreToLocation { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_BackupLocation();
    [CompilerGeneratedAttribute]
public void set_BackupLocation(string value);
    [CompilerGeneratedAttribute]
public string get_RestoreToLocation();
    [CompilerGeneratedAttribute]
public void set_RestoreToLocation(string value);
}
public class Raven.Abstractions.Counters.CountersBatchOptions : object {
    [CompilerGeneratedAttribute]
private int <BatchSizeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchReadTimeoutInMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectionReopenTimingInMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StreamingInitializeTimeout>k__BackingField;
    public int BatchSizeLimit { get; public set; }
    public int BatchReadTimeoutInMilliseconds { get; public set; }
    public int ConnectionReopenTimingInMilliseconds { get; public set; }
    public int StreamingInitializeTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public int get_BatchSizeLimit();
    [CompilerGeneratedAttribute]
public void set_BatchSizeLimit(int value);
    [CompilerGeneratedAttribute]
public int get_BatchReadTimeoutInMilliseconds();
    [CompilerGeneratedAttribute]
public void set_BatchReadTimeoutInMilliseconds(int value);
    [CompilerGeneratedAttribute]
public int get_ConnectionReopenTimingInMilliseconds();
    [CompilerGeneratedAttribute]
public void set_ConnectionReopenTimingInMilliseconds(int value);
    [CompilerGeneratedAttribute]
public int get_StreamingInitializeTimeout();
    [CompilerGeneratedAttribute]
public void set_StreamingInitializeTimeout(int value);
}
public class Raven.Abstractions.Counters.CountersReplicationDocument : object {
    [CompilerGeneratedAttribute]
private List`1<CounterReplicationDestination> <Destinations>k__BackingField;
    public List`1<CounterReplicationDestination> Destinations { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<CounterReplicationDestination> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(List`1<CounterReplicationDestination> value);
}
public class Raven.Abstractions.Counters.CountersStorageMetrics : object {
    [CompilerGeneratedAttribute]
private double <RequestsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <Resets>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <Increments>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <Decrements>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <ClientRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <IncomingReplications>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <OutgoingReplications>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramData <RequestsDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramData <IncSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramData <DecSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MeterData> <ReplicationBatchSizeMeter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, HistogramData> <ReplicationBatchSizeHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, HistogramData> <ReplicationDurationHistogram>k__BackingField;
    public double RequestsPerSecond { get; public set; }
    public MeterData Resets { get; public set; }
    public MeterData Increments { get; public set; }
    public MeterData Decrements { get; public set; }
    public MeterData ClientRequests { get; public set; }
    public MeterData IncomingReplications { get; public set; }
    public MeterData OutgoingReplications { get; public set; }
    public HistogramData RequestsDuration { get; public set; }
    public HistogramData IncSizes { get; public set; }
    public HistogramData DecSizes { get; public set; }
    public Dictionary`2<string, MeterData> ReplicationBatchSizeMeter { get; public set; }
    public Dictionary`2<string, HistogramData> ReplicationBatchSizeHistogram { get; public set; }
    public Dictionary`2<string, HistogramData> ReplicationDurationHistogram { get; public set; }
    [CompilerGeneratedAttribute]
public double get_RequestsPerSecond();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSecond(double value);
    [CompilerGeneratedAttribute]
public MeterData get_Resets();
    [CompilerGeneratedAttribute]
public void set_Resets(MeterData value);
    [CompilerGeneratedAttribute]
public MeterData get_Increments();
    [CompilerGeneratedAttribute]
public void set_Increments(MeterData value);
    [CompilerGeneratedAttribute]
public MeterData get_Decrements();
    [CompilerGeneratedAttribute]
public void set_Decrements(MeterData value);
    [CompilerGeneratedAttribute]
public MeterData get_ClientRequests();
    [CompilerGeneratedAttribute]
public void set_ClientRequests(MeterData value);
    [CompilerGeneratedAttribute]
public MeterData get_IncomingReplications();
    [CompilerGeneratedAttribute]
public void set_IncomingReplications(MeterData value);
    [CompilerGeneratedAttribute]
public MeterData get_OutgoingReplications();
    [CompilerGeneratedAttribute]
public void set_OutgoingReplications(MeterData value);
    [CompilerGeneratedAttribute]
public HistogramData get_RequestsDuration();
    [CompilerGeneratedAttribute]
public void set_RequestsDuration(HistogramData value);
    [CompilerGeneratedAttribute]
public HistogramData get_IncSizes();
    [CompilerGeneratedAttribute]
public void set_IncSizes(HistogramData value);
    [CompilerGeneratedAttribute]
public HistogramData get_DecSizes();
    [CompilerGeneratedAttribute]
public void set_DecSizes(HistogramData value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MeterData> get_ReplicationBatchSizeMeter();
    [CompilerGeneratedAttribute]
public void set_ReplicationBatchSizeMeter(Dictionary`2<string, MeterData> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, HistogramData> get_ReplicationBatchSizeHistogram();
    [CompilerGeneratedAttribute]
public void set_ReplicationBatchSizeHistogram(Dictionary`2<string, HistogramData> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, HistogramData> get_ReplicationDurationHistogram();
    [CompilerGeneratedAttribute]
public void set_ReplicationDurationHistogram(Dictionary`2<string, HistogramData> value);
}
public class Raven.Abstractions.Counters.CounterStorageDocument : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <SecuredSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    public string Id { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    public Dictionary`2<string, string> SecuredSettings { get; public set; }
    public bool Disabled { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_SecuredSettings();
    [CompilerGeneratedAttribute]
public void set_SecuredSettings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
}
public class Raven.Abstractions.Counters.CounterStorageReplicationStats : object {
    [CompilerGeneratedAttribute]
private List`1<CounterDestinationStats> <Stats>k__BackingField;
    public List`1<CounterDestinationStats> Stats { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<CounterDestinationStats> get_Stats();
    [CompilerGeneratedAttribute]
public void set_Stats(List`1<CounterDestinationStats> value);
}
public class Raven.Abstractions.Counters.CounterStorageStats : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountersCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <GroupsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TombstonesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastCounterEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplicationTasksCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterStorageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReplicatedServersCount>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RequestsPerSecond>k__BackingField;
    public string Name { get; public set; }
    public string Url { get; public set; }
    public long CountersCount { get; public set; }
    public long GroupsCount { get; public set; }
    public long TombstonesCount { get; public set; }
    public long LastCounterEtag { get; public set; }
    public int ReplicationTasksCount { get; public set; }
    public string CounterStorageSize { get; public set; }
    public long ReplicatedServersCount { get; public set; }
    public double RequestsPerSecond { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public long get_CountersCount();
    [CompilerGeneratedAttribute]
public void set_CountersCount(long value);
    [CompilerGeneratedAttribute]
public long get_GroupsCount();
    [CompilerGeneratedAttribute]
public void set_GroupsCount(long value);
    [CompilerGeneratedAttribute]
public long get_TombstonesCount();
    [CompilerGeneratedAttribute]
public void set_TombstonesCount(long value);
    [CompilerGeneratedAttribute]
public long get_LastCounterEtag();
    [CompilerGeneratedAttribute]
public void set_LastCounterEtag(long value);
    [CompilerGeneratedAttribute]
public int get_ReplicationTasksCount();
    [CompilerGeneratedAttribute]
public void set_ReplicationTasksCount(int value);
    [CompilerGeneratedAttribute]
public string get_CounterStorageSize();
    [CompilerGeneratedAttribute]
public void set_CounterStorageSize(string value);
    [CompilerGeneratedAttribute]
public long get_ReplicatedServersCount();
    [CompilerGeneratedAttribute]
public void set_ReplicatedServersCount(long value);
    [CompilerGeneratedAttribute]
public double get_RequestsPerSecond();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSecond(double value);
}
public class Raven.Abstractions.Counters.CounterSummary : object {
    [CompilerGeneratedAttribute]
private string <GroupName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Increments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Decrements>k__BackingField;
    public string GroupName { get; public set; }
    public string CounterName { get; public set; }
    public long Total { get; }
    public long Increments { get; public set; }
    public long Decrements { get; public set; }
    [CompilerGeneratedAttribute]
public string get_GroupName();
    [CompilerGeneratedAttribute]
public void set_GroupName(string value);
    [CompilerGeneratedAttribute]
public string get_CounterName();
    [CompilerGeneratedAttribute]
public void set_CounterName(string value);
    public long get_Total();
    [CompilerGeneratedAttribute]
public long get_Increments();
    [CompilerGeneratedAttribute]
public void set_Increments(long value);
    [CompilerGeneratedAttribute]
public long get_Decrements();
    [CompilerGeneratedAttribute]
public void set_Decrements(long value);
}
public class Raven.Abstractions.Counters.CounterTotal : object {
    [CompilerGeneratedAttribute]
private bool <IsExists>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Total>k__BackingField;
    public bool IsExists { get; public set; }
    public long Total { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsExists();
    [CompilerGeneratedAttribute]
public void set_IsExists(bool value);
    [CompilerGeneratedAttribute]
public long get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(long value);
}
public static class Raven.Abstractions.Counters.CounterUtils : object {
    public static string GetFullCounterName(string groupName, string counterName);
}
public enum Raven.Abstractions.Counters.Notifications.BatchType : Enum {
    public int value__;
    public static BatchType Started;
    public static BatchType Ended;
    public static BatchType Error;
}
public class Raven.Abstractions.Counters.Notifications.BulkOperationNotification : CounterStorageNotification {
    [CompilerGeneratedAttribute]
private Guid <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private BatchType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public Guid OperationId { get; public set; }
    public BatchType Type { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_OperationId();
    [CompilerGeneratedAttribute]
public void set_OperationId(Guid value);
    [CompilerGeneratedAttribute]
public BatchType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(BatchType value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
public class Raven.Abstractions.Counters.Notifications.ChangeNotification : CounterStorageNotification {
    [CompilerGeneratedAttribute]
private string <GroupName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterName>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterChangeAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Delta>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Total>k__BackingField;
    public string GroupName { get; public set; }
    public string CounterName { get; public set; }
    public CounterChangeAction Action { get; public set; }
    public long Delta { get; public set; }
    public long Total { get; public set; }
    [CompilerGeneratedAttribute]
public string get_GroupName();
    [CompilerGeneratedAttribute]
public void set_GroupName(string value);
    [CompilerGeneratedAttribute]
public string get_CounterName();
    [CompilerGeneratedAttribute]
public void set_CounterName(string value);
    [CompilerGeneratedAttribute]
public CounterChangeAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(CounterChangeAction value);
    [CompilerGeneratedAttribute]
public long get_Delta();
    [CompilerGeneratedAttribute]
public void set_Delta(long value);
    [CompilerGeneratedAttribute]
public long get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(long value);
}
public enum Raven.Abstractions.Counters.Notifications.CounterChangeAction : Enum {
    public int value__;
    public static CounterChangeAction Add;
    public static CounterChangeAction Increment;
    public static CounterChangeAction Decrement;
    public static CounterChangeAction Delete;
}
public class Raven.Abstractions.Counters.Notifications.CounterStorageNotification : object {
}
public class Raven.Abstractions.Counters.Notifications.InGroupNotification : ChangeNotification {
    public virtual string ToString();
}
public class Raven.Abstractions.Counters.Notifications.StartingWithNotification : ChangeNotification {
    public virtual string ToString();
}
public class Raven.Abstractions.Counters.ServerValue : object {
    [CompilerGeneratedAttribute]
private Guid <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Etag>k__BackingField;
    public Guid ServerId { get; public set; }
    public long Value { get; public set; }
    public string ServerName { get; public set; }
    public long Etag { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(Guid value);
    [CompilerGeneratedAttribute]
public long get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(long value);
    [CompilerGeneratedAttribute]
public string get_ServerName();
    [CompilerGeneratedAttribute]
public void set_ServerName(string value);
    [CompilerGeneratedAttribute]
public long get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(long value);
}
public abstract class Raven.Abstractions.Data.AbstractRestoreRequest : object {
    [CompilerGeneratedAttribute]
private string <BackupLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JournalsLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexesLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Defrag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RestoreStartTimeout>k__BackingField;
    public string BackupLocation { get; public set; }
    [ObsoleteAttribute]
public string RestoreLocation { get; public set; }
    public string JournalsLocation { get; public set; }
    public string IndexesLocation { get; public set; }
    public bool Defrag { get; public set; }
    public Nullable`1<int> RestoreStartTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BackupLocation();
    [CompilerGeneratedAttribute]
public void set_BackupLocation(string value);
    public string get_RestoreLocation();
    public void set_RestoreLocation(string value);
    [CompilerGeneratedAttribute]
public string get_JournalsLocation();
    [CompilerGeneratedAttribute]
public void set_JournalsLocation(string value);
    [CompilerGeneratedAttribute]
public string get_IndexesLocation();
    [CompilerGeneratedAttribute]
public void set_IndexesLocation(string value);
    [CompilerGeneratedAttribute]
public bool get_Defrag();
    [CompilerGeneratedAttribute]
public void set_Defrag(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RestoreStartTimeout();
    [CompilerGeneratedAttribute]
public void set_RestoreStartTimeout(Nullable`1<int> value);
}
public class Raven.Abstractions.Data.AccessTokenBody : object {
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ResourceAccess> <AuthorizedDatabases>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Issued>k__BackingField;
    public string UserId { get; public set; }
    public List`1<ResourceAccess> AuthorizedDatabases { get; public set; }
    public double Issued { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
    [CompilerGeneratedAttribute]
public List`1<ResourceAccess> get_AuthorizedDatabases();
    [CompilerGeneratedAttribute]
public void set_AuthorizedDatabases(List`1<ResourceAccess> value);
    [CompilerGeneratedAttribute]
public double get_Issued();
    [CompilerGeneratedAttribute]
public void set_Issued(double value);
    public bool IsExpired();
    public bool IsAuthorized(string tenantId, bool writeAccess);
}
public class Raven.Abstractions.Data.AdminMemoryStatistics : object {
    [CompilerGeneratedAttribute]
private decimal <DatabaseCacheSizeInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <ManagedMemorySizeInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <TotalProcessMemorySizeInMB>k__BackingField;
    public decimal DatabaseCacheSizeInMB { get; public set; }
    public decimal ManagedMemorySizeInMB { get; public set; }
    public decimal TotalProcessMemorySizeInMB { get; public set; }
    [CompilerGeneratedAttribute]
public decimal get_DatabaseCacheSizeInMB();
    [CompilerGeneratedAttribute]
public void set_DatabaseCacheSizeInMB(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_ManagedMemorySizeInMB();
    [CompilerGeneratedAttribute]
public void set_ManagedMemorySizeInMB(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_TotalProcessMemorySizeInMB();
    [CompilerGeneratedAttribute]
public void set_TotalProcessMemorySizeInMB(decimal value);
}
public class Raven.Abstractions.Data.AdminStatistics : object {
    [CompilerGeneratedAttribute]
private string <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalNumberOfRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Uptime>k__BackingField;
    [CompilerGeneratedAttribute]
private AdminMemoryStatistics <Memory>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LoadedDatabaseStatistics> <LoadedDatabases>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FileSystemStats> <LoadedFileSystems>k__BackingField;
    public string ServerName { get; public set; }
    public int TotalNumberOfRequests { get; public set; }
    public TimeSpan Uptime { get; public set; }
    public AdminMemoryStatistics Memory { get; public set; }
    public IEnumerable`1<LoadedDatabaseStatistics> LoadedDatabases { get; public set; }
    public IEnumerable`1<FileSystemStats> LoadedFileSystems { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServerName();
    [CompilerGeneratedAttribute]
public void set_ServerName(string value);
    [CompilerGeneratedAttribute]
public int get_TotalNumberOfRequests();
    [CompilerGeneratedAttribute]
public void set_TotalNumberOfRequests(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Uptime();
    [CompilerGeneratedAttribute]
public void set_Uptime(TimeSpan value);
    [CompilerGeneratedAttribute]
public AdminMemoryStatistics get_Memory();
    [CompilerGeneratedAttribute]
public void set_Memory(AdminMemoryStatistics value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<LoadedDatabaseStatistics> get_LoadedDatabases();
    [CompilerGeneratedAttribute]
public void set_LoadedDatabases(IEnumerable`1<LoadedDatabaseStatistics> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<FileSystemStats> get_LoadedFileSystems();
    [CompilerGeneratedAttribute]
public void set_LoadedFileSystems(IEnumerable`1<FileSystemStats> value);
}
public class Raven.Abstractions.Data.Alert : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Observed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastDismissedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private AlertLevel <AlertLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueKey>k__BackingField;
    public string Title { get; public set; }
    public DateTime CreatedAt { get; public set; }
    public bool Observed { get; public set; }
    public Nullable`1<DateTime> LastDismissedAt { get; public set; }
    public string Message { get; public set; }
    public AlertLevel AlertLevel { get; public set; }
    public string Exception { get; public set; }
    public string UniqueKey { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_Observed();
    [CompilerGeneratedAttribute]
public void set_Observed(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastDismissedAt();
    [CompilerGeneratedAttribute]
public void set_LastDismissedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public AlertLevel get_AlertLevel();
    [CompilerGeneratedAttribute]
public void set_AlertLevel(AlertLevel value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    [CompilerGeneratedAttribute]
public string get_UniqueKey();
    [CompilerGeneratedAttribute]
public void set_UniqueKey(string value);
}
public enum Raven.Abstractions.Data.AlertLevel : Enum {
    public int value__;
    public static AlertLevel Warning;
    public static AlertLevel Error;
}
public class Raven.Abstractions.Data.AlertsDocument : object {
    [CompilerGeneratedAttribute]
private List`1<Alert> <Alerts>k__BackingField;
    public List`1<Alert> Alerts { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Alert> get_Alerts();
    [CompilerGeneratedAttribute]
public void set_Alerts(List`1<Alert> value);
}
public class Raven.Abstractions.Data.ApiKeyDefinition : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Secret>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ResourceAccess> <Databases>k__BackingField;
    public string Id { get; public set; }
    public string Name { get; public set; }
    public string Secret { get; public set; }
    [JsonIgnoreAttribute]
public string FullApiKey { get; }
    [JsonIgnoreAttribute]
public string ConnectionString { get; }
    [JsonIgnoreAttribute]
private string DbName { get; }
    public bool Enabled { get; public set; }
    public List`1<ResourceAccess> Databases { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Secret();
    [CompilerGeneratedAttribute]
public void set_Secret(string value);
    public string get_FullApiKey();
    public string get_ConnectionString();
    private string get_DbName();
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public List`1<ResourceAccess> get_Databases();
    [CompilerGeneratedAttribute]
public void set_Databases(List`1<ResourceAccess> value);
    protected bool Equals(ApiKeyDefinition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Abstractions.Data.Attachment : object {
    [CompilerGeneratedAttribute]
private Func`1<Stream> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public Func`1<Stream> Data { get; public set; }
    public int Size { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public Etag Etag { get; public set; }
    public string Key { get; public set; }
    [CompilerGeneratedAttribute]
public Func`1<Stream> get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Func`1<Stream> value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
}
public class Raven.Abstractions.Data.AttachmentChangeNotification : EventArgs {
    [CompilerGeneratedAttribute]
private AttachmentChangeTypes <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public AttachmentChangeTypes Type { get; public set; }
    public string Id { get; public set; }
    public Etag Etag { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public AttachmentChangeTypes get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(AttachmentChangeTypes value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public virtual string ToString();
}
[FlagsAttribute]
public enum Raven.Abstractions.Data.AttachmentChangeTypes : Enum {
    public int value__;
    public static AttachmentChangeTypes None;
    public static AttachmentChangeTypes Put;
    public static AttachmentChangeTypes Delete;
    public static AttachmentChangeTypes Common;
}
public class Raven.Abstractions.Data.AutoTunerDecisionDescription : object {
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public DateTime Time { get; public set; }
    public string Name { get; public set; }
    public string DatabaseName { get; public set; }
    public string Reason { get; public set; }
    public AutoTunerDecisionDescription(string name, string dbname, string reason);
    [CompilerGeneratedAttribute]
public DateTime get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
}
public class Raven.Abstractions.Data.AutoTunerInfo : object {
    [CompilerGeneratedAttribute]
private List`1<AutoTunerDecisionDescription> <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LowMemoryCalledRecord> <LowMemoryCallsRecords>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CpuUsageCallsRecord> <CpuUsageCallsRecords>k__BackingField;
    public List`1<AutoTunerDecisionDescription> Reason { get; public set; }
    public List`1<LowMemoryCalledRecord> LowMemoryCallsRecords { get; public set; }
    public List`1<CpuUsageCallsRecord> CpuUsageCallsRecords { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<AutoTunerDecisionDescription> get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(List`1<AutoTunerDecisionDescription> value);
    [CompilerGeneratedAttribute]
public List`1<LowMemoryCalledRecord> get_LowMemoryCallsRecords();
    [CompilerGeneratedAttribute]
public void set_LowMemoryCallsRecords(List`1<LowMemoryCalledRecord> value);
    [CompilerGeneratedAttribute]
public List`1<CpuUsageCallsRecord> get_CpuUsageCallsRecords();
    [CompilerGeneratedAttribute]
public void set_CpuUsageCallsRecords(List`1<CpuUsageCallsRecord> value);
}
public class Raven.Abstractions.Data.BackupStatus : object {
    public static string RavenBackupStatusDocumentKey;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BackupMessage> <Messages>k__BackingField;
    public DateTime Started { get; public set; }
    public Nullable`1<DateTime> Completed { get; public set; }
    public bool IsRunning { get; public set; }
    public bool Success { get; public set; }
    public List`1<BackupMessage> Messages { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_IsRunning();
    [CompilerGeneratedAttribute]
public void set_IsRunning(bool value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public List`1<BackupMessage> get_Messages();
    [CompilerGeneratedAttribute]
public void set_Messages(List`1<BackupMessage> value);
}
public abstract class Raven.Abstractions.Data.BasePerformanceStats : object {
    [CompilerGeneratedAttribute]
private long <DurationMs>k__BackingField;
    public long DurationMs { get; public set; }
    [CompilerGeneratedAttribute]
public long get_DurationMs();
    [CompilerGeneratedAttribute]
public void set_DurationMs(long value);
}
public class Raven.Abstractions.Data.BatchResult : object {
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <AdditionalData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PatchResult> <PatchResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Deleted>k__BackingField;
    public Etag Etag { get; public set; }
    public string Method { get; public set; }
    public string Key { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public RavenJObject AdditionalData { get; public set; }
    public Nullable`1<PatchResult> PatchResult { get; public set; }
    public Nullable`1<bool> Deleted { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public RavenJObject get_AdditionalData();
    [CompilerGeneratedAttribute]
public void set_AdditionalData(RavenJObject value);
    [CompilerGeneratedAttribute]
public Nullable`1<PatchResult> get_PatchResult();
    [CompilerGeneratedAttribute]
public void set_PatchResult(Nullable`1<PatchResult> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Deleted();
    [CompilerGeneratedAttribute]
public void set_Deleted(Nullable`1<bool> value);
}
public enum Raven.Abstractions.Data.BatchType : Enum {
    public int value__;
    public static BatchType Standard;
    public static BatchType Precomputed;
}
public class Raven.Abstractions.Data.BoostedValue : object {
    [CompilerGeneratedAttribute]
private float <Boost>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public float Boost { get; public set; }
    public object Value { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Boost();
    [CompilerGeneratedAttribute]
public void set_Boost(float value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
public class Raven.Abstractions.Data.BuildNumber : object {
    [CompilerGeneratedAttribute]
private string <ProductVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildVersion>k__BackingField;
    public string ProductVersion { get; public set; }
    public string BuildVersion { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProductVersion();
    [CompilerGeneratedAttribute]
public void set_ProductVersion(string value);
    [CompilerGeneratedAttribute]
public string get_BuildVersion();
    [CompilerGeneratedAttribute]
public void set_BuildVersion(string value);
}
public class Raven.Abstractions.Data.BulkInsertChangeNotification : DocumentChangeNotification {
    [CompilerGeneratedAttribute]
private Guid <OperationId>k__BackingField;
    public Guid OperationId { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_OperationId();
    [CompilerGeneratedAttribute]
public void set_OperationId(Guid value);
}
public enum Raven.Abstractions.Data.BulkInsertCompression : Enum {
    public int value__;
    public static BulkInsertCompression None;
    public static BulkInsertCompression GZip;
}
public enum Raven.Abstractions.Data.BulkInsertFormat : Enum {
    public int value__;
    public static BulkInsertFormat Bson;
    public static BulkInsertFormat Json;
}
public class Raven.Abstractions.Data.BulkInsertOptions : object {
    [CompilerGeneratedAttribute]
private bool <OverwriteExisting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckReferencesInIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipOverwriteIfUnchanged>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WriteTimeoutMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private BulkInsertCompression <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private BulkInsertFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ChunkedBulkInsertOptions <ChunkedBulkInsertOptions>k__BackingField;
    public bool OverwriteExisting { get; public set; }
    public bool CheckReferencesInIndexes { get; public set; }
    public bool SkipOverwriteIfUnchanged { get; public set; }
    public int BatchSize { get; public set; }
    public int WriteTimeoutMilliseconds { get; public set; }
    public BulkInsertCompression Compression { get; public set; }
    public BulkInsertFormat Format { get; public set; }
    public ChunkedBulkInsertOptions ChunkedBulkInsertOptions { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_OverwriteExisting();
    [CompilerGeneratedAttribute]
public void set_OverwriteExisting(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckReferencesInIndexes();
    [CompilerGeneratedAttribute]
public void set_CheckReferencesInIndexes(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipOverwriteIfUnchanged();
    [CompilerGeneratedAttribute]
public void set_SkipOverwriteIfUnchanged(bool value);
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
    [CompilerGeneratedAttribute]
public int get_WriteTimeoutMilliseconds();
    [CompilerGeneratedAttribute]
public void set_WriteTimeoutMilliseconds(int value);
    [CompilerGeneratedAttribute]
public BulkInsertCompression get_Compression();
    [CompilerGeneratedAttribute]
public void set_Compression(BulkInsertCompression value);
    [CompilerGeneratedAttribute]
public BulkInsertFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(BulkInsertFormat value);
    [CompilerGeneratedAttribute]
public ChunkedBulkInsertOptions get_ChunkedBulkInsertOptions();
    [CompilerGeneratedAttribute]
public void set_ChunkedBulkInsertOptions(ChunkedBulkInsertOptions value);
}
public class Raven.Abstractions.Data.BulkOperationOptions : object {
    [CompilerGeneratedAttribute]
private bool <AllowStale>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <StaleTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxOpsPerSec>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RetrieveDetails>k__BackingField;
    public bool AllowStale { get; public set; }
    public Nullable`1<TimeSpan> StaleTimeout { get; public set; }
    public Nullable`1<int> MaxOpsPerSec { get; public set; }
    public bool RetrieveDetails { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowStale();
    [CompilerGeneratedAttribute]
public void set_AllowStale(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_StaleTimeout();
    [CompilerGeneratedAttribute]
public void set_StaleTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxOpsPerSec();
    [CompilerGeneratedAttribute]
public void set_MaxOpsPerSec(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_RetrieveDetails();
    [CompilerGeneratedAttribute]
public void set_RetrieveDetails(bool value);
}
public class Raven.Abstractions.Data.BulkOperationProgress : object {
    public int TotalEntries;
    public int ProcessedEntries;
}
public class Raven.Abstractions.Data.ChunkedBulkInsertOptions : object {
    [CompilerGeneratedAttribute]
private int <MaxDocumentsPerChunk>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxChunkVolumeInBytes>k__BackingField;
    public int MaxDocumentsPerChunk { get; public set; }
    public long MaxChunkVolumeInBytes { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxDocumentsPerChunk();
    [CompilerGeneratedAttribute]
public void set_MaxDocumentsPerChunk(int value);
    [CompilerGeneratedAttribute]
public long get_MaxChunkVolumeInBytes();
    [CompilerGeneratedAttribute]
public void set_MaxChunkVolumeInBytes(long value);
}
public class Raven.Abstractions.Data.CompactStatus : object {
    public CompactStatusState State;
    [CompilerGeneratedAttribute]
private List`1<string> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastProgressMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastProgressMessageTime>k__BackingField;
    public List`1<string> Messages { get; public set; }
    public string LastProgressMessage { get; public set; }
    public Nullable`1<DateTime> LastProgressMessageTime { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Messages();
    [CompilerGeneratedAttribute]
public void set_Messages(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_LastProgressMessage();
    [CompilerGeneratedAttribute]
public void set_LastProgressMessage(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastProgressMessageTime();
    [CompilerGeneratedAttribute]
public void set_LastProgressMessageTime(Nullable`1<DateTime> value);
    public static string RavenDatabaseCompactStatusDocumentKey(string databaseName);
    public static string RavenFilesystemCompactStatusDocumentKey(string fileSystemName);
    public static string RavenCounterStoageCompactStatusDocumentKey(string counterStorageName);
}
public enum Raven.Abstractions.Data.CompactStatusState : Enum {
    public int value__;
    public static CompactStatusState Running;
    public static CompactStatusState Completed;
    public static CompactStatusState Faulted;
}
public class Raven.Abstractions.Data.ConnectionStringOptions : object {
    private string url;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentOAuthToken>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthenticationScheme>k__BackingField;
    public string Url { get; public set; }
    public string ApiKey { get; public set; }
    internal string CurrentOAuthToken { get; internal set; }
    public ICredentials Credentials { get; public set; }
    public string AuthenticationScheme { get; public set; }
    public string get_Url();
    public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
internal string get_CurrentOAuthToken();
    [CompilerGeneratedAttribute]
internal void set_CurrentOAuthToken(string value);
    [CompilerGeneratedAttribute]
public ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(ICredentials value);
    [CompilerGeneratedAttribute]
public string get_AuthenticationScheme();
    [CompilerGeneratedAttribute]
public void set_AuthenticationScheme(string value);
    public virtual string ToString();
}
public class Raven.Abstractions.Data.ConnectionStringParser`1 : object {
    private static Regex connectionStringRegex;
    private static Regex connectionStringArgumentsSplitterRegex;
    private string connectionString;
    private string connectionStringName;
    private bool setupPasswordInConnectionString;
    private bool setupUsernameInConnectionString;
    [CompilerGeneratedAttribute]
private TConnectionString <ConnectionStringOptions>k__BackingField;
    public TConnectionString ConnectionStringOptions { get; public set; }
    private ConnectionStringParser`1(string connectionStringName, string connectionString);
    private static ConnectionStringParser`1();
    public static ConnectionStringParser`1<TConnectionString> FromConnectionStringName(string connectionStringName);
    public static ConnectionStringParser`1<TConnectionString> FromConnectionString(string connectionString);
    [CompilerGeneratedAttribute]
public TConnectionString get_ConnectionStringOptions();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringOptions(TConnectionString value);
    protected virtual bool ProcessConnectionStringOption(ConnectionStringOptions options, NetworkCredential networkCredentials, string key, string value);
    protected virtual bool ProcessConnectionStringOption(RavenConnectionStringOptions options, string key, string value);
    protected virtual bool ProcessConnectionStringOption(EmbeddedRavenConnectionStringOptions options, string key, string value);
    protected virtual bool ProcessConnectionStringOption(FilesConnectionStringOptions options, string key, string value);
    public void Parse();
}
public static class Raven.Abstractions.Data.Constants : object {
    public static string ParticipatingIDsPropertyName;
    public static string IsReplicatedUrlParamName;
    public static string IndexVersion;
    public static string TransformerVersion;
    public static string RavenClientPrimaryServerUrl;
    public static string RavenClientPrimaryServerLastCheck;
    public static string RavenForcePrimaryServerCheck;
    public static string RavenShardId;
    public static string BuildVersion;
    public static string LastModified;
    public static string SerializedSizeOnDisk;
    public static string CreationDate;
    public static string RavenCreationDate;
    public static string RavenLastModified;
    public static string SystemDatabase;
    public static string TemporaryScoreValue;
    public static string AlphaNumericFieldName;
    public static string RandomFieldName;
    public static string CustomSortFieldName;
    public static string NullValueNotAnalyzed;
    public static string EmptyStringNotAnalyzed;
    public static string NullValue;
    public static string EmptyString;
    public static string DocumentIdFieldName;
    public static string ReduceKeyFieldName;
    public static string ReduceValueFieldName;
    public static string IntersectSeparator;
    public static string RavenClrType;
    public static string RavenEntityName;
    public static string RavenReadOnly;
    public static string AllFields;
    public static string RavenDocumentDoesNotExists;
    public static string Metadata;
    public static string NotForReplication;
    public static string RavenDeleteMarker;
    public static string RavenIndexDeleteMarker;
    public static string RavenTransformerDeleteMarker;
    public static string TemporaryTransformerPrefix;
    public static string ActiveBundles;
    public static string AllowBundlesChange;
    public static string RavenAlerts;
    public static string RavenJavascriptFunctions;
    public static string MemoryLimitForProcessing_BackwardCompatibility;
    public static string MemoryLimitForProcessing;
    public static string LowMemoryLimitForLinuxDetectionInMB;
    public static string RunInMemory;
    public static string ExposeConfigOverTheWire;
    public static string RavenMaxConcurrentResourceLoads;
    public static string ConcurrentResourceLoadTimeout;
    public static string MaxConcurrentServerRequests;
    public static string MaxConcurrentMultiGetRequests;
    public static string MaxConcurrentRequestsForDatabaseDuringLoad;
    public static string MaxSecondsForTaskToWaitForDatabaseToLoad;
    public static string RejectClientsModeEnabled;
    public static string RavenServerBuild;
    public static string RavenPrefetchingDurationLimit;
    public static int DefaultPrefetchingDurationLimit;
    public static string BulkImportBatchTimeout;
    public static string BulkImportHeartbeatDocKey;
    public static int BulkImportDefaultTimeoutInMs;
    public static string IndexingDisabled;
    public static string MaxNumberOfItemsToProcessInTestIndexes;
    public static string MaxNumberOfStoredIndexingBatchInfoElements;
    public static string UseLuceneASTParser;
    public static string IndexReplacePrefix;
    public static string SideBySideIndexNamePrefix;
    public static string RavenDataDir;
    public static string RavenEsentLogsPath;
    public static string RavenTxJournalPath;
    public static string RavenIndexPath;
    public static int WindowsMaxPath;
    public static int LinuxMaxPath;
    public static int LinuxMaxFileNameLength;
    public static String[] WindowsReservedFileNames;
    public static string DontEncryptDocumentsStartingWith;
    public static string AlgorithmTypeSetting;
    public static string EncryptionKeySetting;
    public static string EncryptionKeyBitsPreferenceSetting;
    public static string EncryptIndexes;
    public static string InResourceKeyVerificationDocumentName;
    public static RavenJObject InResourceKeyVerificationDocumentContents;
    public static int DefaultGeneratedEncryptionKeyLength;
    public static int MinimumAcceptableEncryptionKeyLength;
    public static int DefaultKeySizeToUseInActualEncryptionInBits;
    public static int Rfc2898Iterations;
    public static int DefaultIndexFileBlockSize;
    public static Type DefaultCryptoServiceProvider;
    public static string DocsHardLimit;
    public static string DocsSoftLimit;
    public static string SizeHardLimitInKB;
    public static string SizeSoftLimitInKB;
    public static string RavenIndexAndTransformerReplicationLatencyInSec;
    public static int DefaultRavenIndexAndTransformerReplicationLatencyInSec;
    public static string RavenReplicationSource;
    public static string RavenReplicationVersion;
    public static string RavenReplicationHistory;
    public static string RavenReplicationMergedHistory;
    public static string RavenReplicationConflict;
    public static string RavenReplicationConflictSkipResolution;
    public static string RavenReplicationConflictDocument;
    public static string RavenReplicationConflictDocumentForcePut;
    public static string RavenReplicationSourcesBasePath;
    public static string RavenReplicationDestinations;
    public static string RavenReplicationDestinationsBasePath;
    public static string RavenReplicationConfig;
    public static string RavenReplicationDocsTombstones;
    public static string RavenReplicationIndexesTombstones;
    public static string RavenReplicationTransformerTombstones;
    public static string RavenDeletedIndexesVersions;
    public static string RavenDeletedTransformersVersions;
    public static string RavenSqlReplicationConnectionsDocumentName;
    public static string ReplicationPropagationDelayInSeconds;
    public static string AllowNonAdminUsersToSetupPeriodicExport;
    [ObsoleteAttribute("Use RavenFS instead.")]
public static string RavenReplicationAttachmentsTombstones;
    public static string RavenPeriodicExportsDocsTombstones;
    [ObsoleteAttribute("Use RavenFS instead.")]
public static string RavenPeriodicExportsAttachmentsTombstones;
    public static string DefaultSpatialFieldName;
    public static string SpatialShapeFieldName;
    public static double DefaultSpatialDistanceErrorPct;
    public static string DistanceFieldName;
    public static double EarthMeanRadiusKm;
    public static double MilesToKm;
    public static string RavenCreateVersion;
    public static string RavenIgnoreVersioning;
    public static string RavenClientVersion;
    public static string RavenDefaultQueryTimeout;
    public static string NextPageStart;
    public static string DefaultRequestEncoding;
    public static string DocumentsByEntityNameIndex;
    public static string ConflictDocumentsIndex;
    public static string MetadataEtagField;
    public static string TempUploadsDirectoryName;
    public static string DataCouldNotBeDecrypted;
    public static int NumberOfCachedRequests;
    public static string DatabaseDocumentFilename;
    public static string FilesystemDocumentFilename;
    public static string IncrementalBackupAlertTimeout;
    public static string IncrementalBackupRecurringAlertTimeout;
    public static string IncrementalBackupState;
    public static string BackupFailureMarker;
    public static string MaxClauseCount;
    public static string ResourceMarkerPrefix;
    public static string RavenSubscriptionsPrefix;
    public static string AllowScriptsToAdjustNumberOfSteps;
    public static string RequestFailedExceptionMarker;
    public static string TempPath;
    private static Constants();
}
public class Raven.Abstractions.Data.CounterConnectionStringOptions : ConnectionStringOptions {
    [CompilerGeneratedAttribute]
private string <CounterStoreId>k__BackingField;
    public string CounterStoreId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CounterStoreId();
    [CompilerGeneratedAttribute]
public void set_CounterStoreId(string value);
}
public class Raven.Abstractions.Data.CounterStorageBackupRequest : object {
    [CompilerGeneratedAttribute]
private string <BackupLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterStorageDocument <CounterStorageDocument>k__BackingField;
    public string BackupLocation { get; public set; }
    public CounterStorageDocument CounterStorageDocument { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BackupLocation();
    [CompilerGeneratedAttribute]
public void set_BackupLocation(string value);
    [CompilerGeneratedAttribute]
public CounterStorageDocument get_CounterStorageDocument();
    [CompilerGeneratedAttribute]
public void set_CounterStorageDocument(CounterStorageDocument value);
}
public class Raven.Abstractions.Data.CpuUsageCallsRecord : object {
    [CompilerGeneratedAttribute]
private DateTime <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private CpuUsageLevel <Reason>k__BackingField;
    public DateTime StartedAt { get; public set; }
    public CpuUsageLevel Reason { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_StartedAt();
    [CompilerGeneratedAttribute]
public void set_StartedAt(DateTime value);
    [CompilerGeneratedAttribute]
public CpuUsageLevel get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(CpuUsageLevel value);
}
public enum Raven.Abstractions.Data.CpuUsageLevel : Enum {
    public int value__;
    public static CpuUsageLevel HighCpuUsage;
    public static CpuUsageLevel NormalCpuUsage;
    public static CpuUsageLevel LowCpuUsage;
}
public class Raven.Abstractions.Data.DatabaseBackupRequest : object {
    [CompilerGeneratedAttribute]
private string <BackupLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseDocument <DatabaseDocument>k__BackingField;
    public string BackupLocation { get; public set; }
    public DatabaseDocument DatabaseDocument { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BackupLocation();
    [CompilerGeneratedAttribute]
public void set_BackupLocation(string value);
    [CompilerGeneratedAttribute]
public DatabaseDocument get_DatabaseDocument();
    [CompilerGeneratedAttribute]
public void set_DatabaseDocument(DatabaseDocument value);
}
public class Raven.Abstractions.Data.DatabaseDocument : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <SecuredSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    public string Id { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    public Dictionary`2<string, string> SecuredSettings { get; public set; }
    public bool Disabled { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_SecuredSettings();
    [CompilerGeneratedAttribute]
public void set_SecuredSettings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    public static bool CompareDatabaseDocumentWithoutId(DatabaseDocument one, DatabaseDocument two);
    private static bool CompareTwoDictionaries(Dictionary`2<string, string> one, Dictionary`2<string, string> two);
    private static bool DictionaryContainsDictionary(Dictionary`2<string, string> one, Dictionary`2<string, string> two);
}
public class Raven.Abstractions.Data.DatabaseInfo : object {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAdmin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public string Database { get; public set; }
    public bool IsAdmin { get; public set; }
    public bool IsReadOnly { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAdmin();
    [CompilerGeneratedAttribute]
public void set_IsAdmin(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public void set_IsReadOnly(bool value);
}
public class Raven.Abstractions.Data.DatabaseMetrics : object {
    [CompilerGeneratedAttribute]
private double <DocsWritesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IndexedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ReducedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RequestsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <Requests>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramData <RequestsDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private OneMinuteMetricData <RequestDurationLastMinute>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramData <StaleIndexMaps>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramData <StaleIndexReduces>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MeterValue> <JsonDeserializationsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MeterValue> <JsonDeserializedBytesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MeterValue> <JsonSerializationsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MeterValue> <JsonSerializedBytesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Dictionary`2<string, string>> <Gauges>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MeterData> <ReplicationBatchSizeMeter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, HistogramData> <ReplicationBatchSizeHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, HistogramData> <ReplicationDurationHistogram>k__BackingField;
    public double DocsWritesPerSecond { get; public set; }
    public double IndexedPerSecond { get; public set; }
    public double ReducedPerSecond { get; public set; }
    public double RequestsPerSecond { get; public set; }
    public MeterData Requests { get; public set; }
    public HistogramData RequestsDuration { get; public set; }
    public OneMinuteMetricData RequestDurationLastMinute { get; public set; }
    public HistogramData StaleIndexMaps { get; public set; }
    public HistogramData StaleIndexReduces { get; public set; }
    public Nullable`1<MeterValue> JsonDeserializationsPerSecond { get; public set; }
    public Nullable`1<MeterValue> JsonDeserializedBytesPerSecond { get; public set; }
    public Nullable`1<MeterValue> JsonSerializationsPerSecond { get; public set; }
    public Nullable`1<MeterValue> JsonSerializedBytesPerSecond { get; public set; }
    public Dictionary`2<string, Dictionary`2<string, string>> Gauges { get; public set; }
    public Dictionary`2<string, MeterData> ReplicationBatchSizeMeter { get; public set; }
    public Dictionary`2<string, HistogramData> ReplicationBatchSizeHistogram { get; public set; }
    public Dictionary`2<string, HistogramData> ReplicationDurationHistogram { get; public set; }
    [CompilerGeneratedAttribute]
public double get_DocsWritesPerSecond();
    [CompilerGeneratedAttribute]
public void set_DocsWritesPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_IndexedPerSecond();
    [CompilerGeneratedAttribute]
public void set_IndexedPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_ReducedPerSecond();
    [CompilerGeneratedAttribute]
public void set_ReducedPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_RequestsPerSecond();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSecond(double value);
    [CompilerGeneratedAttribute]
public MeterData get_Requests();
    [CompilerGeneratedAttribute]
public void set_Requests(MeterData value);
    [CompilerGeneratedAttribute]
public HistogramData get_RequestsDuration();
    [CompilerGeneratedAttribute]
public void set_RequestsDuration(HistogramData value);
    [CompilerGeneratedAttribute]
public OneMinuteMetricData get_RequestDurationLastMinute();
    [CompilerGeneratedAttribute]
public void set_RequestDurationLastMinute(OneMinuteMetricData value);
    [CompilerGeneratedAttribute]
public HistogramData get_StaleIndexMaps();
    [CompilerGeneratedAttribute]
public void set_StaleIndexMaps(HistogramData value);
    [CompilerGeneratedAttribute]
public HistogramData get_StaleIndexReduces();
    [CompilerGeneratedAttribute]
public void set_StaleIndexReduces(HistogramData value);
    [CompilerGeneratedAttribute]
public Nullable`1<MeterValue> get_JsonDeserializationsPerSecond();
    [CompilerGeneratedAttribute]
public void set_JsonDeserializationsPerSecond(Nullable`1<MeterValue> value);
    [CompilerGeneratedAttribute]
public Nullable`1<MeterValue> get_JsonDeserializedBytesPerSecond();
    [CompilerGeneratedAttribute]
public void set_JsonDeserializedBytesPerSecond(Nullable`1<MeterValue> value);
    [CompilerGeneratedAttribute]
public Nullable`1<MeterValue> get_JsonSerializationsPerSecond();
    [CompilerGeneratedAttribute]
public void set_JsonSerializationsPerSecond(Nullable`1<MeterValue> value);
    [CompilerGeneratedAttribute]
public Nullable`1<MeterValue> get_JsonSerializedBytesPerSecond();
    [CompilerGeneratedAttribute]
public void set_JsonSerializedBytesPerSecond(Nullable`1<MeterValue> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Dictionary`2<string, string>> get_Gauges();
    [CompilerGeneratedAttribute]
public void set_Gauges(Dictionary`2<string, Dictionary`2<string, string>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MeterData> get_ReplicationBatchSizeMeter();
    [CompilerGeneratedAttribute]
public void set_ReplicationBatchSizeMeter(Dictionary`2<string, MeterData> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, HistogramData> get_ReplicationBatchSizeHistogram();
    [CompilerGeneratedAttribute]
public void set_ReplicationBatchSizeHistogram(Dictionary`2<string, HistogramData> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, HistogramData> get_ReplicationDurationHistogram();
    [CompilerGeneratedAttribute]
public void set_ReplicationDurationHistogram(Dictionary`2<string, HistogramData> value);
}
public class Raven.Abstractions.Data.DatabaseOperationsStatus : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastAlertIssued>k__BackingField;
    public Nullable`1<DateTime> LastBackup { get; public set; }
    public Nullable`1<DateTime> LastAlertIssued { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastBackup();
    [CompilerGeneratedAttribute]
public void set_LastBackup(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastAlertIssued();
    [CompilerGeneratedAttribute]
public void set_LastAlertIssued(Nullable`1<DateTime> value);
}
public class Raven.Abstractions.Data.DatabaseRestoreRequest : AbstractRestoreRequest {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableReplicationDestinations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateNewDatabaseId>k__BackingField;
    public string DatabaseName { get; public set; }
    public string DatabaseLocation { get; public set; }
    public bool DisableReplicationDestinations { get; public set; }
    public bool GenerateNewDatabaseId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseLocation();
    [CompilerGeneratedAttribute]
public void set_DatabaseLocation(string value);
    [CompilerGeneratedAttribute]
public bool get_DisableReplicationDestinations();
    [CompilerGeneratedAttribute]
public void set_DisableReplicationDestinations(bool value);
    [CompilerGeneratedAttribute]
public bool get_GenerateNewDatabaseId();
    [CompilerGeneratedAttribute]
public void set_GenerateNewDatabaseId(bool value);
}
public class Raven.Abstractions.Data.DatabaseStatistics : object {
    [CompilerGeneratedAttribute]
private string <StorageEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastDocEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastAttachmentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfIndexesExcludingDisabledAndAbandoned>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfResultTransformers>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <InMemoryIndexingQueueSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ApproximateTaskCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfAttachments>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <StaleIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountOfStaleIndexesExcludingDisabledAndAbandoned>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentNumberOfParallelTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentNumberOfItemsToIndexInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentNumberOfItemsToReduceInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <DatabaseTransactionVersionSizeInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexStats[] <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingError[] <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private FutureBatchStats[] <Prefetches>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <DatabaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsDtc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Is64Bit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMemoryStatisticThreadRuning>k__BackingField;
    public string StorageEngine { get; public set; }
    public Etag LastDocEtag { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag LastAttachmentEtag { get; public set; }
    public int CountOfIndexes { get; public set; }
    public int CountOfIndexesExcludingDisabledAndAbandoned { get; public set; }
    public int CountOfResultTransformers { get; public set; }
    public Int32[] InMemoryIndexingQueueSizes { get; public set; }
    public long ApproximateTaskCount { get; public set; }
    public long CountOfDocuments { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public long CountOfAttachments { get; public set; }
    public String[] StaleIndexes { get; public set; }
    public int CountOfStaleIndexesExcludingDisabledAndAbandoned { get; public set; }
    public int CurrentNumberOfParallelTasks { get; public set; }
    public int CurrentNumberOfItemsToIndexInSingleBatch { get; public set; }
    public int CurrentNumberOfItemsToReduceInSingleBatch { get; public set; }
    public decimal DatabaseTransactionVersionSizeInMB { get; public set; }
    public IndexStats[] Indexes { get; public set; }
    public IndexingError[] Errors { get; public set; }
    public FutureBatchStats[] Prefetches { get; public set; }
    public Guid DatabaseId { get; public set; }
    public bool SupportsDtc { get; public set; }
    public bool Is64Bit { get; public set; }
    public bool IsMemoryStatisticThreadRuning { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StorageEngine();
    [CompilerGeneratedAttribute]
public void set_StorageEngine(string value);
    [CompilerGeneratedAttribute]
public Etag get_LastDocEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastAttachmentEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentEtag(Etag value);
    [CompilerGeneratedAttribute]
public int get_CountOfIndexes();
    [CompilerGeneratedAttribute]
public void set_CountOfIndexes(int value);
    [CompilerGeneratedAttribute]
public int get_CountOfIndexesExcludingDisabledAndAbandoned();
    [CompilerGeneratedAttribute]
public void set_CountOfIndexesExcludingDisabledAndAbandoned(int value);
    [CompilerGeneratedAttribute]
public int get_CountOfResultTransformers();
    [CompilerGeneratedAttribute]
public void set_CountOfResultTransformers(int value);
    [CompilerGeneratedAttribute]
public Int32[] get_InMemoryIndexingQueueSizes();
    [CompilerGeneratedAttribute]
public void set_InMemoryIndexingQueueSizes(Int32[] value);
    [CompilerGeneratedAttribute]
public long get_ApproximateTaskCount();
    [CompilerGeneratedAttribute]
public void set_ApproximateTaskCount(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfDocuments();
    [CompilerGeneratedAttribute]
public void set_CountOfDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfAttachments();
    [CompilerGeneratedAttribute]
public void set_CountOfAttachments(long value);
    [CompilerGeneratedAttribute]
public String[] get_StaleIndexes();
    [CompilerGeneratedAttribute]
public void set_StaleIndexes(String[] value);
    [CompilerGeneratedAttribute]
public int get_CountOfStaleIndexesExcludingDisabledAndAbandoned();
    [CompilerGeneratedAttribute]
public void set_CountOfStaleIndexesExcludingDisabledAndAbandoned(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentNumberOfParallelTasks();
    [CompilerGeneratedAttribute]
public void set_CurrentNumberOfParallelTasks(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentNumberOfItemsToIndexInSingleBatch();
    [CompilerGeneratedAttribute]
public void set_CurrentNumberOfItemsToIndexInSingleBatch(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentNumberOfItemsToReduceInSingleBatch();
    [CompilerGeneratedAttribute]
public void set_CurrentNumberOfItemsToReduceInSingleBatch(int value);
    [CompilerGeneratedAttribute]
public decimal get_DatabaseTransactionVersionSizeInMB();
    [CompilerGeneratedAttribute]
public void set_DatabaseTransactionVersionSizeInMB(decimal value);
    [CompilerGeneratedAttribute]
public IndexStats[] get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(IndexStats[] value);
    [CompilerGeneratedAttribute]
public IndexingError[] get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(IndexingError[] value);
    [CompilerGeneratedAttribute]
public FutureBatchStats[] get_Prefetches();
    [CompilerGeneratedAttribute]
public void set_Prefetches(FutureBatchStats[] value);
    [CompilerGeneratedAttribute]
public Guid get_DatabaseId();
    [CompilerGeneratedAttribute]
public void set_DatabaseId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_SupportsDtc();
    [CompilerGeneratedAttribute]
public void set_SupportsDtc(bool value);
    [CompilerGeneratedAttribute]
public bool get_Is64Bit();
    [CompilerGeneratedAttribute]
public void set_Is64Bit(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMemoryStatisticThreadRuning();
    [CompilerGeneratedAttribute]
public void set_IsMemoryStatisticThreadRuning(bool value);
}
public class Raven.Abstractions.Data.DataSubscriptionChangeNotification : EventArgs {
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DataSubscriptionChangeTypes <Type>k__BackingField;
    public long Id { get; public set; }
    public DataSubscriptionChangeTypes Type { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(long value);
    [CompilerGeneratedAttribute]
public DataSubscriptionChangeTypes get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(DataSubscriptionChangeTypes value);
}
public enum Raven.Abstractions.Data.DataSubscriptionChangeTypes : Enum {
    public int value__;
    public static DataSubscriptionChangeTypes None;
    public static DataSubscriptionChangeTypes SubscriptionOpened;
    public static DataSubscriptionChangeTypes SubscriptionReleased;
}
public class Raven.Abstractions.Data.DeletionBatchInfo : object {
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalDocumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TotalDurationMs>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PerformanceStats> <PerformanceStats>k__BackingField;
    public long Id { get; public set; }
    public string IndexName { get; public set; }
    public int TotalDocumentCount { get; public set; }
    public DateTime StartedAt { get; public set; }
    public double TotalDurationMs { get; public set; }
    public List`1<PerformanceStats> PerformanceStats { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(long value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public int get_TotalDocumentCount();
    [CompilerGeneratedAttribute]
public void set_TotalDocumentCount(int value);
    [CompilerGeneratedAttribute]
public DateTime get_StartedAt();
    [CompilerGeneratedAttribute]
public void set_StartedAt(DateTime value);
    [CompilerGeneratedAttribute]
public double get_TotalDurationMs();
    [CompilerGeneratedAttribute]
public void set_TotalDurationMs(double value);
    [CompilerGeneratedAttribute]
public List`1<PerformanceStats> get_PerformanceStats();
    [CompilerGeneratedAttribute]
public void set_PerformanceStats(List`1<PerformanceStats> value);
    public void BatchCompleted();
}
public class Raven.Abstractions.Data.DocumentChangeNotification : EventArgs {
    [CompilerGeneratedAttribute]
private DocumentChangeTypes <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public DocumentChangeTypes Type { get; public set; }
    public string Id { get; public set; }
    public string CollectionName { get; public set; }
    public string TypeName { get; public set; }
    public Etag Etag { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public DocumentChangeTypes get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(DocumentChangeTypes value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionName();
    [CompilerGeneratedAttribute]
public void set_CollectionName(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public virtual string ToString();
}
[FlagsAttribute]
public enum Raven.Abstractions.Data.DocumentChangeTypes : Enum {
    public int value__;
    public static DocumentChangeTypes None;
    public static DocumentChangeTypes Put;
    public static DocumentChangeTypes Delete;
    public static DocumentChangeTypes BulkInsertStarted;
    public static DocumentChangeTypes BulkInsertEnded;
    public static DocumentChangeTypes BulkInsertError;
    public static DocumentChangeTypes Common;
}
public class Raven.Abstractions.Data.DocumentsChanges : object {
    [CompilerGeneratedAttribute]
private string <FieldOldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldNewValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldOldType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldNewType>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangeType <Change>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    public string FieldOldValue { get; public set; }
    public string FieldNewValue { get; public set; }
    public string FieldOldType { get; public set; }
    public string FieldNewType { get; public set; }
    public ChangeType Change { get; public set; }
    public string FieldName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FieldOldValue();
    [CompilerGeneratedAttribute]
public void set_FieldOldValue(string value);
    [CompilerGeneratedAttribute]
public string get_FieldNewValue();
    [CompilerGeneratedAttribute]
public void set_FieldNewValue(string value);
    [CompilerGeneratedAttribute]
public string get_FieldOldType();
    [CompilerGeneratedAttribute]
public void set_FieldOldType(string value);
    [CompilerGeneratedAttribute]
public string get_FieldNewType();
    [CompilerGeneratedAttribute]
public void set_FieldNewType(string value);
    [CompilerGeneratedAttribute]
public ChangeType get_Change();
    [CompilerGeneratedAttribute]
public void set_Change(ChangeType value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    protected bool Equals(DocumentsChanges other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Raven.Abstractions.Data.EmbeddedRavenConnectionStringOptions : RavenConnectionStringOptions {
    [CompilerGeneratedAttribute]
private bool <AllowEmbeddedOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DataDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunInMemory>k__BackingField;
    public bool AllowEmbeddedOptions { get; public set; }
    public string DataDirectory { get; public set; }
    public bool RunInMemory { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowEmbeddedOptions();
    [CompilerGeneratedAttribute]
public void set_AllowEmbeddedOptions(bool value);
    [CompilerGeneratedAttribute]
public string get_DataDirectory();
    [CompilerGeneratedAttribute]
public void set_DataDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_RunInMemory();
    [CompilerGeneratedAttribute]
public void set_RunInMemory(bool value);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Data.EnumerableExtension : object {
    [ExtensionAttribute]
public static void ApplyIfNotNull(IEnumerable`1<T> self, Action`1<T> action);
    [ExtensionAttribute]
public static IEnumerable`1<T> EmptyIfNull(IEnumerable`1<T> self);
}
public class Raven.Abstractions.Data.EsentStorageStats : object {
}
public class Raven.Abstractions.Data.Etag : object {
    private long restarts;
    private long changes;
    private static Int32[] _asciisOfHexToNum;
    private static Int32[] ByteToHexStringAsInt32Lookup;
    public long Restarts { get; }
    public long Changes { get; }
    public static Etag InvalidEtag { get; }
    public static Etag Empty { get; }
    public Etag(string str);
    public Etag(UuidType type, long restarts, long changes);
    private static Etag();
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(Etag other);
    public sealed virtual int CompareTo(object other);
    public long get_Restarts();
    public long get_Changes();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Etag a, Etag b);
    public static bool op_Inequality(Etag a, Etag b);
    public sealed virtual bool Equals(Etag other);
    private IEnumerable`1<byte> ToBytes();
    public Byte[] ToByteArray();
    public virtual string ToString();
    public static Etag Parse(Byte[] bytes);
    public static bool TryParse(string str, Etag& etag);
    private static Int32[] CreateHexCharsToNumsTable();
    public static Etag Parse(string str);
    public static Etag get_InvalidEtag();
    public static Etag get_Empty();
    public Etag Setup(UuidType type, long restartsNum);
    public Etag IncrementBy(int amount);
    public Etag DecrementBy(int amount);
    public static string op_Implicit(Etag etag);
    public static Etag op_Implicit(string s);
    public static Etag op_Implicit(Guid g);
    public static Nullable`1<Guid> op_Implicit(Etag e);
    public static Etag op_Implicit(Nullable`1<Guid> g);
    public static Guid op_Implicit(Etag e);
    public Etag HashWith(Etag other);
    public Etag HashWith(IEnumerable`1<byte> bytes);
    public static Etag Max(Etag first, Etag second);
    private static Guid EtagToGuid(Etag etag);
    private static Etag GuidToEtag(Guid guid);
}
public class Raven.Abstractions.Data.EtagJsonConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Abstractions.Data.ExtensionsLog : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionsLogDetail[] <Installed>k__BackingField;
    public string Name { get; public set; }
    public ExtensionsLogDetail[] Installed { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ExtensionsLogDetail[] get_Installed();
    [CompilerGeneratedAttribute]
public void set_Installed(ExtensionsLogDetail[] value);
}
public class Raven.Abstractions.Data.ExtensionsLogDetail : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Assembly>k__BackingField;
    public string Name { get; public set; }
    public string Assembly { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(string value);
}
public class Raven.Abstractions.Data.Facet : object {
    [JsonIgnoreAttribute]
private string displayName;
    [CompilerGeneratedAttribute]
private FacetMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private FacetAggregation <Aggregation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AggregationField>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AggregationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Ranges>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private FacetTermSortMode <TermSortMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeRemainingTerms>k__BackingField;
    public FacetMode Mode { get; public set; }
    public FacetAggregation Aggregation { get; public set; }
    public string AggregationField { get; public set; }
    public string AggregationType { get; public set; }
    public string Name { get; public set; }
    public string DisplayName { get; public set; }
    public List`1<string> Ranges { get; public set; }
    public Nullable`1<int> MaxResults { get; public set; }
    public FacetTermSortMode TermSortMode { get; public set; }
    public bool IncludeRemainingTerms { get; public set; }
    [CompilerGeneratedAttribute]
public FacetMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(FacetMode value);
    [CompilerGeneratedAttribute]
public FacetAggregation get_Aggregation();
    [CompilerGeneratedAttribute]
public void set_Aggregation(FacetAggregation value);
    [CompilerGeneratedAttribute]
public string get_AggregationField();
    [CompilerGeneratedAttribute]
public void set_AggregationField(string value);
    [CompilerGeneratedAttribute]
public string get_AggregationType();
    [CompilerGeneratedAttribute]
public void set_AggregationType(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Ranges();
    [CompilerGeneratedAttribute]
public void set_Ranges(List`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public FacetTermSortMode get_TermSortMode();
    [CompilerGeneratedAttribute]
public void set_TermSortMode(FacetTermSortMode value);
    [CompilerGeneratedAttribute]
public bool get_IncludeRemainingTerms();
    [CompilerGeneratedAttribute]
public void set_IncludeRemainingTerms(bool value);
}
public class Raven.Abstractions.Data.Facet`1 : object {
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<T, object>> <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression`1<Func`2<T, bool>>> <Ranges>k__BackingField;
    public Expression`1<Func`2<T, object>> Name { get; public set; }
    public List`1<Expression`1<Func`2<T, bool>>> Ranges { get; public set; }
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<T, object>> get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(Expression`1<Func`2<T, object>> value);
    [CompilerGeneratedAttribute]
public List`1<Expression`1<Func`2<T, bool>>> get_Ranges();
    [CompilerGeneratedAttribute]
public void set_Ranges(List`1<Expression`1<Func`2<T, bool>>> value);
    public static Facet op_Implicit(Facet`1<T> other);
    private static Type GetExpressionType(Expression expr);
    public static string Parse(Expression`1<Func`2<T, bool>> expr);
    private static string GetFieldName(MemberExpression left);
    private static object ParseSubExpression(BinaryExpression operation);
    private static object ParseUnaryExpression(UnaryExpression expression);
    private static string GetStringRepresentation(ExpressionType op, object value);
    private static string GetStringRepresentation(ExpressionType leftOp, ExpressionType rightOp, object lValue, object rValue);
    private static string CalculateBraces(ExpressionType op, bool isLeft);
    private static string GetStringValue(object value);
}
[FlagsAttribute]
public enum Raven.Abstractions.Data.FacetAggregation : Enum {
    public int value__;
    public static FacetAggregation None;
    public static FacetAggregation Count;
    public static FacetAggregation Max;
    public static FacetAggregation Min;
    public static FacetAggregation Average;
    public static FacetAggregation Sum;
    public static FacetAggregation Distinct;
}
public enum Raven.Abstractions.Data.FacetMode : Enum {
    public int value__;
    public static FacetMode Default;
    public static FacetMode Ranges;
}
public class Raven.Abstractions.Data.FacetQuery : object {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexQuery <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FacetSetupDoc>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Facet> <Facets>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageStart>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PageSize>k__BackingField;
    public string IndexName { get; public set; }
    public IndexQuery Query { get; public set; }
    public string FacetSetupDoc { get; public set; }
    public List`1<Facet> Facets { get; public set; }
    public int PageStart { get; public set; }
    public Nullable`1<int> PageSize { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public IndexQuery get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(IndexQuery value);
    [CompilerGeneratedAttribute]
public string get_FacetSetupDoc();
    [CompilerGeneratedAttribute]
public void set_FacetSetupDoc(string value);
    [CompilerGeneratedAttribute]
public List`1<Facet> get_Facets();
    [CompilerGeneratedAttribute]
public void set_Facets(List`1<Facet> value);
    [CompilerGeneratedAttribute]
public int get_PageStart();
    [CompilerGeneratedAttribute]
public void set_PageStart(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PageSize();
    [CompilerGeneratedAttribute]
public void set_PageSize(Nullable`1<int> value);
}
public class Raven.Abstractions.Data.FacetResult : object {
    [CompilerGeneratedAttribute]
private List`1<FacetValue> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <RemainingTerms>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemainingTermsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemainingHits>k__BackingField;
    public List`1<FacetValue> Values { get; public set; }
    public List`1<string> RemainingTerms { get; public set; }
    public int RemainingTermsCount { get; public set; }
    public int RemainingHits { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<FacetValue> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(List`1<FacetValue> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_RemainingTerms();
    [CompilerGeneratedAttribute]
public void set_RemainingTerms(List`1<string> value);
    [CompilerGeneratedAttribute]
public int get_RemainingTermsCount();
    [CompilerGeneratedAttribute]
public void set_RemainingTermsCount(int value);
    [CompilerGeneratedAttribute]
public int get_RemainingHits();
    [CompilerGeneratedAttribute]
public void set_RemainingHits(int value);
}
public class Raven.Abstractions.Data.FacetResults : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, FacetResult> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <IndexStateEtag>k__BackingField;
    public Dictionary`2<string, FacetResult> Results { get; public set; }
    public TimeSpan Duration { get; public set; }
    public Etag IndexStateEtag { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, FacetResult> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(Dictionary`2<string, FacetResult> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public Etag get_IndexStateEtag();
    [CompilerGeneratedAttribute]
public void set_IndexStateEtag(Etag value);
}
public class Raven.Abstractions.Data.FacetSetup : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Facet> <Facets>k__BackingField;
    public string Id { get; public set; }
    public List`1<Facet> Facets { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public List`1<Facet> get_Facets();
    [CompilerGeneratedAttribute]
public void set_Facets(List`1<Facet> value);
}
public enum Raven.Abstractions.Data.FacetTermSortMode : Enum {
    public int value__;
    public static FacetTermSortMode ValueAsc;
    public static FacetTermSortMode ValueDesc;
    public static FacetTermSortMode HitsAsc;
    public static FacetTermSortMode HitsDesc;
}
public class Raven.Abstractions.Data.FacetValue : object {
    [CompilerGeneratedAttribute]
private string <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exists>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hits>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Sum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Average>k__BackingField;
    public string Range { get; public set; }
    public bool Exists { get; public set; }
    public int Hits { get; public set; }
    public Nullable`1<int> Count { get; public set; }
    public Nullable`1<double> Sum { get; public set; }
    public Nullable`1<double> Max { get; public set; }
    public Nullable`1<double> Min { get; public set; }
    public Nullable`1<double> Average { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(string value);
    [CompilerGeneratedAttribute]
public bool get_Exists();
    [CompilerGeneratedAttribute]
public void set_Exists(bool value);
    [CompilerGeneratedAttribute]
public int get_Hits();
    [CompilerGeneratedAttribute]
public void set_Hits(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Sum();
    [CompilerGeneratedAttribute]
public void set_Sum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Average();
    [CompilerGeneratedAttribute]
public void set_Average(Nullable`1<double> value);
    public Nullable`1<double> GetAggregation(FacetAggregation aggregation);
    public virtual string ToString();
}
public class Raven.Abstractions.Data.FailoverServers : object {
    private HashSet`1<ReplicationDestination> forDefaultDatabase;
    private IDictionary`2<string, HashSet`1<ReplicationDestination>> forDatabases;
    public ReplicationDestination[] ForDefaultDatabase { get; public set; }
    unknown IDictionary`2<string, ReplicationDestination[]> ForDatabases {public set; }
    public bool IsSetForDefaultDatabase { get; }
    public ReplicationDestination[] get_ForDefaultDatabase();
    public void set_ForDefaultDatabase(ReplicationDestination[] value);
    public void set_ForDatabases(IDictionary`2<string, ReplicationDestination[]> value);
    public bool get_IsSetForDefaultDatabase();
    public bool IsSetForDatabase(string databaseName);
    public ReplicationDestination[] GetForDatabase(string databaseName);
    public void AddForDefaultDatabase(ReplicationDestination[] destinations);
    public void AddForDatabase(string databaseName, ReplicationDestination[] destinations);
}
public class Raven.Abstractions.Data.FilesConnectionStringOptions : ConnectionStringOptions {
    [CompilerGeneratedAttribute]
private string <DefaultFileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxChunkSizeInMb>k__BackingField;
    public string DefaultFileSystem { get; public set; }
    public int MaxChunkSizeInMb { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DefaultFileSystem();
    [CompilerGeneratedAttribute]
public void set_DefaultFileSystem(string value);
    [CompilerGeneratedAttribute]
public int get_MaxChunkSizeInMb();
    [CompilerGeneratedAttribute]
public void set_MaxChunkSizeInMb(int value);
    public virtual string ToString();
}
public class Raven.Abstractions.Data.FilesystemBackupRequest : object {
    [CompilerGeneratedAttribute]
private string <BackupLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemDocument <FileSystemDocument>k__BackingField;
    public string BackupLocation { get; public set; }
    public FileSystemDocument FileSystemDocument { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BackupLocation();
    [CompilerGeneratedAttribute]
public void set_BackupLocation(string value);
    [CompilerGeneratedAttribute]
public FileSystemDocument get_FileSystemDocument();
    [CompilerGeneratedAttribute]
public void set_FileSystemDocument(FileSystemDocument value);
}
public class Raven.Abstractions.Data.FilesystemRestoreRequest : AbstractRestoreRequest {
    [CompilerGeneratedAttribute]
private string <FilesystemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilesystemLocation>k__BackingField;
    public string FilesystemName { get; public set; }
    public string FilesystemLocation { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FilesystemName();
    [CompilerGeneratedAttribute]
public void set_FilesystemName(string value);
    [CompilerGeneratedAttribute]
public string get_FilesystemLocation();
    [CompilerGeneratedAttribute]
public void set_FilesystemLocation(string value);
}
public class Raven.Abstractions.Data.FilteredOutIndexStat : object {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    public DateTime Timestamp { get; public set; }
    public string IndexName { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
}
public class Raven.Abstractions.Data.FutureBatchStats : object {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private PrefetchingUser <PrefetchingUser>k__BackingField;
    public DateTime Timestamp { get; public set; }
    public Nullable`1<TimeSpan> Duration { get; public set; }
    public Nullable`1<int> Size { get; public set; }
    public PrefetchingUser PrefetchingUser { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public PrefetchingUser get_PrefetchingUser();
    [CompilerGeneratedAttribute]
public void set_PrefetchingUser(PrefetchingUser value);
}
public class Raven.Abstractions.Data.GCInfo : object {
    [CompilerGeneratedAttribute]
private DateTime <LastForcedGCTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MemoryBeforeLastForcedGC>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MemoryAfterLastForcedGC>k__BackingField;
    public DateTime LastForcedGCTime { get; public set; }
    public long MemoryBeforeLastForcedGC { get; public set; }
    public long MemoryAfterLastForcedGC { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_LastForcedGCTime();
    [CompilerGeneratedAttribute]
public void set_LastForcedGCTime(DateTime value);
    [CompilerGeneratedAttribute]
public long get_MemoryBeforeLastForcedGC();
    [CompilerGeneratedAttribute]
public void set_MemoryBeforeLastForcedGC(long value);
    [CompilerGeneratedAttribute]
public long get_MemoryAfterLastForcedGC();
    [CompilerGeneratedAttribute]
public void set_MemoryAfterLastForcedGC(long value);
    public virtual string ToString();
}
public class Raven.Abstractions.Data.GetRequest : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public string Url { get; public set; }
    public IDictionary`2<string, string> Headers { get; public set; }
    public string Query { get; public set; }
    public string Method { get; public set; }
    [JsonIgnoreAttribute]
public string UrlAndQuery { get; }
    public string Content { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    public string get_UrlAndQuery();
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
}
public class Raven.Abstractions.Data.GetResponse : object {
    [CompilerGeneratedAttribute]
private RavenJToken <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceRetry>k__BackingField;
    public RavenJToken Result { get; public set; }
    public IDictionary`2<string, string> Headers { get; public set; }
    public int Status { get; public set; }
    public bool ForceRetry { get; public set; }
    [CompilerGeneratedAttribute]
public RavenJToken get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(RavenJToken value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public int get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(int value);
    [CompilerGeneratedAttribute]
public bool get_ForceRetry();
    [CompilerGeneratedAttribute]
public void set_ForceRetry(bool value);
    public bool RequestHasErrors();
}
public class Raven.Abstractions.Data.HighlightedField : object {
    private static Regex FieldOptionMatch;
    [CompilerGeneratedAttribute]
private string <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FragmentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FragmentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FragmentsField>k__BackingField;
    public string Field { get; private set; }
    public int FragmentLength { get; private set; }
    public int FragmentCount { get; private set; }
    public string FragmentsField { get; private set; }
    public HighlightedField(string field, int fragmentLength, int fragmentCount, string fragmentsField);
    private static HighlightedField();
    [CompilerGeneratedAttribute]
public string get_Field();
    [CompilerGeneratedAttribute]
private void set_Field(string value);
    [CompilerGeneratedAttribute]
public int get_FragmentLength();
    [CompilerGeneratedAttribute]
private void set_FragmentLength(int value);
    [CompilerGeneratedAttribute]
public int get_FragmentCount();
    [CompilerGeneratedAttribute]
private void set_FragmentCount(int value);
    [CompilerGeneratedAttribute]
public string get_FragmentsField();
    [CompilerGeneratedAttribute]
private void set_FragmentsField(string value);
    public static bool TryParse(string value, HighlightedField& result);
    public virtual string ToString();
    public HighlightedField Clone();
}
public class Raven.Abstractions.Data.HistogramData : object {
    [CompilerGeneratedAttribute]
private long <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Stdev>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, double> <Percentiles>k__BackingField;
    public MetricType Type;
    public long Counter { get; public set; }
    public double Max { get; public set; }
    public double Min { get; public set; }
    public double Mean { get; public set; }
    public double Stdev { get; public set; }
    public Dictionary`2<string, double> Percentiles { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Counter();
    [CompilerGeneratedAttribute]
public void set_Counter(long value);
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(double value);
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
public void set_Mean(double value);
    [CompilerGeneratedAttribute]
public double get_Stdev();
    [CompilerGeneratedAttribute]
public void set_Stdev(double value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, double> get_Percentiles();
    [CompilerGeneratedAttribute]
public void set_Percentiles(Dictionary`2<string, double> value);
}
public interface Raven.Abstractions.Data.IJsonDocumentMetadata {
    public RavenJObject Metadata { get; public set; }
    public string Key { get; public set; }
    public Nullable`1<bool> NonAuthoritativeInformation { get; public set; }
    public Etag Etag { get; public set; }
    public Nullable`1<DateTime> LastModified { get; public set; }
    public abstract virtual RavenJObject get_Metadata();
    public abstract virtual void set_Metadata(RavenJObject value);
    public abstract virtual string get_Key();
    public abstract virtual void set_Key(string value);
    public abstract virtual Nullable`1<bool> get_NonAuthoritativeInformation();
    public abstract virtual void set_NonAuthoritativeInformation(Nullable`1<bool> value);
    public abstract virtual Etag get_Etag();
    public abstract virtual void set_Etag(Etag value);
    public abstract virtual Nullable`1<DateTime> get_LastModified();
    public abstract virtual void set_LastModified(Nullable`1<DateTime> value);
}
public interface Raven.Abstractions.Data.IMetricsData {
}
public class Raven.Abstractions.Data.IndexChangeNotification : EventArgs {
    [CompilerGeneratedAttribute]
private IndexChangeTypes <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Collections>k__BackingField;
    public IndexChangeTypes Type { get; public set; }
    public string Name { get; public set; }
    public Nullable`1<int> Version { get; public set; }
    public Etag Etag { get; public set; }
    public HashSet`1<string> Collections { get; public set; }
    [CompilerGeneratedAttribute]
public IndexChangeTypes get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(IndexChangeTypes value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(HashSet`1<string> value);
    public virtual string ToString();
}
[FlagsAttribute]
public enum Raven.Abstractions.Data.IndexChangeTypes : Enum {
    public int value__;
    public static IndexChangeTypes None;
    public static IndexChangeTypes MapCompleted;
    public static IndexChangeTypes ReduceCompleted;
    public static IndexChangeTypes RemoveFromIndex;
    public static IndexChangeTypes IndexAdded;
    public static IndexChangeTypes IndexRemoved;
    public static IndexChangeTypes IndexDemotedToIdle;
    public static IndexChangeTypes IndexPromotedFromIdle;
    public static IndexChangeTypes IndexDemotedToAbandoned;
    public static IndexChangeTypes IndexDemotedToDisabled;
    public static IndexChangeTypes IndexMarkedAsErrored;
    public static IndexChangeTypes SideBySideReplace;
}
public class Raven.Abstractions.Data.IndexFailureInformation : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Attempts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Successes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReduceAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReduceErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReduceSuccesses>k__BackingField;
    public bool IsInvalidIndex { get; }
    public int Id { get; public set; }
    public int Attempts { get; public set; }
    public int Errors { get; public set; }
    public int Successes { get; public set; }
    public Nullable`1<int> ReduceAttempts { get; public set; }
    public Nullable`1<int> ReduceErrors { get; public set; }
    public Nullable`1<int> ReduceSuccesses { get; public set; }
    public float FailureRate { get; }
    public bool get_IsInvalidIndex();
    public static bool CheckIndexInvalid(int attempts, int errors, Nullable`1<int> reduceAttempts, Nullable`1<int> reduceErrors);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public int get_Attempts();
    [CompilerGeneratedAttribute]
public void set_Attempts(int value);
    [CompilerGeneratedAttribute]
public int get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(int value);
    [CompilerGeneratedAttribute]
public int get_Successes();
    [CompilerGeneratedAttribute]
public void set_Successes(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ReduceAttempts();
    [CompilerGeneratedAttribute]
public void set_ReduceAttempts(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ReduceErrors();
    [CompilerGeneratedAttribute]
public void set_ReduceErrors(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ReduceSuccesses();
    [CompilerGeneratedAttribute]
public void set_ReduceSuccesses(Nullable`1<int> value);
    public float get_FailureRate();
    public string GetErrorMessage();
}
public class Raven.Abstractions.Data.IndexingBatchInfo : object {
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private BatchType <BatchType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <IndexesToWorkOn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalDocumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalDocumentSize>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TotalDurationMs>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TimeSinceFirstIndexInBatchCompletedMs>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, IndexingPerformanceStats> <PerformanceStats>k__BackingField;
    public long Id { get; public set; }
    public BatchType BatchType { get; public set; }
    public List`1<string> IndexesToWorkOn { get; public set; }
    public int TotalDocumentCount { get; public set; }
    public long TotalDocumentSize { get; public set; }
    public DateTime StartedAt { get; public set; }
    public double TotalDurationMs { get; public set; }
    public double TimeSinceFirstIndexInBatchCompletedMs { get; public set; }
    public ConcurrentDictionary`2<string, IndexingPerformanceStats> PerformanceStats { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(long value);
    [CompilerGeneratedAttribute]
public BatchType get_BatchType();
    [CompilerGeneratedAttribute]
public void set_BatchType(BatchType value);
    [CompilerGeneratedAttribute]
public List`1<string> get_IndexesToWorkOn();
    [CompilerGeneratedAttribute]
public void set_IndexesToWorkOn(List`1<string> value);
    [CompilerGeneratedAttribute]
public int get_TotalDocumentCount();
    [CompilerGeneratedAttribute]
public void set_TotalDocumentCount(int value);
    [CompilerGeneratedAttribute]
public long get_TotalDocumentSize();
    [CompilerGeneratedAttribute]
public void set_TotalDocumentSize(long value);
    [CompilerGeneratedAttribute]
public DateTime get_StartedAt();
    [CompilerGeneratedAttribute]
public void set_StartedAt(DateTime value);
    [CompilerGeneratedAttribute]
public double get_TotalDurationMs();
    [CompilerGeneratedAttribute]
public void set_TotalDurationMs(double value);
    [CompilerGeneratedAttribute]
public double get_TimeSinceFirstIndexInBatchCompletedMs();
    [CompilerGeneratedAttribute]
public void set_TimeSinceFirstIndexInBatchCompletedMs(double value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, IndexingPerformanceStats> get_PerformanceStats();
    [CompilerGeneratedAttribute]
public void set_PerformanceStats(ConcurrentDictionary`2<string, IndexingPerformanceStats> value);
    public void BatchCompleted();
}
public class Raven.Abstractions.Data.IndexingError : object {
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    public long Id { get; public set; }
    public int Index { get; public set; }
    public string IndexName { get; public set; }
    public string Error { get; public set; }
    public DateTime Timestamp { get; public set; }
    public string Document { get; public set; }
    public string Action { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(long value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(string value);
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(string value);
    public virtual string ToString();
}
public enum Raven.Abstractions.Data.IndexingOperation : Enum {
    public int value__;
    public static IndexingOperation LoadDocument;
    public static IndexingOperation Linq_MapExecution;
    public static IndexingOperation Linq_ReduceLinqExecution;
    public static IndexingOperation Lucene_DeleteExistingDocument;
    public static IndexingOperation Lucene_ConvertToLuceneDocument;
    public static IndexingOperation Lucene_AddDocument;
    public static IndexingOperation Lucene_FlushToDisk;
    public static IndexingOperation Lucene_RecreateSearcher;
    public static IndexingOperation Map_DeleteMappedResults;
    public static IndexingOperation Map_ConvertToRavenJObject;
    public static IndexingOperation Map_PutMappedResults;
    public static IndexingOperation Map_ScheduleReductions;
    public static IndexingOperation Reduce_GetItemsToReduce;
    public static IndexingOperation Reduce_DeleteScheduledReductions;
    public static IndexingOperation Reduce_ScheduleReductions;
    public static IndexingOperation Reduce_GetMappedResults;
    public static IndexingOperation Reduce_RemoveReduceResults;
    public static IndexingOperation UpdateDocumentReferences;
    public static IndexingOperation Delete_DeleteMappedResultsForDocumentId;
    public static IndexingOperation Delete_Documents;
    public static IndexingOperation Delete_IndexUpdateTriggers;
    public static IndexingOperation Extension_Suggestions;
    public static IndexingOperation StorageCommit;
}
public class Raven.Abstractions.Data.IndexingPerformanceStatistics : object {
    [CompilerGeneratedAttribute]
private int <IndexId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingPerformanceStats[] <Performance>k__BackingField;
    public int IndexId { get; public set; }
    public string IndexName { get; public set; }
    public IndexingPerformanceStats[] Performance { get; public set; }
    [CompilerGeneratedAttribute]
public int get_IndexId();
    [CompilerGeneratedAttribute]
public void set_IndexId(int value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public IndexingPerformanceStats[] get_Performance();
    [CompilerGeneratedAttribute]
public void set_Performance(IndexingPerformanceStats[] value);
}
public class Raven.Abstractions.Data.IndexingPerformanceStats : object {
    [CompilerGeneratedAttribute]
private string <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ItemsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InputCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OutputCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private BasePerformanceStats[] <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <WaitingTimeSinceLastBatchCompleted>k__BackingField;
    [JsonIgnoreAttribute]
public Action OnCompleted;
    public string Operation { get; public set; }
    public int ItemsCount { get; public set; }
    public int InputCount { get; public set; }
    public int OutputCount { get; public set; }
    public DateTime Started { get; public set; }
    public DateTime Completed { get; public set; }
    public TimeSpan Duration { get; public set; }
    public double DurationMilliseconds { get; }
    [JsonPropertyAttribute]
public BasePerformanceStats[] Operations { get; public set; }
    public TimeSpan WaitingTimeSinceLastBatchCompleted { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(string value);
    [CompilerGeneratedAttribute]
public int get_ItemsCount();
    [CompilerGeneratedAttribute]
public void set_ItemsCount(int value);
    [CompilerGeneratedAttribute]
public int get_InputCount();
    [CompilerGeneratedAttribute]
public void set_InputCount(int value);
    [CompilerGeneratedAttribute]
public int get_OutputCount();
    [CompilerGeneratedAttribute]
public void set_OutputCount(int value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    public double get_DurationMilliseconds();
    [CompilerGeneratedAttribute]
public BasePerformanceStats[] get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(BasePerformanceStats[] value);
    [CompilerGeneratedAttribute]
public TimeSpan get_WaitingTimeSinceLastBatchCompleted();
    [CompilerGeneratedAttribute]
public void set_WaitingTimeSinceLastBatchCompleted(TimeSpan value);
    public void RunCompleted();
}
[FlagsAttribute]
public enum Raven.Abstractions.Data.IndexingPriority : Enum {
    public int value__;
    public static IndexingPriority None;
    public static IndexingPriority Normal;
    public static IndexingPriority Disabled;
    public static IndexingPriority Idle;
    public static IndexingPriority Abandoned;
    public static IndexingPriority Error;
    public static IndexingPriority Forced;
}
public class Raven.Abstractions.Data.IndexingStatus : object {
    [CompilerGeneratedAttribute]
private string <MappingStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReducingStatus>k__BackingField;
    public string MappingStatus { get; public set; }
    public string ReducingStatus { get; public set; }
    [CompilerGeneratedAttribute]
public string get_MappingStatus();
    [CompilerGeneratedAttribute]
public void set_MappingStatus(string value);
    [CompilerGeneratedAttribute]
public string get_ReducingStatus();
    [CompilerGeneratedAttribute]
public void set_ReducingStatus(string value);
}
public class Raven.Abstractions.Data.IndexQuery : object {
    private int pageSize;
    [CompilerGeneratedAttribute]
private bool <PageSizeSet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDistinct>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private Reference`1<int> <TotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SortOptions> <SortHints>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, RavenJToken> <TransformerParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FieldsToFetch>k__BackingField;
    [CompilerGeneratedAttribute]
private SortedField[] <SortedFields>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Cutoff>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WaitForNonStaleResultsAsOfNow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WaitForNonStaleResults>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <CutoffEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultField>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryOperator <DefaultOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultipleIndexEntriesForSameDocumentToResultTransformer>k__BackingField;
    [CompilerGeneratedAttribute]
private Reference`1<int> <SkippedResults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugOptionGetIndexEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightedField[] <HighlightedFields>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <HighlighterPreTags>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <HighlighterPostTags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HighlighterKeyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResultsTransformer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableCaching>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipDuplicateChecking>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplainScores>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowTimings>k__BackingField;
    public bool PageSizeSet { get; private set; }
    public bool IsDistinct { get; public set; }
    public string Query { get; public set; }
    public Reference`1<int> TotalSize { get; private set; }
    public Dictionary`2<string, SortOptions> SortHints { get; public set; }
    public Dictionary`2<string, RavenJToken> TransformerParameters { get; public set; }
    public int Start { get; public set; }
    public int PageSize { get; public set; }
    public String[] FieldsToFetch { get; public set; }
    public SortedField[] SortedFields { get; public set; }
    public Nullable`1<DateTime> Cutoff { get; public set; }
    public bool WaitForNonStaleResultsAsOfNow { get; public set; }
    public bool WaitForNonStaleResults { get; public set; }
    public Etag CutoffEtag { get; public set; }
    public string DefaultField { get; public set; }
    public QueryOperator DefaultOperator { get; public set; }
    public bool AllowMultipleIndexEntriesForSameDocumentToResultTransformer { get; public set; }
    public Reference`1<int> SkippedResults { get; public set; }
    public bool DebugOptionGetIndexEntries { get; public set; }
    public HighlightedField[] HighlightedFields { get; public set; }
    public String[] HighlighterPreTags { get; public set; }
    public String[] HighlighterPostTags { get; public set; }
    public string HighlighterKeyName { get; public set; }
    public string ResultsTransformer { get; public set; }
    public bool DisableCaching { get; public set; }
    public bool SkipDuplicateChecking { get; public set; }
    public bool ExplainScores { get; public set; }
    public bool ShowTimings { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PageSizeSet();
    [CompilerGeneratedAttribute]
private void set_PageSizeSet(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDistinct();
    [CompilerGeneratedAttribute]
public void set_IsDistinct(bool value);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(string value);
    [CompilerGeneratedAttribute]
public Reference`1<int> get_TotalSize();
    [CompilerGeneratedAttribute]
private void set_TotalSize(Reference`1<int> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SortOptions> get_SortHints();
    [CompilerGeneratedAttribute]
public void set_SortHints(Dictionary`2<string, SortOptions> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, RavenJToken> get_TransformerParameters();
    [CompilerGeneratedAttribute]
public void set_TransformerParameters(Dictionary`2<string, RavenJToken> value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    public int get_PageSize();
    public void set_PageSize(int value);
    [CompilerGeneratedAttribute]
public String[] get_FieldsToFetch();
    [CompilerGeneratedAttribute]
public void set_FieldsToFetch(String[] value);
    [CompilerGeneratedAttribute]
public SortedField[] get_SortedFields();
    [CompilerGeneratedAttribute]
public void set_SortedFields(SortedField[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Cutoff();
    [CompilerGeneratedAttribute]
public void set_Cutoff(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_WaitForNonStaleResultsAsOfNow();
    [CompilerGeneratedAttribute]
public void set_WaitForNonStaleResultsAsOfNow(bool value);
    [CompilerGeneratedAttribute]
public bool get_WaitForNonStaleResults();
    [CompilerGeneratedAttribute]
public void set_WaitForNonStaleResults(bool value);
    [CompilerGeneratedAttribute]
public Etag get_CutoffEtag();
    [CompilerGeneratedAttribute]
public void set_CutoffEtag(Etag value);
    [CompilerGeneratedAttribute]
public string get_DefaultField();
    [CompilerGeneratedAttribute]
public void set_DefaultField(string value);
    [CompilerGeneratedAttribute]
public QueryOperator get_DefaultOperator();
    [CompilerGeneratedAttribute]
public void set_DefaultOperator(QueryOperator value);
    [CompilerGeneratedAttribute]
public bool get_AllowMultipleIndexEntriesForSameDocumentToResultTransformer();
    [CompilerGeneratedAttribute]
public void set_AllowMultipleIndexEntriesForSameDocumentToResultTransformer(bool value);
    [CompilerGeneratedAttribute]
public Reference`1<int> get_SkippedResults();
    [CompilerGeneratedAttribute]
public void set_SkippedResults(Reference`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_DebugOptionGetIndexEntries();
    [CompilerGeneratedAttribute]
public void set_DebugOptionGetIndexEntries(bool value);
    [CompilerGeneratedAttribute]
public HighlightedField[] get_HighlightedFields();
    [CompilerGeneratedAttribute]
public void set_HighlightedFields(HighlightedField[] value);
    [CompilerGeneratedAttribute]
public String[] get_HighlighterPreTags();
    [CompilerGeneratedAttribute]
public void set_HighlighterPreTags(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_HighlighterPostTags();
    [CompilerGeneratedAttribute]
public void set_HighlighterPostTags(String[] value);
    [CompilerGeneratedAttribute]
public string get_HighlighterKeyName();
    [CompilerGeneratedAttribute]
public void set_HighlighterKeyName(string value);
    [CompilerGeneratedAttribute]
public string get_ResultsTransformer();
    [CompilerGeneratedAttribute]
public void set_ResultsTransformer(string value);
    [CompilerGeneratedAttribute]
public bool get_DisableCaching();
    [CompilerGeneratedAttribute]
public void set_DisableCaching(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipDuplicateChecking();
    [CompilerGeneratedAttribute]
public void set_SkipDuplicateChecking(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExplainScores();
    [CompilerGeneratedAttribute]
public void set_ExplainScores(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowTimings();
    [CompilerGeneratedAttribute]
public void set_ShowTimings(bool value);
    public string GetIndexQueryUrl(string operationUrl, string index, string operationName, bool includePageSizeEvenIfNotExplicitlySet, bool includeQuery);
    public string GetMinimalQueryString();
    public string GetQueryString();
    public void AppendQueryString(StringBuilder path, bool includePageSizeEvenIfNotExplicitlySet, bool includeQuery);
    private void AppendMinimalQueryString(StringBuilder path, bool appendQuery);
    protected virtual string GetCustomQueryStringVariables();
    public IndexQuery Clone();
    public virtual string ToString();
    public sealed virtual bool Equals(IndexQuery other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(IndexQuery left, IndexQuery right);
    public static bool op_Inequality(IndexQuery left, IndexQuery right);
}
public class Raven.Abstractions.Data.IndexStats : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexingAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexingSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexingErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastIndexedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <IndexingLag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastIndexedTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastQueryTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TouchCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReduceIndexingAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReduceIndexingSuccesses>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReduceIndexingErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastReducedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastReducedTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastIndexingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IsOnRam>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexLockMode <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMapReduce>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ForEntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTestIndex>k__BackingField;
    public int Id { get; public set; }
    public string Name { get; public set; }
    public int IndexingAttempts { get; public set; }
    public int IndexingSuccesses { get; public set; }
    public int IndexingErrors { get; public set; }
    public Etag LastIndexedEtag { get; public set; }
    public Nullable`1<int> IndexingLag { get; public set; }
    public DateTime LastIndexedTimestamp { get; public set; }
    public Nullable`1<DateTime> LastQueryTimestamp { get; public set; }
    public int TouchCount { get; public set; }
    public IndexingPriority Priority { get; public set; }
    public Nullable`1<int> ReduceIndexingAttempts { get; public set; }
    public Nullable`1<int> ReduceIndexingSuccesses { get; public set; }
    public Nullable`1<int> ReduceIndexingErrors { get; public set; }
    public Etag LastReducedEtag { get; public set; }
    public Nullable`1<DateTime> LastReducedTimestamp { get; public set; }
    public DateTime CreatedTimestamp { get; public set; }
    public DateTime LastIndexingTime { get; public set; }
    public string IsOnRam { get; public set; }
    public IndexLockMode LockMode { get; public set; }
    public bool IsMapReduce { get; public set; }
    public String[] ForEntityName { get; public set; }
    public int DocsCount { get; public set; }
    public bool IsTestIndex { get; public set; }
    public bool IsInvalidIndex { get; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_IndexingAttempts();
    [CompilerGeneratedAttribute]
public void set_IndexingAttempts(int value);
    [CompilerGeneratedAttribute]
public int get_IndexingSuccesses();
    [CompilerGeneratedAttribute]
public void set_IndexingSuccesses(int value);
    [CompilerGeneratedAttribute]
public int get_IndexingErrors();
    [CompilerGeneratedAttribute]
public void set_IndexingErrors(int value);
    [CompilerGeneratedAttribute]
public Etag get_LastIndexedEtag();
    [CompilerGeneratedAttribute]
public void set_LastIndexedEtag(Etag value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_IndexingLag();
    [CompilerGeneratedAttribute]
public void set_IndexingLag(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public DateTime get_LastIndexedTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastIndexedTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastQueryTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastQueryTimestamp(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public int get_TouchCount();
    [CompilerGeneratedAttribute]
public void set_TouchCount(int value);
    [CompilerGeneratedAttribute]
public IndexingPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(IndexingPriority value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ReduceIndexingAttempts();
    [CompilerGeneratedAttribute]
public void set_ReduceIndexingAttempts(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ReduceIndexingSuccesses();
    [CompilerGeneratedAttribute]
public void set_ReduceIndexingSuccesses(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ReduceIndexingErrors();
    [CompilerGeneratedAttribute]
public void set_ReduceIndexingErrors(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Etag get_LastReducedEtag();
    [CompilerGeneratedAttribute]
public void set_LastReducedEtag(Etag value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastReducedTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastReducedTimestamp(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedTimestamp();
    [CompilerGeneratedAttribute]
public void set_CreatedTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_LastIndexingTime();
    [CompilerGeneratedAttribute]
public void set_LastIndexingTime(DateTime value);
    [CompilerGeneratedAttribute]
public string get_IsOnRam();
    [CompilerGeneratedAttribute]
public void set_IsOnRam(string value);
    [CompilerGeneratedAttribute]
public IndexLockMode get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(IndexLockMode value);
    [CompilerGeneratedAttribute]
public bool get_IsMapReduce();
    [CompilerGeneratedAttribute]
public void set_IsMapReduce(bool value);
    [CompilerGeneratedAttribute]
public String[] get_ForEntityName();
    [CompilerGeneratedAttribute]
public void set_ForEntityName(String[] value);
    [CompilerGeneratedAttribute]
public int get_DocsCount();
    [CompilerGeneratedAttribute]
public void set_DocsCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IsTestIndex();
    [CompilerGeneratedAttribute]
public void set_IsTestIndex(bool value);
    public bool get_IsInvalidIndex();
    public virtual string ToString();
    public void SetLastDocumentEtag(Etag lastDocEtag);
}
public class Raven.Abstractions.Data.IndexToAdd : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexDefinition <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <MinimumEtagBeforeReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ReplaceTimeUtc>k__BackingField;
    public string Name { get; public set; }
    public IndexDefinition Definition { get; public set; }
    public IndexingPriority Priority { get; public set; }
    public Etag MinimumEtagBeforeReplace { get; public set; }
    public Nullable`1<DateTime> ReplaceTimeUtc { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IndexDefinition get_Definition();
    [CompilerGeneratedAttribute]
public void set_Definition(IndexDefinition value);
    [CompilerGeneratedAttribute]
public IndexingPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(IndexingPriority value);
    [CompilerGeneratedAttribute]
public Etag get_MinimumEtagBeforeReplace();
    [CompilerGeneratedAttribute]
public void set_MinimumEtagBeforeReplace(Etag value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ReplaceTimeUtc();
    [CompilerGeneratedAttribute]
public void set_ReplaceTimeUtc(Nullable`1<DateTime> value);
}
public class Raven.Abstractions.Data.InternalStorageBreakdownState : OperationStateBase {
    [CompilerGeneratedAttribute]
private IList`1<string> <ReportResults>k__BackingField;
    public IList`1<string> ReportResults { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<string> get_ReportResults();
    [CompilerGeneratedAttribute]
public void set_ReportResults(IList`1<string> value);
}
public interface Raven.Abstractions.Data.IOperationState {
    public bool Completed { get; }
    public bool Faulted { get; }
    public bool Canceled { get; }
    public Exception Exception { get; }
    public RavenJObject State { get; }
    public abstract virtual bool get_Completed();
    public abstract virtual bool get_Faulted();
    public abstract virtual bool get_Canceled();
    public abstract virtual Exception get_Exception();
    public abstract virtual RavenJObject get_State();
}
public class Raven.Abstractions.Data.JsonDocument : object {
    private RavenJObject dataAsJson;
    private RavenJObject metadata;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NonAuthoritativeInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <TempIndexScore>k__BackingField;
    public int SerializedSizeOnDisk;
    public bool SkipDeleteFromIndex;
    public bool IsIrrelevantForIndexing;
    public RavenJObject DataAsJson { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public string Key { get; public set; }
    public Nullable`1<bool> NonAuthoritativeInformation { get; public set; }
    public Etag Etag { get; public set; }
    public Nullable`1<DateTime> LastModified { get; public set; }
    public Nullable`1<float> TempIndexScore { get; public set; }
    public RavenJObject get_DataAsJson();
    public void set_DataAsJson(RavenJObject value);
    public sealed virtual RavenJObject get_Metadata();
    public sealed virtual void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Key(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_NonAuthoritativeInformation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NonAuthoritativeInformation(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Etag get_Etag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTime> get_LastModified();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastModified(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_TempIndexScore();
    [CompilerGeneratedAttribute]
public void set_TempIndexScore(Nullable`1<float> value);
    public RavenJObject ToJson(bool checkForId);
    public virtual string ToString();
    public static void EnsureIdInMetadata(IJsonDocumentMetadata doc);
}
public class Raven.Abstractions.Data.JsonDocumentMetadata : object {
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NonAuthoritativeInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastModified>k__BackingField;
    public RavenJObject Metadata { get; public set; }
    public string Key { get; public set; }
    public Nullable`1<bool> NonAuthoritativeInformation { get; public set; }
    public Etag Etag { get; public set; }
    public Nullable`1<DateTime> LastModified { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Key(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<bool> get_NonAuthoritativeInformation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NonAuthoritativeInformation(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Etag get_Etag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTime> get_LastModified();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastModified(Nullable`1<DateTime> value);
}
public class Raven.Abstractions.Data.LicensingStatus : object {
    private Dictionary`2<string, string> attributes;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicensePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidCommercialLicenseSeen>k__BackingField;
    public string Message { get; public set; }
    public string Details { get; public set; }
    public string Status { get; public set; }
    public bool Error { get; public set; }
    public bool IsCommercial { get; }
    public string LicensePath { get; public set; }
    public bool ValidCommercialLicenseSeen { get; public set; }
    public Dictionary`2<string, string> Attributes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(string value);
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(string value);
    [CompilerGeneratedAttribute]
public bool get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(bool value);
    public bool get_IsCommercial();
    [CompilerGeneratedAttribute]
public string get_LicensePath();
    [CompilerGeneratedAttribute]
public void set_LicensePath(string value);
    [CompilerGeneratedAttribute]
public bool get_ValidCommercialLicenseSeen();
    [CompilerGeneratedAttribute]
public void set_ValidCommercialLicenseSeen(bool value);
    public Dictionary`2<string, string> get_Attributes();
    public void set_Attributes(Dictionary`2<string, string> value);
}
public class Raven.Abstractions.Data.ListsInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeOnDiskInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MinListItemSizeOnDiskInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxListItemSizeOnDiskInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AverageListItemSizeOnDiskInBytes>k__BackingField;
    public string Name { get; public set; }
    public long Count { get; public set; }
    public long SizeOnDiskInBytes { get; public set; }
    public long MinListItemSizeOnDiskInBytes { get; public set; }
    public long MaxListItemSizeOnDiskInBytes { get; public set; }
    public long AverageListItemSizeOnDiskInBytes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(long value);
    [CompilerGeneratedAttribute]
public long get_SizeOnDiskInBytes();
    [CompilerGeneratedAttribute]
public void set_SizeOnDiskInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_MinListItemSizeOnDiskInBytes();
    [CompilerGeneratedAttribute]
public void set_MinListItemSizeOnDiskInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_MaxListItemSizeOnDiskInBytes();
    [CompilerGeneratedAttribute]
public void set_MaxListItemSizeOnDiskInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_AverageListItemSizeOnDiskInBytes();
    [CompilerGeneratedAttribute]
public void set_AverageListItemSizeOnDiskInBytes(long value);
}
public class Raven.Abstractions.Data.LoadedDatabaseStatistics : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastActivity>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TransactionalStorageAllocatedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransactionalStorageAllocatedSizeHumaneSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TransactionalStorageUsedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransactionalStorageUsedSizeHumaneSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <IndexStorageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexStorageHumaneSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalDatabaseSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TotalDatabaseHumaneSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CountOfAttachments>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <DatabaseTransactionVersionSizeInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseMetrics <Metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageStats <StorageStats>k__BackingField;
    public string Name { get; public set; }
    public DateTime LastActivity { get; public set; }
    public long TransactionalStorageAllocatedSize { get; public set; }
    public string TransactionalStorageAllocatedSizeHumaneSize { get; public set; }
    public long TransactionalStorageUsedSize { get; public set; }
    public string TransactionalStorageUsedSizeHumaneSize { get; public set; }
    public long IndexStorageSize { get; public set; }
    public string IndexStorageHumaneSize { get; public set; }
    public long TotalDatabaseSize { get; public set; }
    public string TotalDatabaseHumaneSize { get; public set; }
    public long CountOfDocuments { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public long CountOfAttachments { get; public set; }
    public decimal DatabaseTransactionVersionSizeInMB { get; public set; }
    public DatabaseMetrics Metrics { get; public set; }
    public StorageStats StorageStats { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastActivity();
    [CompilerGeneratedAttribute]
public void set_LastActivity(DateTime value);
    [CompilerGeneratedAttribute]
public long get_TransactionalStorageAllocatedSize();
    [CompilerGeneratedAttribute]
public void set_TransactionalStorageAllocatedSize(long value);
    [CompilerGeneratedAttribute]
public string get_TransactionalStorageAllocatedSizeHumaneSize();
    [CompilerGeneratedAttribute]
public void set_TransactionalStorageAllocatedSizeHumaneSize(string value);
    [CompilerGeneratedAttribute]
public long get_TransactionalStorageUsedSize();
    [CompilerGeneratedAttribute]
public void set_TransactionalStorageUsedSize(long value);
    [CompilerGeneratedAttribute]
public string get_TransactionalStorageUsedSizeHumaneSize();
    [CompilerGeneratedAttribute]
public void set_TransactionalStorageUsedSizeHumaneSize(string value);
    [CompilerGeneratedAttribute]
public long get_IndexStorageSize();
    [CompilerGeneratedAttribute]
public void set_IndexStorageSize(long value);
    [CompilerGeneratedAttribute]
public string get_IndexStorageHumaneSize();
    [CompilerGeneratedAttribute]
public void set_IndexStorageHumaneSize(string value);
    [CompilerGeneratedAttribute]
public long get_TotalDatabaseSize();
    [CompilerGeneratedAttribute]
public void set_TotalDatabaseSize(long value);
    [CompilerGeneratedAttribute]
public string get_TotalDatabaseHumaneSize();
    [CompilerGeneratedAttribute]
public void set_TotalDatabaseHumaneSize(string value);
    [CompilerGeneratedAttribute]
public long get_CountOfDocuments();
    [CompilerGeneratedAttribute]
public void set_CountOfDocuments(long value);
    [CompilerGeneratedAttribute]
public long get_CountOfAttachments();
    [CompilerGeneratedAttribute]
public void set_CountOfAttachments(long value);
    [CompilerGeneratedAttribute]
public decimal get_DatabaseTransactionVersionSizeInMB();
    [CompilerGeneratedAttribute]
public void set_DatabaseTransactionVersionSizeInMB(decimal value);
    [CompilerGeneratedAttribute]
public DatabaseMetrics get_Metrics();
    [CompilerGeneratedAttribute]
public void set_Metrics(DatabaseMetrics value);
    [CompilerGeneratedAttribute]
public StorageStats get_StorageStats();
    [CompilerGeneratedAttribute]
public void set_StorageStats(StorageStats value);
}
public class Raven.Abstractions.Data.LogItem : object {
    [CompilerGeneratedAttribute]
private string <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    public string Level { get; public set; }
    public string Message { get; public set; }
    public string LoggerName { get; public set; }
    public string Exception { get; public set; }
    public DateTime TimeStamp { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_LoggerName();
    [CompilerGeneratedAttribute]
public void set_LoggerName(string value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
}
public class Raven.Abstractions.Data.LowMemoryCalledRecord : object {
    [CompilerGeneratedAttribute]
private DateTime <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LowMemoryHandlerStatistics> <Operations>k__BackingField;
    public DateTime StartedAt { get; public set; }
    public TimeSpan Duration { get; public set; }
    public string Reason { get; public set; }
    public List`1<LowMemoryHandlerStatistics> Operations { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_StartedAt();
    [CompilerGeneratedAttribute]
public void set_StartedAt(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public List`1<LowMemoryHandlerStatistics> get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(List`1<LowMemoryHandlerStatistics> value);
}
public class Raven.Abstractions.Data.LowMemoryHandlerStatistics : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EstimatedUsedMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    public string Name { get; public set; }
    public long EstimatedUsedMemory { get; public set; }
    public string DatabaseName { get; public set; }
    public object Metadata { get; public set; }
    public string Summary { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_EstimatedUsedMemory();
    [CompilerGeneratedAttribute]
public void set_EstimatedUsedMemory(long value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public object get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(object value);
    [CompilerGeneratedAttribute]
public string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
}
public class Raven.Abstractions.Data.MeterData : object {
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MeanRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OneMinuteRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FiveMinuteRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FifteenMinuteRate>k__BackingField;
    public MetricType Type;
    public long Count { get; public set; }
    public double MeanRate { get; public set; }
    public double OneMinuteRate { get; public set; }
    public double FiveMinuteRate { get; public set; }
    public double FifteenMinuteRate { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(long value);
    [CompilerGeneratedAttribute]
public double get_MeanRate();
    [CompilerGeneratedAttribute]
public void set_MeanRate(double value);
    [CompilerGeneratedAttribute]
public double get_OneMinuteRate();
    [CompilerGeneratedAttribute]
public void set_OneMinuteRate(double value);
    [CompilerGeneratedAttribute]
public double get_FiveMinuteRate();
    [CompilerGeneratedAttribute]
public void set_FiveMinuteRate(double value);
    [CompilerGeneratedAttribute]
public double get_FifteenMinuteRate();
    [CompilerGeneratedAttribute]
public void set_FifteenMinuteRate(double value);
}
public enum Raven.Abstractions.Data.MetricType : Enum {
    public int value__;
    public static MetricType Meter;
    public static MetricType Histogram;
}
public class Raven.Abstractions.Data.MoreLikeThisQuery : object {
    public static int DefaultMaximumNumberOfTokensParsed;
    public static int DefaultMinimumTermFrequency;
    public static int DefaultMinimumDocumentFrequency;
    public static int DefaultMaximumDocumentFrequency;
    public static bool DefaultBoost;
    public static float DefaultBoostFactor;
    public static int DefaultMinimumWordLength;
    public static int DefaultMaximumWordLength;
    public static int DefaultMaximumQueryTerms;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumTermFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumDocumentFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumDocumentFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumDocumentFrequencyPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Boost>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <BoostFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumWordLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumWordLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumQueryTerms>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumNumberOfTokensParsed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StopWordsDocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultAnalyzerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private NameValueCollection <MapGroupFields>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResultsTransformer>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, RavenJToken> <TransformerParameters>k__BackingField;
    public Nullable`1<int> MinimumTermFrequency { get; public set; }
    public Nullable`1<int> MinimumDocumentFrequency { get; public set; }
    public Nullable`1<int> MaximumDocumentFrequency { get; public set; }
    public Nullable`1<int> MaximumDocumentFrequencyPercentage { get; public set; }
    public Nullable`1<bool> Boost { get; public set; }
    public Nullable`1<float> BoostFactor { get; public set; }
    public Nullable`1<int> MinimumWordLength { get; public set; }
    public Nullable`1<int> MaximumWordLength { get; public set; }
    public Nullable`1<int> MaximumQueryTerms { get; public set; }
    public Nullable`1<int> MaximumNumberOfTokensParsed { get; public set; }
    public string StopWordsDocumentId { get; public set; }
    public String[] Fields { get; public set; }
    public string DocumentId { get; public set; }
    public string IndexName { get; public set; }
    public string AdditionalQuery { get; public set; }
    public string DefaultAnalyzerName { get; public set; }
    public string Document { get; public set; }
    public NameValueCollection MapGroupFields { get; public set; }
    public string ResultsTransformer { get; public set; }
    public String[] Includes { get; public set; }
    public Dictionary`2<string, RavenJToken> TransformerParameters { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumTermFrequency();
    [CompilerGeneratedAttribute]
public void set_MinimumTermFrequency(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumDocumentFrequency();
    [CompilerGeneratedAttribute]
public void set_MinimumDocumentFrequency(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumDocumentFrequency();
    [CompilerGeneratedAttribute]
public void set_MaximumDocumentFrequency(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumDocumentFrequencyPercentage();
    [CompilerGeneratedAttribute]
public void set_MaximumDocumentFrequencyPercentage(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Boost();
    [CompilerGeneratedAttribute]
public void set_Boost(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_BoostFactor();
    [CompilerGeneratedAttribute]
public void set_BoostFactor(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumWordLength();
    [CompilerGeneratedAttribute]
public void set_MinimumWordLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumWordLength();
    [CompilerGeneratedAttribute]
public void set_MaximumWordLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumQueryTerms();
    [CompilerGeneratedAttribute]
public void set_MaximumQueryTerms(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumNumberOfTokensParsed();
    [CompilerGeneratedAttribute]
public void set_MaximumNumberOfTokensParsed(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_StopWordsDocumentId();
    [CompilerGeneratedAttribute]
public void set_StopWordsDocumentId(string value);
    [CompilerGeneratedAttribute]
public String[] get_Fields();
    [CompilerGeneratedAttribute]
public void set_Fields(String[] value);
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(string value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public string get_AdditionalQuery();
    [CompilerGeneratedAttribute]
public void set_AdditionalQuery(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultAnalyzerName();
    [CompilerGeneratedAttribute]
public void set_DefaultAnalyzerName(string value);
    [CompilerGeneratedAttribute]
public string get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(string value);
    [CompilerGeneratedAttribute]
public NameValueCollection get_MapGroupFields();
    [CompilerGeneratedAttribute]
public void set_MapGroupFields(NameValueCollection value);
    [CompilerGeneratedAttribute]
public string get_ResultsTransformer();
    [CompilerGeneratedAttribute]
public void set_ResultsTransformer(string value);
    [CompilerGeneratedAttribute]
public String[] get_Includes();
    [CompilerGeneratedAttribute]
public void set_Includes(String[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, RavenJToken> get_TransformerParameters();
    [CompilerGeneratedAttribute]
public void set_TransformerParameters(Dictionary`2<string, RavenJToken> value);
    public string GetRequestUri();
}
public class Raven.Abstractions.Data.MoreLikeThisQueryResult : object {
    [CompilerGeneratedAttribute]
private MultiLoadResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    public MultiLoadResult Result { get; public set; }
    public Etag Etag { get; public set; }
    [CompilerGeneratedAttribute]
public MultiLoadResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(MultiLoadResult value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
}
public class Raven.Abstractions.Data.MultiLoadResult : object {
    [CompilerGeneratedAttribute]
private List`1<RavenJObject> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RavenJObject> <Includes>k__BackingField;
    public List`1<RavenJObject> Results { get; public set; }
    public List`1<RavenJObject> Includes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<RavenJObject> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(List`1<RavenJObject> value);
    [CompilerGeneratedAttribute]
public List`1<RavenJObject> get_Includes();
    [CompilerGeneratedAttribute]
public void set_Includes(List`1<RavenJObject> value);
}
public class Raven.Abstractions.Data.OneMinuteMetricData : object {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Avg>k__BackingField;
    public int Count { get; public set; }
    public long Min { get; public set; }
    public long Max { get; public set; }
    public double Avg { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public long get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(long value);
    [CompilerGeneratedAttribute]
public long get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(long value);
    [CompilerGeneratedAttribute]
public double get_Avg();
    [CompilerGeneratedAttribute]
public void set_Avg(double value);
}
public class Raven.Abstractions.Data.OperationStateBase : object {
    [CompilerGeneratedAttribute]
private bool <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Faulted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Canceled>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public bool Completed { get; private set; }
    public bool Faulted { get; private set; }
    public bool Canceled { get; private set; }
    public RavenJObject State { get; protected set; }
    public Exception Exception { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Completed();
    [CompilerGeneratedAttribute]
private void set_Completed(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Faulted();
    [CompilerGeneratedAttribute]
private void set_Faulted(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Canceled();
    [CompilerGeneratedAttribute]
private void set_Canceled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual RavenJObject get_State();
    [CompilerGeneratedAttribute]
protected void set_State(RavenJObject value);
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    public virtual void MarkProgress(string progress);
    private void MarkProgressInternal(string progress);
    public void MarkCompleted(string state);
    public void MarkCompleted(string initialMessage, TimeSpan elapsed);
    public void MarkFaulted(string error, Exception exception);
    public void MarkCanceled(string error);
    private void VerifyState();
}
public class Raven.Abstractions.Data.ParallelBatchStats : object {
    [CompilerGeneratedAttribute]
private long <StartDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PerformanceStats> <Operations>k__BackingField;
    public long StartDelay { get; public set; }
    public List`1<PerformanceStats> Operations { get; public set; }
    [CompilerGeneratedAttribute]
public long get_StartDelay();
    [CompilerGeneratedAttribute]
public void set_StartDelay(long value);
    [CompilerGeneratedAttribute]
public List`1<PerformanceStats> get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(List`1<PerformanceStats> value);
}
public class Raven.Abstractions.Data.ParallelPerformanceStats : BasePerformanceStats {
    [CompilerGeneratedAttribute]
private long <NumberOfThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ParallelBatchStats> <BatchedOperations>k__BackingField;
    public long NumberOfThreads { get; public set; }
    public List`1<ParallelBatchStats> BatchedOperations { get; public set; }
    [CompilerGeneratedAttribute]
public long get_NumberOfThreads();
    [CompilerGeneratedAttribute]
public void set_NumberOfThreads(long value);
    [CompilerGeneratedAttribute]
public List`1<ParallelBatchStats> get_BatchedOperations();
    [CompilerGeneratedAttribute]
public void set_BatchedOperations(List`1<ParallelBatchStats> value);
}
public enum Raven.Abstractions.Data.PatchCommandType : Enum {
    public int value__;
    public static PatchCommandType Set;
    public static PatchCommandType Unset;
    public static PatchCommandType Add;
    public static PatchCommandType Insert;
    public static PatchCommandType Remove;
    public static PatchCommandType Modify;
    public static PatchCommandType Inc;
    public static PatchCommandType Copy;
    public static PatchCommandType Rename;
}
public class Raven.Abstractions.Data.PatchRequest : object {
    [CompilerGeneratedAttribute]
private PatchCommandType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJToken <PrevVal>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJToken <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private PatchRequest[] <Nested>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllPositions>k__BackingField;
    public PatchCommandType Type { get; public set; }
    public RavenJToken PrevVal { get; public set; }
    public RavenJToken Value { get; public set; }
    public PatchRequest[] Nested { get; public set; }
    public string Name { get; public set; }
    public Nullable`1<int> Position { get; public set; }
    public Nullable`1<bool> AllPositions { get; public set; }
    [CompilerGeneratedAttribute]
public PatchCommandType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PatchCommandType value);
    [CompilerGeneratedAttribute]
public RavenJToken get_PrevVal();
    [CompilerGeneratedAttribute]
public void set_PrevVal(RavenJToken value);
    [CompilerGeneratedAttribute]
public RavenJToken get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(RavenJToken value);
    [CompilerGeneratedAttribute]
public PatchRequest[] get_Nested();
    [CompilerGeneratedAttribute]
public void set_Nested(PatchRequest[] value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllPositions();
    [CompilerGeneratedAttribute]
public void set_AllPositions(Nullable`1<bool> value);
    public RavenJObject ToJson();
    public static PatchRequest FromJson(RavenJObject patchRequestJson);
}
public enum Raven.Abstractions.Data.PatchResult : Enum {
    public int value__;
    public static PatchResult DocumentDoesNotExists;
    public static PatchResult Patched;
    public static PatchResult Tested;
    public static PatchResult Skipped;
    public static PatchResult NotModified;
}
public class Raven.Abstractions.Data.PatchResultData : object {
    [CompilerGeneratedAttribute]
private PatchResult <PatchResult>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <DebugActions>k__BackingField;
    public PatchResult PatchResult { get; public set; }
    public RavenJObject Document { get; public set; }
    public RavenJObject DebugActions { get; public set; }
    [CompilerGeneratedAttribute]
public PatchResult get_PatchResult();
    [CompilerGeneratedAttribute]
public void set_PatchResult(PatchResult value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(RavenJObject value);
    [CompilerGeneratedAttribute]
public RavenJObject get_DebugActions();
    [CompilerGeneratedAttribute]
public void set_DebugActions(RavenJObject value);
}
public class Raven.Abstractions.Data.PerformanceStats : BasePerformanceStats {
    [CompilerGeneratedAttribute]
private IndexingOperation <Name>k__BackingField;
    public IndexingOperation Name { get; public set; }
    [CompilerGeneratedAttribute]
public IndexingOperation get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(IndexingOperation value);
    public static PerformanceStats From(IndexingOperation name, long durationMs);
}
public class Raven.Abstractions.Data.PeriodicExportSetup : object {
    public static string RavenDocumentKey;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GlacierVaultName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <S3BucketName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AwsRegionEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AzureStorageContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalFolderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AzureRemoteFolderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <S3RemoteFolderName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <IntervalMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <FullBackupIntervalMilliseconds>k__BackingField;
    public bool Disabled { get; public set; }
    public string GlacierVaultName { get; public set; }
    public string S3BucketName { get; public set; }
    public string AwsRegionEndpoint { get; public set; }
    public string AzureStorageContainer { get; public set; }
    public string LocalFolderName { get; public set; }
    public string AzureRemoteFolderName { get; public set; }
    public string S3RemoteFolderName { get; public set; }
    public Nullable`1<long> IntervalMilliseconds { get; public set; }
    public Nullable`1<long> FullBackupIntervalMilliseconds { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public string get_GlacierVaultName();
    [CompilerGeneratedAttribute]
public void set_GlacierVaultName(string value);
    [CompilerGeneratedAttribute]
public string get_S3BucketName();
    [CompilerGeneratedAttribute]
public void set_S3BucketName(string value);
    [CompilerGeneratedAttribute]
public string get_AwsRegionEndpoint();
    [CompilerGeneratedAttribute]
public void set_AwsRegionEndpoint(string value);
    [CompilerGeneratedAttribute]
public string get_AzureStorageContainer();
    [CompilerGeneratedAttribute]
public void set_AzureStorageContainer(string value);
    [CompilerGeneratedAttribute]
public string get_LocalFolderName();
    [CompilerGeneratedAttribute]
public void set_LocalFolderName(string value);
    [CompilerGeneratedAttribute]
public string get_AzureRemoteFolderName();
    [CompilerGeneratedAttribute]
public void set_AzureRemoteFolderName(string value);
    [CompilerGeneratedAttribute]
public string get_S3RemoteFolderName();
    [CompilerGeneratedAttribute]
public void set_S3RemoteFolderName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_IntervalMilliseconds();
    [CompilerGeneratedAttribute]
public void set_IntervalMilliseconds(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_FullBackupIntervalMilliseconds();
    [CompilerGeneratedAttribute]
public void set_FullBackupIntervalMilliseconds(Nullable`1<long> value);
    protected bool Equals(PeriodicExportSetup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.Data.PeriodicExportStatus : object {
    public static string RavenDocumentKey;
    [CompilerGeneratedAttribute]
private DateTime <LastBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastFullBackup>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastDocsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastFullLocalBackupFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastAttachmentsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastDocsDeletionEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastAttachmentDeletionEtag>k__BackingField;
    public DateTime LastBackup { get; public set; }
    public DateTime LastFullBackup { get; public set; }
    public Etag LastDocsEtag { get; public set; }
    public string LastFullLocalBackupFolder { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag LastAttachmentsEtag { get; public set; }
    public Etag LastDocsDeletionEtag { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag LastAttachmentDeletionEtag { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_LastBackup();
    [CompilerGeneratedAttribute]
public void set_LastBackup(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_LastFullBackup();
    [CompilerGeneratedAttribute]
public void set_LastFullBackup(DateTime value);
    [CompilerGeneratedAttribute]
public Etag get_LastDocsEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocsEtag(Etag value);
    [CompilerGeneratedAttribute]
public string get_LastFullLocalBackupFolder();
    [CompilerGeneratedAttribute]
public void set_LastFullLocalBackupFolder(string value);
    [CompilerGeneratedAttribute]
public Etag get_LastAttachmentsEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentsEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastDocsDeletionEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocsDeletionEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastAttachmentDeletionEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentDeletionEtag(Etag value);
}
public class Raven.Abstractions.Data.PluginsInfo : object {
    [CompilerGeneratedAttribute]
private List`1<ExtensionsLog> <Extensions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TriggerInfo> <Triggers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <CustomBundles>k__BackingField;
    public List`1<ExtensionsLog> Extensions { get; public set; }
    public List`1<TriggerInfo> Triggers { get; public set; }
    public List`1<string> CustomBundles { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ExtensionsLog> get_Extensions();
    [CompilerGeneratedAttribute]
public void set_Extensions(List`1<ExtensionsLog> value);
    [CompilerGeneratedAttribute]
public List`1<TriggerInfo> get_Triggers();
    [CompilerGeneratedAttribute]
public void set_Triggers(List`1<TriggerInfo> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_CustomBundles();
    [CompilerGeneratedAttribute]
public void set_CustomBundles(List`1<string> value);
}
public enum Raven.Abstractions.Data.PrefetchingUser : Enum {
    public int value__;
    public static PrefetchingUser Indexer;
    public static PrefetchingUser Replicator;
    public static PrefetchingUser SqlReplicator;
}
public class Raven.Abstractions.Data.PutResult : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <ETag>k__BackingField;
    public string Key { get; public set; }
    public Etag ETag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public Etag get_ETag();
    [CompilerGeneratedAttribute]
public void set_ETag(Etag value);
}
public class Raven.Abstractions.Data.QueryHeaderInformation : object {
    [CompilerGeneratedAttribute]
private string <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStale>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <IndexTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalResults>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <ResultEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <IndexEtag>k__BackingField;
    public string Index { get; public set; }
    public bool IsStale { get; public set; }
    public DateTime IndexTimestamp { get; public set; }
    public int TotalResults { get; public set; }
    public Etag ResultEtag { get; public set; }
    public Etag IndexEtag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(string value);
    [CompilerGeneratedAttribute]
public bool get_IsStale();
    [CompilerGeneratedAttribute]
public void set_IsStale(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_IndexTimestamp();
    [CompilerGeneratedAttribute]
public void set_IndexTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public int get_TotalResults();
    [CompilerGeneratedAttribute]
public void set_TotalResults(int value);
    [CompilerGeneratedAttribute]
public Etag get_ResultEtag();
    [CompilerGeneratedAttribute]
public void set_ResultEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_IndexEtag();
    [CompilerGeneratedAttribute]
public void set_IndexEtag(Etag value);
}
public enum Raven.Abstractions.Data.QueryOperator : Enum {
    public int value__;
    public static QueryOperator Or;
    public static QueryOperator And;
}
public class Raven.Abstractions.Data.QueryResult : object {
    [CompilerGeneratedAttribute]
private List`1<RavenJObject> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RavenJObject> <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStale>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <IndexTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalResults>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SkippedResults>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <IndexEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <ResultEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Dictionary`2<string, String[]>> <Highlightings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonAuthoritativeInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastQueryTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ScoreExplanations>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, double> <TimingsInMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ResultSize>k__BackingField;
    public List`1<RavenJObject> Results { get; public set; }
    public List`1<RavenJObject> Includes { get; public set; }
    public bool IsStale { get; public set; }
    public DateTime IndexTimestamp { get; public set; }
    public int TotalResults { get; public set; }
    public int SkippedResults { get; public set; }
    public string IndexName { get; public set; }
    public Etag IndexEtag { get; public set; }
    public Etag ResultEtag { get; public set; }
    public Dictionary`2<string, Dictionary`2<string, String[]>> Highlightings { get; public set; }
    public bool NonAuthoritativeInformation { get; public set; }
    public DateTime LastQueryTime { get; public set; }
    public long DurationMilliseconds { get; public set; }
    public Dictionary`2<string, string> ScoreExplanations { get; public set; }
    public Dictionary`2<string, double> TimingsInMilliseconds { get; public set; }
    public long ResultSize { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<RavenJObject> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(List`1<RavenJObject> value);
    [CompilerGeneratedAttribute]
public List`1<RavenJObject> get_Includes();
    [CompilerGeneratedAttribute]
public void set_Includes(List`1<RavenJObject> value);
    [CompilerGeneratedAttribute]
public bool get_IsStale();
    [CompilerGeneratedAttribute]
public void set_IsStale(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_IndexTimestamp();
    [CompilerGeneratedAttribute]
public void set_IndexTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public int get_TotalResults();
    [CompilerGeneratedAttribute]
public void set_TotalResults(int value);
    [CompilerGeneratedAttribute]
public int get_SkippedResults();
    [CompilerGeneratedAttribute]
public void set_SkippedResults(int value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public Etag get_IndexEtag();
    [CompilerGeneratedAttribute]
public void set_IndexEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_ResultEtag();
    [CompilerGeneratedAttribute]
public void set_ResultEtag(Etag value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Dictionary`2<string, String[]>> get_Highlightings();
    [CompilerGeneratedAttribute]
public void set_Highlightings(Dictionary`2<string, Dictionary`2<string, String[]>> value);
    [CompilerGeneratedAttribute]
public bool get_NonAuthoritativeInformation();
    [CompilerGeneratedAttribute]
public void set_NonAuthoritativeInformation(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_LastQueryTime();
    [CompilerGeneratedAttribute]
public void set_LastQueryTime(DateTime value);
    [CompilerGeneratedAttribute]
public long get_DurationMilliseconds();
    [CompilerGeneratedAttribute]
public void set_DurationMilliseconds(long value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ScoreExplanations();
    [CompilerGeneratedAttribute]
public void set_ScoreExplanations(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, double> get_TimingsInMilliseconds();
    [CompilerGeneratedAttribute]
public void set_TimingsInMilliseconds(Dictionary`2<string, double> value);
    [CompilerGeneratedAttribute]
public long get_ResultSize();
    [CompilerGeneratedAttribute]
public void set_ResultSize(long value);
    public void EnsureSnapshot();
    public QueryResult CreateSnapshot();
}
public class Raven.Abstractions.Data.RavenConnectionStringOptions : ConnectionStringOptions {
    [CompilerGeneratedAttribute]
private Guid <ResourceManagerId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnlistInDistributedTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private FailoverServers <FailoverServers>k__BackingField;
    public Guid ResourceManagerId { get; public set; }
    public bool EnlistInDistributedTransactions { get; public set; }
    public string DefaultDatabase { get; public set; }
    public FailoverServers FailoverServers { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_ResourceManagerId();
    [CompilerGeneratedAttribute]
public void set_ResourceManagerId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_EnlistInDistributedTransactions();
    [CompilerGeneratedAttribute]
public void set_EnlistInDistributedTransactions(bool value);
    [CompilerGeneratedAttribute]
public string get_DefaultDatabase();
    [CompilerGeneratedAttribute]
public void set_DefaultDatabase(string value);
    [CompilerGeneratedAttribute]
public FailoverServers get_FailoverServers();
    [CompilerGeneratedAttribute]
public void set_FailoverServers(FailoverServers value);
    public virtual string ToString();
}
public class Raven.Abstractions.Data.ReduceLevelPeformanceStats : object {
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ItemsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InputCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OutputCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BasePerformanceStats> <Operations>k__BackingField;
    public int Level { get; public set; }
    public int ItemsCount { get; public set; }
    public int InputCount { get; public set; }
    public int OutputCount { get; public set; }
    public DateTime Started { get; public set; }
    public DateTime Completed { get; public set; }
    public TimeSpan Duration { get; public set; }
    public double DurationMs { get; }
    [JsonPropertyAttribute]
public List`1<BasePerformanceStats> Operations { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(int value);
    [CompilerGeneratedAttribute]
public int get_ItemsCount();
    [CompilerGeneratedAttribute]
public void set_ItemsCount(int value);
    [CompilerGeneratedAttribute]
public int get_InputCount();
    [CompilerGeneratedAttribute]
public void set_InputCount(int value);
    [CompilerGeneratedAttribute]
public int get_OutputCount();
    [CompilerGeneratedAttribute]
public void set_OutputCount(int value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_Completed();
    [CompilerGeneratedAttribute]
public void set_Completed(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    public double get_DurationMs();
    [CompilerGeneratedAttribute]
public List`1<BasePerformanceStats> get_Operations();
    [CompilerGeneratedAttribute]
public void set_Operations(List`1<BasePerformanceStats> value);
    public void Add(IndexingPerformanceStats other);
}
public enum Raven.Abstractions.Data.ReduceType : Enum {
    public int value__;
    public static ReduceType None;
    public static ReduceType SingleStep;
    public static ReduceType MultiStep;
}
public class Raven.Abstractions.Data.ReducingBatchInfo : object {
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <IndexesToWorkOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TotalDurationMs>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TimeSinceFirstReduceInBatchCompletedMs>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, ReducingPerformanceStats[]> <PerformanceStats>k__BackingField;
    public long Id { get; public set; }
    public List`1<string> IndexesToWorkOn { get; public set; }
    public DateTime StartedAt { get; public set; }
    public double TotalDurationMs { get; public set; }
    public double TimeSinceFirstReduceInBatchCompletedMs { get; public set; }
    public ConcurrentDictionary`2<string, ReducingPerformanceStats[]> PerformanceStats { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(long value);
    [CompilerGeneratedAttribute]
public List`1<string> get_IndexesToWorkOn();
    [CompilerGeneratedAttribute]
public void set_IndexesToWorkOn(List`1<string> value);
    [CompilerGeneratedAttribute]
public DateTime get_StartedAt();
    [CompilerGeneratedAttribute]
public void set_StartedAt(DateTime value);
    [CompilerGeneratedAttribute]
public double get_TotalDurationMs();
    [CompilerGeneratedAttribute]
public void set_TotalDurationMs(double value);
    [CompilerGeneratedAttribute]
public double get_TimeSinceFirstReduceInBatchCompletedMs();
    [CompilerGeneratedAttribute]
public void set_TimeSinceFirstReduceInBatchCompletedMs(double value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, ReducingPerformanceStats[]> get_PerformanceStats();
    [CompilerGeneratedAttribute]
public void set_PerformanceStats(ConcurrentDictionary`2<string, ReducingPerformanceStats[]> value);
    public void BatchCompleted();
}
public class Raven.Abstractions.Data.ReducingPerformanceStats : object {
    [CompilerGeneratedAttribute]
private ReduceType <ReduceType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ReduceLevelPeformanceStats> <LevelStats>k__BackingField;
    public ReduceType ReduceType { get; private set; }
    public List`1<ReduceLevelPeformanceStats> LevelStats { get; public set; }
    public ReducingPerformanceStats(ReduceType reduceType);
    [CompilerGeneratedAttribute]
public ReduceType get_ReduceType();
    [CompilerGeneratedAttribute]
private void set_ReduceType(ReduceType value);
    [CompilerGeneratedAttribute]
public List`1<ReduceLevelPeformanceStats> get_LevelStats();
    [CompilerGeneratedAttribute]
public void set_LevelStats(List`1<ReduceLevelPeformanceStats> value);
}
public class Raven.Abstractions.Data.ReplicationConflictNotification : EventArgs {
    [CompilerGeneratedAttribute]
private ReplicationConflictTypes <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationOperationTypes <OperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Conflicts>k__BackingField;
    public ReplicationConflictTypes ItemType { get; public set; }
    public string Id { get; public set; }
    public Etag Etag { get; public set; }
    public ReplicationOperationTypes OperationType { get; public set; }
    public String[] Conflicts { get; public set; }
    [CompilerGeneratedAttribute]
public ReplicationConflictTypes get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(ReplicationConflictTypes value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public ReplicationOperationTypes get_OperationType();
    [CompilerGeneratedAttribute]
public void set_OperationType(ReplicationOperationTypes value);
    [CompilerGeneratedAttribute]
public String[] get_Conflicts();
    [CompilerGeneratedAttribute]
public void set_Conflicts(String[] value);
    public virtual string ToString();
}
[FlagsAttribute]
public enum Raven.Abstractions.Data.ReplicationConflictTypes : Enum {
    public int value__;
    public static ReplicationConflictTypes None;
    public static ReplicationConflictTypes DocumentReplicationConflict;
    [ObsoleteAttribute("Use RavenFS instead.")]
public static ReplicationConflictTypes AttachmentReplicationConflict;
}
public class Raven.Abstractions.Data.ReplicationInfoStatus : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    public string Url { get; public set; }
    public string Status { get; public set; }
    public int Code { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(string value);
    [CompilerGeneratedAttribute]
public int get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(int value);
}
[FlagsAttribute]
public enum Raven.Abstractions.Data.ReplicationOperationTypes : Enum {
    public int value__;
    public static ReplicationOperationTypes None;
    public static ReplicationOperationTypes Put;
    public static ReplicationOperationTypes Delete;
}
public class Raven.Abstractions.Data.ResourceAccess : object {
    [CompilerGeneratedAttribute]
private bool <Admin>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadOnly>k__BackingField;
    public bool Admin { get; public set; }
    public string TenantId { get; public set; }
    public bool ReadOnly { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Admin();
    [CompilerGeneratedAttribute]
public void set_Admin(bool value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public bool get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(bool value);
    protected bool Equals(ResourceAccess other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.Data.ResourceBackupState : OperationStateBase {
}
public class Raven.Abstractions.Data.RestoreInProgress : object {
    public static string RavenRestoreInProgressDocumentKey;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    public string Resource { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
}
public class Raven.Abstractions.Data.RestoreStatus : object {
    public static string RavenRestoreStatusDocumentKey;
    public RestoreStatusState State;
    [CompilerGeneratedAttribute]
private List`1<string> <Messages>k__BackingField;
    public List`1<string> Messages { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Messages();
    [CompilerGeneratedAttribute]
public void set_Messages(List`1<string> value);
    public static string RavenFilesystemRestoreStatusDocumentKey(string filesystemName);
}
public enum Raven.Abstractions.Data.RestoreStatusState : Enum {
    public int value__;
    public static RestoreStatusState Running;
    public static RestoreStatusState Completed;
    public static RestoreStatusState Faulted;
}
public class Raven.Abstractions.Data.ScriptedIndexResults : object {
    public static string IdPrefix;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexScript>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeleteScript>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RetryOnConcurrencyExceptions>k__BackingField;
    public string Id { get; public set; }
    public string IndexScript { get; public set; }
    public string DeleteScript { get; public set; }
    public bool RetryOnConcurrencyExceptions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_IndexScript();
    [CompilerGeneratedAttribute]
public void set_IndexScript(string value);
    [CompilerGeneratedAttribute]
public string get_DeleteScript();
    [CompilerGeneratedAttribute]
public void set_DeleteScript(string value);
    [CompilerGeneratedAttribute]
public bool get_RetryOnConcurrencyExceptions();
    [CompilerGeneratedAttribute]
public void set_RetryOnConcurrencyExceptions(bool value);
    protected bool Equals(ScriptedIndexResults other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.Data.ScriptedPatchRequest : object {
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Values>k__BackingField;
    public string Script { get; public set; }
    public Dictionary`2<string, object> Values { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Script();
    [CompilerGeneratedAttribute]
public void set_Script(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(Dictionary`2<string, object> value);
    public static ScriptedPatchRequest FromJson(RavenJObject patchRequestJson);
    protected bool Equals(ScriptedPatchRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.Data.SideBySideIndexes : object {
    [CompilerGeneratedAttribute]
private IndexToAdd[] <IndexesToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <MinimumEtagBeforeReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ReplaceTimeUtc>k__BackingField;
    public IndexToAdd[] IndexesToAdd { get; public set; }
    public Etag MinimumEtagBeforeReplace { get; public set; }
    public Nullable`1<DateTime> ReplaceTimeUtc { get; public set; }
    [CompilerGeneratedAttribute]
public IndexToAdd[] get_IndexesToAdd();
    [CompilerGeneratedAttribute]
public void set_IndexesToAdd(IndexToAdd[] value);
    [CompilerGeneratedAttribute]
public Etag get_MinimumEtagBeforeReplace();
    [CompilerGeneratedAttribute]
public void set_MinimumEtagBeforeReplace(Etag value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ReplaceTimeUtc();
    [CompilerGeneratedAttribute]
public void set_ReplaceTimeUtc(Nullable`1<DateTime> value);
}
public class Raven.Abstractions.Data.SimulateSqlReplicationResult : object {
    public string DocumentId;
    public bool PerformRolledBackTransaction;
    public string SqlReplication;
}
public class Raven.Abstractions.Data.SortedField : object {
    [CompilerGeneratedAttribute]
private string <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Descending>k__BackingField;
    public string Field { get; public set; }
    public bool Descending { get; public set; }
    public SortedField(string fieldWithPotentialPrefix);
    [CompilerGeneratedAttribute]
public string get_Field();
    [CompilerGeneratedAttribute]
public void set_Field(string value);
    [CompilerGeneratedAttribute]
public bool get_Descending();
    [CompilerGeneratedAttribute]
public void set_Descending(bool value);
}
public class Raven.Abstractions.Data.SpatialIndexQuery : IndexQuery {
    [CompilerGeneratedAttribute]
private string <QueryShape>k__BackingField;
    [CompilerGeneratedAttribute]
private SpatialRelation <SpatialRelation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DistanceErrorPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SpatialUnits> <RadiusUnitOverride>k__BackingField;
    private string spatialFieldName;
    public string QueryShape { get; public set; }
    public SpatialRelation SpatialRelation { get; public set; }
    public double DistanceErrorPercentage { get; public set; }
    public Nullable`1<SpatialUnits> RadiusUnitOverride { get; public set; }
    public string SpatialFieldName { get; public set; }
    public SpatialIndexQuery(IndexQuery query);
    public static string GetQueryShapeFromLatLon(double lat, double lng, double radius);
    [CompilerGeneratedAttribute]
public string get_QueryShape();
    [CompilerGeneratedAttribute]
public void set_QueryShape(string value);
    [CompilerGeneratedAttribute]
public SpatialRelation get_SpatialRelation();
    [CompilerGeneratedAttribute]
public void set_SpatialRelation(SpatialRelation value);
    [CompilerGeneratedAttribute]
public double get_DistanceErrorPercentage();
    [CompilerGeneratedAttribute]
public void set_DistanceErrorPercentage(double value);
    [CompilerGeneratedAttribute]
public Nullable`1<SpatialUnits> get_RadiusUnitOverride();
    [CompilerGeneratedAttribute]
public void set_RadiusUnitOverride(Nullable`1<SpatialUnits> value);
    public string get_SpatialFieldName();
    public void set_SpatialFieldName(string value);
    protected virtual string GetCustomQueryStringVariables();
}
public class Raven.Abstractions.Data.StopWordsSetup : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <StopWords>k__BackingField;
    public string Id { get; public set; }
    public List`1<string> StopWords { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_StopWords();
    [CompilerGeneratedAttribute]
public void set_StopWords(List`1<string> value);
}
public class Raven.Abstractions.Data.StorageStats : object {
    [CompilerGeneratedAttribute]
private VoronStorageStats <VoronStats>k__BackingField;
    [CompilerGeneratedAttribute]
private EsentStorageStats <EsentStats>k__BackingField;
    public VoronStorageStats VoronStats { get; public set; }
    public EsentStorageStats EsentStats { get; public set; }
    [CompilerGeneratedAttribute]
public VoronStorageStats get_VoronStats();
    [CompilerGeneratedAttribute]
public void set_VoronStats(VoronStorageStats value);
    [CompilerGeneratedAttribute]
public EsentStorageStats get_EsentStats();
    [CompilerGeneratedAttribute]
public void set_EsentStats(EsentStorageStats value);
}
public class Raven.Abstractions.Data.StreamResult`1 : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private TType <Document>k__BackingField;
    public string Key { get; public set; }
    public Etag Etag { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public TType Document { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public TType get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(TType value);
}
public enum Raven.Abstractions.Data.StringDistanceTypes : Enum {
    public int value__;
    public static StringDistanceTypes None;
    public static StringDistanceTypes Default;
    public static StringDistanceTypes Levenshtein;
    public static StringDistanceTypes JaroWinkler;
    public static StringDistanceTypes NGram;
}
public class Raven.Abstractions.Data.SubscriptionBatchOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDocCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <AcknowledgmentTimeout>k__BackingField;
    public Nullable`1<int> MaxSize { get; public set; }
    public int MaxDocCount { get; public set; }
    public TimeSpan AcknowledgmentTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxSize();
    [CompilerGeneratedAttribute]
public void set_MaxSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public int get_MaxDocCount();
    [CompilerGeneratedAttribute]
public void set_MaxDocCount(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_AcknowledgmentTimeout();
    [CompilerGeneratedAttribute]
public void set_AcknowledgmentTimeout(TimeSpan value);
}
public class Raven.Abstractions.Data.SubscriptionConfig : object {
    [CompilerGeneratedAttribute]
private long <SubscriptionId>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionCriteria <Criteria>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <AckEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeOfSendingLastBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeOfLastAcknowledgment>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeOfLastClientActivity>k__BackingField;
    public long SubscriptionId { get; public set; }
    public SubscriptionCriteria Criteria { get; public set; }
    public Etag AckEtag { get; public set; }
    public DateTime TimeOfSendingLastBatch { get; public set; }
    public DateTime TimeOfLastAcknowledgment { get; public set; }
    public DateTime TimeOfLastClientActivity { get; public set; }
    [CompilerGeneratedAttribute]
public long get_SubscriptionId();
    [CompilerGeneratedAttribute]
public void set_SubscriptionId(long value);
    [CompilerGeneratedAttribute]
public SubscriptionCriteria get_Criteria();
    [CompilerGeneratedAttribute]
public void set_Criteria(SubscriptionCriteria value);
    [CompilerGeneratedAttribute]
public Etag get_AckEtag();
    [CompilerGeneratedAttribute]
public void set_AckEtag(Etag value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeOfSendingLastBatch();
    [CompilerGeneratedAttribute]
public void set_TimeOfSendingLastBatch(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeOfLastAcknowledgment();
    [CompilerGeneratedAttribute]
public void set_TimeOfLastAcknowledgment(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeOfLastClientActivity();
    [CompilerGeneratedAttribute]
public void set_TimeOfLastClientActivity(DateTime value);
}
public class Raven.Abstractions.Data.SubscriptionConnectionOptions : object {
    private static int connectionCounter;
    [CompilerGeneratedAttribute]
private string <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionBatchOptions <BatchOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToWaitBeforeConnectionRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ClientAliveNotificationInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <PullingRequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSubscribersErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionOpeningStrategy <Strategy>k__BackingField;
    public string ConnectionId { get; private set; }
    public SubscriptionBatchOptions BatchOptions { get; public set; }
    public TimeSpan TimeToWaitBeforeConnectionRetry { get; public set; }
    public TimeSpan ClientAliveNotificationInterval { get; public set; }
    public TimeSpan PullingRequestTimeout { get; public set; }
    public bool IgnoreSubscribersErrors { get; public set; }
    public SubscriptionOpeningStrategy Strategy { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConnectionId();
    [CompilerGeneratedAttribute]
private void set_ConnectionId(string value);
    [CompilerGeneratedAttribute]
public SubscriptionBatchOptions get_BatchOptions();
    [CompilerGeneratedAttribute]
public void set_BatchOptions(SubscriptionBatchOptions value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToWaitBeforeConnectionRetry();
    [CompilerGeneratedAttribute]
public void set_TimeToWaitBeforeConnectionRetry(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ClientAliveNotificationInterval();
    [CompilerGeneratedAttribute]
public void set_ClientAliveNotificationInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_PullingRequestTimeout();
    [CompilerGeneratedAttribute]
public void set_PullingRequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSubscribersErrors();
    [CompilerGeneratedAttribute]
public void set_IgnoreSubscribersErrors(bool value);
    [CompilerGeneratedAttribute]
public SubscriptionOpeningStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(SubscriptionOpeningStrategy value);
}
public class Raven.Abstractions.Data.SubscriptionCriteria : object {
    [CompilerGeneratedAttribute]
private string <KeyStartsWith>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <StartEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BelongsToAnyCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, RavenJToken> <PropertiesMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, RavenJToken> <PropertiesNotMatch>k__BackingField;
    public string KeyStartsWith { get; public set; }
    public Etag StartEtag { get; public set; }
    public String[] BelongsToAnyCollection { get; public set; }
    public Dictionary`2<string, RavenJToken> PropertiesMatch { get; public set; }
    public Dictionary`2<string, RavenJToken> PropertiesNotMatch { get; public set; }
    [CompilerGeneratedAttribute]
public string get_KeyStartsWith();
    [CompilerGeneratedAttribute]
public void set_KeyStartsWith(string value);
    [CompilerGeneratedAttribute]
public Etag get_StartEtag();
    [CompilerGeneratedAttribute]
public void set_StartEtag(Etag value);
    [CompilerGeneratedAttribute]
public String[] get_BelongsToAnyCollection();
    [CompilerGeneratedAttribute]
public void set_BelongsToAnyCollection(String[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, RavenJToken> get_PropertiesMatch();
    [CompilerGeneratedAttribute]
public void set_PropertiesMatch(Dictionary`2<string, RavenJToken> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, RavenJToken> get_PropertiesNotMatch();
    [CompilerGeneratedAttribute]
public void set_PropertiesNotMatch(Dictionary`2<string, RavenJToken> value);
}
public class Raven.Abstractions.Data.SubscriptionCriteria`1 : object {
    [CompilerGeneratedAttribute]
private string <KeyStartsWith>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <StartEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<T, object>>, RavenJToken> <PropertiesMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<Expression`1<Func`2<T, object>>, RavenJToken> <PropertiesNotMatch>k__BackingField;
    public string KeyStartsWith { get; public set; }
    public Etag StartEtag { get; public set; }
    public IDictionary`2<Expression`1<Func`2<T, object>>, RavenJToken> PropertiesMatch { get; public set; }
    public IDictionary`2<Expression`1<Func`2<T, object>>, RavenJToken> PropertiesNotMatch { get; public set; }
    [CompilerGeneratedAttribute]
public string get_KeyStartsWith();
    [CompilerGeneratedAttribute]
public void set_KeyStartsWith(string value);
    [CompilerGeneratedAttribute]
public Etag get_StartEtag();
    [CompilerGeneratedAttribute]
public void set_StartEtag(Etag value);
    [CompilerGeneratedAttribute]
public IDictionary`2<Expression`1<Func`2<T, object>>, RavenJToken> get_PropertiesMatch();
    [CompilerGeneratedAttribute]
public void set_PropertiesMatch(IDictionary`2<Expression`1<Func`2<T, object>>, RavenJToken> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<Expression`1<Func`2<T, object>>, RavenJToken> get_PropertiesNotMatch();
    [CompilerGeneratedAttribute]
public void set_PropertiesNotMatch(IDictionary`2<Expression`1<Func`2<T, object>>, RavenJToken> value);
    public void PropertyMatch(Expression`1<Func`2<T, object>> field, RavenJToken indexing);
    public void PropertyNotMatch(Expression`1<Func`2<T, object>> field, RavenJToken indexing);
    public Dictionary`2<string, RavenJToken> GetPropertiesMatchStrings();
    public Dictionary`2<string, RavenJToken> GetPropertiesNotMatchStrings();
    private Dictionary`2<string, TValue> ConvertToStringDictionary(IEnumerable`1<KeyValuePair`2<Expression`1<Func`2<T, object>>, TValue>> input);
}
public enum Raven.Abstractions.Data.SubscriptionOpeningStrategy : Enum {
    public int value__;
    public static SubscriptionOpeningStrategy OpenIfFree;
    public static SubscriptionOpeningStrategy TakeOver;
    public static SubscriptionOpeningStrategy ForceAndKeep;
    public static SubscriptionOpeningStrategy WaitForFree;
}
public class Raven.Abstractions.Data.SuggestionQuery : object {
    public static float DefaultAccuracy;
    public static int DefaultMaxSuggestions;
    public static StringDistanceTypes DefaultDistance;
    [CompilerGeneratedAttribute]
private string <Term>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSuggestions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<StringDistanceTypes> <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <Accuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Popularity>k__BackingField;
    public string Term { get; public set; }
    public string Field { get; public set; }
    public int MaxSuggestions { get; public set; }
    public Nullable`1<StringDistanceTypes> Distance { get; public set; }
    public Nullable`1<float> Accuracy { get; public set; }
    public bool Popularity { get; public set; }
    private static SuggestionQuery();
    [CompilerGeneratedAttribute]
public string get_Term();
    [CompilerGeneratedAttribute]
public void set_Term(string value);
    [CompilerGeneratedAttribute]
public string get_Field();
    [CompilerGeneratedAttribute]
public void set_Field(string value);
    [CompilerGeneratedAttribute]
public int get_MaxSuggestions();
    [CompilerGeneratedAttribute]
public void set_MaxSuggestions(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<StringDistanceTypes> get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(Nullable`1<StringDistanceTypes> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_Accuracy();
    [CompilerGeneratedAttribute]
public void set_Accuracy(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public bool get_Popularity();
    [CompilerGeneratedAttribute]
public void set_Popularity(bool value);
}
public class Raven.Abstractions.Data.SuggestionQueryResult : object {
    [CompilerGeneratedAttribute]
private String[] <Suggestions>k__BackingField;
    public String[] Suggestions { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Suggestions();
    [CompilerGeneratedAttribute]
public void set_Suggestions(String[] value);
}
public class Raven.Abstractions.Data.TaskBasedOperationState : object {
    private Task task;
    private Func`1<RavenJObject> stateProvider;
    public Exception Exception { get; }
    public bool Completed { get; }
    public bool Faulted { get; }
    public bool Canceled { get; }
    public RavenJObject State { get; }
    public TaskBasedOperationState(Task task, Func`1<RavenJObject> stateProvider);
    public sealed virtual Exception get_Exception();
    public sealed virtual bool get_Completed();
    public sealed virtual bool get_Faulted();
    public sealed virtual bool get_Canceled();
    public sealed virtual RavenJObject get_State();
}
public class Raven.Abstractions.Data.TrafficWatchNotification : EventArgs {
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ElapsedMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResponseStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AbsoluteUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InnerRequestsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <QueryTimings>k__BackingField;
    public DateTime TimeStamp { get; public set; }
    public int RequestId { get; public set; }
    public string HttpMethod { get; public set; }
    public long ElapsedMilliseconds { get; public set; }
    public int ResponseStatusCode { get; public set; }
    public string RequestUri { get; public set; }
    public string AbsoluteUri { get; public set; }
    public string TenantName { get; public set; }
    public string CustomInfo { get; public set; }
    public int InnerRequestsCount { get; public set; }
    public RavenJObject QueryTimings { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
    [CompilerGeneratedAttribute]
public int get_RequestId();
    [CompilerGeneratedAttribute]
public void set_RequestId(int value);
    [CompilerGeneratedAttribute]
public string get_HttpMethod();
    [CompilerGeneratedAttribute]
public void set_HttpMethod(string value);
    [CompilerGeneratedAttribute]
public long get_ElapsedMilliseconds();
    [CompilerGeneratedAttribute]
public void set_ElapsedMilliseconds(long value);
    [CompilerGeneratedAttribute]
public int get_ResponseStatusCode();
    [CompilerGeneratedAttribute]
public void set_ResponseStatusCode(int value);
    [CompilerGeneratedAttribute]
public string get_RequestUri();
    [CompilerGeneratedAttribute]
public void set_RequestUri(string value);
    [CompilerGeneratedAttribute]
public string get_AbsoluteUri();
    [CompilerGeneratedAttribute]
public void set_AbsoluteUri(string value);
    [CompilerGeneratedAttribute]
public string get_TenantName();
    [CompilerGeneratedAttribute]
public void set_TenantName(string value);
    [CompilerGeneratedAttribute]
public string get_CustomInfo();
    [CompilerGeneratedAttribute]
public void set_CustomInfo(string value);
    [CompilerGeneratedAttribute]
public int get_InnerRequestsCount();
    [CompilerGeneratedAttribute]
public void set_InnerRequestsCount(int value);
    [CompilerGeneratedAttribute]
public RavenJObject get_QueryTimings();
    [CompilerGeneratedAttribute]
public void set_QueryTimings(RavenJObject value);
}
public class Raven.Abstractions.Data.TransactionInformation : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    public string Id { get; public set; }
    public TimeSpan Timeout { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(TimeSpan value);
}
public enum Raven.Abstractions.Data.TransactionMode : Enum {
    public int value__;
    public static TransactionMode Lazy;
    public static TransactionMode Safe;
}
public class Raven.Abstractions.Data.TransformerChangeNotification : EventArgs {
    [CompilerGeneratedAttribute]
private TransformerChangeTypes <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Version>k__BackingField;
    public TransformerChangeTypes Type { get; public set; }
    public string Name { get; public set; }
    public Nullable`1<int> Version { get; public set; }
    [CompilerGeneratedAttribute]
public TransformerChangeTypes get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TransformerChangeTypes value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Nullable`1<int> value);
    public virtual string ToString();
}
public enum Raven.Abstractions.Data.TransformerChangeTypes : Enum {
    public int value__;
    public static TransformerChangeTypes None;
    public static TransformerChangeTypes TransformerAdded;
    public static TransformerChangeTypes TransformerRemoved;
}
public class Raven.Abstractions.Data.TriggerInfo : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Type { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public class Raven.Abstractions.Data.UserInfo : object {
    [CompilerGeneratedAttribute]
private string <Remark>k__BackingField;
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAdminGlobal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAdminCurrentDb>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DatabaseInfo> <Databases>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrincipal <Principal>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AdminDatabases>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ReadOnlyDatabases>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ReadWriteDatabases>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessTokenBody <AccessTokenBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBackupOperator>k__BackingField;
    public string Remark { get; public set; }
    public string User { get; public set; }
    public bool IsAdminGlobal { get; public set; }
    public bool IsAdminCurrentDb { get; public set; }
    public List`1<DatabaseInfo> Databases { get; public set; }
    public IPrincipal Principal { get; public set; }
    public HashSet`1<string> AdminDatabases { get; public set; }
    public HashSet`1<string> ReadOnlyDatabases { get; public set; }
    public HashSet`1<string> ReadWriteDatabases { get; public set; }
    public AccessTokenBody AccessTokenBody { get; public set; }
    public bool IsBackupOperator { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Remark();
    [CompilerGeneratedAttribute]
public void set_Remark(string value);
    [CompilerGeneratedAttribute]
public string get_User();
    [CompilerGeneratedAttribute]
public void set_User(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAdminGlobal();
    [CompilerGeneratedAttribute]
public void set_IsAdminGlobal(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAdminCurrentDb();
    [CompilerGeneratedAttribute]
public void set_IsAdminCurrentDb(bool value);
    [CompilerGeneratedAttribute]
public List`1<DatabaseInfo> get_Databases();
    [CompilerGeneratedAttribute]
public void set_Databases(List`1<DatabaseInfo> value);
    [CompilerGeneratedAttribute]
public IPrincipal get_Principal();
    [CompilerGeneratedAttribute]
public void set_Principal(IPrincipal value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_AdminDatabases();
    [CompilerGeneratedAttribute]
public void set_AdminDatabases(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ReadOnlyDatabases();
    [CompilerGeneratedAttribute]
public void set_ReadOnlyDatabases(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ReadWriteDatabases();
    [CompilerGeneratedAttribute]
public void set_ReadWriteDatabases(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public AccessTokenBody get_AccessTokenBody();
    [CompilerGeneratedAttribute]
public void set_AccessTokenBody(AccessTokenBody value);
    [CompilerGeneratedAttribute]
public bool get_IsBackupOperator();
    [CompilerGeneratedAttribute]
public void set_IsBackupOperator(bool value);
}
public class Raven.Abstractions.Data.UserPermission : object {
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabaseInfo <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGranted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string User { get; public set; }
    public DatabaseInfo Database { get; public set; }
    public string Method { get; public set; }
    public bool IsGranted { get; public set; }
    public string Reason { get; public set; }
    [CompilerGeneratedAttribute]
public string get_User();
    [CompilerGeneratedAttribute]
public void set_User(string value);
    [CompilerGeneratedAttribute]
public DatabaseInfo get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DatabaseInfo value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public bool get_IsGranted();
    [CompilerGeneratedAttribute]
public void set_IsGranted(bool value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
}
public enum Raven.Abstractions.Data.UuidType : Enum {
    public byte value__;
    public static UuidType Documents;
    [ObsoleteAttribute("Use RavenFS instead.")]
public static UuidType Attachments;
    public static UuidType DocumentTransactions;
    public static UuidType MappedResults;
    public static UuidType ReduceResults;
    public static UuidType ScheduledReductions;
    public static UuidType Queue;
    public static UuidType Tasks;
    public static UuidType Indexing;
    public static UuidType DocumentReferences;
    public static UuidType Subscriptions;
    public static UuidType Transformers;
    public static UuidType Cluster;
    public static UuidType Licensing;
    public static UuidType SupportCoverage;
}
public class Raven.Abstractions.Data.VoronActiveTransaction : object {
    public long Id;
    public string Flags;
}
public class Raven.Abstractions.Data.VoronStorageStats : object {
    public long FreePagesOverhead;
    public long RootPages;
    public long NumberOfAllocatedPages;
    public long NextPageNumber;
    public long UnallocatedPagesAtEndOfFile;
    public long UsedDataFileSizeInBytes;
    public long AllocatedDataFileSizeInBytes;
    public long NextWriteTransactionId;
    public List`1<VoronActiveTransaction> ActiveTransactions;
    public object ScratchBufferPoolInfo;
}
public static class Raven.Abstractions.Default : object {
    public static String[] OnlyDateTimeFormat;
    public static String[] DateTimeFormatsToRead;
    public static string DateTimeOffsetFormatsToWrite;
    public static string DateTimeFormatsToWrite;
    public static JsonConverterCollection Converters;
    private static Default();
}
public class Raven.Abstractions.EnvironmentUtils : object {
    private static bool runningOnMono;
    public static bool RunningOnMono { get; }
    public static bool RunningOnPosix { get; }
    private static EnvironmentUtils();
    public static bool get_RunningOnMono();
    public static bool get_RunningOnPosix();
}
public class Raven.Abstractions.Exceptions.BadRequestException : Exception {
    public BadRequestException(string message);
    public BadRequestException(string message, Exception inner);
    protected BadRequestException(SerializationInfo info, StreamingContext context);
}
public class Raven.Abstractions.Exceptions.ConcurrencyException : Exception {
    [CompilerGeneratedAttribute]
private Etag <ExpectedETag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <ActualETag>k__BackingField;
    public Etag ExpectedETag { get; public set; }
    public Etag ActualETag { get; public set; }
    public ConcurrencyException(string message);
    public ConcurrencyException(string message, Exception inner);
    protected ConcurrencyException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Etag get_ExpectedETag();
    [CompilerGeneratedAttribute]
public void set_ExpectedETag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_ActualETag();
    [CompilerGeneratedAttribute]
public void set_ActualETag(Etag value);
}
public class Raven.Abstractions.Exceptions.ConcurrentLoadTimeoutException : Exception {
    public ConcurrentLoadTimeoutException(string message);
    public ConcurrentLoadTimeoutException(string message, Exception inner);
    protected ConcurrentLoadTimeoutException(SerializationInfo info, StreamingContext context);
}
public class Raven.Abstractions.Exceptions.DocumentDoesNotExistsException : Exception {
    public DocumentDoesNotExistsException(string message);
    public DocumentDoesNotExistsException(string message, Exception inner);
    protected DocumentDoesNotExistsException(SerializationInfo info, StreamingContext context);
}
public class Raven.Abstractions.Exceptions.FixedSizeConcurrentQueue`1 : object {
    private ConcurrentQueue`1<T> inner;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public int Size { get; private set; }
    public FixedSizeConcurrentQueue`1(int size);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(int value);
    public void Enqueue(T obj);
    public bool TryPeek(T& outObj);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Raven.Abstractions.Exceptions.ImplicitFetchFieldsFromDocumentNotAllowedException : Exception {
    public ImplicitFetchFieldsFromDocumentNotAllowedException(string message);
    public ImplicitFetchFieldsFromDocumentNotAllowedException(string message, Exception inner);
    protected ImplicitFetchFieldsFromDocumentNotAllowedException(SerializationInfo info, StreamingContext context);
}
public class Raven.Abstractions.Exceptions.IndexCompilationException : Exception {
    [CompilerGeneratedAttribute]
private string <IndexDefinitionProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProblematicText>k__BackingField;
    public string IndexDefinitionProperty { get; public set; }
    public string ProblematicText { get; public set; }
    public IndexCompilationException(string message);
    public IndexCompilationException(string message, Exception inner);
    protected IndexCompilationException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_IndexDefinitionProperty();
    [CompilerGeneratedAttribute]
public void set_IndexDefinitionProperty(string value);
    [CompilerGeneratedAttribute]
public string get_ProblematicText();
    [CompilerGeneratedAttribute]
public void set_ProblematicText(string value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <ToString>b__12_0(StringBuilder description);
}
public class Raven.Abstractions.Exceptions.IndexDisabledException : Exception {
    [CompilerGeneratedAttribute]
private IndexFailureInformation <Information>k__BackingField;
    public IndexFailureInformation Information { get; public set; }
    public IndexDisabledException(IndexFailureInformation information);
    public IndexDisabledException(string message);
    public IndexDisabledException(string message, Exception inner);
    protected IndexDisabledException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IndexFailureInformation get_Information();
    [CompilerGeneratedAttribute]
public void set_Information(IndexFailureInformation value);
}
public class Raven.Abstractions.Exceptions.IndexDoesNotExistsException : Exception {
    public IndexDoesNotExistsException(string message);
    public IndexDoesNotExistsException(string message, Exception inner);
    protected IndexDoesNotExistsException(SerializationInfo info, StreamingContext context);
}
public class Raven.Abstractions.Exceptions.InvalidSpatialShapException : Exception {
    private string invalidDocumentId;
    public string InvalidDocumentId { get; }
    public InvalidSpatialShapException(string message);
    public InvalidSpatialShapException(string message, Exception inner);
    public InvalidSpatialShapException(Exception invalidShapeException, string invalidDocumentId);
    protected InvalidSpatialShapException(SerializationInfo info, StreamingContext context);
    public string get_InvalidDocumentId();
}
public class Raven.Abstractions.Exceptions.OperationVetoedException : Exception {
    public OperationVetoedException(string message);
    public OperationVetoedException(string message, Exception inner);
    protected OperationVetoedException(SerializationInfo info, StreamingContext context);
}
public class Raven.Abstractions.Exceptions.ServerVersionNotSuppportedException : Exception {
    public ServerVersionNotSuppportedException(string message);
    public ServerVersionNotSuppportedException(string message, Exception inner);
    protected ServerVersionNotSuppportedException(SerializationInfo info, StreamingContext context);
}
public class Raven.Abstractions.Exceptions.SmugglerException : Exception {
    public SmugglerException(string message);
    public SmugglerException(string message, Exception inner);
    protected SmugglerException(SerializationInfo info, StreamingContext context);
}
public class Raven.Abstractions.Exceptions.SmugglerExportException : Exception {
    [CompilerGeneratedAttribute]
private Etag <LastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    public Etag LastEtag { get; public set; }
    public string File { get; public set; }
    public SmugglerExportException(string message);
    public SmugglerExportException(string message, Exception inner);
    protected SmugglerExportException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Etag get_LastEtag();
    [CompilerGeneratedAttribute]
public void set_LastEtag(Etag value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
}
public class Raven.Abstractions.Exceptions.SmugglerImportException : Exception {
    [CompilerGeneratedAttribute]
private Etag <LastEtag>k__BackingField;
    public Etag LastEtag { get; public set; }
    public SmugglerImportException(string message);
    public SmugglerImportException(string message, Exception inner);
    protected SmugglerImportException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Etag get_LastEtag();
    [CompilerGeneratedAttribute]
public void set_LastEtag(Etag value);
}
public class Raven.Abstractions.Exceptions.Subscriptions.SubscriptionAckTimeoutException : SubscriptionException {
    public static HttpStatusCode RelevantHttpStatusCode;
    public SubscriptionAckTimeoutException(string message);
    public SubscriptionAckTimeoutException(string message, Exception inner);
    protected SubscriptionAckTimeoutException(SerializationInfo info, StreamingContext context);
    private static SubscriptionAckTimeoutException();
}
public class Raven.Abstractions.Exceptions.Subscriptions.SubscriptionClosedException : SubscriptionException {
    public static HttpStatusCode RelevantHttpStatusCode;
    public SubscriptionClosedException(string message);
    public SubscriptionClosedException(string message, Exception inner);
    protected SubscriptionClosedException(SerializationInfo info, StreamingContext context);
    private static SubscriptionClosedException();
}
public class Raven.Abstractions.Exceptions.Subscriptions.SubscriptionDoesNotExistException : SubscriptionException {
    public static HttpStatusCode RelevantHttpStatusCode;
    public SubscriptionDoesNotExistException(string message);
    public SubscriptionDoesNotExistException(string message, Exception inner);
    protected SubscriptionDoesNotExistException(SerializationInfo info, StreamingContext context);
    private static SubscriptionDoesNotExistException();
}
public abstract class Raven.Abstractions.Exceptions.Subscriptions.SubscriptionException : Exception {
    [CompilerGeneratedAttribute]
private HttpStatusCode <ResponseStatusCode>k__BackingField;
    public HttpStatusCode ResponseStatusCode { get; private set; }
    protected SubscriptionException(HttpStatusCode httpResponseCode);
    protected SubscriptionException(string message, HttpStatusCode httpResponseCode);
    protected SubscriptionException(string message, Exception inner, HttpStatusCode httpResponseCode);
    protected SubscriptionException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_ResponseStatusCode();
    [CompilerGeneratedAttribute]
private void set_ResponseStatusCode(HttpStatusCode value);
}
public class Raven.Abstractions.Exceptions.Subscriptions.SubscriptionInUseException : SubscriptionException {
    public static HttpStatusCode RelavantHttpStatusCode;
    public SubscriptionInUseException(string message);
    public SubscriptionInUseException(string message, Exception inner);
    protected SubscriptionInUseException(SerializationInfo info, StreamingContext context);
    private static SubscriptionInUseException();
}
public class Raven.Abstractions.Exceptions.TotalDataSizeExceededException : Exception {
    public TotalDataSizeExceededException(string message);
    public TotalDataSizeExceededException(string message, Exception inner);
    protected TotalDataSizeExceededException(SerializationInfo info, StreamingContext context);
}
public class Raven.Abstractions.Exceptions.TransformCompilationException : Exception {
    public TransformCompilationException(string message);
    public TransformCompilationException(string message, Exception inner);
    protected TransformCompilationException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
[ObsoleteAttribute("Use RavenFS instead.")]
public static class Raven.Abstractions.Extensions.AttachmentExtensions : object {
    [ExtensionAttribute]
public static bool IsConflictAttachment(Attachment attachment);
}
public class Raven.Abstractions.Extensions.Buffers : object {
    public static int Compare(Byte[] x, Byte[] y);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.CharExtensions : object {
    [ExtensionAttribute]
public static string CharToString(char c);
    [ExtensionAttribute]
public static string ToInvariantString(object obj);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.ConcurrentDictionaryExtensions : object {
    [ExtensionAttribute]
public static TVal GetOrDefault(ConcurrentDictionary`2<TKey, TVal> self, TKey key, TVal value);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.ConcurrentQueueExtensions : object {
    [ExtensionAttribute]
public static void LimitedSizeEnqueue(ConcurrentQueue`1<T> queue, T item, int sizeOfQueue);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.CryptoTransformExtensions : object {
    [ExtensionAttribute]
public static Byte[] TransformEntireBlock(ICryptoTransform transform, Byte[] data);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.CSharpIdentifierExtensions : object {
    private static Hashtable keywordsTable;
    private static String[] keywords;
    private static CSharpIdentifierExtensions();
    [ExtensionAttribute]
public static bool IsValidIdentifier(string identifier);
    internal static bool is_identifier_start_character(char c);
    internal static bool is_identifier_part_character(char c);
    internal static void FillKeywordTable();
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TVal GetOrAdd(IDictionary`2<TKey, TVal> self, TKey key);
    [ExtensionAttribute]
public static TVal GetOrDefault(IDictionary`2<TKey, TVal> self, TKey key);
    public static bool ContentEquals(IDictionary`2<TKey, TValue> x, IDictionary`2<TKey, TValue> y);
}
public class Raven.Abstractions.Extensions.DisposableAction : object {
    private Action action;
    public DisposableAction(Action action);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.ExceptionExtensions : object {
    [ExtensionAttribute]
public static Exception ExtractSingleInnerException(AggregateException e);
    [ExtensionAttribute]
public static string SimplifyError(Exception e);
    [ExtensionAttribute]
public static Task`1<string> TryReadResponseIfWebException(AggregateException e);
    [ExtensionAttribute]
public static string TryReadResponseIfWebException(Exception ex);
    [ExtensionAttribute]
public static string TryReadErrorPropertyFromJson(string errorString);
    [ExtensionAttribute]
public static Task`1<T> TryReadErrorResponseObject(ErrorResponseException ex, T protoTypeObject);
    [ExtensionAttribute]
public static T TryReadErrorResponseObject(Exception ex, T protoTypeObject);
    [ExtensionAttribute]
public static string ExceptionToString(Exception ex, Action`1<StringBuilder> customFieldsFormatterAction);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.ExpressionExtensions : object {
    [ExtensionAttribute]
public static Type ExtractTypeFromPath(Expression`1<Func`2<T, object>> path);
    private static Type GetMemberType(Type type, string property);
    [ExtensionAttribute]
public static MemberInfo ToProperty(LambdaExpression expr);
    [ExtensionAttribute]
public static string ToPropertyPath(LambdaExpression expr, char propertySeparator, char collectionSeparator);
    [ExtensionAttribute]
public static string ToPropertyPath(Expression expression, char propertySeparator, char collectionSeparator);
}
public static class Raven.Abstractions.Extensions.FileSystemPathExtentions : object {
    public static char DirectorySeparatorChar;
    public static char AltDirectorySeparatorChar;
    public static char VolumeSeparatorChar;
    public static Char[] InvalidPathChars;
    public static bool dirEqualsVolume;
    public static string DirectorySeparatorStr;
    public static Char[] PathSeparatorChars;
    private static FileSystemPathExtentions();
    internal static string CleanPath(string s);
    public static string GetDirectoryName(string path);
    internal static bool IsDirectorySeparator(char c);
    public static bool IsPathRooted(string path);
    public static string GetPathRoot(string path);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.JsonExtensions : object {
    public static MeterMetric JsonStreamDeserializationsPerSecond;
    public static MeterMetric JsonStreamDeserializedBytesPerSecond;
    public static MeterMetric JsonStreamSerializationsPerSecond;
    public static MeterMetric JsonStreamSerializedBytesPerSecond;
    private static IContractResolver contractResolver;
    private static JsonExtensions();
    public static RavenJObject ToJObject(object result);
    public static RavenJArray ToJArray(IEnumerable`1<T> result);
    [ExtensionAttribute]
public static RavenJObject ToJObject(Byte[] self);
    [ExtensionAttribute]
public static RavenJObject ToJObject(Stream self);
    private static void RegisterJsonStreamDeserializationMetrics(int numberOfReadBytes);
    private static void RegisterJsonStreamSerializationMetrics(int size);
    [ExtensionAttribute]
public static void WriteTo(RavenJToken self, Stream stream);
    [ExtensionAttribute]
[IteratorStateMachineAttribute("Raven.Abstractions.Extensions.JsonExtensions/<EnumerateJsonObjects>d__12")]
public static IEnumerable`1<string> EnumerateJsonObjects(StreamReader input, char openChar, char closeChar);
    [ExtensionAttribute]
public static T JsonDeserialization(Byte[] self);
    [ExtensionAttribute]
public static T JsonDeserialization(RavenJToken self);
    [ExtensionAttribute]
public static T[] JsonDeserialization(RavenJArray self);
    [ExtensionAttribute]
public static T JsonDeserialization(StreamReader self);
    [ExtensionAttribute]
public static T JsonDeserialization(Stream stream);
    [ExtensionAttribute]
public static T Deserialize(JsonSerializer self, TextReader reader);
    public static JsonSerializer CreateDefaultJsonSerializer();
    private static bool IsJson(StreamWithCachedHeader stream);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.ListExtensions : object {
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> list, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static HashSet`1<T> ToHashSet(IEnumerable`1<T> items);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.MemberInfoExtensions : object {
    [ExtensionAttribute]
public static bool CanWrite(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool CanRead(MemberInfo memberInfo);
    [ExtensionAttribute]
public static ParameterInfo[] GetIndexParameters(MemberInfo memberInfo);
    [ExtensionAttribute]
public static Type Type(MemberInfo memberInfo);
    [ExtensionAttribute]
public static void SetValue(MemberInfo memberInfo, object entity, object value);
    [ExtensionAttribute]
public static object GetValue(MemberInfo memberInfo, object entity);
    [ExtensionAttribute]
public static bool IsProperty(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool IsField(MemberInfo memberInfo);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.MetadataExtensions : object {
    private static HashSet`1<string> HeadersToIgnoreClient;
    private static HashSet`1<string> HeadersToIgnoreForClient;
    private static HashSet`1<string> PrefixesInHeadersToIgnoreClient;
    private static MetadataExtensions();
    [ExtensionAttribute]
public static RavenJObject FilterHeadersToObject(RavenJObject self, HashSet`1<string> headersToIgnore, HashSet`1<string> prefixesInHeadersToIgnore);
    [ExtensionAttribute]
public static RavenJObject FilterHeadersToObject(RavenJObject self);
    [ObsoleteAttribute("Use RavenFS instead.")]
[ExtensionAttribute]
public static RavenJObject FilterHeadersAttachment(NameValueCollection self);
    [ExtensionAttribute]
public static RavenJObject FilterHeadersToObject(NameValueCollection self);
    [ExtensionAttribute]
[ObsoleteAttribute("Use RavenFS instead.")]
public static RavenJObject FilterHeadersAttachment(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> self);
    [ExtensionAttribute]
public static RavenJObject FilterHeadersToObject(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> self, HashSet`1<string> headersToIgnore, HashSet`1<string> prefixesInHeadersToIgnore);
    [ExtensionAttribute]
public static RavenJObject FilterHeadersToObject(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> self);
    [ExtensionAttribute]
public static RavenJObject HeadersToObject(HttpResponseMessage self);
    private static string CaptureHeaderName(string header);
    private static RavenJToken GetValue(string val);
    private static RavenJToken GetValueWithDates(string val);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.RavenDateTimeExtensions : object {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1601;
    private static int DaysTo1899;
    private static int DaysTo10000;
    internal static long MinTicks;
    internal static long MaxTicks;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static Char[][] _fourDigits;
    private static RavenDateTimeExtensions();
    private static Char[][] CreateFourDigitsCache();
    [ExtensionAttribute]
public static string GetDefaultRavenFormat(DateTime dt, bool isUtc);
}
public class Raven.Abstractions.Extensions.Reference`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.ReflectionExtensions : object {
    private static BindingFlags DefaultFlags;
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static bool IsDefined(Type type, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string name, IList`1<Type> parameterTypes);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string name, BindingFlags bindingFlags, object placeHolder1, IList`1<Type> parameterTypes, object placeHolder2);
    [ExtensionAttribute]
public static void InvokeMember(Type type, string name, BindingFlags invokeAttr, object target);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static Type GetMemberType(MemberInfo member);
    private static bool TestAccessibility(MethodBase member, BindingFlags bindingFlags);
}
public static class Raven.Abstractions.Extensions.SetExtensions : object {
    public static bool ContentEquals(ISet`1<TKey> x, ISet`1<TKey> y);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.StreamExtensions : object {
    private static ILog Logger;
    private static StreamExtensions();
    [ExtensionAttribute]
public static void CopyTo(Stream stream, Stream other);
    [ExtensionAttribute]
public static void Write(Stream stream, long value);
    [ExtensionAttribute]
public static void Write(Stream stream, int value);
    [ExtensionAttribute]
private static void PartialRead(Stream stream, Byte[] buffer, int size);
    [ExtensionAttribute]
public static long ReadInt64(Stream stream);
    [ExtensionAttribute]
public static ulong ReadUInt64(Stream stream);
    [ExtensionAttribute]
public static int ReadInt32(Stream stream);
    [ExtensionAttribute]
public static string ReadString(Stream stream);
    [ExtensionAttribute]
public static string ReadString(Stream stream, Encoding encoding);
    [ExtensionAttribute]
public static string ReadStringWithoutPrefix(Stream stream);
    [ExtensionAttribute]
public static string ReadStringWithoutPrefix(Stream stream, Encoding encoding);
    [ExtensionAttribute]
public static void Write(Stream stream, string value);
    [ExtensionAttribute]
public static void Write(Stream stream, string value, Encoding encoding);
    [ExtensionAttribute]
public static void Write(Stream stream, Etag etag);
    [ExtensionAttribute]
public static Etag ReadEtag(Stream stream);
    [ExtensionAttribute]
public static Byte[] ReadData(Stream stream);
    [ExtensionAttribute]
[AsyncStateMachineAttribute("Raven.Abstractions.Extensions.StreamExtensions/<ReadDataAsync>d__17")]
public static Task`1<Byte[]> ReadDataAsync(Stream stream);
    [ExtensionAttribute]
public static Byte[] ReadEntireBlock(Stream stream, int count);
    [ExtensionAttribute]
public static void ReadEntireBlock(Stream stream, Byte[] buffer, int start, int count);
    [ExtensionAttribute]
public static Stream DisposeTogetherWith(Stream stream, IDisposable[] disposables);
}
internal class Raven.Abstractions.Extensions.StreamWithCachedHeader : Stream {
    private Stream inner;
    [CompilerGeneratedAttribute]
private int <ActualHeaderSize>k__BackingField;
    private int headerSizePosition;
    [CompilerGeneratedAttribute]
private Byte[] <Header>k__BackingField;
    private bool passedHeader;
    private int read;
    public int ActualHeaderSize { get; private set; }
    public Byte[] Header { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public StreamWithCachedHeader(Stream stream, int headerSize);
    [CompilerGeneratedAttribute]
public int get_ActualHeaderSize();
    [CompilerGeneratedAttribute]
private void set_ActualHeaderSize(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Byte[] value);
    private void CacheHeader(Stream stream, Byte[] buffer, int headerSize);
    public virtual void Flush();
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static string ConvertToString(Byte[] buffer, int size);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Extensions.TaskExtensions : object {
    [ExtensionAttribute]
public static Task AssertNotFailed(Task task);
    [ExtensionAttribute]
public static Task IgnoreUnobservedExceptions(Task task);
    [ExtensionAttribute]
public static Task`1<T> ConvertSecurityExceptionToServerNotFound(Task`1<T> parent);
    [ExtensionAttribute]
public static Task`1<T> AddUrlIfFaulting(Task`1<T> parent, Uri uri);
    [ExtensionAttribute]
public static Task WithCancellation(Task task, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken token);
    [ExtensionAttribute]
public static void ThrowCancellationIfNotDefault(CancellationToken token);
    [ExtensionAttribute]
[AsyncStateMachineAttribute("Raven.Abstractions.Extensions.TaskExtensions/<WaitWithTimeout>d__7")]
public static Task`1<bool> WaitWithTimeout(Task task, Nullable`1<TimeSpan> timeout);
    [ExtensionAttribute]
[AsyncStateMachineAttribute("Raven.Abstractions.Extensions.TaskExtensions/<WaitWithTimeout>d__8`1")]
public static Task`1<T> WaitWithTimeout(Task`1<T> task, Nullable`1<TimeSpan> timeout, string caller);
}
public class Raven.Abstractions.FileSystem.ConfigurationSearchResults : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <ConfigNames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageSize>k__BackingField;
    public IList`1<string> ConfigNames { get; public set; }
    public int TotalCount { get; public set; }
    public int Start { get; public set; }
    public int PageSize { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<string> get_ConfigNames();
    [CompilerGeneratedAttribute]
public void set_ConfigNames(IList`1<string> value);
    [CompilerGeneratedAttribute]
public int get_TotalCount();
    [CompilerGeneratedAttribute]
public void set_TotalCount(int value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_PageSize();
    [CompilerGeneratedAttribute]
public void set_PageSize(int value);
}
public class Raven.Abstractions.FileSystem.ConflictItem : object {
    [CompilerGeneratedAttribute]
private bool <ResolveUsingRemote>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<HistoryItem> <RemoteHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<HistoryItem> <CurrentHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteServerUrl>k__BackingField;
    public bool ResolveUsingRemote { get; public set; }
    public IList`1<HistoryItem> RemoteHistory { get; public set; }
    public IList`1<HistoryItem> CurrentHistory { get; public set; }
    public string FileName { get; public set; }
    public string RemoteServerUrl { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ResolveUsingRemote();
    [CompilerGeneratedAttribute]
public void set_ResolveUsingRemote(bool value);
    [CompilerGeneratedAttribute]
public IList`1<HistoryItem> get_RemoteHistory();
    [CompilerGeneratedAttribute]
public void set_RemoteHistory(IList`1<HistoryItem> value);
    [CompilerGeneratedAttribute]
public IList`1<HistoryItem> get_CurrentHistory();
    [CompilerGeneratedAttribute]
public void set_CurrentHistory(IList`1<HistoryItem> value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public string get_RemoteServerUrl();
    [CompilerGeneratedAttribute]
public void set_RemoteServerUrl(string value);
}
public enum Raven.Abstractions.FileSystem.ConflictResolutionStrategy : Enum {
    public int value__;
    public static ConflictResolutionStrategy NoResolution;
    public static ConflictResolutionStrategy RemoteVersion;
    public static ConflictResolutionStrategy CurrentVersion;
}
public class Raven.Abstractions.FileSystem.DestinationSyncResult : object {
    [CompilerGeneratedAttribute]
private string <DestinationServer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationFileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SynchronizationReport> <Reports>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string DestinationServer { get; public set; }
    public string DestinationFileSystem { get; public set; }
    public IEnumerable`1<SynchronizationReport> Reports { get; public set; }
    public Exception Exception { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DestinationServer();
    [CompilerGeneratedAttribute]
public void set_DestinationServer(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationFileSystem();
    [CompilerGeneratedAttribute]
public void set_DestinationFileSystem(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<SynchronizationReport> get_Reports();
    [CompilerGeneratedAttribute]
public void set_Reports(IEnumerable`1<SynchronizationReport> value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
}
public class Raven.Abstractions.FileSystem.FileHeader : object {
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <OriginalMetadata>k__BackingField;
    private Nullable`1<long> _totalSize;
    [CompilerGeneratedAttribute]
private long <UploadedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    public RavenJObject Metadata { get; public set; }
    public RavenJObject OriginalMetadata { get; public set; }
    public Nullable`1<long> TotalSize { get; public set; }
    public long UploadedSize { get; public set; }
    public DateTimeOffset LastModified { get; }
    public DateTimeOffset CreationDate { get; }
    public Etag Etag { get; }
    public string FullPath { get; public set; }
    public string Name { get; }
    public string Extension { get; }
    public string Directory { get; }
    public bool IsTombstone { get; }
    public string HumaneTotalSize { get; }
    public FileHeader(string key, RavenJObject metadata);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public RavenJObject get_OriginalMetadata();
    [CompilerGeneratedAttribute]
public void set_OriginalMetadata(RavenJObject value);
    public Nullable`1<long> get_TotalSize();
    public void set_TotalSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public long get_UploadedSize();
    [CompilerGeneratedAttribute]
public void set_UploadedSize(long value);
    public DateTimeOffset get_LastModified();
    public DateTimeOffset get_CreationDate();
    public Etag get_Etag();
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
public void set_FullPath(string value);
    public string get_Name();
    public string get_Extension();
    public string get_Directory();
    public bool get_IsTombstone();
    public void Refresh();
    private void SetFileSize();
    public string get_HumaneTotalSize();
    public static string Humane(Nullable`1<long> size);
    public bool IsFileBeingUploadedOrUploadHasBeenBroken();
    protected bool Equals(FileHeader other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static string Canonize(string name);
}
[FlagsAttribute]
public enum Raven.Abstractions.FileSystem.FilesSortOptions : Enum {
    public int value__;
    public static FilesSortOptions Default;
    public static FilesSortOptions Name;
    public static FilesSortOptions Size;
    public static FilesSortOptions LastModified;
    public static FilesSortOptions Desc;
}
public enum Raven.Abstractions.FileSystem.FileStatus : Enum {
    public int value__;
    public static FileStatus Unknown;
    public static FileStatus Safe;
    public static FileStatus Broken;
}
public class Raven.Abstractions.FileSystem.FileSystemDocument : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <SecuredSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    public string Id { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    public Dictionary`2<string, string> SecuredSettings { get; public set; }
    public bool Disabled { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_SecuredSettings();
    [CompilerGeneratedAttribute]
public void set_SecuredSettings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
}
public class Raven.Abstractions.FileSystem.FileSystemInfo : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public string Url { get; public set; }
    public Guid Id { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    public virtual string ToString();
    public string AsJson();
}
public class Raven.Abstractions.FileSystem.FileSystemMetrics : object {
    [CompilerGeneratedAttribute]
private double <FilesWritesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RequestsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <Requests>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramData <RequestsDuration>k__BackingField;
    public double FilesWritesPerSecond { get; public set; }
    public double RequestsPerSecond { get; public set; }
    public MeterData Requests { get; public set; }
    public HistogramData RequestsDuration { get; public set; }
    [CompilerGeneratedAttribute]
public double get_FilesWritesPerSecond();
    [CompilerGeneratedAttribute]
public void set_FilesWritesPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_RequestsPerSecond();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSecond(double value);
    [CompilerGeneratedAttribute]
public MeterData get_Requests();
    [CompilerGeneratedAttribute]
public void set_Requests(MeterData value);
    [CompilerGeneratedAttribute]
public HistogramData get_RequestsDuration();
    [CompilerGeneratedAttribute]
public void set_RequestsDuration(HistogramData value);
}
public class Raven.Abstractions.FileSystem.FileSystemNotification : object {
}
public class Raven.Abstractions.FileSystem.FileSystemStats : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <FileSystemId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileCount>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemMetrics <Metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SynchronizationDetails> <ActiveSyncs>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SynchronizationDetails> <PendingSyncs>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastFileEtag>k__BackingField;
    public string Name { get; public set; }
    public Guid FileSystemId { get; public set; }
    public string ServerUrl { get; public set; }
    public long FileCount { get; public set; }
    public FileSystemMetrics Metrics { get; public set; }
    public IList`1<SynchronizationDetails> ActiveSyncs { get; public set; }
    public IList`1<SynchronizationDetails> PendingSyncs { get; public set; }
    public Etag LastFileEtag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Guid get_FileSystemId();
    [CompilerGeneratedAttribute]
public void set_FileSystemId(Guid value);
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
public void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public long get_FileCount();
    [CompilerGeneratedAttribute]
public void set_FileCount(long value);
    [CompilerGeneratedAttribute]
public FileSystemMetrics get_Metrics();
    [CompilerGeneratedAttribute]
public void set_Metrics(FileSystemMetrics value);
    [CompilerGeneratedAttribute]
public IList`1<SynchronizationDetails> get_ActiveSyncs();
    [CompilerGeneratedAttribute]
public void set_ActiveSyncs(IList`1<SynchronizationDetails> value);
    [CompilerGeneratedAttribute]
public IList`1<SynchronizationDetails> get_PendingSyncs();
    [CompilerGeneratedAttribute]
public void set_PendingSyncs(IList`1<SynchronizationDetails> value);
    [CompilerGeneratedAttribute]
public Etag get_LastFileEtag();
    [CompilerGeneratedAttribute]
public void set_LastFileEtag(Etag value);
}
public class Raven.Abstractions.FileSystem.HistoryItem : object {
    [CompilerGeneratedAttribute]
private long <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerId>k__BackingField;
    public long Version { get; public set; }
    public string ServerId { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(long value);
    [CompilerGeneratedAttribute]
public string get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.FileSystem.ItemsPage`1 : object {
    [CompilerGeneratedAttribute]
private int <TotalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<T> <Items>k__BackingField;
    public int TotalCount { get; public set; }
    public IList`1<T> Items { get; public set; }
    public ItemsPage`1(IEnumerable`1<T> items, int total);
    [CompilerGeneratedAttribute]
public int get_TotalCount();
    [CompilerGeneratedAttribute]
public void set_TotalCount(int value);
    [CompilerGeneratedAttribute]
public IList`1<T> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<T> value);
}
public enum Raven.Abstractions.FileSystem.Notifications.ConfigurationChangeAction : Enum {
    public int value__;
    public static ConfigurationChangeAction Set;
    public static ConfigurationChangeAction Delete;
}
public class Raven.Abstractions.FileSystem.Notifications.ConfigurationChangeNotification : FileSystemNotification {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationChangeAction <Action>k__BackingField;
    public string Name { get; public set; }
    public ConfigurationChangeAction Action { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ConfigurationChangeAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(ConfigurationChangeAction value);
}
public class Raven.Abstractions.FileSystem.Notifications.ConflictNotification : FileSystemNotification {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private ConflictStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private FileHeader <RemoteFileHeader>k__BackingField;
    public string FileName { get; public set; }
    public string SourceServerUrl { get; public set; }
    public ConflictStatus Status { get; public set; }
    public FileHeader RemoteFileHeader { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public string get_SourceServerUrl();
    [CompilerGeneratedAttribute]
public void set_SourceServerUrl(string value);
    [CompilerGeneratedAttribute]
public ConflictStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(ConflictStatus value);
    [CompilerGeneratedAttribute]
public FileHeader get_RemoteFileHeader();
    [CompilerGeneratedAttribute]
public void set_RemoteFileHeader(FileHeader value);
}
public enum Raven.Abstractions.FileSystem.Notifications.ConflictStatus : Enum {
    public int value__;
    public static ConflictStatus Detected;
    public static ConflictStatus Resolved;
}
public enum Raven.Abstractions.FileSystem.Notifications.FileChangeAction : Enum {
    public int value__;
    public static FileChangeAction Add;
    public static FileChangeAction Delete;
    public static FileChangeAction Update;
    public static FileChangeAction Renaming;
    public static FileChangeAction Renamed;
}
public class Raven.Abstractions.FileSystem.Notifications.FileChangeNotification : FileSystemNotification {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private FileChangeAction <Action>k__BackingField;
    public string File { get; public set; }
    public FileChangeAction Action { get; public set; }
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public FileChangeAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(FileChangeAction value);
}
public enum Raven.Abstractions.FileSystem.Notifications.SynchronizationAction : Enum {
    public int value__;
    public static SynchronizationAction Enqueue;
    public static SynchronizationAction Start;
    public static SynchronizationAction Finish;
}
public enum Raven.Abstractions.FileSystem.Notifications.SynchronizationDirection : Enum {
    public int value__;
    public static SynchronizationDirection Outgoing;
    public static SynchronizationDirection Incoming;
}
public class Raven.Abstractions.FileSystem.Notifications.SynchronizationUpdateNotification : FileSystemNotification {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationFileSystemUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SourceServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFileSystemUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizationAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizationDirection <Direction>k__BackingField;
    public string FileName { get; public set; }
    public string DestinationFileSystemUrl { get; public set; }
    public Guid SourceServerId { get; public set; }
    public string SourceFileSystemUrl { get; public set; }
    public SynchronizationType Type { get; public set; }
    public SynchronizationAction Action { get; public set; }
    public SynchronizationDirection Direction { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationFileSystemUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationFileSystemUrl(string value);
    [CompilerGeneratedAttribute]
public Guid get_SourceServerId();
    [CompilerGeneratedAttribute]
public void set_SourceServerId(Guid value);
    [CompilerGeneratedAttribute]
public string get_SourceFileSystemUrl();
    [CompilerGeneratedAttribute]
public void set_SourceFileSystemUrl(string value);
    [CompilerGeneratedAttribute]
public SynchronizationType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(SynchronizationType value);
    [CompilerGeneratedAttribute]
public SynchronizationAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(SynchronizationAction value);
    [CompilerGeneratedAttribute]
public SynchronizationDirection get_Direction();
    [CompilerGeneratedAttribute]
public void set_Direction(SynchronizationDirection value);
}
public class Raven.Abstractions.FileSystem.RdcStats : object {
    [CompilerGeneratedAttribute]
private int <CurrentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumCompatibleAppVersion>k__BackingField;
    public int CurrentVersion { get; public set; }
    public int MinimumCompatibleAppVersion { get; public set; }
    [CompilerGeneratedAttribute]
public int get_CurrentVersion();
    [CompilerGeneratedAttribute]
public void set_CurrentVersion(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumCompatibleAppVersion();
    [CompilerGeneratedAttribute]
public void set_MinimumCompatibleAppVersion(int value);
}
public class Raven.Abstractions.FileSystem.SearchResults : object {
    [CompilerGeneratedAttribute]
private List`1<FileHeader> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationMilliseconds>k__BackingField;
    public List`1<FileHeader> Files { get; public set; }
    public int FileCount { get; public set; }
    public int Start { get; public set; }
    public int PageSize { get; public set; }
    public long DurationMilliseconds { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<FileHeader> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(List`1<FileHeader> value);
    [CompilerGeneratedAttribute]
public int get_FileCount();
    [CompilerGeneratedAttribute]
public void set_FileCount(int value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_PageSize();
    [CompilerGeneratedAttribute]
public void set_PageSize(int value);
    [CompilerGeneratedAttribute]
public long get_DurationMilliseconds();
    [CompilerGeneratedAttribute]
public void set_DurationMilliseconds(long value);
}
public class Raven.Abstractions.FileSystem.Signature : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public string Name { get; public set; }
    public long Length { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(long value);
}
public class Raven.Abstractions.FileSystem.SignatureManifest : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Signature> <Signatures>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileLength>k__BackingField;
    public string FileName { get; public set; }
    public IList`1<Signature> Signatures { get; public set; }
    public long FileLength { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public IList`1<Signature> get_Signatures();
    [CompilerGeneratedAttribute]
public void set_Signatures(IList`1<Signature> value);
    [CompilerGeneratedAttribute]
public long get_FileLength();
    [CompilerGeneratedAttribute]
public void set_FileLength(long value);
}
public class Raven.Abstractions.FileSystem.SourceSynchronizationInformation : object {
    [CompilerGeneratedAttribute]
private Etag <LastSourceFileEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <DestinationServerId>k__BackingField;
    public Etag LastSourceFileEtag { get; public set; }
    public string SourceServerUrl { get; public set; }
    public Guid DestinationServerId { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_LastSourceFileEtag();
    [CompilerGeneratedAttribute]
public void set_LastSourceFileEtag(Etag value);
    [CompilerGeneratedAttribute]
public string get_SourceServerUrl();
    [CompilerGeneratedAttribute]
public void set_SourceServerUrl(string value);
    [CompilerGeneratedAttribute]
public Guid get_DestinationServerId();
    [CompilerGeneratedAttribute]
public void set_DestinationServerId(Guid value);
    public virtual string ToString();
}
public class Raven.Abstractions.FileSystem.SynchronizationConfig : object {
    [CompilerGeneratedAttribute]
private StraightforwardConflictResolution <FileConflictResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfSynchronizationsPerDestination>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SynchronizationLockTimeoutMiliseconds>k__BackingField;
    public StraightforwardConflictResolution FileConflictResolution { get; public set; }
    public int MaxNumberOfSynchronizationsPerDestination { get; public set; }
    public int SynchronizationLockTimeoutMiliseconds { get; public set; }
    [CompilerGeneratedAttribute]
public StraightforwardConflictResolution get_FileConflictResolution();
    [CompilerGeneratedAttribute]
public void set_FileConflictResolution(StraightforwardConflictResolution value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfSynchronizationsPerDestination();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfSynchronizationsPerDestination(int value);
    [CompilerGeneratedAttribute]
public int get_SynchronizationLockTimeoutMiliseconds();
    [CompilerGeneratedAttribute]
public void set_SynchronizationLockTimeoutMiliseconds(int value);
}
public class Raven.Abstractions.FileSystem.SynchronizationConfirmation : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private FileStatus <Status>k__BackingField;
    public string FileName { get; public set; }
    public FileStatus Status { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public FileStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(FileStatus value);
}
public static class Raven.Abstractions.FileSystem.SynchronizationConstants : object {
    public static string RavenSynchronizationSource;
    public static string RavenSynchronizationVersion;
    public static string RavenSynchronizationHistory;
    public static string RavenSynchronizationVersionHiLo;
    public static string RavenSynchronizationConflict;
    public static string RavenSynchronizationConflictResolution;
    public static string RavenSynchronizationSourcesBasePath;
    public static string RavenSynchronizationDestinations;
    public static string RavenSynchronizationDestinationsBasePath;
    public static string RavenDeleteMarker;
    public static string RavenRenameFile;
    public static int ChangeHistoryLength;
    public static string RavenSynchronizationConfig;
}
public class Raven.Abstractions.FileSystem.SynchronizationDestination : object {
    private string serverUrl;
    [CompilerGeneratedAttribute]
private string <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthenticationScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    public string ServerUrl { get; public set; }
    public string FileSystem { get; public set; }
    public string Url { get; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string Domain { get; public set; }
    public string ApiKey { get; public set; }
    public string AuthenticationScheme { get; public set; }
    public bool Enabled { get; public set; }
    [JsonIgnoreAttribute]
public ICredentials Credentials { get; }
    public string get_ServerUrl();
    public void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_FileSystem();
    [CompilerGeneratedAttribute]
public void set_FileSystem(string value);
    public string get_Url();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public string get_AuthenticationScheme();
    [CompilerGeneratedAttribute]
public void set_AuthenticationScheme(string value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    public ICredentials get_Credentials();
    protected bool Equals(SynchronizationDestination other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Raven.Abstractions.FileSystem.SynchronizationDestinationsConfig : object {
    [CompilerGeneratedAttribute]
private List`1<SynchronizationDestination> <Destinations>k__BackingField;
    public List`1<SynchronizationDestination> Destinations { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<SynchronizationDestination> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(List`1<SynchronizationDestination> value);
}
public class Raven.Abstractions.FileSystem.SynchronizationDetails : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <FileETag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizationType <Type>k__BackingField;
    public string FileName { get; public set; }
    public Etag FileETag { get; public set; }
    public string DestinationUrl { get; public set; }
    public SynchronizationType Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public Etag get_FileETag();
    [CompilerGeneratedAttribute]
public void set_FileETag(Etag value);
    [CompilerGeneratedAttribute]
public string get_DestinationUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationUrl(string value);
    [CompilerGeneratedAttribute]
public SynchronizationType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(SynchronizationType value);
}
public class Raven.Abstractions.FileSystem.SynchronizationException : Exception {
    public SynchronizationException(string message);
    public SynchronizationException(string message, Exception inner);
    protected SynchronizationException(SerializationInfo info, StreamingContext context);
}
public class Raven.Abstractions.FileSystem.SynchronizationReport : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <FileETag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesTransfered>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesCopied>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NeedListLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizationType <Type>k__BackingField;
    public string FileName { get; private set; }
    public Etag FileETag { get; private set; }
    public long BytesTransfered { get; public set; }
    public long BytesCopied { get; public set; }
    public long NeedListLength { get; public set; }
    public Exception Exception { get; public set; }
    public SynchronizationType Type { get; private set; }
    [JsonConstructorAttribute]
public SynchronizationReport(string fileName, Guid fileETag, SynchronizationType type);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
public Etag get_FileETag();
    [CompilerGeneratedAttribute]
private void set_FileETag(Etag value);
    [CompilerGeneratedAttribute]
public long get_BytesTransfered();
    [CompilerGeneratedAttribute]
public void set_BytesTransfered(long value);
    [CompilerGeneratedAttribute]
public long get_BytesCopied();
    [CompilerGeneratedAttribute]
public void set_BytesCopied(long value);
    [CompilerGeneratedAttribute]
public long get_NeedListLength();
    [CompilerGeneratedAttribute]
public void set_NeedListLength(long value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public SynchronizationType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(SynchronizationType value);
}
public enum Raven.Abstractions.FileSystem.SynchronizationType : Enum {
    public int value__;
    public static SynchronizationType Unknown;
    public static SynchronizationType ContentUpdate;
    public static SynchronizationType MetadataUpdate;
    public static SynchronizationType Rename;
    public static SynchronizationType Delete;
    public static SynchronizationType ContentUpdateNoRDC;
}
public static class Raven.Abstractions.FileSystem.SyncingMultipartConstants : object {
    public static string NeedType;
    public static string RangeFrom;
    public static string RangeTo;
    public static string FileName;
    public static string SourceFileSystemInfo;
    private static SyncingMultipartConstants();
}
public class Raven.Abstractions.FileSystem.TouchFilesResult : object {
    [CompilerGeneratedAttribute]
private long <NumberOfProcessedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastProcessedFileEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfFilteredFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastEtagAfterTouch>k__BackingField;
    public long NumberOfProcessedFiles { get; public set; }
    public Etag LastProcessedFileEtag { get; public set; }
    public long NumberOfFilteredFiles { get; public set; }
    public Etag LastEtagAfterTouch { get; public set; }
    [CompilerGeneratedAttribute]
public long get_NumberOfProcessedFiles();
    [CompilerGeneratedAttribute]
public void set_NumberOfProcessedFiles(long value);
    [CompilerGeneratedAttribute]
public Etag get_LastProcessedFileEtag();
    [CompilerGeneratedAttribute]
public void set_LastProcessedFileEtag(Etag value);
    [CompilerGeneratedAttribute]
public long get_NumberOfFilteredFiles();
    [CompilerGeneratedAttribute]
public void set_NumberOfFilteredFiles(long value);
    [CompilerGeneratedAttribute]
public Etag get_LastEtagAfterTouch();
    [CompilerGeneratedAttribute]
public void set_LastEtagAfterTouch(Etag value);
}
public class Raven.Abstractions.Indexing.CartesianSpatialOptionsFactory : object {
    public SpatialOptions BoundingBoxIndex();
    public SpatialOptions QuadPrefixTreeIndex(int maxTreeLevel, SpatialBounds bounds);
}
public enum Raven.Abstractions.Indexing.FieldIndexing : Enum {
    public int value__;
    public static FieldIndexing No;
    public static FieldIndexing Analyzed;
    public static FieldIndexing NotAnalyzed;
    public static FieldIndexing Default;
}
public enum Raven.Abstractions.Indexing.FieldStorage : Enum {
    public int value__;
    public static FieldStorage Yes;
    public static FieldStorage No;
}
public enum Raven.Abstractions.Indexing.FieldTermVector : Enum {
    public int value__;
    public static FieldTermVector No;
    public static FieldTermVector Yes;
    public static FieldTermVector WithPositions;
    public static FieldTermVector WithOffsets;
    public static FieldTermVector WithPositionsAndOffsets;
}
public class Raven.Abstractions.Indexing.GeographySpatialOptionsFactory : object {
    public SpatialOptions Default(SpatialUnits circleRadiusUnits);
    public SpatialOptions BoundingBoxIndex(SpatialUnits circleRadiusUnits);
    public SpatialOptions GeohashPrefixTreeIndex(int maxTreeLevel, SpatialUnits circleRadiusUnits);
    public SpatialOptions QuadPrefixTreeIndex(int maxTreeLevel, SpatialUnits circleRadiusUnits);
}
public class Raven.Abstractions.Indexing.IndexDefinition : object {
    [CompilerGeneratedAttribute]
private int <IndexId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexLockMode <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <IndexVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reduce>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompiled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxIndexOutputsPerDocument>k__BackingField;
    [JsonIgnoreAttribute]
private Byte[] cachedHashCodeAsBytes;
    [JsonIgnoreAttribute]
private HashSet`1<string> maps;
    [JsonIgnoreAttribute]
private IDictionary`2<string, FieldStorage> stores;
    [JsonIgnoreAttribute]
private IDictionary`2<string, FieldIndexing> indexes;
    [JsonIgnoreAttribute]
private IDictionary`2<string, SortOptions> sortOptions;
    [JsonIgnoreAttribute]
private IDictionary`2<string, string> analyzers;
    [JsonIgnoreAttribute]
private IList`1<string> fields;
    [JsonIgnoreAttribute]
private IDictionary`2<string, FieldTermVector> termVectors;
    [JsonIgnoreAttribute]
private IDictionary`2<string, SpatialOptions> spatialIndexes;
    [JsonIgnoreAttribute]
private IDictionary`2<string, string> internalFieldsMapping;
    [JsonIgnoreAttribute]
private ISet`1<string> suggestionsOptions;
    [CompilerGeneratedAttribute]
private bool <DisableInMemoryIndexing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTestIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSideBySideIndex>k__BackingField;
    public int IndexId { get; public set; }
    public string Name { get; public set; }
    public IndexLockMode LockMode { get; public set; }
    public Nullable`1<int> IndexVersion { get; public set; }
    public string Map { get; public set; }
    public HashSet`1<string> Maps { get; public set; }
    public string Reduce { get; public set; }
    public bool IsMapReduce { get; }
    public bool IsCompiled { get; public set; }
    public IDictionary`2<string, FieldStorage> Stores { get; public set; }
    public IDictionary`2<string, FieldIndexing> Indexes { get; public set; }
    public IDictionary`2<string, SortOptions> SortOptions { get; public set; }
    public IDictionary`2<string, string> Analyzers { get; public set; }
    public IList`1<string> Fields { get; public set; }
    [ObsoleteAttribute("Use SuggestionsOptions")]
public IReadOnlyDictionary`2<string, SuggestionOptions> Suggestions { get; public set; }
    public ISet`1<string> SuggestionsOptions { get; public set; }
    public IDictionary`2<string, FieldTermVector> TermVectors { get; public set; }
    public IDictionary`2<string, SpatialOptions> SpatialIndexes { get; public set; }
    public IDictionary`2<string, string> InternalFieldsMapping { get; public set; }
    public Nullable`1<int> MaxIndexOutputsPerDocument { get; public set; }
    public string Type { get; }
    public bool DisableInMemoryIndexing { get; public set; }
    public bool IsTestIndex { get; public set; }
    public bool IsSideBySideIndex { get; public set; }
    [CompilerGeneratedAttribute]
public int get_IndexId();
    [CompilerGeneratedAttribute]
public void set_IndexId(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IndexLockMode get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(IndexLockMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_IndexVersion();
    [CompilerGeneratedAttribute]
public void set_IndexVersion(Nullable`1<int> value);
    public string get_Map();
    public void set_Map(string value);
    public HashSet`1<string> get_Maps();
    public void set_Maps(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Reduce();
    [CompilerGeneratedAttribute]
public void set_Reduce(string value);
    public bool get_IsMapReduce();
    [CompilerGeneratedAttribute]
public bool get_IsCompiled();
    [CompilerGeneratedAttribute]
public void set_IsCompiled(bool value);
    public IDictionary`2<string, FieldStorage> get_Stores();
    public void set_Stores(IDictionary`2<string, FieldStorage> value);
    public IDictionary`2<string, FieldIndexing> get_Indexes();
    public void set_Indexes(IDictionary`2<string, FieldIndexing> value);
    public IDictionary`2<string, SortOptions> get_SortOptions();
    public void set_SortOptions(IDictionary`2<string, SortOptions> value);
    public IDictionary`2<string, string> get_Analyzers();
    public void set_Analyzers(IDictionary`2<string, string> value);
    public IList`1<string> get_Fields();
    public void set_Fields(IList`1<string> value);
    public IReadOnlyDictionary`2<string, SuggestionOptions> get_Suggestions();
    public void set_Suggestions(IReadOnlyDictionary`2<string, SuggestionOptions> value);
    public ISet`1<string> get_SuggestionsOptions();
    public void set_SuggestionsOptions(ISet`1<string> value);
    public IDictionary`2<string, FieldTermVector> get_TermVectors();
    public void set_TermVectors(IDictionary`2<string, FieldTermVector> value);
    public IDictionary`2<string, SpatialOptions> get_SpatialIndexes();
    public void set_SpatialIndexes(IDictionary`2<string, SpatialOptions> value);
    public IDictionary`2<string, string> get_InternalFieldsMapping();
    public void set_InternalFieldsMapping(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxIndexOutputsPerDocument();
    [CompilerGeneratedAttribute]
public void set_MaxIndexOutputsPerDocument(Nullable`1<int> value);
    public bool Equals(IndexDefinition other, bool compareIndexIds, bool ignoreFormatting, bool ignoreMaxIndexOutput);
    private static int DictionaryHashCode(IEnumerable`1<KeyValuePair`2<TKey, TValue>> x);
    private static int SetHashCode(IEnumerable`1<TKey> x);
    public virtual bool Equals(object obj);
    public Byte[] GetIndexHash();
    public virtual int GetHashCode();
    public string get_Type();
    [CompilerGeneratedAttribute]
public bool get_DisableInMemoryIndexing();
    [CompilerGeneratedAttribute]
public void set_DisableInMemoryIndexing(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsTestIndex();
    [CompilerGeneratedAttribute]
public void set_IsTestIndex(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSideBySideIndex();
    [CompilerGeneratedAttribute]
public void set_IsSideBySideIndex(bool value);
    public void RemoveDefaultValues();
    public virtual string ToString();
}
public enum Raven.Abstractions.Indexing.IndexLockMode : Enum {
    public int value__;
    public static IndexLockMode Unlock;
    public static IndexLockMode LockedIgnore;
    public static IndexLockMode LockedError;
    public static IndexLockMode SideBySide;
}
public class Raven.Abstractions.Indexing.IndexMergeResults : object {
    public Dictionary`2<string, string> Unmergables;
    public List`1<MergeSuggestions> Suggestions;
}
public class Raven.Abstractions.Indexing.IndexReplaceDocument : object {
    [CompilerGeneratedAttribute]
private string <IndexToReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <MinimumEtagBeforeReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ReplaceTimeUtc>k__BackingField;
    public string IndexToReplace { get; public set; }
    public Etag MinimumEtagBeforeReplace { get; public set; }
    public Nullable`1<DateTime> ReplaceTimeUtc { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IndexToReplace();
    [CompilerGeneratedAttribute]
public void set_IndexToReplace(string value);
    [CompilerGeneratedAttribute]
public Etag get_MinimumEtagBeforeReplace();
    [CompilerGeneratedAttribute]
public void set_MinimumEtagBeforeReplace(Etag value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ReplaceTimeUtc();
    [CompilerGeneratedAttribute]
public void set_ReplaceTimeUtc(Nullable`1<DateTime> value);
}
public class Raven.Abstractions.Indexing.MergeSuggestions : object {
    public IndexDefinition MergedIndex;
    public List`1<string> CanMerge;
    public string Collection;
    public List`1<string> CanDelete;
    public string SurpassingIndex;
}
public class Raven.Abstractions.Indexing.NumberUtil : object {
    public static string NumberToString(int number);
    public static string NumberToString(long number);
    public static string NumberToString(float number);
    public static string NumberToString(double number);
    public static object StringToNumber(string number);
}
public enum Raven.Abstractions.Indexing.SortOptions : Enum {
    public int value__;
    public static SortOptions None;
    public static SortOptions String;
    public static SortOptions Int;
    public static SortOptions Float;
    public static SortOptions Long;
    public static SortOptions Double;
    public static SortOptions Short;
    public static SortOptions Custom;
    public static SortOptions Byte;
    public static SortOptions StringVal;
}
public class Raven.Abstractions.Indexing.SpatialBounds : object {
    [CompilerGeneratedAttribute]
private double <MinX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinY>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxY>k__BackingField;
    public double MinX { get; private set; }
    public double MaxX { get; private set; }
    public double MinY { get; private set; }
    public double MaxY { get; private set; }
    public SpatialBounds(double minX, double minY, double maxX, double maxY);
    [CompilerGeneratedAttribute]
public double get_MinX();
    [CompilerGeneratedAttribute]
private void set_MinX(double value);
    [CompilerGeneratedAttribute]
public double get_MaxX();
    [CompilerGeneratedAttribute]
private void set_MaxX(double value);
    [CompilerGeneratedAttribute]
public double get_MinY();
    [CompilerGeneratedAttribute]
private void set_MinY(double value);
    [CompilerGeneratedAttribute]
public double get_MaxY();
    [CompilerGeneratedAttribute]
private void set_MaxY(double value);
    protected bool Equals(SpatialBounds other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Raven.Abstractions.Indexing.SpatialFieldType : Enum {
    public int value__;
    public static SpatialFieldType Geography;
    public static SpatialFieldType Cartesian;
}
public class Raven.Abstractions.Indexing.SpatialOptions : object {
    public static int DefaultGeohashLevel;
    public static int DefaultQuadTreeLevel;
    [CompilerGeneratedAttribute]
private SpatialFieldType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SpatialSearchStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTreeLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinY>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxY>k__BackingField;
    [CompilerGeneratedAttribute]
private SpatialUnits <Units>k__BackingField;
    public SpatialFieldType Type { get; public set; }
    public SpatialSearchStrategy Strategy { get; public set; }
    public int MaxTreeLevel { get; public set; }
    public double MinX { get; public set; }
    public double MaxX { get; public set; }
    public double MinY { get; public set; }
    public double MaxY { get; public set; }
    public SpatialUnits Units { get; public set; }
    [CompilerGeneratedAttribute]
public SpatialFieldType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(SpatialFieldType value);
    [CompilerGeneratedAttribute]
public SpatialSearchStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(SpatialSearchStrategy value);
    [CompilerGeneratedAttribute]
public int get_MaxTreeLevel();
    [CompilerGeneratedAttribute]
public void set_MaxTreeLevel(int value);
    [CompilerGeneratedAttribute]
public double get_MinX();
    [CompilerGeneratedAttribute]
public void set_MinX(double value);
    [CompilerGeneratedAttribute]
public double get_MaxX();
    [CompilerGeneratedAttribute]
public void set_MaxX(double value);
    [CompilerGeneratedAttribute]
public double get_MinY();
    [CompilerGeneratedAttribute]
public void set_MinY(double value);
    [CompilerGeneratedAttribute]
public double get_MaxY();
    [CompilerGeneratedAttribute]
public void set_MaxY(double value);
    [CompilerGeneratedAttribute]
public SpatialUnits get_Units();
    [CompilerGeneratedAttribute]
public void set_Units(SpatialUnits value);
    protected bool Equals(SpatialOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.Indexing.SpatialOptionsFactory : object {
    public GeographySpatialOptionsFactory Geography { get; }
    public CartesianSpatialOptionsFactory Cartesian { get; }
    public GeographySpatialOptionsFactory get_Geography();
    public CartesianSpatialOptionsFactory get_Cartesian();
    public static SpatialOptions FromLegacy(SpatialSearchStrategy spatialSearchStrategy, int maxTreeLevel);
}
public enum Raven.Abstractions.Indexing.SpatialRelation : Enum {
    public int value__;
    public static SpatialRelation Within;
    public static SpatialRelation Contains;
    public static SpatialRelation Disjoint;
    public static SpatialRelation Intersects;
    public static SpatialRelation Nearby;
}
public enum Raven.Abstractions.Indexing.SpatialSearchStrategy : Enum {
    public int value__;
    public static SpatialSearchStrategy GeohashPrefixTree;
    public static SpatialSearchStrategy QuadPrefixTree;
    public static SpatialSearchStrategy BoundingBox;
}
public class Raven.Abstractions.Indexing.SpatialSort : object {
    public string FieldName;
    public double Longitude;
    public double Latitude;
}
public enum Raven.Abstractions.Indexing.SpatialUnits : Enum {
    public int value__;
    public static SpatialUnits Kilometers;
    public static SpatialUnits Miles;
}
public class Raven.Abstractions.Indexing.SuggestionOptions : object {
    [CompilerGeneratedAttribute]
private StringDistanceTypes <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Accuracy>k__BackingField;
    public StringDistanceTypes Distance { get; public set; }
    public float Accuracy { get; public set; }
    [CompilerGeneratedAttribute]
public StringDistanceTypes get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(StringDistanceTypes value);
    [CompilerGeneratedAttribute]
public float get_Accuracy();
    [CompilerGeneratedAttribute]
public void set_Accuracy(float value);
    protected bool Equals(SuggestionOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.Indexing.TransformerDefinition : object {
    [CompilerGeneratedAttribute]
private string <TransformResults>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransfomerId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Temporary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TransformerLockMode <LockMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <TransformerVersion>k__BackingField;
    public string TransformResults { get; public set; }
    public int TransfomerId { get; public set; }
    public bool Temporary { get; public set; }
    public string Name { get; public set; }
    public TransformerLockMode LockMode { get; public set; }
    public Nullable`1<int> TransformerVersion { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TransformResults();
    [CompilerGeneratedAttribute]
public void set_TransformResults(string value);
    [CompilerGeneratedAttribute]
public int get_TransfomerId();
    [CompilerGeneratedAttribute]
public void set_TransfomerId(int value);
    [CompilerGeneratedAttribute]
public bool get_Temporary();
    [CompilerGeneratedAttribute]
public void set_Temporary(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public TransformerLockMode get_LockMode();
    [CompilerGeneratedAttribute]
public void set_LockMode(TransformerLockMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_TransformerVersion();
    [CompilerGeneratedAttribute]
public void set_TransformerVersion(Nullable`1<int> value);
    public bool Equals(TransformerDefinition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public TransformerDefinition Clone();
    public virtual string ToString();
}
public enum Raven.Abstractions.Indexing.TransformerLockMode : Enum {
    public int value__;
    public static TransformerLockMode Unlock;
    public static TransformerLockMode LockedIgnore;
}
public class Raven.Abstractions.Json.ConflictsResolver : object {
    private RavenJObject[] docs;
    private bool isMetadataResolver;
    public ConflictsResolver(IEnumerable`1<RavenJObject> docs, bool isMetadataResolver);
    public MergeResult Resolve(int indent);
    private bool TryHandleArrayValue(int index, Dictionary`2<string, object> result, KeyValuePair`2<string, RavenJToken> prop);
    private bool TryHandleObjectValue(int index, Dictionary`2<string, object> result, KeyValuePair`2<string, RavenJToken> prop);
    private void HandleSimpleValues(Dictionary`2<string, object> result, KeyValuePair`2<string, RavenJToken> prop, int index);
    private void WriteToken(JsonTextWriter writer, string propertyName, object propertyValue);
    private void WriteRawData(JsonTextWriter writer, string data, int indent);
    private void WriteConflictResolver(string name, JsonTextWriter documentWriter, JsonTextWriter metadataWriter, ConflictsResolver resolver, int indent);
    private MergeResult GenerateOutput(Dictionary`2<string, object> result, int indent);
}
public static class Raven.Abstractions.Json.DynamicUtil : object {
    private static ConcurrentDictionary`2<string, CallSite`1<Func`3<CallSite, object, object>>> callsitesCache;
    private static DynamicUtil();
    public static object GetValueDynamically(object entity, string dynamicMemberName);
}
public static class Raven.Abstractions.Json.JsonConverterCache : object {
    private static CompoundKeyEqualityComparer Comparer;
    [ThreadStaticAttribute]
private static Dictionary`2<CompoundKey, JsonConverter> _cache;
    private static Dictionary`2<CompoundKey, JsonConverter> Cache { get; }
    private static JsonConverterCache();
    private static Dictionary`2<CompoundKey, JsonConverter> get_Cache();
    public static JsonConverter GetMatchingConverter(JsonConverterCollection converters, Type type);
}
public class Raven.Abstractions.Json.JsonDateTimeISO8601Converter : RavenJsonConverter {
    public static JsonDateTimeISO8601Converter Instance;
    private static JsonDateTimeISO8601Converter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Abstractions.Json.JsonDateTimeOffsetConverter : RavenJsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Abstractions.Json.JsonDictionaryDateTimeKeysConverter : RavenJsonConverter {
    private MethodInfo genericWriteJsonMethodInfo;
    private MethodInfo genericReadJsonMethodInfo;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public void GenericWriteJson(JsonWriter writer, Dictionary`2<TKey, TValue> value, JsonSerializer serializer);
    public Dictionary`2<TKey, TValue> GenericReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Abstractions.Json.JsonDynamicConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Abstractions.Json.JsonEnumConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Abstractions.Json.JsonLinqEnumerableConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Abstractions.Json.JsonMultiDimensionalArrayConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private List`1<object> ReadRank(JsonReader reader, JsonSerializer serializer, Type elementType);
    private List`1<int> GetRankLengthList(List`1<object> arrayList);
    private void SetValues(Array multiDimensionalArray, Int32[] rankLengthList, Int32[] assignToIndexList, int currentRank, List`1<object> newValues);
    private void WriteRank(JsonWriter writer, JsonSerializer serializer, Array array, int currentRank, Int32[] assignFromIndexList);
}
public class Raven.Abstractions.Json.JsonNumericConverter`1 : JsonConverter {
    private TryParse<T> tryParse;
    public bool CanWrite { get; }
    public JsonNumericConverter`1(TryParse<T> tryParse);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
public class Raven.Abstractions.Json.JsonToJsonConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Json.JTokenExtensions : object {
    private static void BuildPathPart(PathPart pathPart, int pos, String[] pathParts, string final);
    [ExtensionAttribute]
public static RavenJObject SelectTokenWithRavenSyntax(RavenJToken self, String[] paths);
    [ExtensionAttribute]
public static RavenJToken SelectTokenWithRavenSyntaxReturningSingleValue(RavenJToken self, string path);
    [IteratorStateMachineAttribute("Raven.Abstractions.Json.JTokenExtensions/<SelectTokenWithRavenSyntaxReturningFlatStructure>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<Tuple`2<RavenJToken, RavenJToken>> SelectTokenWithRavenSyntaxReturningFlatStructure(RavenJToken self, string path, bool createSnapshots);
}
public class Raven.Abstractions.Json.Linq.RavenJTokenEqualityComparer : object {
    public static RavenJTokenEqualityComparer Default;
    private static RavenJTokenEqualityComparer();
    public bool Equals(RavenJToken x, RavenJToken y, List`1<DocumentsChanges> difference);
    public sealed virtual bool Equals(RavenJToken x, RavenJToken y);
    public sealed virtual int GetHashCode(RavenJToken obj);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
public abstract class Raven.Abstractions.Json.RavenJsonConverter : JsonConverter {
    protected object DeferReadToNextConverter(JsonReader reader, Type objectType, JsonSerializer serializer, object existingValue);
}
public class Raven.Abstractions.Json.RavenJsonTextReader : JsonTextReader {
    public RavenJsonTextReader(TextReader reader);
    public RavenJsonTextReader(Char[] externalBuffer);
    public static DateTime ParseDateMicrosoft(string text);
}
public class Raven.Abstractions.Json.StreamFromJsonConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Abstractions.Linq.DateTools : object {
    private static string YEAR_FORMAT;
    private static string MONTH_FORMAT;
    private static string DAY_FORMAT;
    private static string HOUR_FORMAT;
    private static string MINUTE_FORMAT;
    private static string SECOND_FORMAT;
    private static string MILLISECOND_FORMAT;
    private static DateTools();
    public static string DateToString(DateTime date, Resolution resolution);
    public static string TimeToString(long time, Resolution resolution);
    public static long StringToTime(string dateString);
    public static DateTime StringToDate(string dateString);
    public static DateTime Round(DateTime date, Resolution resolution);
    public static long Round(long time, Resolution resolution);
}
[JsonObjectAttribute]
public class Raven.Abstractions.Linq.DynamicJsonObject : DynamicObject {
    private DynamicJsonObject parent;
    private RavenJObject inner;
    private RavenJObject Raven.Abstractions.Linq.IDynamicJsonObject.Inner { get; }
    public DynamicJsonObject(RavenJObject inner);
    internal DynamicJsonObject(DynamicJsonObject parent, RavenJObject inner);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public object TransformToValue(RavenJToken jToken);
    private RavenJObject FindReference(string refId);
    public DynamicJsonObject GetRootParentOrSelf();
    [IteratorStateMachineAttribute("Raven.Abstractions.Linq.DynamicJsonObject/<Scan>d__15")]
private IEnumerable`1<RavenJObject> Scan();
    public IEnumerable`1<object> OrderBy(Func`2<object, object> func);
    public IEnumerable`1<object> OrderByDescending(Func`2<object, object> func);
    public object FirstOrDefault(Func`2<object, bool> func);
    public object First(Func`2<object, bool> func);
    public object LastOrDefault(Func`2<object, bool> func);
    public object Last(Func`2<object, bool> func);
    public IEnumerable`1<object> Select(Func`2<object, object> func);
    public IEnumerable`1<object> SelectMany(Func`2<object, IEnumerable`1<object>> func);
    public virtual object GetValue(string name);
    public object GetDocumentId();
    private sealed virtual override RavenJObject Raven.Abstractions.Linq.IDynamicJsonObject.get_Inner();
    public virtual void WriteTo(JsonWriter writer);
    [CompilerGeneratedAttribute]
private KeyValuePair`2<object, object> <GetEnumerator>b__1_1(KeyValuePair`2<string, RavenJToken> item);
}
[DefaultMemberAttribute("Item")]
public class Raven.Abstractions.Linq.DynamicList : DynamicObject {
    private DynamicJsonObject parent;
    private IEnumerable`1<object> inner;
    public object Item { get; }
    public int Count { get; }
    public int Length { get; }
    public DynamicList(IEnumerable inner);
    public DynamicList(IEnumerable`1<object> inner);
    internal DynamicList(DynamicJsonObject parent, IEnumerable`1<object> inner);
    public object Get(Int32[] indexes);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    [IteratorStateMachineAttribute("Raven.Abstractions.Linq.DynamicList/<Enumerate>d__8")]
private IEnumerable`1<object> Enumerate();
    public object First();
    public object First(Func`2<object, bool> predicate);
    public object Any(Func`2<object, bool> predicate);
    public object All(Func`2<object, bool> predicate);
    public object FirstOrDefault(Func`2<object, bool> predicate);
    public object FirstOrDefault();
    public object Single(Func`2<object, bool> predicate);
    public IEnumerable`1<object> Distinct();
    public object SingleOrDefault(Func`2<object, bool> predicate);
    public object SingleOrDefault();
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void CopyTo(Array array, int index);
    public object get_Item(int index);
    public bool Contains(object item);
    public int get_Count();
    public int Sum(Func`2<object, int> selector);
    public Nullable`1<int> Sum(Func`2<object, Nullable`1<int>> selector);
    public long Sum(Func`2<object, long> selector);
    public Nullable`1<long> Sum(Func`2<object, Nullable`1<long>> selector);
    public float Sum(Func`2<object, float> selector);
    public Nullable`1<float> Sum(Func`2<object, Nullable`1<float>> selector);
    public double Sum(Func`2<object, double> selector);
    public Nullable`1<double> Sum(Func`2<object, Nullable`1<double>> selector);
    public decimal Sum(Func`2<object, decimal> selector);
    public Nullable`1<decimal> Sum(Func`2<object, Nullable`1<decimal>> selector);
    public object Min();
    public object Min(Func`2<object, TResult> selector);
    public object Max();
    public object Max(Func`2<object, TResult> selector);
    public double Average(Func`2<object, int> selector);
    public Nullable`1<double> Average(Func`2<object, Nullable`1<int>> selector);
    public double Average(Func`2<object, long> selector);
    public Nullable`1<double> Average(Func`2<object, Nullable`1<long>> selector);
    public float Average(Func`2<object, float> selector);
    public Nullable`1<float> Average(Func`2<object, Nullable`1<float>> selector);
    public double Average(Func`2<object, double> selector);
    public Nullable`1<double> Average(Func`2<object, Nullable`1<double>> selector);
    public decimal Average(Func`2<object, decimal> selector);
    public Nullable`1<decimal> Average(Func`2<object, Nullable`1<decimal>> selector);
    public IEnumerable`1<object> OrderBy(Func`2<object, object> comparable);
    public IEnumerable`1<object> OrderByDescending(Func`2<object, object> comparable);
    public object GroupBy(Func`2<object, object> keySelector);
    public object GroupBy(Func`2<object, object> keySelector, Func`2<object, object> selector);
    public object Last();
    public object LastOrDefault();
    public object Last(Func`2<object, bool> predicate);
    public object LastOrDefault(Func`2<object, bool> predicate);
    public object IndexOf(object item);
    public object IndexOf(object item, int index);
    public object IndexOf(object item, int index, int count);
    public object LastIndexOf(object item);
    public object LastIndexOf(object item, int index);
    public object LastIndexOf(object item, int index, int count);
    public IEnumerable`1<object> Take(int count);
    public IEnumerable`1<object> Skip(int count);
    public int get_Length();
    public IEnumerable`1<object> Select(Func`2<object, object> func);
    public IEnumerable`1<object> Select(Func`2<IGrouping`2<object, object>, object> func);
    public IEnumerable`1<object> Select(Func`3<object, int, object> func);
    public IEnumerable`1<object> SelectMany(Func`2<object, IEnumerable`1<object>> func);
    public IEnumerable`1<object> SelectMany(Func`2<object, IEnumerable`1<object>> func, Func`3<object, object, object> selector);
    public IEnumerable`1<object> SelectMany(Func`3<object, int, IEnumerable`1<object>> func);
    public IEnumerable`1<object> Where(Func`2<object, bool> func);
    public IEnumerable`1<object> Where(Func`3<object, int, bool> func);
    public object DefaultIfEmpty(object defaultValue);
    public IEnumerable`1<object> Except(IEnumerable`1<object> except);
    public IEnumerable`1<object> Reverse();
    public bool SequenceEqual(IEnumerable`1<object> second);
    public IEnumerable`1<object> AsEnumerable();
    public Object[] ToArray();
    public List`1<object> ToList();
    public Dictionary`2<TKey, object> ToDictionary(Func`2<object, TKey> keySelector, Func`2<object, object> elementSelector);
    public ILookup`2<TKey, object> ToLookup(Func`2<object, TKey> keySelector, Func`2<object, object> elementSelector);
    public IEnumerable`1<object> OfType();
    public IEnumerable`1<object> Cast();
    public object ElementAt(int index);
    public object ElementAtOrDefault(int index);
    public long LongCount();
    public object Aggregate(Func`3<object, object, object> func);
    public object Aggregate(object seed, Func`3<object, object, object> func);
    public object Aggregate(object seed, Func`3<object, object, object> func, Func`2<object, object> resultSelector);
    public IEnumerable`1<object> TakeWhile(Func`2<object, bool> predicate);
    public IEnumerable`1<object> TakeWhile(Func`3<object, int, bool> predicate);
    public IEnumerable`1<object> SkipWhile(Func`2<object, bool> predicate);
    public IEnumerable`1<object> SkipWhile(Func`3<object, int, bool> predicate);
    public IEnumerable`1<object> Join(IEnumerable`1<object> items, Func`2<object, object> outerKeySelector, Func`2<object, object> innerKeySelector, Func`3<object, object, object> resultSelector);
    public IEnumerable`1<object> GroupJoin(IEnumerable`1<object> items, Func`2<object, object> outerKeySelector, Func`2<object, object> innerKeySelector, Func`3<object, object, object> resultSelector);
    public IEnumerable`1<object> Concat(IEnumerable second);
    public IEnumerable`1<object> Zip(IEnumerable second, Func`3<object, object, object> resultSelector);
    public IEnumerable`1<object> Union(IEnumerable second);
    public IEnumerable`1<object> Intersect(IEnumerable second);
}
public class Raven.Abstractions.Linq.DynamicNullObject : DynamicObject {
    [CompilerGeneratedAttribute]
private bool <IsExplicitNull>k__BackingField;
    public bool IsExplicitNull { get; public set; }
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public bool get_IsExplicitNull();
    [CompilerGeneratedAttribute]
public void set_IsExplicitNull(bool value);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    [IteratorStateMachineAttribute("Raven.Abstractions.Linq.DynamicNullObject/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static bool op_True(DynamicNullObject left);
    public static bool op_False(DynamicNullObject left);
    public static object op_OnesComplement(DynamicNullObject left);
    public static object op_LogicalNot(DynamicNullObject left);
    public static object op_ExclusiveOr(DynamicNullObject left, object right);
    public static object op_BitwiseAnd(DynamicNullObject left, object right);
    public static object op_BitwiseOr(DynamicNullObject left, object right);
    public static DynamicNullObject op_Increment(DynamicNullObject left);
    public static DynamicNullObject op_Decrement(DynamicNullObject left);
    public static object op_Addition(DynamicNullObject left, object right);
    public static object op_Subtraction(DynamicNullObject left, object right);
    public static object op_Multiply(DynamicNullObject left, object right);
    public static object op_Division(DynamicNullObject left, object right);
    public static object op_Modulus(DynamicNullObject left, object right);
    public static bool op_GreaterThanOrEqual(DynamicNullObject left, object right);
    public static bool op_LessThanOrEqual(DynamicNullObject left, object right);
    public static bool op_GreaterThan(DynamicNullObject left, object right);
    public static bool op_LessThan(DynamicNullObject left, object right);
    public static bool op_Equality(DynamicNullObject left, object right);
    public static bool op_Inequality(DynamicNullObject left, object right);
    public static double op_Implicit(DynamicNullObject o);
    public static Nullable`1<double> op_Implicit(DynamicNullObject o);
    public static int op_Implicit(DynamicNullObject o);
    public static Nullable`1<int> op_Implicit(DynamicNullObject o);
    public static long op_Implicit(DynamicNullObject o);
    public static Nullable`1<long> op_Implicit(DynamicNullObject o);
    public static decimal op_Implicit(DynamicNullObject o);
    public static Nullable`1<decimal> op_Implicit(DynamicNullObject o);
    public static float op_Implicit(DynamicNullObject o);
    public static Nullable`1<float> op_Implicit(DynamicNullObject o);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public static string op_Implicit(DynamicNullObject self);
}
public interface Raven.Abstractions.Linq.IDynamicJsonObject {
    public RavenJObject Inner { get; }
    public abstract virtual RavenJObject get_Inner();
    public abstract virtual void WriteTo(JsonWriter writer);
}
public class Raven.Abstractions.Linq.WrapperGrouping : DynamicList {
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IGrouping`2<object, object> inner;
    [DynamicAttribute]
public object Key { get; }
    public WrapperGrouping(IGrouping`2<object, object> inner);
    public sealed virtual object get_Key();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface Raven.Abstractions.Logging.ILog {
    public bool IsInfoEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsWarnEnabled { get; }
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    public abstract virtual void Log(LogLevel logLevel, Func`1<string> messageFunc);
    public abstract virtual void Log(LogLevel logLevel, Func`1<string> messageFunc, TException exception);
    public abstract virtual bool ShouldLog(LogLevel logLevel);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Logging.ILogExtensions : object {
    [ExtensionAttribute]
public static void Debug(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Debug(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void DebugException(ILog logger, string message, Exception ex);
    [ExtensionAttribute]
public static void Error(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void ErrorException(ILog logger, string message, Exception exception);
    [ExtensionAttribute]
public static void FatalException(ILog logger, string message, Exception exception);
    [ExtensionAttribute]
public static void Info(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Info(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void InfoException(ILog logger, string message, Exception exception);
    [ExtensionAttribute]
public static void Warn(ILog logger, Func`1<string> messageFunc);
    [ExtensionAttribute]
public static void Warn(ILog logger, string message, Object[] args);
    [ExtensionAttribute]
public static void WarnException(ILog logger, string message, Exception ex);
    private static void GuardAgainstNullLogger(ILog logger);
}
public interface Raven.Abstractions.Logging.ILogManager {
    public abstract virtual ILog GetLogger(string name);
    public abstract virtual IDisposable OpenNestedConext(string message);
    public abstract virtual IDisposable OpenMappedContext(string key, string value);
}
public static class Raven.Abstractions.Logging.LogContext : object {
    private static ThreadLocal`1<string> resourceName;
    public static string ResourceName { get; public set; }
    private static LogContext();
    public static IDisposable WithResource(string resourceName);
    public static string get_ResourceName();
    public static void set_ResourceName(string value);
}
public class Raven.Abstractions.Logging.LogEventInfo : object {
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormattedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private StackTrace <StackTrace>k__BackingField;
    public string Database { get; public set; }
    public LogLevel Level { get; public set; }
    public DateTime TimeStamp { get; public set; }
    public string FormattedMessage { get; public set; }
    public string LoggerName { get; public set; }
    public Exception Exception { get; public set; }
    public StackTrace StackTrace { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public LogLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_FormattedMessage();
    [CompilerGeneratedAttribute]
public void set_FormattedMessage(string value);
    [CompilerGeneratedAttribute]
public string get_LoggerName();
    [CompilerGeneratedAttribute]
public void set_LoggerName(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public StackTrace get_StackTrace();
    [CompilerGeneratedAttribute]
public void set_StackTrace(StackTrace value);
}
public class Raven.Abstractions.Logging.LogEventInfoFormatted : object {
    [CompilerGeneratedAttribute]
private string <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StackTrace>k__BackingField;
    public string Level { get; public set; }
    public string Database { get; public set; }
    public DateTime TimeStamp { get; public set; }
    public string Message { get; public set; }
    public string LoggerName { get; public set; }
    public string Exception { get; public set; }
    public string StackTrace { get; public set; }
    public LogEventInfoFormatted(LogEventInfo eventInfo);
    [CompilerGeneratedAttribute]
public string get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(string value);
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_LoggerName();
    [CompilerGeneratedAttribute]
public void set_LoggerName(string value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(string value);
    [CompilerGeneratedAttribute]
public string get_StackTrace();
    [CompilerGeneratedAttribute]
public void set_StackTrace(string value);
}
public class Raven.Abstractions.Logging.LoggerExecutionWrapper : object {
    public static string FailedToGenerateLogMessage;
    private ILog logger;
    private string loggerName;
    private ConcurrentSet`1<Target> targets;
    public ILog WrappedLogger { get; }
    public bool IsInfoEnabled { get; }
    public bool IsDebugEnabled { get; }
    public bool IsWarnEnabled { get; }
    public LoggerExecutionWrapper(ILog logger, string loggerName, ConcurrentSet`1<Target> targets);
    public ILog get_WrappedLogger();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual void Log(LogLevel logLevel, Func`1<string> messageFunc);
    public sealed virtual void Log(LogLevel logLevel, Func`1<string> messageFunc, TException exception);
    public sealed virtual bool ShouldLog(LogLevel logLevel);
}
public class Raven.Abstractions.Logging.LogHttpRequestStatsParams : object {
    [CompilerGeneratedAttribute]
private Stopwatch <Stopwatch>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<HttpHeaders> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResponseStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InnerRequestsCount>k__BackingField;
    public Stopwatch Stopwatch { get; private set; }
    public Lazy`1<HttpHeaders> Headers { get; private set; }
    public string HttpMethod { get; private set; }
    public int ResponseStatusCode { get; private set; }
    public string RequestUri { get; private set; }
    public string CustomInfo { get; private set; }
    public int InnerRequestsCount { get; private set; }
    public LogHttpRequestStatsParams(Stopwatch sw, Lazy`1<HttpHeaders> headers, string httpMethod, int responseStatusCode, string requestUri, string customInfo, int innerRequestsCount);
    [CompilerGeneratedAttribute]
public Stopwatch get_Stopwatch();
    [CompilerGeneratedAttribute]
private void set_Stopwatch(Stopwatch value);
    [CompilerGeneratedAttribute]
public Lazy`1<HttpHeaders> get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(Lazy`1<HttpHeaders> value);
    [CompilerGeneratedAttribute]
public string get_HttpMethod();
    [CompilerGeneratedAttribute]
private void set_HttpMethod(string value);
    [CompilerGeneratedAttribute]
public int get_ResponseStatusCode();
    [CompilerGeneratedAttribute]
private void set_ResponseStatusCode(int value);
    [CompilerGeneratedAttribute]
public string get_RequestUri();
    [CompilerGeneratedAttribute]
private void set_RequestUri(string value);
    [CompilerGeneratedAttribute]
public string get_CustomInfo();
    [CompilerGeneratedAttribute]
private void set_CustomInfo(string value);
    [CompilerGeneratedAttribute]
public int get_InnerRequestsCount();
    [CompilerGeneratedAttribute]
private void set_InnerRequestsCount(int value);
}
public enum Raven.Abstractions.Logging.LogLevel : Enum {
    public int value__;
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warn;
    public static LogLevel Error;
    public static LogLevel Fatal;
}
public static class Raven.Abstractions.Logging.LogManager : object {
    private static ConcurrentSet`1<Target> Targets;
    private static ILogManager currentLogManager;
    [CompilerGeneratedAttribute]
private static bool <EnableDebugLogForTargets>k__BackingField;
    public static ILogManager CurrentLogManager { get; public set; }
    public static bool EnableDebugLogForTargets { get; public set; }
    private static LogManager();
    public static void EnsureValidLogger();
    public static ILog GetCurrentClassLogger();
    public static ILogManager get_CurrentLogManager();
    public static void set_CurrentLogManager(ILogManager value);
    public static ILog GetLogger(Type type);
    [CompilerGeneratedAttribute]
public static bool get_EnableDebugLogForTargets();
    [CompilerGeneratedAttribute]
public static void set_EnableDebugLogForTargets(bool value);
    public static ILog GetLogger(string name);
    private static ILogManager ResolveExternalLogManager();
    public static void RegisterTarget();
    public static T GetTarget();
    public static IDisposable OpenNestedConext(string context);
    public static IDisposable OpenMappedContext(string key, string value);
    public static void ClearTargets();
    public static bool ShouldLogToTargets(LogLevel logLevel, ILog logger);
}
public class Raven.Abstractions.Logging.LogProviders.Log4NetLogManager : LogManagerBase {
    private static bool providerIsAvailableOverride;
    private static Lazy`1<Type> LazyGetLogManagerType;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static Log4NetLogManager();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public static bool IsLoggerAvailable();
    protected virtual Type GetLogManagerType();
    protected static Type GetLogManagerTypeStatic();
    protected virtual Type GetNdcType();
    protected virtual Type GetMdcType();
    private static Assembly GetLog4NetAssembly();
}
public abstract class Raven.Abstractions.Logging.LogProviders.LogManagerBase : object {
    private Func`2<object, ILog> loggerFactory;
    private Func`3<Assembly, string, object> getLoggerByNameDelegate;
    private Action`1<string> mdcRemoveMethodCall;
    private Action`2<string, string> mdcSetMethodCall;
    private Func`2<string, IDisposable> ndcPushMethodCall;
    public Func`3<Assembly, string, object> GetLoggerByNameDelegate { get; }
    public Func`2<string, IDisposable> NdcPushMethodCall { get; }
    public Action`2<string, string> MdcSetMethodCall { get; }
    public Action`1<string> MdcRemoveMethodCall { get; }
    protected LogManagerBase(Func`2<object, ILog> loggerFactory);
    public Func`3<Assembly, string, object> get_GetLoggerByNameDelegate();
    public Func`2<string, IDisposable> get_NdcPushMethodCall();
    public Action`2<string, string> get_MdcSetMethodCall();
    public Action`1<string> get_MdcRemoveMethodCall();
    protected abstract virtual Type GetLogManagerType();
    protected abstract virtual Type GetNdcType();
    protected abstract virtual Type GetMdcType();
    public sealed virtual ILog GetLogger(string name);
    public sealed virtual IDisposable OpenNestedConext(string message);
    public sealed virtual IDisposable OpenMappedContext(string key, string value);
    private Func`3<Assembly, string, object> GetGetLoggerMethodCall();
    private Func`2<string, IDisposable> GetNdcPushMethodCall();
    private Action`2<string, string> GetMdcSetMethodCall();
    private Action`1<string> GetMdcRemoveMethodCall();
}
public class Raven.Abstractions.Logging.LogProviders.NLogLogManager : LogManagerBase {
    private static bool providerIsAvailableOverride;
    private static Lazy`1<Type> LazyGetLogManagerType;
    public static bool ProviderIsAvailableOverride { get; public set; }
    private static NLogLogManager();
    public static bool get_ProviderIsAvailableOverride();
    public static void set_ProviderIsAvailableOverride(bool value);
    public static bool IsLoggerAvailable();
    protected virtual Type GetLogManagerType();
    private static Type GetLogManagerTypeStatic();
    protected virtual Type GetNdcType();
    private static Assembly GetNLogAssembly();
    protected virtual Type GetMdcType();
}
public abstract class Raven.Abstractions.Logging.Target : object {
    public abstract virtual void Write(LogEventInfo logEvent);
    public abstract virtual bool ShouldLog(ILog logger, LogLevel level);
    public virtual void Dispose();
}
public class Raven.Abstractions.MEF.DisableTriggerState : object {
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<Type> <Except>k__BackingField;
    public bool Disabled { get; public set; }
    public HashSet`1<Type> Except { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public HashSet`1<Type> get_Except();
    [CompilerGeneratedAttribute]
public void set_Except(HashSet`1<Type> value);
}
public interface Raven.Abstractions.MEF.IPartMetadata {
    [DefaultValueAttribute("0")]
public int Order { get; }
    public abstract virtual int get_Order();
}
public class Raven.Abstractions.MEF.OrderedPartCollection`1 : object {
    private ObservableCollection`1<Lazy`2<T, IPartMetadata>> inner;
    private ThreadLocal`1<DisableTriggerState> disableApplication;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OrderedPartCollection`1<T> Init(ThreadLocal`1<DisableTriggerState> disableApplicationValue);
    public List`1<Lazy`2<T, IPartMetadata>> GetAllParts();
    public sealed virtual IEnumerator`1<Lazy`2<T, IPartMetadata>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(T item);
    public sealed virtual void Add(Lazy`2<T, IPartMetadata> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Lazy`2<T, IPartMetadata> item);
    public sealed virtual void CopyTo(Lazy`2[] array, int arrayIndex);
    public sealed virtual bool Remove(Lazy`2<T, IPartMetadata> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public IEnumerable`1<TResult> OfType();
    public IEnumerable`1<TResult> Select(Func`2<T, TResult> func);
    public TAccumulate Aggregate(TAccumulate seed, Func`3<TAccumulate, T, TAccumulate> func);
    public void Apply(Action`1<T> action);
}
public class Raven.Abstractions.MEF.PartMetadata : object {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public int Order { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
}
public static class Raven.Abstractions.NetworkUtil : object {
    public static bool IsLocalhost(string hostNameOrAddress);
}
public abstract class Raven.Abstractions.OAuth.AbstractAuthenticator : object {
    [CompilerGeneratedAttribute]
private string <CurrentOauthToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentOauthTokenWithBearer>k__BackingField;
    protected string CurrentOauthToken { get; protected set; }
    protected string CurrentOauthTokenWithBearer { get; protected set; }
    [CompilerGeneratedAttribute]
protected string get_CurrentOauthToken();
    [CompilerGeneratedAttribute]
protected void set_CurrentOauthToken(string value);
    [CompilerGeneratedAttribute]
protected string get_CurrentOauthTokenWithBearer();
    [CompilerGeneratedAttribute]
protected void set_CurrentOauthTokenWithBearer(string value);
    public virtual void ConfigureRequest(object sender, WebRequestEventArgs e);
    protected void SetAuthorization(WebRequestEventArgs e);
    protected void SetAuthorization(HttpClient e);
    protected static void SetHeader(WebHeaderCollection headers, string key, string value);
    public abstract virtual Action`1<HttpWebRequest> DoOAuthRequest(string oauthSource, string apiKey);
}
public class Raven.Abstractions.OAuth.BasicAuthenticator : AbstractAuthenticator {
    private bool enableBasicAuthenticationOverUnsecuredHttp;
    private static string BasicOAuthOverHttpError;
    public BasicAuthenticator(bool enableBasicAuthenticationOverUnsecuredHttp);
    [AsyncStateMachineAttribute("Raven.Abstractions.OAuth.BasicAuthenticator/<HandleOAuthResponseAsync>d__2")]
public Task`1<Action`1<HttpClient>> HandleOAuthResponseAsync(string oauthSource, string apiKey);
    private HttpWebRequest PrepareOAuthRequest(string oauthSource, string apiKey);
    public virtual Action`1<HttpWebRequest> DoOAuthRequest(string oauthSource, string apiKey);
    [CompilerGeneratedAttribute]
private void <DoOAuthRequest>b__4_0(HttpWebRequest request);
}
public class Raven.Abstractions.OAuth.SecuredAuthenticator : AbstractAuthenticator {
    private bool autoRefreshToken;
    private Timer autoRefreshTimer;
    private object locker;
    private TimeSpan defaultRefreshTimeInMilis;
    public SecuredAuthenticator(bool autoRefreshToken);
    public sealed virtual void Dispose();
    public virtual void ConfigureRequest(object sender, WebRequestEventArgs e);
    private Tuple`2<HttpWebRequest, string> PrepareOAuthRequest(string oauthSource, string serverRSAExponent, string serverRSAModulus, string challenge, string apiKey);
    public virtual Action`1<HttpWebRequest> DoOAuthRequest(string oauthSource, string apiKey);
    [AsyncStateMachineAttribute("Raven.Abstractions.OAuth.SecuredAuthenticator/<DoOAuthRequestAsync>d__9")]
public Task`1<Action`1<HttpClient>> DoOAuthRequestAsync(string baseUrl, string oauthSource, string apiKey);
    private void ScheduleTokenRefresh(string oauthSource, string apiKey);
    [CompilerGeneratedAttribute]
private void <DoOAuthRequest>b__8_0(HttpWebRequest request);
}
public class Raven.Abstractions.Replication.DestinationStats : object {
    public int FailureCountInternal;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastHeartbeatReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastEtagCheckedForReplication>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastReplicatedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastReplicatedAttachmentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastReplicatedLastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastSuccessTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastFailureTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FirstFailureInCycleTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastError>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJArray <LastStats>k__BackingField;
    public string Url { get; public set; }
    public Nullable`1<DateTime> LastHeartbeatReceived { get; public set; }
    public Etag LastEtagCheckedForReplication { get; public set; }
    public Etag LastReplicatedEtag { get; public set; }
    public Etag LastReplicatedAttachmentEtag { get; public set; }
    public Nullable`1<DateTime> LastReplicatedLastModified { get; public set; }
    public Nullable`1<DateTime> LastSuccessTimestamp { get; public set; }
    public Nullable`1<DateTime> LastFailureTimestamp { get; public set; }
    public Nullable`1<DateTime> FirstFailureInCycleTimestamp { get; public set; }
    public int FailureCount { get; }
    public string LastError { get; public set; }
    public RavenJArray LastStats { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastHeartbeatReceived();
    [CompilerGeneratedAttribute]
public void set_LastHeartbeatReceived(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Etag get_LastEtagCheckedForReplication();
    [CompilerGeneratedAttribute]
public void set_LastEtagCheckedForReplication(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastReplicatedEtag();
    [CompilerGeneratedAttribute]
public void set_LastReplicatedEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastReplicatedAttachmentEtag();
    [CompilerGeneratedAttribute]
public void set_LastReplicatedAttachmentEtag(Etag value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastReplicatedLastModified();
    [CompilerGeneratedAttribute]
public void set_LastReplicatedLastModified(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastSuccessTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastSuccessTimestamp(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastFailureTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastFailureTimestamp(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_FirstFailureInCycleTimestamp();
    [CompilerGeneratedAttribute]
public void set_FirstFailureInCycleTimestamp(Nullable`1<DateTime> value);
    public int get_FailureCount();
    [CompilerGeneratedAttribute]
public string get_LastError();
    [CompilerGeneratedAttribute]
public void set_LastError(string value);
    [CompilerGeneratedAttribute]
public RavenJArray get_LastStats();
    [CompilerGeneratedAttribute]
public void set_LastStats(RavenJArray value);
}
[FlagsAttribute]
public enum Raven.Abstractions.Replication.FailoverBehavior : Enum {
    public int value__;
    public static FailoverBehavior AllowReadsFromSecondaries;
    public static FailoverBehavior AllowReadsFromSecondariesAndWritesToSecondaries;
    public static FailoverBehavior AllowReadFromSecondariesWhenRequestTimeSlaThresholdIsReached;
    public static FailoverBehavior FailImmediately;
    public static FailoverBehavior ReadFromAllServers;
    public static FailoverBehavior ReadFromLeaderWriteToLeader;
    public static FailoverBehavior ReadFromLeaderWriteToLeaderWithFailovers;
    public static FailoverBehavior ReadFromAllWriteToLeader;
    public static FailoverBehavior ReadFromAllWriteToLeaderWithFailovers;
}
public class Raven.Abstractions.Replication.ReplicatedEtagInfo : object {
    [CompilerGeneratedAttribute]
private string <DestinationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <DocumentEtag>k__BackingField;
    public string DestinationUrl { get; public set; }
    public Etag DocumentEtag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DestinationUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationUrl(string value);
    [CompilerGeneratedAttribute]
public Etag get_DocumentEtag();
    [CompilerGeneratedAttribute]
public void set_DocumentEtag(Etag value);
    public virtual string ToString();
}
public class Raven.Abstractions.Replication.ReplicationClientConfiguration : object {
    [CompilerGeneratedAttribute]
private Nullable`1<FailoverBehavior> <FailoverBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyModifyFailoverIfNotInClusterAlready>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <RequestTimeSlaThresholdInMilliseconds>k__BackingField;
    public Nullable`1<FailoverBehavior> FailoverBehavior { get; public set; }
    public bool OnlyModifyFailoverIfNotInClusterAlready { get; public set; }
    public Nullable`1<double> RequestTimeSlaThresholdInMilliseconds { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<FailoverBehavior> get_FailoverBehavior();
    [CompilerGeneratedAttribute]
public void set_FailoverBehavior(Nullable`1<FailoverBehavior> value);
    [CompilerGeneratedAttribute]
public bool get_OnlyModifyFailoverIfNotInClusterAlready();
    [CompilerGeneratedAttribute]
public void set_OnlyModifyFailoverIfNotInClusterAlready(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_RequestTimeSlaThresholdInMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RequestTimeSlaThresholdInMilliseconds(Nullable`1<double> value);
}
public class Raven.Abstractions.Replication.ReplicationConfig : object {
    [CompilerGeneratedAttribute]
private StraightforwardConflictResolution <DocumentConflictResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private StraightforwardConflictResolution <AttachmentConflictResolution>k__BackingField;
    public StraightforwardConflictResolution DocumentConflictResolution { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public StraightforwardConflictResolution AttachmentConflictResolution { get; public set; }
    [CompilerGeneratedAttribute]
public StraightforwardConflictResolution get_DocumentConflictResolution();
    [CompilerGeneratedAttribute]
public void set_DocumentConflictResolution(StraightforwardConflictResolution value);
    [CompilerGeneratedAttribute]
public StraightforwardConflictResolution get_AttachmentConflictResolution();
    [CompilerGeneratedAttribute]
public void set_AttachmentConflictResolution(StraightforwardConflictResolution value);
}
public class Raven.Abstractions.Replication.ReplicationDestination : object {
    private string url;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private TransitiveReplicationOptions <TransitiveReplicationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipIndexReplication>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoredClient>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthenticationScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVisibleUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <SpecifiedCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplicateAttachmentsInEtl>k__BackingField;
    public string Url { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string Domain { get; public set; }
    public string ApiKey { get; public set; }
    public string Database { get; public set; }
    public TransitiveReplicationOptions TransitiveReplicationBehavior { get; public set; }
    public bool SkipIndexReplication { get; public set; }
    public bool IgnoredClient { get; public set; }
    public bool Disabled { get; public set; }
    public string AuthenticationScheme { get; public set; }
    public string ClientVisibleUrl { get; public set; }
    public Dictionary`2<string, string> SpecifiedCollections { get; public set; }
    public bool ReplicateAttachmentsInEtl { get; public set; }
    public string Humane { get; }
    public string get_Url();
    public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public string get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(string value);
    [CompilerGeneratedAttribute]
public TransitiveReplicationOptions get_TransitiveReplicationBehavior();
    [CompilerGeneratedAttribute]
public void set_TransitiveReplicationBehavior(TransitiveReplicationOptions value);
    [CompilerGeneratedAttribute]
public bool get_SkipIndexReplication();
    [CompilerGeneratedAttribute]
public void set_SkipIndexReplication(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoredClient();
    [CompilerGeneratedAttribute]
public void set_IgnoredClient(bool value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public string get_AuthenticationScheme();
    [CompilerGeneratedAttribute]
public void set_AuthenticationScheme(string value);
    [CompilerGeneratedAttribute]
public string get_ClientVisibleUrl();
    [CompilerGeneratedAttribute]
public void set_ClientVisibleUrl(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_SpecifiedCollections();
    [CompilerGeneratedAttribute]
public void set_SpecifiedCollections(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_ReplicateAttachmentsInEtl();
    [CompilerGeneratedAttribute]
public void set_ReplicateAttachmentsInEtl(bool value);
    public string get_Humane();
    public bool CanBeFailover();
    protected bool Equals(ReplicationDestination other);
    public bool IsEqualTo(ReplicationDestination other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.Replication.ReplicationDocument : ReplicationDocument`1<ReplicationDestination> {
}
public class Raven.Abstractions.Replication.ReplicationDocument`1 : object {
    [CompilerGeneratedAttribute]
private List`1<TClass> <Destinations>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicationClientConfiguration <ClientConfiguration>k__BackingField;
    public List`1<TClass> Destinations { get; public set; }
    public string Id { get; public set; }
    public string Source { get; public set; }
    public ReplicationClientConfiguration ClientConfiguration { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TClass> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(List`1<TClass> value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public ReplicationClientConfiguration get_ClientConfiguration();
    [CompilerGeneratedAttribute]
public void set_ClientConfiguration(ReplicationClientConfiguration value);
}
public class Raven.Abstractions.Replication.ReplicationDocumentWithClusterInformation : ReplicationDocument`1<ReplicationDestinationWithClusterInformation> {
    [CompilerGeneratedAttribute]
private ClusterInformation <ClusterInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Term>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ClusterCommitIndex>k__BackingField;
    public ClusterInformation ClusterInformation { get; public set; }
    public long Term { get; public set; }
    public long ClusterCommitIndex { get; public set; }
    public bool HasLeader { get; }
    [CompilerGeneratedAttribute]
public ClusterInformation get_ClusterInformation();
    [CompilerGeneratedAttribute]
public void set_ClusterInformation(ClusterInformation value);
    [CompilerGeneratedAttribute]
public long get_Term();
    [CompilerGeneratedAttribute]
public void set_Term(long value);
    [CompilerGeneratedAttribute]
public long get_ClusterCommitIndex();
    [CompilerGeneratedAttribute]
public void set_ClusterCommitIndex(long value);
    public bool get_HasLeader();
    public virtual string ToString();
}
public class Raven.Abstractions.Replication.ReplicationPerformanceStats : object {
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    public int BatchSize { get; public set; }
    public TimeSpan Duration { get; public set; }
    public DateTime Started { get; public set; }
    public double DurationMilliseconds { get; }
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    public double get_DurationMilliseconds();
    public virtual string ToString();
    protected bool Equals(ReplicationPerformanceStats other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.Replication.ReplicationStatistics : object {
    [CompilerGeneratedAttribute]
private string <Self>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <MostRecentDocumentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <MostRecentAttachmentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DestinationStats> <Stats>k__BackingField;
    public string Self { get; public set; }
    public Etag MostRecentDocumentEtag { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag MostRecentAttachmentEtag { get; public set; }
    public List`1<DestinationStats> Stats { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Self();
    [CompilerGeneratedAttribute]
public void set_Self(string value);
    [CompilerGeneratedAttribute]
public Etag get_MostRecentDocumentEtag();
    [CompilerGeneratedAttribute]
public void set_MostRecentDocumentEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_MostRecentAttachmentEtag();
    [CompilerGeneratedAttribute]
public void set_MostRecentAttachmentEtag(Etag value);
    [CompilerGeneratedAttribute]
public List`1<DestinationStats> get_Stats();
    [CompilerGeneratedAttribute]
public void set_Stats(List`1<DestinationStats> value);
}
public class Raven.Abstractions.Replication.SideBySideReplicationInfo : object {
    [CompilerGeneratedAttribute]
private IndexDefinition <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexDefinition <SideBySideIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexReplaceDocument <IndexReplaceDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginDatabaseId>k__BackingField;
    public IndexDefinition Index { get; public set; }
    public IndexDefinition SideBySideIndex { get; public set; }
    public IndexReplaceDocument IndexReplaceDocument { get; public set; }
    public string OriginDatabaseId { get; public set; }
    [CompilerGeneratedAttribute]
public IndexDefinition get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(IndexDefinition value);
    [CompilerGeneratedAttribute]
public IndexDefinition get_SideBySideIndex();
    [CompilerGeneratedAttribute]
public void set_SideBySideIndex(IndexDefinition value);
    [CompilerGeneratedAttribute]
public IndexReplaceDocument get_IndexReplaceDocument();
    [CompilerGeneratedAttribute]
public void set_IndexReplaceDocument(IndexReplaceDocument value);
    [CompilerGeneratedAttribute]
public string get_OriginDatabaseId();
    [CompilerGeneratedAttribute]
public void set_OriginDatabaseId(string value);
}
public enum Raven.Abstractions.Replication.StraightforwardConflictResolution : Enum {
    public int value__;
    public static StraightforwardConflictResolution None;
    public static StraightforwardConflictResolution ResolveToLocal;
    public static StraightforwardConflictResolution ResolveToRemote;
    public static StraightforwardConflictResolution ResolveToLatest;
}
public enum Raven.Abstractions.Replication.TransitiveReplicationOptions : Enum {
    public int value__;
    [DescriptionAttribute("Changed only")]
public static TransitiveReplicationOptions None;
    [DescriptionAttribute("Changed and replicated")]
public static TransitiveReplicationOptions Replicate;
}
public class Raven.Abstractions.ServerConnectionInfo : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    public string Url { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string Domain { get; public set; }
    public string ApiKey { get; public set; }
    public ICredentials Credentials { get; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    public ICredentials get_Credentials();
}
public class Raven.Abstractions.ServerSmugglerRequest : object {
    [CompilerGeneratedAttribute]
private ServerConnectionInfo <TargetServer>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ServerSmugglingItem> <Config>k__BackingField;
    public ServerConnectionInfo TargetServer { get; public set; }
    public List`1<ServerSmugglingItem> Config { get; public set; }
    [CompilerGeneratedAttribute]
public ServerConnectionInfo get_TargetServer();
    [CompilerGeneratedAttribute]
public void set_TargetServer(ServerConnectionInfo value);
    [CompilerGeneratedAttribute]
public List`1<ServerSmugglingItem> get_Config();
    [CompilerGeneratedAttribute]
public void set_Config(List`1<ServerSmugglingItem> value);
}
public class Raven.Abstractions.ServerSmugglingItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Incremental>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripReplicationInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDisableVersioningBundle>k__BackingField;
    public string Name { get; public set; }
    public bool Incremental { get; public set; }
    public bool StripReplicationInformation { get; public set; }
    public bool ShouldDisableVersioningBundle { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Incremental();
    [CompilerGeneratedAttribute]
public void set_Incremental(bool value);
    [CompilerGeneratedAttribute]
public bool get_StripReplicationInformation();
    [CompilerGeneratedAttribute]
public void set_StripReplicationInformation(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldDisableVersioningBundle();
    [CompilerGeneratedAttribute]
public void set_ShouldDisableVersioningBundle(bool value);
}
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Abstractions.Smuggler.Data.AttachmentExportInfo : object {
    [CompilerGeneratedAttribute]
private Stream <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public Stream Data { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public string Key { get; public set; }
    [CompilerGeneratedAttribute]
public Stream get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Stream value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
}
public class Raven.Abstractions.Smuggler.Data.CounterOperationState : object {
    [CompilerGeneratedAttribute]
private long <LastWrittenEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterId>k__BackingField;
    public long LastWrittenEtag { get; public set; }
    public string CounterId { get; public set; }
    [CompilerGeneratedAttribute]
public long get_LastWrittenEtag();
    [CompilerGeneratedAttribute]
public void set_LastWrittenEtag(long value);
    [CompilerGeneratedAttribute]
public string get_CounterId();
    [CompilerGeneratedAttribute]
public void set_CounterId(string value);
}
public class Raven.Abstractions.Smuggler.Data.ExportFilesDestinationKey : object {
    [CompilerGeneratedAttribute]
private Etag <LastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastDeletedEtag>k__BackingField;
    public Etag LastEtag { get; public set; }
    public Etag LastDeletedEtag { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_LastEtag();
    [CompilerGeneratedAttribute]
public void set_LastEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastDeletedEtag();
    [CompilerGeneratedAttribute]
public void set_LastDeletedEtag(Etag value);
}
public class Raven.Abstractions.Smuggler.Data.ExportFilesDestinations : object {
    public static string RavenDocumentKey;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ExportFilesDestinationKey> <Destinations>k__BackingField;
    public Dictionary`2<string, ExportFilesDestinationKey> Destinations { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ExportFilesDestinationKey> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(Dictionary`2<string, ExportFilesDestinationKey> value);
}
public class Raven.Abstractions.Smuggler.Data.ExportFilesResult : LastFilesEtagsInfo {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string FilePath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
}
public class Raven.Abstractions.Smuggler.Data.FilesUploadWorker : object {
    private FileUploadUnitOfWork[] filesAndMetadata;
    public FilesUploadWorker(FileUploadUnitOfWork[] filesAndMetadata);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.Data.FilesUploadWorker/<UploadFiles>d__2")]
public Task UploadFiles(Stream netStream, TaskCompletionSource`1<object> t);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.Data.FilesUploadWorker/<CopyStreamsUsingBuffer>d__3")]
private static Task CopyStreamsUsingBuffer(Stream netStream, long fileSize, Stream unzippedStream, Byte[] fileCopyBuffer);
}
public class Raven.Abstractions.Smuggler.Data.FileUploadUnitOfWork : object {
    [CompilerGeneratedAttribute]
private ZipArchiveEntry <ZipEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private FileHeader <Header>k__BackingField;
    public ZipArchiveEntry ZipEntry { get; private set; }
    public FileHeader Header { get; private set; }
    public FileUploadUnitOfWork(ZipArchiveEntry zipEntry, FileHeader header);
    [CompilerGeneratedAttribute]
public ZipArchiveEntry get_ZipEntry();
    [CompilerGeneratedAttribute]
private void set_ZipEntry(ZipArchiveEntry value);
    [CompilerGeneratedAttribute]
public FileHeader get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(FileHeader value);
}
public class Raven.Abstractions.Smuggler.Data.LastEtagsInfo : object {
    [CompilerGeneratedAttribute]
private Etag <LastDocsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastDocDeleteEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastAttachmentsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastAttachmentsDeleteEtag>k__BackingField;
    public Etag LastDocsEtag { get; public set; }
    public Etag LastDocDeleteEtag { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag LastAttachmentsEtag { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag LastAttachmentsDeleteEtag { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_LastDocsEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocsEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastDocDeleteEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocDeleteEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastAttachmentsEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentsEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastAttachmentsDeleteEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentsDeleteEtag(Etag value);
}
public class Raven.Abstractions.Smuggler.Data.LastFilesEtagsInfo : object {
    [CompilerGeneratedAttribute]
private Etag <LastDeletedFileEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastFileEtag>k__BackingField;
    public Etag LastDeletedFileEtag { get; public set; }
    public Etag LastFileEtag { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_LastDeletedFileEtag();
    [CompilerGeneratedAttribute]
public void set_LastDeletedFileEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastFileEtag();
    [CompilerGeneratedAttribute]
public void set_LastFileEtag(Etag value);
}
public class Raven.Abstractions.Smuggler.Data.OperationState : LastEtagsInfo {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfExportedDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfExportedAttachments>k__BackingField;
    public string FilePath { get; public set; }
    public int NumberOfExportedDocuments { get; public set; }
    public int NumberOfExportedAttachments { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public int get_NumberOfExportedDocuments();
    [CompilerGeneratedAttribute]
public void set_NumberOfExportedDocuments(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfExportedAttachments();
    [CompilerGeneratedAttribute]
public void set_NumberOfExportedAttachments(int value);
}
internal enum Raven.Abstractions.Smuggler.Data.SmugglerDataFormat : Enum {
    public int value__;
    public static SmugglerDataFormat V3;
    public static SmugglerDataFormat V4;
}
public class Raven.Abstractions.Smuggler.Data.Tombstone : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
}
public class Raven.Abstractions.Smuggler.ExportOptions : object {
    [CompilerGeneratedAttribute]
private bool <ExportDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExportAttachments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExportDeletions>k__BackingField;
    [CompilerGeneratedAttribute]
private LastEtagsInfo <StartEtags>k__BackingField;
    private int maxNumberOfDocumentsToExport;
    private int maxNumberOfAttachmentsToExport;
    public bool ExportDocuments { get; public set; }
    public bool ExportAttachments { get; public set; }
    public bool ExportDeletions { get; public set; }
    public LastEtagsInfo StartEtags { get; public set; }
    public int MaxNumberOfDocumentsToExport { get; public set; }
    public int MaxNumberOfAttachmentsToExport { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ExportDocuments();
    [CompilerGeneratedAttribute]
public void set_ExportDocuments(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExportAttachments();
    [CompilerGeneratedAttribute]
public void set_ExportAttachments(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExportDeletions();
    [CompilerGeneratedAttribute]
public void set_ExportDeletions(bool value);
    [CompilerGeneratedAttribute]
public LastEtagsInfo get_StartEtags();
    [CompilerGeneratedAttribute]
public void set_StartEtags(LastEtagsInfo value);
    public int get_MaxNumberOfDocumentsToExport();
    public void set_MaxNumberOfDocumentsToExport(int value);
    public int get_MaxNumberOfAttachmentsToExport();
    public void set_MaxNumberOfAttachmentsToExport(int value);
    public static ExportOptions Create(OperationState state, ItemType types, bool exportDeletions, int maxNumberOfItemsToExport);
}
public class Raven.Abstractions.Smuggler.FilterSetting : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldMatch>k__BackingField;
    private static Regex Regex;
    public string Path { get; public set; }
    public List`1<string> Values { get; public set; }
    public bool ShouldMatch { get; public set; }
    private static FilterSetting();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ShouldMatch();
    [CompilerGeneratedAttribute]
public void set_ShouldMatch(bool value);
    public static List`1<string> ParseValues(string value);
}
public interface Raven.Abstractions.Smuggler.ISmugglerApi`3 {
    public TOptions Options { get; }
    public abstract virtual TOptions get_Options();
    public abstract virtual Task`1<TOut> ExportData(SmugglerExportOptions`1<TIn> exportOptions);
    public abstract virtual Task ImportData(SmugglerImportOptions`1<TIn> importOptions);
    public abstract virtual Task Between(SmugglerBetweenOptions`1<TIn> betweenOptions);
}
public interface Raven.Abstractions.Smuggler.ISmugglerDatabaseOperations {
    public SmugglerDatabaseOptions Options { get; }
    public abstract virtual SmugglerDatabaseOptions get_Options();
    [ObsoleteAttribute("Use RavenFS instead.")]
public abstract virtual Task DeleteAttachment(string key);
    public abstract virtual Task DeleteDocument(string key);
    [ObsoleteAttribute("Use RavenFS instead.")]
public abstract virtual Task`1<Etag> ExportAttachmentsDeletion(SmugglerJsonTextWriter jsonWriter, Etag startAttachmentsDeletionEtag, Etag maxAttachmentEtag);
    public abstract virtual Task`1<Etag> ExportDocumentsDeletion(SmugglerJsonTextWriter jsonWriter, Etag startDocsEtag, Etag maxEtag);
    public abstract virtual LastEtagsInfo FetchCurrentMaxEtags();
    [ObsoleteAttribute("Use RavenFS instead.")]
public abstract virtual Task`1<List`1<AttachmentInformation>> GetAttachments(int start, Etag etag, int maxRecords);
    [ObsoleteAttribute("Use RavenFS instead.")]
public abstract virtual Task`1<Byte[]> GetAttachmentData(AttachmentInformation attachmentInformation);
    public abstract virtual JsonDocument GetDocument(string key);
    public abstract virtual Task`1<IAsyncEnumerator`1<RavenJObject>> GetDocuments(Etag lastEtag, int take);
    public abstract virtual Task`1<RavenJArray> GetIndexes(int totalCount);
    public abstract virtual Task`1<DatabaseStatistics> GetStats();
    public abstract virtual Task`1<RavenJArray> GetTransformers(int start);
    public abstract virtual Task`1<BuildNumber> GetVersion(RavenConnectionStringOptions server);
    public abstract virtual void PurgeTombstones(OperationState result);
    [ObsoleteAttribute("Use RavenFS instead.")]
public abstract virtual Task PutAttachment(AttachmentExportInfo attachmentExportInfo);
    public abstract virtual Task PutDocument(RavenJObject document, int size);
    public abstract virtual Task PutIndex(string indexName, RavenJToken index);
    public abstract virtual Task PutTransformer(string transformerName, RavenJToken transformer);
    public abstract virtual void ShowProgress(string format, Object[] args);
    public abstract virtual Task`1<RavenJObject> TransformDocument(RavenJObject document, string transformScript);
    public abstract virtual RavenJObject StripReplicationInformationFromMetadata(RavenJObject metadata);
    public abstract virtual void Initialize(SmugglerDatabaseOptions options);
    public abstract virtual void Configure(SmugglerDatabaseOptions options);
    public abstract virtual Task SeedIdentityFor(string identityName, long identityValue);
    public abstract virtual Task`1<IAsyncEnumerator`1<RavenJObject>> ExportItems(ItemType types, OperationState state);
    public abstract virtual string GetIdentifier();
    public abstract virtual Task`1<List`1<KeyValuePair`2<string, long>>> GetIdentities();
    public abstract virtual Task SeedIdentities(List`1<KeyValuePair`2<string, long>> identities);
    public abstract virtual Task WaitForLastBulkInsertTaskToFinish();
}
public interface Raven.Abstractions.Smuggler.ISmugglerFilesOperations {
    public SmugglerFilesOptions Options { get; }
    public bool IsEmbedded { get; }
    public abstract virtual SmugglerFilesOptions get_Options();
    public abstract virtual Task`1<FileSystemStats[]> GetStats();
    public abstract virtual Task`1<BuildNumber> GetVersion(FilesConnectionStringOptions server);
    public abstract virtual LastFilesEtagsInfo FetchCurrentMaxEtags();
    public abstract virtual Task`1<IAsyncEnumerator`1<FileHeader>> GetFiles(Etag lastEtag, int take);
    public abstract virtual Task`1<Stream> DownloadFile(FileHeader file);
    public abstract virtual Task PutFile(FileHeader file, Stream data, long dataSize);
    public abstract virtual Task`1<IEnumerable`1<KeyValuePair`2<string, RavenJObject>>> GetConfigurations(int start, int take);
    public abstract virtual Task PutConfig(string name, RavenJObject value);
    public abstract virtual void Initialize(SmugglerFilesOptions options);
    public abstract virtual void Configure(SmugglerFilesOptions options);
    public abstract virtual void ShowProgress(string format, Object[] args);
    public abstract virtual string CreateIncrementalKey();
    public abstract virtual Task`1<ExportFilesDestinations> GetIncrementalExportKey();
    public abstract virtual Task PutIncrementalExportKey(ExportFilesDestinations destinations);
    public abstract virtual RavenJObject StripReplicationInformationFromMetadata(RavenJObject metadata);
    public abstract virtual RavenJObject DisableVersioning(RavenJObject metadata);
    public abstract virtual Task`1<Stream> ReceiveFilesInStream(List`1<string> filePaths);
    public abstract virtual bool get_IsEmbedded();
    public abstract virtual Task UploadFilesInStream(FileUploadUnitOfWork[] files);
}
[FlagsAttribute]
public enum Raven.Abstractions.Smuggler.ItemType : Enum {
    public int value__;
    public static ItemType Documents;
    public static ItemType Indexes;
    [ObsoleteAttribute("Use RavenFS instead.")]
public static ItemType Attachments;
    public static ItemType Transformers;
    public static ItemType RemoveAnalyzers;
}
public class Raven.Abstractions.Smuggler.ServerSupportedFeatures : object {
    [CompilerGeneratedAttribute]
private bool <IsTransformersSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDocsStreamingSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIdentitiesSmugglingSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBulkIdentitiesSmugglingSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMultiPartExportSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFilesStreamingSupported>k__BackingField;
    public bool IsTransformersSupported { get; public set; }
    public bool IsDocsStreamingSupported { get; public set; }
    public bool IsIdentitiesSmugglingSupported { get; public set; }
    public bool IsBulkIdentitiesSmugglingSupported { get; public set; }
    public bool IsMultiPartExportSupported { get; public set; }
    public bool IsFilesStreamingSupported { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsTransformersSupported();
    [CompilerGeneratedAttribute]
public void set_IsTransformersSupported(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDocsStreamingSupported();
    [CompilerGeneratedAttribute]
public void set_IsDocsStreamingSupported(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsIdentitiesSmugglingSupported();
    [CompilerGeneratedAttribute]
public void set_IsIdentitiesSmugglingSupported(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsBulkIdentitiesSmugglingSupported();
    [CompilerGeneratedAttribute]
public void set_IsBulkIdentitiesSmugglingSupported(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMultiPartExportSupported();
    [CompilerGeneratedAttribute]
public void set_IsMultiPartExportSupported(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFilesStreamingSupported();
    [CompilerGeneratedAttribute]
public void set_IsFilesStreamingSupported(bool value);
}
public enum Raven.Abstractions.Smuggler.SmugglerAction : Enum {
    public int value__;
    public static SmugglerAction Import;
    public static SmugglerAction Export;
    public static SmugglerAction Between;
}
public class Raven.Abstractions.Smuggler.SmugglerBetweenOptions`1 : object {
    [CompilerGeneratedAttribute]
private T <From>k__BackingField;
    [CompilerGeneratedAttribute]
private T <To>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IncrementalKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<string> <ReportProgress>k__BackingField;
    public T From { get; public set; }
    public T To { get; public set; }
    public string IncrementalKey { get; public set; }
    public Action`1<string> ReportProgress { get; public set; }
    [CompilerGeneratedAttribute]
public T get_From();
    [CompilerGeneratedAttribute]
public void set_From(T value);
    [CompilerGeneratedAttribute]
public T get_To();
    [CompilerGeneratedAttribute]
public void set_To(T value);
    [CompilerGeneratedAttribute]
public string get_IncrementalKey();
    [CompilerGeneratedAttribute]
public void set_IncrementalKey(string value);
    [CompilerGeneratedAttribute]
public Action`1<string> get_ReportProgress();
    [CompilerGeneratedAttribute]
public void set_ReportProgress(Action`1<string> value);
}
public class Raven.Abstractions.Smuggler.SmugglerCounterOptions : SmugglerOptions`1<CounterConnectionStringOptions> {
}
public abstract class Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase : object {
    private static int RetriesCount;
    [CompilerGeneratedAttribute]
private ISmugglerDatabaseOperations <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private SmugglerDatabaseOptions <Options>k__BackingField;
    private static string IncrementalExportStateFile;
    private SmugglerDataFormat dataFormat;
    private static Lazy`1<JsonConverterCollection> defaultConverters;
    [CompilerGeneratedAttribute]
private ServerSupportedFeatures <SupportedFeatures>k__BackingField;
    public ISmugglerDatabaseOperations Operations { get; protected set; }
    public SmugglerDatabaseOptions Options { get; private set; }
    protected bool IgnoreErrorsAndContinue { get; }
    private static JsonConverterCollection DefaultConverters { get; }
    public ServerSupportedFeatures SupportedFeatures { get; private set; }
    protected SmugglerDatabaseApiBase(SmugglerDatabaseOptions options);
    private static SmugglerDatabaseApiBase();
    [CompilerGeneratedAttribute]
public ISmugglerDatabaseOperations get_Operations();
    [CompilerGeneratedAttribute]
protected void set_Operations(ISmugglerDatabaseOperations value);
    [CompilerGeneratedAttribute]
public sealed virtual SmugglerDatabaseOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(SmugglerDatabaseOptions value);
    protected bool get_IgnoreErrorsAndContinue();
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ExportData>d__14")]
public virtual Task`1<OperationState> ExportData(SmugglerExportOptions`1<RavenConnectionStringOptions> exportOptions);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<RunLastExportAsync>d__15")]
private Task RunLastExportAsync(SmugglerExportOptions`1<RavenConnectionStringOptions> exportOptions, OperationState state, SmugglerJsonTextWriter writer);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ExportIdentities>d__16")]
private Task ExportIdentities(SmugglerJsonTextWriter jsonWriter, ItemType operateOnTypes);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ModifyItemAsync>d__17")]
private Task`1<RavenJObject> ModifyItemAsync(SmugglerExportType type, RavenJObject item);
    private bool FilterItem(SmugglerExportType type, RavenJToken item, DateTime now);
    private bool FilterDocument(RavenJToken document, DateTime now);
    private static string GetPropertyName(SmugglerExportType type);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<RunSingleExportAsync>d__21")]
private Task`1<SmugglerExportException> RunSingleExportAsync(SmugglerExportOptions`1<RavenConnectionStringOptions> exportOptions, OperationState state, LastEtagsInfo maxEtags, SmugglerJsonTextWriter writer, bool ownedStream);
    public bool FilterIdentity(string identityName, ItemType operateOnTypes);
    public static void ReadLastEtagsFromFile(OperationState result, string etagFileLocation);
    public static void ReadLastEtagsFromFile(OperationState result);
    public static void WriteLastEtagsToFile(OperationState result, string etagFileLocation);
    public static void WriteLastEtagsToFile(OperationState result, string backupPath, string filename);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ExportTransformers>d__27")]
private Task ExportTransformers(RavenConnectionStringOptions src, SmugglerJsonTextWriter jsonWriter);
    public abstract virtual Task ExportDeletions(SmugglerJsonTextWriter jsonWriter, OperationState result, LastEtagsInfo maxEtagsToFetch);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ExportAttachments>d__29")]
[ObsoleteAttribute("Use RavenFS instead.")]
protected virtual Task`1<ExportOperationStatus> ExportAttachments(RavenConnectionStringOptions src, SmugglerJsonTextWriter jsonWriter, Etag lastEtag, Etag maxEtag, int maxNumberOfAttachmentsToExport);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ExportDocuments>d__30")]
protected Task`1<ExportOperationStatus> ExportDocuments(RavenConnectionStringOptions src, SmugglerJsonTextWriter jsonWriter, Etag lastEtag, Etag maxEtag, int maxNumberOfDocumentsToExport);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<WaitForIndexingAsOfLastWrite>d__31")]
public Task WaitForIndexingAsOfLastWrite();
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<WaitForIndexing>d__32")]
public Task WaitForIndexing();
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ImportData>d__33")]
public virtual Task ImportData(SmugglerImportOptions`1<RavenConnectionStringOptions> importOptions);
    public abstract virtual Task Between(SmugglerBetweenOptions`1<RavenConnectionStringOptions> betweenOptions);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ImportData>d__35")]
public virtual Task ImportData(SmugglerImportOptions`1<RavenConnectionStringOptions> importOptions, Stream stream);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<RunSingleImportAsync>d__36")]
private Task RunSingleImportAsync(JsonReader jsonReader, IReadOnlyDictionary`2<string, Func`1<Task`1<int>>> exportSectionRegistar, IDictionary`2<string, int> exportCounts);
    private Task`1<int> ImportIdentities(JsonTextReader jsonReader);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ImportIdentitiesUsingSingleOperation>d__38")]
private Task`1<int> ImportIdentitiesUsingSingleOperation(IEnumerator`1<KeyValuePair`2<string, long>> identities);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ImportIdentitiesUsingBulk>d__39")]
private Task`1<int> ImportIdentitiesUsingBulk(IEnumerator`1<KeyValuePair`2<string, long>> identities);
    [IteratorStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ReadIdentities>d__40")]
private IEnumerator`1<KeyValuePair`2<string, long>> ReadIdentities(JsonTextReader jsonReader);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ImportDeletedDocuments>d__41")]
private Task`1<int> ImportDeletedDocuments(JsonReader jsonReader);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ImportDeletedAttachments>d__42")]
[ObsoleteAttribute("Use RavenFS instead.")]
private Task`1<int> ImportDeletedAttachments(JsonReader jsonReader);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ImportTransformers>d__43")]
private Task`1<int> ImportTransformers(JsonTextReader jsonReader);
    private static JsonConverterCollection get_DefaultConverters();
    [ObsoleteAttribute("Use RavenFS instead.")]
[AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ImportAttachments>d__47")]
private Task`1<int> ImportAttachments(RavenConnectionStringOptions dst, JsonTextReader jsonReader);
    private static void ValidateStartObject(JsonTextReader jsonReader);
    private static void ValidateEndObject(JsonTextReader jsonReader);
    private static void ValidatePropertyName(JsonTextReader jsonReader, string propName);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ImportDocuments>d__51")]
private Task`1<int> ImportDocuments(JsonTextReader jsonReader);
    private static RavenJObject BuildSkipDocument();
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<WriteLastEtagToDatabase>d__53")]
private Task WriteLastEtagToDatabase(OperationState state, JsonDocument lastEtagsDocument);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ImportIndexes>d__54")]
private Task`1<int> ImportIndexes(JsonReader jsonReader);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<ExportIndexes>d__55")]
private Task ExportIndexes(RavenConnectionStringOptions src, SmugglerJsonTextWriter jsonWriter);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerDatabaseApiBase/<DetectServerSupportedFeatures>d__56")]
protected Task`1<ServerSupportedFeatures> DetectServerSupportedFeatures(ISmugglerDatabaseOperations ops, RavenConnectionStringOptions server);
    private ServerSupportedFeatures GetLegacyModeFeatures();
    [CompilerGeneratedAttribute]
public ServerSupportedFeatures get_SupportedFeatures();
    [CompilerGeneratedAttribute]
private void set_SupportedFeatures(ServerSupportedFeatures value);
    protected static void SetDatabaseNameIfEmpty(RavenConnectionStringOptions connection);
}
public class Raven.Abstractions.Smuggler.SmugglerDatabaseOptions : SmugglerOptions`1<RavenConnectionStringOptions> {
    public static int DefaultDocumentSizeInChunkLimitInBytes;
    private int chunkSize;
    private long totalDocumentSizeInChunkLimitInBytes;
    [CompilerGeneratedAttribute]
private bool <IgnoreErrorsAndContinue>k__BackingField;
    private string continuationFile;
    private bool useContinuationFile;
    [CompilerGeneratedAttribute]
private TimeSpan <HeartbeatLatency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableCompressionOnImport>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExportDeletions>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <StartDocsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <StartAttachmentsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <StartDocsDeletionEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <StartAttachmentsDeletionEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemType <OperateOnTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FilterSetting> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldExcludeExpired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDisableVersioningBundle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NoneDefaultFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TransformScript>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxStepsForTransformScript>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WaitForIndexing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripReplicationInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipConflicted>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSplitExportFileSize>k__BackingField;
    public bool IgnoreErrorsAndContinue { get; public set; }
    public TimeSpan HeartbeatLatency { get; public set; }
    public string ContinuationToken { get; public set; }
    public bool UseContinuationFile { get; }
    public long TotalDocumentSizeInChunkLimitInBytes { get; public set; }
    public int ChunkSize { get; public set; }
    public bool DisableCompressionOnImport { get; public set; }
    public bool ExportDeletions { get; public set; }
    public Etag StartDocsEtag { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag StartAttachmentsEtag { get; public set; }
    public Etag StartDocsDeletionEtag { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag StartAttachmentsDeletionEtag { get; public set; }
    public ItemType OperateOnTypes { get; public set; }
    public List`1<FilterSetting> Filters { get; public set; }
    public bool ShouldExcludeExpired { get; public set; }
    public bool ShouldDisableVersioningBundle { get; public set; }
    public string NoneDefaultFileName { get; public set; }
    public string TransformScript { get; public set; }
    public int MaxStepsForTransformScript { get; public set; }
    public bool WaitForIndexing { get; public set; }
    public bool StripReplicationInformation { get; public set; }
    public bool SkipConflicted { get; public set; }
    public int MaxSplitExportFileSize { get; public set; }
    private void ConfigureDefaultFilters();
    [CompilerGeneratedAttribute]
public bool get_IgnoreErrorsAndContinue();
    [CompilerGeneratedAttribute]
public void set_IgnoreErrorsAndContinue(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_HeartbeatLatency();
    [CompilerGeneratedAttribute]
public void set_HeartbeatLatency(TimeSpan value);
    public string get_ContinuationToken();
    public void set_ContinuationToken(string value);
    public bool get_UseContinuationFile();
    public long get_TotalDocumentSizeInChunkLimitInBytes();
    public void set_TotalDocumentSizeInChunkLimitInBytes(long value);
    public int get_ChunkSize();
    public void set_ChunkSize(int value);
    [CompilerGeneratedAttribute]
public bool get_DisableCompressionOnImport();
    [CompilerGeneratedAttribute]
public void set_DisableCompressionOnImport(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExportDeletions();
    [CompilerGeneratedAttribute]
public void set_ExportDeletions(bool value);
    [CompilerGeneratedAttribute]
public Etag get_StartDocsEtag();
    [CompilerGeneratedAttribute]
public void set_StartDocsEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_StartAttachmentsEtag();
    [CompilerGeneratedAttribute]
public void set_StartAttachmentsEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_StartDocsDeletionEtag();
    [CompilerGeneratedAttribute]
public void set_StartDocsDeletionEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_StartAttachmentsDeletionEtag();
    [CompilerGeneratedAttribute]
public void set_StartAttachmentsDeletionEtag(Etag value);
    [CompilerGeneratedAttribute]
public ItemType get_OperateOnTypes();
    [CompilerGeneratedAttribute]
public void set_OperateOnTypes(ItemType value);
    [CompilerGeneratedAttribute]
public List`1<FilterSetting> get_Filters();
    [CompilerGeneratedAttribute]
public void set_Filters(List`1<FilterSetting> value);
    public virtual bool MatchFilters(RavenJToken item);
    [CompilerGeneratedAttribute]
public bool get_ShouldExcludeExpired();
    [CompilerGeneratedAttribute]
public void set_ShouldExcludeExpired(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldDisableVersioningBundle();
    [CompilerGeneratedAttribute]
public void set_ShouldDisableVersioningBundle(bool value);
    [CompilerGeneratedAttribute]
public string get_NoneDefaultFileName();
    [CompilerGeneratedAttribute]
public void set_NoneDefaultFileName(string value);
    public virtual bool ExcludeExpired(RavenJToken item, DateTime now);
    [CompilerGeneratedAttribute]
public string get_TransformScript();
    [CompilerGeneratedAttribute]
public void set_TransformScript(string value);
    [CompilerGeneratedAttribute]
public int get_MaxStepsForTransformScript();
    [CompilerGeneratedAttribute]
public void set_MaxStepsForTransformScript(int value);
    [CompilerGeneratedAttribute]
public bool get_WaitForIndexing();
    [CompilerGeneratedAttribute]
public void set_WaitForIndexing(bool value);
    [CompilerGeneratedAttribute]
public bool get_StripReplicationInformation();
    [CompilerGeneratedAttribute]
public void set_StripReplicationInformation(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipConflicted();
    [CompilerGeneratedAttribute]
public void set_SkipConflicted(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxSplitExportFileSize();
    [CompilerGeneratedAttribute]
public void set_MaxSplitExportFileSize(int value);
}
public class Raven.Abstractions.Smuggler.SmugglerExportOptions`1 : object {
    [CompilerGeneratedAttribute]
private T <From>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <ToStream>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSplitExportFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIncrementalExport>k__BackingField;
    public T From { get; public set; }
    public string ToFile { get; public set; }
    public Stream ToStream { get; public set; }
    public int MaxSplitExportFileSize { get; public set; }
    public bool IsIncrementalExport { get; public set; }
    [CompilerGeneratedAttribute]
public T get_From();
    [CompilerGeneratedAttribute]
public void set_From(T value);
    [CompilerGeneratedAttribute]
public string get_ToFile();
    [CompilerGeneratedAttribute]
public void set_ToFile(string value);
    [CompilerGeneratedAttribute]
public Stream get_ToStream();
    [CompilerGeneratedAttribute]
public void set_ToStream(Stream value);
    [CompilerGeneratedAttribute]
public int get_MaxSplitExportFileSize();
    [CompilerGeneratedAttribute]
public void set_MaxSplitExportFileSize(int value);
    [CompilerGeneratedAttribute]
public bool get_IsIncrementalExport();
    [CompilerGeneratedAttribute]
public void set_IsIncrementalExport(bool value);
}
public enum Raven.Abstractions.Smuggler.SmugglerExportType : Enum {
    public int value__;
    [DescriptionAttribute("Docs")]
public static SmugglerExportType Document;
    [DescriptionAttribute("Attachments")]
public static SmugglerExportType Attachment;
    [DescriptionAttribute("Identities")]
public static SmugglerExportType Identity;
    [DescriptionAttribute("DocsDeletions")]
public static SmugglerExportType DocumentDeletion;
    [DescriptionAttribute("AttachmentsDeletions")]
public static SmugglerExportType AttachmentDeletion;
    [DescriptionAttribute("Summary")]
public static SmugglerExportType Summary;
}
public class Raven.Abstractions.Smuggler.SmugglerFilesApiBase : object {
    private static string MetadataEntry;
    private static string ConfigurationsEntry;
    private Regex internalConfigs;
    [CompilerGeneratedAttribute]
private SmugglerFilesOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ISmugglerFilesOperations <Operations>k__BackingField;
    private static string IncrementalExportStateFile;
    public SmugglerFilesOptions Options { get; private set; }
    public ISmugglerFilesOperations Operations { get; protected set; }
    protected SmugglerFilesApiBase(SmugglerFilesOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual SmugglerFilesOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(SmugglerFilesOptions value);
    [CompilerGeneratedAttribute]
public ISmugglerFilesOperations get_Operations();
    [CompilerGeneratedAttribute]
protected void set_Operations(ISmugglerFilesOperations value);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<ExportData>d__15")]
public virtual Task`1<ExportFilesResult> ExportData(SmugglerExportOptions`1<FilesConnectionStringOptions> exportOptions);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<ExportFilesLegacy>d__16")]
private Task`1<Etag> ExportFilesLegacy(ZipArchive archive, Etag lastEtag, Etag maxEtag);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<ExportFilesStreamingBulk>d__17")]
private Task`1<Etag> ExportFilesStreamingBulk(ZipArchive archive, Etag lastEtag, Etag maxEtag, int maxSizeInBytes);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<GetFilesTask>d__18")]
private Task GetFilesTask(Etag lastEtag, Etag maxEtag, CancellationTokenSource cts, BlockingCollection`1<FileHeader> fileHeaders);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<ExportConfigurations>d__19")]
private Task ExportConfigurations(ZipArchive archive);
    private static RavenJObject EnsureValidExportConfig(KeyValuePair`2<string, RavenJObject> config);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<DetectServerSupportedFeatures>d__21")]
private Task`1<ServerSupportedFeatures> DetectServerSupportedFeatures(FilesConnectionStringOptions filesConnectionStringOptions);
    private static void ReadLastEtagsFromFile(ExportFilesResult result);
    public static void WriteLastEtagsToFile(ExportFilesResult result, string backupPath);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<ImportData>d__24")]
public virtual Task ImportData(SmugglerImportOptions`1<FilesConnectionStringOptions> importOptions);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<ImportData>d__25")]
private Task ImportData(SmugglerImportOptions`1<FilesConnectionStringOptions> importOptions, Stream stream, int streamingBatchSize);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<ImportConfigs>d__26")]
private Task ImportConfigs(StreamReader streamReader, JsonSerializer serializer, int configurationsCount);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<ImportFilesWithStreaming_ForNowShouldNotBeUsed>d__27")]
private Task`1<int> ImportFilesWithStreaming_ForNowShouldNotBeUsed(SmugglerImportOptions`1<FilesConnectionStringOptions> importOptions, int streamingBatchSize, StreamReader streamReader, JsonSerializer serializer, Dictionary`2<string, ZipArchiveEntry> filesLookup);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<ImportFiles>d__28")]
private Task`1<int> ImportFiles(StreamReader streamReader, JsonSerializer serializer, Dictionary`2<string, ZipArchiveEntry> filesLookup);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<Between>d__29")]
public virtual Task Between(SmugglerBetweenOptions`1<FilesConnectionStringOptions> betweenOptions);
    [AsyncStateMachineAttribute("Raven.Abstractions.Smuggler.SmugglerFilesApiBase/<CopyBetweenStores>d__30")]
private Task`1<Etag> CopyBetweenStores(Etag lastEtag, Etag maxEtag);
}
public class Raven.Abstractions.Smuggler.SmugglerFilesOptions : SmugglerOptions`1<FilesConnectionStringOptions> {
    [CompilerGeneratedAttribute]
private Etag <StartFilesEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <StartFilesDeletionEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripReplicationInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDisableVersioningBundle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NoneDefaultFileName>k__BackingField;
    public Etag StartFilesEtag { get; public set; }
    public Etag StartFilesDeletionEtag { get; public set; }
    public bool StripReplicationInformation { get; public set; }
    public bool ShouldDisableVersioningBundle { get; public set; }
    public string NoneDefaultFileName { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_StartFilesEtag();
    [CompilerGeneratedAttribute]
public void set_StartFilesEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_StartFilesDeletionEtag();
    [CompilerGeneratedAttribute]
public void set_StartFilesDeletionEtag(Etag value);
    [CompilerGeneratedAttribute]
public bool get_StripReplicationInformation();
    [CompilerGeneratedAttribute]
public void set_StripReplicationInformation(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldDisableVersioningBundle();
    [CompilerGeneratedAttribute]
public void set_ShouldDisableVersioningBundle(bool value);
    [CompilerGeneratedAttribute]
public string get_NoneDefaultFileName();
    [CompilerGeneratedAttribute]
public void set_NoneDefaultFileName(string value);
}
public static class Raven.Abstractions.Smuggler.SmugglerHelper : object {
    internal static RavenJToken HandleMetadataChanges(RavenJObject metadata, SmugglerDataFormat format);
    public static RavenJToken HandleConflictDocuments(RavenJObject metadata);
    public static RavenJToken DisableVersioning(RavenJObject metadata);
    public static bool TryGetJsonReaderForStream(Stream stream, JsonTextReader& jsonTextReader, CountingStream& sizeStream);
}
public class Raven.Abstractions.Smuggler.SmugglerImportOptions`1 : object {
    [CompilerGeneratedAttribute]
private T <To>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <FromStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIncrementalImport>k__BackingField;
    public T To { get; public set; }
    public string FromFile { get; public set; }
    public Stream FromStream { get; public set; }
    public bool IsIncrementalImport { get; public set; }
    [CompilerGeneratedAttribute]
public T get_To();
    [CompilerGeneratedAttribute]
public void set_To(T value);
    [CompilerGeneratedAttribute]
public string get_FromFile();
    [CompilerGeneratedAttribute]
public void set_FromFile(string value);
    [CompilerGeneratedAttribute]
public Stream get_FromStream();
    [CompilerGeneratedAttribute]
public void set_FromStream(Stream value);
    [CompilerGeneratedAttribute]
public bool get_IsIncrementalImport();
    [CompilerGeneratedAttribute]
public void set_IsIncrementalImport(bool value);
}
public class Raven.Abstractions.Smuggler.SmugglerJsonTextWriter : object {
    private static long Mb;
    private int splitSizeMb;
    private Formatting formatting;
    private string filepath;
    private int splitsCount;
    private LinkedList`1<JsonToken> jsonOperationsStructure;
    private string lastPropertyName;
    private CountingStream currentCountingStream;
    private JsonTextWriter currentJsonTextWriter;
    private GZipStream currentGzipStream;
    private StreamWriter currentStreamWriter;
    private Stream currentStream;
    public SmugglerJsonTextWriter(StreamWriter streamWriter, int splitSizeMb, Formatting formatting, CountingStream countingStream, string filepath);
    public SmugglerJsonTextWriter(StringWriter stringWriter);
    public JsonTextWriter GetCurrentJsonTextWriter();
    private void SpinWriterIfReachedMaxSize();
    public void Write(RavenJObject ravenJObject, JsonConverter[] converters);
    public void Write(RavenJArray ravenJArray, JsonConverter[] converters);
    public void Write(RavenJToken ravenJToken, JsonConverter[] converters);
    private void DisposeStreams();
    public void Flush();
    public void WriteStartObject();
    public void WritePropertyName(string name);
    public void WritePropertyName(string name, bool escape);
    public void WriteStartArray();
    public void WriteEndArray();
    public void WriteEndObject();
    public sealed virtual void Dispose();
}
public enum Raven.Abstractions.Smuggler.SmugglerMode : Enum {
    public int value__;
    public static SmugglerMode Unknown;
    public static SmugglerMode Database;
    public static SmugglerMode Filesystem;
    public static SmugglerMode Counter;
}
public abstract class Raven.Abstractions.Smuggler.SmugglerOptions : object {
    public CancellationTokenSource CancelToken;
    public static int DefaultDocumentSizeInChunkLimitInBytes;
    [CompilerGeneratedAttribute]
private bool <Incremental>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BackupPath>k__BackingField;
    private TimeSpan timeout;
    public string SourceUrl { get; }
    public string DestinationUrl { get; }
    public bool Incremental { get; public set; }
    public string BackupPath { get; public set; }
    public TimeSpan Timeout { get; public set; }
    public abstract virtual string get_SourceUrl();
    public abstract virtual string get_DestinationUrl();
    [CompilerGeneratedAttribute]
public bool get_Incremental();
    [CompilerGeneratedAttribute]
public void set_Incremental(bool value);
    [CompilerGeneratedAttribute]
public string get_BackupPath();
    [CompilerGeneratedAttribute]
public void set_BackupPath(string value);
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
}
public class Raven.Abstractions.Smuggler.SmugglerOptions`1 : SmugglerOptions {
    private int batchSize;
    [CompilerGeneratedAttribute]
private T <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    public T Source { get; public set; }
    public T Destination { get; public set; }
    public string SourceUrl { get; }
    public string DestinationUrl { get; }
    public int Limit { get; public set; }
    public int BatchSize { get; public set; }
    [CompilerGeneratedAttribute]
public T get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(T value);
    [CompilerGeneratedAttribute]
public T get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(T value);
    public virtual string get_SourceUrl();
    public virtual string get_DestinationUrl();
    [CompilerGeneratedAttribute]
public int get_Limit();
    [CompilerGeneratedAttribute]
public void set_Limit(int value);
    public int get_BatchSize();
    public void set_BatchSize(int value);
}
public class Raven.Abstractions.Spatial.GeoJsonWktConverter : object {
    public bool TryConvert(RavenJObject json, String& result);
    private bool TryParseTypeString(RavenJObject obj, String& result);
    private bool TryParseFeature(RavenJObject obj, StringBuilder builder);
    private bool TryParseGeometry(RavenJObject obj, StringBuilder builder);
    private bool TryParsePoint(RavenJObject obj, StringBuilder builder);
    private bool TryParseLineString(RavenJObject obj, StringBuilder builder);
    private bool TryParsePolygon(RavenJObject obj, StringBuilder builder);
    private bool TryParseMultiPoint(RavenJObject obj, StringBuilder builder);
    private bool TryParseMultiLineString(RavenJObject obj, StringBuilder builder);
    private bool TryParseMultiPolygon(RavenJObject obj, StringBuilder builder);
    private bool TryParseGeometryCollection(RavenJObject obj, StringBuilder builder);
    private bool TryParseCoordinate(RavenJArray coordinates, StringBuilder result);
    private bool TryParseCoordinateArray(RavenJArray coordinates, StringBuilder result);
    private bool TryParseCoordinateArrayArray(RavenJArray coordinates, StringBuilder result);
    private bool TryParseCoordinateArrayArrayArray(RavenJArray coordinates, StringBuilder result);
    public object SantizeRavenJObjects(object obj);
    [CompilerGeneratedAttribute]
private object <SantizeRavenJObjects>b__15_1(KeyValuePair`2<string, RavenJToken> x);
}
public class Raven.Abstractions.Spatial.ShapeConverter : object {
    private static GeoJsonWktConverter GeoJsonConverter;
    private static Regex RegexX;
    private static Regex RegexY;
    private static ShapeConverter();
    public virtual bool TryConvert(object value, String& result);
    private bool IsNumber(object obj);
    private double GetDouble(object obj);
    protected string MakePoint(double x, double y);
    protected string MakeCircle(double x, double y, double radius);
    [CompilerGeneratedAttribute]
private bool <TryConvert>b__3_0(KeyValuePair`2<object, object> x);
    [CompilerGeneratedAttribute]
private bool <TryConvert>b__3_3(KeyValuePair`2<string, RavenJToken> x);
}
public class Raven.Abstractions.Spatial.WktSanitizer : object {
    private static Regex RectangleRegex;
    private static Regex DimensionFlagRegex;
    private static Regex ReducerRegex;
    private static WktSanitizer();
    public string Sanitize(string shapeWkt);
}
public interface Raven.Abstractions.Streaming.IOutputWriter {
    public string ContentType { get; }
    public abstract virtual string get_ContentType();
    public abstract virtual void WriteHeader();
    public abstract virtual void Write(RavenJObject result);
    public abstract virtual void WriteError(Exception exception);
    public abstract virtual void Flush();
}
public class Raven.Abstractions.Streaming.JsonOutputWriter : object {
    private static string JsonContentType;
    private Stream stream;
    private JsonWriter writer;
    private bool closedArray;
    public string ContentType { get; }
    public JsonOutputWriter(Stream stream);
    public sealed virtual string get_ContentType();
    public sealed virtual void WriteHeader();
    public sealed virtual void Dispose();
    public sealed virtual void Write(RavenJObject result);
    public sealed virtual void WriteError(Exception exception);
    public sealed virtual void Flush();
}
public static class Raven.Abstractions.SystemTime : object {
    public static double MicroSecPerTick;
    public static Func`1<DateTime> UtcDateTime;
    public static Action`1<int> WaitCalled;
    public static DateTime UtcNow { get; }
    private static SystemTime();
    public static DateTime get_UtcNow();
    public static void Wait(int durationMs);
}
public class Raven.Abstractions.TimeSeries.AggregatedPoint : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartAt>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregationDuration <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregationValue[] <Values>k__BackingField;
    public DateTimeOffset StartAt { get; public set; }
    public AggregationDuration Duration { get; public set; }
    public AggregationValue[] Values { get; public set; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_StartAt();
    [CompilerGeneratedAttribute]
public void set_StartAt(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public AggregationDuration get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(AggregationDuration value);
    [CompilerGeneratedAttribute]
public AggregationValue[] get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(AggregationValue[] value);
}
public class Raven.Abstractions.TimeSeries.AggregationDuration : object {
    [CompilerGeneratedAttribute]
private AggregationDurationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Duration>k__BackingField;
    public AggregationDurationType Type { get; private set; }
    public int Duration { get; private set; }
    public AggregationDuration(AggregationDurationType type, int duration);
    [CompilerGeneratedAttribute]
public AggregationDurationType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(AggregationDurationType value);
    [CompilerGeneratedAttribute]
public int get_Duration();
    [CompilerGeneratedAttribute]
private void set_Duration(int value);
    public static AggregationDuration Seconds(int duration);
    public static AggregationDuration Minutes(int duration);
    public static AggregationDuration Hours(int duration);
    public static AggregationDuration Days(int duration);
    public static AggregationDuration Months(int duration);
    public static AggregationDuration Years(int duration);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public DateTimeOffset AddToDateTime(DateTimeOffset start);
    public DateTimeOffset GetStartOfRangeForDateTime(DateTimeOffset pointAt);
}
public enum Raven.Abstractions.TimeSeries.AggregationDurationType : Enum {
    public int value__;
    public static AggregationDurationType Seconds;
    public static AggregationDurationType Minutes;
    public static AggregationDurationType Hours;
    public static AggregationDurationType Days;
    public static AggregationDurationType Months;
    public static AggregationDurationType Years;
}
public enum Raven.Abstractions.TimeSeries.Notifications.BatchType : Enum {
    public int value__;
    public static BatchType Started;
    public static BatchType Ended;
    public static BatchType Error;
}
public class Raven.Abstractions.TimeSeries.Notifications.BulkOperationNotification : TimeSeriesNotification {
    [CompilerGeneratedAttribute]
private Guid <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private BatchType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public Guid OperationId { get; public set; }
    public BatchType Type { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_OperationId();
    [CompilerGeneratedAttribute]
public void set_OperationId(Guid value);
    [CompilerGeneratedAttribute]
public BatchType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(BatchType value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
public enum Raven.Abstractions.TimeSeries.Notifications.TimeSeriesChangeAction : Enum {
    public int value__;
    public static TimeSeriesChangeAction None;
    public static TimeSeriesChangeAction Append;
    public static TimeSeriesChangeAction Delete;
    public static TimeSeriesChangeAction DeleteInRange;
}
public class Raven.Abstractions.TimeSeries.Notifications.TimeSeriesChangeNotification : TimeSeriesNotification {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesChangeAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <At>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <End>k__BackingField;
    public string Type { get; public set; }
    public string Key { get; public set; }
    public TimeSeriesChangeAction Action { get; public set; }
    public DateTimeOffset At { get; public set; }
    public Double[] Values { get; public set; }
    public DateTimeOffset Start { get; public set; }
    public DateTimeOffset End { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public TimeSeriesChangeAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(TimeSeriesChangeAction value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_At();
    [CompilerGeneratedAttribute]
public void set_At(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Double[] get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(Double[] value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_End();
    [CompilerGeneratedAttribute]
public void set_End(DateTimeOffset value);
}
public class Raven.Abstractions.TimeSeries.Notifications.TimeSeriesNotification : object {
}
public class Raven.Abstractions.TimeSeries.TimeSeriesAppend : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <At>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<object> <Done>k__BackingField;
    public string Type { get; public set; }
    public string Key { get; public set; }
    public DateTimeOffset At { get; public set; }
    public Double[] Values { get; public set; }
    [JsonIgnoreAttribute]
public TaskCompletionSource`1<object> Done { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_At();
    [CompilerGeneratedAttribute]
public void set_At(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Double[] get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(Double[] value);
    [CompilerGeneratedAttribute]
public TaskCompletionSource`1<object> get_Done();
    [CompilerGeneratedAttribute]
public void set_Done(TaskCompletionSource`1<object> value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesBackupRequest : object {
    [CompilerGeneratedAttribute]
private string <BackupLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesDocument <TimeSeriesDocument>k__BackingField;
    public string BackupLocation { get; public set; }
    public TimeSeriesDocument TimeSeriesDocument { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BackupLocation();
    [CompilerGeneratedAttribute]
public void set_BackupLocation(string value);
    [CompilerGeneratedAttribute]
public TimeSeriesDocument get_TimeSeriesDocument();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesDocument(TimeSeriesDocument value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesBatchOptions : object {
    [CompilerGeneratedAttribute]
private int <BatchSizeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchReadTimeoutInMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectionReopenTimingInMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StreamingInitializeTimeout>k__BackingField;
    public int BatchSizeLimit { get; public set; }
    public int BatchReadTimeoutInMilliseconds { get; public set; }
    public int ConnectionReopenTimingInMilliseconds { get; public set; }
    public int StreamingInitializeTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public int get_BatchSizeLimit();
    [CompilerGeneratedAttribute]
public void set_BatchSizeLimit(int value);
    [CompilerGeneratedAttribute]
public int get_BatchReadTimeoutInMilliseconds();
    [CompilerGeneratedAttribute]
public void set_BatchReadTimeoutInMilliseconds(int value);
    [CompilerGeneratedAttribute]
public int get_ConnectionReopenTimingInMilliseconds();
    [CompilerGeneratedAttribute]
public void set_ConnectionReopenTimingInMilliseconds(int value);
    [CompilerGeneratedAttribute]
public int get_StreamingInitializeTimeout();
    [CompilerGeneratedAttribute]
public void set_StreamingInitializeTimeout(int value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesDelete : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<object> <Done>k__BackingField;
    public string Type { get; public set; }
    public string Key { get; public set; }
    [JsonIgnoreAttribute]
public TaskCompletionSource`1<object> Done { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public TaskCompletionSource`1<object> get_Done();
    [CompilerGeneratedAttribute]
public void set_Done(TaskCompletionSource`1<object> value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesDeleteRange : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <End>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<object> <Done>k__BackingField;
    public string Type { get; public set; }
    public string Key { get; public set; }
    public DateTimeOffset Start { get; public set; }
    public DateTimeOffset End { get; public set; }
    [JsonIgnoreAttribute]
public TaskCompletionSource`1<object> Done { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_End();
    [CompilerGeneratedAttribute]
public void set_End(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public TaskCompletionSource`1<object> get_Done();
    [CompilerGeneratedAttribute]
public void set_Done(TaskCompletionSource`1<object> value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesDestinationStats : object {
    public int FailureCountInternal;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastHeartbeatReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastReplicatedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastReplicatedLastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastSuccessTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastFailureTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastError>k__BackingField;
    public string Url { get; public set; }
    public Nullable`1<DateTime> LastHeartbeatReceived { get; public set; }
    public long LastReplicatedEtag { get; public set; }
    public Nullable`1<DateTime> LastReplicatedLastModified { get; public set; }
    public Nullable`1<DateTime> LastSuccessTimestamp { get; public set; }
    public Nullable`1<DateTime> LastFailureTimestamp { get; public set; }
    public int FailureCount { get; }
    public string LastError { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastHeartbeatReceived();
    [CompilerGeneratedAttribute]
public void set_LastHeartbeatReceived(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public long get_LastReplicatedEtag();
    [CompilerGeneratedAttribute]
public void set_LastReplicatedEtag(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastReplicatedLastModified();
    [CompilerGeneratedAttribute]
public void set_LastReplicatedLastModified(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastSuccessTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastSuccessTimestamp(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastFailureTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastFailureTimestamp(Nullable`1<DateTime> value);
    public int get_FailureCount();
    [CompilerGeneratedAttribute]
public string get_LastError();
    [CompilerGeneratedAttribute]
public void set_LastError(string value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesDocument : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <SecuredSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    public string Id { get; public set; }
    public Dictionary`2<string, string> Settings { get; public set; }
    public Dictionary`2<string, string> SecuredSettings { get; public set; }
    public bool Disabled { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_SecuredSettings();
    [CompilerGeneratedAttribute]
public void set_SecuredSettings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesFullPoint : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <At>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Values>k__BackingField;
    public string Type { get; public set; }
    public string Key { get; public set; }
    public DateTimeOffset At { get; public set; }
    public Double[] Values { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_At();
    [CompilerGeneratedAttribute]
public void set_At(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Double[] get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(Double[] value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesKey : object {
    [CompilerGeneratedAttribute]
private TimeSeriesType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PointsCount>k__BackingField;
    public TimeSeriesType Type { get; public set; }
    public string Key { get; public set; }
    public long PointsCount { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSeriesType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TimeSeriesType value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public long get_PointsCount();
    [CompilerGeneratedAttribute]
public void set_PointsCount(long value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesKeySummary : object {
    [CompilerGeneratedAttribute]
private TimeSeriesType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PointsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <MinPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <MaxPoint>k__BackingField;
    public TimeSeriesType Type { get; public set; }
    public string Key { get; public set; }
    public long PointsCount { get; public set; }
    public DateTimeOffset MinPoint { get; public set; }
    public DateTimeOffset MaxPoint { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSeriesType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TimeSeriesType value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public long get_PointsCount();
    [CompilerGeneratedAttribute]
public void set_PointsCount(long value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_MinPoint();
    [CompilerGeneratedAttribute]
public void set_MinPoint(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_MaxPoint();
    [CompilerGeneratedAttribute]
public void set_MaxPoint(DateTimeOffset value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesMetrics : object {
    [CompilerGeneratedAttribute]
private double <RequestsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <Appends>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <Deletes>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <ClientRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <IncomingReplications>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterData <OutgoingReplications>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramData <RequestsDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MeterData> <ReplicationBatchSizeMeter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, HistogramData> <ReplicationBatchSizeHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, HistogramData> <ReplicationDurationHistogram>k__BackingField;
    public double RequestsPerSecond { get; public set; }
    public MeterData Appends { get; public set; }
    public MeterData Deletes { get; public set; }
    public MeterData ClientRequests { get; public set; }
    public MeterData IncomingReplications { get; public set; }
    public MeterData OutgoingReplications { get; public set; }
    public HistogramData RequestsDuration { get; public set; }
    public Dictionary`2<string, MeterData> ReplicationBatchSizeMeter { get; public set; }
    public Dictionary`2<string, HistogramData> ReplicationBatchSizeHistogram { get; public set; }
    public Dictionary`2<string, HistogramData> ReplicationDurationHistogram { get; public set; }
    [CompilerGeneratedAttribute]
public double get_RequestsPerSecond();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSecond(double value);
    [CompilerGeneratedAttribute]
public MeterData get_Appends();
    [CompilerGeneratedAttribute]
public void set_Appends(MeterData value);
    [CompilerGeneratedAttribute]
public MeterData get_Deletes();
    [CompilerGeneratedAttribute]
public void set_Deletes(MeterData value);
    [CompilerGeneratedAttribute]
public MeterData get_ClientRequests();
    [CompilerGeneratedAttribute]
public void set_ClientRequests(MeterData value);
    [CompilerGeneratedAttribute]
public MeterData get_IncomingReplications();
    [CompilerGeneratedAttribute]
public void set_IncomingReplications(MeterData value);
    [CompilerGeneratedAttribute]
public MeterData get_OutgoingReplications();
    [CompilerGeneratedAttribute]
public void set_OutgoingReplications(MeterData value);
    [CompilerGeneratedAttribute]
public HistogramData get_RequestsDuration();
    [CompilerGeneratedAttribute]
public void set_RequestsDuration(HistogramData value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MeterData> get_ReplicationBatchSizeMeter();
    [CompilerGeneratedAttribute]
public void set_ReplicationBatchSizeMeter(Dictionary`2<string, MeterData> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, HistogramData> get_ReplicationBatchSizeHistogram();
    [CompilerGeneratedAttribute]
public void set_ReplicationBatchSizeHistogram(Dictionary`2<string, HistogramData> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, HistogramData> get_ReplicationDurationHistogram();
    [CompilerGeneratedAttribute]
public void set_ReplicationDurationHistogram(Dictionary`2<string, HistogramData> value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesPoint : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <At>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Values>k__BackingField;
    public DateTimeOffset At { get; public set; }
    public Double[] Values { get; public set; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_At();
    [CompilerGeneratedAttribute]
public void set_At(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Double[] get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(Double[] value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesPointId : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <At>k__BackingField;
    public string Type { get; public set; }
    public string Key { get; public set; }
    public DateTimeOffset At { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_At();
    [CompilerGeneratedAttribute]
public void set_At(DateTimeOffset value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesReplicationDestination : object {
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeSeriesName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    public string ServerUrl { get; public set; }
    public string TimeSeriesName { get; public set; }
    public string TimeSeriesUrl { get; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string Domain { get; public set; }
    public string ApiKey { get; public set; }
    public bool Disabled { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
public void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public string get_TimeSeriesName();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesName(string value);
    public string get_TimeSeriesUrl();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    protected bool Equals(TimeSeriesReplicationDestination other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Abstractions.TimeSeries.TimeSeriesReplicationDocument : object {
    [CompilerGeneratedAttribute]
private List`1<TimeSeriesReplicationDestination> <Destinations>k__BackingField;
    public List`1<TimeSeriesReplicationDestination> Destinations { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TimeSeriesReplicationDestination> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(List`1<TimeSeriesReplicationDestination> value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesReplicationStats : object {
    [CompilerGeneratedAttribute]
private List`1<TimeSeriesDestinationStats> <Stats>k__BackingField;
    public List`1<TimeSeriesDestinationStats> Stats { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TimeSeriesDestinationStats> get_Stats();
    [CompilerGeneratedAttribute]
public void set_Stats(List`1<TimeSeriesDestinationStats> value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesRestoreRequest : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BackupLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RestoreToLocation>k__BackingField;
    public string Id { get; public set; }
    public string BackupLocation { get; public set; }
    public string RestoreToLocation { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_BackupLocation();
    [CompilerGeneratedAttribute]
public void set_BackupLocation(string value);
    [CompilerGeneratedAttribute]
public string get_RestoreToLocation();
    [CompilerGeneratedAttribute]
public void set_RestoreToLocation(string value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesStats : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeSeriesSize>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RequestsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TypesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <KeysCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PointsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplicationTasksCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ReplicatedServersCount>k__BackingField;
    public string Name { get; public set; }
    public string Url { get; public set; }
    public string TimeSeriesSize { get; public set; }
    public double RequestsPerSecond { get; public set; }
    public long TypesCount { get; public set; }
    public long KeysCount { get; public set; }
    public long PointsCount { get; public set; }
    public long LastEtag { get; public set; }
    public int ReplicationTasksCount { get; public set; }
    public long ReplicatedServersCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_TimeSeriesSize();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesSize(string value);
    [CompilerGeneratedAttribute]
public double get_RequestsPerSecond();
    [CompilerGeneratedAttribute]
public void set_RequestsPerSecond(double value);
    [CompilerGeneratedAttribute]
public long get_TypesCount();
    [CompilerGeneratedAttribute]
public void set_TypesCount(long value);
    [CompilerGeneratedAttribute]
public long get_KeysCount();
    [CompilerGeneratedAttribute]
public void set_KeysCount(long value);
    [CompilerGeneratedAttribute]
public long get_PointsCount();
    [CompilerGeneratedAttribute]
public void set_PointsCount(long value);
    [CompilerGeneratedAttribute]
public long get_LastEtag();
    [CompilerGeneratedAttribute]
public void set_LastEtag(long value);
    [CompilerGeneratedAttribute]
public int get_ReplicationTasksCount();
    [CompilerGeneratedAttribute]
public void set_ReplicationTasksCount(int value);
    [CompilerGeneratedAttribute]
public long get_ReplicatedServersCount();
    [CompilerGeneratedAttribute]
public void set_ReplicatedServersCount(long value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesType : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private long <KeysCount>k__BackingField;
    public string Type { get; public set; }
    public String[] Fields { get; public set; }
    public long KeysCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public String[] get_Fields();
    [CompilerGeneratedAttribute]
public void set_Fields(String[] value);
    [CompilerGeneratedAttribute]
public long get_KeysCount();
    [CompilerGeneratedAttribute]
public void set_KeysCount(long value);
}
public class Raven.Abstractions.TimeSeries.TimeSeriesView : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OverallTotal>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ServerValue> <Servers>k__BackingField;
    public string Name { get; public set; }
    public string Group { get; public set; }
    public long OverallTotal { get; public set; }
    public List`1<ServerValue> Servers { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public long get_OverallTotal();
    [CompilerGeneratedAttribute]
public void set_OverallTotal(long value);
    [CompilerGeneratedAttribute]
public List`1<ServerValue> get_Servers();
    [CompilerGeneratedAttribute]
public void set_Servers(List`1<ServerValue> value);
}
internal class Raven.Abstractions.Util.ABCDStruct : ValueType {
    public UInt32 A;
    public UInt32 B;
    public UInt32 C;
    public UInt32 D;
}
public static class Raven.Abstractions.Util.AssemblyHelper : object {
    public static string GetAssemblyLocationFor();
    public static string GetAssemblyLocationFor(Type type);
}
public class Raven.Abstractions.Util.AsyncEnumeratorBridge`1 : object {
    private IEnumerator`1<T> enumerator;
    public T Current { get; }
    public AsyncEnumeratorBridge`1(IEnumerator`1<T> enumerator);
    public sealed virtual void Dispose();
    public sealed virtual Task`1<bool> MoveNextAsync();
    public sealed virtual T get_Current();
}
public static class Raven.Abstractions.Util.AsyncHelpers : object {
    public static void RunSync(Func`1<Task> task);
    public static T RunSync(Func`1<Task`1<T>> task);
}
public class Raven.Abstractions.Util.AsyncManualResetEvent : object {
    private TaskCompletionSource`1<bool> tcs;
    public Task WaitAsync();
    [AsyncStateMachineAttribute("Raven.Abstractions.Util.AsyncManualResetEvent/<WaitAsync>d__2")]
public Task`1<bool> WaitAsync(int timeout);
    [AsyncStateMachineAttribute("Raven.Abstractions.Util.AsyncManualResetEvent/<WaitAsync>d__3")]
public Task`1<bool> WaitAsync(int timeout, CancellationToken cancellationToken);
    public void Set();
    public void Reset();
}
public class Raven.Abstractions.Util.AtomicDictionary`1 : object {
    private ConcurrentDictionary`2<string, object> locks;
    private ConcurrentDictionary`2<string, TVal> items;
    private EasyReaderWriterLock globalLocker;
    private List`1<TVal> snapshot;
    private long snapshotVersion;
    private long version;
    private static string NullValue;
    public IEnumerable`1<TVal> Values { get; }
    public List`1<TVal> ValuesSnapshot { get; }
    public AtomicDictionary`1(IEqualityComparer`1<string> comparer);
    private static AtomicDictionary`1();
    public IEnumerable`1<TVal> get_Values();
    public TVal GetOrAdd(string key, Func`2<string, TVal> valueGenerator);
    public List`1<TVal> get_ValuesSnapshot();
    public void Set(string key, Func`2<string, TVal> valueGenerator);
    public void Remove(string key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, TVal>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Clear();
    public bool TryGetValue(string key, TVal& val);
    public bool TryRemove(string key, TVal& val);
    public IDisposable WithAllLocks();
    public IDisposable TryWithAllLocks();
}
public class Raven.Abstractions.Util.Base62Util : object {
    public static string Base62Random();
    private static string Base62ToString(long value);
    private static char ValToChar(long value);
    public static string ToBase62(Guid guid);
}
public class Raven.Abstractions.Util.ByteArrayComparer : object {
    public static ByteArrayComparer Instance;
    private static ByteArrayComparer();
    public sealed virtual int Compare(Guid x, Guid y);
    public sealed virtual int Compare(Nullable`1<Guid> x, Nullable`1<Guid> y);
}
public class Raven.Abstractions.Util.ComparableByteArray : object {
    private Byte[] inner;
    public ComparableByteArray(Etag etag);
    public ComparableByteArray(Byte[] inner);
    public sealed virtual int CompareTo(ComparableByteArray other);
    public int CompareTo(Byte[] otherBuffer);
    public static int CompareTo(Byte[] firstBuffer, Byte[] otherBuffer);
    public sealed virtual int CompareTo(object obj);
    public int CompareTo(Etag obj);
    public int CompareTo(Guid obj);
    public Guid ToGuid();
    public Etag ToEtag();
    public virtual string ToString();
}
public class Raven.Abstractions.Util.CompletedTask : CompletedTask`1<object> {
    public Task Task { get; }
    public CompletedTask(Exception error);
    public Task get_Task();
    public static CompletedTask`1<T> With(T result);
}
public class Raven.Abstractions.Util.CompletedTask`1 : object {
    private Exception error;
    public T Result;
    public Task`1<T> Task { get; }
    public CompletedTask`1(T result);
    public CompletedTask`1(Exception error);
    public Task`1<T> get_Task();
    public static Task`1<T> op_Implicit(CompletedTask`1<T> t);
    public static Task op_Implicit(CompletedTask`1<T> t);
}
public static class Raven.Abstractions.Util.DocumentHelpers : object {
    public static long GetRoughSize(RavenJToken token);
    public static IEnumerable`1<string> GetPropertiesFromDocuments(IEnumerable`1<JsonDocument> jsonDocuments, bool includeNestedProperties);
    public static IEnumerable`1<string> GetMetadataFromDocuments(IEnumerable`1<JsonDocument> jsonDocuments, bool includeNestedProperties);
    public static IEnumerable`1<string> GetPropertiesFromJObjects(IEnumerable`1<RavenJObject> jObjects, bool includeNestedProperties, bool includeMetadata, bool excludeParentPropertyNames);
    [IteratorStateMachineAttribute("Raven.Abstractions.Util.DocumentHelpers/<GetPropertiesFromJObject>d__4")]
public static IEnumerable`1<string> GetPropertiesFromJObject(RavenJObject jObject, string parentPropertyPath, bool includeNestedProperties, bool includeMetadata, bool excludeParentPropertyNames);
}
public class Raven.Abstractions.Util.EasyReaderWriterLock : object {
    private ReaderWriterLockSlim inner;
    public IDisposable EnterReadLock();
    public IDisposable EnterWriteLock();
    public IDisposable TryEnterWriteLock(TimeSpan ts);
}
public class Raven.Abstractions.Util.Encryptors.DefaultEncryptor : EncryptorBase`3<DefaultHashEncryptor, FipsSymmetricalEncryptor, FipsAsymmetricalEncryptor> {
    [CompilerGeneratedAttribute]
private IHashEncryptor <Hash>k__BackingField;
    public IHashEncryptor Hash { get; protected set; }
    [CompilerGeneratedAttribute]
public virtual IHashEncryptor get_Hash();
    [CompilerGeneratedAttribute]
protected virtual void set_Hash(IHashEncryptor value);
}
public static class Raven.Abstractions.Util.Encryptors.Encryptor : object {
    [CompilerGeneratedAttribute]
private static IEncryptor <Current>k__BackingField;
    public static IEncryptor Current { get; private set; }
    public static Lazy`1<bool> IsFipsEnabled { get; }
    private static Encryptor();
    [CompilerGeneratedAttribute]
public static IEncryptor get_Current();
    [CompilerGeneratedAttribute]
private static void set_Current(IEncryptor value);
    public static Lazy`1<bool> get_IsFipsEnabled();
    public static void Initialize(bool useFips);
}
public abstract class Raven.Abstractions.Util.Encryptors.EncryptorBase`3 : object {
    public IHashEncryptor Hash { get; protected set; }
    public abstract virtual IHashEncryptor get_Hash();
    protected abstract virtual void set_Hash(IHashEncryptor value);
    public sealed virtual IHashEncryptor CreateHash();
    public sealed virtual ISymmetricalEncryptor CreateSymmetrical();
    public sealed virtual ISymmetricalEncryptor CreateSymmetrical(int keySize);
    public sealed virtual IAsymmetricalEncryptor CreateAsymmetrical();
    public sealed virtual IAsymmetricalEncryptor CreateAsymmetrical(Byte[] exponent, Byte[] modulus);
    public sealed virtual IAsymmetricalEncryptor CreateAsymmetrical(int keySize);
}
public class Raven.Abstractions.Util.Encryptors.FipsEncryptor : EncryptorBase`3<FipsHashEncryptor, FipsSymmetricalEncryptor, FipsAsymmetricalEncryptor> {
    [CompilerGeneratedAttribute]
private IHashEncryptor <Hash>k__BackingField;
    public IHashEncryptor Hash { get; protected set; }
    [CompilerGeneratedAttribute]
public virtual IHashEncryptor get_Hash();
    [CompilerGeneratedAttribute]
protected virtual void set_Hash(IHashEncryptor value);
}
public abstract class Raven.Abstractions.Util.Encryptors.HashEncryptorBase : object {
    [CompilerGeneratedAttribute]
private bool <AllowNonThreadSafeMethods>k__BackingField;
    protected bool AllowNonThreadSafeMethods { get; private set; }
    protected HashEncryptorBase(bool allowNonThreadSafeMethods);
    [CompilerGeneratedAttribute]
protected bool get_AllowNonThreadSafeMethods();
    [CompilerGeneratedAttribute]
private void set_AllowNonThreadSafeMethods(bool value);
    protected Byte[] ComputeHashInternal(HashAlgorithm algorithm, Byte[] bytes, Nullable`1<int> size);
    protected Byte[] ComputeHashInternal(HashAlgorithm algorithm, Byte[] bytes, int offset, int count, Nullable`1<int> size);
    public Byte[] ComputeHash(HashAlgorithm algorithm, Byte[] bytes, Nullable`1<int> size);
    public Byte[] ComputeHash(HashAlgorithm algorithm, Byte[] bytes, int offset, int count, Nullable`1<int> size);
    protected void ThrowNotSupportedExceptionForNonThreadSafeMethod();
}
public interface Raven.Abstractions.Util.Encryptors.IAsymmetricalEncryptor {
    public int KeySize { get; public set; }
    public AsymmetricAlgorithm Algorithm { get; }
    public abstract virtual int get_KeySize();
    public abstract virtual void set_KeySize(int value);
    public abstract virtual void ImportParameters(Byte[] exponent, Byte[] modulus);
    public abstract virtual Byte[] Encrypt(Byte[] bytes, bool fOAEP);
    public abstract virtual void ImportCspBlob(Byte[] keyBlob);
    public abstract virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public abstract virtual Byte[] SignHash(Byte[] hash, string str);
    public abstract virtual bool VerifyHash(Byte[] hash, string str, Byte[] signature);
    public abstract virtual Byte[] Decrypt(Byte[] bytes, bool fOAEP);
    public abstract virtual void FromXmlString(string xml);
    public abstract virtual AsymmetricAlgorithm get_Algorithm();
    public abstract virtual void ImportParameters(RSAParameters parameters);
    public abstract virtual RSAParameters ExportParameters(bool includePrivateParameters);
}
public interface Raven.Abstractions.Util.Encryptors.IEncryptor {
    public IHashEncryptor Hash { get; }
    public abstract virtual IHashEncryptor get_Hash();
    public abstract virtual IHashEncryptor CreateHash();
    public abstract virtual ISymmetricalEncryptor CreateSymmetrical();
    public abstract virtual ISymmetricalEncryptor CreateSymmetrical(int keySize);
    public abstract virtual IAsymmetricalEncryptor CreateAsymmetrical();
    public abstract virtual IAsymmetricalEncryptor CreateAsymmetrical(Byte[] exponent, Byte[] modulus);
    public abstract virtual IAsymmetricalEncryptor CreateAsymmetrical(int keySize);
}
public interface Raven.Abstractions.Util.Encryptors.IHashEncryptor {
    public int StorageHashSize { get; }
    public abstract virtual int get_StorageHashSize();
    public abstract virtual Byte[] ComputeForOAuth(Byte[] bytes);
    public abstract virtual Byte[] Compute16(Byte[] bytes);
    public abstract virtual Byte[] Compute16(Stream stream);
    public abstract virtual Byte[] Compute16(Byte[] bytes, int offset, int size);
    public abstract virtual Byte[] Compute20(Byte[] bytes);
    public abstract virtual Byte[] Compute20(Byte[] bytes, int offset, int size);
    public abstract virtual Byte[] TransformFinalBlock();
    public abstract virtual void TransformBlock(Byte[] bytes, int offset, int length);
}
public interface Raven.Abstractions.Util.Encryptors.ISymmetricalEncryptor {
    public Byte[] Key { get; public set; }
    public Byte[] IV { get; public set; }
    public int KeySize { get; public set; }
    public abstract virtual Byte[] get_Key();
    public abstract virtual void set_Key(Byte[] value);
    public abstract virtual Byte[] get_IV();
    public abstract virtual void set_IV(Byte[] value);
    public abstract virtual int get_KeySize();
    public abstract virtual void set_KeySize(int value);
    public abstract virtual void GenerateKey();
    public abstract virtual void GenerateIV();
    public abstract virtual ICryptoTransform CreateEncryptor();
    public abstract virtual ICryptoTransform CreateDecryptor();
    public abstract virtual ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv);
}
public static class Raven.Abstractions.Util.EscapingHelper : object {
    public static string EscapeLongDataString(string data);
    public static string UnescapeLongDataString(string data);
}
[ExtensionAttribute]
public static class Raven.Abstractions.Util.EtagUtil : object {
    public static Etag Increment(Etag etag, int amount);
    public static long GetChangesCount(Etag etag);
    public static bool IsGreaterThan(Etag x, Etag y);
    public static bool IsGreaterThanOrEqual(Etag x, Etag y);
    [ExtensionAttribute]
public static Byte[] TransformToValueForEsentSorting(Etag etag);
}
internal class Raven.Abstractions.Util.Gen2GcCallback : CriticalFinalizerObject {
    private Func`2<object, bool> m_callback;
    private GCHandle m_weakTargetObj;
    public static void Register(Func`2<object, bool> callback, object targetObj);
    [SecuritySafeCriticalAttribute]
private void Setup(Func`2<object, bool> callback, object targetObj);
    [SecuritySafeCriticalAttribute]
protected virtual override void Finalize();
}
public static class Raven.Abstractions.Util.HttpMethods : object {
    public static HttpMethod Reset;
    public static HttpMethod Patch;
    public static HttpMethod Eval;
    public static HttpMethod Get;
    public static HttpMethod Post;
    public static HttpMethod Put;
    public static HttpMethod Delete;
    public static HttpMethod Head;
    private static HttpMethods();
}
public interface Raven.Abstractions.Util.IAsyncEnumerator`1 {
    public T Current { get; }
    public abstract virtual Task`1<bool> MoveNextAsync();
    public abstract virtual T get_Current();
}
public class Raven.Abstractions.Util.IncludesUtil : object {
    private static Regex includePrefixRegex;
    private static IncludesUtil();
    private static IncludePath GetIncludePath(string include);
    private static void ExecuteInternal(RavenJToken token, string prefix, Func`3<string, string, bool> loadId);
    public static void Include(RavenJObject document, string include, Func`2<string, bool> loadId);
}
public static class Raven.Abstractions.Util.IndexPrettyPrinter : object {
    public static string TryFormat(string code);
    public static string FormatOrError(string code);
    private static string FormatInternal(string code);
}
public class Raven.Abstractions.Util.IndexPrettyPrinterEqualityComparer : object {
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
}
public class Raven.Abstractions.Util.InterlockedLock : object {
    private int lockStatus;
    private static int Locked;
    private static int UnLocked;
    public bool TryEnter();
    public void Exit();
}
public class Raven.Abstractions.Util.MalformedLineException : Exception {
    public MalformedLineException(string message);
    public MalformedLineException(string message, Exception inner);
}
public class Raven.Abstractions.Util.MD5Core : object {
    public static Byte[] GetHash(string input, Encoding encoding);
    public static Byte[] GetHash(string input);
    public static string GetHashString(Byte[] input);
    public static string GetHashString(string input, Encoding encoding);
    public static string GetHashString(string input);
    internal static ABCDStruct GetInitialStruct();
    public static Byte[] GetHash(Byte[] input);
    public static Byte[] GetHash(Byte[] input, int offset, int length);
    internal static Byte[] GetHashFinalBlock(Byte[] input, int ibStart, int cbSize, ABCDStruct ABCD, long len);
    internal static void GetHashBlock(Byte[] input, ABCDStruct& ABCDValue, int ibStart);
    private static UInt32 r1(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 r2(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 r3(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 r4(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, int s, UInt32 t);
    private static UInt32 LSR(UInt32 i, int s);
    private static UInt32[] Converter(Byte[] input, int ibStart);
}
public class Raven.Abstractions.Util.MiniMetrics.ActionScheduler : object {
    private Thread _schedulerThread;
    private ManualResetEvent _done;
    private ConcurrentSet`1<MeterMetric> _scheduledActions;
    private ILog _logger;
    private int _tickIntervalInNanoseconds;
    private void SchedulerTicking();
    public void StartTickingMetric(TimeSpan interval, MeterMetric tickable);
    public void StopTickingMetric(MeterMetric tickable);
    public sealed virtual void Dispose();
}
public class Raven.Abstractions.Util.MiniMetrics.Clock : object {
    public static int NanosecondsInSecond;
    public static int NanosecondsInMillisecond;
    public static long FrequencyFactor;
    public static long Nanoseconds { get; }
    public static long Milliseconds { get; }
    private static Clock();
    public static long get_Nanoseconds();
    public static long get_Milliseconds();
}
public class Raven.Abstractions.Util.MiniMetrics.Ewma : object {
    private static int Interval;
    private static double SecondsPerMinute;
    private static int OneMinute;
    private static int FiveMinutes;
    private static int FifteenMinutes;
    private static double M1Second;
    private static double M1Alpha;
    private static double M5Alpha;
    private static double M15Alpha;
    private double _alpha;
    private double _interval;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _initialized;
    private double _rate;
    private long _uncounted;
    public Ewma(double alpha, long interval);
    private static Ewma();
    public static Ewma OneSecondEwma();
    public static Ewma OneMinuteEwma();
    public static Ewma FiveMinuteEwma();
    public static Ewma FifteenMinuteEwma();
    public void Update(long value);
    public void Tick();
    public double GetRate();
}
public class Raven.Abstractions.Util.MiniMetrics.MeterMetric : object {
    private long _count;
    private int _currentTickCount;
    private Ewma _m15Rate;
    private Ewma _m1Rate;
    private Ewma _m5Rate;
    private Ewma _s1Rate;
    private MetricsScheduler _tickScheduler;
    private long _startTime;
    public double OneSecondRate { get; }
    public double FifteenMinuteRate { get; }
    public double FiveMinuteRate { get; }
    public double OneMinuteRate { get; }
    public double MeanRate { get; }
    public long Count { get; }
    public MeterMetric(MetricsScheduler scheduler);
    public double get_OneSecondRate();
    public double get_FifteenMinuteRate();
    public double get_FiveMinuteRate();
    public double get_OneMinuteRate();
    public double get_MeanRate();
    public long get_Count();
    public sealed virtual void Dispose();
    public MeterValue GetValue();
    public void Tick();
    public void Mark(long val);
    public double GetMeanRate(double elapsed);
    public void Mark();
}
public class Raven.Abstractions.Util.MiniMetrics.MeterValue : ValueType {
    public long Count;
    public double MeanRate;
    public double OneMinuteRate;
    public double FiveMinuteRate;
    public double FifteenMinuteRate;
    [JsonConstructorAttribute]
public MeterValue(long count, double meanRate, double oneMinuteRate, double fiveMinuteRate, double fifteenMinuteRate);
}
public class Raven.Abstractions.Util.MiniMetrics.MetricsScheduler : object {
    public static MetricsScheduler Instance;
    private ConcurrentSet`1<MeterMetric> _scheduledActions;
    private Task perSecondCounterMetricsTask;
    private Task meterMetricsTask;
    private CancellationTokenSource cts;
    private static MetricsScheduler();
    public void StartTickingMetric(MeterMetric meterMetric);
    public void StopTickingMetric(MeterMetric meterMetric);
    private Task CreateTask(int baseInterval, ConcurrentSet`1<MeterMetric> concurrentSet);
    public sealed virtual void Dispose();
}
public class Raven.Abstractions.Util.PinnableBufferCache : object {
    private static int DefaultNumberOfBuffers;
    private string m_CacheName;
    private Func`1<object> m_factory;
    private ConcurrentStack`1<object> m_FreeList;
    private List`1<object> m_NotGen2;
    private int m_gen1CountAtLastRestock;
    private int m_msecNoUseBeyondFreeListSinceThisTime;
    private bool m_moreThanFreeListNeeded;
    private int m_buffersUnderManagement;
    private int m_restockSize;
    private bool m_trimmingExperimentInProgress;
    private int m_minBufferCount;
    private int m_numAllocCalls;
    public PinnableBufferCache(string cacheName, int numberOfElements);
    [SecuritySafeCriticalAttribute]
internal PinnableBufferCache(string cacheName, Func`1<object> factory);
    public Byte[] AllocateBuffer();
    public void FreeBuffer(Byte[] buffer);
    [SecuritySafeCriticalAttribute]
internal object Allocate();
    [SecuritySafeCriticalAttribute]
internal void Free(object buffer);
    [SecuritySafeCriticalAttribute]
private void Restock(Object& returnBuffer);
    [SecuritySafeCriticalAttribute]
private bool AgePendingBuffers();
    private void CreateNewBuffers();
    [SecuritySafeCriticalAttribute]
private static bool Gen2GcCallbackFunc(object targetObj);
    [SecuritySafeCriticalAttribute]
private bool TrimFreeListIfNeeded();
}
[EventSourceAttribute]
internal class Raven.Abstractions.Util.PinnableBufferCacheEventSource : EventSource {
    public static PinnableBufferCacheEventSource Log;
    private static PinnableBufferCacheEventSource();
    [EventAttribute("1")]
public void DebugMessage(string message);
    [EventAttribute("2")]
public void DebugMessage1(string message, long value);
    [EventAttribute("3")]
public void DebugMessage2(string message, long value1, long value2);
    [EventAttribute("18")]
public void DebugMessage3(string message, long value1, long value2, long value3);
    [EventAttribute("4")]
public void Create(string cacheName);
    [EventAttribute("5")]
public void AllocateBuffer(string cacheName, ulong objectId, int objectHash, int objectGen, int freeCountAfter);
    [EventAttribute("6")]
public void AllocateBufferFromNotGen2(string cacheName, int notGen2CountAfter);
    [EventAttribute("7")]
public void AllocateBufferCreatingNewBuffers(string cacheName, int totalBuffsBefore, int objectCount);
    [EventAttribute("8")]
public void AllocateBufferAged(string cacheName, int agedCount);
    [EventAttribute("9")]
public void AllocateBufferFreeListEmpty(string cacheName, int notGen2CountBefore);
    [EventAttribute("10")]
public void FreeBuffer(string cacheName, ulong objectId, int objectHash, int freeCountBefore);
    [EventAttribute("11")]
public void FreeBufferStillTooYoung(string cacheName, int notGen2CountBefore);
    [EventAttribute("13")]
public void TrimCheck(string cacheName, int totalBuffs, bool neededMoreThanFreeList, int deltaMSec);
    [EventAttribute("14")]
public void TrimFree(string cacheName, int totalBuffs, int freeListCount, int toBeFreed);
    [EventAttribute("15")]
public void TrimExperiment(string cacheName, int totalBuffs, int freeListCount, int numTrimTrial);
    [EventAttribute("16")]
public void TrimFreeSizeOK(string cacheName, int totalBuffs, int freeListCount);
    [EventAttribute("17")]
public void TrimFlush(string cacheName, int totalBuffs, int freeListCount, int notGen2CountBefore);
    [EventAttribute("20")]
public void AgePendingBuffersResults(string cacheName, int promotedToFreeListCount, int heldBackCount);
    [EventAttribute("21")]
public void WalkFreeListResult(string cacheName, int freeListCount, int gen0BuffersInFreeList);
    internal static ulong AddressOf(object obj);
    [SecuritySafeCriticalAttribute]
internal static long AddressOfByteArray(Byte[] array);
}
public class Raven.Abstractions.Util.PositionWrapperStream : Stream {
    private Stream wrapped;
    private bool leaveOpen;
    private long pos;
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public long Length { get; }
    public PositionWrapperStream(Stream wrapped, bool leaveOpen);
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual long get_Length();
}
public static class Raven.Abstractions.Util.RavenQuery : object {
    private static HashSet`1<char> escapeChars;
    private static HashSet`1<char> fieldChars;
    private static RavenQuery();
    public static string Escape(string term);
    public static string Escape(string term, bool allowWildcards, bool makePhrase);
    public static bool IsEscapedChar(char c);
    public static string EscapeInternal(string term, bool allowWildcards, bool makePhrase, bool nested);
    public static string EscapeField(string field);
}
public class Raven.Abstractions.Util.Streams.BufferPool : object {
    private BufferManager bufferManager;
    public BufferPool(long maxBufferPoolSize, int maxBufferSize);
    public sealed virtual void Dispose();
    public sealed virtual Byte[] TakeBuffer(int size);
    public sealed virtual void ReturnBuffer(Byte[] buffer);
}
public class Raven.Abstractions.Util.Streams.BufferPoolMemoryStream : Stream {
    protected Byte[] _buffer;
    protected ObjectPool`1<Byte[]> _bufferPool;
    [CLSCompliantAttribute("False")]
protected long _length;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    private void EnsureCapacity(long requestedCapacity);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public static class Raven.Abstractions.Util.Streams.BufferSharedPools : object {
    private static int Megabyte;
    private static int Kilobyte;
    public static int HugeByteBufferSize;
    public static int BigByteBufferSize;
    public static int ByteBufferSize;
    public static int SmallByteBufferSize;
    public static int MicroByteBufferSize;
    public static ObjectPool`1<Byte[]> HugeByteArray;
    public static ObjectPool`1<Byte[]> BigByteArray;
    public static ObjectPool`1<Byte[]> ByteArray;
    public static ObjectPool`1<Byte[]> SmallByteArray;
    public static ObjectPool`1<Byte[]> MicroByteArray;
    private static BufferSharedPools();
}
public interface Raven.Abstractions.Util.Streams.IBufferPool {
    public abstract virtual Byte[] TakeBuffer(int size);
    public abstract virtual void ReturnBuffer(Byte[] buffer);
}
public class Raven.Abstractions.Util.Streams.NoBufferPool : object {
    public sealed virtual void Dispose();
    public sealed virtual Byte[] TakeBuffer(int size);
    public sealed virtual void ReturnBuffer(Byte[] buffer);
}
public class Raven.Abstractions.Util.Streams.Substream : Stream {
    private bool ownStream;
    private Stream stream;
    private long length;
    private long start;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Substream(Stream stream, long start, long length, bool ownStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
public class Raven.Abstractions.Util.UndisposableStream : Stream {
    private Stream inner;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public UndisposableStream(Stream inner);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class Raven.Abstractions.Util.WildcardMatcher : object {
    private static Char[] Separator;
    private static WildcardMatcher();
    public static bool Matches(string pattern, string input);
    public static bool MatchesExclusion(string pattern, string input);
    private static bool MatchesImpl(string pattern, string input);
    private static bool MatchesImpl(string pattern, string input, int patternPos, int inputPos);
}
public class Raven.Database.Counters.CounterState : object {
    [CompilerGeneratedAttribute]
private string <GroupName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Sign>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Etag>k__BackingField;
    public string GroupName { get; public set; }
    public string CounterName { get; public set; }
    public Guid ServerId { get; public set; }
    public char Sign { get; public set; }
    public long Value { get; public set; }
    public long Etag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_GroupName();
    [CompilerGeneratedAttribute]
public void set_GroupName(string value);
    [CompilerGeneratedAttribute]
public string get_CounterName();
    [CompilerGeneratedAttribute]
public void set_CounterName(string value);
    [CompilerGeneratedAttribute]
public Guid get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(Guid value);
    [CompilerGeneratedAttribute]
public char get_Sign();
    [CompilerGeneratedAttribute]
public void set_Sign(char value);
    [CompilerGeneratedAttribute]
public long get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(long value);
    [CompilerGeneratedAttribute]
public long get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(long value);
}
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Database.Data.AttachmentInformation : object {
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    public int Size { get; public set; }
    public string Key { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public Etag Etag { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
}
public class Raven.Database.Util.SizeLimitedConcurrentDictionary`2 : object {
    private ConcurrentDictionary`2<TKey, TValue> dic;
    private ConcurrentQueue`1<TKey> queue;
    private int size;
    public SizeLimitedConcurrentDictionary`2(int size);
    public SizeLimitedConcurrentDictionary`2(int size, IEqualityComparer`1<TKey> equalityComparer);
    public void Set(TKey key, TValue item);
    public bool TryGetValue(TKey key, TValue& value);
    public bool TryRemove(TKey key, TValue& value);
}
public class Raven.Database.Util.SizeLimitedConcurrentSet`1 : object {
    private ConcurrentDictionary`2<T, object> dic;
    private ConcurrentQueue`1<T> queue;
    private int size;
    public int Count { get; }
    public SizeLimitedConcurrentSet`1(int size);
    public SizeLimitedConcurrentSet`1(int size, IEqualityComparer`1<T> equalityComparer);
    public int get_Count();
    public bool Add(T item);
    public void Clear();
    public bool TryRemove(T item);
    public bool Contains(T item);
    public T[] ToArray();
    public TAccumolate Aggregate(TAccumolate seed, Func`3<TAccumolate, T, TAccumolate> aggregate);
}
internal class Raven.Imports.Newtonsoft.Json.Bson.BsonArray : BsonToken {
    private List`1<BsonToken> _children;
    public BsonType Type { get; }
    public void Add(BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Raven.Imports.Newtonsoft.Json.Bson.BsonBinary : BsonValue {
    [CompilerGeneratedAttribute]
private BsonBinaryType <BinaryType>k__BackingField;
    public BsonBinaryType BinaryType { get; public set; }
    public BsonBinary(Byte[] value, BsonBinaryType binaryType);
    [CompilerGeneratedAttribute]
public BsonBinaryType get_BinaryType();
    [CompilerGeneratedAttribute]
public void set_BinaryType(BsonBinaryType value);
}
internal enum Raven.Imports.Newtonsoft.Json.Bson.BsonBinaryType : Enum {
    public byte value__;
    public static BsonBinaryType Binary;
    public static BsonBinaryType Function;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Binary instead.")]
public static BsonBinaryType BinaryOld;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Uuid instead.")]
public static BsonBinaryType UuidOld;
    public static BsonBinaryType Uuid;
    public static BsonBinaryType Md5;
    public static BsonBinaryType UserDefined;
}
internal class Raven.Imports.Newtonsoft.Json.Bson.BsonBinaryWriter : object {
    private static Encoding Encoding;
    private BinaryWriter _writer;
    private Byte[] _largeByteBuffer;
    [CompilerGeneratedAttribute]
private DateTimeKind <DateTimeKindHandling>k__BackingField;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonBinaryWriter(BinaryWriter writer);
    private static BsonBinaryWriter();
    [CompilerGeneratedAttribute]
public DateTimeKind get_DateTimeKindHandling();
    [CompilerGeneratedAttribute]
public void set_DateTimeKindHandling(DateTimeKind value);
    public void Flush();
    public void Close();
    public void WriteToken(BsonToken t);
    private void WriteTokenInternal(BsonToken t);
    private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix);
    public void WriteUtf8Bytes(string s, int byteCount);
    private int CalculateSize(int stringByteCount);
    private int CalculateSizeWithLength(int stringByteCount, bool includeSize);
    private int CalculateSize(BsonToken t);
}
internal class Raven.Imports.Newtonsoft.Json.Bson.BsonObject : BsonToken {
    private List`1<BsonProperty> _children;
    public BsonType Type { get; }
    public void Add(string name, BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonProperty> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Raven.Imports.Newtonsoft.Json.Bson.BsonObjectId : object {
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; private set; }
    public BsonObjectId(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(Byte[] value);
}
internal class Raven.Imports.Newtonsoft.Json.Bson.BsonProperty : object {
    [CompilerGeneratedAttribute]
private BsonString <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonToken <Value>k__BackingField;
    public BsonString Name { get; public set; }
    public BsonToken Value { get; public set; }
    [CompilerGeneratedAttribute]
public BsonString get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(BsonString value);
    [CompilerGeneratedAttribute]
public BsonToken get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BsonToken value);
}
public class Raven.Imports.Newtonsoft.Json.Bson.BsonReader : JsonReader {
    private static int MaxCharBytesSize;
    private static Byte[] SeqRange1;
    private static Byte[] SeqRange2;
    private static Byte[] SeqRange3;
    private static Byte[] SeqRange4;
    private BinaryReader _reader;
    private List`1<ContainerContext> _stack;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private BsonType _currentElementType;
    private BsonReaderState _bsonReaderState;
    private ContainerContext _currentContext;
    private bool _readRootValueAsArray;
    private bool _jsonNet35BinaryCompatibility;
    private DateTimeKind _dateTimeKindHandling;
    [ObsoleteAttribute("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
public bool JsonNet35BinaryCompatibility { get; public set; }
    public bool ReadRootValueAsArray { get; public set; }
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonReader(Stream stream);
    public BsonReader(BinaryReader reader);
    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    private static BsonReader();
    public bool get_JsonNet35BinaryCompatibility();
    public void set_JsonNet35BinaryCompatibility(bool value);
    public bool get_ReadRootValueAsArray();
    public void set_ReadRootValueAsArray(bool value);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    private string ReadElement();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual bool Read();
    internal virtual bool ReadInternal();
    public virtual void Close();
    private bool ReadCodeWScope();
    private bool ReadReference();
    private bool ReadNormal();
    private void PopContext();
    private void PushContext(ContainerContext newContext);
    private byte ReadByte();
    private void ReadType(BsonType type);
    private Byte[] ReadBinary(BsonBinaryType& binaryType);
    private string ReadString();
    private string ReadLengthString();
    private string GetString(int length);
    private int GetLastFullCharStop(int start);
    private int BytesInSequence(byte b);
    private void EnsureBuffers();
    private double ReadDouble();
    private float ReadSingle();
    private decimal ReadDecimal();
    private int ReadInt32();
    private long ReadInt64();
    private BsonType ReadType();
    private void MovePosition(int count);
    private Byte[] ReadBytes(int count);
}
internal class Raven.Imports.Newtonsoft.Json.Bson.BsonRegex : BsonToken {
    [CompilerGeneratedAttribute]
private BsonString <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonString <Options>k__BackingField;
    public BsonString Pattern { get; public set; }
    public BsonString Options { get; public set; }
    public BsonType Type { get; }
    public BsonRegex(string pattern, string options);
    [CompilerGeneratedAttribute]
public BsonString get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(BsonString value);
    [CompilerGeneratedAttribute]
public BsonString get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(BsonString value);
    public virtual BsonType get_Type();
}
internal class Raven.Imports.Newtonsoft.Json.Bson.BsonString : BsonValue {
    [CompilerGeneratedAttribute]
private int <ByteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeLength>k__BackingField;
    public int ByteCount { get; public set; }
    public bool IncludeLength { get; public set; }
    public BsonString(object value, bool includeLength);
    [CompilerGeneratedAttribute]
public int get_ByteCount();
    [CompilerGeneratedAttribute]
public void set_ByteCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeLength();
    [CompilerGeneratedAttribute]
public void set_IncludeLength(bool value);
}
internal abstract class Raven.Imports.Newtonsoft.Json.Bson.BsonToken : object {
    [CompilerGeneratedAttribute]
private BsonToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CalculatedSize>k__BackingField;
    public BsonType Type { get; }
    public BsonToken Parent { get; public set; }
    public int CalculatedSize { get; public set; }
    public abstract virtual BsonType get_Type();
    [CompilerGeneratedAttribute]
public BsonToken get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(BsonToken value);
    [CompilerGeneratedAttribute]
public int get_CalculatedSize();
    [CompilerGeneratedAttribute]
public void set_CalculatedSize(int value);
}
internal enum Raven.Imports.Newtonsoft.Json.Bson.BsonType : Enum {
    public sbyte value__;
    public static BsonType Number;
    public static BsonType String;
    public static BsonType Object;
    public static BsonType Array;
    public static BsonType Binary;
    public static BsonType Undefined;
    public static BsonType Oid;
    public static BsonType Boolean;
    public static BsonType Date;
    public static BsonType Null;
    public static BsonType Regex;
    public static BsonType Reference;
    public static BsonType Code;
    public static BsonType Symbol;
    public static BsonType CodeWScope;
    public static BsonType Integer;
    public static BsonType TimeStamp;
    public static BsonType Long;
    public static BsonType NumberDecimal;
    public static BsonType RavenDBCustomFloat;
    public static BsonType MinKey;
    public static BsonType MaxKey;
}
internal class Raven.Imports.Newtonsoft.Json.Bson.BsonValue : BsonToken {
    private object _value;
    private BsonType _type;
    public object Value { get; }
    public BsonType Type { get; }
    public BsonValue(object value, BsonType type);
    public object get_Value();
    public virtual BsonType get_Type();
}
public class Raven.Imports.Newtonsoft.Json.Bson.BsonWriter : JsonWriter {
    private BsonBinaryWriter _writer;
    private BsonToken _root;
    private BsonToken _parent;
    private string _propertyName;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonWriter(Stream stream);
    public BsonWriter(BinaryWriter writer);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    public virtual void Flush();
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WriteComment(string text);
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteStartArray();
    public virtual void WriteStartObject();
    public virtual void WritePropertyName(string name);
    public virtual void Close();
    private void AddParent(BsonToken container);
    private void RemoveParent();
    private void AddValue(object value, BsonType type);
    internal void AddToken(BsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public void WriteObjectId(Byte[] value);
    public void WriteRegex(string pattern, string options);
}
public enum Raven.Imports.Newtonsoft.Json.ConstructorHandling : Enum {
    public int value__;
    public static ConstructorHandling Default;
    public static ConstructorHandling AllowNonPublicDefaultConstructor;
}
public class Raven.Imports.Newtonsoft.Json.Converters.BinaryConverter : JsonConverter {
    private static string BinaryTypeName;
    private static string BinaryToArrayName;
    private ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private Byte[] GetByteArray(object value);
    private void EnsureReflectionObject(Type t);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private Byte[] ReadByteArray(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Imports.Newtonsoft.Json.Converters.BsonObjectIdConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public abstract class Raven.Imports.Newtonsoft.Json.Converters.CustomCreationConverter`1 : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T Create(Type objectType);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
public class Raven.Imports.Newtonsoft.Json.Converters.DataSetConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type valueType);
    private void CheckedRead(JsonReader reader);
}
public class Raven.Imports.Newtonsoft.Json.Converters.DataTableConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static void CreateRow(JsonReader reader, DataTable dt, JsonSerializer serializer);
    private static Type GetColumnDataType(JsonReader reader);
    private static void CheckedRead(JsonReader reader);
    public virtual bool CanConvert(Type valueType);
}
public abstract class Raven.Imports.Newtonsoft.Json.Converters.DateTimeConverterBase : JsonConverter {
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Imports.Newtonsoft.Json.Converters.DiscriminatedUnionConverter : JsonConverter {
    private static string CasePropertyName;
    private static string FieldsPropertyName;
    private static ThreadSafeStore`2<Type, Union> UnionCache;
    private static ThreadSafeStore`2<Type, Type> UnionTypeLookupCache;
    private static DiscriminatedUnionConverter();
    private static Type CreateUnionTypeLookup(Type t);
    private static Union CreateUnion(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    private static void ReadAndAssert(JsonReader reader);
}
public class Raven.Imports.Newtonsoft.Json.Converters.EntityKeyMemberConverter : JsonConverter {
    private static string EntityKeyMemberFullTypeName;
    private static string KeyPropertyName;
    private static string TypePropertyName;
    private static string ValuePropertyName;
    private static ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static void ReadAndAssertProperty(JsonReader reader, string propertyName);
    private static void ReadAndAssert(JsonReader reader);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static void EnsureReflectionObject(Type objectType);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Imports.Newtonsoft.Json.Converters.ExpandoObjectConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadValue(JsonReader reader);
    private object ReadList(JsonReader reader);
    private object ReadObject(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
public class Raven.Imports.Newtonsoft.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
    private static string DefaultDateTimeFormat;
    private DateTimeStyles _dateTimeStyles;
    private string _dateTimeFormat;
    private CultureInfo _culture;
    public DateTimeStyles DateTimeStyles { get; public set; }
    public string DateTimeFormat { get; public set; }
    public CultureInfo Culture { get; public set; }
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
    public string get_DateTimeFormat();
    public void set_DateTimeFormat(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
internal interface Raven.Imports.Newtonsoft.Json.Converters.IXmlDeclaration {
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public abstract virtual string get_Version();
    public abstract virtual string get_Encoding();
    public abstract virtual void set_Encoding(string value);
    public abstract virtual string get_Standalone();
    public abstract virtual void set_Standalone(string value);
}
internal interface Raven.Imports.Newtonsoft.Json.Converters.IXmlDocument {
    public IXmlElement DocumentElement { get; }
    public abstract virtual IXmlNode CreateComment(string text);
    public abstract virtual IXmlNode CreateTextNode(string text);
    public abstract virtual IXmlNode CreateCDataSection(string data);
    public abstract virtual IXmlNode CreateWhitespace(string text);
    public abstract virtual IXmlNode CreateSignificantWhitespace(string text);
    public abstract virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public abstract virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public abstract virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public abstract virtual IXmlElement CreateElement(string elementName);
    public abstract virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public abstract virtual IXmlNode CreateAttribute(string name, string value);
    public abstract virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public abstract virtual IXmlElement get_DocumentElement();
}
internal interface Raven.Imports.Newtonsoft.Json.Converters.IXmlDocumentType {
    public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_System();
    public abstract virtual string get_Public();
    public abstract virtual string get_InternalSubset();
}
internal interface Raven.Imports.Newtonsoft.Json.Converters.IXmlElement {
    public bool IsEmpty { get; }
    public abstract virtual void SetAttributeNode(IXmlNode attribute);
    public abstract virtual string GetPrefixOfNamespace(string namespaceUri);
    public abstract virtual bool get_IsEmpty();
}
internal interface Raven.Imports.Newtonsoft.Json.Converters.IXmlNode {
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IList`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public object WrappedNode { get; }
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_LocalName();
    public abstract virtual IList`1<IXmlNode> get_ChildNodes();
    public abstract virtual IList`1<IXmlNode> get_Attributes();
    public abstract virtual IXmlNode get_ParentNode();
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    public abstract virtual IXmlNode AppendChild(IXmlNode newChild);
    public abstract virtual string get_NamespaceUri();
    public abstract virtual object get_WrappedNode();
}
public class Raven.Imports.Newtonsoft.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
public class Raven.Imports.Newtonsoft.Json.Converters.KeyValuePairConverter : JsonConverter {
    private static string KeyName;
    private static string ValueName;
    private static ThreadSafeStore`2<Type, ReflectionObject> ReflectionObjectPerType;
    private static KeyValuePairConverter();
    private static ReflectionObject InitializeReflectionObject(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    private static void ReadAndAssert(JsonReader reader);
}
public class Raven.Imports.Newtonsoft.Json.Converters.RegexConverter : JsonConverter {
    private static string PatternName;
    private static string OptionsName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private bool HasFlag(RegexOptions options, RegexOptions flag);
    private void WriteBson(BsonWriter writer, Regex regex);
    private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadRegexString(JsonReader reader);
    private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Imports.Newtonsoft.Json.Converters.StringEnumConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private bool <CamelCaseText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIntegerValues>k__BackingField;
    public bool CamelCaseText { get; public set; }
    public bool AllowIntegerValues { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CamelCaseText();
    [CompilerGeneratedAttribute]
public void set_CamelCaseText(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowIntegerValues();
    [CompilerGeneratedAttribute]
public void set_AllowIntegerValues(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Imports.Newtonsoft.Json.Converters.VersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XAttributeWrapper : XObjectWrapper {
    private XAttribute Attribute { get; }
    public string Value { get; public set; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public IXmlNode ParentNode { get; }
    public XAttributeWrapper(XAttribute attribute);
    private XAttribute get_Attribute();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual IXmlNode get_ParentNode();
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XCommentWrapper : XObjectWrapper {
    private XComment Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    public XCommentWrapper(XComment text);
    private XComment get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XContainerWrapper : XObjectWrapper {
    private IList`1<IXmlNode> _childNodes;
    private XContainer Container { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IXmlNode ParentNode { get; }
    public XContainerWrapper(XContainer container);
    private XContainer get_Container();
    public virtual IList`1<IXmlNode> get_ChildNodes();
    public virtual IXmlNode get_ParentNode();
    internal static IXmlNode WrapNode(XObject node);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XDeclarationWrapper : XObjectWrapper {
    [CompilerGeneratedAttribute]
private XDeclaration <Declaration>k__BackingField;
    internal XDeclaration Declaration { get; private set; }
    public XmlNodeType NodeType { get; }
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public XDeclarationWrapper(XDeclaration declaration);
    [CompilerGeneratedAttribute]
internal XDeclaration get_Declaration();
    [CompilerGeneratedAttribute]
private void set_Declaration(XDeclaration value);
    public virtual XmlNodeType get_NodeType();
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XDocumentTypeWrapper : XObjectWrapper {
    private XDocumentType _documentType;
    public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public string LocalName { get; }
    public XDocumentTypeWrapper(XDocumentType documentType);
    public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XDocumentWrapper : XContainerWrapper {
    private XDocument Document { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IXmlElement DocumentElement { get; }
    public XDocumentWrapper(XDocument document);
    private XDocument get_Document();
    public virtual IList`1<IXmlNode> get_ChildNodes();
    public sealed virtual IXmlNode CreateComment(string text);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public sealed virtual IXmlElement get_DocumentElement();
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XElementWrapper : XContainerWrapper {
    private XElement Element { get; }
    public IList`1<IXmlNode> Attributes { get; }
    public string Value { get; public set; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public bool IsEmpty { get; }
    public XElementWrapper(XElement element);
    private XElement get_Element();
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public virtual IList`1<IXmlNode> get_Attributes();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
    private XmlDeclaration _declaration;
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public XmlDeclarationWrapper(XmlDeclaration declaration);
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XmlDocumentTypeWrapper : XmlNodeWrapper {
    private XmlDocumentType _documentType;
    public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public string LocalName { get; }
    public XmlDocumentTypeWrapper(XmlDocumentType documentType);
    public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
    private XmlDocument _document;
    public IXmlElement DocumentElement { get; }
    public XmlDocumentWrapper(XmlDocument document);
    public sealed virtual IXmlNode CreateComment(string data);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    public sealed virtual IXmlElement get_DocumentElement();
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
    private XmlElement _element;
    public bool IsEmpty { get; }
    public XmlElementWrapper(XmlElement element);
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
public class Raven.Imports.Newtonsoft.Json.Converters.XmlNodeConverter : JsonConverter {
    private static string TextName;
    private static string CommentName;
    private static string CDataName;
    private static string WhitespaceName;
    private static string SignificantWhitespaceName;
    private static string DeclarationName;
    private static string JsonNamespaceUri;
    [CompilerGeneratedAttribute]
private string <DeserializeRootElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteArrayAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitRootObject>k__BackingField;
    public string DeserializeRootElementName { get; public set; }
    public bool WriteArrayAttribute { get; public set; }
    public bool OmitRootObject { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DeserializeRootElementName();
    [CompilerGeneratedAttribute]
public void set_DeserializeRootElementName(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteArrayAttribute();
    [CompilerGeneratedAttribute]
public void set_WriteArrayAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_OmitRootObject();
    [CompilerGeneratedAttribute]
public void set_OmitRootObject(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private IXmlNode WrapXml(object value);
    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager);
    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager);
    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager);
    private bool IsArray(IXmlNode node);
    private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode);
    private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager);
    private string ConvertTokenToXmlValue(JsonReader reader);
    private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager);
    private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document);
    private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager);
    private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName);
    private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode);
    private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager);
    private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode);
    private bool IsNamespaceAttribute(string attributeName, String& prefix);
    private IEnumerable`1<IXmlNode> ValueAttributes(IEnumerable`1<IXmlNode> c);
    public virtual bool CanConvert(Type valueType);
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XmlNodeWrapper : object {
    private XmlNode _node;
    private IList`1<IXmlNode> _childNodes;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IList`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public XmlNodeWrapper(XmlNode node);
    public sealed virtual object get_WrappedNode();
    public sealed virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    public sealed virtual IList`1<IXmlNode> get_ChildNodes();
    internal static IXmlNode WrapNode(XmlNode node);
    public sealed virtual IList`1<IXmlNode> get_Attributes();
    public sealed virtual IXmlNode get_ParentNode();
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    public sealed virtual IXmlNode AppendChild(IXmlNode newChild);
    public sealed virtual string get_NamespaceUri();
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XObjectWrapper : object {
    private XObject _xmlObject;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IList`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public XObjectWrapper(XObject xmlObject);
    public sealed virtual object get_WrappedNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    public virtual IList`1<IXmlNode> get_ChildNodes();
    public virtual IList`1<IXmlNode> get_Attributes();
    public virtual IXmlNode get_ParentNode();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    public virtual string get_NamespaceUri();
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XProcessingInstructionWrapper : XObjectWrapper {
    private XProcessingInstruction ProcessingInstruction { get; }
    public string LocalName { get; }
    public string Value { get; public set; }
    public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction);
    private XProcessingInstruction get_ProcessingInstruction();
    public virtual string get_LocalName();
    public virtual string get_Value();
    public virtual void set_Value(string value);
}
internal class Raven.Imports.Newtonsoft.Json.Converters.XTextWrapper : XObjectWrapper {
    private XText Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    public XTextWrapper(XText text);
    private XText get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
public enum Raven.Imports.Newtonsoft.Json.DateFormatHandling : Enum {
    public int value__;
    public static DateFormatHandling IsoDateFormat;
    public static DateFormatHandling MicrosoftDateFormat;
}
public enum Raven.Imports.Newtonsoft.Json.DateParseHandling : Enum {
    public int value__;
    public static DateParseHandling None;
    public static DateParseHandling DateTime;
    public static DateParseHandling DateTimeOffset;
}
public enum Raven.Imports.Newtonsoft.Json.DateTimeZoneHandling : Enum {
    public int value__;
    public static DateTimeZoneHandling Local;
    public static DateTimeZoneHandling Utc;
    public static DateTimeZoneHandling Unspecified;
    public static DateTimeZoneHandling RoundtripKind;
}
[FlagsAttribute]
public enum Raven.Imports.Newtonsoft.Json.DefaultValueHandling : Enum {
    public int value__;
    public static DefaultValueHandling Include;
    public static DefaultValueHandling Ignore;
    public static DefaultValueHandling Populate;
    public static DefaultValueHandling IgnoreAndPopulate;
}
public enum Raven.Imports.Newtonsoft.Json.FloatFormatHandling : Enum {
    public int value__;
    public static FloatFormatHandling String;
    public static FloatFormatHandling Symbol;
    public static FloatFormatHandling DefaultValue;
}
public enum Raven.Imports.Newtonsoft.Json.FloatParseHandling : Enum {
    public int value__;
    public static FloatParseHandling Double;
    public static FloatParseHandling Decimal;
    public static FloatParseHandling PreferDecimalFallbackToDouble;
}
public enum Raven.Imports.Newtonsoft.Json.Formatting : Enum {
    public int value__;
    public static Formatting None;
    public static Formatting Indented;
}
public interface Raven.Imports.Newtonsoft.Json.IJsonLineInfo {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public abstract virtual bool HasLineInfo();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
}
[AttributeUsageAttribute("1028")]
public class Raven.Imports.Newtonsoft.Json.JsonArrayAttribute : JsonContainerAttribute {
    private bool _allowNullItems;
    public bool AllowNullItems { get; public set; }
    public JsonArrayAttribute(bool allowNullItems);
    public JsonArrayAttribute(string id);
    public bool get_AllowNullItems();
    public void set_AllowNullItems(bool value);
}
[AttributeUsageAttribute("32")]
public class Raven.Imports.Newtonsoft.Json.JsonConstructorAttribute : Attribute {
}
[AttributeUsageAttribute("1028")]
public abstract class Raven.Imports.Newtonsoft.Json.JsonContainerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public Type ItemConverterType { get; public set; }
    public Object[] ItemConverterParameters { get; public set; }
    public bool IsReference { get; public set; }
    public bool ItemIsReference { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    protected JsonContainerAttribute(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
}
internal enum Raven.Imports.Newtonsoft.Json.JsonContainerType : Enum {
    public int value__;
    public static JsonContainerType None;
    public static JsonContainerType Object;
    public static JsonContainerType Array;
    public static JsonContainerType Constructor;
}
public static class Raven.Imports.Newtonsoft.Json.JsonConvert : object {
    [CompilerGeneratedAttribute]
private static Func`1<JsonSerializerSettings> <DefaultSettings>k__BackingField;
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    public static Func`1<JsonSerializerSettings> DefaultSettings { get; public set; }
    private static JsonConvert();
    [CompilerGeneratedAttribute]
public static Func`1<JsonSerializerSettings> get_DefaultSettings();
    [CompilerGeneratedAttribute]
public static void set_DefaultSettings(Func`1<JsonSerializerSettings> value);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling);
    public static string ToString(DateTimeOffset value);
    public static string ToString(DateTimeOffset value, DateFormatHandling format);
    public static string ToString(bool value);
    public static string ToString(char value);
    public static string ToString(Enum value);
    public static string ToString(int value);
    public static string ToString(short value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    public static string ToString(long value);
    private static string ToStringInternal(BigInteger value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    public static string ToString(float value);
    internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    public static string ToString(double value);
    internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureDecimalPlace(double value, string text);
    private static string EnsureDecimalPlace(string text);
    public static string ToString(byte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    public static string ToString(decimal value);
    public static string ToString(Guid value);
    internal static string ToString(Guid value, char quoteChar);
    public static string ToString(TimeSpan value);
    internal static string ToString(TimeSpan value, char quoteChar);
    public static string ToString(Uri value);
    internal static string ToString(Uri value, char quoteChar);
    public static string ToString(string value);
    public static string ToString(string value, char delimiter);
    public static string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling);
    public static string ToString(object value);
    public static string SerializeObject(object value);
    public static string SerializeObject(object value, Formatting formatting);
    public static string SerializeObject(object value, JsonConverter[] converters);
    public static string SerializeObject(object value, JsonConverterCollection converters);
    public static string SerializeObject(object value, Formatting formatting, JsonConverter[] converters);
    public static string SerializeObject(object value, Formatting formatting, JsonConverterCollection converters);
    public static string SerializeObject(object value, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Type type, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings);
    public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings);
    private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer);
    [ObsoleteAttribute("SerializeObjectAsync is obsolete. Use the Task.Factory.StartNew method to serialize JSON asynchronously: Task.Factory.StartNew(() => JsonConvert.SerializeObject(value))")]
public static Task`1<string> SerializeObjectAsync(object value);
    [ObsoleteAttribute("SerializeObjectAsync is obsolete. Use the Task.Factory.StartNew method to serialize JSON asynchronously: Task.Factory.StartNew(() => JsonConvert.SerializeObject(value, formatting))")]
public static Task`1<string> SerializeObjectAsync(object value, Formatting formatting);
    [ObsoleteAttribute("SerializeObjectAsync is obsolete. Use the Task.Factory.StartNew method to serialize JSON asynchronously: Task.Factory.StartNew(() => JsonConvert.SerializeObject(value, formatting, settings))")]
public static Task`1<string> SerializeObjectAsync(object value, Formatting formatting, JsonSerializerSettings settings);
    public static object DeserializeObject(string value);
    public static object DeserializeObject(string value, JsonSerializerSettings settings);
    public static object DeserializeObject(string value, Type type);
    public static T DeserializeObject(string value);
    public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    public static T DeserializeAnonymousType(string value, T anonymousTypeObject, JsonSerializerSettings settings);
    public static T DeserializeObject(string value, JsonConverter[] converters);
    public static T DeserializeObject(string value, JsonConverterCollection converters);
    public static T DeserializeObject(string value, JsonSerializerSettings settings);
    public static object DeserializeObject(string value, Type type, JsonConverter[] converters);
    public static object DeserializeObject(string value, Type type, JsonConverterCollection converters);
    public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings);
    [ObsoleteAttribute("DeserializeObjectAsync is obsolete. Use the Task.Factory.StartNew method to deserialize JSON asynchronously: Task.Factory.StartNew(() => JsonConvert.DeserializeObject<T>(value))")]
public static Task`1<T> DeserializeObjectAsync(string value);
    [ObsoleteAttribute("DeserializeObjectAsync is obsolete. Use the Task.Factory.StartNew method to deserialize JSON asynchronously: Task.Factory.StartNew(() => JsonConvert.DeserializeObject<T>(value, settings))")]
public static Task`1<T> DeserializeObjectAsync(string value, JsonSerializerSettings settings);
    [ObsoleteAttribute("DeserializeObjectAsync is obsolete. Use the Task.Factory.StartNew method to deserialize JSON asynchronously: Task.Factory.StartNew(() => JsonConvert.DeserializeObject(value))")]
public static Task`1<object> DeserializeObjectAsync(string value);
    [ObsoleteAttribute("DeserializeObjectAsync is obsolete. Use the Task.Factory.StartNew method to deserialize JSON asynchronously: Task.Factory.StartNew(() => JsonConvert.DeserializeObject(value, type, settings))")]
public static Task`1<object> DeserializeObjectAsync(string value, Type type, JsonSerializerSettings settings);
    public static void PopulateObject(string value, object target);
    public static void PopulateObject(string value, object target, JsonSerializerSettings settings);
    [ObsoleteAttribute("PopulateObjectAsync is obsolete. Use the Task.Factory.StartNew method to populate an object with JSON values asynchronously: Task.Factory.StartNew(() => JsonConvert.PopulateObject(value, target, settings))")]
public static Task PopulateObjectAsync(string value, object target, JsonSerializerSettings settings);
    public static string SerializeXmlNode(XmlNode node);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject);
    public static XmlDocument DeserializeXmlNode(string value);
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName);
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    public static string SerializeXNode(XObject node);
    public static string SerializeXNode(XObject node, Formatting formatting);
    public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject);
    public static XDocument DeserializeXNode(string value);
    public static XDocument DeserializeXNode(string value, string deserializeRootElementName);
    public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
}
public abstract class Raven.Imports.Newtonsoft.Json.JsonConverter : object {
    public static JsonConverter[] Empty;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    private static JsonConverter();
    public abstract virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual bool CanConvert(Type objectType);
    [ObsoleteAttribute("JSON Schema validation has been moved to its own package. It is strongly recommended that you do not override GetSchema() in your own converter. It is not used by Json.NET and will be removed at some point in the future. Converter's that override GetSchema() will stop working when it is removed.")]
public virtual JsonSchema GetSchema();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
}
[AttributeUsageAttribute("3484")]
public class Raven.Imports.Newtonsoft.Json.JsonConverterAttribute : Attribute {
    private Type _converterType;
    [CompilerGeneratedAttribute]
private Object[] <ConverterParameters>k__BackingField;
    public Type ConverterType { get; }
    public Object[] ConverterParameters { get; private set; }
    public JsonConverterAttribute(Type converterType);
    public JsonConverterAttribute(Type converterType, Object[] converterParameters);
    public Type get_ConverterType();
    [CompilerGeneratedAttribute]
public Object[] get_ConverterParameters();
    [CompilerGeneratedAttribute]
private void set_ConverterParameters(Object[] value);
}
public class Raven.Imports.Newtonsoft.Json.JsonConverterCollection : Collection`1<JsonConverter> {
    public static JsonConverterCollection Empty;
    [CompilerGeneratedAttribute]
private bool <IsFrozen>k__BackingField;
    public bool IsFrozen { get; private set; }
    private static JsonConverterCollection();
    public JsonConverterCollection(IEnumerable`1<JsonConverter> converters);
    protected JsonConverterCollection(JsonConverterCollection collection);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, JsonConverter item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, JsonConverter item);
    [CompilerGeneratedAttribute]
public bool get_IsFrozen();
    [CompilerGeneratedAttribute]
private void set_IsFrozen(bool value);
    public void Freeze();
}
[AttributeUsageAttribute("1028")]
public class Raven.Imports.Newtonsoft.Json.JsonDictionaryAttribute : JsonContainerAttribute {
    public JsonDictionaryAttribute(string id);
}
public class Raven.Imports.Newtonsoft.Json.JsonException : Exception {
    public JsonException(string message);
    public JsonException(string message, Exception innerException);
    public JsonException(SerializationInfo info, StreamingContext context);
    internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("384")]
public class Raven.Imports.Newtonsoft.Json.JsonExtensionDataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WriteData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadData>k__BackingField;
    public bool WriteData { get; public set; }
    public bool ReadData { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WriteData();
    [CompilerGeneratedAttribute]
public void set_WriteData(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadData();
    [CompilerGeneratedAttribute]
public void set_ReadData(bool value);
}
[AttributeUsageAttribute("384")]
public class Raven.Imports.Newtonsoft.Json.JsonIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
public class Raven.Imports.Newtonsoft.Json.JsonObjectAttribute : JsonContainerAttribute {
    private MemberSerialization _memberSerialization;
    internal Nullable`1<Required> _itemRequired;
    public MemberSerialization MemberSerialization { get; public set; }
    public Required ItemRequired { get; public set; }
    public JsonObjectAttribute(MemberSerialization memberSerialization);
    public JsonObjectAttribute(string id);
    public MemberSerialization get_MemberSerialization();
    public void set_MemberSerialization(MemberSerialization value);
    public Required get_ItemRequired();
    public void set_ItemRequired(Required value);
}
internal class Raven.Imports.Newtonsoft.Json.JsonPosition : ValueType {
    private static Char[] SpecialCharacters;
    internal JsonContainerType Type;
    internal int Position;
    internal string PropertyName;
    internal bool HasIndex;
    public JsonPosition(JsonContainerType type);
    private static JsonPosition();
    internal void WriteTo(StringBuilder sb);
    internal static bool TypeHasIndex(JsonContainerType type);
    internal static string BuildPath(IEnumerable`1<JsonPosition> positions);
    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("2432")]
public class Raven.Imports.Newtonsoft.Json.JsonPropertyAttribute : Attribute {
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<int> _order;
    internal Nullable`1<Required> _required;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public Type ItemConverterType { get; public set; }
    public Object[] ItemConverterParameters { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public bool IsReference { get; public set; }
    public int Order { get; public set; }
    public Required Required { get; public set; }
    public string PropertyName { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    public bool ItemIsReference { get; public set; }
    public JsonPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public int get_Order();
    public void set_Order(int value);
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
}
public abstract class Raven.Imports.Newtonsoft.Json.JsonReader : object {
    private JsonToken _tokenType;
    private object _value;
    internal char _quoteChar;
    internal State _currentState;
    internal ReadType _readType;
    private JsonPosition _currentPosition;
    private CultureInfo _culture;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    internal DateParseHandling _dateParseHandling;
    internal FloatParseHandling _floatParseHandling;
    private string _dateFormatString;
    private List`1<JsonPosition> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMultipleContent>k__BackingField;
    protected State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public bool SupportMultipleContent { get; public set; }
    public char QuoteChar { get; protected internal set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    public int Depth { get; }
    public string Path { get; }
    public CultureInfo Culture { get; public set; }
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMultipleContent();
    [CompilerGeneratedAttribute]
public void set_SupportMultipleContent(bool value);
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual int get_Depth();
    public virtual string get_Path();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal JsonPosition GetPosition(int depth);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public abstract virtual Nullable`1<int> ReadAsInt32();
    public abstract virtual string ReadAsString();
    public abstract virtual Byte[] ReadAsBytes();
    public abstract virtual Nullable`1<decimal> ReadAsDecimal();
    public abstract virtual Nullable`1<DateTime> ReadAsDateTime();
    public abstract virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal virtual bool ReadInternal();
    internal Nullable`1<DateTimeOffset> ReadAsDateTimeOffsetInternal();
    internal Byte[] ReadAsBytesInternal();
    internal Nullable`1<decimal> ReadAsDecimalInternal();
    internal Nullable`1<int> ReadAsInt32Internal();
    internal string ReadAsStringInternal();
    internal Nullable`1<DateTime> ReadAsDateTimeInternal();
    private bool IsWrappedInTypeObject();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    internal void SetToken(JsonToken newToken, object value, bool updateIndex);
    internal void SetPostValueState(bool updateIndex);
    private void UpdateScopeWithFinishedValue();
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    private void SetFinished();
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
}
public class Raven.Imports.Newtonsoft.Json.JsonReaderException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public string Path { get; private set; }
    public JsonReaderException(string message);
    public JsonReaderException(string message, Exception innerException);
    public JsonReaderException(SerializationInfo info, StreamingContext context);
    internal JsonReaderException(string message, Exception innerException, string path, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    internal static JsonReaderException Create(JsonReader reader, string message);
    internal static JsonReaderException Create(JsonReader reader, string message, Exception ex);
    internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[AttributeUsageAttribute("384")]
public class Raven.Imports.Newtonsoft.Json.JsonRequiredAttribute : Attribute {
}
public class Raven.Imports.Newtonsoft.Json.JsonSerializationException : JsonException {
    public JsonSerializationException(string message);
    public JsonSerializationException(string message, Exception innerException);
    public JsonSerializationException(SerializationInfo info, StreamingContext context);
    internal static JsonSerializationException Create(JsonReader reader, string message);
    internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex);
    internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
public class Raven.Imports.Newtonsoft.Json.JsonSerializer : object {
    internal TypeNameHandling _typeNameHandling;
    internal FormatterAssemblyStyle _typeNameAssemblyFormat;
    internal PreserveReferencesHandling _preserveReferencesHandling;
    internal ReferenceLoopHandling _referenceLoopHandling;
    internal MissingMemberHandling _missingMemberHandling;
    internal ObjectCreationHandling _objectCreationHandling;
    internal NullValueHandling _nullValueHandling;
    internal DefaultValueHandling _defaultValueHandling;
    internal ConstructorHandling _constructorHandling;
    internal MetadataPropertyHandling _metadataPropertyHandling;
    internal JsonConverterCollection _converters;
    internal IContractResolver _contractResolver;
    internal ITraceWriter _traceWriter;
    internal SerializationBinder _binder;
    internal StreamingContext _context;
    private IReferenceResolver _referenceResolver;
    private Nullable`1<Formatting> _formatting;
    private Nullable`1<DateFormatHandling> _dateFormatHandling;
    private Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    private Nullable`1<DateParseHandling> _dateParseHandling;
    private Nullable`1<FloatFormatHandling> _floatFormatHandling;
    private Nullable`1<FloatParseHandling> _floatParseHandling;
    private Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    private CultureInfo _culture;
    private Nullable`1<int> _maxDepth;
    private bool _maxDepthSet;
    private Nullable`1<bool> _checkAdditionalContent;
    private string _dateFormatString;
    private bool _dateFormatStringSet;
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Error;
    [CompilerGeneratedAttribute]
private Action`2<object, JsonWriter> BeforeClosingObject;
    public IReferenceResolver ReferenceResolver { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    public JsonConverterCollection Converters { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    [CompilerGeneratedAttribute]
public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_BeforeClosingObject(Action`2<object, JsonWriter> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeClosingObject(Action`2<object, JsonWriter> value);
    public virtual IReferenceResolver get_ReferenceResolver();
    public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ITraceWriter get_TraceWriter();
    public virtual void set_TraceWriter(ITraceWriter value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual JsonConverterCollection get_Converters();
    public virtual void set_Converters(JsonConverterCollection value);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal bool IsCheckAdditionalContentSet();
    public static JsonSerializer Create();
    public static JsonSerializer Create(JsonSerializerSettings settings);
    public static JsonSerializer CreateDefault();
    public static JsonSerializer CreateDefault(JsonSerializerSettings settings);
    private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings);
    public void Populate(TextReader reader, object target);
    public void Populate(JsonReader reader, object target);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    public object Deserialize(JsonReader reader);
    public object Deserialize(TextReader reader, Type objectType);
    public T Deserialize(JsonReader reader);
    public object Deserialize(JsonReader reader, Type objectType);
    internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    private void SetupReader(JsonReader reader, CultureInfo& previousCulture, Nullable`1& previousDateTimeZoneHandling, Nullable`1& previousDateParseHandling, Nullable`1& previousFloatParseHandling, Nullable`1& previousMaxDepth, String& previousDateFormatString);
    private void ResetReader(JsonReader reader, CultureInfo previousCulture, Nullable`1<DateTimeZoneHandling> previousDateTimeZoneHandling, Nullable`1<DateParseHandling> previousDateParseHandling, Nullable`1<FloatParseHandling> previousFloatParseHandling, Nullable`1<int> previousMaxDepth, string previousDateFormatString);
    public void Serialize(TextWriter textWriter, object value);
    public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    public void Serialize(TextWriter textWriter, object value, Type objectType);
    public void Serialize(JsonWriter jsonWriter, object value);
    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType);
    internal IReferenceResolver GetReferenceResolver();
    internal JsonConverter GetMatchingConverter(Type type);
    internal void OnError(ErrorEventArgs e);
}
public class Raven.Imports.Newtonsoft.Json.JsonSerializerSettings : object {
    internal static ReferenceLoopHandling DefaultReferenceLoopHandling;
    internal static MissingMemberHandling DefaultMissingMemberHandling;
    internal static NullValueHandling DefaultNullValueHandling;
    internal static DefaultValueHandling DefaultDefaultValueHandling;
    internal static ObjectCreationHandling DefaultObjectCreationHandling;
    internal static PreserveReferencesHandling DefaultPreserveReferencesHandling;
    internal static ConstructorHandling DefaultConstructorHandling;
    internal static TypeNameHandling DefaultTypeNameHandling;
    internal static MetadataPropertyHandling DefaultMetadataPropertyHandling;
    internal static FormatterAssemblyStyle DefaultTypeNameAssemblyFormat;
    internal static StreamingContext DefaultContext;
    internal static Formatting DefaultFormatting;
    internal static DateFormatHandling DefaultDateFormatHandling;
    internal static DateTimeZoneHandling DefaultDateTimeZoneHandling;
    internal static DateParseHandling DefaultDateParseHandling;
    internal static FloatParseHandling DefaultFloatParseHandling;
    internal static FloatFormatHandling DefaultFloatFormatHandling;
    internal static StringEscapeHandling DefaultStringEscapeHandling;
    internal static FormatterAssemblyStyle DefaultFormatterAssemblyStyle;
    internal static CultureInfo DefaultCulture;
    internal static bool DefaultCheckAdditionalContent;
    internal static string DefaultDateFormatString;
    internal Nullable`1<Formatting> _formatting;
    internal Nullable`1<DateFormatHandling> _dateFormatHandling;
    internal Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    internal Nullable`1<DateParseHandling> _dateParseHandling;
    internal Nullable`1<FloatFormatHandling> _floatFormatHandling;
    internal Nullable`1<FloatParseHandling> _floatParseHandling;
    internal Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    internal CultureInfo _culture;
    internal Nullable`1<bool> _checkAdditionalContent;
    internal Nullable`1<int> _maxDepth;
    internal bool _maxDepthSet;
    internal string _dateFormatString;
    internal bool _dateFormatStringSet;
    internal Nullable`1<FormatterAssemblyStyle> _typeNameAssemblyFormat;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<PreserveReferencesHandling> _preserveReferencesHandling;
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<StreamingContext> _context;
    internal Nullable`1<ConstructorHandling> _constructorHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<MetadataPropertyHandling> _metadataPropertyHandling;
    [CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private IContractResolver <ContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IReferenceResolver> <ReferenceResolverProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <TraceWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializationBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> <Error>k__BackingField;
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IList`1<JsonConverter> Converters { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    [ObsoleteAttribute("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]
public IReferenceResolver ReferenceResolver { get; public set; }
    public Func`1<IReferenceResolver> ReferenceResolverProvider { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public EventHandler`1<ErrorEventArgs> Error { get; public set; }
    public StreamingContext Context { get; public set; }
    public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public CultureInfo Culture { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    private static JsonSerializerSettings();
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    [CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    [CompilerGeneratedAttribute]
public void set_Converters(IList`1<JsonConverter> value);
    public PreserveReferencesHandling get_PreserveReferencesHandling();
    public void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public MetadataPropertyHandling get_MetadataPropertyHandling();
    public void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public ConstructorHandling get_ConstructorHandling();
    public void set_ConstructorHandling(ConstructorHandling value);
    [CompilerGeneratedAttribute]
public IContractResolver get_ContractResolver();
    [CompilerGeneratedAttribute]
public void set_ContractResolver(IContractResolver value);
    public IReferenceResolver get_ReferenceResolver();
    public void set_ReferenceResolver(IReferenceResolver value);
    [CompilerGeneratedAttribute]
public Func`1<IReferenceResolver> get_ReferenceResolverProvider();
    [CompilerGeneratedAttribute]
public void set_ReferenceResolverProvider(Func`1<IReferenceResolver> value);
    [CompilerGeneratedAttribute]
public ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
public void set_TraceWriter(ITraceWriter value);
    [CompilerGeneratedAttribute]
public SerializationBinder get_Binder();
    [CompilerGeneratedAttribute]
public void set_Binder(SerializationBinder value);
    [CompilerGeneratedAttribute]
public EventHandler`1<ErrorEventArgs> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(EventHandler`1<ErrorEventArgs> value);
    public StreamingContext get_Context();
    public void set_Context(StreamingContext value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public bool get_CheckAdditionalContent();
    public void set_CheckAdditionalContent(bool value);
}
public class Raven.Imports.Newtonsoft.Json.JsonTextReader : JsonReader {
    private static char UnicodeReplacementChar;
    private static int MaximumJavascriptIntegerCharacterLength;
    private TextReader _reader;
    private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _buffer;
    private StringReference _stringReference;
    internal PropertyNameTable NameTable;
    private Byte[] _largeBytesBuffer;
    private static Byte[] charsLookupTable;
    private static byte WHITESPACE;
    private static byte INVALID;
    private static byte EQUALS;
    private static byte QUOTE;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public JsonTextReader(TextReader reader);
    public JsonTextReader(Char[] externalBuffer);
    private static JsonTextReader();
    private StringBuffer GetBuffer();
    private void OnNewLine(int pos);
    private void ParseString(char quote);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private int ReadData(bool append, int charsRequired);
    protected virtual int ReadChars(Char[] buffer, int start, int count);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    [DebuggerStepThroughAttribute]
public virtual bool Read();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal virtual bool ReadInternal();
    private void ReadStringIntoBuffer(char quote);
    private void WriteCharToBuffer(StringBuffer buffer, char writeChar, int lastWritePosition, int writeToPosition);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private void ClearRecentString();
    private bool ParsePostValue();
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private bool EatWhitespace(bool oneOrMore);
    private void ParseConstructor();
    private void ParseNumber();
    private static object BigIntegerParse(string number, CultureInfo culture);
    private void ParseComment();
    private bool MatchValue(string value);
    private bool MatchValueWithTrailingSeparator(string value);
    private bool IsSeparator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private void ParseNumberNegativeInfinity();
    private void ParseNumberPositiveInfinity();
    private void ParseNumberNaN();
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    public Stream ReadBytesAsStream();
    private int ConvertBase64(Byte[] buffer, int bufferPos, Int32& buf, Int32& iter);
    private bool SkipToNextQouteInsideBuffer(Char& quote);
}
public class Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync : object {
    private static char UnicodeReplacementChar;
    private TextReader _reader;
    private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _buffer;
    private StringReference _stringReference;
    private JsonToken _tokenType;
    private object _value;
    private char _quoteChar;
    internal State _currentState;
    internal ReadType _readType;
    private JsonPosition _currentPosition;
    private CultureInfo _culture;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    internal DateParseHandling _dateParseHandling;
    private List`1<JsonPosition> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    internal State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public char QuoteChar { get; protected internal set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    public int Depth { get; }
    public string Path { get; }
    public CultureInfo Culture { get; public set; }
    public JsonTextReaderAsync(TextReader reader);
    internal void SetCharBuffer(Char[] chars);
    private StringBuffer GetBuffer();
    private void OnNewLine(int pos);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseString>d__14")]
private Task ParseString(char quote);
    private bool ParseDateIso(string text);
    private void ParseDateMicrosoft(string text);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private Task`1<int> ReadData(bool append);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadData>d__20")]
private Task`1<int> ReadData(bool append, int charsRequired);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<EnsureChars>d__21")]
private Task`1<bool> EnsureChars(int relativePosition, bool append);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadChars>d__22")]
private Task`1<bool> ReadChars(int relativePosition, bool append);
    private static TimeSpan ReadOffset(string offsetText);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsync>d__24")]
[DebuggerStepThroughAttribute]
public Task`1<bool> ReadAsync();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsBytes>d__25")]
public Task`1<Byte[]> ReadAsBytes();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsDecimal>d__26")]
public Task`1<Nullable`1<decimal>> ReadAsDecimal();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsInt32>d__27")]
public Task`1<Nullable`1<int>> ReadAsInt32();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsString>d__28")]
public Task`1<string> ReadAsString();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsDateTime>d__29")]
public Task`1<Nullable`1<DateTime>> ReadAsDateTime();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsDateTimeOffset>d__30")]
public Task`1<Nullable`1<DateTimeOffset>> ReadAsDateTimeOffset();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadInternal>d__31")]
internal Task`1<bool> ReadInternal();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadStringIntoBuffer>d__32")]
private Task ReadStringIntoBuffer(char quote);
    private void WriteCharToBuffer(StringBuffer buffer, char writeChar, int lastWritePosition, int writeToPosition);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseUnicode>d__34")]
private Task`1<char> ParseUnicode();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadNumberIntoBuffer>d__35")]
private Task ReadNumberIntoBuffer();
    private void ClearRecentString();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParsePostValue>d__37")]
private Task`1<bool> ParsePostValue();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseObject>d__38")]
private Task`1<bool> ParseObject();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseProperty>d__39")]
private Task`1<bool> ParseProperty();
    private bool ValidIdentifierChar(char value);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseUnquotedProperty>d__41")]
private Task ParseUnquotedProperty();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseValue>d__42")]
private Task`1<bool> ParseValue();
    private void ProcessLineFeed();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ProcessCarriageReturn>d__44")]
private Task ProcessCarriageReturn(bool append);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<EatWhitespace>d__45")]
private Task`1<bool> EatWhitespace(bool oneOrMore);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseConstructor>d__46")]
private Task ParseConstructor();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseNumber>d__47")]
private Task ParseNumber();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseComment>d__48")]
private Task ParseComment();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<MatchValue>d__49")]
private Task`1<bool> MatchValue(string value);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<MatchValueWithTrailingSeperator>d__50")]
private Task`1<bool> MatchValueWithTrailingSeperator(string value);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<IsSeperator>d__51")]
private Task`1<bool> IsSeperator(char c);
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseTrue>d__52")]
private Task ParseTrue();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseNull>d__53")]
private Task ParseNull();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseUndefined>d__54")]
private Task ParseUndefined();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseFalse>d__55")]
private Task ParseFalse();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseNumberNegativeInfinity>d__56")]
private Task ParseNumberNegativeInfinity();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseNumberPositiveInfinity>d__57")]
private Task ParseNumberPositiveInfinity();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ParseNumberNaN>d__58")]
private Task ParseNumberNaN();
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    internal State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual int get_Depth();
    public virtual string get_Path();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal JsonPosition GetPosition(int depth);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsDateTimeOffsetInternal>d__112")]
internal Task`1<Nullable`1<DateTimeOffset>> ReadAsDateTimeOffsetInternal();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsBytesInternal>d__113")]
internal Task`1<Byte[]> ReadAsBytesInternal();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsDecimalInternal>d__114")]
internal Task`1<Nullable`1<decimal>> ReadAsDecimalInternal();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsInt32Internal>d__115")]
internal Task`1<Nullable`1<int>> ReadAsInt32Internal();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsStringInternal>d__116")]
internal Task`1<string> ReadAsStringInternal();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<ReadAsDateTimeInternal>d__117")]
internal Task`1<Nullable`1<DateTime>> ReadAsDateTimeInternal();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<IsWrappedInTypeObject>d__118")]
private Task`1<bool> IsWrappedInTypeObject();
    [AsyncStateMachineAttribute("Raven.Imports.Newtonsoft.Json.JsonTextReaderAsync/<SkipAsync>d__119")]
public Task SkipAsync();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    private void UpdateScopeWithFinishedValue();
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    internal static bool IsPrimitiveToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Raven.Imports.Newtonsoft.Json.JsonTextWriter : JsonWriter {
    private TextWriter _writer;
    private Base64Encoder _base64Encoder;
    private char _indentChar;
    private int _indentation;
    private char _quoteChar;
    private bool _quoteName;
    private Boolean[] _charEscapeFlags;
    private Char[] _writeBuffer;
    private Char[] _indentChars;
    private Base64Encoder Base64Encoder { get; }
    public int Indentation { get; public set; }
    public char QuoteChar { get; public set; }
    public char IndentChar { get; public set; }
    public bool QuoteName { get; public set; }
    public JsonTextWriter(TextWriter textWriter);
    private Base64Encoder get_Base64Encoder();
    public int get_Indentation();
    public void set_Indentation(int value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public char get_IndentChar();
    public void set_IndentChar(char value);
    public bool get_QuoteName();
    public void set_QuoteName(bool value);
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    internal virtual void OnStringEscapeHandlingChanged();
    private void UpdateCharEscapeFlags();
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    private void WriteValueInternal(string value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteValue(string value);
    private void WriteEscapedString(string value, bool quote);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void EnsureWriteBuffer();
    private void WriteIntegerValue(long value);
    private void WriteIntegerValue(ulong uvalue);
    public void SealValue();
}
public enum Raven.Imports.Newtonsoft.Json.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public class Raven.Imports.Newtonsoft.Json.JsonValidatingReader : JsonReader {
    private JsonReader _reader;
    private Stack`1<SchemaScope> _stack;
    private JsonSchema _schema;
    private JsonSchemaModel _model;
    private SchemaScope _currentScope;
    [CompilerGeneratedAttribute]
private ValidationEventHandler ValidationEventHandler;
    private static IList`1<JsonSchemaModel> EmptySchemaList;
    public object Value { get; }
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public Type ValueType { get; }
    private IList`1<JsonSchemaModel> CurrentSchemas { get; }
    private IList`1<JsonSchemaModel> CurrentMemberSchemas { get; }
    public JsonSchema Schema { get; public set; }
    public JsonReader Reader { get; }
    private int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public JsonValidatingReader(JsonReader reader);
    private static JsonValidatingReader();
    [CompilerGeneratedAttribute]
public void add_ValidationEventHandler(ValidationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ValidationEventHandler(ValidationEventHandler value);
    public virtual object get_Value();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual Type get_ValueType();
    private void Push(SchemaScope scope);
    private SchemaScope Pop();
    private IList`1<JsonSchemaModel> get_CurrentSchemas();
    private IList`1<JsonSchemaModel> get_CurrentMemberSchemas();
    private void RaiseError(string message, JsonSchemaModel schema);
    private void OnValidationEvent(JsonSchemaException exception);
    public JsonSchema get_Schema();
    public void set_Schema(JsonSchema value);
    public JsonReader get_Reader();
    private void ValidateNotDisallowed(JsonSchemaModel schema);
    private Nullable`1<JsonSchemaType> GetCurrentNodeSchemaType();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual bool Read();
    private void ValidateCurrentToken();
    private void WriteToken(IList`1<JsonSchemaModel> schemas);
    private void ValidateEndObject(JsonSchemaModel schema);
    private void ValidateEndArray(JsonSchemaModel schema);
    private void ValidateNull(JsonSchemaModel schema);
    private void ValidateBoolean(JsonSchemaModel schema);
    private void ValidateString(JsonSchemaModel schema);
    private void ValidateInteger(JsonSchemaModel schema);
    private void ProcessValue();
    private void ValidateFloat(JsonSchemaModel schema);
    private static double FloatingPointRemainder(double dividend, double divisor);
    private static bool IsZero(double value);
    private void ValidatePropertyName(JsonSchemaModel schema);
    private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName);
    private bool ValidateArray(JsonSchemaModel schema);
    private bool ValidateObject(JsonSchemaModel schema);
    private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType);
    private sealed virtual override bool Raven.Imports.Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
public abstract class Raven.Imports.Newtonsoft.Json.JsonWriter : object {
    private static State[][] StateArray;
    internal static State[][] StateArrayTempate;
    private List`1<JsonPosition> _stack;
    private JsonPosition _currentPosition;
    private State _currentState;
    private Formatting _formatting;
    [CompilerGeneratedAttribute]
private bool <CloseOutput>k__BackingField;
    private DateFormatHandling _dateFormatHandling;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private StringEscapeHandling _stringEscapeHandling;
    private FloatFormatHandling _floatFormatHandling;
    private string _dateFormatString;
    private CultureInfo _culture;
    public bool CloseOutput { get; public set; }
    protected internal int Top { get; }
    public WriteState WriteState { get; }
    internal string ContainerPath { get; }
    public string Path { get; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    private static JsonWriter();
    internal static State[][] BuildStateArray();
    [CompilerGeneratedAttribute]
public bool get_CloseOutput();
    [CompilerGeneratedAttribute]
public void set_CloseOutput(bool value);
    protected internal int get_Top();
    public WriteState get_WriteState();
    internal string get_ContainerPath();
    public string get_Path();
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    internal virtual void OnStringEscapeHandlingChanged();
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal void UpdateScopeWithFinishedValue();
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteEnd();
    public void WriteToken(JsonReader reader);
    public void WriteToken(JsonReader reader, bool writeChildren);
    public void WriteToken(JsonToken token, object value);
    public void WriteToken(JsonToken token);
    internal void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate);
    internal void WriteToken(JsonReader reader, int initialDepth, bool writeChildren, bool writeDateConstructorAsDate);
    private void WriteTokenInternal(JsonToken tokenType, object value);
    private void WriteConstructorDate(JsonReader reader);
    private void WriteEnd(JsonContainerType type);
    private void AutoCompleteAll();
    private JsonToken GetCloseTokenForType(JsonContainerType type);
    private void AutoCompleteClose(JsonContainerType type);
    protected virtual void WriteEnd(JsonToken token);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    internal void AutoComplete(JsonToken tokenBeingWritten);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<int> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ulong> value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteValue(Nullable`1<char> value);
    public virtual void WriteValue(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteValue(object value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose(bool disposing);
    internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value);
    private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value);
    protected void SetWriteState(JsonToken token, object value);
    internal void InternalWriteEnd(JsonContainerType container);
    internal void InternalWritePropertyName(string name);
    internal void InternalWriteRaw();
    internal void InternalWriteStart(JsonToken token, JsonContainerType container);
    internal void InternalWriteValue(JsonToken token);
    internal void InternalWriteWhitespace(string ws);
    internal void InternalWriteComment();
}
public class Raven.Imports.Newtonsoft.Json.JsonWriterException : JsonException {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; private set; }
    public JsonWriterException(string message);
    public JsonWriterException(string message, Exception innerException);
    public JsonWriterException(SerializationInfo info, StreamingContext context);
    internal JsonWriterException(string message, Exception innerException, string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex);
    internal static JsonWriterException Create(string path, string message, Exception ex);
}
[ExtensionAttribute]
public static class Raven.Imports.Newtonsoft.Json.Linq.Extensions : object {
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AncestorsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> DescendantsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<JToken> value);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<T> value);
    [ExtensionAttribute]
[IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.Extensions/<Values>d__11`2")]
internal static IEnumerable`1<U> Values(IEnumerable`1<T> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Children(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.Extensions/<Convert>d__14`2")]
[ExtensionAttribute]
internal static IEnumerable`1<U> Convert(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static U Convert(T token);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source);
}
[DefaultMemberAttribute("Item")]
public interface Raven.Imports.Newtonsoft.Json.Linq.IJEnumerable`1 {
    public IJEnumerable`1<JToken> Item { get; }
    public abstract virtual IJEnumerable`1<JToken> get_Item(object key);
}
[DefaultMemberAttribute("Item")]
public class Raven.Imports.Newtonsoft.Json.Linq.JArray : JContainer {
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public bool IsReadOnly { get; }
    public JArray(JArray other);
    public JArray(Object[] content);
    public JArray(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public static JArray Load(JsonReader reader);
    public static JArray Parse(string json);
    public static JArray FromObject(object o);
    public static JArray FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverterCollection converters);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    public sealed virtual int IndexOf(JToken item);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
    internal virtual int GetDeepHashCode();
}
[DefaultMemberAttribute("Item")]
public class Raven.Imports.Newtonsoft.Json.Linq.JConstructor : JContainer {
    private string _name;
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; public set; }
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JConstructor(JConstructor other);
    public JConstructor(string name, Object[] content);
    public JConstructor(string name, object content);
    public JConstructor(string name);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    public string get_Name();
    public void set_Name(string value);
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public virtual void WriteTo(JsonWriter writer, JsonConverterCollection converters);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    internal virtual int GetDeepHashCode();
    public static JConstructor Load(JsonReader reader);
}
public abstract class Raven.Imports.Newtonsoft.Json.Linq.JContainer : JToken {
    internal ListChangedEventHandler _listChanged;
    internal AddingNewEventHandler _addingNew;
    internal NotifyCollectionChangedEventHandler _collectionChanged;
    private object _syncRoot;
    private bool _busy;
    protected IList`1<JToken> ChildrenTokens { get; }
    public bool HasValues { get; }
    public JToken First { get; }
    public JToken Last { get; }
    private JToken System.Collections.Generic.IList<Raven.Imports.Newtonsoft.Json.Linq.JToken>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<Raven.Imports.Newtonsoft.Json.Linq.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    internal JContainer(JContainer other);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    internal void CheckReentrancy();
    internal virtual IList`1<JToken> CreateChildrenCollection();
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    public virtual bool get_HasValues();
    internal bool ContentsEqual(JContainer container);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public virtual IEnumerable`1<T> Values();
    public IEnumerable`1<JToken> Descendants();
    public IEnumerable`1<JToken> DescendantsAndSelf();
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JContainer/<GetDescendants>d__34")]
internal IEnumerable`1<JToken> GetDescendants(bool self);
    internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck);
    internal int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void RemoveItemAt(int index);
    internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual void ReplaceItem(JToken existing, JToken replacement);
    internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    internal virtual void ValidateToken(JToken o, JToken existing);
    public virtual void Add(object content);
    internal void AddAndSkipParentCheck(JToken token);
    public void AddFirst(object content);
    internal void AddInternal(int index, object content, bool skipParentCheck);
    internal static JToken CreateFromContent(object content);
    public JsonWriter CreateWriter();
    public void ReplaceAll(object content);
    public void RemoveAll();
    internal abstract virtual void MergeItem(object content, JsonMergeSettings settings);
    public void Merge(object content);
    public void Merge(object content, JsonMergeSettings settings);
    internal void ReadTokenFrom(JsonReader reader);
    internal void ReadContentFrom(JsonReader r);
    internal int ContentsHashCode();
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override int System.Collections.Generic.IList<Raven.Imports.Newtonsoft.Json.Linq.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Raven.Imports.Newtonsoft.Json.Linq.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Raven.Imports.Newtonsoft.Json.Linq.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<Raven.Imports.Newtonsoft.Json.Linq.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<Raven.Imports.Newtonsoft.Json.Linq.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<Raven.Imports.Newtonsoft.Json.Linq.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Raven.Imports.Newtonsoft.Json.Linq.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<Raven.Imports.Newtonsoft.Json.Linq.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Raven.Imports.Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<Raven.Imports.Newtonsoft.Json.Linq.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Raven.Imports.Newtonsoft.Json.Linq.JToken>.Remove(JToken item);
    private JToken EnsureValue(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings);
}
[DefaultMemberAttribute("Item")]
public class Raven.Imports.Newtonsoft.Json.Linq.JEnumerable`1 : ValueType {
    public static JEnumerable`1<T> Empty;
    private IEnumerable`1<T> _enumerable;
    public IJEnumerable`1<JToken> Item { get; }
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IJEnumerable`1<JToken> get_Item(object key);
    public sealed virtual bool Equals(JEnumerable`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class Raven.Imports.Newtonsoft.Json.Linq.JObject : JContainer {
    private JPropertyKeyedCollection _properties;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>.Keys { get; }
    private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>>.IsReadOnly { get; }
    public JObject(JObject other);
    public JObject(Object[] content);
    public JObject(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    internal virtual bool DeepEquals(JToken node);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void ValidateToken(JToken o, JToken existing);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    internal void InternalPropertyChanged(JProperty childProperty);
    internal void InternalPropertyChanging(JProperty childProperty);
    internal virtual JToken CloneToken();
    public virtual JTokenType get_Type();
    public IEnumerable`1<JProperty> Properties();
    public JProperty Property(string name);
    public JEnumerable`1<JToken> PropertyValues();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JToken value);
    public static JObject Load(JsonReader reader);
    public static JObject Parse(string json);
    public static JObject FromObject(object o);
    public static JObject FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverterCollection converters);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public JToken GetValue(string propertyName);
    public JToken GetValue(string propertyName, StringComparison comparison);
    public bool TryGetValue(string propertyName, StringComparison comparison, JToken& value);
    public sealed virtual void Add(string propertyName, JToken value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>.ContainsKey(string key);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>.get_Keys();
    public sealed virtual bool Remove(string propertyName);
    public sealed virtual bool TryGetValue(string propertyName, JToken& value);
    private sealed virtual override ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Raven.Imports.Newtonsoft.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item);
    internal virtual int GetDeepHashCode();
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JObject/<GetEnumerator>d__56")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator();
    protected virtual void OnPropertyChanged(string propertyName);
    protected virtual void OnPropertyChanging(string propertyName);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
public class Raven.Imports.Newtonsoft.Json.Linq.JProperty : JContainer {
    private JPropertyList _content;
    private string _name;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; }
    public JToken Value { get; public set; }
    public JTokenType Type { get; }
    public JProperty(JProperty other);
    internal JProperty(string name);
    public JProperty(string name, Object[] content);
    public JProperty(string name, object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual bool RemoveItem(JToken item);
    internal virtual void RemoveItemAt(int index);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual bool ContainsItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    internal virtual void ClearItems();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    [DebuggerStepThroughAttribute]
public virtual JTokenType get_Type();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual void WriteTo(JsonWriter writer, JsonConverterCollection converters);
    internal virtual int GetDeepHashCode();
    public static JProperty Load(JsonReader reader);
}
public class Raven.Imports.Newtonsoft.Json.Linq.JPropertyDescriptor : PropertyDescriptor {
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    protected int NameHashCode { get; }
    public JPropertyDescriptor(string name);
    private static JObject CastInstance(object instance);
    public virtual bool CanResetValue(object component);
    public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    protected virtual int get_NameHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Raven.Imports.Newtonsoft.Json.Linq.JPropertyKeyedCollection : Collection`1<JToken> {
    private static IEqualityComparer`1<string> Comparer;
    private Dictionary`2<string, JToken> _dictionary;
    public JToken Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<JToken> Values { get; }
    private static JPropertyKeyedCollection();
    private void AddKey(string key, JToken item);
    protected void ChangeItemKey(JToken item, string newKey);
    protected virtual void ClearItems();
    public bool Contains(string key);
    private bool ContainsItem(JToken item);
    private void EnsureDictionary();
    private string GetKeyForItem(JToken item);
    protected virtual void InsertItem(int index, JToken item);
    public bool Remove(string key);
    protected virtual void RemoveItem(int index);
    private void RemoveKey(string key);
    protected virtual void SetItem(int index, JToken item);
    public JToken get_Item(string key);
    public bool TryGetValue(string key, JToken& value);
    public ICollection`1<string> get_Keys();
    public ICollection`1<JToken> get_Values();
    public bool Compare(JPropertyKeyedCollection other);
}
public class Raven.Imports.Newtonsoft.Json.Linq.JRaw : JValue {
    public JRaw(JRaw other);
    public JRaw(object rawJson);
    public static JRaw Create(JsonReader reader);
    internal virtual JToken CloneToken();
}
public class Raven.Imports.Newtonsoft.Json.Linq.JsonMergeSettings : object {
    private MergeArrayHandling _mergeArrayHandling;
    public MergeArrayHandling MergeArrayHandling { get; public set; }
    public MergeArrayHandling get_MergeArrayHandling();
    public void set_MergeArrayHandling(MergeArrayHandling value);
}
internal class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Index>k__BackingField;
    public Nullable`1<int> Index { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Nullable`1<int> value);
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter/<ExecuteFilter>d__4")]
public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
internal class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter : PathFilter {
    [CompilerGeneratedAttribute]
private List`1<int> <Indexes>k__BackingField;
    public List`1<int> Indexes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<int> get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(List`1<int> value);
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter/<ExecuteFilter>d__4")]
public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
internal class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <End>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Step>k__BackingField;
    public Nullable`1<int> Start { get; public set; }
    public Nullable`1<int> End { get; public set; }
    public Nullable`1<int> Step { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_End();
    [CompilerGeneratedAttribute]
public void set_End(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Step();
    [CompilerGeneratedAttribute]
public void set_Step(Nullable`1<int> value);
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter/<ExecuteFilter>d__12")]
public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
    private bool IsValid(int index, int stopIndex, bool positiveStep);
}
internal class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.BooleanQueryExpression : QueryExpression {
    [CompilerGeneratedAttribute]
private List`1<PathFilter> <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private JValue <Value>k__BackingField;
    public List`1<PathFilter> Path { get; public set; }
    public JValue Value { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<PathFilter> get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(List`1<PathFilter> value);
    [CompilerGeneratedAttribute]
public JValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(JValue value);
    public virtual bool IsMatch(JToken t);
}
internal class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.CompositeExpression : QueryExpression {
    [CompilerGeneratedAttribute]
private List`1<QueryExpression> <Expressions>k__BackingField;
    public List`1<QueryExpression> Expressions { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<QueryExpression> get_Expressions();
    [CompilerGeneratedAttribute]
public void set_Expressions(List`1<QueryExpression> value);
    public virtual bool IsMatch(JToken t);
}
internal class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.FieldFilter : PathFilter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JsonPath.FieldFilter/<ExecuteFilter>d__4")]
public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
internal class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter : PathFilter {
    [CompilerGeneratedAttribute]
private List`1<string> <Names>k__BackingField;
    public List`1<string> Names { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Names();
    [CompilerGeneratedAttribute]
public void set_Names(List`1<string> value);
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter/<ExecuteFilter>d__4")]
public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
internal class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.JPath : object {
    private string _expression;
    [CompilerGeneratedAttribute]
private List`1<PathFilter> <Filters>k__BackingField;
    private int _currentIndex;
    public List`1<PathFilter> Filters { get; private set; }
    public JPath(string expression);
    [CompilerGeneratedAttribute]
public List`1<PathFilter> get_Filters();
    [CompilerGeneratedAttribute]
private void set_Filters(List`1<PathFilter> value);
    private void ParseMain();
    private bool ParsePath(List`1<PathFilter> filters, int currentPartStartIndex, bool query);
    private PathFilter ParseIndexer(char indexerOpenChar);
    private PathFilter ParseArrayIndexer(char indexerCloseChar);
    private void EatWhitespace();
    private PathFilter ParseQuery(char indexerCloseChar);
    private QueryExpression ParseExpression();
    private object ParseValue();
    private string ReadQuotedString();
    private bool Match(string s);
    private QueryOperator ParseOperator();
    private PathFilter ParseQuotedField(char indexerCloseChar);
    private void EnsureLength(string message);
    internal IEnumerable`1<JToken> Evaluate(JToken t, bool errorWhenNoMatch);
    internal static IEnumerable`1<JToken> Evaluate(List`1<PathFilter> filters, JToken t, bool errorWhenNoMatch);
}
internal abstract class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.PathFilter : object {
    public abstract virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
    protected static JToken GetTokenIndex(JToken t, bool errorWhenNoMatch, int index);
}
internal abstract class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.QueryExpression : object {
    [CompilerGeneratedAttribute]
private QueryOperator <Operator>k__BackingField;
    public QueryOperator Operator { get; public set; }
    [CompilerGeneratedAttribute]
public QueryOperator get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(QueryOperator value);
    public abstract virtual bool IsMatch(JToken t);
}
internal class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.QueryFilter : PathFilter {
    [CompilerGeneratedAttribute]
private QueryExpression <Expression>k__BackingField;
    public QueryExpression Expression { get; public set; }
    [CompilerGeneratedAttribute]
public QueryExpression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(QueryExpression value);
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JsonPath.QueryFilter/<ExecuteFilter>d__4")]
public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
internal enum Raven.Imports.Newtonsoft.Json.Linq.JsonPath.QueryOperator : Enum {
    public int value__;
    public static QueryOperator None;
    public static QueryOperator Equals;
    public static QueryOperator NotEquals;
    public static QueryOperator Exists;
    public static QueryOperator LessThan;
    public static QueryOperator LessThanOrEquals;
    public static QueryOperator GreaterThan;
    public static QueryOperator GreaterThanOrEquals;
    public static QueryOperator And;
    public static QueryOperator Or;
}
internal class Raven.Imports.Newtonsoft.Json.Linq.JsonPath.ScanFilter : PathFilter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JsonPath.ScanFilter/<ExecuteFilter>d__4")]
public virtual IEnumerable`1<JToken> ExecuteFilter(IEnumerable`1<JToken> current, bool errorWhenNoMatch);
}
[DefaultMemberAttribute("Item")]
public abstract class Raven.Imports.Newtonsoft.Json.Linq.JToken : object {
    private static JTokenEqualityComparer _equalityComparer;
    private JContainer _parent;
    private JToken _previous;
    private JToken _next;
    private object _annotations;
    private static JTokenType[] BooleanTypes;
    private static JTokenType[] NumberTypes;
    private static JTokenType[] BigIntegerTypes;
    private static JTokenType[] StringTypes;
    private static JTokenType[] GuidTypes;
    private static JTokenType[] TimeSpanTypes;
    private static JTokenType[] UriTypes;
    private static JTokenType[] CharTypes;
    private static JTokenType[] DateTimeTypes;
    private static JTokenType[] BytesTypes;
    public static JTokenEqualityComparer EqualityComparer { get; }
    public JContainer Parent { get; internal set; }
    public JToken Root { get; }
    public JTokenType Type { get; }
    public bool HasValues { get; }
    public JToken Next { get; internal set; }
    public JToken Previous { get; internal set; }
    public string Path { get; }
    public JToken Item { get; public set; }
    public JToken First { get; }
    public JToken Last { get; }
    private IJEnumerable`1<JToken> Raven.Imports.Newtonsoft.Json.Linq.IJEnumerable<Raven.Imports.Newtonsoft.Json.Linq.JToken>.Item { get; }
    private int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    private static JToken();
    public static JTokenEqualityComparer get_EqualityComparer();
    [DebuggerStepThroughAttribute]
public JContainer get_Parent();
    internal void set_Parent(JContainer value);
    public JToken get_Root();
    internal abstract virtual JToken CloneToken();
    internal abstract virtual bool DeepEquals(JToken node);
    public abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    public static bool DeepEquals(JToken t1, JToken t2);
    public JToken get_Next();
    internal void set_Next(JToken value);
    public JToken get_Previous();
    internal void set_Previous(JToken value);
    public string get_Path();
    public void AddAfterSelf(object content);
    public void AddBeforeSelf(object content);
    public IEnumerable`1<JToken> Ancestors();
    public IEnumerable`1<JToken> AncestorsAndSelf();
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JToken/<GetAncestors>d__42")]
internal IEnumerable`1<JToken> GetAncestors(bool self);
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JToken/<AfterSelf>d__43")]
public IEnumerable`1<JToken> AfterSelf();
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JToken/<BeforeSelf>d__44")]
public IEnumerable`1<JToken> BeforeSelf();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public virtual T Value(object key);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public JEnumerable`1<T> Children();
    public virtual IEnumerable`1<T> Values();
    public void Remove();
    public void Replace(JToken value);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverterCollection converters);
    public virtual string ToString();
    public string ToString(Formatting formatting, JsonConverter[] converters);
    private static JValue EnsureValue(JToken value);
    private static string GetType(JToken token);
    private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable);
    public static bool op_Explicit(JToken value);
    public static DateTimeOffset op_Explicit(JToken value);
    public static Nullable`1<bool> op_Explicit(JToken value);
    public static long op_Explicit(JToken value);
    public static Nullable`1<DateTime> op_Explicit(JToken value);
    public static Nullable`1<DateTimeOffset> op_Explicit(JToken value);
    public static Nullable`1<decimal> op_Explicit(JToken value);
    public static Nullable`1<double> op_Explicit(JToken value);
    public static Nullable`1<char> op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static short op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static char op_Explicit(JToken value);
    public static byte op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JToken value);
    public static Nullable`1<int> op_Explicit(JToken value);
    public static Nullable`1<short> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JToken value);
    public static Nullable`1<byte> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JToken value);
    public static DateTime op_Explicit(JToken value);
    public static Nullable`1<long> op_Explicit(JToken value);
    public static Nullable`1<float> op_Explicit(JToken value);
    public static decimal op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    public static string op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JToken value);
    public static Byte[] op_Explicit(JToken value);
    public static Guid op_Explicit(JToken value);
    public static Nullable`1<Guid> op_Explicit(JToken value);
    public static TimeSpan op_Explicit(JToken value);
    public static Nullable`1<TimeSpan> op_Explicit(JToken value);
    public static Uri op_Explicit(JToken value);
    private static BigInteger ToBigInteger(JToken value);
    private static Nullable`1<BigInteger> ToBigIntegerNullable(JToken value);
    public static JToken op_Implicit(bool value);
    public static JToken op_Implicit(DateTimeOffset value);
    public static JToken op_Implicit(byte value);
    public static JToken op_Implicit(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<sbyte> value);
    public static JToken op_Implicit(Nullable`1<bool> value);
    public static JToken op_Implicit(long value);
    public static JToken op_Implicit(Nullable`1<DateTime> value);
    public static JToken op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JToken op_Implicit(Nullable`1<decimal> value);
    public static JToken op_Implicit(Nullable`1<double> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ushort value);
    public static JToken op_Implicit(int value);
    public static JToken op_Implicit(Nullable`1<int> value);
    public static JToken op_Implicit(DateTime value);
    public static JToken op_Implicit(Nullable`1<long> value);
    public static JToken op_Implicit(Nullable`1<float> value);
    public static JToken op_Implicit(decimal value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ulong> value);
    public static JToken op_Implicit(double value);
    public static JToken op_Implicit(float value);
    public static JToken op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ulong value);
    public static JToken op_Implicit(Byte[] value);
    public static JToken op_Implicit(Uri value);
    public static JToken op_Implicit(TimeSpan value);
    public static JToken op_Implicit(Nullable`1<TimeSpan> value);
    public static JToken op_Implicit(Guid value);
    public static JToken op_Implicit(Nullable`1<Guid> value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Raven.Imports.Newtonsoft.Json.Linq.JToken>.GetEnumerator();
    internal abstract virtual int GetDeepHashCode();
    private sealed virtual override IJEnumerable`1<JToken> Raven.Imports.Newtonsoft.Json.Linq.IJEnumerable<Raven.Imports.Newtonsoft.Json.Linq.JToken>.get_Item(object key);
    public JsonReader CreateReader();
    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer);
    public static JToken FromObject(object o);
    public static JToken FromObject(object o, JsonSerializer jsonSerializer);
    public T ToObject();
    public object ToObject(Type objectType);
    public T ToObject(JsonSerializer jsonSerializer);
    public object ToObject(Type objectType, JsonSerializer jsonSerializer);
    public static JToken ReadFrom(JsonReader reader);
    public static JToken Parse(string json);
    public static JToken Load(JsonReader reader);
    internal void SetLineInfo(IJsonLineInfo lineInfo);
    internal void SetLineInfo(int lineNumber, int linePosition);
    private sealed virtual override bool Raven.Imports.Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public JToken SelectToken(string path);
    public JToken SelectToken(string path, bool errorWhenNoMatch);
    public IEnumerable`1<JToken> SelectTokens(string path);
    public IEnumerable`1<JToken> SelectTokens(string path, bool errorWhenNoMatch);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private sealed virtual override object System.ICloneable.Clone();
    public JToken DeepClone();
    public void AddAnnotation(object annotation);
    public T Annotation();
    public object Annotation(Type type);
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JToken/<Annotations>d__174`1")]
public IEnumerable`1<T> Annotations();
    [IteratorStateMachineAttribute("Raven.Imports.Newtonsoft.Json.Linq.JToken/<Annotations>d__175")]
public IEnumerable`1<object> Annotations(Type type);
    public void RemoveAnnotations();
    public void RemoveAnnotations(Type type);
}
public class Raven.Imports.Newtonsoft.Json.Linq.JTokenEqualityComparer : object {
    public sealed virtual bool Equals(JToken x, JToken y);
    public sealed virtual int GetHashCode(JToken obj);
}
public class Raven.Imports.Newtonsoft.Json.Linq.JTokenReader : JsonReader {
    private string _initialPath;
    private JToken _root;
    private JToken _parent;
    private JToken _current;
    public JToken CurrentToken { get; }
    private int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public string Path { get; }
    public JTokenReader(JToken token);
    internal JTokenReader(JToken token, string initialPath);
    public JToken get_CurrentToken();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal virtual bool ReadInternal();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    private string SafeToString(object value);
    private sealed virtual override bool Raven.Imports.Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public virtual string get_Path();
}
public enum Raven.Imports.Newtonsoft.Json.Linq.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
    public static JTokenType Guid;
    public static JTokenType Uri;
    public static JTokenType TimeSpan;
}
public class Raven.Imports.Newtonsoft.Json.Linq.JTokenWriter : JsonWriter {
    private JContainer _token;
    private JContainer _parent;
    private JValue _value;
    private JToken _current;
    public JToken CurrentToken { get; }
    public JToken Token { get; }
    public JTokenWriter(JContainer container);
    public JToken get_CurrentToken();
    public JToken get_Token();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    private void AddParent(JContainer container);
    private void RemoveParent();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    private void AddValue(object value, JsonToken token);
    internal void AddValue(JValue value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteComment(string text);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Uri value);
}
public class Raven.Imports.Newtonsoft.Json.Linq.JValue : JToken {
    private JTokenType _valueType;
    private object _value;
    public bool HasValues { get; }
    public JTokenType Type { get; }
    public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    public JValue(JValue other);
    public JValue(long value);
    public JValue(decimal value);
    public JValue(char value);
    [CLSCompliantAttribute("False")]
public JValue(ulong value);
    public JValue(double value);
    public JValue(float value);
    public JValue(DateTime value);
    public JValue(DateTimeOffset value);
    public JValue(bool value);
    public JValue(string value);
    public JValue(Guid value);
    public JValue(Uri value);
    public JValue(TimeSpan value);
    public JValue(object value);
    internal virtual bool DeepEquals(JToken node);
    public virtual bool get_HasValues();
    private static int CompareBigInteger(BigInteger i1, object i2);
    internal static int Compare(JTokenType valueType, object objA, object objB);
    private static int CompareFloat(object objA, object objB);
    private static bool Operation(ExpressionType operation, object objA, object objB, Object& result);
    internal virtual JToken CloneToken();
    public static JValue CreateComment(string value);
    public static JValue CreateString(string value);
    public static JValue CreateNull();
    public static JValue CreateUndefined();
    private static JTokenType GetValueType(Nullable`1<JTokenType> current, object value);
    private static JTokenType GetStringValueType(Nullable`1<JTokenType> current);
    public virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual void WriteTo(JsonWriter writer, JsonConverterCollection converters);
    internal virtual int GetDeepHashCode();
    private static bool ValuesEquals(JValue v1, JValue v2);
    public sealed virtual bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(JValue obj);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
}
public enum Raven.Imports.Newtonsoft.Json.Linq.MergeArrayHandling : Enum {
    public int value__;
    public static MergeArrayHandling Concat;
    public static MergeArrayHandling Union;
    public static MergeArrayHandling Replace;
    public static MergeArrayHandling Merge;
}
public enum Raven.Imports.Newtonsoft.Json.MemberSerialization : Enum {
    public int value__;
    public static MemberSerialization OptOut;
    public static MemberSerialization OptIn;
    public static MemberSerialization Fields;
}
public enum Raven.Imports.Newtonsoft.Json.MetadataPropertyHandling : Enum {
    public int value__;
    public static MetadataPropertyHandling Default;
    public static MetadataPropertyHandling ReadAhead;
    public static MetadataPropertyHandling Ignore;
}
public enum Raven.Imports.Newtonsoft.Json.MissingMemberHandling : Enum {
    public int value__;
    public static MissingMemberHandling Ignore;
    public static MissingMemberHandling Error;
}
public enum Raven.Imports.Newtonsoft.Json.NullValueHandling : Enum {
    public int value__;
    public static NullValueHandling Include;
    public static NullValueHandling Ignore;
}
public enum Raven.Imports.Newtonsoft.Json.ObjectCreationHandling : Enum {
    public int value__;
    public static ObjectCreationHandling Auto;
    public static ObjectCreationHandling Reuse;
    public static ObjectCreationHandling Replace;
}
[FlagsAttribute]
public enum Raven.Imports.Newtonsoft.Json.PreserveReferencesHandling : Enum {
    public int value__;
    public static PreserveReferencesHandling None;
    public static PreserveReferencesHandling Objects;
    public static PreserveReferencesHandling Arrays;
    public static PreserveReferencesHandling All;
}
internal enum Raven.Imports.Newtonsoft.Json.ReadType : Enum {
    public int value__;
    public static ReadType Read;
    public static ReadType ReadAsInt32;
    public static ReadType ReadAsBytes;
    public static ReadType ReadAsString;
    public static ReadType ReadAsDecimal;
    public static ReadType ReadAsDateTime;
    public static ReadType ReadAsDateTimeOffset;
}
public enum Raven.Imports.Newtonsoft.Json.ReferenceLoopHandling : Enum {
    public int value__;
    public static ReferenceLoopHandling Error;
    public static ReferenceLoopHandling Ignore;
    public static ReferenceLoopHandling Serialize;
}
public enum Raven.Imports.Newtonsoft.Json.Required : Enum {
    public int value__;
    public static Required Default;
    public static Required AllowNull;
    public static Required Always;
}
[ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public static class Raven.Imports.Newtonsoft.Json.Schema.Extensions : object {
    [ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
[ExtensionAttribute]
public static bool IsValid(JToken source, JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public static bool IsValid(JToken source, JsonSchema schema, IList`1& errorMessages);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public static void Validate(JToken source, JsonSchema schema);
    [ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
[ExtensionAttribute]
public static void Validate(JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public class Raven.Imports.Newtonsoft.Json.Schema.JsonSchema : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Transient>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Requires>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Disallow>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Extends>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    private string _internalId;
    [CompilerGeneratedAttribute]
private string <DeferredReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReferencesResolved>k__BackingField;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public Nullable`1<bool> Required { get; public set; }
    public Nullable`1<bool> ReadOnly { get; public set; }
    public Nullable`1<bool> Hidden { get; public set; }
    public Nullable`1<bool> Transient { get; public set; }
    public string Description { get; public set; }
    public Nullable`1<JsonSchemaType> Type { get; public set; }
    public string Pattern { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public Nullable`1<bool> ExclusiveMinimum { get; public set; }
    public Nullable`1<bool> ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<JsonSchema> Items { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public JsonSchema AdditionalItems { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IDictionary`2<string, JsonSchema> Properties { get; public set; }
    public JsonSchema AdditionalProperties { get; public set; }
    public IDictionary`2<string, JsonSchema> PatternProperties { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public string Requires { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public Nullable`1<JsonSchemaType> Disallow { get; public set; }
    public JToken Default { get; public set; }
    public IList`1<JsonSchema> Extends { get; public set; }
    public string Format { get; public set; }
    internal string Location { get; internal set; }
    internal string InternalId { get; }
    internal string DeferredReference { get; internal set; }
    internal bool ReferencesResolved { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Transient();
    [CompilerGeneratedAttribute]
public void set_Transient(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchema value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchema value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public string get_Requires();
    [CompilerGeneratedAttribute]
public void set_Requires(string value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public JToken get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(JToken value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Extends();
    [CompilerGeneratedAttribute]
public void set_Extends(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
internal string get_Location();
    [CompilerGeneratedAttribute]
internal void set_Location(string value);
    internal string get_InternalId();
    [CompilerGeneratedAttribute]
internal string get_DeferredReference();
    [CompilerGeneratedAttribute]
internal void set_DeferredReference(string value);
    [CompilerGeneratedAttribute]
internal bool get_ReferencesResolved();
    [CompilerGeneratedAttribute]
internal void set_ReferencesResolved(bool value);
    public static JsonSchema Read(JsonReader reader);
    public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver);
    public static JsonSchema Parse(string json);
    public static JsonSchema Parse(string json, JsonSchemaResolver resolver);
    public void WriteTo(JsonWriter writer);
    public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver);
    public virtual string ToString();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
internal class Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaBuilder : object {
    private IList`1<JsonSchema> _stack;
    private JsonSchemaResolver _resolver;
    private IDictionary`2<string, JsonSchema> _documentSchemas;
    private JsonSchema _currentSchema;
    private JObject _rootSchema;
    private JsonSchema CurrentSchema { get; }
    public JsonSchemaBuilder(JsonSchemaResolver resolver);
    private void Push(JsonSchema value);
    private JsonSchema Pop();
    private JsonSchema get_CurrentSchema();
    internal JsonSchema Read(JsonReader reader);
    private string UnescapeReference(string reference);
    private JsonSchema ResolveReferences(JsonSchema schema);
    private JsonSchema BuildSchema(JToken token);
    private void ProcessSchemaProperties(JObject schemaObject);
    private void ProcessExtends(JToken token);
    private void ProcessEnum(JToken token);
    private void ProcessAdditionalProperties(JToken token);
    private void ProcessAdditionalItems(JToken token);
    private IDictionary`2<string, JsonSchema> ProcessProperties(JToken token);
    private void ProcessItems(JToken token);
    private Nullable`1<JsonSchemaType> ProcessType(JToken token);
    internal static JsonSchemaType MapType(string type);
    internal static string MapType(JsonSchemaType type);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
internal static class Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaConstants : object {
    public static string TypePropertyName;
    public static string PropertiesPropertyName;
    public static string ItemsPropertyName;
    public static string AdditionalItemsPropertyName;
    public static string RequiredPropertyName;
    public static string PatternPropertiesPropertyName;
    public static string AdditionalPropertiesPropertyName;
    public static string RequiresPropertyName;
    public static string MinimumPropertyName;
    public static string MaximumPropertyName;
    public static string ExclusiveMinimumPropertyName;
    public static string ExclusiveMaximumPropertyName;
    public static string MinimumItemsPropertyName;
    public static string MaximumItemsPropertyName;
    public static string PatternPropertyName;
    public static string MaximumLengthPropertyName;
    public static string MinimumLengthPropertyName;
    public static string EnumPropertyName;
    public static string ReadOnlyPropertyName;
    public static string TitlePropertyName;
    public static string DescriptionPropertyName;
    public static string FormatPropertyName;
    public static string DefaultPropertyName;
    public static string TransientPropertyName;
    public static string DivisibleByPropertyName;
    public static string HiddenPropertyName;
    public static string DisallowPropertyName;
    public static string ExtendsPropertyName;
    public static string IdPropertyName;
    public static string UniqueItemsPropertyName;
    public static string OptionValuePropertyName;
    public static string OptionLabelPropertyName;
    public static IDictionary`2<string, JsonSchemaType> JsonSchemaTypeMapping;
    private static JsonSchemaConstants();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public class Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public string Path { get; private set; }
    public JsonSchemaException(string message);
    public JsonSchemaException(string message, Exception innerException);
    public JsonSchemaException(SerializationInfo info, StreamingContext context);
    internal JsonSchemaException(string message, Exception innerException, string path, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public class Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaGenerator : object {
    [CompilerGeneratedAttribute]
private UndefinedSchemaIdHandling <UndefinedSchemaIdHandling>k__BackingField;
    private IContractResolver _contractResolver;
    private JsonSchemaResolver _resolver;
    private IList`1<TypeSchema> _stack;
    private JsonSchema _currentSchema;
    public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    private JsonSchema CurrentSchema { get; }
    [CompilerGeneratedAttribute]
public UndefinedSchemaIdHandling get_UndefinedSchemaIdHandling();
    [CompilerGeneratedAttribute]
public void set_UndefinedSchemaIdHandling(UndefinedSchemaIdHandling value);
    public IContractResolver get_ContractResolver();
    public void set_ContractResolver(IContractResolver value);
    private JsonSchema get_CurrentSchema();
    private void Push(TypeSchema typeSchema);
    private TypeSchema Pop();
    public JsonSchema Generate(Type type);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver);
    public JsonSchema Generate(Type type, bool rootSchemaNullable);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable);
    private string GetTitle(Type type);
    private string GetDescription(Type type);
    private string GetTypeId(Type type, bool explicitOnly);
    private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required);
    private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private void GenerateObjectSchema(Type type, JsonObjectContract contract);
    private void GenerateISerializableContract(Type type, JsonISerializableContract contract);
    internal static bool HasFlag(Nullable`1<JsonSchemaType> value, JsonSchemaType flag);
    private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
internal class Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaModel : object {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Patterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchemaModel> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Disallow>k__BackingField;
    public bool Required { get; public set; }
    public JsonSchemaType Type { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public bool ExclusiveMinimum { get; public set; }
    public bool ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<string> Patterns { get; public set; }
    public IList`1<JsonSchemaModel> Items { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> Properties { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> PatternProperties { get; public set; }
    public JsonSchemaModel AdditionalProperties { get; public set; }
    public JsonSchemaModel AdditionalItems { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public JsonSchemaType Disallow { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(JsonSchemaType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Patterns();
    [CompilerGeneratedAttribute]
public void set_Patterns(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchemaModel> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(JsonSchemaType value);
    public static JsonSchemaModel Create(IList`1<JsonSchema> schemata);
    private static void Combine(JsonSchemaModel model, JsonSchema schema);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
internal class Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaModelBuilder : object {
    private JsonSchemaNodeCollection _nodes;
    private Dictionary`2<JsonSchemaNode, JsonSchemaModel> _nodeModels;
    private JsonSchemaNode _node;
    public JsonSchemaModel Build(JsonSchema schema);
    public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema);
    public void AddProperties(IDictionary`2<string, JsonSchema> source, IDictionary`2<string, JsonSchemaNode> target);
    public void AddProperty(IDictionary`2<string, JsonSchemaNode> target, string propertyName, JsonSchema schema);
    public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema);
    public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema);
    public void AddAdditionalItems(JsonSchemaNode parentNode, JsonSchema schema);
    private JsonSchemaModel BuildNodeModel(JsonSchemaNode node);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
internal class Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaNode : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<JsonSchema> <Schemas>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<JsonSchemaNode> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalItems>k__BackingField;
    public string Id { get; private set; }
    public ReadOnlyCollection`1<JsonSchema> Schemas { get; private set; }
    public Dictionary`2<string, JsonSchemaNode> Properties { get; private set; }
    public Dictionary`2<string, JsonSchemaNode> PatternProperties { get; private set; }
    public List`1<JsonSchemaNode> Items { get; private set; }
    public JsonSchemaNode AdditionalProperties { get; public set; }
    public JsonSchemaNode AdditionalItems { get; public set; }
    public JsonSchemaNode(JsonSchema schema);
    private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<JsonSchema> get_Schemas();
    [CompilerGeneratedAttribute]
private void set_Schemas(ReadOnlyCollection`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(Dictionary`2<string, JsonSchemaNode> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_PatternProperties();
    [CompilerGeneratedAttribute]
private void set_PatternProperties(Dictionary`2<string, JsonSchemaNode> value);
    [CompilerGeneratedAttribute]
public List`1<JsonSchemaNode> get_Items();
    [CompilerGeneratedAttribute]
private void set_Items(List`1<JsonSchemaNode> value);
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaNode value);
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaNode value);
    public JsonSchemaNode Combine(JsonSchema schema);
    public static string GetId(IEnumerable`1<JsonSchema> schemata);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
internal class Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaNodeCollection : KeyedCollection`2<string, JsonSchemaNode> {
    protected virtual string GetKeyForItem(JsonSchemaNode item);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public class Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaResolver : object {
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <LoadedSchemas>k__BackingField;
    public IList`1<JsonSchema> LoadedSchemas { get; protected set; }
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_LoadedSchemas();
    [CompilerGeneratedAttribute]
protected void set_LoadedSchemas(IList`1<JsonSchema> value);
    public virtual JsonSchema GetSchema(string reference);
}
[FlagsAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public enum Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaType : Enum {
    public int value__;
    public static JsonSchemaType None;
    public static JsonSchemaType String;
    public static JsonSchemaType Float;
    public static JsonSchemaType Integer;
    public static JsonSchemaType Boolean;
    public static JsonSchemaType Object;
    public static JsonSchemaType Array;
    public static JsonSchemaType Null;
    public static JsonSchemaType Any;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
internal class Raven.Imports.Newtonsoft.Json.Schema.JsonSchemaWriter : object {
    private JsonWriter _writer;
    private JsonSchemaResolver _resolver;
    public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver);
    private void ReferenceOrWriteSchema(JsonSchema schema);
    public void WriteSchema(JsonSchema schema);
    private void WriteSchemaDictionaryIfNotNull(JsonWriter writer, string propertyName, IDictionary`2<string, JsonSchema> properties);
    private void WriteItems(JsonSchema schema);
    private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type);
    private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public enum Raven.Imports.Newtonsoft.Json.Schema.UndefinedSchemaIdHandling : Enum {
    public int value__;
    public static UndefinedSchemaIdHandling None;
    public static UndefinedSchemaIdHandling UseTypeName;
    public static UndefinedSchemaIdHandling UseAssemblyQualifiedName;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public class Raven.Imports.Newtonsoft.Json.Schema.ValidationEventArgs : EventArgs {
    private JsonSchemaException _ex;
    public JsonSchemaException Exception { get; }
    public string Path { get; }
    public string Message { get; }
    internal ValidationEventArgs(JsonSchemaException ex);
    public JsonSchemaException get_Exception();
    public string get_Path();
    public string get_Message();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
public class Raven.Imports.Newtonsoft.Json.Schema.ValidationEventHandler : MulticastDelegate {
    public ValidationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Raven.Imports.Newtonsoft.Json.Serialization.CachedAttributeGetter`1 : object {
    private static ThreadSafeStore`2<object, T> TypeAttributeCache;
    private static CachedAttributeGetter`1();
    public static T GetAttribute(object type);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
    protected virtual string ResolvePropertyName(string propertyName);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.DefaultContractResolver : object {
    private static IContractResolver _instance;
    private static JsonConverterCollection BuiltInConverters;
    private static object TypeContractCacheLock;
    private static DefaultContractResolverState _sharedState;
    private DefaultContractResolverState _instanceState;
    private bool _sharedCache;
    [CompilerGeneratedAttribute]
private BindingFlags <DefaultMembersSearchFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeCompilerGeneratedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableAttribute>k__BackingField;
    internal static IContractResolver Instance { get; }
    public bool DynamicCodeGeneration { get; }
    [ObsoleteAttribute("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
public BindingFlags DefaultMembersSearchFlags { get; public set; }
    public bool SerializeCompilerGeneratedMembers { get; public set; }
    public bool IgnoreSerializableInterface { get; public set; }
    public bool IgnoreSerializableAttribute { get; public set; }
    private static DefaultContractResolver();
    [ObsoleteAttribute("DefaultContractResolver(bool) is obsolete. Use the parameterless constructor and cache instances of the contract resolver within your application for optimal performance.")]
public DefaultContractResolver(bool shareCache);
    internal static IContractResolver get_Instance();
    public bool get_DynamicCodeGeneration();
    [CompilerGeneratedAttribute]
public BindingFlags get_DefaultMembersSearchFlags();
    [CompilerGeneratedAttribute]
public void set_DefaultMembersSearchFlags(BindingFlags value);
    [CompilerGeneratedAttribute]
public bool get_SerializeCompilerGeneratedMembers();
    [CompilerGeneratedAttribute]
public void set_SerializeCompilerGeneratedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableInterface();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableInterface(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableAttribute();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableAttribute(bool value);
    internal DefaultContractResolverState GetState();
    public virtual JsonContract ResolveContract(Type type);
    protected virtual List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private bool ShouldSerializeEntityMember(MemberInfo memberInfo);
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    private MemberInfo GetExtensionDataMemberForType(Type type);
    private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member);
    private ConstructorInfo GetAttributeConstructor(Type objectType);
    private ConstructorInfo GetParametrizedConstructor(Type objectType);
    protected virtual IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    protected virtual JsonConverter ResolveContractConverter(Type objectType);
    private Func`1<object> GetDefaultCreator(Type createdType);
    private void InitializeContract(JsonContract contract);
    private void ResolveCallbackMethods(JsonContract contract, Type t);
    private void GetCallbackMethodsForType(Type type, List`1& onSerializing, List`1& onSerialized, List`1& onDeserializing, List`1& onDeserialized, List`1& onError);
    private static bool IsConcurrentOrObservableCollection(Type t);
    private static bool ShouldSkipDeserialized(Type t);
    private static bool ShouldSkipSerializing(Type t);
    private List`1<Type> GetClassHierarchyForType(Type type);
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType);
    protected virtual JsonArrayContract CreateArrayContract(Type objectType);
    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType);
    protected virtual JsonLinqContract CreateLinqContract(Type objectType);
    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType);
    protected virtual JsonDynamicContract CreateDynamicContract(Type objectType);
    protected virtual JsonStringContract CreateStringContract(Type objectType);
    protected virtual JsonContract CreateContract(Type objectType);
    internal static bool IsJsonPrimitiveType(Type t);
    internal static bool IsIConvertible(Type t);
    internal static bool CanConvertToString(Type type);
    private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType);
    internal static string GetClrTypeFullName(Type type);
    protected virtual IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization);
    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, Boolean& allowNonPublicAccess);
    private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member);
    private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess);
    protected virtual string ResolvePropertyName(string propertyName);
    protected virtual string ResolveDictionaryKey(string dictionaryKey);
    public string GetResolvedPropertyName(string propertyName);
}
internal class Raven.Imports.Newtonsoft.Json.Serialization.DefaultContractResolverState : object {
    public Dictionary`2<ResolverContractKey, JsonContract> ContractCache;
    public PropertyNameTable NameTable;
}
internal class Raven.Imports.Newtonsoft.Json.Serialization.DefaultReferenceResolver : object {
    private int _referenceCount;
    private BidirectionalDictionary`2<string, object> GetMappings(object context);
    public sealed virtual object ResolveReference(object context, string reference);
    public sealed virtual string GetReference(object context, object value);
    public sealed virtual void AddReference(object context, string reference, object value);
    public sealed virtual bool IsReferenced(object context, object value);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
    internal static DefaultSerializationBinder Instance;
    private ThreadSafeStore`2<TypeNameKey, Type> _typeCache;
    private static DefaultSerializationBinder();
    private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey);
    public virtual Type BindToType(string assemblyName, string typeName);
    public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.DiagnosticsTraceWriter : object {
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    private TraceEventType GetTraceEventType(TraceLevel level);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.DynamicValueProvider : object {
    private MemberInfo _memberInfo;
    private Func`2<object, object> _getter;
    private Action`2<object, object> _setter;
    public DynamicValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.ErrorContext : object {
    [CompilerGeneratedAttribute]
private bool <Traced>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OriginalObject>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    internal bool Traced { get; internal set; }
    public Exception Error { get; private set; }
    public object OriginalObject { get; private set; }
    public object Member { get; private set; }
    public string Path { get; private set; }
    public bool Handled { get; public set; }
    internal ErrorContext(object originalObject, object member, string path, Exception error);
    [CompilerGeneratedAttribute]
internal bool get_Traced();
    [CompilerGeneratedAttribute]
internal void set_Traced(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public object get_OriginalObject();
    [CompilerGeneratedAttribute]
private void set_OriginalObject(object value);
    [CompilerGeneratedAttribute]
public object get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(object value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.ErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <CurrentObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorContext <ErrorContext>k__BackingField;
    public object CurrentObject { get; private set; }
    public ErrorContext ErrorContext { get; private set; }
    public ErrorEventArgs(object currentObject, ErrorContext errorContext);
    [CompilerGeneratedAttribute]
public object get_CurrentObject();
    [CompilerGeneratedAttribute]
private void set_CurrentObject(object value);
    [CompilerGeneratedAttribute]
public ErrorContext get_ErrorContext();
    [CompilerGeneratedAttribute]
private void set_ErrorContext(ErrorContext value);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.ExpressionValueProvider : object {
    private MemberInfo _memberInfo;
    private Func`2<object, object> _getter;
    private Action`2<object, object> _setter;
    public ExpressionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.ExtensionDataGetter : MulticastDelegate {
    public ExtensionDataGetter(object object, IntPtr method);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> Invoke(object o);
    public virtual IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> EndInvoke(IAsyncResult result);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.ExtensionDataSetter : MulticastDelegate {
    public ExtensionDataSetter(object object, IntPtr method);
    public virtual void Invoke(object o, string key, object value);
    public virtual IAsyncResult BeginInvoke(object o, string key, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface Raven.Imports.Newtonsoft.Json.Serialization.IAttributeProvider {
    public abstract virtual IList`1<Attribute> GetAttributes(bool inherit);
    public abstract virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
public interface Raven.Imports.Newtonsoft.Json.Serialization.IContractResolver {
    public abstract virtual JsonContract ResolveContract(Type type);
}
public interface Raven.Imports.Newtonsoft.Json.Serialization.IReferenceResolver {
    public abstract virtual object ResolveReference(object context, string reference);
    public abstract virtual string GetReference(object context, object value);
    public abstract virtual bool IsReferenced(object context, object value);
    public abstract virtual void AddReference(object context, string reference, object value);
}
public interface Raven.Imports.Newtonsoft.Json.Serialization.ITraceWriter {
    public TraceLevel LevelFilter { get; }
    public abstract virtual TraceLevel get_LevelFilter();
    public abstract virtual void Trace(TraceLevel level, string message, Exception ex);
}
public interface Raven.Imports.Newtonsoft.Json.Serialization.IValueProvider {
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonArrayContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private Type <CollectionItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMultidimensionalArray>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    private ObjectConstructor`1<object> _genericWrapperCreator;
    private Func`1<object> _genericTemporaryCollectionCreator;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    private ConstructorInfo _parametrizedConstructor;
    private ObjectConstructor`1<object> _parametrizedCreator;
    public Type CollectionItemType { get; private set; }
    public bool IsMultidimensionalArray { get; private set; }
    internal bool IsArray { get; private set; }
    internal bool ShouldCreateWrapper { get; private set; }
    internal bool CanDeserialize { get; private set; }
    internal ObjectConstructor`1<object> ParametrizedCreator { get; }
    internal bool HasParametrizedCreator { get; }
    public JsonArrayContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_CollectionItemType();
    [CompilerGeneratedAttribute]
private void set_CollectionItemType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsMultidimensionalArray();
    [CompilerGeneratedAttribute]
private void set_IsMultidimensionalArray(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsArray();
    [CompilerGeneratedAttribute]
private void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
private void set_ShouldCreateWrapper(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    internal ObjectConstructor`1<object> get_ParametrizedCreator();
    internal bool get_HasParametrizedCreator();
    internal IWrappedCollection CreateWrapper(object list);
    internal IList CreateTemporaryCollection();
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonContainerContract : JsonContract {
    private JsonContract _itemContract;
    private JsonContract _finalItemContract;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    internal JsonContract ItemContract { get; internal set; }
    internal JsonContract FinalItemContract { get; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
    internal JsonContract get_FinalItemContract();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
}
public abstract class Raven.Imports.Newtonsoft.Json.Serialization.JsonContract : object {
    internal bool IsNullable;
    internal bool IsConvertable;
    internal bool IsEnum;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;
    internal bool IsReadOnlyOrFixedSize;
    internal bool IsSealed;
    internal bool IsInstantiable;
    private List`1<SerializationCallback> _onDeserializedCallbacks;
    private IList`1<SerializationCallback> _onDeserializingCallbacks;
    private IList`1<SerializationCallback> _onSerializedCallbacks;
    private IList`1<SerializationCallback> _onSerializingCallbacks;
    private IList`1<SerializationErrorCallback> _onErrorCallbacks;
    private Type _createdType;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <InternalConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<object> <DefaultCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultCreatorNonPublic>k__BackingField;
    public Type UnderlyingType { get; private set; }
    public Type CreatedType { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    public JsonConverter Converter { get; public set; }
    internal JsonConverter InternalConverter { get; internal set; }
    public IList`1<SerializationCallback> OnDeserializedCallbacks { get; }
    public IList`1<SerializationCallback> OnDeserializingCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializedCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializingCallbacks { get; }
    public IList`1<SerializationErrorCallback> OnErrorCallbacks { get; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnDeserializedCallbacks collection.")]
public MethodInfo OnDeserialized { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnDeserializingCallbacks collection.")]
public MethodInfo OnDeserializing { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnSerializedCallbacks collection.")]
public MethodInfo OnSerialized { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnSerializingCallbacks collection.")]
public MethodInfo OnSerializing { get; public set; }
    [ObsoleteAttribute("This property is obsolete and has been replaced by the OnErrorCallbacks collection.")]
public MethodInfo OnError { get; public set; }
    public Func`1<object> DefaultCreator { get; public set; }
    public bool DefaultCreatorNonPublic { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    [CompilerGeneratedAttribute]
private void set_UnderlyingType(Type value);
    public Type get_CreatedType();
    public void set_CreatedType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [CompilerGeneratedAttribute]
internal JsonConverter get_InternalConverter();
    [CompilerGeneratedAttribute]
internal void set_InternalConverter(JsonConverter value);
    public IList`1<SerializationCallback> get_OnDeserializedCallbacks();
    public IList`1<SerializationCallback> get_OnDeserializingCallbacks();
    public IList`1<SerializationCallback> get_OnSerializedCallbacks();
    public IList`1<SerializationCallback> get_OnSerializingCallbacks();
    public IList`1<SerializationErrorCallback> get_OnErrorCallbacks();
    public MethodInfo get_OnDeserialized();
    public void set_OnDeserialized(MethodInfo value);
    public MethodInfo get_OnDeserializing();
    public void set_OnDeserializing(MethodInfo value);
    public MethodInfo get_OnSerialized();
    public void set_OnSerialized(MethodInfo value);
    public MethodInfo get_OnSerializing();
    public void set_OnSerializing(MethodInfo value);
    public MethodInfo get_OnError();
    public void set_OnError(MethodInfo value);
    [CompilerGeneratedAttribute]
public Func`1<object> get_DefaultCreator();
    [CompilerGeneratedAttribute]
public void set_DefaultCreator(Func`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_DefaultCreatorNonPublic();
    [CompilerGeneratedAttribute]
public void set_DefaultCreatorNonPublic(bool value);
    internal void InvokeOnSerializing(object o, StreamingContext context);
    internal void InvokeOnSerialized(object o, StreamingContext context);
    internal void InvokeOnDeserializing(object o, StreamingContext context);
    internal void InvokeOnDeserialized(object o, StreamingContext context);
    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext);
    internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo);
    internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo);
}
internal enum Raven.Imports.Newtonsoft.Json.Serialization.JsonContractType : Enum {
    public int value__;
    public static JsonContractType None;
    public static JsonContractType Object;
    public static JsonContractType Array;
    public static JsonContractType Primitive;
    public static JsonContractType String;
    public static JsonContractType Dictionary;
    public static JsonContractType Dynamic;
    public static JsonContractType Serializable;
    public static JsonContractType Linq;
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonDictionaryContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private Func`2<string, string> <DictionaryKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContract <KeyContract>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    private ObjectConstructor`1<object> _genericWrapperCreator;
    private Func`1<object> _genericTemporaryDictionaryCreator;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    private ConstructorInfo _parametrizedConstructor;
    private ObjectConstructor`1<object> _parametrizedCreator;
    [ObsoleteAttribute("PropertyNameResolver is obsolete. Use DictionaryKeyResolver instead.")]
public Func`2<string, string> PropertyNameResolver { get; public set; }
    public Func`2<string, string> DictionaryKeyResolver { get; public set; }
    public Type DictionaryKeyType { get; private set; }
    public Type DictionaryValueType { get; private set; }
    internal JsonContract KeyContract { get; internal set; }
    internal bool ShouldCreateWrapper { get; private set; }
    internal ObjectConstructor`1<object> ParametrizedCreator { get; }
    internal bool HasParametrizedCreator { get; }
    public JsonDictionaryContract(Type underlyingType);
    public Func`2<string, string> get_PropertyNameResolver();
    public void set_PropertyNameResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_DictionaryKeyResolver();
    [CompilerGeneratedAttribute]
public void set_DictionaryKeyResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
private void set_DictionaryKeyType(Type value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
private void set_DictionaryValueType(Type value);
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
private void set_ShouldCreateWrapper(bool value);
    internal ObjectConstructor`1<object> get_ParametrizedCreator();
    internal bool get_HasParametrizedCreator();
    internal IWrappedDictionary CreateWrapper(object dictionary);
    internal IDictionary CreateTemporaryDictionary();
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonDynamicContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, string> <PropertyNameResolver>k__BackingField;
    private ThreadSafeStore`2<string, CallSite`1<Func`3<CallSite, object, object>>> _callSiteGetters;
    private ThreadSafeStore`2<string, CallSite`1<Func`4<CallSite, object, object, object>>> _callSiteSetters;
    public JsonPropertyCollection Properties { get; private set; }
    public Func`2<string, string> PropertyNameResolver { get; public set; }
    public JsonDynamicContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(JsonPropertyCollection value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_PropertyNameResolver();
    [CompilerGeneratedAttribute]
public void set_PropertyNameResolver(Func`2<string, string> value);
    private static CallSite`1<Func`3<CallSite, object, object>> CreateCallSiteGetter(string name);
    private static CallSite`1<Func`4<CallSite, object, object, object>> CreateCallSiteSetter(string name);
    internal bool TryGetMember(IDynamicMetaObjectProvider dynamicProvider, string name, Object& value);
    internal bool TrySetMember(IDynamicMetaObjectProvider dynamicProvider, string name, object value);
}
internal class Raven.Imports.Newtonsoft.Json.Serialization.JsonFormatterConverter : object {
    private JsonSerializerInternalReader _reader;
    private JsonISerializableContract _contract;
    private JsonProperty _member;
    public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member);
    private T GetTokenValue(object value);
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    public sealed virtual ushort ToUInt16(object value);
    public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual ulong ToUInt64(object value);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonISerializableContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField;
    public ObjectConstructor`1<object> ISerializableCreator { get; public set; }
    public JsonISerializableContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_ISerializableCreator();
    [CompilerGeneratedAttribute]
public void set_ISerializableCreator(ObjectConstructor`1<object> value);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonLinqContract : JsonContract {
    public JsonLinqContract(Type underlyingType);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonObjectContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private MemberSerialization <MemberSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Required> <ItemRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <CreatorParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataSetter <ExtensionDataSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataGetter <ExtensionDataGetter>k__BackingField;
    private Nullable`1<bool> _hasRequiredOrDefaultValueProperties;
    private ConstructorInfo _parametrizedConstructor;
    private ConstructorInfo _overrideConstructor;
    private ObjectConstructor`1<object> _overrideCreator;
    private ObjectConstructor`1<object> _parametrizedCreator;
    public MemberSerialization MemberSerialization { get; public set; }
    public Nullable`1<Required> ItemRequired { get; public set; }
    public JsonPropertyCollection Properties { get; private set; }
    [ObsoleteAttribute("ConstructorParameters is obsolete. Use CreatorParameters instead.")]
public JsonPropertyCollection ConstructorParameters { get; }
    public JsonPropertyCollection CreatorParameters { get; private set; }
    [ObsoleteAttribute("OverrideConstructor is obsolete. Use OverrideCreator instead.")]
public ConstructorInfo OverrideConstructor { get; public set; }
    [ObsoleteAttribute("ParametrizedConstructor is obsolete. Use OverrideCreator instead.")]
public ConstructorInfo ParametrizedConstructor { get; public set; }
    public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    internal ObjectConstructor`1<object> ParametrizedCreator { get; }
    public ExtensionDataSetter ExtensionDataSetter { get; public set; }
    public ExtensionDataGetter ExtensionDataGetter { get; public set; }
    internal bool HasRequiredOrDefaultValueProperties { get; }
    public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public MemberSerialization get_MemberSerialization();
    [CompilerGeneratedAttribute]
public void set_MemberSerialization(MemberSerialization value);
    [CompilerGeneratedAttribute]
public Nullable`1<Required> get_ItemRequired();
    [CompilerGeneratedAttribute]
public void set_ItemRequired(Nullable`1<Required> value);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(JsonPropertyCollection value);
    public JsonPropertyCollection get_ConstructorParameters();
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_CreatorParameters();
    [CompilerGeneratedAttribute]
private void set_CreatorParameters(JsonPropertyCollection value);
    public ConstructorInfo get_OverrideConstructor();
    public void set_OverrideConstructor(ConstructorInfo value);
    public ConstructorInfo get_ParametrizedConstructor();
    public void set_ParametrizedConstructor(ConstructorInfo value);
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    internal ObjectConstructor`1<object> get_ParametrizedCreator();
    [CompilerGeneratedAttribute]
public ExtensionDataSetter get_ExtensionDataSetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataSetter(ExtensionDataSetter value);
    [CompilerGeneratedAttribute]
public ExtensionDataGetter get_ExtensionDataGetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataGetter(ExtensionDataGetter value);
    internal bool get_HasRequiredOrDefaultValueProperties();
    [SecuritySafeCriticalAttribute]
internal object GetUninitializedObject();
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonProperty : object {
    internal Nullable`1<Required> _required;
    internal bool _hasExplicitDefaultValue;
    private object _defaultValue;
    private bool _hasGeneratedDefaultValue;
    private string _propertyName;
    internal bool _skipPropertyNameEscape;
    private Type _propertyType;
    [CompilerGeneratedAttribute]
private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnderlyingName>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueProvider <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IAttributeProvider <AttributeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <MemberConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMemberAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<object> <GetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, object> <SetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    internal JsonContract PropertyContract { get; internal set; }
    public string PropertyName { get; public set; }
    public Type DeclaringType { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public string UnderlyingName { get; public set; }
    public IValueProvider ValueProvider { get; public set; }
    public IAttributeProvider AttributeProvider { get; public set; }
    public Type PropertyType { get; public set; }
    public JsonConverter Converter { get; public set; }
    public JsonConverter MemberConverter { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public bool HasMemberAttribute { get; public set; }
    public object DefaultValue { get; public set; }
    public Required Required { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    public Nullable`1<NullValueHandling> NullValueHandling { get; public set; }
    public Nullable`1<DefaultValueHandling> DefaultValueHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling { get; public set; }
    public Nullable`1<ObjectCreationHandling> ObjectCreationHandling { get; public set; }
    public Nullable`1<TypeNameHandling> TypeNameHandling { get; public set; }
    public Predicate`1<object> ShouldSerialize { get; public set; }
    public Predicate`1<object> GetIsSpecified { get; public set; }
    public Action`2<object, object> SetIsSpecified { get; public set; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_UnderlyingName();
    [CompilerGeneratedAttribute]
public void set_UnderlyingName(string value);
    [CompilerGeneratedAttribute]
public IValueProvider get_ValueProvider();
    [CompilerGeneratedAttribute]
public void set_ValueProvider(IValueProvider value);
    [CompilerGeneratedAttribute]
public IAttributeProvider get_AttributeProvider();
    [CompilerGeneratedAttribute]
public void set_AttributeProvider(IAttributeProvider value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [CompilerGeneratedAttribute]
public JsonConverter get_MemberConverter();
    [CompilerGeneratedAttribute]
public void set_MemberConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal object GetResolvedDefaultValue();
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_NullValueHandling();
    [CompilerGeneratedAttribute]
public void set_NullValueHandling(Nullable`1<NullValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
public void set_ShouldSerialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_GetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_GetIsSpecified(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_SetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_SetIsSpecified(Action`2<object, object> value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    internal void WritePropertyName(JsonWriter writer);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private Type _type;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetValue(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
internal abstract class Raven.Imports.Newtonsoft.Json.Serialization.JsonSerializerInternalBase : object {
    private ErrorContext _currentErrorContext;
    private BidirectionalDictionary`2<string, object> _mappings;
    private bool _serializing;
    internal JsonSerializer Serializer;
    internal ITraceWriter TraceWriter;
    internal BidirectionalDictionary`2<string, object> DefaultReferenceMappings { get; }
    protected JsonSerializerInternalBase(JsonSerializer serializer);
    internal BidirectionalDictionary`2<string, object> get_DefaultReferenceMappings();
    private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error);
    protected void ClearErrorContext();
    protected void TryClearErrorContext();
    protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex);
}
internal class Raven.Imports.Newtonsoft.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
    private JsonSerializerProxy _internalSerializer;
    public JsonSerializerInternalReader(JsonSerializer serializer);
    public void Populate(JsonReader reader, object target);
    private JsonContract GetContractSafe(Type type);
    public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent);
    private JsonSerializerProxy GetInternalSerializer();
    private JToken CreateJToken(JsonReader reader, JsonContract contract);
    private JToken CreateJObject(JsonReader reader);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    internal string GetExpectedDescription(JsonContract contract);
    private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private bool ReadMetadataPropertiesToken(JTokenReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    private bool ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    private void ResolveTypeName(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName);
    private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract);
    private void CheckedRead(JsonReader reader);
    private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id);
    private bool HasNoDefinedType(JsonContract contract);
    private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target);
    private bool CalculatePropertyDetails(JsonProperty property, JsonConverter& propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, Boolean& useExistingValue, Object& currentValue, JsonContract& propertyContract, Boolean& gottenCurrentValue);
    private void AddReference(JsonReader reader, string id, object value);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool ShouldSetPropertyValue(JsonProperty property, object value);
    private IList CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator);
    private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, Boolean& createdFromNonDefaultCreator);
    private void OnDeserializing(JsonReader reader, JsonContract contract, object value);
    private void OnDeserialized(JsonReader reader, JsonContract contract, object value);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id);
    private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message);
    private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id);
    internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member);
    private object CreateDynamic(JsonReader reader, JsonDynamicContract contract, JsonProperty member, string id);
    private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1<object> creator, string id);
    private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue);
    private IDictionary`2<JsonProperty, object> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType, IDictionary`2& extensionData);
    private bool ReadForType(JsonReader reader, JsonContract contract, bool hasConverter);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, Boolean& createdFromNonDefaultCreator);
    private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id);
    private bool CheckPropertyName(JsonReader reader, string memberName);
    private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o);
    private void EndObject(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, Dictionary`2<JsonProperty, PropertyPresence> propertiesPresence);
    private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, PropertyPresence> requiredProperties);
    private void HandleError(JsonReader reader, bool readPastError, int initialDepth);
}
internal class Raven.Imports.Newtonsoft.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
    private JsonContract _rootContract;
    private int _rootLevel;
    private List`1<object> _serializeStack;
    private JsonSerializerProxy _internalSerializer;
    private JsonConverterCollection _internalConverters;
    private Action`2<object, JsonWriter> beforeClosingObject;
    public JsonSerializerInternalWriter(JsonSerializer serializer, Action`2<object, JsonWriter> beforeClosingObject);
    public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    private JsonSerializerProxy GetInternalSerializer();
    private JsonContract GetContractSafe(object value);
    private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private Nullable`1<bool> ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteProperty(object memberValue, JsonProperty property);
    private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void WriteReference(JsonWriter writer, object value);
    private string GetReference(JsonWriter writer, object value);
    internal static bool TryConvertToString(object value, Type type, String& s);
    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract);
    private void OnSerializing(JsonWriter writer, JsonContract contract, object value);
    private void OnSerialized(JsonWriter writer, JsonContract contract, object value);
    private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, JsonContract& memberContract, Object& memberValue);
    private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value);
    private void WriteTypeProperty(JsonWriter writer, Type type);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag);
    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag);
    private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, Int32[] indices);
    private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [SecuritySafeCriticalAttribute]
private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeDynamic(JsonWriter writer, IDynamicMetaObjectProvider value, JsonDynamicContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool ShouldWriteDynamicProperty(object memberValue);
    private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, Boolean& escape);
    private void HandleError(JsonWriter writer, int initialDepth);
    private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target);
    private bool IsSpecified(JsonWriter writer, JsonProperty property, object target);
}
internal class Raven.Imports.Newtonsoft.Json.Serialization.JsonSerializerProxy : JsonSerializer {
    private JsonSerializerInternalReader _serializerReader;
    private JsonSerializerInternalWriter _serializerWriter;
    private JsonSerializer _serializer;
    public IReferenceResolver ReferenceResolver { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    public JsonConverterCollection Converters { get; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader);
    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter);
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual IReferenceResolver get_ReferenceResolver();
    public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual ITraceWriter get_TraceWriter();
    public virtual void set_TraceWriter(ITraceWriter value);
    public virtual JsonConverterCollection get_Converters();
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal JsonSerializerInternalBase GetInternalSerializer();
    internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.JsonStringContract : JsonPrimitiveContract {
    public JsonStringContract(Type underlyingType);
}
internal static class Raven.Imports.Newtonsoft.Json.Serialization.JsonTypeReflector : object {
    private static Nullable`1<bool> _dynamicCodeGeneration;
    private static Nullable`1<bool> _fullyTrusted;
    public static string IdPropertyName;
    public static string RefPropertyName;
    public static string TypePropertyName;
    public static string ValuePropertyName;
    public static string ArrayValuesPropertyName;
    public static string ShouldSerializePrefix;
    public static string SpecifiedPostfix;
    public static string ConcurrentDictionaryTypeName;
    private static ThreadSafeStore`2<Type, Func`2<Object[], JsonConverter>> JsonConverterCreatorCache;
    private static ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache;
    private static ReflectionObject _metadataTypeAttributeReflectionObject;
    public static bool DynamicCodeGeneration { get; }
    public static bool FullyTrusted { get; }
    public static ReflectionDelegateFactory ReflectionDelegateFactory { get; }
    private static JsonTypeReflector();
    public static T GetCachedAttribute(object attributeProvider);
    public static DataContractAttribute GetDataContractAttribute(Type type);
    public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo);
    public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute);
    public static JsonConverter GetJsonConverter(object attributeProvider);
    public static JsonConverter CreateJsonConverterInstance(Type converterType, Object[] converterArgs);
    private static Func`2<Object[], JsonConverter> GetJsonConverterCreator(Type converterType);
    public static TypeConverter GetTypeConverter(Type type);
    private static Type GetAssociatedMetadataType(Type type);
    private static Type GetAssociateMetadataTypeFromAttribute(Type type);
    private static T GetAttribute(Type type);
    private static T GetAttribute(MemberInfo memberInfo);
    public static T GetAttribute(object provider);
    [SecuritySafeCriticalAttribute]
public static bool get_DynamicCodeGeneration();
    public static bool get_FullyTrusted();
    public static ReflectionDelegateFactory get_ReflectionDelegateFactory();
}
public class Raven.Imports.Newtonsoft.Json.Serialization.MemoryTraceWriter : object {
    private Queue`1<string> _traceMessages;
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
    public IEnumerable`1<string> GetTraceMessages();
    public virtual string ToString();
}
public class Raven.Imports.Newtonsoft.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
    public ObjectConstructor`1(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
public class Raven.Imports.Newtonsoft.Json.Serialization.OnErrorAttribute : Attribute {
}
public class Raven.Imports.Newtonsoft.Json.Serialization.ReflectionAttributeProvider : object {
    private object _attributeProvider;
    public ReflectionAttributeProvider(object attributeProvider);
    public sealed virtual IList`1<Attribute> GetAttributes(bool inherit);
    public sealed virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.ReflectionValueProvider : object {
    private MemberInfo _memberInfo;
    public ReflectionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
internal class Raven.Imports.Newtonsoft.Json.Serialization.ResolverContractKey : ValueType {
    private Type _resolverType;
    private Type _contractType;
    public ResolverContractKey(Type resolverType, Type contractType);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ResolverContractKey other);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.SerializationCallback : MulticastDelegate {
    public SerializationCallback(object object, IntPtr method);
    public virtual void Invoke(object o, StreamingContext context);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Raven.Imports.Newtonsoft.Json.Serialization.SerializationErrorCallback : MulticastDelegate {
    public SerializationErrorCallback(object object, IntPtr method);
    public virtual void Invoke(object o, StreamingContext context, ErrorContext errorContext);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, ErrorContext errorContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Raven.Imports.Newtonsoft.Json.Serialization.TraceJsonReader : JsonReader {
    private JsonReader _innerReader;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    private int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public TraceJsonReader(JsonReader innerReader);
    public string GetDeserializedJsonMessage();
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual void Close();
    private sealed virtual override bool Raven.Imports.Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Raven.Imports.Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
internal class Raven.Imports.Newtonsoft.Json.Serialization.TraceJsonWriter : JsonWriter {
    private JsonWriter _innerWriter;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public TraceJsonWriter(JsonWriter innerWriter);
    public string GetSerializedJsonMessage();
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(byte value);
    public virtual void WriteValue(Nullable`1<byte> value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(double value);
    public virtual void WriteUndefined();
    public virtual void WriteNull();
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(short value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(ulong value);
    public virtual void WriteValue(Uri value);
    public virtual void WriteValue(ushort value);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteComment(string text);
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void Close();
    public virtual void Flush();
}
public enum Raven.Imports.Newtonsoft.Json.StringEscapeHandling : Enum {
    public int value__;
    public static StringEscapeHandling Default;
    public static StringEscapeHandling EscapeNonAscii;
    public static StringEscapeHandling EscapeHtml;
}
[FlagsAttribute]
public enum Raven.Imports.Newtonsoft.Json.TypeNameHandling : Enum {
    public int value__;
    public static TypeNameHandling None;
    public static TypeNameHandling Objects;
    public static TypeNameHandling Arrays;
    public static TypeNameHandling All;
    public static TypeNameHandling Auto;
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.Base64Encoder : object {
    private static int Base64LineSize;
    private static int LineSizeInBytes;
    private Char[] _charsLine;
    private TextWriter _writer;
    private Byte[] _leftOverBytes;
    private int _leftOverBytesCount;
    public Base64Encoder(TextWriter writer);
    public void Encode(Byte[] buffer, int index, int count);
    public void Flush();
    private void WriteChars(Char[] chars, int index, int count);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.BidirectionalDictionary`2 : object {
    private IDictionary`2<TFirst, TSecond> _firstToSecond;
    private IDictionary`2<TSecond, TFirst> _secondToFirst;
    private string _duplicateFirstErrorMessage;
    private string _duplicateSecondErrorMessage;
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer);
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage);
    public void Set(TFirst first, TSecond second);
    public bool TryGetByFirst(TFirst first, TSecond& second);
    public bool TryGetBySecond(TSecond second, TFirst& first);
}
[ExtensionAttribute]
internal static class Raven.Imports.Newtonsoft.Json.Utilities.CollectionUtils : object {
    public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable`1<T> collection);
    public static bool IsDictionaryType(Type type);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<TSource> list, TSource value, IEqualityComparer`1<TSource> comparer);
    private static IList`1<int> GetDimensions(IList values, int dimensionsCount);
    private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, Int32[] indices);
    private static object JaggedArrayGetValue(IList values, Int32[] indices);
    public static Array ToMultidimensionalArray(IList values, Type type, int rank);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.CollectionWrapper`1 : object {
    private IList _list;
    private ICollection`1<T> _genericCollection;
    private object _syncRoot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingCollection { get; }
    public CollectionWrapper`1(IList list);
    public CollectionWrapper`1(ICollection`1<T> list);
    public virtual void Add(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool Remove(T item);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private static void VerifyValueType(object value);
    private static bool IsCompatibleObject(object value);
    public sealed virtual object get_UnderlyingCollection();
}
internal static class Raven.Imports.Newtonsoft.Json.Utilities.ConvertUtils : object {
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static TypeInformation[] PrimitiveTypeCodes;
    private static ThreadSafeStore`2<TypeConvertKey, Func`2<object, object>> CastConverters;
    private static ConvertUtils();
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
    public static TypeInformation GetTypeInformation(IConvertible convertable);
    public static bool IsConvertible(Type t);
    public static TimeSpan ParseTimeSpan(string input);
    private static Func`2<object, object> CreateCastConverter(TypeConvertKey t);
    internal static BigInteger ToBigInteger(object value);
    public static object FromBigInteger(BigInteger i, Type targetType);
    public static object Convert(object initialValue, CultureInfo culture, Type targetType);
    private static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& value);
    private static ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, Object& value);
    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType);
    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType);
    public static object ToValue(INullable nullableValue);
    internal static TypeConverter GetConverter(Type t);
    public static bool IsInteger(object value);
    public static ParseResult Int32TryParse(Char[] chars, int start, int length, Int32& value);
    public static ParseResult Int64TryParse(Char[] chars, int start, int length, Int64& value);
    public static bool TryConvertGuid(string s, Guid& g);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.Creator`1 : MulticastDelegate {
    public Creator`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.DateTimeParser : ValueType {
    public int Year;
    public int Month;
    public int Day;
    public int Hour;
    public int Minute;
    public int Second;
    public int Fraction;
    public int ZoneHour;
    public int ZoneMinute;
    public ParserTimeZone Zone;
    private string _text;
    private int _length;
    private static Int32[] Power10;
    private static int Lzyyyy;
    private static int Lzyyyy_;
    private static int Lzyyyy_MM;
    private static int Lzyyyy_MM_;
    private static int Lzyyyy_MM_dd;
    private static int Lzyyyy_MM_ddT;
    private static int LzHH;
    private static int LzHH_;
    private static int LzHH_mm;
    private static int LzHH_mm_;
    private static int LzHH_mm_ss;
    private static int Lz_;
    private static int Lz_zz;
    private static short MaxFractionDigits;
    private static DateTimeParser();
    public bool Parse(string text);
    private bool ParseDate(int start);
    private bool ParseTimeAndZoneAndWhitespace(int start);
    private bool ParseTime(Int32& start);
    private bool ParseZone(int start);
    private bool Parse4Digit(int start, Int32& num);
    private bool Parse2Digit(int start, Int32& num);
    private bool ParseChar(int start, char ch);
}
[ExtensionAttribute]
internal static class Raven.Imports.Newtonsoft.Json.Utilities.DateTimeUtils : object {
    internal static long InitialJavaScriptDateTicks;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysPer4Years;
    private static int DaysPerYear;
    private static long TicksPerDay;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static DateTimeUtils();
    [ExtensionAttribute]
public static TimeSpan GetUtcOffset(DateTime d);
    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind);
    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone);
    private static DateTime SwitchToLocalTime(DateTime value);
    private static DateTime SwitchToUtcTime(DateTime value);
    private static long ToUniversalTicks(DateTime dateTime);
    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc);
    private static long UniversialTicksToJavaScriptTicks(long universialTicks);
    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
    internal static bool TryParseDateIso(string text, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, Object& dt);
    internal static bool TryParseDateTime(string s, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, Object& dt);
    private static bool TryParseDateMicrosoft(string text, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, Object& dt);
    private static bool TryParseDateExact(string text, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, Object& dt);
    private static TimeSpan ReadOffset(string offsetText);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture);
    internal static int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format);
    internal static int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt);
    private static void CopyIntToCharArray(Char[] chars, int start, int value, int digits);
    internal static int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format);
    internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture);
    private static void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day);
}
[DefaultMemberAttribute("Item")]
internal class Raven.Imports.Newtonsoft.Json.Utilities.DictionaryWrapper`2 : object {
    private IDictionary _dictionary;
    private IDictionary`2<TKey, TValue> _genericDictionary;
    private IReadOnlyDictionary`2<TKey, TValue> _readOnlyDictionary;
    private object _syncRoot;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingDictionary { get; }
    public DictionaryWrapper`2(IDictionary dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public DictionaryWrapper`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual void Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_UnderlyingDictionary();
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.DynamicProxy`1 : object {
    public virtual IEnumerable`1<string> GetDynamicMemberNames(T instance);
    public virtual bool TryBinaryOperation(T instance, BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryConvert(T instance, ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(T instance, CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryDeleteIndex(T instance, DeleteIndexBinder binder, Object[] indexes);
    public virtual bool TryDeleteMember(T instance, DeleteMemberBinder binder);
    public virtual bool TryGetIndex(T instance, GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(T instance, GetMemberBinder binder, Object& result);
    public virtual bool TryInvoke(T instance, InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryInvokeMember(T instance, InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TrySetIndex(T instance, SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TrySetMember(T instance, SetMemberBinder binder, object value);
    public virtual bool TryUnaryOperation(T instance, UnaryOperationBinder binder, Object& result);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1 : DynamicMetaObject {
    private DynamicProxy`1<T> _proxy;
    private bool _dontFallbackFirst;
    private static Expression[] NoArgs;
    private T Value { get; }
    internal DynamicProxyMetaObject`1(Expression expression, T value, DynamicProxy`1<T> proxy, bool dontFallbackFirst);
    private static DynamicProxyMetaObject`1();
    private T get_Value();
    private bool IsOverridden(string method);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    private static Expression[] GetArgs(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args, DynamicMetaObject value);
    private static ConstantExpression Constant(DynamicMetaObjectBinder binder);
    private DynamicMetaObject CallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback<T> fallback, Fallback<T> fallbackInvoke);
    private DynamicMetaObject BuildCallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, DynamicMetaObject fallbackResult, Fallback<T> fallbackInvoke);
    private DynamicMetaObject CallMethodReturnLast(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback<T> fallback);
    private DynamicMetaObject CallMethodNoResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback<T> fallback);
    private BindingRestrictions GetRestrictions();
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.DynamicReflectionDelegateFactory : ReflectionDelegateFactory {
    public static DynamicReflectionDelegateFactory Instance;
    private static DynamicReflectionDelegateFactory();
    private static DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public virtual ObjectConstructor`1<object> CreateParametrizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private void GenerateCreateMethodCallIL(MethodBase method, ILGenerator generator, int argsIndex);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    private void GenerateCreateDefaultConstructorIL(Type type, ILGenerator generator);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    private void GenerateCreateGetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    private void GenerateCreateGetFieldIL(FieldInfo fieldInfo, ILGenerator generator);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    internal static void GenerateCreateSetFieldIL(FieldInfo fieldInfo, ILGenerator generator);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    internal static void GenerateCreateSetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator);
}
[ExtensionAttribute]
internal static class Raven.Imports.Newtonsoft.Json.Utilities.DynamicUtils : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDynamicMemberNames(IDynamicMetaObjectProvider dynamicProvider);
}
internal static class Raven.Imports.Newtonsoft.Json.Utilities.EnumUtils : object {
    private static ThreadSafeStore`2<Type, BidirectionalDictionary`2<string, string>> EnumMemberNamesPerType;
    private static EnumUtils();
    private static BidirectionalDictionary`2<string, string> InitializeEnumType(Type type);
    public static IList`1<T> GetFlagsValues(T value);
    public static IList`1<EnumValue`1<ulong>> GetNamesAndValues();
    public static IList`1<EnumValue`1<TUnderlyingType>> GetNamesAndValues(Type enumType);
    public static IList`1<object> GetValues(Type enumType);
    public static IList`1<string> GetNames(Type enumType);
    public static object ParseEnumName(string enumText, bool isNullable, Type t);
    public static string ToEnumName(Type enumType, string enumText, bool camelCaseText);
    private static string ResolvedEnumName(BidirectionalDictionary`2<string, string> map, string enumText);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.EnumValue`1 : object {
    private string _name;
    private T _value;
    public string Name { get; }
    public T Value { get; }
    public EnumValue`1(string name, T value);
    public string get_Name();
    public T get_Value();
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.ExpressionReflectionDelegateFactory : ReflectionDelegateFactory {
    private static ExpressionReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static ExpressionReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParametrizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private Expression BuildMethodCall(MethodBase method, Type type, ParameterExpression targetParameterExpression, ParameterExpression argsParameterExpression);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    private Expression EnsureCastExpression(Expression expression, Type targetType);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.FSharpFunction : object {
    private object _instance;
    private MethodCall`2<object, object> _invoker;
    public FSharpFunction(object instance, MethodCall`2<object, object> invoker);
    public object Invoke(Object[] args);
}
internal static class Raven.Imports.Newtonsoft.Json.Utilities.FSharpUtils : object {
    private static object Lock;
    private static bool _initialized;
    private static MethodInfo _ofSeq;
    private static Type _mapType;
    [CompilerGeneratedAttribute]
private static Assembly <FSharpCoreAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private static MethodCall`2<object, object> <IsUnion>k__BackingField;
    [CompilerGeneratedAttribute]
private static MethodCall`2<object, object> <GetUnionCases>k__BackingField;
    [CompilerGeneratedAttribute]
private static MethodCall`2<object, object> <PreComputeUnionTagReader>k__BackingField;
    [CompilerGeneratedAttribute]
private static MethodCall`2<object, object> <PreComputeUnionReader>k__BackingField;
    [CompilerGeneratedAttribute]
private static MethodCall`2<object, object> <PreComputeUnionConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<object, object> <GetUnionCaseInfoDeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<object, object> <GetUnionCaseInfoName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<object, object> <GetUnionCaseInfoTag>k__BackingField;
    [CompilerGeneratedAttribute]
private static MethodCall`2<object, object> <GetUnionCaseInfoFields>k__BackingField;
    public static string FSharpSetTypeName;
    public static string FSharpListTypeName;
    public static string FSharpMapTypeName;
    public static Assembly FSharpCoreAssembly { get; private set; }
    public static MethodCall`2<object, object> IsUnion { get; private set; }
    public static MethodCall`2<object, object> GetUnionCases { get; private set; }
    public static MethodCall`2<object, object> PreComputeUnionTagReader { get; private set; }
    public static MethodCall`2<object, object> PreComputeUnionReader { get; private set; }
    public static MethodCall`2<object, object> PreComputeUnionConstructor { get; private set; }
    public static Func`2<object, object> GetUnionCaseInfoDeclaringType { get; private set; }
    public static Func`2<object, object> GetUnionCaseInfoName { get; private set; }
    public static Func`2<object, object> GetUnionCaseInfoTag { get; private set; }
    public static MethodCall`2<object, object> GetUnionCaseInfoFields { get; private set; }
    private static FSharpUtils();
    [CompilerGeneratedAttribute]
public static Assembly get_FSharpCoreAssembly();
    [CompilerGeneratedAttribute]
private static void set_FSharpCoreAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public static MethodCall`2<object, object> get_IsUnion();
    [CompilerGeneratedAttribute]
private static void set_IsUnion(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public static MethodCall`2<object, object> get_GetUnionCases();
    [CompilerGeneratedAttribute]
private static void set_GetUnionCases(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public static MethodCall`2<object, object> get_PreComputeUnionTagReader();
    [CompilerGeneratedAttribute]
private static void set_PreComputeUnionTagReader(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public static MethodCall`2<object, object> get_PreComputeUnionReader();
    [CompilerGeneratedAttribute]
private static void set_PreComputeUnionReader(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public static MethodCall`2<object, object> get_PreComputeUnionConstructor();
    [CompilerGeneratedAttribute]
private static void set_PreComputeUnionConstructor(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public static Func`2<object, object> get_GetUnionCaseInfoDeclaringType();
    [CompilerGeneratedAttribute]
private static void set_GetUnionCaseInfoDeclaringType(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public static Func`2<object, object> get_GetUnionCaseInfoName();
    [CompilerGeneratedAttribute]
private static void set_GetUnionCaseInfoName(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public static Func`2<object, object> get_GetUnionCaseInfoTag();
    [CompilerGeneratedAttribute]
private static void set_GetUnionCaseInfoTag(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public static MethodCall`2<object, object> get_GetUnionCaseInfoFields();
    [CompilerGeneratedAttribute]
private static void set_GetUnionCaseInfoFields(MethodCall`2<object, object> value);
    public static void EnsureInitialized(Assembly fsharpCoreAssembly);
    private static MethodCall`2<object, object> CreateFSharpFuncCall(Type type, string methodName);
    public static ObjectConstructor`1<object> CreateSeq(Type t);
    public static ObjectConstructor`1<object> CreateMap(Type keyType, Type valueType);
    public static ObjectConstructor`1<object> BuildMapCreator();
}
[ExtensionAttribute]
internal static class Raven.Imports.Newtonsoft.Json.Utilities.ILGeneratorExtensions : object {
    [ExtensionAttribute]
public static void PushInstance(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void PushArrayInstance(ILGenerator generator, int argsIndex, int arrayIndex);
    [ExtensionAttribute]
public static void BoxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void UnboxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void CallMethod(ILGenerator generator, MethodInfo methodInfo);
    [ExtensionAttribute]
public static void Return(ILGenerator generator);
}
internal static class Raven.Imports.Newtonsoft.Json.Utilities.ImmutableCollectionsUtils : object {
    private static string ImmutableListGenericInterfaceTypeName;
    private static string ImmutableQueueGenericInterfaceTypeName;
    private static string ImmutableStackGenericInterfaceTypeName;
    private static string ImmutableSetGenericInterfaceTypeName;
    private static string ImmutableArrayTypeName;
    private static string ImmutableArrayGenericTypeName;
    private static string ImmutableListTypeName;
    private static string ImmutableListGenericTypeName;
    private static string ImmutableQueueTypeName;
    private static string ImmutableQueueGenericTypeName;
    private static string ImmutableStackTypeName;
    private static string ImmutableStackGenericTypeName;
    private static string ImmutableSortedSetTypeName;
    private static string ImmutableSortedSetGenericTypeName;
    private static string ImmutableHashSetTypeName;
    private static string ImmutableHashSetGenericTypeName;
    private static IList`1<ImmutableCollectionTypeInfo> ArrayContractImmutableCollectionDefinitions;
    private static string ImmutableDictionaryGenericInterfaceTypeName;
    private static string ImmutableDictionaryTypeName;
    private static string ImmutableDictionaryGenericTypeName;
    private static string ImmutableSortedDictionaryTypeName;
    private static string ImmutableSortedDictionaryGenericTypeName;
    private static IList`1<ImmutableCollectionTypeInfo> DictionaryContractImmutableCollectionDefinitions;
    private static ImmutableCollectionsUtils();
    internal static bool TryBuildImmutableForArrayContract(Type underlyingType, Type collectionItemType, Type& createdType, ObjectConstructor`1& parameterizedCreator);
    internal static bool TryBuildImmutableForDictionaryContract(Type underlyingType, Type keyItemType, Type valueItemType, Type& createdType, ObjectConstructor`1& parameterizedCreator);
}
internal interface Raven.Imports.Newtonsoft.Json.Utilities.IWrappedCollection {
    public object UnderlyingCollection { get; }
    public abstract virtual object get_UnderlyingCollection();
}
internal interface Raven.Imports.Newtonsoft.Json.Utilities.IWrappedDictionary {
    public object UnderlyingDictionary { get; }
    public abstract virtual object get_UnderlyingDictionary();
}
internal interface Raven.Imports.Newtonsoft.Json.Utilities.IWrappedList {
    public object UnderlyingList { get; }
    public abstract virtual object get_UnderlyingList();
}
internal static class Raven.Imports.Newtonsoft.Json.Utilities.JavaScriptUtils : object {
    internal static Boolean[] SingleQuoteCharEscapeFlags;
    internal static Boolean[] DoubleQuoteCharEscapeFlags;
    internal static Boolean[] HtmlCharEscapeFlags;
    private static string EscapedUnicodeText;
    private static JavaScriptUtils();
    public static Boolean[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar);
    public static bool ShouldEscapeJavaScriptString(string s, Boolean[] charEscapeFlags);
    public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, Char[]& writeBuffer);
    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters);
    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling);
}
internal static class Raven.Imports.Newtonsoft.Json.Utilities.JsonTokenUtils : object {
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    internal static bool IsPrimitiveToken(JsonToken token);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
    private static LateBoundReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static LateBoundReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParametrizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[DefaultMemberAttribute("Item")]
internal class Raven.Imports.Newtonsoft.Json.Utilities.ListWrapper`1 : CollectionWrapper`1<T> {
    private IList`1<T> _genericList;
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public object UnderlyingList { get; }
    public ListWrapper`1(IList list);
    public ListWrapper`1(IList`1<T> list);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public virtual void Add(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool Remove(T item);
    public virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual object get_UnderlyingList();
}
internal static class Raven.Imports.Newtonsoft.Json.Utilities.MathUtils : object {
    public static int IntLength(ulong i);
    public static char IntToHex(int n);
    public static Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2);
    public static bool ApproxEquals(double d1, double d2);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.MethodCall`2 : MulticastDelegate {
    public MethodCall`2(object object, IntPtr method);
    public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal static class Raven.Imports.Newtonsoft.Json.Utilities.MiscellaneousUtils : object {
    public static bool ValueEquals(object objA, object objB);
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static string GetPrefix(string qualifiedName);
    public static string GetLocalName(string qualifiedName);
    public static void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName);
    internal static string FormatValueForPrint(object value);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.NoThrowExpressionVisitor : ExpressionVisitor {
    internal static object ErrorResult;
    private static NoThrowExpressionVisitor();
    protected virtual Expression VisitConditional(ConditionalExpression node);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.NoThrowGetBinderMember : GetMemberBinder {
    private GetMemberBinder _innerBinder;
    public NoThrowGetBinderMember(GetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.NoThrowSetBinderMember : SetMemberBinder {
    private SetMemberBinder _innerBinder;
    public NoThrowSetBinderMember(SetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal enum Raven.Imports.Newtonsoft.Json.Utilities.ParseResult : Enum {
    public int value__;
    public static ParseResult None;
    public static ParseResult Success;
    public static ParseResult Overflow;
    public static ParseResult Invalid;
}
internal enum Raven.Imports.Newtonsoft.Json.Utilities.ParserTimeZone : Enum {
    public int value__;
    public static ParserTimeZone Unspecified;
    public static ParserTimeZone Utc;
    public static ParserTimeZone LocalWestOfUtc;
    public static ParserTimeZone LocalEastOfUtc;
}
internal enum Raven.Imports.Newtonsoft.Json.Utilities.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.PropertyNameTable : object {
    private static int HashCodeRandomizer;
    private int _count;
    private Entry[] _entries;
    private int _mask;
    private static PropertyNameTable();
    public string Get(Char[] key, int start, int length);
    public string Add(string key);
    private string AddEntry(string str, int hashCode);
    private void Grow();
    private static bool TextEquals(string str1, Char[] str2, int str2Start, int str2Length);
}
internal abstract class Raven.Imports.Newtonsoft.Json.Utilities.ReflectionDelegateFactory : object {
    public Func`2<T, object> CreateGet(MemberInfo memberInfo);
    public Action`2<T, object> CreateSet(MemberInfo memberInfo);
    public abstract virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public abstract virtual ObjectConstructor`1<object> CreateParametrizedConstructor(MethodBase method);
    public abstract virtual Func`1<T> CreateDefaultConstructor(Type type);
    public abstract virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public abstract virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.ReflectionMember : object {
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, object> <Setter>k__BackingField;
    public Type MemberType { get; public set; }
    public Func`2<object, object> Getter { get; public set; }
    public Action`2<object, object> Setter { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public void set_MemberType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(Action`2<object, object> value);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.ReflectionObject : object {
    [CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <Creator>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ReflectionMember> <Members>k__BackingField;
    public ObjectConstructor`1<object> Creator { get; private set; }
    public IDictionary`2<string, ReflectionMember> Members { get; private set; }
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_Creator();
    [CompilerGeneratedAttribute]
private void set_Creator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ReflectionMember> get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(IDictionary`2<string, ReflectionMember> value);
    public object GetValue(object target, string member);
    public void SetValue(object target, string member, object value);
    public Type GetType(string member);
    public static ReflectionObject Create(Type t, String[] memberNames);
    public static ReflectionObject Create(Type t, MethodBase creator, String[] memberNames);
}
[ExtensionAttribute]
public static class Raven.Imports.Newtonsoft.Json.Utilities.ReflectionUtils : object {
    public static Type[] EmptyTypes;
    private static ReflectionUtils();
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static MethodInfo GetBaseDefinition(PropertyInfo propertyInfo);
    public static bool IsPublic(PropertyInfo property);
    public static Type GetObjectType(object v);
    public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder);
    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName);
    public static bool HasDefaultConstructor(Type t, bool nonPublic);
    public static ConstructorInfo GetDefaultConstructor(Type t);
    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static Type EnsureNotNullableType(Type t);
    public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType);
    private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, Type& implementingType);
    public static Type GetCollectionItemType(Type type);
    public static void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType);
    public static Type GetMemberUnderlyingType(MemberInfo member);
    public static bool IsIndexedProperty(MemberInfo member);
    public static bool IsIndexedProperty(PropertyInfo property);
    public static object GetMemberValue(MemberInfo member, object target);
    public static void SetMemberValue(MemberInfo member, object target, object value);
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    public static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static T GetAttribute(object attributeProvider);
    public static T GetAttribute(object attributeProvider, bool inherit);
    public static T[] GetAttributes(object attributeProvider, bool inherit);
    public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit);
    public static void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, String& typeName, String& assemblyName);
    private static Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName);
    public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo);
    public static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag);
    private static void GetChildPrivateProperties(IList`1<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr);
    public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method);
    public static object GetDefaultValue(Type type);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.StringBuffer : object {
    private Char[] _buffer;
    private int _position;
    private static Char[] EmptyBuffer;
    public int Position { get; public set; }
    public StringBuffer(int initalSize);
    private static StringBuffer();
    public int get_Position();
    public void set_Position(int value);
    public void Append(char value);
    public void Append(Char[] buffer, int startIndex, int count);
    public void Clear();
    private void EnsureSize(int appendLength);
    public virtual string ToString();
    public string ToString(int start, int length);
    public Char[] GetInternalBuffer();
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.StringReference : ValueType {
    private Char[] _chars;
    private int _startIndex;
    private int _length;
    public Char[] Chars { get; }
    public int StartIndex { get; }
    public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Raven.Imports.Newtonsoft.Json.Utilities.StringUtils : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
private static string FormatWith(string format, IFormatProvider provider, Object[] args);
    public static bool IsWhiteSpace(string s);
    public static string NullEmptyString(string s);
    public static StringWriter CreateStringWriter(int capacity);
    public static Nullable`1<int> GetLength(string value);
    public static void ToCharAsUnicode(char c, Char[] buffer);
    [ExtensionAttribute]
public static TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue);
    public static string ToCamelCase(string s);
    public static bool IsHighSurrogate(char c);
    public static bool IsLowSurrogate(char c);
    [ExtensionAttribute]
public static bool StartsWith(string source, char value);
    [ExtensionAttribute]
public static bool EndsWith(string source, char value);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.ThreadSafeStore`2 : object {
    private object _lock;
    private Dictionary`2<TKey, TValue> _store;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
    private TValue AddValue(TKey key);
}
[ExtensionAttribute]
internal static class Raven.Imports.Newtonsoft.Json.Utilities.TypeExtensions : object {
    [ExtensionAttribute]
public static MethodInfo Method(Delegate d);
    [ExtensionAttribute]
public static MemberTypes MemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsVisible(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, Type& match);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName);
}
internal class Raven.Imports.Newtonsoft.Json.Utilities.TypeInformation : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    public Type Type { get; public set; }
    public PrimitiveTypeCode TypeCode { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
public void set_TypeCode(PrimitiveTypeCode value);
}
internal static class Raven.Imports.Newtonsoft.Json.Utilities.ValidationUtils : object {
    public static void ArgumentNotNullOrEmpty(string value, string parameterName);
    public static void ArgumentTypeIsEnum(Type enumType, string parameterName);
    public static void ArgumentNotNull(object value, string parameterName);
}
public enum Raven.Imports.Newtonsoft.Json.WriteState : Enum {
    public int value__;
    public static WriteState Error;
    public static WriteState Closed;
    public static WriteState Object;
    public static WriteState Array;
    public static WriteState Constructor;
    public static WriteState Property;
    public static WriteState Start;
}
[DefaultMemberAttribute("Item")]
internal class Raven.Json.Linq.DictionaryWithParentSnapshot : object {
    private IEqualityComparer`1<string> comparer;
    private static RavenJToken DeletedMarker;
    private DictionaryWithParentSnapshot parentSnapshot;
    private IDictionary`2<string, RavenJToken> localChanges;
    private string snapshotMsg;
    private int localCount;
    [CompilerGeneratedAttribute]
private bool <CaseInsensitivePropertyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSnapshot>k__BackingField;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<RavenJToken> Values { get; }
    public RavenJToken Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool CaseInsensitivePropertyNames { get; public set; }
    public bool IsSnapshot { get; private set; }
    public DictionaryWithParentSnapshot(IEqualityComparer`1<string> comparer);
    private DictionaryWithParentSnapshot(DictionaryWithParentSnapshot previous);
    private static DictionaryWithParentSnapshot();
    protected void EnsureCanWriteToLocalChanges();
    public sealed virtual void Add(string key, RavenJToken value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, RavenJToken& value);
    public sealed virtual ICollection`1<RavenJToken> get_Values();
    public sealed virtual RavenJToken get_Item(string key);
    public sealed virtual void set_Item(string key, RavenJToken value);
    [IteratorStateMachineAttribute("Raven.Json.Linq.DictionaryWithParentSnapshot/<GetEnumerator>d__19")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, RavenJToken>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<string, RavenJToken> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, RavenJToken> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, RavenJToken> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public bool get_CaseInsensitivePropertyNames();
    [CompilerGeneratedAttribute]
public void set_CaseInsensitivePropertyNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSnapshot();
    [CompilerGeneratedAttribute]
private void set_IsSnapshot(bool value);
    public DictionaryWithParentSnapshot CreateSnapshot();
    public void EnsureSnapshot(string msg);
}
[ExtensionAttribute]
public static class Raven.Json.Linq.Extensions : object {
    [ExtensionAttribute]
public static U Value(IEnumerable`1<RavenJToken> value);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<T> value);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<RavenJToken> source);
    [ExtensionAttribute]
public static IEnumerable`1<RavenJToken> Values(IEnumerable`1<RavenJToken> source, string key);
    [ExtensionAttribute]
public static IEnumerable`1<RavenJToken> Values(IEnumerable`1<RavenJToken> source);
    [ExtensionAttribute]
[IteratorStateMachineAttribute("Raven.Json.Linq.Extensions/<Values>d__5`1")]
internal static IEnumerable`1<U> Values(IEnumerable`1<RavenJToken> source, string key);
    [ExtensionAttribute]
internal static U Convert(RavenJToken token);
    [ExtensionAttribute]
internal static IEnumerable`1<U> Convert(IEnumerable`1<RavenJToken> source);
    [ExtensionAttribute]
internal static U Convert(RavenJToken token, bool cast);
    [ExtensionAttribute]
public static bool CompareRavenJArrayData(ICollection`1<DocumentsChanges> docChanges, RavenJArray selfArray, RavenJArray otherArray, string fieldArrName);
    [ExtensionAttribute]
public static bool CompareDifferentLengthRavenJObjectData(ICollection`1<DocumentsChanges> docChanges, RavenJObject otherObj, RavenJObject selfObj, string fieldName);
    private static void FillDifferentJsonData(DictionaryWithParentSnapshot selfObj, DictionaryWithParentSnapshot otherObj, Dictionary`2<string, string> diffData);
    [ExtensionAttribute]
public static void AddChanges(List`1<DocumentsChanges> docChanges, ChangeType change);
    [ExtensionAttribute]
public static void AddChanges(ICollection`1<DocumentsChanges> docChanges, KeyValuePair`2<string, RavenJToken> kvp, RavenJToken token, string fieldName);
    [ExtensionAttribute]
public static void AddChanges(ICollection`1<DocumentsChanges> docChanges, RavenJToken curThisReader, RavenJToken curOtherReader, string fieldName);
}
[DefaultMemberAttribute("Item")]
public class Raven.Json.Linq.RavenJArray : RavenJToken {
    private bool isSnapshot;
    [CompilerGeneratedAttribute]
private List`1<RavenJToken> <Items>k__BackingField;
    public JTokenType Type { get; }
    public RavenJToken Item { get; public set; }
    public bool IsSnapshot { get; }
    public int Length { get; }
    private List`1<RavenJToken> Items { get; private set; }
    public RavenJArray(IEnumerable content);
    public RavenJArray(Object[] content);
    public RavenJArray(IEnumerable`1<RavenJToken> content);
    public virtual JTokenType get_Type();
    public RavenJToken get_Item(int index);
    public void set_Item(int index, RavenJToken value);
    public virtual RavenJToken CloneToken();
    public virtual bool get_IsSnapshot();
    public int get_Length();
    [CompilerGeneratedAttribute]
private List`1<RavenJToken> get_Items();
    [CompilerGeneratedAttribute]
private void set_Items(List`1<RavenJToken> value);
    public static RavenJArray Load(JsonReader reader);
    public static RavenJArray Parse(string json);
    public virtual void WriteTo(JsonWriter writer, JsonConverterCollection converters);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public sealed virtual IEnumerator`1<RavenJToken> GetEnumerator();
    internal virtual IEnumerable`1<KeyValuePair`2<string, RavenJToken>> GetCloningEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(RavenJToken token);
    public bool Remove(RavenJToken token);
    public void RemoveAt(int index);
    public void Insert(int index, RavenJToken item);
    public virtual IEnumerable`1<T> Values();
    public virtual IEnumerable`1<RavenJToken> Values();
    internal virtual void AddForCloning(string key, RavenJToken token);
    public virtual void EnsureCannotBeChangeAndEnableSnapshotting();
    public virtual RavenJToken CreateSnapshot();
    [AsyncStateMachineAttribute("Raven.Json.Linq.RavenJArray/<LoadAsync>d__35")]
public static Task`1<RavenJToken> LoadAsync(JsonTextReaderAsync reader);
}
[DefaultMemberAttribute("Item")]
public class Raven.Json.Linq.RavenJObject : RavenJToken {
    private IEqualityComparer`1<string> comparer;
    private Dictionary`2<string, object> externalState;
    [CompilerGeneratedAttribute]
private DictionaryWithParentSnapshot <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    [CLSCompliantAttribute("False")]
public Dictionary`2<string, object> __ExternalState { get; }
    public JTokenType Type { get; }
    public IEqualityComparer`1<string> Comparer { get; }
    internal DictionaryWithParentSnapshot Properties { get; internal set; }
    public int Count { get; }
    public ICollection`1<string> Keys { get; }
    public bool IsSnapshot { get; }
    public object Tag { get; public set; }
    public RavenJToken Item { get; public set; }
    public RavenJObject(IEqualityComparer`1<string> comparer);
    public RavenJObject(RavenJObject other);
    public RavenJObject(RavenJObject other, IEqualityComparer`1<string> comparer);
    private RavenJObject(DictionaryWithParentSnapshot snapshot);
    public Dictionary`2<string, object> get___ExternalState();
    public virtual JTokenType get_Type();
    public IEqualityComparer`1<string> get_Comparer();
    [CompilerGeneratedAttribute]
internal DictionaryWithParentSnapshot get_Properties();
    [CompilerGeneratedAttribute]
internal void set_Properties(DictionaryWithParentSnapshot value);
    public int get_Count();
    public ICollection`1<string> get_Keys();
    public virtual bool get_IsSnapshot();
    [CompilerGeneratedAttribute]
public object get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(object value);
    public RavenJObject WithCaseInsensitivePropertyNames();
    internal virtual bool DeepEquals(RavenJToken other, List`1<DocumentsChanges> changes);
    public virtual T Value(string key);
    public RavenJToken get_Item(string propertyName);
    public void set_Item(string propertyName, RavenJToken value);
    public virtual RavenJToken CloneToken();
    internal virtual IEnumerable`1<KeyValuePair`2<string, RavenJToken>> GetCloningEnumerator();
    public static RavenJObject FromObject(object o);
    public static RavenJObject FromObject(object o, JsonSerializer jsonSerializer);
    public static RavenJObject Load(JsonReader reader);
    public static RavenJObject Parse(string json);
    public virtual void WriteTo(JsonWriter writer, JsonConverterCollection converters);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, RavenJToken>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(string propName, RavenJToken token);
    internal virtual void AddForCloning(string key, RavenJToken token);
    public bool Remove(string propName);
    public bool ContainsKey(string key);
    public bool TryGetValue(string name, RavenJToken& value);
    public virtual RavenJToken CreateSnapshot();
    public virtual void EnsureCannotBeChangeAndEnableSnapshotting();
    public void EnsureSnapshot(string msg);
    public virtual IEnumerable`1<RavenJToken> Values();
    public virtual IEnumerable`1<T> Values();
    [AsyncStateMachineAttribute("Raven.Json.Linq.RavenJObject/<LoadAsync>d__53")]
public static Task`1<RavenJToken> LoadAsync(JsonTextReaderAsync reader);
}
public class Raven.Json.Linq.RavenJPath : object {
    private string _expression;
    [CompilerGeneratedAttribute]
private List`1<object> <Parts>k__BackingField;
    private int _currentIndex;
    public List`1<object> Parts { get; private set; }
    public RavenJPath(string expression);
    [CompilerGeneratedAttribute]
public List`1<object> get_Parts();
    [CompilerGeneratedAttribute]
private void set_Parts(List`1<object> value);
    private void ParseMain();
    private void ParseIndexer(char indexerOpenChar);
    internal RavenJToken Evaluate(RavenJToken root, bool errorWhenNoMatch, bool createSnapshots);
}
public class Raven.Json.Linq.RavenJsonConvert : object {
    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone);
    private static DateTime SwitchToLocalTime(DateTime value);
    private static DateTime SwitchToUtcTime(DateTime value);
}
public abstract class Raven.Json.Linq.RavenJToken : object {
    private static JsonSerializer defaultJsonSerializer;
    public JTokenType Type { get; }
    public bool IsSnapshot { get; }
    private static RavenJToken();
    public abstract virtual JTokenType get_Type();
    public abstract virtual RavenJToken CloneToken();
    public abstract virtual bool get_IsSnapshot();
    public abstract virtual void EnsureCannotBeChangeAndEnableSnapshotting();
    public abstract virtual RavenJToken CreateSnapshot();
    protected RavenJToken CloneTokenImpl(RavenJToken newObject);
    internal static RavenJToken FromObjectInternal(object o, JsonSerializer jsonSerializer);
    public T ToObject();
    public T ToObject(JsonSerializer jsonSerializer);
    public static RavenJToken FromObject(object o);
    public static RavenJToken FromObject(object o, JsonSerializer jsonSerializer);
    public virtual string ToString();
    public string ToString(Formatting formatting, JsonConverter[] converters);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverterCollection converters);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public static RavenJToken ReadFrom(JsonReader reader);
    public static RavenJToken Parse(string json);
    public static bool TryParse(string json, RavenJToken& token);
    private static RavenJToken ParseInternal(string json);
    public static RavenJToken TryLoad(Stream stream);
    [AsyncStateMachineAttribute("Raven.Json.Linq.RavenJToken/<TryLoadAsync>d__23")]
public static Task`1<RavenJToken> TryLoadAsync(Stream stream);
    public static RavenJToken Load(JsonReader reader);
    public virtual T Value(string key);
    public static bool DeepEquals(RavenJToken t1, RavenJToken t2, List`1<DocumentsChanges> difference);
    public static bool DeepEquals(RavenJToken t1, RavenJToken t2);
    public static int GetDeepHashCode(RavenJToken t);
    internal virtual bool DeepEquals(RavenJToken other);
    internal virtual bool DeepEquals(RavenJToken other, List`1<DocumentsChanges> docChanges);
    private static string FieldName(JTokenType prevType, string origFieldName, string key, RavenJTokenState curOtherReader, bool addKeyToFieldName);
    private bool CheckType(JTokenType otherType);
    internal virtual int GetDeepHashCode();
    public RavenJToken SelectToken(string path);
    public RavenJToken SelectToken(string path, bool errorWhenNoMatch, bool createSnapshots);
    public RavenJToken SelectToken(RavenJPath path);
    public RavenJToken SelectToken(RavenJPath path, bool errorWhenNoMatch, bool createSnapshots);
    public virtual IEnumerable`1<T> Values();
    public virtual T Value();
    public virtual IEnumerable`1<RavenJToken> Values();
    internal virtual void AddForCloning(string key, RavenJToken token);
    internal virtual IEnumerable`1<KeyValuePair`2<string, RavenJToken>> GetCloningEnumerator();
    public static RavenJToken op_Implicit(bool value);
    public static RavenJToken op_Implicit(DateTimeOffset value);
    public static RavenJToken op_Implicit(Nullable`1<bool> value);
    public static RavenJToken op_Implicit(long value);
    public static RavenJToken op_Implicit(Nullable`1<DateTime> value);
    public static RavenJToken op_Implicit(Nullable`1<DateTimeOffset> value);
    public static RavenJToken op_Implicit(Nullable`1<decimal> value);
    public static RavenJToken op_Implicit(Nullable`1<double> value);
    [CLSCompliantAttribute("False")]
public static RavenJToken op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static RavenJToken op_Implicit(ushort value);
    public static RavenJToken op_Implicit(int value);
    public static RavenJToken op_Implicit(Nullable`1<int> value);
    public static RavenJToken op_Implicit(DateTime value);
    public static RavenJToken op_Implicit(Nullable`1<long> value);
    public static RavenJToken op_Implicit(Nullable`1<float> value);
    public static RavenJToken op_Implicit(decimal value);
    [CLSCompliantAttribute("False")]
public static RavenJToken op_Implicit(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public static RavenJToken op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static RavenJToken op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static RavenJToken op_Implicit(Nullable`1<ulong> value);
    public static RavenJToken op_Implicit(double value);
    public static RavenJToken op_Implicit(float value);
    public static RavenJToken op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static RavenJToken op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static RavenJToken op_Implicit(ulong value);
    public static RavenJToken op_Implicit(Byte[] value);
    [AsyncStateMachineAttribute("Raven.Json.Linq.RavenJToken/<ReadFromAsync>d__69")]
public static Task`1<RavenJToken> ReadFromAsync(JsonTextReaderAsync reader);
}
public class Raven.Json.Linq.RavenJTokenReader : JsonReader {
    private RavenJToken _root;
    private IEnumerator`1<ReadState> enumerator;
    public RavenJTokenReader(RavenJToken token);
    public virtual Byte[] ReadAsBytes();
    private bool IsWrappedInTypeObject();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual bool Read();
    [IteratorStateMachineAttribute("Raven.Json.Linq.RavenJTokenReader/<ReadRavenJToken>d__12")]
private static IEnumerable`1<ReadState> ReadRavenJToken(RavenJToken token);
    private static JsonToken GetJsonTokenType(RavenJToken token);
    private static JsonReaderException CreateReaderException(JsonReader reader, string message);
    internal static bool IsPrimitiveToken(JsonToken token);
}
public class Raven.Json.Linq.RavenJTokenState : object {
    public JTokenType CurType;
    public bool WasHere;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJToken <Token>k__BackingField;
    public int Index { get; }
    public RavenJToken Token { get; }
    public RavenJTokenState(RavenJToken token, JTokenType curType, int index, bool wasHere);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public RavenJToken get_Token();
}
public class Raven.Json.Linq.RavenJTokenWriter : JsonWriter {
    private RavenJToken _token;
    private RavenJValue _value;
    private Stack`1<RavenJToken> _tokenStack;
    private string _tempPropName;
    protected RavenJToken CurrentToken { get; }
    public RavenJToken Token { get; }
    protected RavenJToken get_CurrentToken();
    public RavenJToken get_Token();
    public virtual void Flush();
    public virtual void WritePropertyName(string name);
    private void AddParent(RavenJToken token);
    private void RemoveParent();
    public virtual void WriteStartObject();
    public virtual void WriteStartArray();
    protected virtual void WriteEnd(JsonToken token);
    private void AddValue(object value, JsonToken token);
    internal void AddValue(RavenJValue value, JsonToken token);
    public virtual void WriteRaw(string json);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public void AssociateCurrentOBjectWith(object o);
}
public class Raven.Json.Linq.RavenJValue : RavenJToken {
    private JTokenType _valueType;
    private object _value;
    private bool isSnapshot;
    public JTokenType Type { get; }
    public object Value { get; public set; }
    public bool IsSnapshot { get; }
    public static RavenJValue Null { get; }
    internal RavenJValue(object value, JTokenType type);
    public RavenJValue(int value);
    public RavenJValue(long value);
    [CLSCompliantAttribute("False")]
public RavenJValue(ulong value);
    public RavenJValue(double value);
    public RavenJValue(float value);
    public RavenJValue(DateTime value);
    public RavenJValue(bool value);
    public RavenJValue(string value);
    public RavenJValue(Guid value);
    public RavenJValue(Uri value);
    public RavenJValue(TimeSpan value);
    public RavenJValue(object value);
    public virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    public virtual RavenJToken CloneToken();
    public virtual bool get_IsSnapshot();
    private static JTokenType GetValueType(Nullable`1<JTokenType> current, object value);
    private static JTokenType GetStringValueType(Nullable`1<JTokenType> current);
    public static RavenJValue Load(JsonReader reader);
    public virtual void WriteTo(JsonWriter writer, JsonConverterCollection converters);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual bool Equals(RavenJValue other);
    private static bool ValuesEquals(RavenJValue v1, RavenJValue v2);
    public sealed virtual int CompareTo(RavenJValue other);
    private static int Compare(JTokenType valueType, object objA, object objB);
    private static int CompareFloat(object objA, object objB);
    private static bool TryConvertToDouble(object obj, Double& d);
    internal virtual bool DeepEquals(RavenJToken node);
    internal virtual int GetDeepHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual void EnsureCannotBeChangeAndEnableSnapshotting();
    public virtual RavenJToken CreateSnapshot();
    public static RavenJValue get_Null();
    public static RavenJToken Load(JsonTextReaderAsync reader);
}
internal static class Raven.Json.Utilities.MiscellaneousUtils : object {
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
}
[ExtensionAttribute]
internal static class Raven.Json.Utilities.StringUtils : object {
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, Object[] args);
}
public class Raven.Smuggler.ExportIncremental : object {
    [CompilerGeneratedAttribute]
private Etag <LastDocsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastAttachmentsEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastFilesEtag>k__BackingField;
    public Etag LastDocsEtag { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag LastAttachmentsEtag { get; public set; }
    public Etag LastFilesEtag { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_LastDocsEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocsEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastAttachmentsEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentsEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastFilesEtag();
    [CompilerGeneratedAttribute]
public void set_LastFilesEtag(Etag value);
}
public class Raven.Smuggler.SmugglerExportIncremental : object {
    public static string RavenDocumentKey;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ExportIncremental> <ExportIncremental>k__BackingField;
    public Dictionary`2<string, ExportIncremental> ExportIncremental { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ExportIncremental> get_ExportIncremental();
    [CompilerGeneratedAttribute]
public void set_ExportIncremental(Dictionary`2<string, ExportIncremental> value);
}
[AttributeUsageAttribute("1")]
public class RavenVersionAttribute : Attribute {
    private string build;
    [CompilerGeneratedAttribute]
private string <CommitHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string CommitHash { get; public set; }
    public string Build { get; public set; }
    public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CommitHash();
    [CompilerGeneratedAttribute]
public void set_CommitHash(string value);
    public string get_Build();
    public void set_Build(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
}
