[CompilerGeneratedAttribute]
internal static class Costura.AssemblyLoader : object {
    private static Dictionary`2<string, bool> nullCache;
    private static Dictionary`2<string, string> assemblyNames;
    private static Dictionary`2<string, string> symbolNames;
    private static Dictionary`2<string, object> currentlyLoading;
    private static object Locker;
    private static AssemblyLoader();
    public static Assembly ResolveAssembly(string assemblyName);
    private static string CultureToString(CultureInfo culture);
    private static Assembly ReadExistingAssembly(AssemblyName name);
    private static void CopyTo(Stream source, Stream destination);
    private static Stream LoadStream(string fullname);
    private static Stream LoadStream(Dictionary`2<string, string> resourceNames, string name);
    private static Byte[] ReadStream(Stream stream);
    private static Assembly ReadFromEmbeddedResources(Dictionary`2<string, string> assemblyNames, Dictionary`2<string, string> symbolNames, AssemblyName requestedAssemblyName);
    public static void Attach();
}
public class Lucene.Net.Search.Similar.MoreLikeThis : object {
    public static int DEFAULT_MAX_NUM_TOKENS_PARSED;
    public static Analyzer DEFAULT_ANALYZER;
    public static int DEFAULT_MIN_TERM_FREQ;
    public static int DEFAULT_MIN_DOC_FREQ;
    public static int DEFAULT_MAX_DOC_FREQ;
    public static bool DEFAULT_BOOST;
    public static String[] DEFAULT_FIELD_NAMES;
    public static int DEFAULT_MIN_WORD_LENGTH;
    public static int DEFAULT_MAX_WORD_LENGTH;
    public static ISet`1<string> DEFAULT_STOP_WORDS;
    private ISet`1<string> stopWords;
    public static int DEFAULT_MAX_QUERY_TERMS;
    private Analyzer analyzer;
    private int minTermFreq;
    private int minDocFreq;
    private int maxDocfreq;
    private bool boost;
    private String[] fieldNames;
    private int maxNumTokensParsed;
    private int minWordLen;
    private int maxWordLen;
    private int maxQueryTerms;
    private Similarity similarity;
    private IndexReader ir;
    private float boostFactor;
    public float BoostFactor { get; public set; }
    public Similarity Similarity { get; public set; }
    public Analyzer Analyzer { get; public set; }
    public int MinTermFreq { get; public set; }
    public int MinDocFreq { get; public set; }
    public int MaxDocFreq { get; public set; }
    public bool Boost { get; public set; }
    public int MinWordLen { get; public set; }
    public int MaxWordLen { get; public set; }
    public int MaxQueryTerms { get; public set; }
    public int MaxNumTokensParsed { get; public set; }
    public MoreLikeThis(IndexReader ir);
    public MoreLikeThis(IndexReader ir, Similarity sim);
    private static MoreLikeThis();
    public float get_BoostFactor();
    public void set_BoostFactor(float value);
    public Similarity get_Similarity();
    public void set_Similarity(Similarity value);
    public Analyzer get_Analyzer();
    public void set_Analyzer(Analyzer value);
    public int get_MinTermFreq();
    public void set_MinTermFreq(int value);
    public int get_MinDocFreq();
    public void set_MinDocFreq(int value);
    public int get_MaxDocFreq();
    public void set_MaxDocFreq(int value);
    public void SetMaxDocFreqPct(int maxPercentage);
    public bool get_Boost();
    public void set_Boost(bool value);
    public String[] GetFieldNames();
    public void SetFieldNames(String[] fieldNames);
    public int get_MinWordLen();
    public void set_MinWordLen(int value);
    public int get_MaxWordLen();
    public void set_MaxWordLen(int value);
    public void SetStopWords(ISet`1<string> stopWords);
    public ISet`1<string> GetStopWords();
    public int get_MaxQueryTerms();
    public void set_MaxQueryTerms(int value);
    public int get_MaxNumTokensParsed();
    public void set_MaxNumTokensParsed(int value);
    public Query Like(int docNum);
    public Query Like(FileInfo f);
    public Query Like(Uri u);
    public Query Like(Stream is_Renamed);
    public Query Like(TextReader r);
    internal Query Like(RavenJObject jsonDocument);
    private Query CreateQuery(PriorityQueue`1<Object[]> q);
    protected PriorityQueue`1<Object[]> CreateQueue(IDictionary`2<string, Int> words);
    public string DescribeParams();
    protected virtual PriorityQueue`1<Object[]> RetrieveTerms(int docNum);
    protected void AddTermFrequencies(IDictionary`2<string, Int> termFreqMap, ITermFreqVector vector);
    protected void AddTermFrequencies(TextReader r, IDictionary`2<string, Int> termFreqMap, string fieldName);
    protected bool IsNoiseWord(string term);
    internal PriorityQueue`1<Object[]> RetrieveTerms(RavenJObject jsonDocument);
    private void RetrieveTerms(RavenJObject jsonDocument, IDictionary`2<string, Int> words);
    public PriorityQueue`1<Object[]> RetrieveTerms(TextReader r);
    public String[] RetrieveInterestingTerms(int docNum);
    public String[] RetrieveInterestingTerms(TextReader r);
}
public abstract class Lucene.Net.Search.Vectorhighlight.BaseFragmentsBuilder : object {
    protected String[] preTags;
    protected String[] postTags;
    public static String[] COLORED_PRE_TAGS;
    public static String[] COLORED_POST_TAGS;
    protected BaseFragmentsBuilder(String[] preTags, String[] postTags);
    private static BaseFragmentsBuilder();
    private static object CheckTagsArgument(object tags);
    public abstract virtual List`1<WeightedFragInfo> GetWeightedFragInfoList(List`1<WeightedFragInfo> src);
    public virtual string CreateFragment(IndexReader reader, int docId, string fieldName, FieldFragList fieldFragList, int fragCharSize);
    public virtual String[] CreateFragments(IndexReader reader, int docId, string fieldName, FieldFragList fieldFragList, int maxNumFragments, int fragCharSize);
    [ObsoleteAttribute]
protected virtual String[] GetFieldValues(IndexReader reader, int docId, string fieldName);
    protected virtual Field[] GetFields(IndexReader reader, int docId, string fieldName);
    protected virtual string MakeFragment(StringBuilder buffer, Int32[] index, Field[] values, WeightedFragInfo fragInfo, int fragCharSize);
    private string MakeFragment(WeightedFragInfo fragInfo, string src, int adjustedStart, int fragCharSize);
    [ObsoleteAttribute]
protected virtual string GetFragmentSource(StringBuilder buffer, Int32[] index, String[] values, int startOffset, int endOffset);
    protected virtual string GetFragmentSource(StringBuilder buffer, Int32[] index, Field[] values, int startOffset, int endOffset);
    private string GetFragmentSource(StringBuilder buffer, Int32[] index, Field[] values, WeightedFragInfo weightedFragInfo, Int32& startOffset);
    private string TrimEdges(StringBuilder buffer, int startOffset, int endOffset, Int32& retStartOffset, int maxStart, int minEnd);
    protected virtual string GetPreTag(int num);
    protected virtual string GetPostTag(int num);
}
public class Lucene.Net.Search.Vectorhighlight.FastVectorHighlighter : object {
    public static bool DEFAULT_PHRASE_HIGHLIGHT;
    public static bool DEFAULT_FIELD_MATCH;
    private bool phraseHighlight;
    private bool fieldMatch;
    private FragListBuilder fragListBuilder;
    private FragmentsBuilder fragmentsBuilder;
    private int phraseLimit;
    public int PhraseLimit { get; public set; }
    public FastVectorHighlighter(bool phraseHighlight, bool fieldMatch);
    public FastVectorHighlighter(bool phraseHighlight, bool fieldMatch, FragListBuilder fragListBuilder, FragmentsBuilder fragmentsBuilder);
    private static FastVectorHighlighter();
    public FieldQuery GetFieldQuery(Query query);
    public string GetBestFragment(FieldQuery fieldQuery, IndexReader reader, int docId, string fieldName, int fragCharSize);
    public String[] GetBestFragments(FieldQuery fieldQuery, IndexReader reader, int docId, string fieldName, int fragCharSize, int maxNumFragments);
    private FieldFragList GetFieldFragList(FieldQuery fieldQuery, IndexReader reader, int docId, string fieldName, int fragCharSize);
    public bool IsPhraseHighlight();
    public bool IsFieldMatch();
    public int get_PhraseLimit();
    public void set_PhraseLimit(int value);
}
public class Lucene.Net.Search.Vectorhighlight.FieldFragList : object {
    private int fragCharSize;
    public List`1<WeightedFragInfo> fragInfos;
    public FieldFragList(int fragCharSize);
    public void Add(int startOffset, int endOffset, List`1<WeightedPhraseInfo> phraseInfoList);
}
public class Lucene.Net.Search.Vectorhighlight.FieldPhraseList : object {
    public LinkedList`1<WeightedPhraseInfo> phraseList;
    public FieldPhraseList(FieldTermStack fieldTermStack, FieldQuery fieldQuery);
    public FieldPhraseList(FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit);
    private void AddIfNoOverlap(WeightedPhraseInfo wpi);
}
public class Lucene.Net.Search.Vectorhighlight.FieldQuery : object {
    private bool fieldMatch;
    public HashMap`2<string, QueryPhraseMap> rootMaps;
    public HashMap`2<string, List`1<string>> termSetMap;
    private int termOrPhraseNumber;
    public FieldQuery(Query query, bool phraseHighlight, bool fieldMatch);
    public void flatten(Query sourceQuery, Dictionary`2<Query, Query> flatQueries);
    public Dictionary`2<Query, Query> expand(Dictionary`2<Query, Query> flatQueries);
    private void CheckOverlap(Dictionary`2<Query, Query> expandQueries, PhraseQuery a, PhraseQuery b);
    private void CheckOverlap(Dictionary`2<Query, Query> expandQueries, Term[] src, Term[] dest, int slop, float boost);
    public QueryPhraseMap getRootMap(Query query);
    private string GetKey(Query query);
    private void SaveTerms(Dictionary`2<Query, Query> flatQueries);
    private List`1<string> GetTermSet(Query query);
    public List`1<string> getTermSet(string field);
    public QueryPhraseMap GetFieldTermMap(string fieldName, string term);
    public QueryPhraseMap RetrieveQueryFromSubMap(QueryPhraseMap rootMap, string term);
    public QueryPhraseMap SearchPhrase(string fieldName, List`1<TermInfo> phraseCandidate);
    private QueryPhraseMap GetRootMap(string fieldName);
    private int NextTermOrPhraseNumber();
}
public class Lucene.Net.Search.Vectorhighlight.FieldTermStack : object {
    private string fieldName;
    public LinkedList`1<TermInfo> termList;
    public string FieldName { get; }
    public FieldTermStack(IndexReader reader, int docId, string fieldName, FieldQuery fieldQuery);
    private void Sort(LinkedList`1<TermInfo> linkList);
    private int PosComparer(TermInfo t1, TermInfo t2);
    public string get_FieldName();
    public TermInfo Pop();
    public void Push(TermInfo termInfo);
    public bool IsEmpty();
}
public interface Lucene.Net.Search.Vectorhighlight.FragListBuilder {
    public abstract virtual FieldFragList CreateFieldFragList(FieldPhraseList fieldPhraseList, int fragCharSize);
}
public interface Lucene.Net.Search.Vectorhighlight.FragmentsBuilder {
    public abstract virtual string CreateFragment(IndexReader reader, int docId, string fieldName, FieldFragList fieldFragList, int fragCharSize);
    public abstract virtual String[] CreateFragments(IndexReader reader, int docId, string fieldName, FieldFragList fieldFragList, int maxNumFragments, int fragCharSize);
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Search.Vectorhighlight.HashMap`2 : Dictionary`2<K, V> {
    private V _NullKeyValue;
    public int Count { get; }
    public V Item { get; public set; }
    public void Add(K key, V value);
    public int get_Count();
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public V Get(K key);
    public void Put(K key, V val);
}
public class Lucene.Net.Search.Vectorhighlight.ScoreOrderFragmentsBuilder : BaseFragmentsBuilder {
    public ScoreOrderFragmentsBuilder(String[] preTags, String[] postTags);
    public virtual List`1<WeightedFragInfo> GetWeightedFragInfoList(List`1<WeightedFragInfo> src);
}
public class Lucene.Net.Search.Vectorhighlight.SimpleFragListBuilder : object {
    public static int MARGIN;
    public static int MIN_FRAG_CHAR_SIZE;
    private static SimpleFragListBuilder();
    public sealed virtual FieldFragList CreateFieldFragList(FieldPhraseList fieldPhraseList, int fragCharSize);
}
public class Lucene.Net.Search.Vectorhighlight.SimpleFragmentsBuilder : BaseFragmentsBuilder {
    public SimpleFragmentsBuilder(String[] preTags, String[] postTags);
    public virtual List`1<WeightedFragInfo> GetWeightedFragInfoList(List`1<WeightedFragInfo> src);
}
public static class Lucene.Net.Search.Vectorhighlight.StringUtils : object {
    public static bool TermStringMatch(string term, string termToMatch);
    public static bool AnyTermMatch(IList`1<string> terms, string term);
}
internal class Mono.Reflection.ByteBuffer : object {
    internal Byte[] buffer;
    internal int position;
    public ByteBuffer(Byte[] buffer);
    public byte ReadByte();
    public Byte[] ReadBytes(int length);
    public short ReadInt16();
    public int ReadInt32();
    public long ReadInt64();
    public float ReadSingle();
    public double ReadDouble();
    private void CheckCanRead(int count);
}
[ExtensionAttribute]
public static class Mono.Reflection.Disassembler : object {
    [ExtensionAttribute]
public static IList`1<Instruction> GetInstructions(MethodBase self);
}
public class Mono.Reflection.Instruction : object {
    private int offset;
    private OpCode opcode;
    private object operand;
    private Instruction previous;
    private Instruction next;
    public int Offset { get; }
    public OpCode OpCode { get; }
    public object Operand { get; internal set; }
    public Instruction Previous { get; internal set; }
    public Instruction Next { get; internal set; }
    public int Size { get; }
    internal Instruction(int offset, OpCode opcode);
    public int get_Offset();
    public OpCode get_OpCode();
    public object get_Operand();
    internal void set_Operand(object value);
    public Instruction get_Previous();
    internal void set_Previous(Instruction value);
    public Instruction get_Next();
    internal void set_Next(Instruction value);
    public int get_Size();
    public virtual string ToString();
    private static void AppendLabel(StringBuilder builder, Instruction instruction);
}
internal class Mono.Reflection.MethodBodyReader : object {
    private static OpCode[] one_byte_opcodes;
    private static OpCode[] two_bytes_opcodes;
    private MethodBase method;
    private MethodBody body;
    private Module module;
    private Type[] type_arguments;
    private Type[] method_arguments;
    private ByteBuffer il;
    private ParameterInfo[] parameters;
    private IList`1<LocalVariableInfo> locals;
    private List`1<Instruction> instructions;
    private static MethodBodyReader();
    private MethodBodyReader(MethodBase method, MethodBody methodBody);
    private void ReadInstructions();
    private void ReadOperand(Instruction instruction);
    private void ResolveBranches();
    private static Instruction GetInstruction(List`1<Instruction> instructions, int offset);
    private object GetVariable(Instruction instruction, int index);
    private static bool TargetsLocalVariable(OpCode opcode);
    private LocalVariableInfo GetLocalVariable(int index);
    private ParameterInfo GetParameter(int index);
    private OpCode ReadOpCode();
    public static List`1<Instruction> GetInstructions(MethodBase method);
}
public class OAuthPrincipal : object {
    private AccessTokenBody tokenBody;
    private string tenantId;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AdminDatabases>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ReadOnlyDatabases>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ReadWriteDatabases>k__BackingField;
    public IIdentity Identity { get; }
    public string Name { get; }
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public AccessTokenBody TokenBody { get; }
    public HashSet`1<string> AdminDatabases { get; private set; }
    public HashSet`1<string> ReadOnlyDatabases { get; private set; }
    public HashSet`1<string> ReadWriteDatabases { get; private set; }
    public OAuthPrincipal(AccessTokenBody tokenBody, string tenantId);
    public sealed virtual bool IsInRole(string role);
    public sealed virtual IIdentity get_Identity();
    public sealed virtual string get_Name();
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool get_IsAuthenticated();
    public List`1<string> GetApprovedResources();
    public AccessTokenBody get_TokenBody();
    public bool IsGlobalAdmin();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_AdminDatabases();
    [CompilerGeneratedAttribute]
private void set_AdminDatabases(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ReadOnlyDatabases();
    [CompilerGeneratedAttribute]
private void set_ReadOnlyDatabases(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ReadWriteDatabases();
    [CompilerGeneratedAttribute]
private void set_ReadWriteDatabases(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
private bool <IsInRole>b__3_0(ResourceAccess x);
}
[ExtensionAttribute]
public static class Owin.AppBuilderExtensions : object {
    private static string HostOnAppDisposing;
    [ExtensionAttribute]
public static IAppBuilder UseRavenDB(IAppBuilder app);
    [ExtensionAttribute]
public static IAppBuilder UseRavenDB(IAppBuilder app, InMemoryRavenConfiguration configuration);
    [ExtensionAttribute]
private static IAppBuilder UseInterceptor(IAppBuilder app);
    [ExtensionAttribute]
public static IAppBuilder UseRavenDB(IAppBuilder app, RavenDBOptions options);
    [AsyncStateMachineAttribute("Owin.AppBuilderExtensions/<UpgradeToWebSockets>d__5")]
private static Task UpgradeToWebSockets(RavenDBOptions options, IOwinContext context, Func`1<Task> next);
    private static HttpConfiguration CreateHttpCfg(RavenDBOptions options);
    private static void AddRoutes(HttpConfiguration cfg);
}
internal interface ProcessedByFody {
}
public class QUT.GplexBuffers.BlockReader : MulticastDelegate {
    public BlockReader(object object, IntPtr method);
    public virtual int Invoke(Char[] block, int index, int number);
    public virtual IAsyncResult BeginInvoke(Char[] block, int index, int number, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public static class QUT.GplexBuffers.BlockReaderFactory : object {
    private static ThreadLocal`1<Byte[]> buffer;
    private static BlockReaderFactory();
    public static BlockReader Raw(Stream stream);
    public static BlockReader Get(Stream stream, int fallbackCodePage);
    private static int Preamble(Stream stream);
}
public class QUT.GplexBuffers.BufferException : Exception {
    public BufferException(string message);
    public BufferException(string message, Exception innerException);
    protected BufferException(SerializationInfo info, StreamingContext context);
}
internal class QUT.GplexBuffers.BuildBuffer : ScanBuff {
    private BufferElement data;
    private int bPos;
    private BlockReader NextBlk;
    private Char[] chrs;
    private string EncodingName { get; }
    public int Pos { get; public set; }
    public BuildBuffer(Stream stream);
    public BuildBuffer(Stream stream, int fallbackCodePage);
    private string get_EncodingName();
    public virtual void Mark();
    public virtual int get_Pos();
    public virtual void set_Pos(int value);
    public virtual int Read();
    public virtual string GetString(int begin, int limit);
    public virtual string ToString();
}
public static class QUT.GplexBuffers.CodePageHandling : object {
    public static int GetCodePage(string option);
}
internal class QUT.GplexBuffers.Guesser : object {
    private ScanBuff buffer;
    private static int maxAccept;
    private static int initial;
    private static int eofNum;
    private static int goStart;
    private static int INITIAL;
    private static int EndToken;
    public long utfX;
    public long uppr;
    private int state;
    private int currentStart;
    private int code;
    private static Int32[] startState;
    private static SByte[] map;
    private static SByte[][] nextState;
    private static Guesser();
    public Guesser(Stream file);
    public int GuessCodePage();
    private int NextState();
    public void SetSource(Stream source);
    private int Scan();
}
internal class QUT.GplexBuffers.LineBuffer : ScanBuff {
    private IList`1<string> line;
    private int numLines;
    private string curLine;
    private int cLine;
    private int curLen;
    private int curLineStart;
    private int curLineEnd;
    private int maxPos;
    private int cPos;
    private int cachedPosition;
    private int cachedIxdex;
    private int cachedLineStart;
    public int Pos { get; public set; }
    public LineBuffer(IList`1<string> lineList);
    public virtual int Read();
    private void findIndex(int pos, Int32& ix, Int32& lstart);
    public virtual string GetString(int begin, int limit);
    public virtual int get_Pos();
    public virtual void set_Pos(int value);
    public virtual string ToString();
}
public abstract class QUT.GplexBuffers.ScanBuff : object {
    private string fileNm;
    public static int EndOfFile;
    public static int UnicodeReplacementChar;
    [CompilerGeneratedAttribute]
private bool <EscapeCommaMode>k__BackingField;
    [CompilerGeneratedAttribute]
private CommaState <state>k__BackingField;
    public bool IsFile { get; }
    public string FileName { get; public set; }
    public int Pos { get; public set; }
    public bool EscapeCommaMode { get; public set; }
    protected CommaState state { get; protected set; }
    public bool get_IsFile();
    public string get_FileName();
    public void set_FileName(string value);
    public abstract virtual int get_Pos();
    public abstract virtual void set_Pos(int value);
    public abstract virtual int Read();
    public virtual void Mark();
    public abstract virtual string GetString(int begin, int limit);
    public static ScanBuff GetBuffer(string source);
    public static ScanBuff GetBuffer(IList`1<string> source);
    public static ScanBuff GetBuffer(Stream source);
    public static ScanBuff GetBuffer(Stream source, int fallbackCodePage);
    [CompilerGeneratedAttribute]
public bool get_EscapeCommaMode();
    [CompilerGeneratedAttribute]
public void set_EscapeCommaMode(bool value);
    [CompilerGeneratedAttribute]
protected CommaState get_state();
    [CompilerGeneratedAttribute]
protected void set_state(CommaState value);
}
internal class QUT.GplexBuffers.StringBuffer : ScanBuff {
    private string str;
    private int bPos;
    private int sLen;
    public int Pos { get; public set; }
    public StringBuffer(string source);
    public virtual int Read();
    public virtual string GetString(int begin, int limit);
    public virtual int get_Pos();
    public virtual void set_Pos(int value);
    public virtual string ToString();
}
internal abstract class QUT.Gppg.AbstractScanner`2 : object {
    public TValue yylval;
    public TSpan yylloc { get; public set; }
    public virtual TSpan get_yylloc();
    public virtual void set_yylloc(TSpan value);
    public abstract virtual int yylex();
    public virtual void yyerror(string format, Object[] args);
}
internal interface QUT.Gppg.IMerge`1 {
    public abstract virtual TSpan Merge(TSpan last);
}
internal class QUT.Gppg.LexLocation : object {
    private int startLine;
    private int startColumn;
    private int endLine;
    private int endColumn;
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public LexLocation(int sl, int sc, int el, int ec);
    public int get_StartLine();
    public int get_StartColumn();
    public int get_EndLine();
    public int get_EndColumn();
    public sealed virtual LexLocation Merge(LexLocation last);
}
[DefaultMemberAttribute("Item")]
internal class QUT.Gppg.PushdownPrefixState`1 : object {
    private T[] array;
    private int tos;
    public T Item { get; }
    public int Depth { get; }
    public T get_Item(int index);
    public int get_Depth();
    internal void Push(T value);
    internal T Pop();
    internal T TopElement();
    internal bool IsEmpty();
}
internal class QUT.Gppg.Rule : object {
    internal int LeftHandSide;
    internal Int32[] RightHandSide;
    public Rule(int left, Int32[] right);
}
internal abstract class QUT.Gppg.ShiftReduceParser`2 : object {
    private AbstractScanner`2<TValue, TSpan> scanner;
    protected TValue CurrentSemanticValue;
    protected TSpan CurrentLocationSpan;
    protected int NextToken;
    private TSpan LastSpan;
    private State FsaState;
    private bool recovering;
    private int tokensSinceLastError;
    private PushdownPrefixState`1<State> StateStack;
    private PushdownPrefixState`1<TValue> valueStack;
    private PushdownPrefixState`1<TSpan> locationStack;
    private int errorToken;
    private int endOfFileToken;
    private String[] nonTerminals;
    private State[] states;
    private Rule[] rules;
    protected AbstractScanner`2<TValue, TSpan> Scanner { get; protected set; }
    protected PushdownPrefixState`1<TValue> ValueStack { get; }
    protected PushdownPrefixState`1<TSpan> LocationStack { get; }
    protected bool YYRecovering { get; }
    protected ShiftReduceParser`2(AbstractScanner`2<TValue, TSpan> scanner);
    protected AbstractScanner`2<TValue, TSpan> get_Scanner();
    protected void set_Scanner(AbstractScanner`2<TValue, TSpan> value);
    protected PushdownPrefixState`1<TValue> get_ValueStack();
    protected PushdownPrefixState`1<TSpan> get_LocationStack();
    protected void InitRules(Rule[] rules);
    protected void InitStates(State[] states);
    protected void InitStateTable(int size);
    protected void InitSpecialTokens(int err, int end);
    protected void InitNonTerminals(String[] names);
    protected static void YYAccept();
    protected static void YYAbort();
    protected static void YYError();
    protected bool get_YYRecovering();
    protected abstract virtual void Initialize();
    public bool Parse();
    private void Shift(int stateIndex);
    private void Reduce(int ruleNumber);
    protected abstract virtual void DoAction(int actionNumber);
    private bool ErrorRecovery();
    private void ReportError();
    private void ShiftErrorToken();
    private bool FindErrorRecoveryState();
    private bool DiscardInvalidTokens();
    protected void yyclearin();
    protected void yyerrok();
    protected void AddState(int stateNumber, State state);
    private void DisplayStack();
    private void DisplayRule(int ruleNumber);
    private void DisplayProduction(Rule rule);
    protected abstract virtual string TerminalToString(int terminal);
    private string SymbolToString(int symbol);
    protected static string CharToString(char input);
}
internal class QUT.Gppg.State : object {
    internal int number;
    internal Dictionary`2<int, int> ParserTable;
    internal Int32[] Goto;
    internal int defaultAction;
    private int shift;
    public State(Int32[] actions, Int32[] goToList);
    public State(Int32[] actions);
    public State(int defaultAction);
    public State(int defaultAction, Int32[] goToList);
    private void InitGoto(Int32[] goToList);
    public bool TryGetValue(int key, Int32& val);
}
public class Raven.Abstractions.Streaming.ExcelOutputWriter : object {
    private static string CsvContentType;
    private Stream stream;
    private String[] customColumns;
    private IEnumerable`1<string> properties;
    private StreamWriter writer;
    private CsvWriter csvWriter;
    private bool doIncludeId;
    public string ContentType { get; }
    public ExcelOutputWriter(Stream stream, String[] customColumns);
    public sealed virtual string get_ContentType();
    public sealed virtual void Dispose();
    public sealed virtual void WriteHeader();
    public sealed virtual void Write(RavenJObject result);
    public void Write(string result);
    public sealed virtual void WriteError(Exception exception);
    public sealed virtual void Flush();
    private void GetPropertiesAndWriteCsvHeader(RavenJObject result, Boolean& includeId);
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractDocumentCodec")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Bundles.Compression.Plugin.DocumentCompression : AbstractDocumentCodec {
    [CLSCompliantAttribute("False")]
public static UInt32 CompressFileMagic;
    public virtual Stream Encode(string key, RavenJObject data, RavenJObject metadata, Stream dataStream);
    public virtual Stream Decode(string key, RavenJObject metadata, Stream dataStream);
}
internal class Raven.Bundles.Compression.Streams.CompressStream : Stream {
    private DeflateStream deflateStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    public CompressStream(Stream underlyingStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Length();
    public virtual void SetLength(long value);
    public virtual void Close();
}
internal class Raven.Bundles.Compression.Streams.DecompressStream : Stream {
    private StreamReaderWithUnread underlyingStream;
    private bool compressed;
    private DeflateStream deflateStream;
    private long pos;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    public DecompressStream(Stream underlyingStream);
    private bool CheckMagicNumber();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Length();
    public virtual void SetLength(long value);
    public virtual void Close();
}
internal class Raven.Bundles.Compression.Streams.StreamReaderWithUnread : object {
    public Stream stream;
    private Stack`1<Buffer> unreadBuffer;
    public StreamReaderWithUnread(Stream stream);
    public int Read(Byte[] buffer, int start, int length);
    public void Unread(IEnumerable`1<byte> data);
    public void Close();
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractDocumentCodec")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Bundles.Encryption.Plugin.DocumentEncryption : AbstractDocumentCodec {
    private EncryptionSettings settings;
    public virtual void Initialize();
    public virtual void SecondStageInit();
    public virtual Stream Encode(string key, RavenJObject data, RavenJObject metadata, Stream dataStream);
    public virtual Stream Decode(string key, RavenJObject metadata, Stream dataStream);
    public void SetSettings(EncryptionSettings newSettings);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractDeleteTrigger")]
public class Raven.Bundles.Encryption.Plugin.EncryptionSettingsDeleteTrigger : AbstractDeleteTrigger {
    public virtual VetoResult AllowDelete(string key, TransactionInformation transactionInformation);
}
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractPutTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Bundles.Encryption.Plugin.EncryptionSettingsPutTrigger : AbstractPutTrigger {
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractIndexCodec")]
public class Raven.Bundles.Encryption.Plugin.IndexEncryption : AbstractIndexCodec {
    private EncryptionSettings settings;
    public virtual void Initialize(DocumentDatabase database);
    public virtual Stream Encode(string key, Stream dataStream);
    public virtual Stream Decode(string key, Stream dataStream);
}
public class Raven.Bundles.Encryption.Settings.EncryptionSettings : object {
    private Byte[] encryptionKey;
    private Type algorithmType;
    private Func`1<SymmetricAlgorithm> algorithmGenerator;
    private bool encryptIndexes;
    private int preferedEncryptionKeyBitsSize;
    public Codec Codec;
    public Byte[] EncryptionKey { get; private set; }
    public Type SymmetricAlgorithmType { get; }
    public Func`1<SymmetricAlgorithm> GenerateAlgorithm { get; }
    public bool EncryptIndexes { get; }
    public int PreferedEncryptionKeyBitsSize { get; }
    public EncryptionSettings(Byte[] encryptionKey, Type symmetricAlgorithmType, bool encryptIndexes, int preferedEncryptionKeyBitsSize);
    public static bool DontEncrypt(string key);
    public Byte[] get_EncryptionKey();
    private void set_EncryptionKey(Byte[] value);
    public Type get_SymmetricAlgorithmType();
    public Func`1<SymmetricAlgorithm> get_GenerateAlgorithm();
    public bool get_EncryptIndexes();
    public int get_PreferedEncryptionKeyBitsSize();
    public static Byte[] GenerateRandomEncryptionKey(int length);
}
internal class Raven.Bundles.Encryption.Streams.BlockReaderWriter : object {
    private EncryptionSettings settings;
    private Stream stream;
    private string key;
    private object locker;
    private bool isReadonly;
    private Header header;
    private Footer footer;
    private long totalUnencryptedSize;
    public Header Header { get; }
    public Footer Footer { get; }
    public BlockReaderWriter(EncryptionSettings encryptionSettings, string key, Stream stream, int defaultBlockSize);
    public Header get_Header();
    public Footer get_Footer();
    private Header ReadOrWriteEmptyHeader(int defaultBlockSize);
    private int GetHeaderSizeByMagicNumber(ulong magicNumber);
    private void WriteHeaderInCurrentPositionIfNotReadonly(Header fileHeader, ulong magicNumber);
    private Footer ReadOrWriteFooter();
    private void WriteFooterInCurrentPosition(Footer footer);
    public Block ReadBlock(long blockNumber);
    public void WriteBlock(Block block, long size);
    public void Flush();
    public sealed virtual void Dispose();
}
internal static class Raven.Bundles.Encryption.Streams.EncryptedFile : object {
    public static ulong DefaultMagicNumber;
    public static ulong WithTotalSizeMagicNumber;
}
public class Raven.Bundles.Encryption.Streams.SeekableCryptoStream : Stream {
    private BlockReaderWriter underlyingStream;
    private int currentBlockSize;
    private object locker;
    private Block currentReadingBlock;
    private Block currentWritingBlock;
    private long currentWritingBlockUsage;
    private long currentPosition;
    private bool isReadonly;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public long Length { get; }
    public SeekableCryptoStream(EncryptionSettings encryptionSettings, string key, Stream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual int Read(Byte[] buffer, int bufferOffset, int count);
    public virtual void Write(Byte[] buffer, int bufferOffset, int count);
    private void WriteAnyUnwrittenData();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual long get_Length();
    public virtual void SetLength(long value);
}
public static class Raven.Bundles.Encryption.Streams.StructConverter : object {
    public static T ConvertBitsToStruct(Byte[] bytes, Nullable`1<int> overrideHeaderSize);
    public static Byte[] ConvertStructToBits(T data, Nullable`1<int> overrideHeaderSize);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractReadTrigger")]
public class Raven.Bundles.Expiration.ExpirationReadTrigger : AbstractReadTrigger {
    public static string RavenExpirationDate;
    public virtual ReadVetoResult AllowRead(string key, RavenJObject metadata, ReadOperation operation, TransactionInformation transactionInformation);
}
public class Raven.Bundles.Quotas.Documents.DocQuotaConfiguration : object {
    private DocumentDatabase database;
    private long hardLimit;
    private long softLimit;
    private DateTime lastCheck;
    private VetoResult skipCheck;
    private bool recheckOnDelete;
    public DocQuotaConfiguration(DocumentDatabase database);
    public static DocQuotaConfiguration GetConfiguration(DocumentDatabase database);
    public VetoResult AllowPut();
    private void UpdateSkippedCheck();
    public void AfterDelete();
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractDeleteTrigger")]
public class Raven.Bundles.Quotas.Documents.Triggers.DatabaseCountDocumentDeleteTrigger : AbstractDeleteTrigger {
    public virtual void AfterDelete(string key, TransactionInformation transactionInformation);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractPutTrigger")]
public class Raven.Bundles.Quotas.Documents.Triggers.DatabaseCountQuotaForDocumentsPutTrigger : AbstractPutTrigger {
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
}
public class Raven.Bundles.Quotas.Size.SizeQuotaConfiguration : object {
    private DocumentDatabase database;
    private int margin;
    private long hardLimit;
    private long softLimit;
    private DateTime lastCheck;
    private VetoResult skipCheck;
    private bool recheckOnDelete;
    public SizeQuotaConfiguration(DocumentDatabase database);
    public static SizeQuotaConfiguration GetConfiguration(DocumentDatabase database);
    public VetoResult AllowPut();
    private void UpdateSkippedCheck();
    public void AfterDelete();
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractAttachmentDeleteTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Bundles.Quotas.Size.Triggers.DatabaseSizeAttachmentDeleteTrigger : AbstractAttachmentDeleteTrigger {
    public virtual void AfterDelete(string key);
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractDeleteTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Bundles.Quotas.Size.Triggers.DatabaseSizeDocumentDeleteTrigger : AbstractDeleteTrigger {
    public virtual void AfterDelete(string key, TransactionInformation transactionInformation);
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractAttachmentPutTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Bundles.Quotas.Size.Triggers.DatabaseSizeQuotaForAttachmentsPutTrigger : AbstractAttachmentPutTrigger {
    public virtual VetoResult AllowPut(string key, Stream data, RavenJObject metadata);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractPutTrigger")]
public class Raven.Bundles.Quotas.Size.Triggers.DatabaseSizeQuotaForDocumentsPutTrigger : AbstractPutTrigger {
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
}
public class Raven.Bundles.Replication.Data.DestinationFailureInformation : object {
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FailureCount>k__BackingField;
    public string Destination { get; public set; }
    public int FailureCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    [CompilerGeneratedAttribute]
public int get_FailureCount();
    [CompilerGeneratedAttribute]
public void set_FailureCount(int value);
}
public class Raven.Bundles.Replication.Data.SourceReplicationInformation : object {
    [CompilerGeneratedAttribute]
private Etag <LastDocumentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastModifiedAtSource>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastAttachmentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ServerInstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LastBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceCollections>k__BackingField;
    public Etag LastDocumentEtag { get; public set; }
    public Nullable`1<DateTime> LastModifiedAtSource { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag LastAttachmentEtag { get; public set; }
    public Guid ServerInstanceId { get; public set; }
    public string Source { get; public set; }
    public Nullable`1<DateTime> LastModified { get; public set; }
    public Nullable`1<int> LastBatchSize { get; public set; }
    public string SourceCollections { get; public set; }
    [JsonIgnoreAttribute]
public bool IsETL { get; }
    [CompilerGeneratedAttribute]
public Etag get_LastDocumentEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocumentEtag(Etag value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastModifiedAtSource();
    [CompilerGeneratedAttribute]
public void set_LastModifiedAtSource(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Etag get_LastAttachmentEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentEtag(Etag value);
    [CompilerGeneratedAttribute]
public Guid get_ServerInstanceId();
    [CompilerGeneratedAttribute]
public void set_ServerInstanceId(Guid value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LastBatchSize();
    [CompilerGeneratedAttribute]
public void set_LastBatchSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_SourceCollections();
    [CompilerGeneratedAttribute]
public void set_SourceCollections(string value);
    public bool get_IsETL();
    public virtual string ToString();
}
public class Raven.Bundles.Replication.Data.SourceReplicationInformationWithBatchInformation : SourceReplicationInformation {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxNumberOfItemsToReceiveInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <DatabaseId>k__BackingField;
    public Nullable`1<int> MaxNumberOfItemsToReceiveInSingleBatch { get; public set; }
    public Nullable`1<Guid> DatabaseId { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxNumberOfItemsToReceiveInSingleBatch();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfItemsToReceiveInSingleBatch(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_DatabaseId();
    [CompilerGeneratedAttribute]
public void set_DatabaseId(Nullable`1<Guid> value);
}
internal class Raven.Bundles.Replication.Impl.ReplicationHiLo : object {
    private object generatorLock;
    private Holder modreq(System.Runtime.CompilerServices.IsVolatile) currentMax;
    private long capacity;
    private long current;
    private DateTime lastRequestedUtc;
    private static string RavenReplicationHilo;
    private static string RavenReplicationVersionHiLo;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    private ReplicationHiLo(DocumentDatabase database);
    public static long NextId(DocumentDatabase database);
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    public long NextId();
    private long GetNextMax();
}
[InheritedExportAttribute]
[ObsoleteAttribute("Use RavenFS instead.")]
public abstract class Raven.Bundles.Replication.Plugins.AbstractAttachmentReplicationConflictResolver : object {
    private ILog log;
    public bool TryResolveConflict(string id, RavenJObject metadata, Byte[] data, Attachment existingAttachment, Func`2<string, Attachment> getAttachment, RavenJObject& metadataToSave, Byte[]& dataToSave);
    protected abstract virtual bool TryResolve(string id, RavenJObject metadata, Byte[] data, Attachment existingAttachment, Func`2<string, Attachment> getAttachment, RavenJObject& metadataToSave, Byte[]& dataToSave);
}
[InheritedExportAttribute]
public abstract class Raven.Bundles.Replication.Plugins.AbstractDocumentReplicationConflictResolver : object {
    private ILog log;
    public bool TryResolveConflict(string id, RavenJObject metadata, RavenJObject document, JsonDocument existingDoc, Func`2<string, JsonDocument> getDocument, RavenJObject& metadataToSave, RavenJObject& documentToSave);
    protected abstract virtual bool TryResolve(string id, RavenJObject metadata, RavenJObject document, JsonDocument existingDoc, Func`2<string, JsonDocument> getDocument, RavenJObject& metadataToSave, RavenJObject& documentToSave);
}
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Bundles.Replication.Responders.AttachmentReplicationBehavior : SingleItemReplicationBehavior`2<Attachment, Byte[]> {
    [CompilerGeneratedAttribute]
private IEnumerable`1<AbstractAttachmentReplicationConflictResolver> <ReplicationConflictResolvers>k__BackingField;
    public IEnumerable`1<AbstractAttachmentReplicationConflictResolver> ReplicationConflictResolvers { get; public set; }
    protected ReplicationConflictTypes ReplicationConflict { get; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<AbstractAttachmentReplicationConflictResolver> get_ReplicationConflictResolvers();
    [CompilerGeneratedAttribute]
public void set_ReplicationConflictResolvers(IEnumerable`1<AbstractAttachmentReplicationConflictResolver> value);
    protected virtual ReplicationConflictTypes get_ReplicationConflict();
    protected virtual void DeleteItem(string id, Etag etag);
    protected virtual void MarkAsDeleted(string id, RavenJObject metadata);
    protected virtual void AddWithoutConflict(string id, Etag etag, RavenJObject metadata, Byte[] incoming);
    protected virtual CreatedConflict<Attachment, Byte[]> CreateConflict(string id, string newDocumentConflictId, string existingDocumentConflictId, Attachment existingItem, RavenJObject existingMetadata);
    protected virtual CreatedConflict<Attachment, Byte[]> AppendToCurrentItemConflicts(string id, string newConflictId, RavenJObject existingMetadata, Attachment existingItem);
    protected virtual RavenJObject TryGetExisting(string id, Attachment& existingItem, Etag& existingEtag, Boolean& deleted);
    protected virtual bool TryResolveConflict(string id, RavenJObject metadata, Byte[] data, Attachment existing, RavenJObject& metadataToSave, Byte[]& dataToSave);
    protected virtual bool TryResolveConflictByCheckingIfIdentical(string documentId, RavenJObject metadata, Byte[] document, Attachment existing, RavenJObject& resolvedMetadataToSave);
}
public class Raven.Bundles.Replication.Responders.DocumentReplicationBehavior : SingleItemReplicationBehavior`2<JsonDocument, RavenJObject> {
    [CompilerGeneratedAttribute]
private IEnumerable`1<AbstractDocumentReplicationConflictResolver> <ReplicationConflictResolvers>k__BackingField;
    public IEnumerable`1<AbstractDocumentReplicationConflictResolver> ReplicationConflictResolvers { get; public set; }
    protected ReplicationConflictTypes ReplicationConflict { get; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<AbstractDocumentReplicationConflictResolver> get_ReplicationConflictResolvers();
    [CompilerGeneratedAttribute]
public void set_ReplicationConflictResolvers(IEnumerable`1<AbstractDocumentReplicationConflictResolver> value);
    protected virtual ReplicationConflictTypes get_ReplicationConflict();
    protected virtual void DeleteItem(string id, Etag etag);
    protected virtual void MarkAsDeleted(string id, RavenJObject metadata);
    protected virtual void AddWithoutConflict(string id, Etag etag, RavenJObject metadata, RavenJObject incoming);
    protected virtual CreatedConflict<JsonDocument, RavenJObject> CreateConflict(string id, string newDocumentConflictId, string existingDocumentConflictId, JsonDocument existingItem, RavenJObject existingMetadata);
    protected virtual CreatedConflict<JsonDocument, RavenJObject> AppendToCurrentItemConflicts(string id, string newConflictId, RavenJObject existingMetadata, JsonDocument existingItem);
    protected virtual RavenJObject TryGetExisting(string id, JsonDocument& existingItem, Etag& existingEtag, Boolean& deleted);
    protected virtual bool TryResolveConflict(string id, RavenJObject metadata, RavenJObject document, JsonDocument existing, RavenJObject& metadataToSave, RavenJObject& documentToSave);
    protected virtual bool TryResolveConflictByCheckingIfIdentical(string documentId, RavenJObject metadata, RavenJObject document, JsonDocument existing, RavenJObject& resolvedMetadataToSave);
    [CompilerGeneratedAttribute]
private JsonDocument <TryResolveConflict>b__12_0(string key);
}
internal class Raven.Bundles.Replication.Tasks.LastReplicatedEtags : object {
    [CompilerGeneratedAttribute]
private Etag <LastReplicatedDocumentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastReplicatedAttachmentEtag>k__BackingField;
    public Etag LastReplicatedDocumentEtag { get; public set; }
    public Etag LastReplicatedAttachmentEtag { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_LastReplicatedDocumentEtag();
    [CompilerGeneratedAttribute]
public void set_LastReplicatedDocumentEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastReplicatedAttachmentEtag();
    [CompilerGeneratedAttribute]
public void set_LastReplicatedAttachmentEtag(Etag value);
}
internal class Raven.Bundles.Replication.Tasks.ReplicationScriptedJsonPatcher : ScriptedJsonPatcher {
    private ScriptedPatchRequest scriptedPatchRequest;
    public ReplicationScriptedJsonPatcher(DocumentDatabase database, ScriptedPatchRequest scriptedPatchRequest);
    protected virtual void CustomizeEngine(Engine engine, ScriptedJsonPatcherOperationScope scope);
}
internal class Raven.Bundles.Replication.Tasks.ReplicationStatisticsRecorder : object {
    private ReplicationStrategy destination;
    private ConcurrentDictionary`2<string, DestinationStats> destinationStats;
    private RavenJObject record;
    private RavenJArray records;
    private Stopwatch watch;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    public DateTime Started { get; private set; }
    public TimeSpan ElapsedTime { get; }
    public ReplicationStatisticsRecorder(ReplicationStrategy destination, ConcurrentDictionary`2<string, DestinationStats> destinationStats);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
private void set_Started(DateTime value);
    public TimeSpan get_ElapsedTime();
    public sealed virtual void Dispose();
    public ReplicationStatisticsRecorderScope StartRecording(string name);
}
public class Raven.Bundles.Replication.Tasks.ReplicationStrategy : object {
    private static ILog Log;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <SpecifiedCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReplicateAttachmentsInEtl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentDatabaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private TransitiveReplicationOptions <ReplicationOptionsBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenConnectionStringOptions <ConnectionStringOptions>k__BackingField;
    public Dictionary`2<string, string> SpecifiedCollections { get; public set; }
    public bool IsETL { get; }
    public bool ReplicateAttachmentsInEtl { get; public set; }
    public string CurrentDatabaseId { get; public set; }
    public TransitiveReplicationOptions ReplicationOptionsBehavior { get; public set; }
    public RavenConnectionStringOptions ConnectionStringOptions { get; public set; }
    private static ReplicationStrategy();
    public bool FilterDocuments(string destinationId, string key, RavenJObject metadata, String& reason);
    public bool OriginsFromDestination(string destinationId, RavenJObject metadata);
    public bool OriginatedAtOtherDestinations(string sourceId, RavenJObject metadata);
    public bool IsSystemDocumentId(string key);
    [ObsoleteAttribute("Use RavenFS instead.")]
public bool FilterAttachments(AttachmentInformation attachment, string destinationInstanceId);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_SpecifiedCollections();
    [CompilerGeneratedAttribute]
public void set_SpecifiedCollections(Dictionary`2<string, string> value);
    public bool get_IsETL();
    [CompilerGeneratedAttribute]
public bool get_ReplicateAttachmentsInEtl();
    [CompilerGeneratedAttribute]
public void set_ReplicateAttachmentsInEtl(bool value);
    [CompilerGeneratedAttribute]
public string get_CurrentDatabaseId();
    [CompilerGeneratedAttribute]
public void set_CurrentDatabaseId(string value);
    [CompilerGeneratedAttribute]
public TransitiveReplicationOptions get_ReplicationOptionsBehavior();
    [CompilerGeneratedAttribute]
public void set_ReplicationOptionsBehavior(TransitiveReplicationOptions value);
    [CompilerGeneratedAttribute]
public RavenConnectionStringOptions get_ConnectionStringOptions();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringOptions(RavenConnectionStringOptions value);
    public virtual string ToString();
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.IStartupTask")]
public class Raven.Bundles.Replication.Tasks.ReplicationTask : object {
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) shouldPause;
    [CompilerGeneratedAttribute]
private int <NumberOfActiveReplicationDestinations>k__BackingField;
    public static int SystemDocsLimitForRemoteEtagUpdate;
    public static int DestinationDocsLimitForRemoteEtagUpdate;
    public static int EtlFilteredDocumentsForRemoteEtagUpdate;
    public ConcurrentSet`1<Task> activeTasks;
    private ConcurrentDictionary`2<string, DestinationStats> destinationStats;
    private DocumentDatabase docDb;
    private static ILog log;
    private bool firstTimeFoundNoReplicationDocument;
    private bool wrongReplicationSourceAlertSent;
    private ConcurrentDictionary`2<string, SemaphoreSlim> activeReplicationTasks;
    private static Task completedTask;
    private ConcurrentDictionary`2<string, DateTime> destinationAlertSent;
    private ConcurrentDictionary`2<string, bool> destinationForceBuffering;
    private int replicationAttempts;
    private int workCounter;
    private HttpRavenRequestFactory httpRavenRequestFactory;
    private IndependentBatchSizeAutoTuner autoTuner;
    private ConcurrentDictionary`2<string, PrefetchingBehavior> prefetchingBehaviors;
    [CompilerGeneratedAttribute]
private IndexReplicationTask <IndexReplication>k__BackingField;
    [CompilerGeneratedAttribute]
private TransformerReplicationTask <TransformerReplication>k__BackingField;
    private CancellationTokenSource _cts;
    private int _needToPropogateToSiblings;
    private Timer _propagationTimeoutTimer;
    private ThreadLocal`1<bool> isThreadProcessingReplication;
    [CompilerGeneratedAttribute]
private DatabaseIdsCache <DatabaseIdsCache>k__BackingField;
    private ConcurrentDictionary`2<string, Etag> lastReplicatedDocumentOrTombstoneEtag;
    private ConcurrentDictionary`2<string, Etag> lastReplicatedAttachmentOrTombstoneEtag;
    private bool _hasReplicationRanAtLeastOnce;
    private ConcurrentQueue`1<TaskCompletionSource`1<object>> _waitForReplicationTasks;
    private string _transactionalStorageId;
    private ConcurrentDictionary`2<string, DateTime> heartbeatDictionary;
    private Etag lastWorkDocumentEtag;
    private Etag lastWorkAttachmentEtag;
    private bool lastWorkIsIndexOrTransformer;
    public bool IsRunning { get; private set; }
    public int NumberOfActiveReplicationDestinations { get; private set; }
    public ConcurrentDictionary`2<string, DestinationStats> DestinationStats { get; }
    public ConcurrentDictionary`2<string, DateTime> Heartbeats { get; }
    public IndexReplicationTask IndexReplication { get; public set; }
    public TransformerReplicationTask TransformerReplication { get; public set; }
    public DatabaseIdsCache DatabaseIdsCache { get; private set; }
    internal ThreadLocal`1<bool> IsThreadProcessingReplication { get; internal set; }
    private static ReplicationTask();
    [CompilerGeneratedAttribute]
public bool get_IsRunning();
    [CompilerGeneratedAttribute]
private void set_IsRunning(bool value);
    [CompilerGeneratedAttribute]
public int get_NumberOfActiveReplicationDestinations();
    [CompilerGeneratedAttribute]
private void set_NumberOfActiveReplicationDestinations(int value);
    public ConcurrentDictionary`2<string, DestinationStats> get_DestinationStats();
    public ConcurrentDictionary`2<string, DateTime> get_Heartbeats();
    [CompilerGeneratedAttribute]
public IndexReplicationTask get_IndexReplication();
    [CompilerGeneratedAttribute]
public void set_IndexReplication(IndexReplicationTask value);
    [CompilerGeneratedAttribute]
public TransformerReplicationTask get_TransformerReplication();
    [CompilerGeneratedAttribute]
public void set_TransformerReplication(TransformerReplicationTask value);
    [CompilerGeneratedAttribute]
public DatabaseIdsCache get_DatabaseIdsCache();
    [CompilerGeneratedAttribute]
private void set_DatabaseIdsCache(DatabaseIdsCache value);
    internal ThreadLocal`1<bool> get_IsThreadProcessingReplication();
    internal void set_IsThreadProcessingReplication(ThreadLocal`1<bool> value);
    public sealed virtual void Execute(DocumentDatabase database);
    private static void DeployIndexesAndTransformers(DocumentDatabase database);
    public void Pause();
    public void Continue();
    private bool IsHotSpare();
    private void Execute();
    private bool HasAttachmentEtagChanged();
    private bool HasDocumentOrTombstoneEtagChanged();
    public Task ExecuteReplicationOnce(bool runningBecauseOfDataModifications);
    private void ClearCachedLastEtagForRemovedServers(ReplicationStrategy[] destinations);
    public void ForceReplicationToRunOnce();
    private void CleanupPrefetchingBehaviors(IEnumerable`1<string> allDestinations, IEnumerable`1<string> failingDestinations);
    private void NotifySiblings();
    private void NotifySibling(BlockingCollection`1<RavenConnectionStringOptions> collection);
    private bool IsNotFailing(ReplicationStrategy dest, int currentReplicationAttempts);
    public static string EscapeDestinationName(string url);
    private void WarnIfNoReplicationTargetsWereFound();
    private bool ReplicateTo(ReplicationStrategy destination, Etag& lastDocumentEtag, Etag& lastAttachmentEtag);
    private void UpdateReplicationPerformance(ReplicationStrategy destination, DateTime startTime, TimeSpan elapsed, int batchSize);
    [ObsoleteAttribute("Use RavenFS instead.")]
private Nullable`1<bool> ReplicateAttachments(ReplicationStrategy destination, SourceReplicationInformationWithBatchInformation destinationsReplicationInformationForSource, ReplicationStatisticsRecorderScope recorder, Etag& lastAttachmentEtag);
    private Nullable`1<bool> ReplicateDocuments(ReplicationStrategy destination, SourceReplicationInformationWithBatchInformation destinationsReplicationInformationForSource, ReplicationStatisticsRecorderScope recorder, Int32& replicatedDocuments, Etag& lastReplicatedEtag);
    private void SetLastReplicatedEtagForServer(ReplicationStrategy destination, Etag lastDocEtag, Etag lastAttachmentEtag);
    private string GetUrlFor(ReplicationStrategy destination, string endpoint);
    private void RecordFailure(string url, string lastError);
    private void RecordLastEtagChecked(string url, Etag lastEtagChecked);
    private void RecordSuccess(string url, Etag lastReplicatedEtag, Nullable`1<DateTime> lastReplicatedLastModified, Nullable`1<DateTime> lastHeartbeatReceived, string lastError, bool forDocuments);
    private bool IsFirstFailure(string url);
    [ObsoleteAttribute("Use RavenFS instead.")]
private bool TryReplicationAttachments(ReplicationStrategy destination, RavenJArray jsonAttachments, String& errorMessage);
    public int GetSizeOfMajorityFromActiveReplicationDestination(int replicas);
    [AsyncStateMachineAttribute("Raven.Bundles.Replication.Tasks.ReplicationTask/<WaitForReplicationAsync>d__84")]
public Task`1<int> WaitForReplicationAsync(Etag etag, TimeSpan timeout, int numberOfReplicasToWaitFor);
    private Task WaitForNextReplicationAsync();
    private int ReplicatedPast(Etag etag);
    internal bool GetRequestBuffering(ReplicationStrategy destination);
    private bool TryReplicationDocuments(ReplicationStrategy destination, RavenJArray jsonDocuments, String& lastError);
    internal void HandleRequestBufferingErrors(Exception e, ReplicationStrategy destination);
    private JsonDocumentsToReplicate GetJsonDocuments(SourceReplicationInformationWithBatchInformation destinationsReplicationInformationForSource, ReplicationStrategy destination, PrefetchingBehavior prefetchingBehavior, ReplicationStatisticsRecorderScope scope);
    private List`1<JsonDocument> GetDocsToReplicate(PrefetchingBehavior prefetchingBehavior, Etag from, Nullable`1<int> maxNumberOfItemsToReceiveInSingleBatch);
    [ObsoleteAttribute("Use RavenFS instead.")]
private Tuple`2<RavenJArray, Etag> GetAttachments(SourceReplicationInformationWithBatchInformation destinationsReplicationInformationForSource, ReplicationStrategy destination, ReplicationStatisticsRecorderScope scope);
    [ObsoleteAttribute("Use RavenFS instead.")]
private List`1<AttachmentInformation> GetAttachmentsToReplicate(IStorageActionsAccessor actions, Etag lastAttachmentEtag, Nullable`1<int> maxNumberOfItemsToReceiveInSingleBatch);
    internal SourceReplicationInformationWithBatchInformation GetLastReplicatedEtagFrom(ReplicationStrategy destination);
    private string UrlEncodedServerUrl();
    internal ReplicationStrategy[] GetReplicationDestinations(Predicate`1<ReplicationDestination> predicate);
    private ReplicationStrategy GetConnectionOptionsSafe(ReplicationDestination x);
    public static ReplicationStrategy GetConnectionOptions(ReplicationDestination destination, DocumentDatabase database);
    private static ReplicationStrategy CreateReplicationStrategyFromDocument(ReplicationDestination destination, ReplicationStrategy replicationStrategy);
    public void HandleHeartbeat(string src, bool wake);
    public bool IsHeartbeatAvailable(string src, DateTime lastCheck);
    private void ResetFailureForHeartbeat(string src);
    public sealed virtual void Dispose();
    internal static void EnsureReplicationInformationInMetadata(RavenJObject metadata, DocumentDatabase database);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractAttachmentPutTrigger")]
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Bundles.Replication.Triggers.AttachmentAncestryPutTrigger : AbstractAttachmentPutTrigger {
    public virtual void OnPut(string key, Stream data, RavenJObject metadata);
    private RavenJObject GetAttachmentMetadata(string key);
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractAttachmentReadTrigger")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Bundles.Replication.Triggers.HideVirtuallyDeletedAttachmentsReadTrigger : AbstractAttachmentReadTrigger {
    public virtual ReadVetoResult AllowRead(string key, Stream data, RavenJObject metadata, ReadOperation operation);
}
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractReadTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Bundles.Replication.Triggers.HideVirtuallyDeletedDocumentsReadTrigger : AbstractReadTrigger {
    public virtual ReadVetoResult AllowRead(string key, RavenJObject metadata, ReadOperation operation, TransactionInformation transactionInformation);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractPutTrigger")]
public class Raven.Bundles.Replication.Triggers.PreventConflictDocumentsPutTrigger : AbstractPutTrigger {
    public virtual void OnPut(string key, RavenJObject jsonReplicationDocument, RavenJObject metadata, TransactionInformation transactionInformation);
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
}
[ObsoleteAttribute("Use RavenFS instead.")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractAttachmentDeleteTrigger")]
public class Raven.Bundles.Replication.Triggers.RemoveConflictOnAttachmentDeleteTrigger : AbstractAttachmentDeleteTrigger {
    public virtual void OnDelete(string key);
}
[ObsoleteAttribute("Use RavenFS instead.")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractAttachmentDeleteTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Bundles.Replication.Triggers.VirtualAttachmentDeleteTrigger : AbstractAttachmentDeleteTrigger {
    private ThreadLocal`1<RavenJArray> deletedHistory;
    public virtual void OnDelete(string key);
    public virtual void AfterDelete(string key);
    private void HandleConflictedAttachment(Attachment attachment);
    private void HandleAttachment(Attachment document);
    private bool HasConflict(Attachment attachment);
    public virtual void Dispose();
}
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractDeleteTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Bundles.Replication.Triggers.VirtualDeleteAndRemoveConflictsTrigger : AbstractDeleteTrigger {
    private ThreadLocal`1<RavenJArray> deletedHistory;
    public virtual void OnDelete(string key, TransactionInformation transactionInformation);
    public virtual void AfterDelete(string key, TransactionInformation transactionInformation, RavenJObject metaJObject);
    private void HandleConflictedDocument(JsonDocument document, TransactionInformation transactionInformation);
    private void HandleDocument(JsonDocumentMetadata metadata);
    private bool HasConflict(JsonDocumentMetadata metadata, TransactionInformation transactionInformation, JsonDocument& document);
    public bool IsConflictDocument(JsonDocumentMetadata metadata, TransactionInformation transactionInformation, JsonDocument& document);
    public virtual void Dispose();
}
public class Raven.Bundles.Versioning.Data.VersioningConfiguration : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRevisions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeUnlessExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PurgeOnDelete>k__BackingField;
    public string Id { get; public set; }
    public int MaxRevisions { get; public set; }
    public bool Exclude { get; public set; }
    public bool ExcludeUnlessExplicit { get; public set; }
    public bool PurgeOnDelete { get; public set; }
    protected bool Equals(VersioningConfiguration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public int get_MaxRevisions();
    [CompilerGeneratedAttribute]
public void set_MaxRevisions(int value);
    [CompilerGeneratedAttribute]
public bool get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeUnlessExplicit();
    [CompilerGeneratedAttribute]
public void set_ExcludeUnlessExplicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_PurgeOnDelete();
    [CompilerGeneratedAttribute]
public void set_PurgeOnDelete(bool value);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractReadTrigger")]
public class Raven.Bundles.Versioning.Triggers.HideVersionedDocumentsFromIndexingTrigger : AbstractReadTrigger {
    public virtual ReadVetoResult AllowRead(string key, RavenJObject metadata, ReadOperation operation, TransactionInformation transactionInformation);
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractDeleteTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Bundles.Versioning.Triggers.VersioningDeleteTrigger : AbstractDeleteTrigger {
    private ThreadLocal`1<Dictionary`2<string, RavenJObject>> versionInformer;
    public virtual VetoResult AllowDelete(string key, TransactionInformation transactionInformation);
    public virtual void AfterDelete(string key, TransactionInformation transactionInformation);
    public virtual void Dispose();
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractPutTrigger")]
public class Raven.Bundles.Versioning.Triggers.VersioningPutTrigger : AbstractPutTrigger {
    internal static string CreationOfHistoricalRevisionIsNotAllowed;
    internal static string ModificationOfHistoricalRevisionIsNotAllowed;
    public IEnumerable`1<string> GeneratedMetadataNames { get; }
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
    public virtual void OnPut(string key, RavenJObject jsonReplicationDocument, RavenJObject metadata, TransactionInformation transactionInformation);
    public virtual void AfterPut(string key, RavenJObject document, RavenJObject metadata, Etag etag, TransactionInformation transactionInformation);
    private long GetNextRevisionNumber(string key);
    private RavenJObject GetLatestRevisionsDoc(string key);
    private bool TryGetVersioningConfiguration(string key, RavenJObject metadata, VersioningConfiguration& versioningConfiguration);
    private void RemoveOldRevisions(string key, long revision, VersioningConfiguration versioningConfiguration, TransactionInformation transactionInformation);
    public virtual IEnumerable`1<string> get_GeneratedMetadataNames();
}
[ExtensionAttribute]
internal static class Raven.Bundles.Versioning.VersioningUtil : object {
    public static string RavenDocumentRevision;
    public static string RavenDocumentParentRevision;
    public static string RavenDocumentRevisionStatus;
    [ExtensionAttribute]
public static VersioningConfiguration GetDocumentVersioningConfiguration(DocumentDatabase database, RavenJObject metadata);
    [ExtensionAttribute]
public static bool IsVersioningDisabledForImport(DocumentDatabase database, RavenJObject metadata);
    [ExtensionAttribute]
public static bool IsVersioningActive(DocumentDatabase database, RavenJObject metadata);
    [ExtensionAttribute]
public static bool ChangesToRevisionsAllowed(DocumentDatabase database);
}
public class Raven.Client.Embedded.EmbeddableDocumentStore : object {
    private IDocumentStore _inner;
    private string _connectionStringName;
    [CompilerGeneratedAttribute]
private RavenConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnlistInDistributedTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ResourceManagerId>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentConvention <Conventions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentSessionListeners <Listeners>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseEmbeddedHttpServer>k__BackingField;
    public RavenConfiguration Configuration { get; private set; }
    public string ConnectionStringName { get; public set; }
    public bool EnlistInDistributedTransactions { get; public set; }
    public string ApiKey { get; public set; }
    public string DefaultDatabase { get; public set; }
    public ICredentials Credentials { get; public set; }
    private IDocumentStore Inner { get; }
    public Guid ResourceManagerId { get; public set; }
    public RavenDbServer ServerIfEmbedded { get; }
    public DocumentDatabase SystemDatabase { get; }
    public DocumentDatabase DocumentDatabase { get; }
    public DocumentConvention Conventions { get; public set; }
    public string DataDirectory { get; public set; }
    public string Url { get; public set; }
    public bool WasDisposed { get; }
    public NameValueCollection SharedOperationsHeaders { get; }
    public HttpJsonRequestFactory JsonRequestFactory { get; }
    public bool HasJsonRequestFactory { get; }
    public string Identifier { get; public set; }
    public IAsyncDatabaseCommands AsyncDatabaseCommands { get; }
    public IFilesStore FilesStore { get; }
    public IDatabaseCommands DatabaseCommands { get; }
    public DocumentSessionListeners Listeners { get; private set; }
    public IAsyncReliableSubscriptions AsyncSubscriptions { get; }
    public IReliableSubscriptions Subscriptions { get; }
    public bool UseEmbeddedHttpServer { get; public set; }
    public bool RunInMemory { get; public set; }
    [CompilerGeneratedAttribute]
public RavenConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(RavenConfiguration value);
    public string get_ConnectionStringName();
    public void set_ConnectionStringName(string value);
    protected void HandleConnectionStringOptions();
    [CompilerGeneratedAttribute]
public bool get_EnlistInDistributedTransactions();
    [CompilerGeneratedAttribute]
public void set_EnlistInDistributedTransactions(bool value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultDatabase();
    [CompilerGeneratedAttribute]
public void set_DefaultDatabase(string value);
    [CompilerGeneratedAttribute]
public ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(ICredentials value);
    private static void LegacyDataDirSupport(InMemoryRavenConfiguration configuration);
    private IDocumentStore get_Inner();
    public sealed virtual IDocumentStore Initialize();
    private void AssertValidConfiguration();
    [CompilerGeneratedAttribute]
public Guid get_ResourceManagerId();
    [CompilerGeneratedAttribute]
public void set_ResourceManagerId(Guid value);
    public RavenDbServer get_ServerIfEmbedded();
    public DocumentDatabase get_SystemDatabase();
    public DocumentDatabase get_DocumentDatabase();
    [CompilerGeneratedAttribute]
public sealed virtual DocumentConvention get_Conventions();
    [CompilerGeneratedAttribute]
public void set_Conventions(DocumentConvention value);
    public string get_DataDirectory();
    public void set_DataDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    public sealed virtual void Dispose();
    public sealed virtual void add_AfterDispose(EventHandler value);
    public sealed virtual void remove_AfterDispose(EventHandler value);
    public sealed virtual bool get_WasDisposed();
    public sealed virtual IDatabaseChanges Changes(string database);
    public sealed virtual IDisposable AggressivelyCacheFor(TimeSpan cacheDuration);
    public sealed virtual IDisposable AggressivelyCache();
    public sealed virtual IDisposable DisableAggressiveCaching();
    public sealed virtual IDisposable SetRequestsTimeoutFor(TimeSpan timeout);
    public sealed virtual NameValueCollection get_SharedOperationsHeaders();
    public sealed virtual HttpJsonRequestFactory get_JsonRequestFactory();
    public sealed virtual bool get_HasJsonRequestFactory();
    public sealed virtual string get_Identifier();
    public sealed virtual void set_Identifier(string value);
    public sealed virtual IAsyncDatabaseCommands get_AsyncDatabaseCommands();
    public IFilesStore get_FilesStore();
    public sealed virtual IAsyncDocumentSession OpenAsyncSession();
    public sealed virtual IAsyncDocumentSession OpenAsyncSession(string database);
    public sealed virtual IAsyncDocumentSession OpenAsyncSession(OpenSessionOptions sessionOptions);
    public sealed virtual IDocumentSession OpenSession();
    public sealed virtual IDocumentSession OpenSession(string database);
    public sealed virtual IDocumentSession OpenSession(OpenSessionOptions sessionOptions);
    public sealed virtual IAsyncDocumentSession OpenNagleAsyncSession();
    public sealed virtual IAsyncDocumentSession OpenNagleAsyncSession(string database);
    public sealed virtual IAsyncDocumentSession OpenNagleAsyncSession(OpenSessionOptions sessionOptions);
    public sealed virtual IDocumentSession OpenNagleSession();
    public sealed virtual IDocumentSession OpenNagleSession(string database);
    public sealed virtual IDocumentSession OpenNagleSession(OpenSessionOptions sessionOptions);
    public sealed virtual IDatabaseCommands get_DatabaseCommands();
    public sealed virtual void ExecuteIndex(AbstractIndexCreationTask indexCreationTask);
    public sealed virtual void ExecuteIndexes(List`1<AbstractIndexCreationTask> indexCreationTasks);
    public sealed virtual void SideBySideExecuteIndexes(List`1<AbstractIndexCreationTask> indexCreationTasks, Etag minimumEtagBeforeReplace, Nullable`1<DateTime> replaceTimeUtc);
    public sealed virtual Task SideBySideExecuteIndexesAsync(List`1<AbstractIndexCreationTask> indexCreationTasks, Etag minimumEtagBeforeReplace, Nullable`1<DateTime> replaceTimeUtc);
    public sealed virtual Task ExecuteIndexAsync(AbstractIndexCreationTask indexCreationTask);
    public sealed virtual Task ExecuteIndexesAsync(List`1<AbstractIndexCreationTask> indexCreationTasks);
    public sealed virtual void SideBySideExecuteIndex(AbstractIndexCreationTask indexCreationTask, Etag minimumEtagBeforeReplace, Nullable`1<DateTime> replaceTimeUtc);
    public sealed virtual Task SideBySideExecuteIndexAsync(AbstractIndexCreationTask indexCreationTask, Etag minimumEtagBeforeReplace, Nullable`1<DateTime> replaceTimeUtc);
    public sealed virtual void ExecuteTransformer(AbstractTransformerCreationTask transformerCreationTask);
    public sealed virtual Task ExecuteTransformerAsync(AbstractTransformerCreationTask transformerCreationTask);
    public sealed virtual Etag GetLastWrittenEtag();
    public sealed virtual BulkInsertOperation BulkInsert(string database, BulkInsertOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual DocumentSessionListeners get_Listeners();
    [CompilerGeneratedAttribute]
private void set_Listeners(DocumentSessionListeners value);
    public sealed virtual IAsyncReliableSubscriptions get_AsyncSubscriptions();
    public sealed virtual IReliableSubscriptions get_Subscriptions();
    public sealed virtual void SetListeners(DocumentSessionListeners listeners);
    [CompilerGeneratedAttribute]
public bool get_UseEmbeddedHttpServer();
    [CompilerGeneratedAttribute]
public void set_UseEmbeddedHttpServer(bool value);
    public bool get_RunInMemory();
    public void set_RunInMemory(bool value);
    public IDocumentStore RegisterListener(IDocumentStoreListener listener);
    public IDocumentStore RegisterListener(IDocumentDeleteListener listener);
    public IDocumentStore RegisterListener(IDocumentConversionListener listener);
    public IDocumentStore RegisterListener(IDocumentQueryListener listener);
    public IDocumentStore RegisterListener(IDocumentConflictListener listener);
    public sealed virtual void InitializeProfiling();
    public sealed virtual ProfilingInformation GetProfilingInformationFor(Guid id);
}
public abstract class Raven.Database.Actions.ActionsBase : object {
    protected static HashSet`1<string> HeadersToIgnoreServer;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private ILog <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private IUuidGenerator <UuidGenerator>k__BackingField;
    protected DocumentDatabase Database { get; private set; }
    protected ILog Log { get; private set; }
    [CLSCompliantAttribute("False")]
protected ITransactionalStorage TransactionalStorage { get; }
    protected WorkContext WorkContext { get; }
    protected IndexDefinitionStorage IndexDefinitionStorage { get; }
    protected IUuidGenerator UuidGenerator { get; private set; }
    protected ActionsBase(DocumentDatabase database, IUuidGenerator uuidGenerator, ILog log);
    private static ActionsBase();
    [CompilerGeneratedAttribute]
protected DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
private void set_Database(DocumentDatabase value);
    [CompilerGeneratedAttribute]
protected ILog get_Log();
    [CompilerGeneratedAttribute]
private void set_Log(ILog value);
    protected ITransactionalStorage get_TransactionalStorage();
    protected WorkContext get_WorkContext();
    protected IndexDefinitionStorage get_IndexDefinitionStorage();
    [CompilerGeneratedAttribute]
protected IUuidGenerator get_UuidGenerator();
    [CompilerGeneratedAttribute]
private void set_UuidGenerator(IUuidGenerator value);
}
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Database.Actions.AttachmentActions : ActionsBase {
    private Dictionary`2<string, AttachmentLocker> putAttachmentSerialLock;
    public AttachmentActions(DocumentDatabase database, IUuidGenerator uuidGenerator, ILog log);
    public IEnumerable`1<AttachmentInformation> GetStaticsStartingWith(string idPrefix, int start, int pageSize);
    public AttachmentInformation[] GetAttachments(int start, int pageSize, Etag etag, string startsWith, long maxSize);
    public Attachment GetStatic(string name);
    public Etag PutStatic(string name, Etag etag, Stream data, RavenJObject metadata);
    public void DeleteStatic(string name, Etag etag);
    private void AssertAttachmentPutOperationNotVetoed(string key, RavenJObject metadata, Stream data);
    private Attachment ProcessAttachmentReadVetoes(string name, Attachment attachment);
    private void ExecuteAttachmentReadTriggers(string name, Attachment attachment);
    private AttachmentInformation ProcessAttachmentReadVetoes(AttachmentInformation attachment);
    private void ExecuteAttachmentReadTriggers(AttachmentInformation information);
    private void AssertAttachmentDeleteOperationNotVetoed(string key);
}
public class Raven.Database.Actions.DocumentActions : ActionsBase {
    public DocumentActions(DocumentDatabase database, IUuidGenerator uuidGenerator, ILog log);
    public long GetNextIdentityValueWithoutOverwritingOnExistingDocuments(string key, IStorageActionsAccessor actions);
    public long GetNextIdentityValueWithoutOverwritingOnExistingDocuments(string key, IStorageActionsAccessor actions, Int32& tries);
    private void AssertPutOperationNotVetoed(string key, RavenJObject metadata, RavenJObject document, TransactionInformation transactionInformation);
    public RavenJArray GetDocumentsWithIdStartingWith(string idPrefix, string matches, string exclude, int start, int pageSize, CancellationToken token, Int32& nextStart, string transformer, Dictionary`2<string, RavenJToken> transformerParameters, string skipAfter);
    public void GetDocumentsWithIdStartingWith(string idPrefix, string matches, string exclude, int start, int pageSize, CancellationToken token, Int32& nextStart, Action`1<JsonDocument> addDoc, string transformer, Dictionary`2<string, RavenJToken> transformerParameters, string skipAfter);
    private JsonDocument TransformDocumentIfNeeded(JsonDocument document, AbstractTransformer storedTransformer, DocumentRetriever documentRetriever);
    private void RemoveMetadataReservedProperties(RavenJObject metadata, InvokeSource source);
    private void RemoveReservedProperties(RavenJObject document);
    private void AssertDeleteOperationNotVetoed(string key, TransactionInformation transactionInformation);
    public int BulkInsert(BulkInsertOptions options, IEnumerable`1<IEnumerable`1<JsonDocument>> docBatches, Guid operationId, CancellationToken token, CancellationTimeout timeout);
    private bool IsTheSameDocument(JsonDocument doc, JsonDocument existingDoc);
    public RavenJArray GetDocumentsAsJson(int start, int pageSize, Etag etag, CancellationToken token, Nullable`1<long> maxSize, Nullable`1<TimeSpan> timeout);
    public Etag GetDocuments(int start, int pageSize, Etag etag, CancellationToken token, Func`2<JsonDocument, bool> addDocument, string transformer, Dictionary`2<string, RavenJToken> transformerParameters, Nullable`1<long> maxSize, Nullable`1<TimeSpan> timeout, HashSet`1<string> collections);
    public Etag GetDocumentsWithIdStartingWith(string idPrefix, int pageSize, Etag etag, CancellationToken token, Func`2<JsonDocument, bool> addDocument, HashSet`1<string> collections);
    public JsonDocument Get(string key, TransactionInformation transactionInformation);
    public JsonDocumentMetadata GetDocumentMetadata(string key, TransactionInformation transactionInformation);
    public Etag GetLastEtagForCollection(string collectionName);
    public JsonDocument GetWithTransformer(string key, string transformer, TransactionInformation transactionInformation, Dictionary`2<string, RavenJToken> transformerParameters, HashSet`1& itemsToInclude);
    public PutResult Put(string key, Etag etag, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation, IEnumerable`1<string> participatingIds, InvokeSource source);
    public bool Delete(string key, Etag etag, TransactionInformation transactionInformation, IEnumerable`1<string> participatingIds);
    public bool Delete(string key, Etag etag, TransactionInformation transactionInformation, RavenJObject& metadata, IEnumerable`1<string> participatingIds);
    internal void DeleteDocumentFromIndexesForCollection(string key, string collection, IStorageActionsAccessor actions);
    [CompilerGeneratedAttribute]
private bool <RemoveReservedProperties>b__8_0(string propertyName);
}
public class Raven.Database.Actions.IndexActions : ActionsBase {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isPrecomputedBatchForNewIndexIsRunning;
    private object precomputedLock;
    internal IndexDefinition[] Definitions { get; }
    public IndexActions(DocumentDatabase database, IUuidGenerator uuidGenerator, ILog log);
    internal IndexDefinition[] get_Definitions();
    public String[] GetIndexFields(string index);
    public Etag GetIndexEtag(string indexName, Etag previousEtag, string resultTransformer);
    internal int CheckReferenceBecauseOfDocumentUpdate(string key, IStorageActionsAccessor actions, IEnumerable`1<string> participatingIds);
    private static void IsIndexNameValid(string name);
    public bool IndexHasChanged(string name, IndexDefinition definition);
    public string PutIndex(string name, IndexDefinition definition, bool isReplication);
    private string PutIndexInternal(string name, IndexDefinition definition, bool disableIndexBeforePut, bool isUpdateBySideSide, Nullable`1<IndexCreationOptions> creationOptions, bool isReplication);
    private bool CanUpdateIndex(string name, IndexDefinition definition, bool isUpdateBySideSide, IndexDefinition existingIndex);
    private int GetOriginalIndexVersion(string name);
    public String[] PutIndexes(IndexToAdd[] indexesToAdd, bool isReplication);
    public List`1<IndexInfo> PutSideBySideIndexes(SideBySideIndexes sideBySideIndexes, bool isReplication);
    private void SetIndexesPriority(Int32[] indexesIds, List`1<IndexingPriority> prioritiesList);
    private void CreateIndexReplacementDocuments(List`1<IndexInfo> createdIndexes);
    private Nullable`1<IndexLockMode> GetCurrentLockMode(string indexName);
    private static void AssertAnalyzersValid(IndexDefinition indexDefinition);
    internal void PutNewIndexIntoStorage(string name, IndexDefinition definition, bool disableIndex);
    private Action TryCreateTaskForApplyingPrecomputedBatchForNewIndex(Index index, IndexDefinition definition);
    private void ApplyPrecomputedBatchForNewIndex(Index index, AbstractViewGenerator generator, int pageSize, CancellationTokenSource cts);
    private void InvokeSuggestionIndexing(string name, IndexDefinition definition, Index index);
    private IndexCreationOptions FindIndexCreationOptions(IndexDefinition definition, String& name);
    public RavenJArray GetIndexNames(int start, int pageSize);
    public RavenJArray GetIndexNamesWithType(int start, int pageSize);
    public RavenJArray GetIndexes(int start, int pageSize);
    public IndexDefinition GetIndexDefinition(string index);
    public void ResetIndex(string index);
    public bool DeleteIndex(string name, Nullable`1<int> deletedIndexVersion);
    internal void DeleteIndex(IndexDefinition instance, bool removeByNameMapping, bool clearErrors, bool removeIndexReplaceDocument, bool isSideBySideReplacement, Nullable`1<int> deletedIndexVersion);
    private void PrepareIndexDeletion(int indexId);
    public void RenameIndex(IndexDefinition instance, string newIndexName);
    [CompilerGeneratedAttribute]
private int <PutIndexes>b__14_0(string x);
    [CompilerGeneratedAttribute]
private int <PutSideBySideIndexes>b__15_0(IndexInfo x);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType2`2<string, IndexDefinition> <GetIndexNamesWithType>b__27_0(string indexName);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType2`2<string, IndexDefinition> <GetIndexes>b__28_0(string indexName);
}
public class Raven.Database.Actions.LastCollectionEtags : object {
    private static ILog Log;
    private WorkContext context;
    private ConcurrentDictionary`2<string, Entry> lastCollectionEtags;
    public LastCollectionEtags(WorkContext context);
    private static LastCollectionEtags();
    public void InitializeBasedOnIndexingResults();
    public bool HasEtagGreaterThan(List`1<string> collectionsToCheck, Etag etagToCheck);
    public void Update(string collectionName, Etag etag);
    public void Update(string collectionName);
    public Etag GetLastEtagForCollection(string collectionName);
    public List`1<string> GetLastChangedCollections(DateTime date);
}
public class Raven.Database.Actions.LastMapCompletedDatesPerCollection : object {
    private ConcurrentDictionary`2<string, DateTime> lastIndexingTime;
    public LastMapCompletedDatesPerCollection(DocumentDatabase documentDatabase);
    public void Update(HashSet`1<string> collections);
    public List`1<string> GetLastChangedCollections(DateTime date);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(DocumentDatabase database, IndexChangeNotification notification);
}
public class Raven.Database.Actions.MaintenanceActions : ActionsBase {
    private ConcurrentQueue`1<DeleteIndexTask> pendingDeletions;
    private InterlockedLock interlockedLock;
    public MaintenanceActions(DocumentDatabase database, IUuidGenerator uuidGenerator, ILog log);
    internal static string FindDatabaseDocument(string rootBackupPath);
    public static void Restore(RavenConfiguration configuration, DatabaseRestoreRequest restoreRequest, Action`1<string> output, InMemoryRavenConfiguration globalConfiguration);
    public Task StartBackup(string backupDestinationDirectory, bool incrementalBackup, DatabaseDocument databaseDocument, ResourceBackupState state, CancellationToken token);
    public void RemoveAllBefore(string listName, Etag etag, Nullable`1<TimeSpan> timeout);
    public void PurgeOutdatedTombstones();
    public void DeleteRemovedIndexes(Dictionary`2<int, IndexFailDetails> reason);
    public void StartDeletingIndexDataAsync(int indexId, string indexName);
    private void TryCreateIndexesDeletionTask();
    private bool DeleteIndex(DeleteIndexTask pendingDeletion, Action`1<string> markProgress);
}
public class Raven.Database.Actions.NotificationActions : ActionsBase {
    [CompilerGeneratedAttribute]
private Action`3<DocumentDatabase, DocumentChangeNotification, RavenJObject> OnDocumentChange;
    [CompilerGeneratedAttribute]
private Action`2<DocumentDatabase, IndexChangeNotification> OnIndexChange;
    [CompilerGeneratedAttribute]
private Action`2<DocumentDatabase, TransformerChangeNotification> OnTransformerChange;
    [CompilerGeneratedAttribute]
private Action`3<DocumentDatabase, AttachmentChangeNotification, RavenJObject> OnAttachmentChange;
    [CompilerGeneratedAttribute]
private Action`2<DocumentDatabase, BulkInsertChangeNotification> OnBulkInsertChange;
    public NotificationActions(DocumentDatabase database, IUuidGenerator uuidGenerator, ILog log);
    [CompilerGeneratedAttribute]
public void add_OnDocumentChange(Action`3<DocumentDatabase, DocumentChangeNotification, RavenJObject> value);
    [CompilerGeneratedAttribute]
public void remove_OnDocumentChange(Action`3<DocumentDatabase, DocumentChangeNotification, RavenJObject> value);
    [CompilerGeneratedAttribute]
public void add_OnIndexChange(Action`2<DocumentDatabase, IndexChangeNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnIndexChange(Action`2<DocumentDatabase, IndexChangeNotification> value);
    [CompilerGeneratedAttribute]
public void add_OnTransformerChange(Action`2<DocumentDatabase, TransformerChangeNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnTransformerChange(Action`2<DocumentDatabase, TransformerChangeNotification> value);
    [CompilerGeneratedAttribute]
public void add_OnAttachmentChange(Action`3<DocumentDatabase, AttachmentChangeNotification, RavenJObject> value);
    [CompilerGeneratedAttribute]
public void remove_OnAttachmentChange(Action`3<DocumentDatabase, AttachmentChangeNotification, RavenJObject> value);
    [CompilerGeneratedAttribute]
public void add_OnBulkInsertChange(Action`2<DocumentDatabase, BulkInsertChangeNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnBulkInsertChange(Action`2<DocumentDatabase, BulkInsertChangeNotification> value);
    public void RaiseNotifications(DocumentChangeNotification obj, RavenJObject metadata);
    public void RaiseNotifications(AttachmentChangeNotification obj, RavenJObject metadata);
    public void RaiseNotifications(IndexChangeNotification obj);
    public void RaiseNotifications(TransformerChangeNotification obj);
    public void RaiseNotifications(ReplicationConflictNotification obj);
    public void RaiseNotifications(BulkInsertChangeNotification obj);
    public void RaiseNotifications(DataSubscriptionChangeNotification obj);
}
public class Raven.Database.Actions.OneTimeAcknowledgement : object {
    public string ConnectionId;
    public DateTime ValidUntil;
    public ManualResetEventSlim AckDelivered;
    public bool ValidFor(string connection);
}
public class Raven.Database.Actions.PatchActions : ActionsBase {
    public PatchActions(DocumentDatabase database, IUuidGenerator uuidGenerator, ILog log);
    public PatchResultData ApplyPatch(string docId, Etag etag, PatchRequest[] patchDoc, TransactionInformation transactionInformation, bool debugMode, IEnumerable`1<string> participatingIds);
    public PatchResultData ApplyPatch(string docId, Etag etag, PatchRequest[] patchExistingDoc, PatchRequest[] patchDefaultDoc, RavenJObject defaultMetadata, TransactionInformation transactionInformation, bool debugMode, bool skipPatchIfEtagMismatch, IEnumerable`1<string> participatingIds);
    private PatchResultData ApplyPatchInternal(string docId, Etag etag, TransactionInformation transactionInformation, Func`2<JsonDocument, RavenJObject> patcher, Func`1<RavenJObject> patcherIfMissing, Func`1<IList`1<JsonDocument>> getDocsCreatedInPatch, Func`1<RavenJObject> getDebugActions, bool debugMode, bool skipPatchIfEtagMismatch, IEnumerable`1<string> participatingIds);
    private static bool IsNotModified(RavenJToken patchedDocClone, RavenJToken existingDocClone);
    public Tuple`2<PatchResultData, List`1<string>> ApplyPatch(string docId, Etag etag, ScriptedPatchRequest patch, TransactionInformation transactionInformation, bool debugMode);
    public Tuple`2<PatchResultData, List`1<string>> ApplyPatch(string docId, Etag etag, ScriptedPatchRequest patchExisting, ScriptedPatchRequest patchDefault, RavenJObject defaultMetadata, TransactionInformation transactionInformation, bool debugMode, IEnumerable`1<string> participatingIds);
}
public class Raven.Database.Actions.QueryActions : ActionsBase {
    public QueryActions(DocumentDatabase database, IUuidGenerator uuidGenerator, ILog log);
    public HashSet`1<string> QueryDocumentIds(string index, IndexQuery query, CancellationTokenSource tokenSource, Boolean& stale);
    public QueryResultWithIncludes Query(string index, IndexQuery query, CancellationToken externalCancellationToken);
    private void RemoveFromCurrentlyRunningQueryList(string index, ExecutingQueryInfo queryStat);
    private ExecutingQueryInfo AddToCurrentlyRunningQueryList(string index, IndexQuery query, CancellationTokenSource externalTokenSource);
    private IEnumerable`1<RavenJObject> GetQueryResults(IndexQuery query, AbstractViewGenerator viewGenerator, DocumentRetriever docRetriever, IEnumerable`1<JsonDocument> results, List`1<string> transformerErrors, Action`1<double> loadingDocumentsFinish, Action`1<double> transformerFinish, bool showTimings, CancellationToken token);
}
public class Raven.Database.Actions.SubscriptionActions : ActionsBase {
    private ConcurrentDictionary`2<long, SubscriptionConnectionOptions> openSubscriptions;
    private ConcurrentSet`1<long> deletedSubscriptions;
    private ConcurrentDictionary`2<long, PutSerialLock> locks;
    public ConcurrentDictionary`2<long, OneTimeAcknowledgement> allowedOneTimeAcknowledgements;
    private ConcurrentDictionary`2<long, SizeLimitedConcurrentSet`1<string>> forciblyReleasedSubscriptions;
    public SubscriptionActions(DocumentDatabase database, ILog log);
    public long CreateSubscription(SubscriptionCriteria criteria);
    private void TryFigureOutFirstEtagForSubscription(SubscriptionCriteria criteria);
    private IDisposable LockSubscription(long id);
    public void DeleteSubscription(long id);
    private void SaveSubscriptionConfig(long id, SubscriptionConfig config);
    public void OpenSubscription(long id, SubscriptionConnectionOptions options);
    private void ForceReleaseAndOpenForNewClient(long id, SubscriptionConnectionOptions oldOptions, SubscriptionConnectionOptions newOptions, SubscriptionConfig config, bool allowExistingClientToAcknowledge);
    public void ReleaseSubscription(long id, bool forced);
    public void AcknowledgeBatchProcessed(long id, Etag lastEtag);
    public void AssertOpenSubscriptionConnection(long id, string connection, bool ackRequest);
    public SubscriptionBatchOptions GetBatchOptions(long id);
    public SubscriptionConfig GetSubscriptionConfig(long id);
    public void UpdateBatchSentTime(long id);
    public void UpdateClientActivityDate(long id);
    public List`1<SubscriptionConfig> GetSubscriptions(int start, int take);
    public List`1<object> GetDebugInfo();
    public void SetAcknowledgeEtag(long id, Etag lastEtag);
    public Etag GetAcknowledgeEtag(long id);
}
public class Raven.Database.Actions.TaskActions : ActionsBase {
    private long pendingTaskCounter;
    private object clearTasksLock;
    private ConcurrentDictionary`2<long, PendingTask> pendingTasks;
    public TaskActions(DocumentDatabase database, IUuidGenerator uuidGenerator, ILog log);
    internal void ClearCompletedPendingTasks();
    public List`1<PendingTaskDescriptionAndStatus> GetAll();
    public void AddTask(Task task, IOperationState state, PendingTaskDescription description, Int64& id, CancellationTokenSource tokenSource);
    public void AddTask(Task task, IOperationState state, PendingTaskDescription description, long id, CancellationTokenSource tokenSource, bool skipStatusCheck);
    public long GetNextTaskId();
    public void RemoveTask(long taskId);
    public IOperationState KillTask(long id);
    public IOperationState GetTaskState(long id);
    public void Dispose(ExceptionAggregator exceptionAggregator);
}
public class Raven.Database.Actions.TransformerActions : ActionsBase {
    private int temporaryTransfomerIndex;
    internal String[] Names { get; }
    internal TransformerDefinition[] Definitions { get; }
    public TransformerActions(DocumentDatabase database, IUuidGenerator uuidGenerator, ILog log);
    internal String[] get_Names();
    internal TransformerDefinition[] get_Definitions();
    public RavenJArray GetTransformerNames(int start, int pageSize);
    public RavenJArray GetTransformers(int start, int pageSize);
    public TransformerDefinition GetTransformerDefinition(string name);
    public bool DeleteTransform(string name, Nullable`1<int> deletedTransformerVersion);
    public string PutTransform(string name, TransformerDefinition definition, bool isReplication);
    private int GetDeletedTransformerVersion(string listName, string transformerName);
    public int GetNextTemporaryTransformerIndex();
    [CompilerGeneratedAttribute]
private RavenJObject <GetTransformers>b__7_0(string indexName);
}
public class Raven.Database.Backup.DirectoryBackup : object {
    public static int MoveFileDelayUntilReboot;
    [CompilerGeneratedAttribute]
private Action`3<string, Exception, BackupMessageSeverity> Notify;
    private Dictionary`2<string, long> fileToSize;
    private static ILog logger;
    private string source;
    private string destination;
    private string tempPath;
    private bool allowOverwrite;
    public DirectoryBackup(string source, string destination, string tempPath, bool allowOverwrite);
    private static DirectoryBackup();
    public static bool CreateHardLink(string lpFileName, string lpExistingFileName, IntPtr lpSecurityAttributes);
    public static bool MoveFileEx(string lpExistingFileName, string lpNewFileName, int dwFlags);
    [CompilerGeneratedAttribute]
public void add_Notify(Action`3<string, Exception, BackupMessageSeverity> value);
    [CompilerGeneratedAttribute]
public void remove_Notify(Action`3<string, Exception, BackupMessageSeverity> value);
    private static void EnsureDirectoryExists(string dir);
    public void Execute(ProgressNotifier progressNotifier, CancellationToken token);
    private void FileCopy(string src, string dest, long size, ProgressNotifier notifier, CancellationToken token);
    public long Prepare();
}
public class Raven.Database.Backup.ProgressNotifier : object {
    [CompilerGeneratedAttribute]
private long <TotalBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalBytesWritten>k__BackingField;
    private int lastPercentWritten;
    public long TotalBytes { get; public set; }
    public long TotalBytesWritten { get; private set; }
    [CompilerGeneratedAttribute]
public long get_TotalBytes();
    [CompilerGeneratedAttribute]
public void set_TotalBytes(long value);
    [CompilerGeneratedAttribute]
public long get_TotalBytesWritten();
    [CompilerGeneratedAttribute]
private void set_TotalBytesWritten(long value);
    public void UpdateProgress(long bytesWritten, Action`3<string, Exception, BackupMessageSeverity> notifier);
}
public class Raven.Database.Backup.RemoveBackupDocumentStartupTask : object {
    public sealed virtual void Execute(DocumentDatabase database);
}
public class Raven.Database.Bundles.Encryption.Codec : object {
    private static ThreadLocal`1<RNGCryptoServiceProvider> LocalRNG;
    private EncryptionSettings encryptionSettings;
    private Tuple`2<Byte[], Byte[]> encryptionStartingKeyAndIV;
    private Nullable`1<int> encryptionKeySize;
    private Nullable`1<int> encryptionIVSize;
    private int usingSha1;
    public bool UsingSha1 { get; private set; }
    public Codec(EncryptionSettings settings);
    private static Codec();
    public bool get_UsingSha1();
    private void set_UsingSha1(bool value);
    public Stream Encode(string key, Stream dataStream);
    public Stream Decode(string key, Stream dataStream);
    public EncodedBlock EncodeBlock(string key, Byte[] data);
    public Byte[] DecodeBlock(string key, EncodedBlock block);
    private int GetIVLength();
    private SymmetricAlgorithm GetCryptoProvider(Byte[] iv);
    private SymmetricAlgorithm GetCryptoProviderWithRandomIV(Byte[]& iv);
    private Tuple`2<Byte[], Byte[]> GetStartingKeyAndIVForEncryption(SymmetricAlgorithm algorithm);
    private Byte[] GetSaltFromEncryptionKey(Byte[] key);
    public void UseSha1();
}
[ExtensionAttribute]
internal static class Raven.Database.Bundles.Encryption.CodecSaltExtensions : object {
    [ExtensionAttribute]
public static Stream WriteSalt(Stream stream, string key);
    [ExtensionAttribute]
public static Stream ReadSalt(Stream stream, string key);
}
internal static class Raven.Database.Bundles.Encryption.Settings.EncryptionSettingsManager : object {
    private static string EncryptionSettingsKeyInExtensionsState;
    private static ILog log;
    private static EncryptionSettingsManager();
    public static EncryptionSettings GetEncryptionSettingsForResource(IResourceStore resource);
    private static Byte[] GetKeyFromBase64(string base64, int defaultEncryptionKeySize);
    private static Type GetTypeFromName(string typeName);
    public static void VerifyEncryptionKey(RavenFileSystem fileSystem, EncryptionSettings settings);
    public static void VerifyEncryptionKey(DocumentDatabase database, EncryptionSettings settings);
    private static bool EncryptedDocumentsExist(DocumentDatabase database);
    private static bool EncryptedFileExist(RavenFileSystem fileSystem);
    private static bool GetEncryptIndexesFromString(string value, bool defaultValue);
}
[InheritedExportAttribute("Raven.Database.Plugins.IStartupTask")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.Bundles.Expiration.ExpiredDocumentsCleaner : object {
    public static string RavenDocumentsByExpirationDate;
    private ILog logger;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    private object locker;
    private Timer timer;
    public DocumentDatabase Database { get; public set; }
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    public sealed virtual void Execute(DocumentDatabase database);
    public bool TimerCallback();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Execute>b__6_0(object state);
}
internal class Raven.Database.Bundles.MoreLikeThis.RavenMoreLikeThis : MoreLikeThis {
    private IndexReader _ir;
    public RavenMoreLikeThis(IndexReader ir);
    protected virtual PriorityQueue`1<Object[]> RetrieveTerms(int docNum);
}
public class Raven.Database.Bundles.PeriodicExports.Controllers.AdminPeriodicExportController : AdminBundlesApiController {
    public string BundleName { get; }
    public virtual string get_BundleName();
    [RavenRouteAttribute("databases/{databaseName}/admin/periodicExport/purge-tombstones")]
[RavenRouteAttribute("admin/periodicExport/purge-tombstones")]
[HttpPostAttribute]
public HttpResponseMessage PurgeTombstones();
}
[InheritedExportAttribute("Raven.Database.Plugins.IStartupTask")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.Bundles.PeriodicExports.PeriodicExportTask : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <FullBackupInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <IncrementalInterval>k__BackingField;
    private Timer incrementalBackupTimer;
    private Timer fullBackupTimer;
    private TimeSpan fullBackupIntermediateInterval;
    private TimeSpan incrementalIntermediateInterval;
    private ILog logger;
    private long maxTimerTimeoutInMilliseconds;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) currentTask;
    private string awsAccessKey;
    private string awsSecretKey;
    private string azureStorageAccount;
    private string azureStorageKey;
    private PeriodicExportStatus modreq(System.Runtime.CompilerServices.IsVolatile) exportStatus;
    private PeriodicExportSetup modreq(System.Runtime.CompilerServices.IsVolatile) exportConfigs;
    private int backupLimit;
    public DocumentDatabase Database { get; public set; }
    public TimeSpan FullBackupInterval { get; private set; }
    public TimeSpan IncrementalInterval { get; private set; }
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    [CompilerGeneratedAttribute]
public TimeSpan get_FullBackupInterval();
    [CompilerGeneratedAttribute]
private void set_FullBackupInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_IncrementalInterval();
    [CompilerGeneratedAttribute]
private void set_IncrementalInterval(TimeSpan value);
    public sealed virtual void Execute(DocumentDatabase database);
    private void ResetSetupValuesFromDocument();
    private void ReadSetupValuesFromDocument();
    private PeriodicExportStatus GetExportStatus();
    private void LongPeriodTimerCallback(bool fullBackup);
    private Timer RescheduleLongTimer(bool isFullbackup);
    private bool IsValidTimespanForTimer(TimeSpan timespan);
    private void ReleaseTimerIfNeeded(Timer& timer);
    private void TimerCallback(bool fullBackup);
    private static string GetLocalBackupPath(bool fullBackup, string folderName, string localFolderName, string lastFullLocalBackupFolder);
    [AsyncStateMachineAttribute("Raven.Database.Bundles.PeriodicExports.PeriodicExportTask/<UploadToServer>d__36")]
private Task UploadToServer(string backupPath, PeriodicExportSetup localExportConfigs, bool isFullBackup);
    private void UploadToS3(string backupPath, PeriodicExportSetup localExportConfigs, bool isFullBackup);
    private void UploadToGlacier(string backupPath, PeriodicExportSetup localExportConfigs, bool isFullBackup);
    [AsyncStateMachineAttribute("Raven.Database.Bundles.PeriodicExports.PeriodicExportTask/<UploadToAzure>d__39")]
private Task UploadToAzure(string backupPath, PeriodicExportSetup localExportConfigs, bool isFullBackup);
    private static string CombinePathAndKey(string path, string fileName);
    private string GetArchiveDescription(bool isFullBackup);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Execute>b__26_0(DocumentDatabase sender, DocumentChangeNotification notification, RavenJObject metadata);
    [CompilerGeneratedAttribute]
private void <ReadSetupValuesFromDocument>b__28_2(object state);
    [CompilerGeneratedAttribute]
private void <ReadSetupValuesFromDocument>b__28_0(object state);
    [CompilerGeneratedAttribute]
private void <ReadSetupValuesFromDocument>b__28_3(object state);
    [CompilerGeneratedAttribute]
private void <ReadSetupValuesFromDocument>b__28_1(object state);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractPutTrigger")]
public class Raven.Database.Bundles.PeriodicExports.Triggers.AncestryPutTrigger : AbstractPutTrigger {
    public virtual void OnPut(string key, RavenJObject jsonReplicationDocument, RavenJObject metadata, TransactionInformation transactionInformation);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractAttachmentPutTrigger")]
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Database.Bundles.PeriodicExports.Triggers.AttachmentAncestryPutTrigger : AbstractAttachmentPutTrigger {
    public virtual void OnPut(string key, Stream data, RavenJObject metadata);
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractAttachmentDeleteTrigger")]
[ObsoleteAttribute("Use RavenFS instead.")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.Bundles.PeriodicExports.Triggers.VirtualAttachmentDeleteTrigger : AbstractAttachmentDeleteTrigger {
    public virtual void AfterDelete(string key);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractDeleteTrigger")]
public class Raven.Database.Bundles.PeriodicExports.Triggers.VirtualDeleteTrigger : AbstractDeleteTrigger {
    public virtual void AfterDelete(string key, TransactionInformation transactionInformation);
}
public class Raven.Database.Bundles.Replication.Controllers.AdminReplicationController : AdminBundlesApiController {
    public string BundleName { get; }
    public virtual string get_BundleName();
    [HttpPostAttribute]
[RavenRouteAttribute("admin/replication/purge-tombstones")]
[RavenRouteAttribute("databases/{databaseName}/admin/replication/purge-tombstones")]
public HttpResponseMessage PurgeTombstones();
    [AsyncStateMachineAttribute("Raven.Database.Bundles.Replication.Controllers.AdminReplicationController/<ReplicationInfo>d__3")]
[HttpPostAttribute]
[RavenRouteAttribute("admin/replicationInfo")]
[RavenRouteAttribute("databases/{databaseName}/admin/replicationInfo")]
public Task`1<HttpResponseMessage> ReplicationInfo();
    [RavenRouteAttribute("databases/{databaseName}/admin/replication/topology/view")]
[HttpPostAttribute]
[RavenRouteAttribute("admin/replication/topology/view")]
public Task`1<HttpResponseMessage> ReplicationTopology();
    [RavenRouteAttribute("admin/replication/docs-left-to-replicate")]
[HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/admin/replication/docs-left-to-replicate")]
[AsyncStateMachineAttribute("Raven.Database.Bundles.Replication.Controllers.AdminReplicationController/<DocumentsLeftToReplicate>d__5")]
public Task`1<HttpResponseMessage> DocumentsLeftToReplicate();
    [AsyncStateMachineAttribute("Raven.Database.Bundles.Replication.Controllers.AdminReplicationController/<ReplicatedDocumentsByEntityNames>d__6")]
[RavenRouteAttribute("databases/{databaseName}/admin/replication/replicated-docs-by-entity-names")]
[RavenRouteAttribute("admin/replication/replicated-docs-by-entity-names")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> ReplicatedDocumentsByEntityNames();
    [RavenRouteAttribute("databases/{databaseName}/admin/replication/export-docs-left-to-replicate")]
[RavenRouteAttribute("admin/replication/export-docs-left-to-replicate")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> ExportDocumentsLeftToReplicate(ExportData optionsJson);
    private ReplicationInfoStatus[] CheckDestinations(ReplicationDocument replicationDocument);
    private void FillStatus(ReplicationInfoStatus replicationInfoStatus, WebException e);
    private static string GetErrorStringFromException(WebException webException, HttpWebResponse response);
}
public class Raven.Database.Bundles.Replication.Controllers.ReplicationController : BundlesApiController {
    private static int ConflictBatchSize;
    private static ILog log;
    private ReplicationTask replicationTask;
    public string BundleName { get; }
    public ReplicationTask ReplicationTask { get; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public IEnumerable`1<AbstractAttachmentReplicationConflictResolver> AttachmentReplicationConflictResolvers { get; }
    private static ReplicationController();
    public virtual string get_BundleName();
    public ReplicationTask get_ReplicationTask();
    public IEnumerable`1<AbstractAttachmentReplicationConflictResolver> get_AttachmentReplicationConflictResolvers();
    [RavenRouteAttribute("databases/{databaseName}/replication/explain/{*docId}")]
[RavenRouteAttribute("replication/explain/{*docId}")]
[HttpGetAttribute]
public HttpResponseMessage ExplainGet(string docId);
    [RavenRouteAttribute("replication/topology")]
[RavenRouteAttribute("databases/{databaseName}/replication/topology")]
[HttpGetAttribute]
public HttpResponseMessage TopologyGet();
    [RavenRouteAttribute("replication/forceConflictResolution")]
[HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/replication/forceConflictResolution")]
public HttpResponseMessage ForceConflictResolution();
    private int HandleBatchOfConflicts(List`1<ConflictToResolve> conflicts, ConflictResolveStatus status);
    private void HandleSingleConflictResolving(IStorageActionsAccessor actions, ConflictToResolve c, ConflictResolveStatus status, Int32& i);
    private void AddSingleConflict(RavenJObject conflict, List`1<ConflictToResolve> conflicts);
    [RavenRouteAttribute("databases/{databaseName}/replication/replicateDocs")]
[RavenRouteAttribute("replication/replicateDocs")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Bundles.Replication.Controllers.ReplicationController/<DocReplicatePost>d__15")]
public Task`1<HttpResponseMessage> DocReplicatePost();
    private bool IsFromDifferentCluster(string topologyId);
    private void SaveReplicationSource(string src, string lastEtag, int batchSize, DateTime lastModified, string collections);
    [HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/replication/replicateAttachments")]
[ObsoleteAttribute("Use RavenFS instead.")]
[AsyncStateMachineAttribute("Raven.Database.Bundles.Replication.Controllers.ReplicationController/<AttachmentReplicatePost>d__18")]
[RavenRouteAttribute("replication/replicateAttachments")]
public Task`1<HttpResponseMessage> AttachmentReplicatePost();
    [HttpGetAttribute]
[HttpPostAttribute]
[RavenRouteAttribute("replication/info")]
[RavenRouteAttribute("databases/{databaseName}/replication/info")]
public HttpResponseMessage ReplicationInfoGet();
    [AsyncStateMachineAttribute("Raven.Database.Bundles.Replication.Controllers.ReplicationController/<ReplicationWriteAssurance>d__20")]
[HttpGetAttribute]
[RavenRouteAttribute("replication/writeAssurance")]
[RavenRouteAttribute("databases/{databaseName}/replication/writeAssurance")]
public Task`1<HttpResponseMessage> ReplicationWriteAssurance(string etag, int replicas, bool majority, TimeSpan timeout);
    [RavenRouteAttribute("databases/{databaseName}/replication/lastEtag")]
[RavenRouteAttribute("replication/lastEtag")]
[HttpGetAttribute]
public HttpResponseMessage ReplicationLastEtagGet();
    [RavenRouteAttribute("databases/{databaseName}/replication/lastEtag")]
[RavenRouteAttribute("replication/lastEtag")]
[HttpPutAttribute]
public HttpResponseMessage ReplicationLastEtagPut();
    [HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/replication/heartbeat")]
[RavenRouteAttribute("replication/heartbeat")]
public HttpResponseMessage HeartbeatPost();
    [RavenRouteAttribute("replication/side-by-side/")]
[RavenRouteAttribute("databases/{databaseName}/replication/side-by-side/")]
[HttpPostAttribute]
public HttpResponseMessage ReplicateSideBySideIndex(SideBySideReplicationInfo sideBySideReplicationInfo);
    private void PutSideBySideIndexDocument(SideBySideReplicationInfo sideBySideReplicationInfo);
    private HttpResponseMessage InternalPutIndex(IndexDefinition indexToUpdate, string message);
    private HttpResponseMessage InternalPutIndex(string indexName, IndexDefinition indexToUpdate, string message);
    [HttpPostAttribute]
[RavenRouteAttribute("replication/replicate-indexes")]
[RavenRouteAttribute("databases/{databaseName}/replication/replicate-indexes")]
public HttpResponseMessage IndexReplicate(ReplicationDestination replicationDestination);
    [HttpPostAttribute]
[RavenRouteAttribute("replication/replicate-transformers")]
[RavenRouteAttribute("databases/{databaseName}/replication/replicate-transformers")]
public HttpResponseMessage TransformersReplicate(ReplicationDestination replicationDestination);
    private HttpResponseMessage GetValuesForLastEtag(String& src, String& dbid, String& collections);
    private void ReplicateDocument(IStorageActionsAccessor actions, string id, RavenJObject metadata, RavenJObject document, string src, IEnumerable`1<AbstractDocumentReplicationConflictResolver> conflictResolvers);
    [ObsoleteAttribute("Use RavenFS instead.")]
private void ReplicateAttachment(IStorageActionsAccessor actions, string id, RavenJObject metadata, Byte[] data, string src, IEnumerable`1<AbstractAttachmentReplicationConflictResolver> conflictResolvers);
}
public class Raven.Database.Bundles.Replication.Controllers.ReplicationTopologyController : BaseDatabaseApiController {
    [RavenRouteAttribute("admin/replication/topology/discover")]
[RavenRouteAttribute("databases/{databaseName}/admin/replication/topology/discover")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Bundles.Replication.Controllers.ReplicationTopologyController/<ReplicationTopologyDiscover>d__0")]
public Task`1<HttpResponseMessage> ReplicationTopologyDiscover();
}
public class Raven.Database.Bundles.Replication.Data.GlobalReplicationTopologyRequest : object {
    [CompilerGeneratedAttribute]
private bool <Databases>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Filesystems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Counters>k__BackingField;
    public bool Databases { get; public set; }
    public bool Filesystems { get; public set; }
    public bool Counters { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Databases();
    [CompilerGeneratedAttribute]
public void set_Databases(bool value);
    [CompilerGeneratedAttribute]
public bool get_Filesystems();
    [CompilerGeneratedAttribute]
public void set_Filesystems(bool value);
    [CompilerGeneratedAttribute]
public bool get_Counters();
    [CompilerGeneratedAttribute]
public void set_Counters(bool value);
}
public class Raven.Database.Bundles.Replication.Data.ReplicationTopology : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Servers>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ReplicationTopologyConnection> <Connections>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <SkippedResources>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Guid> <LocalDatabaseIds>k__BackingField;
    public HashSet`1<string> Servers { get; public set; }
    public HashSet`1<ReplicationTopologyConnection> Connections { get; public set; }
    public HashSet`1<string> SkippedResources { get; public set; }
    public List`1<Guid> LocalDatabaseIds { get; public set; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Servers();
    [CompilerGeneratedAttribute]
public void set_Servers(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<ReplicationTopologyConnection> get_Connections();
    [CompilerGeneratedAttribute]
public void set_Connections(HashSet`1<ReplicationTopologyConnection> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SkippedResources();
    [CompilerGeneratedAttribute]
public void set_SkippedResources(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<Guid> get_LocalDatabaseIds();
    [CompilerGeneratedAttribute]
public void set_LocalDatabaseIds(List`1<Guid> value);
    public ReplicationTopologyConnection GetConnection(Guid fromServerId, Nullable`1<Guid> toServerId, string fromUrl, string toUrl);
}
public class Raven.Database.Bundles.Replication.Data.ReplicationTopologyConnection : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <SourceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <DestinationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <DestinationServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SendServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <StoredServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastAttachmentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastDocumentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private TransitiveReplicationOptions <ReplicationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicatonNodeState <SourceToDestinationState>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicatonNodeState <DestinationToSourceState>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    public HashSet`1<string> SourceUrl { get; public set; }
    public HashSet`1<string> DestinationUrl { get; public set; }
    public Guid SourceServerId { get; }
    public Nullable`1<Guid> DestinationServerId { get; public set; }
    public Guid SendServerId { get; public set; }
    public Guid StoredServerId { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag LastAttachmentEtag { get; public set; }
    public Etag LastDocumentEtag { get; public set; }
    public TransitiveReplicationOptions ReplicationBehavior { get; public set; }
    public ReplicatonNodeState SourceToDestinationState { get; public set; }
    public ReplicatonNodeState DestinationToSourceState { get; public set; }
    public List`1<string> Errors { get; public set; }
    public string Source { get; public set; }
    public string Destination { get; public set; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SourceUrl();
    [CompilerGeneratedAttribute]
public void set_SourceUrl(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_DestinationUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationUrl(HashSet`1<string> value);
    public Guid get_SourceServerId();
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_DestinationServerId();
    [CompilerGeneratedAttribute]
public void set_DestinationServerId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Guid get_SendServerId();
    [CompilerGeneratedAttribute]
public void set_SendServerId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_StoredServerId();
    [CompilerGeneratedAttribute]
public void set_StoredServerId(Guid value);
    [CompilerGeneratedAttribute]
public Etag get_LastAttachmentEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastDocumentEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocumentEtag(Etag value);
    [CompilerGeneratedAttribute]
public TransitiveReplicationOptions get_ReplicationBehavior();
    [CompilerGeneratedAttribute]
public void set_ReplicationBehavior(TransitiveReplicationOptions value);
    [CompilerGeneratedAttribute]
public ReplicatonNodeState get_SourceToDestinationState();
    [CompilerGeneratedAttribute]
public void set_SourceToDestinationState(ReplicatonNodeState value);
    [CompilerGeneratedAttribute]
public ReplicatonNodeState get_DestinationToSourceState();
    [CompilerGeneratedAttribute]
public void set_DestinationToSourceState(ReplicatonNodeState value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
}
public class Raven.Database.Bundles.Replication.Data.ReplicationTopologyDestinationNode : ReplicationTopologyNode {
    [CompilerGeneratedAttribute]
private Guid <SendServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private TransitiveReplicationOptions <ReplicationBehavior>k__BackingField;
    public Guid SendServerId { get; public set; }
    public TransitiveReplicationOptions ReplicationBehavior { get; protected set; }
    [CompilerGeneratedAttribute]
public Guid get_SendServerId();
    [CompilerGeneratedAttribute]
public void set_SendServerId(Guid value);
    [CompilerGeneratedAttribute]
public TransitiveReplicationOptions get_ReplicationBehavior();
    [CompilerGeneratedAttribute]
protected void set_ReplicationBehavior(TransitiveReplicationOptions value);
    public static ReplicationTopologyDestinationNode Online(string serverUrl, Guid sourceServerId, Nullable`1<Guid> destinationServerId, TransitiveReplicationOptions replicationBehavior);
    public static ReplicationTopologyDestinationNode Offline(string serverUrl, Guid sourceServerId, Nullable`1<Guid> destinationServerId, TransitiveReplicationOptions replicationBehavior);
    public static ReplicationTopologyDestinationNode Disabled(string serverUrl, Guid sourceServerId, Nullable`1<Guid> destinationServerId, TransitiveReplicationOptions replicationBehavior);
}
public abstract class Raven.Database.Bundles.Replication.Data.ReplicationTopologyNode : ReplicationTopologyNodeBase {
    [CompilerGeneratedAttribute]
private ReplicatonNodeState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <DestinationServerId>k__BackingField;
    public ReplicatonNodeState State { get; protected set; }
    public Nullable`1<Guid> DestinationServerId { get; public set; }
    [CompilerGeneratedAttribute]
public ReplicatonNodeState get_State();
    [CompilerGeneratedAttribute]
protected void set_State(ReplicatonNodeState value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_DestinationServerId();
    [CompilerGeneratedAttribute]
public void set_DestinationServerId(Nullable`1<Guid> value);
}
public abstract class Raven.Database.Bundles.Replication.Data.ReplicationTopologyNodeBase : object {
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ReplicationTopologySourceNode> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ReplicationTopologyDestinationNode> <Destinations>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    public string ServerUrl { get; protected set; }
    public Guid ServerId { get; public set; }
    public List`1<ReplicationTopologySourceNode> Sources { get; public set; }
    public List`1<ReplicationTopologyDestinationNode> Destinations { get; public set; }
    public List`1<string> Errors { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
protected void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public Guid get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(Guid value);
    [CompilerGeneratedAttribute]
public List`1<ReplicationTopologySourceNode> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(List`1<ReplicationTopologySourceNode> value);
    [CompilerGeneratedAttribute]
public List`1<ReplicationTopologyDestinationNode> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(List`1<ReplicationTopologyDestinationNode> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<string> value);
}
public class Raven.Database.Bundles.Replication.Data.ReplicationTopologyRootNode : ReplicationTopologyNodeBase {
    private Dictionary`2<Guid, string> resourceIdToUrl;
    private Dictionary`2<string, Guid> urlToResourceId;
    public ReplicationTopologyRootNode(string serverUrl, Guid serverId);
    private void HandleLink(ReplicationTopology topology, ReplicationTopologyNodeBase source, ReplicationTopologyNodeBase target);
    private string AddToCache(Nullable`1<Guid> resourceId, string url);
    private Nullable`1<Guid> GetResourceId(Nullable`1<Guid> resourceId, string url);
    private string GetUrlByDatabaseId(Nullable`1<Guid> databaseId, string url);
    public ReplicationTopology Flatten();
}
public class Raven.Database.Bundles.Replication.Data.ReplicationTopologySourceNode : ReplicationTopologyNode {
    [CompilerGeneratedAttribute]
private Guid <StoredServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastAttachmentEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastDocumentEtag>k__BackingField;
    public Guid StoredServerId { get; public set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Etag LastAttachmentEtag { get; public set; }
    public Etag LastDocumentEtag { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_StoredServerId();
    [CompilerGeneratedAttribute]
public void set_StoredServerId(Guid value);
    [CompilerGeneratedAttribute]
public Etag get_LastAttachmentEtag();
    [CompilerGeneratedAttribute]
public void set_LastAttachmentEtag(Etag value);
    [CompilerGeneratedAttribute]
public Etag get_LastDocumentEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocumentEtag(Etag value);
    public static ReplicationTopologySourceNode Online(string serverUrl, Guid sourceServerId, Guid destinationServerId, Etag lastDocumentEtag, Etag lastAttachmentEtag);
    public static ReplicationTopologySourceNode Offline(string serverUrl, Guid sourceServerId, Guid destinationServerId, Etag lastDocumentEtag, Etag lastAttachmentEtag);
}
public enum Raven.Database.Bundles.Replication.Data.ReplicatonNodeState : Enum {
    public int value__;
    public static ReplicatonNodeState Offline;
    public static ReplicatonNodeState Online;
    public static ReplicatonNodeState Disabled;
}
public enum Raven.Database.Bundles.Replication.Impl.CountType : Enum {
    public int value__;
    public static CountType Accurate;
    public static CountType Approximate;
}
public class Raven.Database.Bundles.Replication.Impl.DocumentCount : object {
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private CountType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEtl>k__BackingField;
    public long Count { get; public set; }
    public CountType Type { get; public set; }
    public bool IsEtl { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(long value);
    [CompilerGeneratedAttribute]
public CountType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(CountType value);
    [CompilerGeneratedAttribute]
public bool get_IsEtl();
    [CompilerGeneratedAttribute]
public void set_IsEtl(bool value);
}
internal class Raven.Database.Bundles.Replication.Impl.DocumentsLeftToReplicate : object {
    private DocumentDatabase database;
    private ReplicationTask replicationTask;
    private HttpRavenRequestFactory requestFactory;
    private static int MaxDocumentsToCheck;
    [CompilerGeneratedAttribute]
private string <DatabaseId>k__BackingField;
    public string DatabaseId { get; }
    public DocumentsLeftToReplicate(DocumentDatabase database);
    [CompilerGeneratedAttribute]
public string get_DatabaseId();
    public DocumentCount Calculate(ServerInfo serverInfo);
    private ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin> GetReplicationDocument();
    private string FetchTargetServerUrl(ReplicationDestination replicationDestination);
    private DocumentCount GetDocumentsLeftCountFromAnotherSourceServer(ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin> replicationDocument, ServerInfo serverInfo);
    private DocumentCount DocumentsLeftCountFromAnotherSourceServer(ServerInfo serverInfo, ReplicationDestinationWithConfigurationOrigin replicationDestination);
    private DocumentCount GetDocumentsLeftCount(ReplicationStrategy replicationStrategy, string destinationUrl, string databaseName);
    private Func`4<string, RavenJObject, Func`1<JsonDocument>, bool> WillDocumentBeReplicated(ReplicationStrategy strategy, string destinationId, Action skippedAction);
    private bool WillReplicateByScript(string script, JsonDocument document);
    private DocumentCount GetDocumentsLeftCountForEtl(ReplicationStrategy replicationStrategy, string destinationUrl, string databaseName);
    public long GetDocumentCountForEntityNames(string query);
    public void ExtractDocumentIds(ServerInfo serverInfo, Action`1<string> successAction, Action skippedAction);
}
internal static class Raven.Database.Bundles.Replication.Impl.Historian : object {
    private static ILog log;
    private static Historian();
    public static bool IsDirectChildOfCurrent(RavenJObject incomingMetadata, RavenJObject existingMetadata);
    public static RavenJArray MergeReplicationHistories(RavenJArray leftHandHistory, RavenJArray rightHandHistory, string documentId);
    public static void MergeSingleHistory(RavenJArray history, Dictionary`2<string, RavenJObject> sourcesToVersionEntries, string documentId);
}
public class Raven.Database.Bundles.Replication.Impl.ReplicationData : object {
    public static RavenJArray GetOrCreateHistory(RavenJObject metadata);
    public static RavenJArray GetHistory(RavenJObject metadata);
    public static void SetHistory(RavenJObject metadata, RavenJArray history);
}
internal class Raven.Database.Bundles.Replication.Impl.ReplicationTopologyDiscoverer : object {
    private DocumentDatabase database;
    private int ttl;
    private ILog log;
    private HashSet`1<string> from;
    private HttpRavenRequestFactory requestFactory;
    private Guid currentServerId;
    private ReplicationTask replicationTask;
    public ReplicationTopologyDiscoverer(DocumentDatabase database, IEnumerable`1<string> from, int ttl, ILog log);
    public ReplicationTopologyRootNode Discover();
    private List`1<ReplicationTopologySourceNode> HandleSources(IEnumerable`1<RavenJToken> sources, ReplicationTopologyRootNode root);
    private ReplicationTopologySourceNode HandleSource(SourceReplicationInformation source);
    private List`1<ReplicationTopologyDestinationNode> HandleDestinations(ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin> destinations);
    private ReplicationTopologyDestinationNode HandleDestination(ReplicationDestination replicationDestination);
    private bool FetchTargetServerUrl(string serverUrl, RavenConnectionStringOptions connectionStringOptions, String& targetServerUrl, Nullable`1& databaseId, String& error);
    private Nullable`1<Guid> GetDatabaseId(string serverUrl, RavenConnectionStringOptions connectionStringOptions);
    private bool TryGetSchema(string serverUrl, RavenConnectionStringOptions connectionStringOptions, ReplicationTopologyRootNode& rootNode, String& error);
    private void FindVisitedNodes(ReplicationTopologyNodeBase rootNode, HashSet`1<string> visitedNodes);
    private ReplicatonNodeState CheckSourceConnectionState(string sourceUrl);
    private ReplicatonNodeState CheckDestinationConnectionState(ReplicationStrategy destination);
    private ReplicatonNodeState CheckConnectionState(string serverUrl, RavenConnectionStringOptions connectionStringOptions);
}
public class Raven.Database.Bundles.Replication.Impl.ServerInfo : object {
    [CompilerGeneratedAttribute]
private string <SourceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <SourcesToIgnore>k__BackingField;
    public string SourceUrl { get; public set; }
    public string DestinationUrl { get; public set; }
    public string DatabaseName { get; public set; }
    public string SourceId { get; public set; }
    public List`1<string> SourcesToIgnore { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SourceUrl();
    [CompilerGeneratedAttribute]
public void set_SourceUrl(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationUrl(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_SourceId();
    [CompilerGeneratedAttribute]
public void set_SourceId(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_SourcesToIgnore();
    [CompilerGeneratedAttribute]
public void set_SourcesToIgnore(List`1<string> value);
}
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Database.Bundles.Replication.Plugins.DefaultAttachmentReplicationConflictResolver : AbstractAttachmentReplicationConflictResolver {
    protected virtual bool TryResolve(string id, RavenJObject metadata, Byte[] data, Attachment existingAttachment, Func`2<string, Attachment> getAttachment, RavenJObject& metadataToSave, Byte[]& dataToSave);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Bundles.Replication.Plugins.AbstractDocumentReplicationConflictResolver")]
public class Raven.Database.Bundles.Replication.Plugins.DefaultDocumentReplicationConflictResolver : AbstractDocumentReplicationConflictResolver {
    protected virtual bool TryResolve(string id, RavenJObject metadata, RavenJObject document, JsonDocument existingDoc, Func`2<string, JsonDocument> getDocument, RavenJObject& metadataToSave, RavenJObject& documentToSave);
}
[PartNotDiscoverableAttribute]
public class Raven.Database.Bundles.Replication.Plugins.LatestDocumentReplicationConflictResolver : AbstractDocumentReplicationConflictResolver {
    public static LatestDocumentReplicationConflictResolver Instance;
    private static LatestDocumentReplicationConflictResolver();
    protected virtual bool TryResolve(string id, RavenJObject metadata, RavenJObject document, JsonDocument existingDoc, Func`2<string, JsonDocument> getDocument, RavenJObject& metadataToSave, RavenJObject& documentToSave);
}
[PartNotDiscoverableAttribute]
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Database.Bundles.Replication.Plugins.LocalAttachmentReplicationConflictResolver : AbstractAttachmentReplicationConflictResolver {
    public static LocalAttachmentReplicationConflictResolver Instance;
    private static LocalAttachmentReplicationConflictResolver();
    protected virtual bool TryResolve(string id, RavenJObject metadata, Byte[] data, Attachment existingAttachment, Func`2<string, Attachment> getAttachment, RavenJObject& metadataToSave, Byte[]& dataToSave);
}
[PartNotDiscoverableAttribute]
public class Raven.Database.Bundles.Replication.Plugins.LocalDocumentReplicationConflictResolver : AbstractDocumentReplicationConflictResolver {
    public static LocalDocumentReplicationConflictResolver Instance;
    private static LocalDocumentReplicationConflictResolver();
    protected virtual bool TryResolve(string id, RavenJObject metadata, RavenJObject document, JsonDocument existingDoc, Func`2<string, JsonDocument> getDocument, RavenJObject& metadataToSave, RavenJObject& documentToSave);
}
[ObsoleteAttribute("Use RavenFS instead.")]
[PartNotDiscoverableAttribute]
public class Raven.Database.Bundles.Replication.Plugins.RemoteAttachmentReplicationConflictResolver : AbstractAttachmentReplicationConflictResolver {
    public static RemoteAttachmentReplicationConflictResolver Instance;
    private static RemoteAttachmentReplicationConflictResolver();
    protected virtual bool TryResolve(string id, RavenJObject metadata, Byte[] data, Attachment existingAttachment, Func`2<string, Attachment> getAttachment, RavenJObject& metadataToSave, Byte[]& dataToSave);
}
[PartNotDiscoverableAttribute]
public class Raven.Database.Bundles.Replication.Plugins.RemoteDocumentReplicationConflictResolver : AbstractDocumentReplicationConflictResolver {
    public static RemoteDocumentReplicationConflictResolver Instance;
    private static RemoteDocumentReplicationConflictResolver();
    protected virtual bool TryResolve(string id, RavenJObject metadata, RavenJObject document, JsonDocument existingDoc, Func`2<string, JsonDocument> getDocument, RavenJObject& metadataToSave, RavenJObject& documentToSave);
}
public class Raven.Database.Bundles.Replication.RavenConflictDocuments : AbstractIndexCreationTask {
    public string IndexName { get; }
    public virtual string get_IndexName();
    public virtual IndexDefinition CreateIndexDefinition();
}
public class Raven.Database.Bundles.Replication.RavenConflictDocumentsTransformer : AbstractTransformerCreationTask {
    public string TransformerName { get; }
    public virtual string get_TransformerName();
    public virtual TransformerDefinition CreateTransformerDefinition(bool prettify);
}
public abstract class Raven.Database.Bundles.Replication.Responders.Behaviors.SingleItemReplicationBehavior`2 : object {
    private ILog log;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private IStorageActionsAccessor <Actions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Src>k__BackingField;
    private static HashSet`1<string> IgnoreProperties;
    public DocumentDatabase Database { get; public set; }
    public IStorageActionsAccessor Actions { get; public set; }
    public string Src { get; public set; }
    protected ReplicationConflictTypes ReplicationConflict { get; }
    private static SingleItemReplicationBehavior`2();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    [CompilerGeneratedAttribute]
public IStorageActionsAccessor get_Actions();
    [CompilerGeneratedAttribute]
public void set_Actions(IStorageActionsAccessor value);
    [CompilerGeneratedAttribute]
public string get_Src();
    [CompilerGeneratedAttribute]
public void set_Src(string value);
    public void Replicate(string id, RavenJObject metadata, TExternal incoming);
    public void ResolveConflict(string id, RavenJObject metadata, TExternal incoming, TInternal existingItem);
    private void ExecuteRemoveConflictOnPutTrigger(string id, RavenJObject metadata, RavenJObject resolvedItemJObject);
    protected abstract virtual ReplicationConflictTypes get_ReplicationConflict();
    private string SaveConflictedItem(string id, RavenJObject metadata, TExternal incoming, Etag existingEtag);
    private void ReplicateDelete(string id, RavenJObject newMetadata, TExternal incoming);
    protected abstract virtual void DeleteItem(string id, Etag etag);
    protected abstract virtual void MarkAsDeleted(string id, RavenJObject metadata);
    protected abstract virtual void AddWithoutConflict(string id, Etag etag, RavenJObject metadata, TExternal incoming);
    protected abstract virtual CreatedConflict<TInternal, TExternal> CreateConflict(string id, string newDocumentConflictId, string existingDocumentConflictId, TInternal existingItem, RavenJObject existingMetadata);
    protected abstract virtual CreatedConflict<TInternal, TExternal> AppendToCurrentItemConflicts(string id, string newConflictId, RavenJObject existingMetadata, TInternal existingItem);
    protected abstract virtual RavenJObject TryGetExisting(string id, TInternal& existingItem, Etag& existingEtag, Boolean& deleted);
    protected abstract virtual bool TryResolveConflict(string id, RavenJObject metadata, TExternal document, TInternal existing, RavenJObject& resolvedMetadataToSave, TExternal& resolvedItemToSave);
    protected abstract virtual bool TryResolveConflictByCheckingIfIdentical(string documentId, RavenJObject metadata, TExternal document, TInternal existing, RavenJObject& resolvedMetadataToSave);
    protected static bool CheckIfMetadataIsEqualEnoughForReplicationAndMergeHistorires(string documentId, RavenJObject origin, RavenJObject external, RavenJObject& result);
    private static void MergeReplicationHistories(string documentId, RavenJObject origin, RavenJObject external, RavenJObject& result);
    private static string GetReplicationIdentifier(RavenJObject metadata);
    private string GetReplicationIdentifierForCurrentDatabase();
}
public class Raven.Database.Bundles.Replication.Tasks.DatabaseIdsCache : object {
    private DocumentDatabase documentDatabase;
    private ILog log;
    private DatabaseIdsCacheDocument databaseIdsCacheDocument;
    private Timer saveDocumentTimer;
    private static string CacheDocumentId;
    private bool disposed;
    private long version;
    private long snapshotVersion;
    public DatabaseIdsCache(DocumentDatabase documentDatabase, ILog log);
    private DatabaseIdsCacheDocument GetCachedDocument();
    public void Add(string url, Nullable`1<Guid> databaseId);
    public Nullable`1<Guid> Get(string url);
    private void SaveDocument(object _);
    public sealed virtual void Dispose();
}
public class Raven.Database.Bundles.Replication.Tasks.Handlers.FilterAndTransformSpecifiedCollections : object {
    private static ILog Log;
    private DocumentDatabase database;
    private ReplicationStrategy strategy;
    private string destinationId;
    public FilterAndTransformSpecifiedCollections(DocumentDatabase database, ReplicationStrategy strategy, string destinationId);
    private static FilterAndTransformSpecifiedCollections();
    public sealed virtual IEnumerable`1<JsonDocument> Handle(IEnumerable`1<JsonDocument> docs);
    [CompilerGeneratedAttribute]
private JsonDocument <Handle>b__5_0(JsonDocument doc);
}
public class Raven.Database.Bundles.Replication.Tasks.Handlers.FilterReplicatedDocs : object {
    private static ILog Log;
    private DocumentActions docActions;
    private ReplicationStrategy strategy;
    private PrefetchingBehavior prefetchingBehavior;
    private string destinationId;
    private Etag lastEtag;
    public FilterReplicatedDocs(DocumentActions docActions, ReplicationStrategy strategy, PrefetchingBehavior prefetchingBehavior, string destinationId, Etag lastEtag);
    private static FilterReplicatedDocs();
    public sealed virtual IEnumerable`1<JsonDocument> Handle(IEnumerable`1<JsonDocument> docs);
    [CompilerGeneratedAttribute]
private bool <Handle>b__7_0(JsonDocument document);
}
public interface Raven.Database.Bundles.Replication.Tasks.Handlers.IReplicatedDocsHandler {
    public abstract virtual IEnumerable`1<JsonDocument> Handle(IEnumerable`1<JsonDocument> docs);
}
public class Raven.Database.Bundles.Replication.Tasks.IndexReplicationTask : ReplicationTaskBase {
    private static ILog Log;
    private TimeSpan replicationFrequency;
    private TimeSpan lastQueriedFrequency;
    private object indexReplicationLock;
    private Timer indexReplicationTimer;
    private Timer lastQueriedTimer;
    private ConcurrentDictionary`2<int, IndexToAdd> sideBySideIndexesToReplicate;
    private ConcurrentDictionary`2<string, ConcurrentSet`1<int>> replicatedSideBySideIndexIds;
    private long sideBySideWorkCounter;
    private InterlockedLock interlockedLock;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToWaitBeforeSendingDeletesOfIndexesToSiblings>k__BackingField;
    public TimeSpan TimeToWaitBeforeSendingDeletesOfIndexesToSiblings { get; public set; }
    public IndexReplicationTask(DocumentDatabase database, HttpRavenRequestFactory httpRavenRequestFactory, ReplicationTask replication);
    private static IndexReplicationTask();
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToWaitBeforeSendingDeletesOfIndexesToSiblings();
    [CompilerGeneratedAttribute]
public void set_TimeToWaitBeforeSendingDeletesOfIndexesToSiblings(TimeSpan value);
    public void Start();
    public void StartReplicatingSideBySideIndexAsync(IndexToAdd indexToAdd);
    public void ReplicateSideBySideIndexes();
    private void OnDocumentChange(DocumentDatabase db, DocumentChangeNotification notification, RavenJObject doc);
    private void SetIndexReplaceInfo(string indexName, IndexToAdd indexToAdd);
    public bool Execute(Func`2<ReplicationDestination, bool> shouldSkipDestinationPredicate, bool forceTombstoneReplication);
    public void Execute(string indexName);
    private void OnIndexChange(DocumentDatabase documentDatabase, IndexChangeNotification notification);
    private void ReplicateIndexesMultiPut(ReplicationStrategy destination, List`1<IndexToAdd> indexesToAdd);
    private void ReplicateSideBySideIndexesMultiPut(ReplicationStrategy destination, List`1<IndexToAdd> indexes);
    private void ReplicateSingleSideBySideIndex(ReplicationStrategy destination, IndexDefinition indexDefinition, IndexDefinition sideBySideIndexDefinition);
    private void ReplicateIndexDeletionIfNeeded(List`1<JsonDocument> indexTombstones, ReplicationStrategy destination, Dictionary`2<string, int> replicatedIndexTombstones);
    public void SendLastQueried();
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Start>b__15_1(object x);
    [CompilerGeneratedAttribute]
private void <Start>b__15_2(object x);
}
public abstract class Raven.Database.Bundles.Replication.Tasks.ReplicationTaskBase : object {
    protected object EmptyRequestBody;
    protected DocumentDatabase Database;
    protected HttpRavenRequestFactory HttpRavenRequestFactory;
    protected ReplicationTask Replication;
    protected ReplicationTaskBase(DocumentDatabase database, HttpRavenRequestFactory httpRavenRequestFactory, ReplicationTask replication);
    protected string GetTombstoneVersion(JsonDocument tombstone, string tombstoneKey, string key);
    protected string GetDebugInformation();
    protected List`1<JsonDocument> GetTombstones(string tombstoneListName, int start, int take, Func`2<ListItem, bool> wherePredicate);
    protected List`1<ReplicationStrategy> GetReplicationDestinations(Predicate`1<ReplicationDestination> predicate);
    public abstract virtual void Dispose();
}
public class Raven.Database.Bundles.Replication.Tasks.TransformerReplicationTask : ReplicationTaskBase {
    private static ILog Log;
    private TimeSpan replicationFrequency;
    private Timer timer;
    private object replicationLock;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToWaitBeforeSendingDeletesOfTransformersToSiblings>k__BackingField;
    public TimeSpan TimeToWaitBeforeSendingDeletesOfTransformersToSiblings { get; public set; }
    public TransformerReplicationTask(DocumentDatabase database, HttpRavenRequestFactory httpRavenRequestFactory, ReplicationTask replication);
    private static TransformerReplicationTask();
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToWaitBeforeSendingDeletesOfTransformersToSiblings();
    [CompilerGeneratedAttribute]
public void set_TimeToWaitBeforeSendingDeletesOfTransformersToSiblings(TimeSpan value);
    public void Start();
    private void OnTransformerChange(DocumentDatabase documentDatabase, TransformerChangeNotification notification);
    public bool Execute(Func`2<ReplicationDestination, bool> shouldSkipDestinationPredicate, bool forceTombstoneReplication);
    public void Execute(string transformerName);
    private void ReplicateSingleTransformer(ReplicationStrategy destination, TransformerDefinition definition);
    private void ReplicateTransformerDeletionIfNeeded(List`1<JsonDocument> transformerTombstones, ReplicationStrategy destination, Dictionary`2<string, int> replicatedTransformerTombstones);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Start>b__9_0(object x);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractPutTrigger")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.Bundles.Replication.Triggers.AncestryPutTrigger : AbstractPutTrigger {
    public IEnumerable`1<string> GeneratedMetadataNames { get; }
    public virtual void OnPut(string key, RavenJObject jsonReplicationDocument, RavenJObject metadata, TransactionInformation transactionInformation);
    private RavenJObject GetDocumentMetadata(string key);
    public virtual IEnumerable`1<string> get_GeneratedMetadataNames();
}
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ObsoleteAttribute("Use RavenFS instead.")]
[InheritedExportAttribute("Raven.Database.Plugins.AbstractAttachmentPutTrigger")]
public class Raven.Database.Bundles.Replication.Triggers.RemoveConflictOnAttachmentPutTrigger : AbstractAttachmentPutTrigger {
    public virtual void OnPut(string key, Stream data, RavenJObject metadata);
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractPutTrigger")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.Bundles.Replication.Triggers.RemoveConflictOnPutTrigger : AbstractPutTrigger {
    public IEnumerable`1<string> GeneratedMetadataNames { get; }
    public virtual void OnPut(string key, RavenJObject jsonReplicationDocument, RavenJObject metadata, TransactionInformation transactionInformation);
    public virtual IEnumerable`1<string> get_GeneratedMetadataNames();
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractIndexUpdateTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.Bundles.Replication.Triggers.RenameConflictDocumentIdIndexTrigger : AbstractIndexUpdateTrigger {
    public virtual AbstractIndexUpdateTriggerBatcher CreateBatcher(int indexId);
}
public static class Raven.Database.Bundles.Replication.Utils.ReplicationUtils : object {
    internal static ReplicationStatistics GetReplicationInformation(DocumentDatabase database);
}
[InheritedExportAttribute("Raven.Database.Plugins.AbstractIndexUpdateTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.Bundles.ScriptedIndexResults.ScriptedIndexResultsIndexTrigger : AbstractIndexUpdateTrigger {
    private static ILog Log;
    private static ScriptedIndexResultsIndexTrigger();
    public virtual AbstractIndexUpdateTriggerBatcher CreateBatcher(int indexId);
}
internal class Raven.Database.Bundles.ScriptedIndexResults.ScriptedIndexResultsJsonPatcherScope : DefaultScriptedJsonPatcherOperationScope {
    private HashSet`1<string> entityNames;
    private HashSet`1<string> forbiddenDocuments;
    public ScriptedIndexResultsJsonPatcherScope(DocumentDatabase database, HashSet`1<string> entityNames);
    public virtual JsValue LoadDocument(string documentKey, Engine engine, Int32& totalStatements);
    public virtual string PutDocument(string documentKey, object data, object meta, Engine engine);
    public virtual void DeleteDocument(string documentKey);
    public virtual void Dispose();
    protected virtual void ValidateDocument(JsonDocument newDocument);
}
public class Raven.Database.Bundles.SqlReplication.ConversionScriptResult : object {
    public Dictionary`2<string, List`1<ItemToReplicate>> Data;
    public List`1<string> Ids;
}
public class Raven.Database.Bundles.SqlReplication.ItemToReplicate : object {
    [CompilerGeneratedAttribute]
private string <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Columns>k__BackingField;
    public string DocumentId { get; public set; }
    public RavenJObject Columns { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(string value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Columns();
    [CompilerGeneratedAttribute]
public void set_Columns(RavenJObject value);
}
public class Raven.Database.Bundles.SqlReplication.LastReplicatedEtag : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastDocEtag>k__BackingField;
    public string Name { get; public set; }
    public Etag LastDocEtag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Etag get_LastDocEtag();
    [CompilerGeneratedAttribute]
public void set_LastDocEtag(Etag value);
}
public class Raven.Database.Bundles.SqlReplication.RelationalDatabaseWriter : object {
    private static String[] SqlServerFactoryNames;
    private DocumentDatabase database;
    private SqlReplicationConfig cfg;
    private DbProviderFactory providerFactory;
    private SqlReplicationStatistics replicationStatistics;
    private DbCommandBuilder commandBuilder;
    private DbConnection connection;
    private DbTransaction tx;
    private List`1<Func`3<DbParameter, string, bool>> stringParserList;
    private bool IsSqlServerFactoryType;
    private SqlReplicationMetricsCountersManager sqlReplicationMetrics;
    private static ILog log;
    private static int LongStatementWarnThresholdInMiliseconds;
    private bool hadErrors;
    private static Func`3<DbCommandBuilder, string, string> getParameterNameFromBuilder;
    public RelationalDatabaseWriter(DocumentDatabase database, SqlReplicationConfig cfg, SqlReplicationStatistics replicationStatistics);
    private static RelationalDatabaseWriter();
    public static void TestConnection(string factoryName, string connectionString);
    public List`1<Func`3<DbParameter, string, bool>> GenerateStringParsers();
    public bool Execute(ConversionScriptResult scriptResult);
    [IteratorStateMachineAttribute("Raven.Database.Bundles.SqlReplication.RelationalDatabaseWriter/<RolledBackExecute>d__19")]
public IEnumerable`1<TableQuerySummary> RolledBackExecute(ConversionScriptResult scriptResult);
    public bool Commit();
    public bool Rollback();
    private void InsertItems(string tableName, string pkName, List`1<ItemToReplicate> dataForTable, Action`1<DbCommand> commandCallback);
    public void DeleteItems(string tableName, string pkName, bool doNotParameterize, List`1<string> identifiers, Action`1<DbCommand> commandCallback);
    private void HandleSlowSql(long elapsedMiliseconds, string stmt);
    private string GetTableNameString(string tableName);
    public static string SanitizeSqlValue(string sqlValue);
    private static string GetParameterName(DbProviderFactory providerFactory, DbCommandBuilder commandBuilder, string paramName);
    public static void SetParamValue(DbParameter colParam, RavenJToken val, List`1<Func`3<DbParameter, string, bool>> stringParsers);
    private DbProviderFactory GetDbProviderFactory(SqlReplicationConfig cfg);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <GenerateStringParsers>b__16_0(DbParameter colParam, string value);
    [CompilerGeneratedAttribute]
private bool <GenerateStringParsers>b__16_1(DbParameter colParam, string value);
    [CompilerGeneratedAttribute]
private string <GetTableNameString>b__25_0(string x);
}
public class Raven.Database.Bundles.SqlReplication.RelationalDatabaseWriterSimulator : object {
    private DocumentDatabase database;
    private SqlReplicationConfig cfg;
    private DbProviderFactory providerFactory;
    private SqlReplicationStatistics replicationStatistics;
    private DbCommandBuilder commandBuilder;
    private bool IsSqlServerFactoryType;
    private static String[] SqlServerFactoryNames;
    public RelationalDatabaseWriterSimulator(DocumentDatabase database, SqlReplicationConfig cfg, SqlReplicationStatistics replicationStatistics);
    private static RelationalDatabaseWriterSimulator();
    [IteratorStateMachineAttribute("Raven.Database.Bundles.SqlReplication.RelationalDatabaseWriterSimulator/<SimulateExecuteCommandText>d__8")]
public IEnumerable`1<string> SimulateExecuteCommandText(ConversionScriptResult scriptResult);
    [IteratorStateMachineAttribute("Raven.Database.Bundles.SqlReplication.RelationalDatabaseWriterSimulator/<GenerteInsertItemCommandText>d__9")]
private IEnumerable`1<string> GenerteInsertItemCommandText(string tableName, string pkName, List`1<ItemToReplicate> dataForTable);
    [IteratorStateMachineAttribute("Raven.Database.Bundles.SqlReplication.RelationalDatabaseWriterSimulator/<GenerateDeleteItemsCommandText>d__10")]
private IEnumerable`1<string> GenerateDeleteItemsCommandText(string tableName, string pkName, bool doNotParameterize, List`1<string> identifiers);
    private string GetTableNameString(string tableName);
    [CompilerGeneratedAttribute]
private string <GetTableNameString>b__11_0(string x);
}
internal static class Raven.Database.Bundles.SqlReplication.SqlReplicationClassifier : object {
    private static Dictionary`2<Etag, List`1<SqlReplicationConfigWithLastReplicatedEtag>> Empty;
    private static SqlReplicationClassifier();
    public static Dictionary`2<Etag, List`1<SqlReplicationConfigWithLastReplicatedEtag>> GroupConfigs(IList`1<SqlReplicationConfig> configs, Func`2<SqlReplicationConfig, Etag> getLastEtagFor);
}
public class Raven.Database.Bundles.SqlReplication.SqlReplicationConfig : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ParameterizeDeletesDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceSqlServerQueryRecompile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QuoteTables>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RavenEntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FactoryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PredefinedConnectionStringSettingName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionStringSettingName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CommandTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SqlReplicationTable> <SqlReplicationTables>k__BackingField;
    public string Id { get; public set; }
    public string Name { get; public set; }
    public bool Disabled { get; public set; }
    public bool ParameterizeDeletesDisabled { get; public set; }
    public bool ForceSqlServerQueryRecompile { get; public set; }
    [ObsoleteAttribute("Use QuoteTables, instead", "True")]
public bool PerformTableQuatation { get; public set; }
    public bool QuoteTables { get; public set; }
    public string RavenEntityName { get; public set; }
    public string Script { get; public set; }
    public string FactoryName { get; public set; }
    public string ConnectionString { get; public set; }
    public string PredefinedConnectionStringSettingName { get; public set; }
    public string ConnectionStringName { get; public set; }
    public string ConnectionStringSettingName { get; public set; }
    public Nullable`1<int> CommandTimeout { get; public set; }
    public List`1<SqlReplicationTable> SqlReplicationTables { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Disabled();
    [CompilerGeneratedAttribute]
public void set_Disabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_ParameterizeDeletesDisabled();
    [CompilerGeneratedAttribute]
public void set_ParameterizeDeletesDisabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceSqlServerQueryRecompile();
    [CompilerGeneratedAttribute]
public void set_ForceSqlServerQueryRecompile(bool value);
    public bool get_PerformTableQuatation();
    public void set_PerformTableQuatation(bool value);
    [CompilerGeneratedAttribute]
public bool get_QuoteTables();
    [CompilerGeneratedAttribute]
public void set_QuoteTables(bool value);
    [CompilerGeneratedAttribute]
public string get_RavenEntityName();
    [CompilerGeneratedAttribute]
public void set_RavenEntityName(string value);
    [CompilerGeneratedAttribute]
public string get_Script();
    [CompilerGeneratedAttribute]
public void set_Script(string value);
    [CompilerGeneratedAttribute]
public string get_FactoryName();
    [CompilerGeneratedAttribute]
public void set_FactoryName(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    [CompilerGeneratedAttribute]
public void set_ConnectionString(string value);
    [CompilerGeneratedAttribute]
public string get_PredefinedConnectionStringSettingName();
    [CompilerGeneratedAttribute]
public void set_PredefinedConnectionStringSettingName(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringName(string value);
    [CompilerGeneratedAttribute]
public string get_ConnectionStringSettingName();
    [CompilerGeneratedAttribute]
public void set_ConnectionStringSettingName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CommandTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandTimeout(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<SqlReplicationTable> get_SqlReplicationTables();
    [CompilerGeneratedAttribute]
public void set_SqlReplicationTables(List`1<SqlReplicationTable> value);
}
internal class Raven.Database.Bundles.SqlReplication.SqlReplicationConfigWithLastReplicatedEtag : SqlReplicationConfig {
    [CompilerGeneratedAttribute]
private Etag <LastReplicatedEtag>k__BackingField;
    public Etag LastReplicatedEtag { get; private set; }
    public SqlReplicationConfigWithLastReplicatedEtag(SqlReplicationConfig config, Etag lastReplicatedEtag);
    [CompilerGeneratedAttribute]
public Etag get_LastReplicatedEtag();
    [CompilerGeneratedAttribute]
private void set_LastReplicatedEtag(Etag value);
}
public class Raven.Database.Bundles.SqlReplication.SqlReplicationConnections : SqlReplicationConnections`1<PredefinedSqlConnection> {
}
public class Raven.Database.Bundles.SqlReplication.SqlReplicationConnections`1 : object {
    [CompilerGeneratedAttribute]
private List`1<TClass> <PredefinedConnections>k__BackingField;
    public List`1<TClass> PredefinedConnections { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TClass> get_PredefinedConnections();
    [CompilerGeneratedAttribute]
public void set_PredefinedConnections(List`1<TClass> value);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Bundles.SqlReplication.SqlReplicationMetricsCountersManager : object {
    private Metrics dbMetrics;
    private SqlReplicationConfig sqlReplicationConfig;
    private static string MeterContext;
    private string meterName;
    [CompilerGeneratedAttribute]
private MeterMetric <SqlReplicationBatchSizeMeter>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramMetric <SqlReplicationBatchSizeHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramMetric <SqlReplicationDurationHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, SqlReplicationTableMetrics> <TablesMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentQueue`1<SqlReplicationPerformanceStats> <ReplicationPerformanceStats>k__BackingField;
    public MeterMetric SqlReplicationBatchSizeMeter { get; private set; }
    public HistogramMetric SqlReplicationBatchSizeHistogram { get; private set; }
    public HistogramMetric SqlReplicationDurationHistogram { get; private set; }
    public ConcurrentDictionary`2<string, SqlReplicationTableMetrics> TablesMetrics { get; public set; }
    public ConcurrentQueue`1<SqlReplicationPerformanceStats> ReplicationPerformanceStats { get; public set; }
    public SqlReplicationMetricsCountersManager(Metrics dbMetrics, SqlReplicationConfig sqlReplicationConfig);
    [CompilerGeneratedAttribute]
public MeterMetric get_SqlReplicationBatchSizeMeter();
    [CompilerGeneratedAttribute]
private void set_SqlReplicationBatchSizeMeter(MeterMetric value);
    [CompilerGeneratedAttribute]
public HistogramMetric get_SqlReplicationBatchSizeHistogram();
    [CompilerGeneratedAttribute]
private void set_SqlReplicationBatchSizeHistogram(HistogramMetric value);
    [CompilerGeneratedAttribute]
public HistogramMetric get_SqlReplicationDurationHistogram();
    [CompilerGeneratedAttribute]
private void set_SqlReplicationDurationHistogram(HistogramMetric value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, SqlReplicationTableMetrics> get_TablesMetrics();
    [CompilerGeneratedAttribute]
public void set_TablesMetrics(ConcurrentDictionary`2<string, SqlReplicationTableMetrics> value);
    [CompilerGeneratedAttribute]
public ConcurrentQueue`1<SqlReplicationPerformanceStats> get_ReplicationPerformanceStats();
    [CompilerGeneratedAttribute]
public void set_ReplicationPerformanceStats(ConcurrentQueue`1<SqlReplicationPerformanceStats> value);
    public SqlReplicationTableMetrics GetTableMetrics(string tableName);
    public SqlReplicationMetricsData ToSqlReplicationMetricsData();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private SqlReplicationTableMetrics <GetTableMetrics>b__25_0(string s);
}
public class Raven.Database.Bundles.SqlReplication.SqlReplicationMetricsData : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IMetricsData> <GeneralMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Dictionary`2<string, IMetricsData>> <TablesMetrics>k__BackingField;
    public Dictionary`2<string, IMetricsData> GeneralMetrics { get; public set; }
    public Dictionary`2<string, Dictionary`2<string, IMetricsData>> TablesMetrics { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IMetricsData> get_GeneralMetrics();
    [CompilerGeneratedAttribute]
public void set_GeneralMetrics(Dictionary`2<string, IMetricsData> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Dictionary`2<string, IMetricsData>> get_TablesMetrics();
    [CompilerGeneratedAttribute]
public void set_TablesMetrics(Dictionary`2<string, Dictionary`2<string, IMetricsData>> value);
}
public class Raven.Database.Bundles.SqlReplication.SqlReplicationPerformanceStats : object {
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    public int BatchSize { get; public set; }
    public TimeSpan Duration { get; public set; }
    public DateTime Started { get; public set; }
    public double DurationMilliseconds { get; }
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public void set_Started(DateTime value);
    public double get_DurationMilliseconds();
    public virtual string ToString();
    protected bool Equals(SqlReplicationPerformanceStats other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Raven.Database.Bundles.SqlReplication.SqlReplicationScriptedJsonPatcher : ScriptedJsonPatcher {
    private static int DefaultSize;
    private ConversionScriptResult scriptResult;
    private SqlReplicationConfig config;
    private string docId;
    public SqlReplicationScriptedJsonPatcher(DocumentDatabase database, ConversionScriptResult scriptResult, SqlReplicationConfig config, string docId);
    protected virtual void RemoveEngineCustomizations(Engine engine, ScriptedJsonPatcherOperationScope scope);
    protected virtual void CustomizeEngine(Engine engine, ScriptedJsonPatcherOperationScope scope);
    private void ReplicateToFunction(string tableName, object colsAsObject);
    private ValueTypeLengthTriple ToVarchar(string value, Nullable`1<double> sizeAsDouble);
    private ValueTypeLengthTriple ToNVarchar(string value, Nullable`1<double> sizeAsDouble);
}
internal class Raven.Database.Bundles.SqlReplication.SqlReplicationScriptedJsonPatcherOperationScope : DefaultScriptedJsonPatcherOperationScope {
    public SqlReplicationScriptedJsonPatcherOperationScope(DocumentDatabase database);
    public virtual RavenJObject ConvertReturnValue(JsValue jsObject);
}
public class Raven.Database.Bundles.SqlReplication.SqlReplicationStatistics : object {
    private string name;
    private bool reportToDatabaseAlerts;
    [CompilerGeneratedAttribute]
private DateTime <LastErrorTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <SuspendUntil>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScriptErrorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScriptSuccessCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WriteErrorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SuccessCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Alert <LastAlert>k__BackingField;
    public DateTime LastErrorTime { get; private set; }
    public DateTime SuspendUntil { get; private set; }
    private int ScriptErrorCount { get; private set; }
    private int ScriptSuccessCount { get; private set; }
    private int WriteErrorCount { get; private set; }
    private int SuccessCount { get; private set; }
    public Alert LastAlert { get; public set; }
    public SqlReplicationStatistics(string name, bool reportToDatabaseAlerts);
    [CompilerGeneratedAttribute]
public DateTime get_LastErrorTime();
    [CompilerGeneratedAttribute]
private void set_LastErrorTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_SuspendUntil();
    [CompilerGeneratedAttribute]
private void set_SuspendUntil(DateTime value);
    [CompilerGeneratedAttribute]
private int get_ScriptErrorCount();
    [CompilerGeneratedAttribute]
private void set_ScriptErrorCount(int value);
    [CompilerGeneratedAttribute]
private int get_ScriptSuccessCount();
    [CompilerGeneratedAttribute]
private void set_ScriptSuccessCount(int value);
    [CompilerGeneratedAttribute]
private int get_WriteErrorCount();
    [CompilerGeneratedAttribute]
private void set_WriteErrorCount(int value);
    [CompilerGeneratedAttribute]
private int get_SuccessCount();
    [CompilerGeneratedAttribute]
private void set_SuccessCount(int value);
    [CompilerGeneratedAttribute]
public Alert get_LastAlert();
    [CompilerGeneratedAttribute]
public void set_LastAlert(Alert value);
    public void Success(int countOfItems);
    public void RecordWriteError(Exception e, DocumentDatabase database, int count, Nullable`1<DateTime> suspendUntil);
    public virtual string ToString();
    public void CompleteSuccess(int countOfItems);
    public void MarkScriptAsInvalid(DocumentDatabase database, string script);
    public void RecordScriptError(DocumentDatabase database, Exception e);
    public void ScriptSuccess();
}
public class Raven.Database.Bundles.SqlReplication.SqlReplicationStatus : object {
    [CompilerGeneratedAttribute]
private List`1<LastReplicatedEtag> <LastReplicatedEtags>k__BackingField;
    public List`1<LastReplicatedEtag> LastReplicatedEtags { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<LastReplicatedEtag> get_LastReplicatedEtags();
    [CompilerGeneratedAttribute]
public void set_LastReplicatedEtags(List`1<LastReplicatedEtag> value);
}
public class Raven.Database.Bundles.SqlReplication.SqlReplicationTable : object {
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentKeyColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsertOnlyMode>k__BackingField;
    public string TableName { get; public set; }
    public string DocumentKeyColumn { get; public set; }
    public bool InsertOnlyMode { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
public void set_TableName(string value);
    [CompilerGeneratedAttribute]
public string get_DocumentKeyColumn();
    [CompilerGeneratedAttribute]
public void set_DocumentKeyColumn(string value);
    [CompilerGeneratedAttribute]
public bool get_InsertOnlyMode();
    [CompilerGeneratedAttribute]
public void set_InsertOnlyMode(bool value);
    protected bool Equals(SqlReplicationTable other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[InheritedExportAttribute("Raven.Database.Plugins.IStartupTask")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[CLSCompliantAttribute("False")]
public class Raven.Database.Bundles.SqlReplication.SqlReplicationTask : object {
    private static int MaxNumberOfDeletionsToReplicate;
    private static int MaxNumberOfChangesToReplicate;
    private static int MaxBatchSizeToReturnToNormal;
    private int changesBatchSize;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) shouldPause;
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    public static string RavenSqlReplicationStatus;
    private static ILog Log;
    [CompilerGeneratedAttribute]
private Action`1<int> AfterReplicationCompleted;
    private Metrics sqlReplicationMetrics;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    private List`1<SqlReplicationConfig> replicationConfigs;
    private ConcurrentDictionary`2<string, SqlReplicationStatistics> statistics;
    public ConcurrentDictionary`2<string, SqlReplicationMetricsCountersManager> SqlReplicationMetricsCounters;
    private ConcurrentSet`1<PrefetchingBehavior> prefetchingBehaviors;
    private ConcurrentDictionary`2<string, bool> resetRequested;
    public bool IsRunning { get; private set; }
    public DocumentDatabase Database { get; public set; }
    public ConcurrentDictionary`2<string, SqlReplicationStatistics> Statistics { get; }
    public ConcurrentDictionary`2<string, bool> ResetRequested { get; }
    private static SqlReplicationTask();
    [CompilerGeneratedAttribute]
public bool get_IsRunning();
    [CompilerGeneratedAttribute]
private void set_IsRunning(bool value);
    [CompilerGeneratedAttribute]
public void add_AfterReplicationCompleted(Action`1<int> value);
    [CompilerGeneratedAttribute]
public void remove_AfterReplicationCompleted(Action`1<int> value);
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    public ConcurrentDictionary`2<string, SqlReplicationStatistics> get_Statistics();
    public ConcurrentDictionary`2<string, bool> get_ResetRequested();
    public sealed virtual void Execute(DocumentDatabase database);
    public void Pause();
    public void Continue();
    private void RecordDelete(string id, RavenJObject metadata);
    private SqlReplicationStatus GetReplicationStatus();
    public SqlReplicationMetricsCountersManager GetSqlReplicationMetricsManager(SqlReplicationConfig cfg);
    private bool IsHotSpare();
    private void BackgroundSqlReplication();
    private void UpdateLastReplicatedStatus(SqlReplicationStatus localReplicationStatus, List`1<SqlReplicationConfig> config);
    private void SetPrefetcherForIndexingGroup(SqlConfigGroup sqlConfig, ConcurrentSet`1<PrefetchingBehavior> usedPrefetchers);
    private PrefetchingBehavior TryGetPrefetcherFor(Etag fromEtag, ConcurrentSet`1<PrefetchingBehavior> usedPrefetchers, HashSet`1<string> entityNames);
    private PrefetchingBehavior GetPrefetcherFor(Etag fromEtag, ConcurrentSet`1<PrefetchingBehavior> usedPrefetchers, HashSet`1<string> entityNames);
    private void RemoveUnusedPrefetchers(IEnumerable`1<PrefetchingBehavior> usedPrefetchingBehaviors);
    private void UpdateReplicationPerformance(SqlReplicationConfig replicationConfig, DateTime startTime, TimeSpan elapsed, int batchSize);
    private void SaveNewReplicationStatus(SqlReplicationStatus localReplicationStatus);
    private Etag HandleDeletesAndChangesMerging(List`1<ListItem> deletedDocs, List`1<ReplicatedDoc> docsToReplicate, SqlReplicationConfigWithLastReplicatedEtag replicationConfig);
    private bool ReplicateDeletionsToDestination(SqlReplicationConfig cfg, IEnumerable`1<ListItem> deletedDocs);
    private static string GetSqlReplicationDeletionName(SqlReplicationConfig replicationConfig);
    private bool ReplicateChangesToDestination(SqlReplicationConfig cfg, ICollection`1<ReplicatedDoc> docs, Int32& countOfReplicatedItems);
    private ConversionScriptResult ApplyConversionScript(SqlReplicationConfig cfg, IEnumerable`1<ReplicatedDoc> docs, SqlReplicationStatistics replicationStats);
    private Etag GetLastEtagFor(SqlReplicationStatus replicationStatus, SqlReplicationConfig sqlReplicationConfig);
    public TableQuerySummary[] SimulateSqlReplicationSqlQueries(string strDocumentId, SqlReplicationConfig sqlReplication, bool performRolledbackTransaction, Alert& alert);
    public List`1<SqlReplicationConfig> GetConfiguredReplicationDestinations();
    private bool PrepareSqlReplicationConfig(SqlReplicationConfig cfg, string sqlReplicationConfigDocumentKey, SqlReplicationStatistics replicationStats, SqlReplicationConnections`1<PredefinedSqlConnectionWithConfigurationOrigin> sqlReplicationConnections, bool writeToLog, bool validateSqlReplicationName);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <BackgroundSqlReplication>b__36_0(SqlReplicationConfig x);
}
public class Raven.Database.Bundles.Versioning.Data.FileVersioningConfiguration : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRevisions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeUnlessExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PurgeOnDelete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResetOnRename>k__BackingField;
    public string Id { get; public set; }
    public int MaxRevisions { get; public set; }
    public bool Exclude { get; public set; }
    public bool ExcludeUnlessExplicit { get; public set; }
    public bool PurgeOnDelete { get; public set; }
    public bool ResetOnRename { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public int get_MaxRevisions();
    [CompilerGeneratedAttribute]
public void set_MaxRevisions(int value);
    [CompilerGeneratedAttribute]
public bool get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeUnlessExplicit();
    [CompilerGeneratedAttribute]
public void set_ExcludeUnlessExplicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_PurgeOnDelete();
    [CompilerGeneratedAttribute]
public void set_PurgeOnDelete(bool value);
    [CompilerGeneratedAttribute]
public bool get_ResetOnRename();
    [CompilerGeneratedAttribute]
public void set_ResetOnRename(bool value);
}
public abstract class Raven.Database.Client.Aws.RavenAwsClient : RavenStorageClient {
    public static string DefaultRegion;
    private static bool endpointsLoaded;
    private static Dictionary`2<string, string> Endpoints;
    private string awsAccessKey;
    private Byte[] awsSecretKey;
    [CompilerGeneratedAttribute]
private string <AwsRegion>k__BackingField;
    public string ServiceName { get; }
    protected string AwsRegion { get; private set; }
    protected RavenAwsClient(string awsAccessKey, string awsSecretKey, string awsRegionEndpoint);
    private static RavenAwsClient();
    public abstract virtual string get_ServiceName();
    [CompilerGeneratedAttribute]
protected string get_AwsRegion();
    [CompilerGeneratedAttribute]
private void set_AwsRegion(string value);
    public AuthenticationHeaderValue CalculateAuthorizationHeaderValue(HttpMethod httpMethod, string url, DateTime date, IDictionary`2<string, string> httpHeaders);
    protected Dictionary`2<string, string> ConvertToHeaders(string name, HttpHeaders headers);
    public string GetUrl(string name);
    public abstract virtual string GetHost(string bucketName);
    private static string CalculateCanonicalRequestHash(HttpMethod httpMethod, string url, IDictionary`2<string, string> httpHeaders, String& signedHeaders);
    private Byte[] CalculateSigningKey(DateTime date, string service);
    private string GetAwsRegion(string awsRegionEndpoint);
    private void LoadEndpoints();
    private static void LoadEndpointsFromReader(TextReader reader);
}
public class Raven.Database.Client.Aws.RavenAwsGlacierClient : RavenAwsClient {
    public string ServiceName { get; }
    public RavenAwsGlacierClient(string awsAccessKey, string awsSecretKey, string awsRegionEndpoint);
    public string UploadArchive(string glacierVaultName, Stream stream, string archiveDescription, int timeoutInSeconds);
    public virtual string get_ServiceName();
    public virtual string GetHost(string glacierVaultName);
    private static string ReadArchiveId(HttpResponseMessage response);
}
public static class Raven.Database.Client.Aws.RavenAwsHelper : object {
    private static int OneMegabyte;
    public static string ConvertToString(DateTime date);
    public static string ConvertToHex(Byte[] array);
    public static string CalculatePayloadHash(Stream stream);
    public static string CalculatePayloadTreeHash(Stream stream);
    private static Byte[] CalculateSHA256Hash(Byte[] inputBytes, int count);
    private static Byte[] ComputeSHA256TreeHash(Byte[][] chunkSHA256Hashes);
    private static Byte[][] GetChunkSHA256Hashes(Stream stream);
}
public class Raven.Database.Client.Aws.RavenAwsS3Client : RavenAwsClient {
    private AmazonS3Client _client;
    private static long OneKb;
    public static long OneMb;
    private static long OneGb;
    private static long OneTb;
    internal long MaxUploadPutObjectInBytes;
    internal long MinOnePartUploadSizeLimitInBytes;
    private static long TotalBlocksSizeLimitInBytes;
    public string ServiceName { get; }
    public RavenAwsS3Client(string awsAccessKey, string awsSecretKey, string awsRegionEndpoint);
    private static RavenAwsS3Client();
    public void PutObject(string bucketName, string key, Stream stream, Dictionary`2<string, string> metadata, int timeoutInSeconds);
    [AsyncStateMachineAttribute("Raven.Database.Client.Aws.RavenAwsS3Client/<PutObjectAsync>d__10")]
public Task PutObjectAsync(string bucketName, string key, Stream stream, Dictionary`2<string, string> metadata);
    private static void FillMetadata(MetadataCollection collection, IDictionary`2<string, string> metadata);
    public Blob GetObject(string bucketName, string key);
    public virtual string get_ServiceName();
    public virtual string GetHost(string bucketName);
    public virtual void Dispose();
}
public class Raven.Database.Client.Azure.RavenAzureClient : RavenStorageClient {
    private string accountName;
    private Byte[] accountKey;
    private string azureServerUrl;
    private static string AzureStorageVersion;
    private static int MaxUploadPutBlobInBytes;
    private static int OnePutBlockSizeLimitInBytes;
    private static long TotalBlocksSizeLimitInBytes;
    public RavenAzureClient(string accountName, string accountKey, string containerName, bool isTest);
    private string GetUrl(string containerName, bool isTest);
    [AsyncStateMachineAttribute("Raven.Database.Client.Azure.RavenAzureClient/<PutContainer>d__9")]
public Task PutContainer();
    [AsyncStateMachineAttribute("Raven.Database.Client.Azure.RavenAzureClient/<PutBlob>d__10")]
public Task PutBlob(string key, Stream stream, Dictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Raven.Database.Client.Azure.RavenAzureClient/<PutBlockApi>d__11")]
private Task PutBlockApi(string key, Stream stream, Dictionary`2<string, string> metadata);
    private static void GetExceptionsFromTasks(Task[] tasks);
    private static Task CreateFillQueueTask(Stream inputStream, List`1<string> blockIds, BlockingCollection`1<ByteArrayWithBlockId> queue, CancellationTokenSource cts);
    private Task CreateUploadTask(BlockingCollection`1<ByteArrayWithBlockId> queue, string baseUrl, CancellationTokenSource cts);
    [AsyncStateMachineAttribute("Raven.Database.Client.Azure.RavenAzureClient/<PutBlock>d__16")]
private Task PutBlock(Byte[] streamAsByteArray, HttpClient client, string url, CancellationTokenSource cts, bool retryRequest);
    [AsyncStateMachineAttribute("Raven.Database.Client.Azure.RavenAzureClient/<PutBlockList>d__17")]
private Task PutBlockList(string baseUrl, List`1<string> blockIds, Dictionary`2<string, string> metadata);
    private static XmlDocument CreateXmlDocument(List`1<string> blockIds);
    [AsyncStateMachineAttribute("Raven.Database.Client.Azure.RavenAzureClient/<GetBlob>d__19")]
public Task`1<Blob> GetBlob(string key);
    private AuthenticationHeaderValue CalculateAuthorizationHeaderValue(string httpMethod, string url, HttpHeaders httpHeaders);
    private static string ComputeCanonicalizedHeaders(string httpMethod, HttpHeaders httpHeaders);
    private string ComputeCanonicalizedResource(string url);
}
internal class Raven.Database.Client.EmbeddedDocumentStore : object {
    private RavenDbServer server;
    private bool embeddedFileStoreInitiated;
    public RavenDbServer Server { get; }
    public bool UseEmbeddedHttpServer { get; public set; }
    public InMemoryRavenConfiguration Configuration { get; public set; }
    public DocumentDatabase SystemDatabase { get; }
    public DocumentDatabase DocumentDatabase { get; }
    public IFilesStore FilesStore { get; }
    public string ConnectionStringName { get; public set; }
    public bool RunInMemory { get; public set; }
    public string DataDirectory { get; public set; }
    public bool WasDisposed { get; }
    public NameValueCollection SharedOperationsHeaders { get; }
    public HttpJsonRequestFactory JsonRequestFactory { get; }
    public bool HasJsonRequestFactory { get; }
    public string Identifier { get; public set; }
    public IAsyncDatabaseCommands AsyncDatabaseCommands { get; }
    public IDatabaseCommands DatabaseCommands { get; }
    public DocumentConvention Conventions { get; public set; }
    public string Url { get; public set; }
    public IReliableSubscriptions Subscriptions { get; }
    public IAsyncReliableSubscriptions AsyncSubscriptions { get; }
    public DocumentSessionListeners Listeners { get; }
    public string DefaultDatabase { get; public set; }
    public Guid ResourceManagerId { get; public set; }
    public bool EnlistInDistributedTransactions { get; public set; }
    public DocumentStore DocumentStore { get; }
    public int MaxNumberOfCachedRequests { get; public set; }
    public RavenDbServer get_Server();
    public bool get_UseEmbeddedHttpServer();
    public void set_UseEmbeddedHttpServer(bool value);
    public InMemoryRavenConfiguration get_Configuration();
    public void set_Configuration(InMemoryRavenConfiguration value);
    public DocumentDatabase get_SystemDatabase();
    public DocumentDatabase get_DocumentDatabase();
    public IFilesStore get_FilesStore();
    public string get_ConnectionStringName();
    public void set_ConnectionStringName(string value);
    public bool get_RunInMemory();
    public void set_RunInMemory(bool value);
    public string get_DataDirectory();
    public void set_DataDirectory(string value);
    public sealed virtual void Dispose();
    public sealed virtual void add_AfterDispose(EventHandler value);
    public sealed virtual void remove_AfterDispose(EventHandler value);
    public sealed virtual bool get_WasDisposed();
    public sealed virtual IDatabaseChanges Changes(string database);
    public sealed virtual IDisposable AggressivelyCacheFor(TimeSpan cacheDuration);
    public sealed virtual IDisposable AggressivelyCache();
    public sealed virtual IDisposable DisableAggressiveCaching();
    public sealed virtual IDisposable SetRequestsTimeoutFor(TimeSpan timeout);
    public sealed virtual NameValueCollection get_SharedOperationsHeaders();
    public sealed virtual HttpJsonRequestFactory get_JsonRequestFactory();
    public sealed virtual bool get_HasJsonRequestFactory();
    public sealed virtual string get_Identifier();
    public sealed virtual void set_Identifier(string value);
    public sealed virtual IDocumentStore Initialize();
    public sealed virtual IAsyncDatabaseCommands get_AsyncDatabaseCommands();
    public sealed virtual IAsyncDocumentSession OpenAsyncSession();
    public sealed virtual IAsyncDocumentSession OpenAsyncSession(string database);
    public sealed virtual IAsyncDocumentSession OpenAsyncSession(OpenSessionOptions sessionOptions);
    public sealed virtual IDocumentSession OpenSession();
    public sealed virtual IDocumentSession OpenSession(string database);
    public sealed virtual IDocumentSession OpenSession(OpenSessionOptions sessionOptions);
    public sealed virtual IAsyncDocumentSession OpenNagleAsyncSession();
    public sealed virtual IAsyncDocumentSession OpenNagleAsyncSession(string database);
    public sealed virtual IAsyncDocumentSession OpenNagleAsyncSession(OpenSessionOptions sessionOptions);
    public sealed virtual IDocumentSession OpenNagleSession();
    public sealed virtual IDocumentSession OpenNagleSession(string database);
    public sealed virtual IDocumentSession OpenNagleSession(OpenSessionOptions sessionOptions);
    public sealed virtual IDatabaseCommands get_DatabaseCommands();
    public sealed virtual void ExecuteIndex(AbstractIndexCreationTask indexCreationTask);
    public sealed virtual void ExecuteIndexes(List`1<AbstractIndexCreationTask> indexCreationTasks);
    public sealed virtual void SideBySideExecuteIndexes(List`1<AbstractIndexCreationTask> indexCreationTasks, Etag minimumEtagBeforeReplace, Nullable`1<DateTime> replaceTimeUtc);
    public sealed virtual Task SideBySideExecuteIndexesAsync(List`1<AbstractIndexCreationTask> indexCreationTasks, Etag minimumEtagBeforeReplace, Nullable`1<DateTime> replaceTimeUtc);
    public sealed virtual Task ExecuteIndexAsync(AbstractIndexCreationTask indexCreationTask);
    public sealed virtual Task ExecuteIndexesAsync(List`1<AbstractIndexCreationTask> indexCreationTasks);
    public sealed virtual void SideBySideExecuteIndex(AbstractIndexCreationTask indexCreationTask, Etag minimumEtagBeforeReplace, Nullable`1<DateTime> replaceTimeUtc);
    public sealed virtual Task SideBySideExecuteIndexAsync(AbstractIndexCreationTask indexCreationTask, Etag minimumEtagBeforeReplace, Nullable`1<DateTime> replaceTimeUtc);
    public sealed virtual void ExecuteTransformer(AbstractTransformerCreationTask transformerCreationTask);
    public sealed virtual Task ExecuteTransformerAsync(AbstractTransformerCreationTask transformerCreationTask);
    public sealed virtual DocumentConvention get_Conventions();
    public void set_Conventions(DocumentConvention value);
    public sealed virtual string get_Url();
    public void set_Url(string value);
    public sealed virtual Etag GetLastWrittenEtag();
    public sealed virtual BulkInsertOperation BulkInsert(string database, BulkInsertOptions options);
    public sealed virtual IReliableSubscriptions get_Subscriptions();
    public sealed virtual IAsyncReliableSubscriptions get_AsyncSubscriptions();
    public sealed virtual DocumentSessionListeners get_Listeners();
    public sealed virtual void SetListeners(DocumentSessionListeners listeners);
    public string get_DefaultDatabase();
    public void set_DefaultDatabase(string value);
    public Guid get_ResourceManagerId();
    public void set_ResourceManagerId(Guid value);
    public bool get_EnlistInDistributedTransactions();
    public void set_EnlistInDistributedTransactions(bool value);
    public IDocumentStore RegisterListener(IDocumentStoreListener documentStoreListener);
    public DocumentStoreBase RegisterListener(IDocumentQueryListener queryListener);
    public DocumentStoreBase RegisterListener(IDocumentDeleteListener deleteListener);
    public DocumentStoreBase RegisterListener(IDocumentConversionListener documentConversionListener);
    public DocumentStoreBase RegisterListener(IDocumentConflictListener conflictListener);
    public sealed virtual void InitializeProfiling();
    public sealed virtual ProfilingInformation GetProfilingInformationFor(Guid id);
    public DocumentStore get_DocumentStore();
    public int get_MaxNumberOfCachedRequests();
    public void set_MaxNumberOfCachedRequests(int value);
    [CompilerGeneratedAttribute]
private Task`1<DocumentDatabase> <get_DocumentDatabase>b__13_0();
}
public abstract class Raven.Database.Client.RavenStorageClient : object {
    private List`1<HttpClient> clients;
    protected HttpClient GetClient(Nullable`1<TimeSpan> timeout);
    public virtual void Dispose();
}
public class Raven.Database.Commercial.SupportCoverage : object {
    private static string SupportCoverageList;
    private static string SupportCoverageKeyPrefix;
    private static TimeSpan OneDay;
    private static Timer modreq(System.Runtime.CompilerServices.IsVolatile) supportTimer;
    [CompilerGeneratedAttribute]
private static SupportCoverageResult <CurrentSupport>k__BackingField;
    private DatabasesLandlord landlord;
    private LicensingStatus licensingStatus;
    private ILog log;
    private HttpJsonRequestFactory requestFactory;
    private DocumentConvention conventions;
    public static SupportCoverageResult CurrentSupport { get; private set; }
    private static SupportCoverage();
    [CompilerGeneratedAttribute]
public static SupportCoverageResult get_CurrentSupport();
    [CompilerGeneratedAttribute]
private static void set_CurrentSupport(SupportCoverageResult value);
    public sealed virtual void Dispose();
    private void DeactivateTimer();
    public sealed virtual void Execute(RavenDBOptions serverOptions);
    private void CheckSupportCoverage();
    private void PutSupportCoverage(string id, SupportCoverageResult doc);
    private SupportCoverageResult QueryForSupportCoverage(string id);
    private static SupportCoverageResult CreateDefaultSupportCoverageDocument();
    private LicensingStatus GetLicensingStatus();
    private void OnCurrentLicenseChanged(LicensingStatus newLicense);
    private bool LicenseEqual(LicensingStatus license1, LicensingStatus license2);
    private string GetLicenseId();
    private SupportCoverageResult GetSupportDocument(string id);
    private string GenerateSupportStatusDocKey(string id);
    [CompilerGeneratedAttribute]
private void <Execute>b__15_0(object _);
    [CompilerGeneratedAttribute]
private void <OnCurrentLicenseChanged>b__21_0(object _);
}
public class Raven.Database.Commercial.SupportCoverageResult : object {
    [CompilerGeneratedAttribute]
private SupportCoverageStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <EndsAt>k__BackingField;
    public SupportCoverageStatus Status { get; public set; }
    public Nullable`1<DateTimeOffset> EndsAt { get; public set; }
    [CompilerGeneratedAttribute]
public SupportCoverageStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(SupportCoverageStatus value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_EndsAt();
    [CompilerGeneratedAttribute]
public void set_EndsAt(Nullable`1<DateTimeOffset> value);
}
public enum Raven.Database.Commercial.SupportCoverageStatus : Enum {
    public int value__;
    public static SupportCoverageStatus NoSupport;
    public static SupportCoverageStatus PartialSupport;
    public static SupportCoverageStatus ProfessionalSupport;
    public static SupportCoverageStatus ProductionSupport;
    public static SupportCoverageStatus LicenseNotFound;
    public static SupportCoverageStatus InvalidStateSupportNotFound;
}
internal class Raven.Database.Commercial.ValidateLicense : object {
    [CompilerGeneratedAttribute]
private static LicensingStatus <CurrentLicense>k__BackingField;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, string> <LicenseAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<LicensingStatus> CurrentLicenseChanged;
    private AbstractLicenseValidator licenseValidator;
    private ILog logger;
    private Timer timer;
    private object validationLockObject;
    private static Dictionary`2<string, string> AlwaysOnAttributes;
    public static LicensingStatus CurrentLicense { get; public set; }
    public static Dictionary`2<string, string> LicenseAttributes { get; public set; }
    private static ValidateLicense();
    [CompilerGeneratedAttribute]
public static LicensingStatus get_CurrentLicense();
    [CompilerGeneratedAttribute]
public static void set_CurrentLicense(LicensingStatus value);
    [CompilerGeneratedAttribute]
public static Dictionary`2<string, string> get_LicenseAttributes();
    [CompilerGeneratedAttribute]
public static void set_LicenseAttributes(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public static void add_CurrentLicenseChanged(Action`1<LicensingStatus> value);
    [CompilerGeneratedAttribute]
public static void remove_CurrentLicenseChanged(Action`1<LicensingStatus> value);
    public void Execute(InMemoryRavenConfiguration config);
    public void ForceExecute(InMemoryRavenConfiguration config);
    private void ExecuteInternal(InMemoryRavenConfiguration config, bool firstTime, bool forceUpdate);
    private bool TryLoadLicense(InMemoryRavenConfiguration config);
    private bool IsSameLicense(string value, string fullPath);
    private static string AssertLicenseAttributes(IDictionary`2<string, string> licenseAttributes, LicenseType licenseType);
    private static void ThrowIfStandardLicenseExpired(IDictionary`2<string, string> licenseAttributes, LicenseType licenseType);
    private string GetLicenseText(InMemoryRavenConfiguration config);
    private static string GetLicensePath(InMemoryRavenConfiguration config);
    private void OnMultipleLicensesWereDiscovered(object sender, ClientDiscoveredEventArgs clientDiscoveredEventArgs, string fullPath);
    private void OnLicenseInvalidated(InvalidationType invalidationType, string fullPath);
    public sealed virtual void Dispose();
}
public abstract class Raven.Database.Common.AdminResourceApiController`2 : ResourceApiController`2<TResource, TResourceLandlord> {
    protected WindowsBuiltInRole[] AdditionalSupportedRoles { get; }
    protected virtual WindowsBuiltInRole[] get_AdditionalSupportedRoles();
    protected static bool IsSystemDatabase(string databaseId);
    [AsyncStateMachineAttribute("Raven.Database.Common.AdminResourceApiController`2/<ExecuteAsync>d__3")]
public virtual Task`1<HttpResponseMessage> ExecuteAsync(HttpControllerContext controllerContext, CancellationToken cancellationToken);
    private bool SupportedByAnyAdditionalRoles(IPrincipal user);
    protected static bool IsValidName(string name, string dataDirectory, MessageWithStatusCode& errorMessageWithStatusCode);
    protected bool ParseBoolQueryString(string parameterName);
    protected bool IsAnotherRestoreInProgress(String& resourceName);
    protected bool HasPermissions(string path, HttpResponseMessage& message);
    private bool HasPermissionsOnFolder(string path);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpControllerContext controllerContext, CancellationToken cancellationToken);
}
public interface Raven.Database.Common.IResourceApiController {
    public IResourceStore Resource { get; }
    public InMemoryRavenConfiguration ResourceConfiguration { get; }
    public string ResourceName { get; }
    public ResourceType ResourceType { get; }
    public InMemoryRavenConfiguration SystemConfiguration { get; }
    public DocumentDatabase SystemDatabase { get; }
    public List`1<Action`1<StringBuilder>> CustomRequestTraceInfo { get; }
    public HttpRequestMessage InnerRequest { get; }
    public int InnerRequestsCount { get; }
    public bool IsInternalRequest { get; }
    public bool RejectClientRequests { get; }
    public abstract virtual IResourceStore get_Resource();
    public abstract virtual InMemoryRavenConfiguration get_ResourceConfiguration();
    public abstract virtual string get_ResourceName();
    public abstract virtual ResourceType get_ResourceType();
    public abstract virtual InMemoryRavenConfiguration get_SystemConfiguration();
    public abstract virtual DocumentDatabase get_SystemDatabase();
    public abstract virtual Task`1<RequestWebApiEventArgs> TrySetupRequestToProperResource();
    public abstract virtual List`1<Action`1<StringBuilder>> get_CustomRequestTraceInfo();
    public abstract virtual HttpRequestMessage get_InnerRequest();
    public abstract virtual int get_InnerRequestsCount();
    public abstract virtual bool get_IsInternalRequest();
    public abstract virtual void MarkRequestDuration(long elapsedMilliseconds);
    public abstract virtual bool get_RejectClientRequests();
}
public interface Raven.Database.Common.IResourceApiController`1 {
    public TResource Resource { get; }
    public abstract virtual TResource get_Resource();
}
public interface Raven.Database.Common.IResourceLandlord`1 {
    public ConcurrentDictionary`2<string, DateTime> LastRecentlyUsed { get; }
    public abstract virtual Task`1<TResource> GetResourceInternal(string resourceName);
    public abstract virtual bool TryGetOrCreateResourceStore(string resourceName, Task`1& resourceTask);
    public abstract virtual ConcurrentDictionary`2<string, DateTime> get_LastRecentlyUsed();
    public abstract virtual InMemoryRavenConfiguration GetSystemConfiguration();
}
public interface Raven.Database.Common.IResourceStore {
    public string Name { get; }
    public string ResourceName { get; }
    public TransportState TransportState { get; }
    public AtomicDictionary`1<object> ExtensionsState { get; }
    public InMemoryRavenConfiguration Configuration { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_ResourceName();
    public abstract virtual TransportState get_TransportState();
    public abstract virtual AtomicDictionary`1<object> get_ExtensionsState();
    public abstract virtual InMemoryRavenConfiguration get_Configuration();
}
public abstract class Raven.Database.Common.ResourceApiController`2 : RavenBaseApiController {
    private Nullable`1<int> _maxSecondsForTaskToWaitForResourceToLoad;
    private string _resourcePrefix;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    private SemaphoreSlim _maxNumberOfThreadsForResourceToLoadSemaphore;
    private TResourceLandlord _resourceLandlord;
    private TResource _resource;
    public ResourceType ResourceType { get; }
    public int MaxSecondsForTaskToWaitForResourceToLoad { get; }
    public string ResourcePrefix { get; }
    public string ResourceName { get; protected set; }
    public SemaphoreSlim MaxNumberOfThreadsForResourceToLoadSemaphore { get; }
    private IResourceStore Raven.Database.Common.IResourceApiController.Resource { get; }
    public InMemoryRavenConfiguration ResourceConfiguration { get; }
    public TResourceLandlord ResourceLandlord { get; }
    public TResource Resource { get; }
    public DocumentDatabase SystemDatabase { get; }
    public InMemoryRavenConfiguration SystemConfiguration { get; }
    public bool RejectClientRequests { get; }
    public abstract virtual ResourceType get_ResourceType();
    public int get_MaxSecondsForTaskToWaitForResourceToLoad();
    public virtual string get_ResourcePrefix();
    [CompilerGeneratedAttribute]
public virtual string get_ResourceName();
    [CompilerGeneratedAttribute]
protected virtual void set_ResourceName(string value);
    public SemaphoreSlim get_MaxNumberOfThreadsForResourceToLoadSemaphore();
    private sealed virtual override IResourceStore Raven.Database.Common.IResourceApiController.get_Resource();
    public virtual InMemoryRavenConfiguration get_ResourceConfiguration();
    public TResourceLandlord get_ResourceLandlord();
    public sealed virtual TResource get_Resource();
    public sealed virtual DocumentDatabase get_SystemDatabase();
    public virtual InMemoryRavenConfiguration get_SystemConfiguration();
    public void SetResource(TResource resource);
    protected bool EnsureSystemDatabase();
    protected virtual void InnerInitialization(HttpControllerContext controllerContext);
    private string GetResourceName(HttpControllerContext controllerContext, ResourceType resourceType);
    [AsyncStateMachineAttribute("Raven.Database.Common.ResourceApiController`2/<TrySetupRequestToProperResource>d__33")]
public virtual Task`1<RequestWebApiEventArgs> TrySetupRequestToProperResource();
    public sealed virtual bool get_RejectClientRequests();
    [AsyncStateMachineAttribute("Raven.Database.Common.ResourceApiController`2/<ExecuteAsync>d__36")]
public virtual Task`1<HttpResponseMessage> ExecuteAsync(HttpControllerContext controllerContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Raven.Database.Common.ResourceApiController`2/<ExecuteActualRequest>d__37")]
private Task`1<HttpResponseMessage> ExecuteActualRequest(HttpControllerContext controllerContext, CancellationToken cancellationToken, MixedModeRequestAuthorizer authorizer);
    protected string GetResourceNameUrlKey(ResourceType resourceType);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpControllerContext controllerContext, CancellationToken cancellationToken);
}
public enum Raven.Database.Common.ResourceType : Enum {
    public int value__;
    public static ResourceType Database;
    public static ResourceType FileSystem;
    public static ResourceType TimeSeries;
    public static ResourceType Counter;
}
internal class Raven.Database.Config.ConfigOptionDocs : object {
    public static ConfigOptionDocs OptionsDocs;
    private List`1<ConfigOption> inner;
    private static ConfigOptionDocs();
    [IteratorStateMachineAttribute("Raven.Database.Config.ConfigOptionDocs/<GetEnumerator>d__3")]
public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void Add(string option, string type, string range, string doc);
}
public static class Raven.Database.Config.CpuStatistics : object {
    private static float HighNotificationThreshold;
    private static float LowNotificationThreshold;
    private static int NumberOfItemsInQueue;
    private static Single[] LastUsages;
    private static ConcurrentSet`1<WeakReference`1<ICpuUsageHandler>> CpuUsageHandlers;
    private static ILog Log;
    private static int nextWriteIndex;
    private static ManualResetEventSlim _domainUnload;
    private static bool dynamicLoadBalancing;
    [CompilerGeneratedAttribute]
private static double <Average>k__BackingField;
    public static FixedSizeConcurrentQueue`1<CpuUsageCallsRecord> CpuUsageCallsRecordsQueue;
    public static double Average { get; private set; }
    private static CpuStatistics();
    [CompilerGeneratedAttribute]
public static double get_Average();
    [CompilerGeneratedAttribute]
private static void set_Average(double value);
    public static void HandleCpuUsage(float usageInPercents);
    public static void RegisterCpuUsageHandler(ICpuUsageHandler handler);
    private static void RunCpuUsageHandlers(Action`1<ICpuUsageHandler> action);
}
public class Raven.Database.Config.CpuUsage : object {
    private ulong _previousIdleTicks;
    private ulong _previousTotalTicks;
    private float _previousResult;
    private static bool GetSystemTimes(FILETIME& lpIdleTime, FILETIME& lpKernelTime, FILETIME& lpUserTime);
    public float GetCurrentUsage();
    private ulong FileTimeToULong(FILETIME time);
}
public class Raven.Database.Config.GlobalSettingsDocument : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <SecuredSettings>k__BackingField;
    public Dictionary`2<string, string> Settings { get; public set; }
    public Dictionary`2<string, string> SecuredSettings { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_SecuredSettings();
    [CompilerGeneratedAttribute]
public void set_SecuredSettings(Dictionary`2<string, string> value);
}
internal static class Raven.Database.Config.GlobalSettingsDocumentProtector : object {
    private static ILog Logger;
    private static GlobalSettingsDocumentProtector();
    internal static void Protect(GlobalSettingsDocument settings);
    internal static void Unprotect(GlobalSettingsDocument settings);
}
public interface Raven.Database.Config.ICpuUsageHandler {
    public abstract virtual void HandleHighCpuUsage();
    public abstract virtual void HandleLowCpuUsage();
}
public interface Raven.Database.Config.ILowMemoryHandler {
    public abstract virtual LowMemoryHandlerStatistics HandleLowMemory();
    public abstract virtual LowMemoryHandlerStatistics GetStats();
}
public enum Raven.Database.Config.ImplicitFetchFieldsMode : Enum {
    public int value__;
    public static ImplicitFetchFieldsMode Enabled;
    public static ImplicitFetchFieldsMode DoNothing;
    public static ImplicitFetchFieldsMode Exception;
}
public class Raven.Database.Config.InMemoryRavenConfiguration : object {
    public static string VoronTypeName;
    public static string EsentTypeName;
    private CompositionContainer container;
    private bool containerExternallySet;
    private string pluginsDirectory;
    [CompilerGeneratedAttribute]
private ReplicationConfiguration <Replication>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlReplicationConfiguration <SqlReplication>k__BackingField;
    [CompilerGeneratedAttribute]
private PrefetcherConfiguration <Prefetcher>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageConfiguration <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemConfiguration <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterConfiguration <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesConfiguration <TimeSeries>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionConfiguration <Encryption>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingConfiguration <Indexing>k__BackingField;
    [CompilerGeneratedAttribute]
private ClusterConfiguration <Cluster>k__BackingField;
    [CompilerGeneratedAttribute]
private MonitoringConfiguration <Monitoring>k__BackingField;
    [CompilerGeneratedAttribute]
private WebSocketsConfiguration <WebSockets>k__BackingField;
    [CompilerGeneratedAttribute]
private StudioConfiguration <Studio>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileSystemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterStorageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeSeriesName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxPrecomputedBatchSizeForNewIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxPrecomputedBatchTotalDocumentSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ConcurrentResourceLoadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrentResourceLoads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxClauseCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSecondsForTaskToWaitForDatabaseToLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexAndTransformerReplicationLatencyInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowScriptsToAdjustNumberOfSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TombstoneRetentionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrentServerRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrentRequestsForDatabaseDuringLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrentMultiGetRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PrefetchingDurationLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <BulkImportBatchTimeout>k__BackingField;
    [JsonIgnoreAttribute]
public SemaphoreSlim ConcurrentMultiGetRequests;
    [CompilerGeneratedAttribute]
private TimeSpan <DatabaseOperationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToWaitBeforeRunningIdleIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToWaitBeforeRunningAbandonedIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToWaitBeforeMarkingAutoIndexAsIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToWaitBeforeMarkingIdleIndexAsAbandoned>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CheckReferenceBecauseOfDocumentUpdateTimeout>k__BackingField;
    private HashSet`1<string> headersToIgnore;
    [CompilerGeneratedAttribute]
private TaskScheduler <CustomTaskScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedirectStudioUrl>k__BackingField;
    private static Lazy`1<Byte[]> DefaultOauthKey;
    [CompilerGeneratedAttribute]
private NameValueCollection <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResetIndexOnUncleanShutdown>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinThreadPoolWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinThreadPoolCompletionThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxPageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MemoryCacheLimitPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MemoryCacheLimitMegabytes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MemoryCacheLimitCheckInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexingClassifier <IndexingClassifier>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfItemsToProcessInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialNumberOfItemsToProcessInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfItemsToReduceInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InitialNumberOfItemsToReduceInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfItemsToExecuteReduceInSingleStep>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewIndexInMemoryMaxBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExposeConfigOverTheWire>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AccessControlAllowOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessControlMaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessControlAllowMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessControlRequestHeaders>k__BackingField;
    private string virtualDirectory;
    [CompilerGeneratedAttribute]
private bool <HttpCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private AnonymousUserAccessMode <AnonymousUserAccessMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RejectClientsMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <OAuthTokenKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IgnoreSslCertificateErrorsMode <IgnoreSslCertificateErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    private string defaultStorageTypeName;
    private bool runInMemory;
    [CompilerGeneratedAttribute]
private bool <DisableInMemoryIndexing>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionMode <TransactionMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WebDir>k__BackingField;
    private string assembliesDirectory;
    [CompilerGeneratedAttribute]
private string <EmbeddedFilesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreatePluginsDirectoryIfNotExisting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateAnalyzersDirectoryIfNotExisting>k__BackingField;
    private string compiledIndexCacheDirectory;
    [CompilerGeneratedAttribute]
private string <OAuthTokenServer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableDocumentPreFetching>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfItemsToPreFetch>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregateCatalog <Catalog>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunInUnreliableYetFastModeThatIsNotSuitableForProduction>k__BackingField;
    private string indexStoragePath;
    private string countersDataDirectory;
    private Nullable`1<int> maxNumberOfParallelIndexTasks;
    private static AssemblyCatalog CurrentAssemblyCatalog;
    [CompilerGeneratedAttribute]
private TimeSpan <MemoryCacheExpiration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateAutoIndexesForAdHocQueriesIfNeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxIndexCommitPointStoreTimeInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MinIndexingTimeIntervalToStoreCommitPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfStoredCommitPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MemoryLimitForProcessingInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<InMemoryRavenConfiguration, IDocumentCacher> <CustomMemoryCacher>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LowMemoryForLinuxDetectionInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AvailableMemoryForRaisingBatchSizeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxProcessingRunLatency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTenantDatabase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableClusterDiscovery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TurnOffDiscoveryClient>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxStepsForScript>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AdditionalStepsForScriptBasedOnDocumentSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxIndexWritesBeforeRecreate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSimpleIndexOutputsPerDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxMapReduceIndexOutputsPerDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <PrewarmFacetsOnIndexingMaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <PrewarmFacetsSyncronousWaitTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FlushIndexToDiskSizeInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableResponseLoggingForEmbeddedDatabases>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EmbeddedResponseStreamMaxCachedBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <NewIndexInMemoryMaxTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitFetchFieldsMode <ImplicitFetchFieldsFromDocumentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheDocumentsInMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempPath>k__BackingField;
    public ReplicationConfiguration Replication { get; private set; }
    public SqlReplicationConfiguration SqlReplication { get; private set; }
    public PrefetcherConfiguration Prefetcher { get; private set; }
    public StorageConfiguration Storage { get; private set; }
    public FileSystemConfiguration FileSystem { get; private set; }
    public CounterConfiguration Counter { get; private set; }
    public TimeSeriesConfiguration TimeSeries { get; private set; }
    public EncryptionConfiguration Encryption { get; private set; }
    public IndexingConfiguration Indexing { get; public set; }
    public ClusterConfiguration Cluster { get; private set; }
    public MonitoringConfiguration Monitoring { get; private set; }
    public WebSocketsConfiguration WebSockets { get; private set; }
    public StudioConfiguration Studio { get; private set; }
    public string DatabaseName { get; public set; }
    public string FileSystemName { get; public set; }
    public string CounterStorageName { get; public set; }
    public string TimeSeriesName { get; public set; }
    public int MaxPrecomputedBatchSizeForNewIndex { get; public set; }
    public int MaxPrecomputedBatchTotalDocumentSizeInBytes { get; public set; }
    public TimeSpan ConcurrentResourceLoadTimeout { get; private set; }
    public int MaxConcurrentResourceLoads { get; private set; }
    public int MaxClauseCount { get; public set; }
    public int MaxSecondsForTaskToWaitForDatabaseToLoad { get; public set; }
    public int IndexAndTransformerReplicationLatencyInSec { get; internal set; }
    public bool AllowScriptsToAdjustNumberOfSteps { get; public set; }
    public TimeSpan TombstoneRetentionTime { get; public set; }
    public int MaxConcurrentServerRequests { get; public set; }
    public int MaxConcurrentRequestsForDatabaseDuringLoad { get; public set; }
    public int MaxConcurrentMultiGetRequests { get; public set; }
    public int PrefetchingDurationLimit { get; private set; }
    public TimeSpan BulkImportBatchTimeout { get; public set; }
    public TimeSpan DatabaseOperationTimeout { get; public set; }
    public TimeSpan TimeToWaitBeforeRunningIdleIndexes { get; internal set; }
    public TimeSpan TimeToWaitBeforeRunningAbandonedIndexes { get; private set; }
    public TimeSpan TimeToWaitBeforeMarkingAutoIndexAsIdle { get; private set; }
    public TimeSpan TimeToWaitBeforeMarkingIdleIndexAsAbandoned { get; private set; }
    public TimeSpan CheckReferenceBecauseOfDocumentUpdateTimeout { get; public set; }
    public IEnumerable`1<string> ActiveBundles { get; }
    public HashSet`1<string> HeadersToIgnore { get; }
    public TaskScheduler CustomTaskScheduler { get; public set; }
    public string RedirectStudioUrl { get; public set; }
    public bool UseDefaultOAuthTokenServer { get; }
    public NameValueCollection Settings { get; public set; }
    public string ServerUrl { get; }
    public bool ResetIndexOnUncleanShutdown { get; public set; }
    public int MinThreadPoolWorkerThreads { get; public set; }
    public int MinThreadPoolCompletionThreads { get; public set; }
    public int MaxPageSize { get; public set; }
    public int MemoryCacheLimitPercentage { get; public set; }
    public int MemoryCacheLimitMegabytes { get; public set; }
    public TimeSpan MemoryCacheLimitCheckInterval { get; public set; }
    public IIndexingClassifier IndexingClassifier { get; public set; }
    public int MaxNumberOfItemsToProcessInSingleBatch { get; public set; }
    public int InitialNumberOfItemsToProcessInSingleBatch { get; public set; }
    public int MaxNumberOfItemsToReduceInSingleBatch { get; public set; }
    public int InitialNumberOfItemsToReduceInSingleBatch { get; public set; }
    public int NumberOfItemsToExecuteReduceInSingleStep { get; public set; }
    public int MaxNumberOfParallelProcessingTasks { get; public set; }
    public int NewIndexInMemoryMaxBytes { get; public set; }
    public string HostName { get; public set; }
    public int Port { get; public set; }
    public string ExposeConfigOverTheWire { get; public set; }
    public HashSet`1<string> AccessControlAllowOrigin { get; public set; }
    public string AccessControlMaxAge { get; public set; }
    public string AccessControlAllowMethods { get; public set; }
    public string AccessControlRequestHeaders { get; public set; }
    public string VirtualDirectory { get; public set; }
    public bool HttpCompression { get; public set; }
    public AnonymousUserAccessMode AnonymousUserAccessMode { get; public set; }
    public bool RejectClientsMode { get; public set; }
    public Byte[] OAuthTokenKey { get; public set; }
    public IgnoreSslCertificateErrorsMode IgnoreSslCertificateErrors { get; public set; }
    public string WorkingDirectory { get; private set; }
    public string DataDirectory { get; public set; }
    public string DefaultStorageTypeName { get; public set; }
    public bool RunInMemory { get; public set; }
    public bool DisableInMemoryIndexing { get; public set; }
    public TransactionMode TransactionMode { get; public set; }
    public string WebDir { get; public set; }
    public string PluginsDirectory { get; public set; }
    public string AssembliesDirectory { get; public set; }
    public string EmbeddedFilesDirectory { get; public set; }
    public bool CreatePluginsDirectoryIfNotExisting { get; public set; }
    public bool CreateAnalyzersDirectoryIfNotExisting { get; public set; }
    public string CompiledIndexCacheDirectory { get; public set; }
    public string OAuthTokenServer { get; public set; }
    [JsonIgnoreAttribute]
public CompositionContainer Container { get; public set; }
    public bool DisableDocumentPreFetching { get; public set; }
    public int MaxNumberOfItemsToPreFetch { get; public set; }
    [JsonIgnoreAttribute]
public AggregateCatalog Catalog { get; public set; }
    public bool RunInUnreliableYetFastModeThatIsNotSuitableForProduction { get; public set; }
    public TimeSpan MemoryCacheExpiration { get; public set; }
    public bool CreateAutoIndexesForAdHocQueriesIfNeeded { get; public set; }
    public TimeSpan MaxIndexCommitPointStoreTimeInterval { get; public set; }
    public TimeSpan MinIndexingTimeIntervalToStoreCommitPoint { get; public set; }
    public int MaxNumberOfStoredCommitPoints { get; public set; }
    public int MemoryLimitForProcessingInMb { get; public set; }
    public Func`2<InMemoryRavenConfiguration, IDocumentCacher> CustomMemoryCacher { get; public set; }
    public long DynamicMemoryLimitForProcessing { get; }
    public int LowMemoryForLinuxDetectionInMB { get; public set; }
    public string IndexStoragePath { get; public set; }
    public int AvailableMemoryForRaisingBatchSizeLimit { get; public set; }
    public TimeSpan MaxProcessingRunLatency { get; public set; }
    internal bool IsTenantDatabase { get; internal set; }
    public bool DisableClusterDiscovery { get; public set; }
    public bool TurnOffDiscoveryClient { get; public set; }
    public string ServerName { get; public set; }
    public int MaxStepsForScript { get; public set; }
    public int AdditionalStepsForScriptBasedOnDocumentSize { get; public set; }
    public int MaxIndexWritesBeforeRecreate { get; public set; }
    public int MaxSimpleIndexOutputsPerDocument { get; public set; }
    public int MaxMapReduceIndexOutputsPerDocument { get; public set; }
    [BrowsableAttribute("False")]
public TimeSpan PrewarmFacetsOnIndexingMaxAge { get; public set; }
    public TimeSpan PrewarmFacetsSyncronousWaitTime { get; public set; }
    public long FlushIndexToDiskSizeInMb { get; public set; }
    public bool EnableResponseLoggingForEmbeddedDatabases { get; public set; }
    public int EmbeddedResponseStreamMaxCachedBlocks { get; public set; }
    public TimeSpan NewIndexInMemoryMaxTime { get; public set; }
    public ImplicitFetchFieldsMode ImplicitFetchFieldsFromDocumentMode { get; public set; }
    public bool CacheDocumentsInMemory { get; public set; }
    public string TempPath { get; public set; }
    private static InMemoryRavenConfiguration();
    [CompilerGeneratedAttribute]
public ReplicationConfiguration get_Replication();
    [CompilerGeneratedAttribute]
private void set_Replication(ReplicationConfiguration value);
    [CompilerGeneratedAttribute]
public SqlReplicationConfiguration get_SqlReplication();
    [CompilerGeneratedAttribute]
private void set_SqlReplication(SqlReplicationConfiguration value);
    [CompilerGeneratedAttribute]
public PrefetcherConfiguration get_Prefetcher();
    [CompilerGeneratedAttribute]
private void set_Prefetcher(PrefetcherConfiguration value);
    [CompilerGeneratedAttribute]
public StorageConfiguration get_Storage();
    [CompilerGeneratedAttribute]
private void set_Storage(StorageConfiguration value);
    [CompilerGeneratedAttribute]
public FileSystemConfiguration get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(FileSystemConfiguration value);
    [CompilerGeneratedAttribute]
public CounterConfiguration get_Counter();
    [CompilerGeneratedAttribute]
private void set_Counter(CounterConfiguration value);
    [CompilerGeneratedAttribute]
public TimeSeriesConfiguration get_TimeSeries();
    [CompilerGeneratedAttribute]
private void set_TimeSeries(TimeSeriesConfiguration value);
    [CompilerGeneratedAttribute]
public EncryptionConfiguration get_Encryption();
    [CompilerGeneratedAttribute]
private void set_Encryption(EncryptionConfiguration value);
    [CompilerGeneratedAttribute]
public IndexingConfiguration get_Indexing();
    [CompilerGeneratedAttribute]
public void set_Indexing(IndexingConfiguration value);
    [CompilerGeneratedAttribute]
public ClusterConfiguration get_Cluster();
    [CompilerGeneratedAttribute]
private void set_Cluster(ClusterConfiguration value);
    [CompilerGeneratedAttribute]
public MonitoringConfiguration get_Monitoring();
    [CompilerGeneratedAttribute]
private void set_Monitoring(MonitoringConfiguration value);
    [CompilerGeneratedAttribute]
public WebSocketsConfiguration get_WebSockets();
    [CompilerGeneratedAttribute]
private void set_WebSockets(WebSocketsConfiguration value);
    [CompilerGeneratedAttribute]
public StudioConfiguration get_Studio();
    [CompilerGeneratedAttribute]
private void set_Studio(StudioConfiguration value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [CompilerGeneratedAttribute]
public string get_FileSystemName();
    [CompilerGeneratedAttribute]
public void set_FileSystemName(string value);
    [CompilerGeneratedAttribute]
public string get_CounterStorageName();
    [CompilerGeneratedAttribute]
public void set_CounterStorageName(string value);
    [CompilerGeneratedAttribute]
public string get_TimeSeriesName();
    [CompilerGeneratedAttribute]
public void set_TimeSeriesName(string value);
    public void PostInit();
    public InMemoryRavenConfiguration Initialize();
    private void FillMonitoringSettings(StronglyTypedRavenSettings settings);
    private static string CalculateWorkingDirectory(string workingDirectory);
    [CompilerGeneratedAttribute]
public int get_MaxPrecomputedBatchSizeForNewIndex();
    [CompilerGeneratedAttribute]
public void set_MaxPrecomputedBatchSizeForNewIndex(int value);
    [CompilerGeneratedAttribute]
public int get_MaxPrecomputedBatchTotalDocumentSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_MaxPrecomputedBatchTotalDocumentSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ConcurrentResourceLoadTimeout();
    [CompilerGeneratedAttribute]
private void set_ConcurrentResourceLoadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrentResourceLoads();
    [CompilerGeneratedAttribute]
private void set_MaxConcurrentResourceLoads(int value);
    [CompilerGeneratedAttribute]
public int get_MaxClauseCount();
    [CompilerGeneratedAttribute]
public void set_MaxClauseCount(int value);
    [CompilerGeneratedAttribute]
public int get_MaxSecondsForTaskToWaitForDatabaseToLoad();
    [CompilerGeneratedAttribute]
public void set_MaxSecondsForTaskToWaitForDatabaseToLoad(int value);
    [CompilerGeneratedAttribute]
public int get_IndexAndTransformerReplicationLatencyInSec();
    [CompilerGeneratedAttribute]
internal void set_IndexAndTransformerReplicationLatencyInSec(int value);
    [CompilerGeneratedAttribute]
public bool get_AllowScriptsToAdjustNumberOfSteps();
    [CompilerGeneratedAttribute]
public void set_AllowScriptsToAdjustNumberOfSteps(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TombstoneRetentionTime();
    [CompilerGeneratedAttribute]
public void set_TombstoneRetentionTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrentServerRequests();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrentServerRequests(int value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrentRequestsForDatabaseDuringLoad();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrentRequestsForDatabaseDuringLoad(int value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrentMultiGetRequests();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrentMultiGetRequests(int value);
    [CompilerGeneratedAttribute]
public int get_PrefetchingDurationLimit();
    [CompilerGeneratedAttribute]
private void set_PrefetchingDurationLimit(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_BulkImportBatchTimeout();
    [CompilerGeneratedAttribute]
public void set_BulkImportBatchTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DatabaseOperationTimeout();
    [CompilerGeneratedAttribute]
public void set_DatabaseOperationTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToWaitBeforeRunningIdleIndexes();
    [CompilerGeneratedAttribute]
internal void set_TimeToWaitBeforeRunningIdleIndexes(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToWaitBeforeRunningAbandonedIndexes();
    [CompilerGeneratedAttribute]
private void set_TimeToWaitBeforeRunningAbandonedIndexes(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToWaitBeforeMarkingAutoIndexAsIdle();
    [CompilerGeneratedAttribute]
private void set_TimeToWaitBeforeMarkingAutoIndexAsIdle(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToWaitBeforeMarkingIdleIndexAsAbandoned();
    [CompilerGeneratedAttribute]
private void set_TimeToWaitBeforeMarkingIdleIndexAsAbandoned(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_CheckReferenceBecauseOfDocumentUpdateTimeout();
    [CompilerGeneratedAttribute]
public void set_CheckReferenceBecauseOfDocumentUpdateTimeout(TimeSpan value);
    private void CheckDirectoryPermissions();
    private void FilterActiveBundles();
    public IEnumerable`1<string> get_ActiveBundles();
    public HashSet`1<string> get_HeadersToIgnore();
    internal static ComposablePartCatalog GetUnfilteredCatalogs(ICollection`1<ComposablePartCatalog> catalogs);
    private static ComposablePartCatalog GetUnfilteredCatalog(ComposablePartCatalog x);
    [CompilerGeneratedAttribute]
public TaskScheduler get_CustomTaskScheduler();
    [CompilerGeneratedAttribute]
public void set_CustomTaskScheduler(TaskScheduler value);
    [CompilerGeneratedAttribute]
public string get_RedirectStudioUrl();
    [CompilerGeneratedAttribute]
public void set_RedirectStudioUrl(string value);
    private void SetupTransactionMode();
    private void SetVirtualDirectory();
    public bool get_UseDefaultOAuthTokenServer();
    private void SetupOAuth();
    private void SetupGC();
    private Byte[] GetOAuthKey();
    [CompilerGeneratedAttribute]
public NameValueCollection get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(NameValueCollection value);
    public string get_ServerUrl();
    [CompilerGeneratedAttribute]
public bool get_ResetIndexOnUncleanShutdown();
    [CompilerGeneratedAttribute]
public void set_ResetIndexOnUncleanShutdown(bool value);
    [CompilerGeneratedAttribute]
public int get_MinThreadPoolWorkerThreads();
    [CompilerGeneratedAttribute]
public void set_MinThreadPoolWorkerThreads(int value);
    [CompilerGeneratedAttribute]
public int get_MinThreadPoolCompletionThreads();
    [CompilerGeneratedAttribute]
public void set_MinThreadPoolCompletionThreads(int value);
    [CompilerGeneratedAttribute]
public int get_MaxPageSize();
    [CompilerGeneratedAttribute]
public void set_MaxPageSize(int value);
    [CompilerGeneratedAttribute]
public int get_MemoryCacheLimitPercentage();
    [CompilerGeneratedAttribute]
public void set_MemoryCacheLimitPercentage(int value);
    [CompilerGeneratedAttribute]
public int get_MemoryCacheLimitMegabytes();
    [CompilerGeneratedAttribute]
public void set_MemoryCacheLimitMegabytes(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MemoryCacheLimitCheckInterval();
    [CompilerGeneratedAttribute]
public void set_MemoryCacheLimitCheckInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public IIndexingClassifier get_IndexingClassifier();
    [CompilerGeneratedAttribute]
public void set_IndexingClassifier(IIndexingClassifier value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfItemsToProcessInSingleBatch();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfItemsToProcessInSingleBatch(int value);
    [CompilerGeneratedAttribute]
public int get_InitialNumberOfItemsToProcessInSingleBatch();
    [CompilerGeneratedAttribute]
public void set_InitialNumberOfItemsToProcessInSingleBatch(int value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfItemsToReduceInSingleBatch();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfItemsToReduceInSingleBatch(int value);
    [CompilerGeneratedAttribute]
public int get_InitialNumberOfItemsToReduceInSingleBatch();
    [CompilerGeneratedAttribute]
public void set_InitialNumberOfItemsToReduceInSingleBatch(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfItemsToExecuteReduceInSingleStep();
    [CompilerGeneratedAttribute]
public void set_NumberOfItemsToExecuteReduceInSingleStep(int value);
    public int get_MaxNumberOfParallelProcessingTasks();
    public void set_MaxNumberOfParallelProcessingTasks(int value);
    [CompilerGeneratedAttribute]
public int get_NewIndexInMemoryMaxBytes();
    [CompilerGeneratedAttribute]
public void set_NewIndexInMemoryMaxBytes(int value);
    [CompilerGeneratedAttribute]
public string get_HostName();
    [CompilerGeneratedAttribute]
public void set_HostName(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public string get_ExposeConfigOverTheWire();
    [CompilerGeneratedAttribute]
public void set_ExposeConfigOverTheWire(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_AccessControlAllowOrigin();
    [CompilerGeneratedAttribute]
public void set_AccessControlAllowOrigin(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public string get_AccessControlMaxAge();
    [CompilerGeneratedAttribute]
public void set_AccessControlMaxAge(string value);
    [CompilerGeneratedAttribute]
public string get_AccessControlAllowMethods();
    [CompilerGeneratedAttribute]
public void set_AccessControlAllowMethods(string value);
    [CompilerGeneratedAttribute]
public string get_AccessControlRequestHeaders();
    [CompilerGeneratedAttribute]
public void set_AccessControlRequestHeaders(string value);
    public string get_VirtualDirectory();
    public void set_VirtualDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_HttpCompression();
    [CompilerGeneratedAttribute]
public void set_HttpCompression(bool value);
    [CompilerGeneratedAttribute]
public AnonymousUserAccessMode get_AnonymousUserAccessMode();
    [CompilerGeneratedAttribute]
public void set_AnonymousUserAccessMode(AnonymousUserAccessMode value);
    [CompilerGeneratedAttribute]
public bool get_RejectClientsMode();
    [CompilerGeneratedAttribute]
public void set_RejectClientsMode(bool value);
    [CompilerGeneratedAttribute]
public Byte[] get_OAuthTokenKey();
    [CompilerGeneratedAttribute]
public void set_OAuthTokenKey(Byte[] value);
    [CompilerGeneratedAttribute]
public IgnoreSslCertificateErrorsMode get_IgnoreSslCertificateErrors();
    [CompilerGeneratedAttribute]
public void set_IgnoreSslCertificateErrors(IgnoreSslCertificateErrorsMode value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
private void set_WorkingDirectory(string value);
    public string get_DataDirectory();
    public void set_DataDirectory(string value);
    public string get_DefaultStorageTypeName();
    public void set_DefaultStorageTypeName(string value);
    public bool get_RunInMemory();
    public void set_RunInMemory(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableInMemoryIndexing();
    [CompilerGeneratedAttribute]
public void set_DisableInMemoryIndexing(bool value);
    [CompilerGeneratedAttribute]
public TransactionMode get_TransactionMode();
    [CompilerGeneratedAttribute]
public void set_TransactionMode(TransactionMode value);
    [CompilerGeneratedAttribute]
public string get_WebDir();
    [CompilerGeneratedAttribute]
public void set_WebDir(string value);
    public string get_PluginsDirectory();
    public void set_PluginsDirectory(string value);
    public string get_AssembliesDirectory();
    public void set_AssembliesDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_EmbeddedFilesDirectory();
    [CompilerGeneratedAttribute]
public void set_EmbeddedFilesDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_CreatePluginsDirectoryIfNotExisting();
    [CompilerGeneratedAttribute]
public void set_CreatePluginsDirectoryIfNotExisting(bool value);
    [CompilerGeneratedAttribute]
public bool get_CreateAnalyzersDirectoryIfNotExisting();
    [CompilerGeneratedAttribute]
public void set_CreateAnalyzersDirectoryIfNotExisting(bool value);
    public string get_CompiledIndexCacheDirectory();
    public void set_CompiledIndexCacheDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_OAuthTokenServer();
    [CompilerGeneratedAttribute]
public void set_OAuthTokenServer(string value);
    public CompositionContainer get_Container();
    public void set_Container(CompositionContainer value);
    [CompilerGeneratedAttribute]
public bool get_DisableDocumentPreFetching();
    [CompilerGeneratedAttribute]
public void set_DisableDocumentPreFetching(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfItemsToPreFetch();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfItemsToPreFetch(int value);
    [CompilerGeneratedAttribute]
public AggregateCatalog get_Catalog();
    [CompilerGeneratedAttribute]
public void set_Catalog(AggregateCatalog value);
    [CompilerGeneratedAttribute]
public bool get_RunInUnreliableYetFastModeThatIsNotSuitableForProduction();
    [CompilerGeneratedAttribute]
public void set_RunInUnreliableYetFastModeThatIsNotSuitableForProduction(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MemoryCacheExpiration();
    [CompilerGeneratedAttribute]
public void set_MemoryCacheExpiration(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_CreateAutoIndexesForAdHocQueriesIfNeeded();
    [CompilerGeneratedAttribute]
public void set_CreateAutoIndexesForAdHocQueriesIfNeeded(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxIndexCommitPointStoreTimeInterval();
    [CompilerGeneratedAttribute]
public void set_MaxIndexCommitPointStoreTimeInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MinIndexingTimeIntervalToStoreCommitPoint();
    [CompilerGeneratedAttribute]
public void set_MinIndexingTimeIntervalToStoreCommitPoint(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfStoredCommitPoints();
    [CompilerGeneratedAttribute]
public void set_MaxNumberOfStoredCommitPoints(int value);
    [CompilerGeneratedAttribute]
public int get_MemoryLimitForProcessingInMb();
    [CompilerGeneratedAttribute]
public void set_MemoryLimitForProcessingInMb(int value);
    [CompilerGeneratedAttribute]
public Func`2<InMemoryRavenConfiguration, IDocumentCacher> get_CustomMemoryCacher();
    [CompilerGeneratedAttribute]
public void set_CustomMemoryCacher(Func`2<InMemoryRavenConfiguration, IDocumentCacher> value);
    public long get_DynamicMemoryLimitForProcessing();
    [CompilerGeneratedAttribute]
public int get_LowMemoryForLinuxDetectionInMB();
    [CompilerGeneratedAttribute]
public void set_LowMemoryForLinuxDetectionInMB(int value);
    public string get_IndexStoragePath();
    public void set_IndexStoragePath(string value);
    [CompilerGeneratedAttribute]
public int get_AvailableMemoryForRaisingBatchSizeLimit();
    [CompilerGeneratedAttribute]
public void set_AvailableMemoryForRaisingBatchSizeLimit(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxProcessingRunLatency();
    [CompilerGeneratedAttribute]
public void set_MaxProcessingRunLatency(TimeSpan value);
    [CompilerGeneratedAttribute]
internal bool get_IsTenantDatabase();
    [CompilerGeneratedAttribute]
internal void set_IsTenantDatabase(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableClusterDiscovery();
    [CompilerGeneratedAttribute]
public void set_DisableClusterDiscovery(bool value);
    [CompilerGeneratedAttribute]
public bool get_TurnOffDiscoveryClient();
    [CompilerGeneratedAttribute]
public void set_TurnOffDiscoveryClient(bool value);
    [CompilerGeneratedAttribute]
public string get_ServerName();
    [CompilerGeneratedAttribute]
public void set_ServerName(string value);
    [CompilerGeneratedAttribute]
public int get_MaxStepsForScript();
    [CompilerGeneratedAttribute]
public void set_MaxStepsForScript(int value);
    [CompilerGeneratedAttribute]
public int get_AdditionalStepsForScriptBasedOnDocumentSize();
    [CompilerGeneratedAttribute]
public void set_AdditionalStepsForScriptBasedOnDocumentSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxIndexWritesBeforeRecreate();
    [CompilerGeneratedAttribute]
public void set_MaxIndexWritesBeforeRecreate(int value);
    [CompilerGeneratedAttribute]
public int get_MaxSimpleIndexOutputsPerDocument();
    [CompilerGeneratedAttribute]
public void set_MaxSimpleIndexOutputsPerDocument(int value);
    [CompilerGeneratedAttribute]
public int get_MaxMapReduceIndexOutputsPerDocument();
    [CompilerGeneratedAttribute]
public void set_MaxMapReduceIndexOutputsPerDocument(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_PrewarmFacetsOnIndexingMaxAge();
    [CompilerGeneratedAttribute]
public void set_PrewarmFacetsOnIndexingMaxAge(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_PrewarmFacetsSyncronousWaitTime();
    [CompilerGeneratedAttribute]
public void set_PrewarmFacetsSyncronousWaitTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public long get_FlushIndexToDiskSizeInMb();
    [CompilerGeneratedAttribute]
public void set_FlushIndexToDiskSizeInMb(long value);
    [CompilerGeneratedAttribute]
public bool get_EnableResponseLoggingForEmbeddedDatabases();
    [CompilerGeneratedAttribute]
public void set_EnableResponseLoggingForEmbeddedDatabases(bool value);
    [CompilerGeneratedAttribute]
public int get_EmbeddedResponseStreamMaxCachedBlocks();
    [CompilerGeneratedAttribute]
public void set_EmbeddedResponseStreamMaxCachedBlocks(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_NewIndexInMemoryMaxTime();
    [CompilerGeneratedAttribute]
public void set_NewIndexInMemoryMaxTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public ImplicitFetchFieldsMode get_ImplicitFetchFieldsFromDocumentMode();
    [CompilerGeneratedAttribute]
public void set_ImplicitFetchFieldsFromDocumentMode(ImplicitFetchFieldsMode value);
    [CompilerGeneratedAttribute]
public bool get_CacheDocumentsInMemory();
    [CompilerGeneratedAttribute]
public void set_CacheDocumentsInMemory(bool value);
    [CompilerGeneratedAttribute]
public string get_TempPath();
    [CompilerGeneratedAttribute]
public void set_TempPath(string value);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public void SetSystemDatabase();
    [EditorBrowsableAttribute("1")]
[BrowsableAttribute("False")]
public bool IsSystemDatabase();
    protected void ResetContainer();
    protected AnonymousUserAccessMode GetAnonymousUserAccessMode();
    protected IgnoreSslCertificateErrorsMode GetIgnoreSslCertificateErrorModeMode();
    public Uri GetFullUrl(string baseUrl);
    public Nullable`1<T> GetConfigurationValue(string configName);
    [CLSCompliantAttribute("False")]
public ITransactionalStorage CreateTransactionalStorage(string storageEngine, Action notifyAboutWork, Action handleStorageInaccessible, Action onNestedTransactionEnter, Action onNestedTransactionExit);
    public static string StorageEngineAssemblyNameByTypeName(string typeName);
    public string SelectDatabaseStorageEngineAndFetchTypeName();
    public void Dispose();
    private ExtensionsLog GetExtensionsFor(Type type);
    public IEnumerable`1<ExtensionsLog> ReportExtensions(Type[] types);
    public void CustomizeValuesForDatabaseTenant(string tenantId);
    public void CustomizeValuesForFileSystemTenant(string tenantId);
    public void CustomizeValuesForCounterStorageTenant(string tenantId);
    public void CustomizeValuesForTimeSeriesTenant(string tenantId);
    public void CopyParentSettings(InMemoryRavenConfiguration defaultConfiguration);
    public IEnumerable`1<string> GetConfigOptionsDocs();
    public void UpdateDataDirForLegacySystemDb();
    [CompilerGeneratedAttribute]
private void <.ctor>b__57_0(object sender, ComposablePartCatalogChangeEventArgs args);
    [CompilerGeneratedAttribute]
private bool <set_PluginsDirectory>b__330_2(DirectoryCatalog c);
}
public static class Raven.Database.Config.MemoryStatistics : object {
    private static ILog Log;
    private static int LowMemoryResourceNotification;
    private static bool failedToGetAvailablePhysicalMemory;
    private static bool failedToGetTotalPhysicalMemory;
    private static int memoryLimit;
    private static IntPtr LowMemoryNotificationHandle;
    private static ConcurrentSet`1<WeakReference`1<ILowMemoryHandler>> LowMemoryHandlers;
    private static IntPtr LowMemorySimulationEvent;
    private static IntPtr SoftMemoryReleaseEvent;
    private static ManualResetEvent StopPosixLowMemThreadEvent;
    private static ManualResetEvent LowPosixMemorySimulationEvent;
    private static IntPtr currentProcessHandle;
    public static FixedSizeConcurrentQueue`1<LowMemoryCalledRecord> LowMemoryCallRecords;
    private static Thread lowMemoryWatcherThread;
    [CompilerGeneratedAttribute]
private static bool <MaxParallelismSet>k__BackingField;
    private static int maxParallelism;
    private static bool memoryLimitSet;
    private static ILog Logger;
    public static ThreadState LowMemoryWatcherThreadState { get; }
    public static bool IsLowMemory { get; }
    public static int TotalPhysicalMemory { get; }
    public static bool MaxParallelismSet { get; private set; }
    public static int MaxParallelism { get; public set; }
    public static int MemoryLimit { get; public set; }
    public static int AvailableMemoryInMb { get; }
    private static MemoryStatistics();
    private static IntPtr CreateMemoryResourceNotification(int notificationType);
    private static bool QueryMemoryResourceNotification(IntPtr hResNotification, Boolean& isResourceStateMet);
    private static UInt32 WaitForMultipleObjects(UInt32 nCount, IntPtr[] lpHandles, bool bWaitAll, UInt32 dwMilliseconds);
    private static IntPtr CreateEvent(IntPtr lpEventAttributes, bool bManualReset, bool bIntialState, string lpName);
    public static bool SetEvent(IntPtr hEvent);
    public static IntPtr GetCurrentProcess();
    public static void StopPosixLowMemThread();
    public static ThreadState get_LowMemoryWatcherThreadState();
    private static void MemoryStatisticsForPosix();
    public static void SimulateLowMemoryNotification();
    public static void InitiateSoftMemoryRelease();
    public static void RunLowMemoryHandlers(string reason);
    public static List`1<LowMemoryHandlerStatistics> GetLowMemoryHandlersStatistics();
    private static void ClearInactiveHandlers();
    public static bool get_IsLowMemory();
    public static void RegisterLowMemoryHandler(ILowMemoryHandler handler);
    public static int get_TotalPhysicalMemory();
    [CompilerGeneratedAttribute]
public static bool get_MaxParallelismSet();
    [CompilerGeneratedAttribute]
private static void set_MaxParallelismSet(bool value);
    public static int get_MaxParallelism();
    public static void set_MaxParallelism(int value);
    public static int get_MemoryLimit();
    public static void set_MemoryLimit(int value);
    private static bool GetProcessMemoryInfo(IntPtr hProcess, PROCESS_MEMORY_COUNTERS& counters, UInt32 size);
    public static long GetCurrentWorkingSet();
    public static int get_AvailableMemoryInMb();
}
public class Raven.Database.Config.RavenConfiguration : InMemoryRavenConfiguration {
    private void LoadConfigurationAndInitialize(IEnumerable`1<Tuple`2<string, string>> values);
    public void LoadFrom(string path);
}
public class Raven.Database.Config.Retriever.ConfigurationDocument`1 : object {
    [CompilerGeneratedAttribute]
private bool <LocalExists>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GlobalExists>k__BackingField;
    [CompilerGeneratedAttribute]
private TClass <MergedDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private TClass <GlobalDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    public bool LocalExists { get; public set; }
    public bool GlobalExists { get; public set; }
    public TClass MergedDocument { get; public set; }
    public TClass GlobalDocument { get; public set; }
    public Etag Etag { get; public set; }
    public RavenJObject Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_LocalExists();
    [CompilerGeneratedAttribute]
public void set_LocalExists(bool value);
    [CompilerGeneratedAttribute]
public bool get_GlobalExists();
    [CompilerGeneratedAttribute]
public void set_GlobalExists(bool value);
    [CompilerGeneratedAttribute]
public TClass get_MergedDocument();
    [CompilerGeneratedAttribute]
public void set_MergedDocument(TClass value);
    [CompilerGeneratedAttribute]
public TClass get_GlobalDocument();
    [CompilerGeneratedAttribute]
public void set_GlobalDocument(TClass value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
}
public class Raven.Database.Config.Retriever.ConfigurationRetriever : object {
    private DocumentDatabase systemDatabase;
    private DocumentDatabase database;
    private Dictionary`2<string, DocumentType> documentTypes;
    private ReplicationConflictResolutionConfigurationRetriever replicationConflictResolutionConfigurationRetriever;
    private ReplicationConfigurationRetriever replicationConfigurationRetriever;
    private VersioningConfigurationRetriever versioningConfigurationRetriever;
    private PeriodicExportConfigurationRetriever periodicExportConfigurationRetriever;
    private ConfigurationSettingRetriever configurationSettingRetriever;
    private SqlReplicationConfigurationRetriever sqlReplicationConfigurationRetriever;
    private JavascriptFunctionsRetriever javascriptFunctionsRetriever;
    private ConcurrentSet`1<Action`3<DocumentDatabase, DocumentChangeNotification, RavenJObject>> systemOnDocumentChangeNotifications;
    private static Nullable`1<DateTime> licenseEnabled;
    public static bool IsGlobalConfigurationEnabled { get; }
    public ConfigurationRetriever(DocumentDatabase systemDatabase, DocumentDatabase database);
    public static void EnableGlobalConfigurationOnce();
    public static bool get_IsGlobalConfigurationEnabled();
    public ConfigurationDocument`1<TType> GetConfigurationDocument(string key);
    public RavenJObject GetConfigurationDocumentAsJson(string key);
    public ConfigurationSettings GetConfigurationSettings(String[] keys);
    public string GetEffectiveConfigurationSetting(string key);
    public ConfigurationSetting GetConfigurationSetting(string key);
    public void SubscribeToConfigurationDocumentChanges(string key, Action action);
    private object GetConfigurationDocumentInternal(string key);
    private ConfigurationDocument`1<TType> GetConfigurationDocumentInternal(string key);
    private IConfigurationRetriever GetConfigurationRetriever(string key);
    private string GetGlobalConfigurationDocumentKey(string key);
    private static void SendNotification(DocumentChangeNotification notification, string key, Action action);
    private DocumentType DetectDocumentType(string key);
    public sealed virtual void Dispose();
}
public abstract class Raven.Database.Config.Retriever.ConfigurationRetrieverBase`1 : object {
    private bool shouldDeserialize;
    protected abstract virtual TClass ApplyGlobalDocumentToLocal(TClass global, TClass local, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    protected abstract virtual TClass ConvertGlobalDocumentToLocal(TClass global, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    protected virtual TClass PostProcessLocalOnly(TClass local);
    public sealed virtual ConfigurationDocument`1<TClass> GetConfigurationDocument(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    private sealed virtual override object Raven.Database.Config.Retriever.IConfigurationRetriever.GetConfigurationDocument(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public virtual ConfigurationSetting GetConfigurationSetting(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public abstract virtual string GetGlobalConfigurationDocumentKey(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    private TClass Deserialize(JsonDocument document);
}
public class Raven.Database.Config.Retriever.ConfigurationSetting : object {
    [CompilerGeneratedAttribute]
private bool <LocalExists>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GlobalExists>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EffectiveValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GlobalValue>k__BackingField;
    public bool LocalExists { get; public set; }
    public bool GlobalExists { get; public set; }
    public string EffectiveValue { get; public set; }
    public string GlobalValue { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_LocalExists();
    [CompilerGeneratedAttribute]
public void set_LocalExists(bool value);
    [CompilerGeneratedAttribute]
public bool get_GlobalExists();
    [CompilerGeneratedAttribute]
public void set_GlobalExists(bool value);
    [CompilerGeneratedAttribute]
public string get_EffectiveValue();
    [CompilerGeneratedAttribute]
public void set_EffectiveValue(string value);
    [CompilerGeneratedAttribute]
public string get_GlobalValue();
    [CompilerGeneratedAttribute]
public void set_GlobalValue(string value);
}
public class Raven.Database.Config.Retriever.ConfigurationSettingRetriever : ConfigurationRetrieverBase`1<object> {
    private DocumentDatabase systemDatabase;
    private GlobalSettingsDocument globalSettings;
    public ConfigurationSettingRetriever(DocumentDatabase systemDatabase);
    protected virtual object ApplyGlobalDocumentToLocal(object global, object local, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    protected virtual object ConvertGlobalDocumentToLocal(object global, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public virtual string GetGlobalConfigurationDocumentKey(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    private void LoadGlobalSettings();
    public virtual ConfigurationSetting GetConfigurationSetting(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(DocumentDatabase database, DocumentChangeNotification notification, RavenJObject meta);
}
public class Raven.Database.Config.Retriever.ConfigurationSettings : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ConfigurationSetting> <Results>k__BackingField;
    public Dictionary`2<string, ConfigurationSetting> Results { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ConfigurationSetting> get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(Dictionary`2<string, ConfigurationSetting> value);
}
public interface Raven.Database.Config.Retriever.IConfigurationRetriever {
    public abstract virtual ConfigurationSetting GetConfigurationSetting(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public abstract virtual string GetGlobalConfigurationDocumentKey(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public abstract virtual object GetConfigurationDocument(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
}
public interface Raven.Database.Config.Retriever.IConfigurationRetriever`1 {
    public abstract virtual ConfigurationDocument`1<TClass> GetConfigurationDocument(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
}
public class Raven.Database.Config.Retriever.JavascriptFunctionsRetriever : ConfigurationRetrieverBase`1<RavenJObject> {
    protected virtual RavenJObject ApplyGlobalDocumentToLocal(RavenJObject global, RavenJObject local, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    protected virtual RavenJObject ConvertGlobalDocumentToLocal(RavenJObject global, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public virtual string GetGlobalConfigurationDocumentKey(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
}
internal class Raven.Database.Config.Retriever.PeriodicExportConfigurationRetriever : ConfigurationRetrieverBase`1<PeriodicExportSetup> {
    protected virtual PeriodicExportSetup ApplyGlobalDocumentToLocal(PeriodicExportSetup global, PeriodicExportSetup local, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    protected virtual PeriodicExportSetup ConvertGlobalDocumentToLocal(PeriodicExportSetup global, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public virtual string GetGlobalConfigurationDocumentKey(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
}
internal class Raven.Database.Config.Retriever.ReplicationConfigurationRetriever : ConfigurationRetrieverBase`1<ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin>> {
    protected virtual ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin> ApplyGlobalDocumentToLocal(ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin> global, ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin> local, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    protected virtual ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin> PostProcessLocalOnly(ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin> local);
    protected virtual ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin> ConvertGlobalDocumentToLocal(ReplicationDocument`1<ReplicationDestinationWithConfigurationOrigin> global, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public virtual string GetGlobalConfigurationDocumentKey(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
}
internal class Raven.Database.Config.Retriever.ReplicationConflictResolutionConfigurationRetriever : ConfigurationRetrieverBase`1<ReplicationConfig> {
    protected virtual ReplicationConfig ApplyGlobalDocumentToLocal(ReplicationConfig global, ReplicationConfig local, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    protected virtual ReplicationConfig ConvertGlobalDocumentToLocal(ReplicationConfig global, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public virtual string GetGlobalConfigurationDocumentKey(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
}
public class Raven.Database.Config.Retriever.SqlReplicationConfigurationRetriever : ConfigurationRetrieverBase`1<SqlReplicationConnections`1<PredefinedSqlConnectionWithConfigurationOrigin>> {
    protected virtual SqlReplicationConnections`1<PredefinedSqlConnectionWithConfigurationOrigin> ApplyGlobalDocumentToLocal(SqlReplicationConnections`1<PredefinedSqlConnectionWithConfigurationOrigin> global, SqlReplicationConnections`1<PredefinedSqlConnectionWithConfigurationOrigin> local, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    protected virtual SqlReplicationConnections`1<PredefinedSqlConnectionWithConfigurationOrigin> PostProcessLocalOnly(SqlReplicationConnections`1<PredefinedSqlConnectionWithConfigurationOrigin> local);
    protected virtual SqlReplicationConnections`1<PredefinedSqlConnectionWithConfigurationOrigin> ConvertGlobalDocumentToLocal(SqlReplicationConnections`1<PredefinedSqlConnectionWithConfigurationOrigin> global, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public virtual string GetGlobalConfigurationDocumentKey(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
}
public class Raven.Database.Config.Retriever.VersioningConfigurationRetriever : ConfigurationRetrieverBase`1<VersioningConfiguration> {
    protected virtual VersioningConfiguration ApplyGlobalDocumentToLocal(VersioningConfiguration global, VersioningConfiguration local, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    protected virtual VersioningConfiguration ConvertGlobalDocumentToLocal(VersioningConfiguration global, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
    public virtual string GetGlobalConfigurationDocumentKey(string key, DocumentDatabase systemDatabase, DocumentDatabase localDatabase);
}
internal class Raven.Database.Config.Settings.BooleanSetting : Setting`1<bool> {
    public bool Value { get; }
    public BooleanSetting(string value, bool defaultValue);
    public virtual bool get_Value();
}
internal class Raven.Database.Config.Settings.EnumSetting`1 : Setting`1<T> {
    private Type enumType;
    public T Value { get; }
    public EnumSetting`1(string value, T defaultValue);
    public EnumSetting`1(string value, Func`1<T> getDefaultValue);
    private static Type GetEnumType();
    public virtual T get_Value();
}
internal class Raven.Database.Config.Settings.IntegerSetting : Setting`1<int> {
    public int Value { get; }
    public IntegerSetting(string value, int defaultValue);
    public IntegerSetting(string value, Func`1<int> getDefaultValue);
    public virtual int get_Value();
}
internal class Raven.Database.Config.Settings.IntegerSettingWithMin : Setting`1<int> {
    private int min;
    public int Value { get; }
    public int Default { get; }
    public IntegerSettingWithMin(string value, int defaultValue, int min);
    public virtual int get_Value();
    public int get_Default();
}
internal class Raven.Database.Config.Settings.MultipliedIntegerSetting : object {
    private Setting`1<int> setting;
    private int factor;
    public int Value { get; }
    public MultipliedIntegerSetting(Setting`1<int> setting, int factor);
    public int get_Value();
}
internal class Raven.Database.Config.Settings.NullableIntegerSetting : Setting`1<Nullable`1<int>> {
    public Nullable`1<int> Value { get; }
    public NullableIntegerSetting(string value, Nullable`1<int> defaultValue);
    public NullableIntegerSetting(string value, Func`1<Nullable`1<int>> getDefaultValue);
    public virtual Nullable`1<int> get_Value();
}
internal class Raven.Database.Config.Settings.NullableIntegerSettingWithMin : Setting`1<Nullable`1<int>> {
    private int minValue;
    public Nullable`1<int> Value { get; }
    public NullableIntegerSettingWithMin(string value, Nullable`1<int> defaultValue, int minValue);
    public NullableIntegerSettingWithMin(string value, Func`1<Nullable`1<int>> getDefaultValue, int minValue);
    public virtual Nullable`1<int> get_Value();
}
internal abstract class Raven.Database.Config.Settings.Setting`1 : object {
    protected string value;
    protected Func`1<T> getDefaultValue;
    protected T defaultValue;
    public T Value { get; }
    public T DefaultValue { get; }
    protected Setting`1(string value, T defaultValue);
    protected Setting`1(string value, Func`1<T> getDefaultValue);
    public abstract virtual T get_Value();
    public T get_DefaultValue();
}
internal class Raven.Database.Config.Settings.StringSetting : Setting`1<string> {
    public string Value { get; }
    public StringSetting(string value, string defaultValue);
    public StringSetting(string value, Func`1<string> getDefaultValue);
    public virtual string get_Value();
}
public enum Raven.Database.Config.Settings.TimeSpanArgumentType : Enum {
    public int value__;
    public static TimeSpanArgumentType Unknown;
    public static TimeSpanArgumentType FromSeconds;
    public static TimeSpanArgumentType FromParse;
}
internal class Raven.Database.Config.Settings.TimeSpanSetting : Setting`1<TimeSpan> {
    private TimeSpanArgumentType argumentType;
    public TimeSpan Value { get; }
    public TimeSpanSetting(string value, TimeSpan defaultValue, TimeSpanArgumentType argumentType);
    public virtual TimeSpan get_Value();
}
internal class Raven.Database.Config.StronglyTypedRavenSettings : object {
    private NameValueCollection settings;
    [CompilerGeneratedAttribute]
private ReplicationConfiguration <Replication>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlReplicationConfiguration <SqlReplication>k__BackingField;
    [CompilerGeneratedAttribute]
private VoronConfiguration <Voron>k__BackingField;
    [CompilerGeneratedAttribute]
private EsentConfiguration <Esent>k__BackingField;
    [CompilerGeneratedAttribute]
private PrefetcherConfiguration <Prefetcher>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemConfiguration <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterConfiguration <Counter>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesConfiguration <TimeSeries>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionConfiguration <Encryption>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingConfiguration <Indexing>k__BackingField;
    [CompilerGeneratedAttribute]
private ClusterConfiguration <Cluster>k__BackingField;
    [CompilerGeneratedAttribute]
private WebSocketsConfiguration <WebSockets>k__BackingField;
    [CompilerGeneratedAttribute]
private MonitoringConfiguration <Monitoring>k__BackingField;
    [CompilerGeneratedAttribute]
private StudioConfiguration <Studio>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxPrecomputedBatchTotalDocumentSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxPrecomputedBatchSizeForNewIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <CacheDocumentsInMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxConcurrentResourceLoads>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <ConcurrentResourceLoadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxClauseCount>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <AllowScriptsToAdjustNumberOfSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <IndexAndTransformerReplicationLatencyInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MemoryLimitForProcessing>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSettingWithMin <MinThreadPoolWorkerThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSettingWithMin <MinThreadPoolCompletionThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <LowMemoryLimitForLinuxDetectionInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxConcurrentServerRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxConcurrentRequestsForDatabaseDuringLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxSecondsForTaskToWaitForDatabaseToLoad>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxConcurrentMultiGetRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <PrefetchingDurationLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <BulkImportBatchTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSettingWithMin <MaxPageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MemoryCacheLimitMegabytes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <MemoryCacheExpiration>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MemoryCacheLimitPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <MemoryCacheLimitCheckInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <MemoryCacher>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <MaxProcessingRunLatency>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <PrewarmFacetsOnIndexingMaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <PrewarmFacetsSyncronousWaitTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSettingWithMin <MaxNumberOfItemsToProcessInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <AvailableMemoryForRaisingBatchSizeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSettingWithMin <MaxNumberOfItemsToReduceInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <NumberOfItemsToExecuteReduceInSingleStep>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSettingWithMin <MaxNumberOfParallelProcessingTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private MultipliedIntegerSetting <NewIndexInMemoryMaxMb>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <NewIndexInMemoryMaxTime>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <RunInMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <CreateAutoIndexesForAdHocQueriesIfNeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <ResetIndexOnUncleanShutdown>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <DisableInMemoryIndexing>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <WorkingDir>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <DataDir>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <IndexStoragePath>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <ExposeConfigOverTheWire>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <HttpCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <AccessControlAllowOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <AccessControlMaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <AccessControlAllowMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <AccessControlRequestHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <RedirectStudioUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <DisableDocumentPreFetching>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSettingWithMin <MaxNumberOfItemsToPreFetch>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <WebDir>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <DisableClusterDiscovery>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <TurnOffDiscoveryClient>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <PluginsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <CompiledIndexCacheDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <AssembliesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <EmbeddedFilesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <TaskScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <RejectClientsModeEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <MaxIndexCommitPointStoreTimeInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <MinIndexingTimeIntervalToStoreCommitPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxNumberOfStoredCommitPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <TimeToWaitBeforeRunningIdleIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <TimeToWaitBeforeMarkingAutoIndexAsIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <TimeToWaitBeforeMarkingIdleIndexAsAbandoned>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <CheckReferenceBecauseOfDocumentUpdateTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <TimeToWaitBeforeRunningAbandonedIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxStepsForScript>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <AdditionalStepsForScriptBasedOnDocumentSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxIndexWritesBeforeRecreate>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxSimpleIndexOutputsPerDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <MaxMapReduceIndexOutputsPerDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <DatbaseOperationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <DefaultStorageTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private IntegerSetting <FlushIndexToDiskSizeInMb>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <TombstoneRetentionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private EnumSetting`1<ImplicitFetchFieldsMode> <ImplicitFetchFieldsFromDocumentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSetting <TempPath>k__BackingField;
    [CompilerGeneratedAttribute]
private BooleanSetting <SkipConsistencyCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpanSetting <PutSerialLockDuration>k__BackingField;
    public ReplicationConfiguration Replication { get; private set; }
    public SqlReplicationConfiguration SqlReplication { get; private set; }
    public VoronConfiguration Voron { get; private set; }
    public EsentConfiguration Esent { get; private set; }
    public PrefetcherConfiguration Prefetcher { get; private set; }
    public FileSystemConfiguration FileSystem { get; private set; }
    public CounterConfiguration Counter { get; private set; }
    public TimeSeriesConfiguration TimeSeries { get; private set; }
    public EncryptionConfiguration Encryption { get; private set; }
    public IndexingConfiguration Indexing { get; public set; }
    public ClusterConfiguration Cluster { get; private set; }
    public WebSocketsConfiguration WebSockets { get; private set; }
    public MonitoringConfiguration Monitoring { get; private set; }
    public StudioConfiguration Studio { get; private set; }
    public IntegerSetting MaxPrecomputedBatchTotalDocumentSizeInBytes { get; private set; }
    public IntegerSetting MaxPrecomputedBatchSizeForNewIndex { get; private set; }
    public BooleanSetting CacheDocumentsInMemory { get; public set; }
    public IntegerSetting MaxConcurrentResourceLoads { get; private set; }
    public TimeSpanSetting ConcurrentResourceLoadTimeout { get; private set; }
    public IntegerSetting MaxClauseCount { get; private set; }
    public BooleanSetting AllowScriptsToAdjustNumberOfSteps { get; private set; }
    public IntegerSetting IndexAndTransformerReplicationLatencyInSec { get; private set; }
    public IntegerSetting MemoryLimitForProcessing { get; private set; }
    public IntegerSettingWithMin MinThreadPoolWorkerThreads { get; private set; }
    public IntegerSettingWithMin MinThreadPoolCompletionThreads { get; private set; }
    public IntegerSetting LowMemoryLimitForLinuxDetectionInMB { get; private set; }
    public IntegerSetting MaxConcurrentServerRequests { get; private set; }
    public IntegerSetting MaxConcurrentRequestsForDatabaseDuringLoad { get; private set; }
    public IntegerSetting MaxSecondsForTaskToWaitForDatabaseToLoad { get; public set; }
    public IntegerSetting MaxConcurrentMultiGetRequests { get; private set; }
    public IntegerSetting PrefetchingDurationLimit { get; private set; }
    public TimeSpanSetting BulkImportBatchTimeout { get; private set; }
    public IntegerSettingWithMin MaxPageSize { get; private set; }
    public IntegerSetting MemoryCacheLimitMegabytes { get; private set; }
    public TimeSpanSetting MemoryCacheExpiration { get; private set; }
    public IntegerSetting MemoryCacheLimitPercentage { get; private set; }
    public TimeSpanSetting MemoryCacheLimitCheckInterval { get; private set; }
    public StringSetting MemoryCacher { get; private set; }
    public TimeSpanSetting MaxProcessingRunLatency { get; private set; }
    public TimeSpanSetting PrewarmFacetsOnIndexingMaxAge { get; private set; }
    public TimeSpanSetting PrewarmFacetsSyncronousWaitTime { get; private set; }
    public IntegerSettingWithMin MaxNumberOfItemsToProcessInSingleBatch { get; private set; }
    public IntegerSetting AvailableMemoryForRaisingBatchSizeLimit { get; private set; }
    public IntegerSettingWithMin MaxNumberOfItemsToReduceInSingleBatch { get; private set; }
    public IntegerSetting NumberOfItemsToExecuteReduceInSingleStep { get; private set; }
    public IntegerSettingWithMin MaxNumberOfParallelProcessingTasks { get; private set; }
    public MultipliedIntegerSetting NewIndexInMemoryMaxMb { get; private set; }
    public TimeSpanSetting NewIndexInMemoryMaxTime { get; private set; }
    public BooleanSetting RunInMemory { get; private set; }
    public BooleanSetting CreateAutoIndexesForAdHocQueriesIfNeeded { get; private set; }
    public BooleanSetting ResetIndexOnUncleanShutdown { get; private set; }
    public BooleanSetting DisableInMemoryIndexing { get; private set; }
    public StringSetting WorkingDir { get; private set; }
    public StringSetting DataDir { get; private set; }
    public StringSetting IndexStoragePath { get; private set; }
    public StringSetting HostName { get; private set; }
    public StringSetting Port { get; private set; }
    public StringSetting ExposeConfigOverTheWire { get; public set; }
    public BooleanSetting HttpCompression { get; private set; }
    public StringSetting AccessControlAllowOrigin { get; private set; }
    public StringSetting AccessControlMaxAge { get; private set; }
    public StringSetting AccessControlAllowMethods { get; private set; }
    public StringSetting AccessControlRequestHeaders { get; private set; }
    public StringSetting RedirectStudioUrl { get; private set; }
    public BooleanSetting DisableDocumentPreFetching { get; private set; }
    public IntegerSettingWithMin MaxNumberOfItemsToPreFetch { get; private set; }
    public StringSetting WebDir { get; private set; }
    public BooleanSetting DisableClusterDiscovery { get; private set; }
    public BooleanSetting TurnOffDiscoveryClient { get; private set; }
    public StringSetting ServerName { get; private set; }
    public StringSetting PluginsDirectory { get; private set; }
    public StringSetting CompiledIndexCacheDirectory { get; private set; }
    public StringSetting AssembliesDirectory { get; private set; }
    public StringSetting EmbeddedFilesDirectory { get; private set; }
    public StringSetting TaskScheduler { get; private set; }
    public BooleanSetting RejectClientsModeEnabled { get; private set; }
    public TimeSpanSetting MaxIndexCommitPointStoreTimeInterval { get; private set; }
    public TimeSpanSetting MinIndexingTimeIntervalToStoreCommitPoint { get; private set; }
    public IntegerSetting MaxNumberOfStoredCommitPoints { get; private set; }
    public TimeSpanSetting TimeToWaitBeforeRunningIdleIndexes { get; private set; }
    public TimeSpanSetting TimeToWaitBeforeMarkingAutoIndexAsIdle { get; private set; }
    public TimeSpanSetting TimeToWaitBeforeMarkingIdleIndexAsAbandoned { get; private set; }
    public TimeSpanSetting CheckReferenceBecauseOfDocumentUpdateTimeout { get; private set; }
    public TimeSpanSetting TimeToWaitBeforeRunningAbandonedIndexes { get; private set; }
    public IntegerSetting MaxStepsForScript { get; private set; }
    public IntegerSetting AdditionalStepsForScriptBasedOnDocumentSize { get; private set; }
    public IntegerSetting MaxIndexWritesBeforeRecreate { get; private set; }
    public IntegerSetting MaxSimpleIndexOutputsPerDocument { get; private set; }
    public IntegerSetting MaxMapReduceIndexOutputsPerDocument { get; private set; }
    public TimeSpanSetting DatbaseOperationTimeout { get; private set; }
    public StringSetting DefaultStorageTypeName { get; private set; }
    public IntegerSetting FlushIndexToDiskSizeInMb { get; public set; }
    public TimeSpanSetting TombstoneRetentionTime { get; private set; }
    public EnumSetting`1<ImplicitFetchFieldsMode> ImplicitFetchFieldsFromDocumentMode { get; private set; }
    public StringSetting TempPath { get; private set; }
    public BooleanSetting SkipConsistencyCheck { get; public set; }
    public TimeSpanSetting PutSerialLockDuration { get; public set; }
    public StronglyTypedRavenSettings(NameValueCollection settings);
    [CompilerGeneratedAttribute]
public ReplicationConfiguration get_Replication();
    [CompilerGeneratedAttribute]
private void set_Replication(ReplicationConfiguration value);
    [CompilerGeneratedAttribute]
public SqlReplicationConfiguration get_SqlReplication();
    [CompilerGeneratedAttribute]
private void set_SqlReplication(SqlReplicationConfiguration value);
    [CompilerGeneratedAttribute]
public VoronConfiguration get_Voron();
    [CompilerGeneratedAttribute]
private void set_Voron(VoronConfiguration value);
    [CompilerGeneratedAttribute]
public EsentConfiguration get_Esent();
    [CompilerGeneratedAttribute]
private void set_Esent(EsentConfiguration value);
    [CompilerGeneratedAttribute]
public PrefetcherConfiguration get_Prefetcher();
    [CompilerGeneratedAttribute]
private void set_Prefetcher(PrefetcherConfiguration value);
    [CompilerGeneratedAttribute]
public FileSystemConfiguration get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(FileSystemConfiguration value);
    [CompilerGeneratedAttribute]
public CounterConfiguration get_Counter();
    [CompilerGeneratedAttribute]
private void set_Counter(CounterConfiguration value);
    [CompilerGeneratedAttribute]
public TimeSeriesConfiguration get_TimeSeries();
    [CompilerGeneratedAttribute]
private void set_TimeSeries(TimeSeriesConfiguration value);
    [CompilerGeneratedAttribute]
public EncryptionConfiguration get_Encryption();
    [CompilerGeneratedAttribute]
private void set_Encryption(EncryptionConfiguration value);
    [CompilerGeneratedAttribute]
public IndexingConfiguration get_Indexing();
    [CompilerGeneratedAttribute]
public void set_Indexing(IndexingConfiguration value);
    [CompilerGeneratedAttribute]
public ClusterConfiguration get_Cluster();
    [CompilerGeneratedAttribute]
private void set_Cluster(ClusterConfiguration value);
    [CompilerGeneratedAttribute]
public WebSocketsConfiguration get_WebSockets();
    [CompilerGeneratedAttribute]
private void set_WebSockets(WebSocketsConfiguration value);
    [CompilerGeneratedAttribute]
public MonitoringConfiguration get_Monitoring();
    [CompilerGeneratedAttribute]
private void set_Monitoring(MonitoringConfiguration value);
    [CompilerGeneratedAttribute]
public StudioConfiguration get_Studio();
    [CompilerGeneratedAttribute]
private void set_Studio(StudioConfiguration value);
    public void Setup(int defaultMaxNumberOfItemsToIndexInSingleBatch, int defaultInitialNumberOfItemsToIndexInSingleBatch);
    private void FillMonitoringSettings();
    private string GetDefaultWebDir();
    private int GetDefaultMemoryCacheLimitMegabytes();
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxPrecomputedBatchTotalDocumentSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_MaxPrecomputedBatchTotalDocumentSizeInBytes(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxPrecomputedBatchSizeForNewIndex();
    [CompilerGeneratedAttribute]
private void set_MaxPrecomputedBatchSizeForNewIndex(IntegerSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_CacheDocumentsInMemory();
    [CompilerGeneratedAttribute]
public void set_CacheDocumentsInMemory(BooleanSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxConcurrentResourceLoads();
    [CompilerGeneratedAttribute]
private void set_MaxConcurrentResourceLoads(IntegerSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_ConcurrentResourceLoadTimeout();
    [CompilerGeneratedAttribute]
private void set_ConcurrentResourceLoadTimeout(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxClauseCount();
    [CompilerGeneratedAttribute]
private void set_MaxClauseCount(IntegerSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_AllowScriptsToAdjustNumberOfSteps();
    [CompilerGeneratedAttribute]
private void set_AllowScriptsToAdjustNumberOfSteps(BooleanSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_IndexAndTransformerReplicationLatencyInSec();
    [CompilerGeneratedAttribute]
private void set_IndexAndTransformerReplicationLatencyInSec(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MemoryLimitForProcessing();
    [CompilerGeneratedAttribute]
private void set_MemoryLimitForProcessing(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSettingWithMin get_MinThreadPoolWorkerThreads();
    [CompilerGeneratedAttribute]
private void set_MinThreadPoolWorkerThreads(IntegerSettingWithMin value);
    [CompilerGeneratedAttribute]
public IntegerSettingWithMin get_MinThreadPoolCompletionThreads();
    [CompilerGeneratedAttribute]
private void set_MinThreadPoolCompletionThreads(IntegerSettingWithMin value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_LowMemoryLimitForLinuxDetectionInMB();
    [CompilerGeneratedAttribute]
private void set_LowMemoryLimitForLinuxDetectionInMB(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxConcurrentServerRequests();
    [CompilerGeneratedAttribute]
private void set_MaxConcurrentServerRequests(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxConcurrentRequestsForDatabaseDuringLoad();
    [CompilerGeneratedAttribute]
private void set_MaxConcurrentRequestsForDatabaseDuringLoad(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxSecondsForTaskToWaitForDatabaseToLoad();
    [CompilerGeneratedAttribute]
public void set_MaxSecondsForTaskToWaitForDatabaseToLoad(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxConcurrentMultiGetRequests();
    [CompilerGeneratedAttribute]
private void set_MaxConcurrentMultiGetRequests(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_PrefetchingDurationLimit();
    [CompilerGeneratedAttribute]
private void set_PrefetchingDurationLimit(IntegerSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_BulkImportBatchTimeout();
    [CompilerGeneratedAttribute]
private void set_BulkImportBatchTimeout(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public IntegerSettingWithMin get_MaxPageSize();
    [CompilerGeneratedAttribute]
private void set_MaxPageSize(IntegerSettingWithMin value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MemoryCacheLimitMegabytes();
    [CompilerGeneratedAttribute]
private void set_MemoryCacheLimitMegabytes(IntegerSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_MemoryCacheExpiration();
    [CompilerGeneratedAttribute]
private void set_MemoryCacheExpiration(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MemoryCacheLimitPercentage();
    [CompilerGeneratedAttribute]
private void set_MemoryCacheLimitPercentage(IntegerSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_MemoryCacheLimitCheckInterval();
    [CompilerGeneratedAttribute]
private void set_MemoryCacheLimitCheckInterval(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_MemoryCacher();
    [CompilerGeneratedAttribute]
private void set_MemoryCacher(StringSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_MaxProcessingRunLatency();
    [CompilerGeneratedAttribute]
private void set_MaxProcessingRunLatency(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_PrewarmFacetsOnIndexingMaxAge();
    [CompilerGeneratedAttribute]
private void set_PrewarmFacetsOnIndexingMaxAge(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_PrewarmFacetsSyncronousWaitTime();
    [CompilerGeneratedAttribute]
private void set_PrewarmFacetsSyncronousWaitTime(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public IntegerSettingWithMin get_MaxNumberOfItemsToProcessInSingleBatch();
    [CompilerGeneratedAttribute]
private void set_MaxNumberOfItemsToProcessInSingleBatch(IntegerSettingWithMin value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_AvailableMemoryForRaisingBatchSizeLimit();
    [CompilerGeneratedAttribute]
private void set_AvailableMemoryForRaisingBatchSizeLimit(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSettingWithMin get_MaxNumberOfItemsToReduceInSingleBatch();
    [CompilerGeneratedAttribute]
private void set_MaxNumberOfItemsToReduceInSingleBatch(IntegerSettingWithMin value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_NumberOfItemsToExecuteReduceInSingleStep();
    [CompilerGeneratedAttribute]
private void set_NumberOfItemsToExecuteReduceInSingleStep(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSettingWithMin get_MaxNumberOfParallelProcessingTasks();
    [CompilerGeneratedAttribute]
private void set_MaxNumberOfParallelProcessingTasks(IntegerSettingWithMin value);
    [CompilerGeneratedAttribute]
public MultipliedIntegerSetting get_NewIndexInMemoryMaxMb();
    [CompilerGeneratedAttribute]
private void set_NewIndexInMemoryMaxMb(MultipliedIntegerSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_NewIndexInMemoryMaxTime();
    [CompilerGeneratedAttribute]
private void set_NewIndexInMemoryMaxTime(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_RunInMemory();
    [CompilerGeneratedAttribute]
private void set_RunInMemory(BooleanSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_CreateAutoIndexesForAdHocQueriesIfNeeded();
    [CompilerGeneratedAttribute]
private void set_CreateAutoIndexesForAdHocQueriesIfNeeded(BooleanSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_ResetIndexOnUncleanShutdown();
    [CompilerGeneratedAttribute]
private void set_ResetIndexOnUncleanShutdown(BooleanSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_DisableInMemoryIndexing();
    [CompilerGeneratedAttribute]
private void set_DisableInMemoryIndexing(BooleanSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_WorkingDir();
    [CompilerGeneratedAttribute]
private void set_WorkingDir(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_DataDir();
    [CompilerGeneratedAttribute]
private void set_DataDir(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_IndexStoragePath();
    [CompilerGeneratedAttribute]
private void set_IndexStoragePath(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_HostName();
    [CompilerGeneratedAttribute]
private void set_HostName(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_Port();
    [CompilerGeneratedAttribute]
private void set_Port(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_ExposeConfigOverTheWire();
    [CompilerGeneratedAttribute]
public void set_ExposeConfigOverTheWire(StringSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_HttpCompression();
    [CompilerGeneratedAttribute]
private void set_HttpCompression(BooleanSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_AccessControlAllowOrigin();
    [CompilerGeneratedAttribute]
private void set_AccessControlAllowOrigin(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_AccessControlMaxAge();
    [CompilerGeneratedAttribute]
private void set_AccessControlMaxAge(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_AccessControlAllowMethods();
    [CompilerGeneratedAttribute]
private void set_AccessControlAllowMethods(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_AccessControlRequestHeaders();
    [CompilerGeneratedAttribute]
private void set_AccessControlRequestHeaders(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_RedirectStudioUrl();
    [CompilerGeneratedAttribute]
private void set_RedirectStudioUrl(StringSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_DisableDocumentPreFetching();
    [CompilerGeneratedAttribute]
private void set_DisableDocumentPreFetching(BooleanSetting value);
    [CompilerGeneratedAttribute]
public IntegerSettingWithMin get_MaxNumberOfItemsToPreFetch();
    [CompilerGeneratedAttribute]
private void set_MaxNumberOfItemsToPreFetch(IntegerSettingWithMin value);
    [CompilerGeneratedAttribute]
public StringSetting get_WebDir();
    [CompilerGeneratedAttribute]
private void set_WebDir(StringSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_DisableClusterDiscovery();
    [CompilerGeneratedAttribute]
private void set_DisableClusterDiscovery(BooleanSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_TurnOffDiscoveryClient();
    [CompilerGeneratedAttribute]
private void set_TurnOffDiscoveryClient(BooleanSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_ServerName();
    [CompilerGeneratedAttribute]
private void set_ServerName(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_PluginsDirectory();
    [CompilerGeneratedAttribute]
private void set_PluginsDirectory(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_CompiledIndexCacheDirectory();
    [CompilerGeneratedAttribute]
private void set_CompiledIndexCacheDirectory(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_AssembliesDirectory();
    [CompilerGeneratedAttribute]
private void set_AssembliesDirectory(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_EmbeddedFilesDirectory();
    [CompilerGeneratedAttribute]
private void set_EmbeddedFilesDirectory(StringSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_TaskScheduler();
    [CompilerGeneratedAttribute]
private void set_TaskScheduler(StringSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_RejectClientsModeEnabled();
    [CompilerGeneratedAttribute]
private void set_RejectClientsModeEnabled(BooleanSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_MaxIndexCommitPointStoreTimeInterval();
    [CompilerGeneratedAttribute]
private void set_MaxIndexCommitPointStoreTimeInterval(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_MinIndexingTimeIntervalToStoreCommitPoint();
    [CompilerGeneratedAttribute]
private void set_MinIndexingTimeIntervalToStoreCommitPoint(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxNumberOfStoredCommitPoints();
    [CompilerGeneratedAttribute]
private void set_MaxNumberOfStoredCommitPoints(IntegerSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_TimeToWaitBeforeRunningIdleIndexes();
    [CompilerGeneratedAttribute]
private void set_TimeToWaitBeforeRunningIdleIndexes(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_TimeToWaitBeforeMarkingAutoIndexAsIdle();
    [CompilerGeneratedAttribute]
private void set_TimeToWaitBeforeMarkingAutoIndexAsIdle(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_TimeToWaitBeforeMarkingIdleIndexAsAbandoned();
    [CompilerGeneratedAttribute]
private void set_TimeToWaitBeforeMarkingIdleIndexAsAbandoned(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_CheckReferenceBecauseOfDocumentUpdateTimeout();
    [CompilerGeneratedAttribute]
private void set_CheckReferenceBecauseOfDocumentUpdateTimeout(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_TimeToWaitBeforeRunningAbandonedIndexes();
    [CompilerGeneratedAttribute]
private void set_TimeToWaitBeforeRunningAbandonedIndexes(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxStepsForScript();
    [CompilerGeneratedAttribute]
private void set_MaxStepsForScript(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_AdditionalStepsForScriptBasedOnDocumentSize();
    [CompilerGeneratedAttribute]
private void set_AdditionalStepsForScriptBasedOnDocumentSize(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxIndexWritesBeforeRecreate();
    [CompilerGeneratedAttribute]
private void set_MaxIndexWritesBeforeRecreate(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxSimpleIndexOutputsPerDocument();
    [CompilerGeneratedAttribute]
private void set_MaxSimpleIndexOutputsPerDocument(IntegerSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_MaxMapReduceIndexOutputsPerDocument();
    [CompilerGeneratedAttribute]
private void set_MaxMapReduceIndexOutputsPerDocument(IntegerSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_DatbaseOperationTimeout();
    [CompilerGeneratedAttribute]
private void set_DatbaseOperationTimeout(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public StringSetting get_DefaultStorageTypeName();
    [CompilerGeneratedAttribute]
private void set_DefaultStorageTypeName(StringSetting value);
    [CompilerGeneratedAttribute]
public IntegerSetting get_FlushIndexToDiskSizeInMb();
    [CompilerGeneratedAttribute]
public void set_FlushIndexToDiskSizeInMb(IntegerSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_TombstoneRetentionTime();
    [CompilerGeneratedAttribute]
private void set_TombstoneRetentionTime(TimeSpanSetting value);
    [CompilerGeneratedAttribute]
public EnumSetting`1<ImplicitFetchFieldsMode> get_ImplicitFetchFieldsFromDocumentMode();
    [CompilerGeneratedAttribute]
private void set_ImplicitFetchFieldsFromDocumentMode(EnumSetting`1<ImplicitFetchFieldsMode> value);
    [CompilerGeneratedAttribute]
public StringSetting get_TempPath();
    [CompilerGeneratedAttribute]
private void set_TempPath(StringSetting value);
    [CompilerGeneratedAttribute]
public BooleanSetting get_SkipConsistencyCheck();
    [CompilerGeneratedAttribute]
public void set_SkipConsistencyCheck(BooleanSetting value);
    [CompilerGeneratedAttribute]
public TimeSpanSetting get_PutSerialLockDuration();
    [CompilerGeneratedAttribute]
public void set_PutSerialLockDuration(TimeSpanSetting value);
}
public class Raven.Database.Config.SystemInfoLoggin : object {
    private static ILog Log;
    private RavenDBOptions options;
    private Timer timer;
    private StringBuilder logText;
    private static SystemInfoLoggin();
    public sealed virtual void Execute(RavenDBOptions serverOptions);
    private void ExecuteCheck(object state);
    private void WriteCurrentServerStateInformationToLog();
    private void LogMetrics(DocumentDatabase database);
    private void LogVoronStats(DocumentDatabase database);
    private void LogEtags(DocumentDatabase database);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <ExecuteCheck>b__5_0(DocumentDatabase database);
}
public class Raven.Database.Counters.Backup.BackupOperation : object {
    private CounterStorage storage;
    private string backupDestinationDirectory;
    private StorageEnvironment env;
    private bool incrementalBackup;
    private CounterStorageDocument counterDocument;
    private static ILog _log;
    private string backupFilename;
    private string backupSourceDirectory;
    public bool BackupAlreadyExists { get; }
    public BackupOperation(CounterStorage storage, string backupSourceDirectory, string backupDestinationDirectory, StorageEnvironment env, bool incrementalBackup, CounterStorageDocument counterDocument);
    private static BackupOperation();
    public void Execute();
    private void PrepareForIncrementalBackup();
    private string DirectoryForIncrementalBackup();
    private void CompleteBackup();
    private void UpdateBackupStatus(string newMsg, string details, BackupMessageSeverity severity);
    private BackupStatus GetBackupStatus();
    private void SetBackupStatus(BackupStatus backupStatus);
    private void DeleteBackupStatus();
    private void EnsureBackupDestinationExists(string backupDestination);
    public bool get_BackupAlreadyExists();
    [CompilerGeneratedAttribute]
private void <Execute>b__9_1(string s);
    [CompilerGeneratedAttribute]
private void <Execute>b__9_0(string s);
}
public class Raven.Database.Counters.Backup.RestoreOperation : object {
    private static ILog log;
    private Action`1<string> output;
    private string backupPath;
    private CounterRestoreRequest restoreRequest;
    private string restoreToPath;
    private string backupFilename;
    public RestoreOperation(CounterRestoreRequest restoreRequest, Action`1<string> output);
    private static RestoreOperation();
    public bool IsValidBackup();
    private string GetBackupFilenamePath();
    private void ValidateRestorePreconditionsAndReturnLogsPath();
    public void Execute();
    [CompilerGeneratedAttribute]
private string <Execute>b__10_1(string dir);
}
public class Raven.Database.Counters.Controllers.AdminCounterStorageController : BaseAdminCountersApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("admin/cs/{*counterStorageName}")]
[AsyncStateMachineAttribute("Raven.Database.Counters.Controllers.AdminCounterStorageController/<Get>d__0")]
public Task`1<HttpResponseMessage> Get(int skip, int take);
    private bool ValidateSkipAndTake(int skip, int take, HttpResponseMessage& message);
    [AsyncStateMachineAttribute("Raven.Database.Counters.Controllers.AdminCounterStorageController/<GetNamesAndGroups>d__2")]
private Task`1<HttpResponseMessage> GetNamesAndGroups(string id, int skip, int take);
    [AsyncStateMachineAttribute("Raven.Database.Counters.Controllers.AdminCounterStorageController/<GetSummary>d__3")]
private Task`1<HttpResponseMessage> GetSummary(string counterStorageId, int shouldSkip, int shouldTake);
    private static int AdjustToTake(int shouldTake, int taken, int toTake);
    [HttpPutAttribute]
[RavenRouteAttribute("admin/cs/{*id}")]
[AsyncStateMachineAttribute("Raven.Database.Counters.Controllers.AdminCounterStorageController/<Put>d__5")]
public Task`1<HttpResponseMessage> Put(string id);
    [HttpDeleteAttribute]
[RavenRouteAttribute("admin/cs/{*id}")]
public HttpResponseMessage Delete(string id);
    [HttpDeleteAttribute]
[RavenRouteAttribute("admin/cs/batch-delete")]
public HttpResponseMessage BatchDelete();
    [HttpPostAttribute]
[RavenRouteAttribute("admin/cs/{*id}")]
public HttpResponseMessage Disable(string id, bool isSettingDisabled);
    [HttpPostAttribute]
[RavenRouteAttribute("admin/cs/batch-toggle-disable")]
public HttpResponseMessage ToggleDisable(bool isSettingDisabled);
    private MessageWithStatusCode<CounterStorage, CountersLandlord> DeleteCounterStorage(string id, bool isHardDeleteNeeded);
    private MessageWithStatusCode<CounterStorage, CountersLandlord> ToggleCounterStorageDisabled(string id, bool isSettingDisabled);
    [AsyncStateMachineAttribute("Raven.Database.Counters.Controllers.AdminCounterStorageController/<Backup>d__12")]
[HttpPostAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/admin/backup")]
public Task`1<HttpResponseMessage> Backup();
    [RavenRouteAttribute("cs/{counterStorageName}/admin/replication/topology/view")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> ReplicationTopology();
}
public abstract class Raven.Database.Counters.Controllers.BaseAdminCountersApiController : AdminResourceApiController`2<CounterStorage, CountersLandlord> {
    public ResourceType ResourceType { get; }
    public string CounterName { get; }
    public CounterStorage Counters { get; }
    public virtual ResourceType get_ResourceType();
    public string get_CounterName();
    public CounterStorage get_Counters();
    public virtual void MarkRequestDuration(long duration);
}
public abstract class Raven.Database.Counters.Controllers.BaseCountersApiController : ResourceApiController`2<CounterStorage, CountersLandlord> {
    protected string CountersName { get; }
    protected CounterStorage CounterStorage { get; }
    public ResourceType ResourceType { get; }
    protected string get_CountersName();
    protected CounterStorage get_CounterStorage();
    public virtual ResourceType get_ResourceType();
    public virtual void MarkRequestDuration(long duration);
}
public class Raven.Database.Counters.Controllers.ClusterAwareCountersApiController : BaseCountersApiController {
    protected bool ForceClusterAwareness { get; }
    protected virtual bool get_ForceClusterAwareness();
    [AsyncStateMachineAttribute("Raven.Database.Counters.Controllers.ClusterAwareCountersApiController/<ExecuteAsync>d__2")]
public virtual Task`1<HttpResponseMessage> ExecuteAsync(HttpControllerContext controllerContext, CancellationToken cancellationToken);
    private static bool IsReadRequest(HttpControllerContext controllerContext);
    private static string GetClusterHeader(HttpControllerContext controllerContext, string key);
    private HttpResponseMessage RedirectToLeader(HttpRequestMessage request);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpControllerContext controllerContext, CancellationToken cancellationToken);
}
public class Raven.Database.Counters.Controllers.CounterOperationsController : BaseCountersApiController {
    [RavenRouteAttribute("cs/{counterStorageName}/sinceEtag")]
[HttpGetAttribute]
public HttpResponseMessage GetCounterStatesSinceEtag(long etag, int skip, int take);
    [RavenRouteAttribute("cs/{counterStorageName}/change")]
[HttpPostAttribute]
public HttpResponseMessage Change(string groupName, string counterName, long delta);
    [HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/groups")]
public HttpResponseMessage GetCounterGroups(int skip, int take);
    [RavenRouteAttribute("cs/{counterStorageName}/batch")]
[AsyncStateMachineAttribute("Raven.Database.Counters.Controllers.CounterOperationsController/<CountersBatch>d__3")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> CountersBatch();
    [IteratorStateMachineAttribute("Raven.Database.Counters.Controllers.CounterOperationsController/<YieldChangeBatches>d__4")]
private IEnumerable`1<IEnumerable`1<CounterChange>> YieldChangeBatches(Stream requestStream, CancellationTimeout timeout, Action`1<int> changeCounterFunc);
    [IteratorStateMachineAttribute("Raven.Database.Counters.Controllers.CounterOperationsController/<YieldBatchItems>d__5")]
private IEnumerable`1<CounterChange> YieldBatchItems(Stream partialStream, JsonSerializer serializer, CancellationTimeout timeout, Action`1<int> changeCounterFunc);
    [RavenRouteAttribute("cs/{counterStorageName}/reset")]
[HttpPostAttribute]
public HttpResponseMessage Reset(string groupName, string counterName);
    [HttpDeleteAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/delete")]
public HttpResponseMessage Delete(string groupName, string counterName);
    [HttpDeleteAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/delete-by-group")]
public HttpResponseMessage DeleteByGroup(string groupName);
    [RavenRouteAttribute("cs/{counterStorageName}/counters")]
[HttpGetAttribute]
public HttpResponseMessage GetCounterSummariesByGroup(int skip, int take, string group);
    [RavenRouteAttribute("cs/{counterStorageName}/getCounterOverallTotal")]
[HttpGetAttribute]
public HttpResponseMessage GetCounterOverallTotal(string groupName, string counterName);
    [RavenRouteAttribute("cs/{counterStorageName}/by-prefix")]
[HttpGetAttribute]
public HttpResponseMessage GetCountersByPrefix(string groupName, int skip, int take, string counterNamePrefix);
    private bool ValidateSkipAndTake(int skip, int take, HttpResponseMessage& messageWithObject);
    [RavenRouteAttribute("cs/{counterStorageName}/getCounter")]
[HttpGetAttribute]
public HttpResponseMessage GetCounter(string groupName, string counterName);
    [HttpPostAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/purge-tombstones")]
public HttpResponseMessage PurgeTombstones();
    private HttpResponseMessage VerifyGroupAndCounterName(string groupName, string counterName);
    [CompilerGeneratedAttribute]
private void <DeleteByGroup>b__9_0(ChangeNotification change);
}
public class Raven.Database.Counters.Controllers.CountersChangesController : BaseCountersApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/changes/config")]
public HttpResponseMessage GetChangeConfig();
    [HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/changes/events")]
public HttpResponseMessage GetChangesEvents();
}
public class Raven.Database.Counters.Controllers.CountersController : BaseDatabaseApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("cs")]
public HttpResponseMessage Counters(int skip, int take, bool getAdditionalData);
    [HttpGetAttribute]
[RavenRouteAttribute("cs/exists")]
public HttpResponseMessage Exists(string storageName);
    private static List`1<CounterStorageData> GetCounterStoragesData(IEnumerable`1<RavenJToken> counterStorages, int skip, int take);
}
public class Raven.Database.Counters.Controllers.CounterSingleAuthTokenController : BaseCountersApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/singleAuthToken")]
public HttpResponseMessage SingleAuthGet();
}
public class Raven.Database.Counters.Controllers.CountersReplicationController : BaseCountersApiController {
    [RavenRouteAttribute("cs/{counterStorageName}/lastEtag")]
[HttpGetAttribute]
public HttpResponseMessage GetLastEtag(Guid serverId);
    [AsyncStateMachineAttribute("Raven.Database.Counters.Controllers.CountersReplicationController/<Post>d__1")]
[HttpPostAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/replication")]
public Task`1<HttpResponseMessage> Post();
    [RavenRouteAttribute("cs/{counterStorageName}/replication/heartbeat")]
[HttpPostAttribute]
public HttpResponseMessage HeartbeatPost(string sourceServer);
    [RavenRouteAttribute("cs/{counterStorageName}/replication/config")]
[HttpGetAttribute]
public HttpResponseMessage ReplicationsGet();
    [HttpPostAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/replication/config")]
[AsyncStateMachineAttribute("Raven.Database.Counters.Controllers.CountersReplicationController/<ReplicationsSave>d__4")]
public Task`1<HttpResponseMessage> ReplicationsSave();
}
public class Raven.Database.Counters.Controllers.CountersReplicationTopologyController : BaseCountersApiController {
    [RavenRouteAttribute("cs/{counterStorageName}/admin/replication/topology/discover")]
[AsyncStateMachineAttribute("Raven.Database.Counters.Controllers.CountersReplicationTopologyController/<ReplicationTopologyDiscover>d__0")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> ReplicationTopologyDiscover();
}
public class Raven.Database.Counters.Controllers.CountersStatsController : BaseCountersApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/stats")]
public HttpResponseMessage CounterStats();
    [HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/metrics")]
public HttpResponseMessage CounterMetrics();
    [HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/replications/stats")]
public HttpResponseMessage ReplicationStats(int skip, int take);
}
public class Raven.Database.Counters.Controllers.CounterStreamsController : ClusterAwareCountersApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/streams/groups")]
public HttpResponseMessage StreamCounterGroups();
    [HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/streams/summaries")]
public HttpResponseMessage StreamCounterSummaries(string group, string counterNamePrefix);
    private bool GetRelevantWriterFactory(Func`2& getWriter, HttpResponseMessage& errorResponse);
    private bool GetAndValidateSkipAndTake(Int32& skip, Int32& take, HttpResponseMessage& httpResponseMessage);
    private HttpResponseMessage GetSummariesForAllGroupsStreamResponse(int skip, int take, HttpResponseMessage response, Func`2<Stream, IOutputWriter> getWriter);
    private HttpResponseMessage GetSummariesPerGroupStreamResponse(string group, int skip, int take, HttpResponseMessage response, Func`2<Stream, IOutputWriter> getWriter);
    private HttpResponseMessage GetSummariesPerGroupByPrefixStreamResponse(string group, string counterNamePrefix, int skip, int take, HttpResponseMessage response, Func`2<Stream, IOutputWriter> getWriter);
    private bool ValidateStreamFormat(string writer, HttpResponseMessage& response);
    private static bool IsCsvDownloadRequest(HttpRequestMessage request);
}
public class Raven.Database.Counters.Controllers.ReplicationTask : object {
    private static ILog Log;
    private object waitForCounterUpdate;
    private int actualWorkCounter;
    private int replicatedWorkCounter;
    private ConcurrentDictionary`2<string, CounterDestinationStats> destinationsStats;
    private int replicationAttempts;
    private ConcurrentDictionary`2<string, SemaphoreSlim> activeReplicationTasks;
    private ConcurrentQueue`1<Task> activeTasks;
    private HttpRavenRequestFactory httpRavenRequestFactory;
    private CounterStorage storage;
    private CancellationTokenSource cancellation;
    public ConcurrentDictionary`2<string, CounterDestinationStats> DestinationStats { get; }
    public ReplicationTask(CounterStorage storage);
    private static ReplicationTask();
    public void SignalCounterUpdate();
    public void StartReplication();
    private void ReplicationAction();
    private bool WaitForCountersUpdate(TimeSpan timeout);
    public void HandleHeartbeat(string src);
    private void ResetFailureForHeartbeat(string src);
    public void SendReplicationToAllServers(bool runningBecauseOfDataModifications);
    private void ReplicateToDestination(CounterReplicationDestination destination);
    private bool ReplicateTo(CounterReplicationDestination destination);
    private ReplicationResult TryReplicate(CounterReplicationDestination destination, Int64& lastEtagSent, String& lastError);
    private bool GetLastReplicatedEtagFrom(RavenConnectionStringOptions connectionStringOptions, string counterStorageUrl, Int64& lastEtag, String& lastError);
    private bool TryGetLastReplicatedEtagFrom(RavenConnectionStringOptions connectionStringOptions, string counterStorageUrl, Int64& lastEtag, String& lastError);
    private bool PerformReplicationToServer(RavenConnectionStringOptions connectionStringOptions, string counterStorageUrl, ReplicationMessage message, String& lastError);
    private bool TryPerformReplicationToServer(RavenConnectionStringOptions connectionStringOptions, string counterStorageUrl, ReplicationMessage message, String& lastError);
    private List`1<CounterReplicationDestination> GetReplicationDestinations();
    private bool IsNotFailing(string destServerName, int currentReplicationAttempts);
    private ReplicationMessage GetCountersDataSinceEtag(long etag, Int64& lastEtagSent, int take);
    private RavenConnectionStringOptions GetConnectionOptionsSafe(CounterReplicationDestination destination, String& lastError);
    private bool IsFirstFailure(string destinationUrl);
    private void NotifySiblings();
    private void NotifySibling(BlockingCollection`1<RavenConnectionStringOptions> collection);
    private void RecordSuccess(string url, Nullable`1<DateTime> lastSuccessTimestamp, Nullable`1<long> lastReplicatedEtag, Nullable`1<DateTime> lastReplicatedLastModified, Nullable`1<DateTime> lastHeartbeatReceived, string lastError);
    private void RecordFailure(string url, string lastError);
    private string HandleReplicationDistributionWebException(WebException e, string destinationUrl);
    public int GetActiveTasksCount();
    public ConcurrentDictionary`2<string, CounterDestinationStats> get_DestinationStats();
    public sealed virtual void Dispose();
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Counters.CountersMetricsManager : object {
    private Metrics counterMetrics;
    [CompilerGeneratedAttribute]
private PerSecondCounterMetric <RequestsPerSecondCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <Increments>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <Decrements>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <Resets>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <Deletes>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <ClientRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <IncomingReplications>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <OutgoingReplications>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramMetric <IncSizeMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramMetric <DecSizeMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramMetric <RequestDurationMetric>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, MeterMetric> <ReplicationBatchSizeMeter>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, HistogramMetric> <ReplicationBatchSizeHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, HistogramMetric> <ReplicationDurationHistogram>k__BackingField;
    public long ConcurrentRequestsCount;
    public PerSecondCounterMetric RequestsPerSecondCounter { get; private set; }
    public MeterMetric Increments { get; private set; }
    public MeterMetric Decrements { get; private set; }
    public MeterMetric Resets { get; private set; }
    public MeterMetric Deletes { get; private set; }
    public MeterMetric ClientRequests { get; private set; }
    public MeterMetric IncomingReplications { get; private set; }
    public MeterMetric OutgoingReplications { get; private set; }
    public HistogramMetric IncSizeMetrics { get; private set; }
    public HistogramMetric DecSizeMetrics { get; private set; }
    public HistogramMetric RequestDurationMetric { get; private set; }
    public ConcurrentDictionary`2<string, MeterMetric> ReplicationBatchSizeMeter { get; private set; }
    public ConcurrentDictionary`2<string, HistogramMetric> ReplicationBatchSizeHistogram { get; private set; }
    public ConcurrentDictionary`2<string, HistogramMetric> ReplicationDurationHistogram { get; private set; }
    public Dictionary`2<string, Dictionary`2<string, string>> Gauges { get; }
    [CompilerGeneratedAttribute]
public PerSecondCounterMetric get_RequestsPerSecondCounter();
    [CompilerGeneratedAttribute]
private void set_RequestsPerSecondCounter(PerSecondCounterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_Increments();
    [CompilerGeneratedAttribute]
private void set_Increments(MeterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_Decrements();
    [CompilerGeneratedAttribute]
private void set_Decrements(MeterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_Resets();
    [CompilerGeneratedAttribute]
private void set_Resets(MeterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_Deletes();
    [CompilerGeneratedAttribute]
private void set_Deletes(MeterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_ClientRequests();
    [CompilerGeneratedAttribute]
private void set_ClientRequests(MeterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_IncomingReplications();
    [CompilerGeneratedAttribute]
private void set_IncomingReplications(MeterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_OutgoingReplications();
    [CompilerGeneratedAttribute]
private void set_OutgoingReplications(MeterMetric value);
    [CompilerGeneratedAttribute]
public HistogramMetric get_IncSizeMetrics();
    [CompilerGeneratedAttribute]
private void set_IncSizeMetrics(HistogramMetric value);
    [CompilerGeneratedAttribute]
public HistogramMetric get_DecSizeMetrics();
    [CompilerGeneratedAttribute]
private void set_DecSizeMetrics(HistogramMetric value);
    [CompilerGeneratedAttribute]
public HistogramMetric get_RequestDurationMetric();
    [CompilerGeneratedAttribute]
private void set_RequestDurationMetric(HistogramMetric value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, MeterMetric> get_ReplicationBatchSizeMeter();
    [CompilerGeneratedAttribute]
private void set_ReplicationBatchSizeMeter(ConcurrentDictionary`2<string, MeterMetric> value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, HistogramMetric> get_ReplicationBatchSizeHistogram();
    [CompilerGeneratedAttribute]
private void set_ReplicationBatchSizeHistogram(ConcurrentDictionary`2<string, HistogramMetric> value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, HistogramMetric> get_ReplicationDurationHistogram();
    [CompilerGeneratedAttribute]
private void set_ReplicationDurationHistogram(ConcurrentDictionary`2<string, HistogramMetric> value);
    public void AddGauge(Type type, string name, Func`1<T> function);
    public Dictionary`2<string, Dictionary`2<string, string>> get_Gauges();
    public sealed virtual void Dispose();
    public MeterMetric GetReplicationBatchSizeMetric(string serverUrl);
    public HistogramMetric GetReplicationBatchSizeHistogram(string serverUrl);
    public HistogramMetric GetReplicationDurationHistogram(string serverUrl);
    [CompilerGeneratedAttribute]
private MeterMetric <GetReplicationBatchSizeMetric>b__63_0(string s);
    [CompilerGeneratedAttribute]
private HistogramMetric <GetReplicationBatchSizeHistogram>b__64_0(string s);
    [CompilerGeneratedAttribute]
private HistogramMetric <GetReplicationDurationHistogram>b__65_0(string s);
}
public class Raven.Database.Counters.CounterStorage : object {
    private static ILog Log;
    private StorageEnvironment storageEnvironment;
    private TransportState transportState;
    private CountersMetricsManager metricsCounters;
    private NotificationPublisher notificationPublisher;
    private ReplicationTask replicationTask;
    private JsonSerializer jsonSerializer;
    private Guid tombstoneId;
    private int sizeOfGuid;
    private TimeSpan tombstoneRetentionTime;
    private int deletedTombstonesInBatch;
    private long lastEtag;
    private long lastCounterId;
    private Timer purgeTombstonesTimer;
    [CompilerGeneratedAttribute]
private Action CounterUpdated;
    [CompilerGeneratedAttribute]
private string <CounterStorageUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplicationTimeoutInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private AtomicDictionary`1<object> <ExtensionsState>k__BackingField;
    [CompilerGeneratedAttribute]
private InMemoryRavenConfiguration <Configuration>k__BackingField;
    public string CounterStorageUrl { get; private set; }
    public DateTime LastWrite { get; private set; }
    public Guid ServerId { get; private set; }
    public string Name { get; private set; }
    public string ResourceName { get; private set; }
    public int ReplicationTimeoutInMs { get; private set; }
    private string Raven.Database.Common.IResourceStore.Name { get; }
    [CLSCompliantAttribute("False")]
public CountersMetricsManager MetricsCounters { get; }
    public TransportState TransportState { get; }
    public NotificationPublisher Publisher { get; }
    public ReplicationTask ReplicationTask { get; }
    public StorageEnvironment Environment { get; }
    private JsonSerializer JsonSerializer { get; }
    public AtomicDictionary`1<object> ExtensionsState { get; private set; }
    public InMemoryRavenConfiguration Configuration { get; private set; }
    public CounterStorage(string serverUrl, string storageName, InMemoryRavenConfiguration configuration, TransportState receivedTransportState);
    private static CounterStorage();
    [CompilerGeneratedAttribute]
public void add_CounterUpdated(Action value);
    [CompilerGeneratedAttribute]
public void remove_CounterUpdated(Action value);
    [CompilerGeneratedAttribute]
public string get_CounterStorageUrl();
    [CompilerGeneratedAttribute]
private void set_CounterStorageUrl(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastWrite();
    [CompilerGeneratedAttribute]
private void set_LastWrite(DateTime value);
    [CompilerGeneratedAttribute]
public Guid get_ServerId();
    [CompilerGeneratedAttribute]
private void set_ServerId(Guid value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResourceName();
    [CompilerGeneratedAttribute]
private void set_ResourceName(string value);
    [CompilerGeneratedAttribute]
public int get_ReplicationTimeoutInMs();
    [CompilerGeneratedAttribute]
private void set_ReplicationTimeoutInMs(int value);
    private void Initialize();
    private void BackgroundActionsCallback(object state);
    private sealed virtual override string Raven.Database.Common.IResourceStore.get_Name();
    public CountersMetricsManager get_MetricsCounters();
    public sealed virtual TransportState get_TransportState();
    public NotificationPublisher get_Publisher();
    public ReplicationTask get_ReplicationTask();
    public StorageEnvironment get_Environment();
    private JsonSerializer get_JsonSerializer();
    [CompilerGeneratedAttribute]
public sealed virtual AtomicDictionary`1<object> get_ExtensionsState();
    [CompilerGeneratedAttribute]
private void set_ExtensionsState(AtomicDictionary`1<object> value);
    [CompilerGeneratedAttribute]
public sealed virtual InMemoryRavenConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(InMemoryRavenConfiguration value);
    public CounterStorageStats CreateStats();
    public CountersStorageMetrics CreateMetrics();
    private static StorageEnvironmentOptions CreateStorageOptionsFromConfiguration(string path, NameValueCollection settings);
    [CLSCompliantAttribute("False")]
public Reader CreateReader();
    [CLSCompliantAttribute("False")]
public Writer CreateWriter();
    private void Notify();
    public sealed virtual void Dispose();
}
public class Raven.Database.Counters.Notifications.NotificationPublisher : object {
    private TransportState transportState;
    public NotificationPublisher(TransportState transportState);
    public void RaiseNotification(ChangeNotification notification);
    public void RaiseNotification(BulkOperationNotification change);
}
public class Raven.Database.Counters.Replication.CountersReplicationTopology : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Servers>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<CountersReplicationTopologyConnection> <Connections>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <SkippedResources>k__BackingField;
    public HashSet`1<string> Servers { get; public set; }
    public HashSet`1<CountersReplicationTopologyConnection> Connections { get; public set; }
    public HashSet`1<string> SkippedResources { get; public set; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Servers();
    [CompilerGeneratedAttribute]
public void set_Servers(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<CountersReplicationTopologyConnection> get_Connections();
    [CompilerGeneratedAttribute]
public void set_Connections(HashSet`1<CountersReplicationTopologyConnection> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SkippedResources();
    [CompilerGeneratedAttribute]
public void set_SkippedResources(HashSet`1<string> value);
    public CountersReplicationTopologyConnection GetConnection(string fromUrl, string toUrl);
}
public class Raven.Database.Counters.Replication.CountersReplicationTopologyConnection : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SendServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <StoredServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicatonNodeState <SourceToDestinationState>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicatonNodeState <DestinationToSourceState>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    public string Source { get; public set; }
    public string Destination { get; public set; }
    public Guid SendServerId { get; public set; }
    public Guid StoredServerId { get; public set; }
    public long LastEtag { get; public set; }
    public ReplicatonNodeState SourceToDestinationState { get; public set; }
    public ReplicatonNodeState DestinationToSourceState { get; public set; }
    public List`1<string> Errors { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    [CompilerGeneratedAttribute]
public Guid get_SendServerId();
    [CompilerGeneratedAttribute]
public void set_SendServerId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_StoredServerId();
    [CompilerGeneratedAttribute]
public void set_StoredServerId(Guid value);
    [CompilerGeneratedAttribute]
public long get_LastEtag();
    [CompilerGeneratedAttribute]
public void set_LastEtag(long value);
    [CompilerGeneratedAttribute]
public ReplicatonNodeState get_SourceToDestinationState();
    [CompilerGeneratedAttribute]
public void set_SourceToDestinationState(ReplicatonNodeState value);
    [CompilerGeneratedAttribute]
public ReplicatonNodeState get_DestinationToSourceState();
    [CompilerGeneratedAttribute]
public void set_DestinationToSourceState(ReplicatonNodeState value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<string> value);
}
public class Raven.Database.Counters.Replication.CountersReplicationTopologyDestinationNode : CountersReplicationTopologyNode {
    [CompilerGeneratedAttribute]
private Guid <SendServerId>k__BackingField;
    public Guid SendServerId { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_SendServerId();
    [CompilerGeneratedAttribute]
public void set_SendServerId(Guid value);
    public static CountersReplicationTopologyDestinationNode Online(string serverUrl, Guid serverId);
    public static CountersReplicationTopologyDestinationNode Offline(string serverUrl, Guid serverId);
    public static CountersReplicationTopologyDestinationNode Disabled(string serverUrl, Guid serverId);
}
internal class Raven.Database.Counters.Replication.CountersReplicationTopologyDiscoverer : object {
    private CounterStorage counterStorage;
    private int ttl;
    private ILog log;
    private RavenJArray from;
    private HttpRavenRequestFactory requestFactory;
    public CountersReplicationTopologyDiscoverer(CounterStorage counterStorage, RavenJArray from, int ttl, ILog log);
    public CountersReplicationTopologyRootNode Discover();
    private List`1<CountersReplicationTopologySourceNode> HandleSources(IEnumerable`1<ReplicationSourceInfo> serverSources, CountersReplicationTopologyRootNode root);
    private CountersReplicationTopologySourceNode HandleSource(ReplicationSourceInfo source);
    private List`1<CountersReplicationTopologyDestinationNode> HandleDestinations(List`1<CounterReplicationDestination> destinations);
    private CountersReplicationTopologyDestinationNode HandleDestination(CounterReplicationDestination replicationDestination);
    private bool FetchTargetServerUrl(string serverUrl, RavenConnectionStringOptions connectionStringOptions, String& targetServerUrl, String& error);
    private bool TryGetSchema(string serverUrl, RavenConnectionStringOptions connectionStringOptions, CountersReplicationTopologyRootNode& rootNode, String& error);
    private void FindVisitedNodes(CountersReplicationTopologyNodeBase rootNode, HashSet`1<string> visitedNodes);
    private ReplicatonNodeState CheckSourceConnectionState(string sourceUrl);
    private ReplicatonNodeState CheckConnectionState(string serverUrl, RavenConnectionStringOptions connectionStringOptions);
}
public abstract class Raven.Database.Counters.Replication.CountersReplicationTopologyNode : CountersReplicationTopologyNodeBase {
    [CompilerGeneratedAttribute]
private ReplicatonNodeState <State>k__BackingField;
    public ReplicatonNodeState State { get; protected set; }
    [CompilerGeneratedAttribute]
public ReplicatonNodeState get_State();
    [CompilerGeneratedAttribute]
protected void set_State(ReplicatonNodeState value);
}
public abstract class Raven.Database.Counters.Replication.CountersReplicationTopologyNodeBase : object {
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CountersReplicationTopologySourceNode> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CountersReplicationTopologyDestinationNode> <Destinations>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    public string ServerUrl { get; protected set; }
    public List`1<CountersReplicationTopologySourceNode> Sources { get; public set; }
    public List`1<CountersReplicationTopologyDestinationNode> Destinations { get; public set; }
    public List`1<string> Errors { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
protected void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public List`1<CountersReplicationTopologySourceNode> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(List`1<CountersReplicationTopologySourceNode> value);
    [CompilerGeneratedAttribute]
public List`1<CountersReplicationTopologyDestinationNode> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(List`1<CountersReplicationTopologyDestinationNode> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<string> value);
}
public class Raven.Database.Counters.Replication.CountersReplicationTopologyRootNode : CountersReplicationTopologyNodeBase {
    [CompilerGeneratedAttribute]
private Guid <ServerId>k__BackingField;
    public Guid ServerId { get; public set; }
    public CountersReplicationTopologyRootNode(string serverUrl, Guid serverId);
    [CompilerGeneratedAttribute]
public Guid get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(Guid value);
    private static void HandleLink(CountersReplicationTopology topology, CountersReplicationTopologyNodeBase source, CountersReplicationTopologyNodeBase target);
    public CountersReplicationTopology Flatten();
}
public class Raven.Database.Counters.Replication.CountersReplicationTopologySourceNode : CountersReplicationTopologyNode {
    [CompilerGeneratedAttribute]
private Guid <StoredServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastEtag>k__BackingField;
    public Guid StoredServerId { get; public set; }
    public long LastEtag { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_StoredServerId();
    [CompilerGeneratedAttribute]
public void set_StoredServerId(Guid value);
    [CompilerGeneratedAttribute]
public long get_LastEtag();
    [CompilerGeneratedAttribute]
public void set_LastEtag(long value);
    public static CountersReplicationTopologySourceNode Online(string serverUrl, Guid serverId, long lastEtag);
    public static CountersReplicationTopologySourceNode Offline(string serverUrl, Guid serverId, long lastEtag);
}
public class Raven.Database.Counters.ReplicationMessage : object {
    [CompilerGeneratedAttribute]
private string <SendingServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CounterState> <Counters>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ServerId>k__BackingField;
    public string SendingServerName { get; public set; }
    public List`1<CounterState> Counters { get; public set; }
    public Guid ServerId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SendingServerName();
    [CompilerGeneratedAttribute]
public void set_SendingServerName(string value);
    [CompilerGeneratedAttribute]
public List`1<CounterState> get_Counters();
    [CompilerGeneratedAttribute]
public void set_Counters(List`1<CounterState> value);
    [CompilerGeneratedAttribute]
public Guid get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(Guid value);
}
public static class Raven.Database.Counters.ValueSign : object {
    public static char Positive;
    public static char Negative;
}
public class Raven.Database.Data.AddIncludesCommand : object {
    [CompilerGeneratedAttribute]
private String[] <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<Etag, RavenJObject, bool> <Add>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionInformation <TransactionInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <LoadedIds>k__BackingField;
    private String[] Includes { get; private set; }
    private Action`3<Etag, RavenJObject, bool> Add { get; private set; }
    private DocumentDatabase Database { get; private set; }
    private TransactionInformation TransactionInformation { get; private set; }
    private HashSet`1<string> LoadedIds { get; private set; }
    public AddIncludesCommand(DocumentDatabase database, TransactionInformation transactionInformation, Action`3<Etag, RavenJObject, bool> add, String[] includes, HashSet`1<string> loadedIds);
    public void AlsoInclude(IEnumerable`1<string> ids);
    [CompilerGeneratedAttribute]
private String[] get_Includes();
    [CompilerGeneratedAttribute]
private void set_Includes(String[] value);
    [CompilerGeneratedAttribute]
private Action`3<Etag, RavenJObject, bool> get_Add();
    [CompilerGeneratedAttribute]
private void set_Add(Action`3<Etag, RavenJObject, bool> value);
    [CompilerGeneratedAttribute]
private DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
private void set_Database(DocumentDatabase value);
    [CompilerGeneratedAttribute]
private TransactionInformation get_TransactionInformation();
    [CompilerGeneratedAttribute]
private void set_TransactionInformation(TransactionInformation value);
    [CompilerGeneratedAttribute]
private HashSet`1<string> get_LoadedIds();
    [CompilerGeneratedAttribute]
private void set_LoadedIds(HashSet`1<string> value);
    public void Execute(RavenJObject document);
    private bool LoadId(string value);
}
public static class Raven.Database.Data.CommandDataFactory : object {
    private static Char[] IllegalHeaderChars;
    private static CommandDataFactory();
    public static ICommandData CreateCommand(RavenJObject jsonCommand, TransactionInformation transactionInformation);
    private static void ValidateMetadataKeys(RavenJObject metaDataProps);
    private static Etag GetEtagFromCommand(RavenJObject jsonCommand);
}
public class Raven.Database.Data.DiskSpaceNotification : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private PathType <PathType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FreeSpaceInPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FreeSpaceInBytes>k__BackingField;
    public string Path { get; private set; }
    public PathType PathType { get; private set; }
    public double FreeSpaceInPercentage { get; private set; }
    public double FreeSpaceInBytes { get; private set; }
    public DiskSpaceNotification(string path, PathType pathType, double freeSpaceInBytes, double freeSpaceInPercentage);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public PathType get_PathType();
    [CompilerGeneratedAttribute]
private void set_PathType(PathType value);
    [CompilerGeneratedAttribute]
public double get_FreeSpaceInPercentage();
    [CompilerGeneratedAttribute]
private void set_FreeSpaceInPercentage(double value);
    [CompilerGeneratedAttribute]
public double get_FreeSpaceInBytes();
    [CompilerGeneratedAttribute]
private void set_FreeSpaceInBytes(double value);
}
public class Raven.Database.Data.DynamicQueryMapping : object {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ForEntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicSortInfo[] <SortDescriptors>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicQueryMappingItem[] <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <HighlightedFields>k__BackingField;
    private List`1<Action`1<IndexDefinition>> extraActionsToPerform;
    private static Regex replaceInvalidCharacterForFields;
    public string IndexName { get; public set; }
    public string ForEntityName { get; public set; }
    public DynamicSortInfo[] SortDescriptors { get; public set; }
    public DynamicQueryMappingItem[] Items { get; public set; }
    public String[] HighlightedFields { get; public set; }
    private static DynamicQueryMapping();
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public string get_ForEntityName();
    [CompilerGeneratedAttribute]
public void set_ForEntityName(string value);
    [CompilerGeneratedAttribute]
public DynamicSortInfo[] get_SortDescriptors();
    [CompilerGeneratedAttribute]
public void set_SortDescriptors(DynamicSortInfo[] value);
    [CompilerGeneratedAttribute]
public DynamicQueryMappingItem[] get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(DynamicQueryMappingItem[] value);
    [CompilerGeneratedAttribute]
public String[] get_HighlightedFields();
    [CompilerGeneratedAttribute]
public void set_HighlightedFields(String[] value);
    public IndexDefinition CreateIndexDefinition();
    private string ToFieldName(string field);
    public static DynamicQueryMapping Create(DocumentDatabase database, string query, string entityName);
    public static DynamicQueryMapping Create(DocumentDatabase database, IndexQuery query, string entityName);
    private void SetupSortDescriptors(DynamicSortInfo[] sortDescriptors);
    public void AddExistingIndexDefinition(IndexDefinition indexDefinition, DocumentDatabase database, IndexQuery query);
    private void SetupFieldsToIndex(IndexQuery query, IEnumerable`1<Tuple`2<string, string>> fields);
    private string EscapeParentheses(string str);
    public static string ReplaceInvalidCharactersForFields(string field);
    public static DynamicSortInfo[] GetSortInfo(Action`1<string> addField, IndexQuery indexQuery);
    private void FindIndexName(DocumentDatabase database, DynamicQueryMapping map, IndexQuery query);
    [CompilerGeneratedAttribute]
private bool <AddExistingIndexDefinition>b__27_0(KeyValuePair`2<string, string> field);
    [CompilerGeneratedAttribute]
private DynamicQueryMappingItem <AddExistingIndexDefinition>b__27_1(KeyValuePair`2<string, string> field);
    [CompilerGeneratedAttribute]
private bool <AddExistingIndexDefinition>b__27_2(KeyValuePair`2<string, SortOptions> option);
    [CompilerGeneratedAttribute]
private DynamicQueryMappingItem <SetupFieldsToIndex>b__29_0(Tuple`2<string, string> x);
}
public class Raven.Database.Data.DynamicQueryMappingItem : object {
    [CompilerGeneratedAttribute]
private string <QueryFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private string <From>k__BackingField;
    [CompilerGeneratedAttribute]
private string <To>k__BackingField;
    public string QueryFrom { get; public set; }
    public string From { get; public set; }
    public string To { get; public set; }
    [CompilerGeneratedAttribute]
public string get_QueryFrom();
    [CompilerGeneratedAttribute]
public void set_QueryFrom(string value);
    [CompilerGeneratedAttribute]
public string get_From();
    [CompilerGeneratedAttribute]
public void set_From(string value);
    [CompilerGeneratedAttribute]
public string get_To();
    [CompilerGeneratedAttribute]
public void set_To(string value);
}
public class Raven.Database.Data.ExecutingQueryInfo : object {
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexQuery <QueryInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private long <QueryId>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationTokenSource <TokenSource>k__BackingField;
    private Stopwatch stopwatch;
    public DateTime StartTime { get; private set; }
    public IndexQuery QueryInfo { get; private set; }
    public long QueryId { get; private set; }
    [JsonIgnoreAttribute]
public CancellationTokenSource TokenSource { get; private set; }
    public TimeSpan Duration { get; }
    public ExecutingQueryInfo(DateTime startTime, IndexQuery queryInfo, long queryId, CancellationTokenSource tokenSource);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public IndexQuery get_QueryInfo();
    [CompilerGeneratedAttribute]
private void set_QueryInfo(IndexQuery value);
    [CompilerGeneratedAttribute]
public long get_QueryId();
    [CompilerGeneratedAttribute]
private void set_QueryId(long value);
    [CompilerGeneratedAttribute]
public CancellationTokenSource get_TokenSource();
    [CompilerGeneratedAttribute]
private void set_TokenSource(CancellationTokenSource value);
    public TimeSpan get_Duration();
}
public class Raven.Database.Data.IndexQueryResult : object {
    [CompilerGeneratedAttribute]
private JsonDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DocumentLoaded>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReduceVal>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Projection>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Score>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <Highligtings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HighlighterKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScoreExplanation>k__BackingField;
    public JsonDocument Document { get; public set; }
    public bool DocumentLoaded { get; public set; }
    public string Key { get; public set; }
    public string ReduceVal { get; public set; }
    public RavenJObject Projection { get; public set; }
    public float Score { get; public set; }
    public Dictionary`2<string, String[]> Highligtings { get; public set; }
    public string HighlighterKey { get; public set; }
    public string ScoreExplanation { get; public set; }
    [CompilerGeneratedAttribute]
public JsonDocument get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(JsonDocument value);
    [CompilerGeneratedAttribute]
public bool get_DocumentLoaded();
    [CompilerGeneratedAttribute]
public void set_DocumentLoaded(bool value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public string get_ReduceVal();
    [CompilerGeneratedAttribute]
public void set_ReduceVal(string value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Projection();
    [CompilerGeneratedAttribute]
public void set_Projection(RavenJObject value);
    [CompilerGeneratedAttribute]
public float get_Score();
    [CompilerGeneratedAttribute]
public void set_Score(float value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, String[]> get_Highligtings();
    [CompilerGeneratedAttribute]
public void set_Highligtings(Dictionary`2<string, String[]> value);
    [CompilerGeneratedAttribute]
public string get_HighlighterKey();
    [CompilerGeneratedAttribute]
public void set_HighlighterKey(string value);
    [CompilerGeneratedAttribute]
public string get_ScoreExplanation();
    [CompilerGeneratedAttribute]
public void set_ScoreExplanation(string value);
    public sealed virtual bool Equals(IndexQueryResult other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(IndexQueryResult left, IndexQueryResult right);
    public static bool op_Inequality(IndexQueryResult left, IndexQueryResult right);
}
public enum Raven.Database.Data.PathType : Enum {
    public int value__;
    public static PathType Data;
    public static PathType Index;
    public static PathType Journal;
}
public class Raven.Database.Data.QueryResultWithIncludes : QueryResult {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <IdsToInclude>k__BackingField;
    [JsonIgnoreAttribute]
public HashSet`1<string> IdsToInclude { get; public set; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_IdsToInclude();
    [CompilerGeneratedAttribute]
public void set_IdsToInclude(HashSet`1<string> value);
}
public abstract class Raven.Database.DiskIO.AbstractDiskPerformanceTester : object {
    public static string PerformanceResultDocumentKey;
    public static string TemporaryFileName;
    public static string TemporaryJournalFileName;
    protected ConcurrentBag`1<Exception> errors;
    protected bool hasFailed;
    public bool HasFailed { get; }
    public DiskPerformanceResult Result { get; }
    public IEnumerable`1<Exception> Errors { get; }
    public bool get_HasFailed();
    public abstract virtual void TestDiskIO();
    public abstract virtual DiskPerformanceResult get_Result();
    public IEnumerable`1<Exception> get_Errors();
    public static AbstractDiskPerformanceTester ForRequest(AbstractPerformanceTestRequest ioTestRequest, Action`1<string> add, CancellationToken token);
    public abstract virtual void Dispose();
    public abstract virtual void DescribeTestParameters();
}
public abstract class Raven.Database.DiskIO.AbstractDiskPerformanceTester`1 : AbstractDiskPerformanceTester {
    protected TRequest testRequest;
    protected Action`1<string> onInfo;
    protected CancellationTokenSource testTimerCts;
    protected CancellationTokenSource linkedCts;
    protected CancellationToken taskKillToken;
    protected DiskPerformanceStorage dataStorage;
    protected string filePath;
    protected Timer secondTimer;
    protected long statCounter;
    protected long testTime;
    protected ILog log;
    public DiskPerformanceResult Result { get; }
    protected AbstractDiskPerformanceTester`1(TRequest testRequest, Action`1<string> onInfo, CancellationToken taskKillToken);
    public virtual DiskPerformanceResult get_Result();
    protected IDisposable TestTimeMeasure();
    protected void PrepareTestFile(string path);
    private static void AssertDiskSpace(string path, long fileSize);
    protected long LongRandom(long min, long max, int mutlipleOf, Random rand);
    protected static void ValidateHandle(SafeFileHandle handle);
    public virtual void Dispose();
    protected void DisposeTimer();
}
public abstract class Raven.Database.DiskIO.AbstractPerformanceTestRequest : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileSize>k__BackingField;
    public string TestType { get; }
    public string Path { get; public set; }
    public long FileSize { get; public set; }
    public abstract virtual string get_TestType();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public long get_FileSize();
    [CompilerGeneratedAttribute]
public void set_FileSize(long value);
}
public class Raven.Database.DiskIO.BatchDiskPerformanceTester : AbstractDiskPerformanceTester`1<BatchPerformanceTestRequest> {
    private string journalPath;
    private SafeFileHandle dataHandle;
    private SafeFileHandle journalHandle;
    private FileStream dataFs;
    private FileStream journalFs;
    public BatchDiskPerformanceTester(BatchPerformanceTestRequest testRequest, Action`1<string> onInfo, CancellationToken token);
    public virtual void TestDiskIO();
    private int RoundToMultipleOf(int number, int multiple);
    private void MeasurePerformance();
    private void FsyncIfNeeded(int dataFileWriteCounter);
    protected void SecondTicked(object state);
    public virtual void DescribeTestParameters();
}
public class Raven.Database.DiskIO.BatchPerformanceTestRequest : AbstractPerformanceTestRequest {
    public static string Mode;
    [CompilerGeneratedAttribute]
private int <NumberOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeOfDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfDocumentsInBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WaitBetweenBatches>k__BackingField;
    public string TestType { get; }
    public int NumberOfDocuments { get; public set; }
    public int SizeOfDocuments { get; public set; }
    public int NumberOfDocumentsInBatch { get; public set; }
    public int WaitBetweenBatches { get; public set; }
    public virtual string get_TestType();
    [CompilerGeneratedAttribute]
public int get_NumberOfDocuments();
    [CompilerGeneratedAttribute]
public void set_NumberOfDocuments(int value);
    [CompilerGeneratedAttribute]
public int get_SizeOfDocuments();
    [CompilerGeneratedAttribute]
public void set_SizeOfDocuments(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfDocumentsInBatch();
    [CompilerGeneratedAttribute]
public void set_NumberOfDocumentsInBatch(int value);
    [CompilerGeneratedAttribute]
public int get_WaitBetweenBatches();
    [CompilerGeneratedAttribute]
public void set_WaitBetweenBatches(int value);
}
public enum Raven.Database.DiskIO.BufferingType : Enum {
    public int value__;
    public static BufferingType None;
    public static BufferingType ReadAndWrite;
    public static BufferingType Read;
}
public class Raven.Database.DiskIO.DiskPerformanceResult : object {
    [CompilerGeneratedAttribute]
private List`1<long> <ReadPerSecondHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<long> <WritePerSecondHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<double> <AverageReadLatencyPerSecondHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<double> <AverageWriteLatencyPerSecondHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramData <ReadLatency>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramData <WriteLatency>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalRead>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalTimeMs>k__BackingField;
    public List`1<long> ReadPerSecondHistory { get; private set; }
    public List`1<long> WritePerSecondHistory { get; private set; }
    public List`1<double> AverageReadLatencyPerSecondHistory { get; private set; }
    public List`1<double> AverageWriteLatencyPerSecondHistory { get; private set; }
    public HistogramData ReadLatency { get; private set; }
    public HistogramData WriteLatency { get; private set; }
    public long TotalRead { get; private set; }
    public long TotalWrite { get; private set; }
    public long TotalTimeMs { get; private set; }
    public DiskPerformanceResult(DiskPerformanceStorage storage, long totalTimeMs);
    [CompilerGeneratedAttribute]
public List`1<long> get_ReadPerSecondHistory();
    [CompilerGeneratedAttribute]
private void set_ReadPerSecondHistory(List`1<long> value);
    [CompilerGeneratedAttribute]
public List`1<long> get_WritePerSecondHistory();
    [CompilerGeneratedAttribute]
private void set_WritePerSecondHistory(List`1<long> value);
    [CompilerGeneratedAttribute]
public List`1<double> get_AverageReadLatencyPerSecondHistory();
    [CompilerGeneratedAttribute]
private void set_AverageReadLatencyPerSecondHistory(List`1<double> value);
    [CompilerGeneratedAttribute]
public List`1<double> get_AverageWriteLatencyPerSecondHistory();
    [CompilerGeneratedAttribute]
private void set_AverageWriteLatencyPerSecondHistory(List`1<double> value);
    [CompilerGeneratedAttribute]
public HistogramData get_ReadLatency();
    [CompilerGeneratedAttribute]
private void set_ReadLatency(HistogramData value);
    [CompilerGeneratedAttribute]
public HistogramData get_WriteLatency();
    [CompilerGeneratedAttribute]
private void set_WriteLatency(HistogramData value);
    [CompilerGeneratedAttribute]
public long get_TotalRead();
    [CompilerGeneratedAttribute]
private void set_TotalRead(long value);
    [CompilerGeneratedAttribute]
public long get_TotalWrite();
    [CompilerGeneratedAttribute]
private void set_TotalWrite(long value);
    [CompilerGeneratedAttribute]
public long get_TotalTimeMs();
    [CompilerGeneratedAttribute]
private void set_TotalTimeMs(long value);
}
public class Raven.Database.DiskIO.DiskPerformanceStorage : object {
    [CompilerGeneratedAttribute]
private List`1<long> <ReadPerSecondHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<long> <WritePerSecondHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<double> <AverageReadLatencyPerSecondHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<double> <AverageWriteLatencyPerSecondHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramMetric <WriteLatencyHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramMetric <ReadLatencyHistogram>k__BackingField;
    private long totalReadLatencyInCurrentSecond;
    private long readEventsInCurrentSecond;
    private long totalWriteLatencyInCurrentSecond;
    private long writeEventsInCurrentSecond;
    private long totalRead;
    private long totalWrite;
    private long lastTotalWrite;
    private long lastTotalRead;
    public List`1<long> ReadPerSecondHistory { get; private set; }
    public List`1<long> WritePerSecondHistory { get; private set; }
    public List`1<double> AverageReadLatencyPerSecondHistory { get; private set; }
    public List`1<double> AverageWriteLatencyPerSecondHistory { get; private set; }
    public HistogramMetric WriteLatencyHistogram { get; private set; }
    public HistogramMetric ReadLatencyHistogram { get; private set; }
    public long TotalRead { get; }
    public long TotalWrite { get; }
    [CompilerGeneratedAttribute]
public List`1<long> get_ReadPerSecondHistory();
    [CompilerGeneratedAttribute]
private void set_ReadPerSecondHistory(List`1<long> value);
    [CompilerGeneratedAttribute]
public List`1<long> get_WritePerSecondHistory();
    [CompilerGeneratedAttribute]
private void set_WritePerSecondHistory(List`1<long> value);
    [CompilerGeneratedAttribute]
public List`1<double> get_AverageReadLatencyPerSecondHistory();
    [CompilerGeneratedAttribute]
private void set_AverageReadLatencyPerSecondHistory(List`1<double> value);
    [CompilerGeneratedAttribute]
public List`1<double> get_AverageWriteLatencyPerSecondHistory();
    [CompilerGeneratedAttribute]
private void set_AverageWriteLatencyPerSecondHistory(List`1<double> value);
    [CompilerGeneratedAttribute]
public HistogramMetric get_WriteLatencyHistogram();
    [CompilerGeneratedAttribute]
private void set_WriteLatencyHistogram(HistogramMetric value);
    [CompilerGeneratedAttribute]
public HistogramMetric get_ReadLatencyHistogram();
    [CompilerGeneratedAttribute]
private void set_ReadLatencyHistogram(HistogramMetric value);
    public long get_TotalRead();
    public long get_TotalWrite();
    public void Update();
    public void MarkRead(long size, long latency);
    public void MarkWrite(long size, long latency);
}
public class Raven.Database.DiskIO.GenericDiskPerformanceTester : AbstractDiskPerformanceTester`1<GenericPerformanceTestRequest> {
    private List`1<Thread> threads;
    private List`1<Random> perThreadRandom;
    public GenericDiskPerformanceTester(GenericPerformanceTestRequest testRequest, Action`1<string> onInfo, CancellationToken taskKillToken);
    public virtual void TestDiskIO();
    private void StartWorkers();
    protected void SecondTicked(object state);
    private void MeasurePerformance(CancellationToken token, Random random, long start, long end);
    private void TestRandomReadWrite(CancellationToken token, Random random, long start, long end);
    private void TestRandomWrite(CancellationToken token, Random random, long start, long end);
    private void TestRandomRead(CancellationToken token, Random random);
    private void TestSequentialWrite(CancellationToken token, Random random, long start, long end);
    private void TestSequentialRead(CancellationToken token);
    public virtual void DescribeTestParameters();
}
public class Raven.Database.DiskIO.GenericPerformanceTestRequest : AbstractPerformanceTestRequest {
    public static string Mode;
    [CompilerGeneratedAttribute]
private OperationType <OperationType>k__BackingField;
    [CompilerGeneratedAttribute]
private BufferingType <BufferingType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeToRunInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Sequential>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RandomSeed>k__BackingField;
    private int chunkSize;
    public string TestType { get; }
    public OperationType OperationType { get; public set; }
    public BufferingType BufferingType { get; public set; }
    public int TimeToRunInSeconds { get; public set; }
    public bool Sequential { get; public set; }
    public int ThreadCount { get; public set; }
    public Nullable`1<int> RandomSeed { get; public set; }
    public int ChunkSize { get; public set; }
    public bool BufferedReads { get; }
    public bool BufferedWrites { get; }
    public virtual string get_TestType();
    [CompilerGeneratedAttribute]
public OperationType get_OperationType();
    [CompilerGeneratedAttribute]
public void set_OperationType(OperationType value);
    [CompilerGeneratedAttribute]
public BufferingType get_BufferingType();
    [CompilerGeneratedAttribute]
public void set_BufferingType(BufferingType value);
    [CompilerGeneratedAttribute]
public int get_TimeToRunInSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeToRunInSeconds(int value);
    [CompilerGeneratedAttribute]
public bool get_Sequential();
    [CompilerGeneratedAttribute]
public void set_Sequential(bool value);
    [CompilerGeneratedAttribute]
public int get_ThreadCount();
    [CompilerGeneratedAttribute]
public void set_ThreadCount(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RandomSeed();
    [CompilerGeneratedAttribute]
public void set_RandomSeed(Nullable`1<int> value);
    public int get_ChunkSize();
    public void set_ChunkSize(int value);
    public bool get_BufferedReads();
    public bool get_BufferedWrites();
}
public enum Raven.Database.DiskIO.OperationType : Enum {
    public int value__;
    public static OperationType Read;
    public static OperationType Write;
    public static OperationType Mix;
}
[ExtensionAttribute]
public static class Raven.Database.DocumentConflictResolver : object {
    private static ILog Log;
    private static DocumentConflictResolver();
    [ExtensionAttribute]
public static void ResolveConflict(DocumentDatabase database, JsonDocument document, IStorageActionsAccessor actions, JsonDocument& newDocument);
    [ExtensionAttribute]
public static ReplicationConfig GetReplicationConfig(DocumentDatabase database);
    [ExtensionAttribute]
public static IEnumerable`1<AbstractDocumentReplicationConflictResolver> DocsConflictResolvers(DocumentDatabase database);
    [ExtensionAttribute]
public static void GetConflictDocuments(DocumentDatabase database, IEnumerable`1<JsonDocument> conflicts, KeyValuePair`2& local, KeyValuePair`2& remote);
}
public class Raven.Database.DocumentDatabase : object {
    private static ILog Log;
    private static int buildVersion;
    private static string productVersion;
    private TaskScheduler backgroundTaskScheduler;
    private ThreadLocal`1<DisableTriggerState> disableAllTriggers;
    private object idleLocker;
    private InFlightTransactionalState inFlightTransactionalState;
    private IndexingExecuter indexingExecuter;
    private LastCollectionEtags lastCollectionEtags;
    private LastMapCompletedDatesPerCollection lastMapCompletedDatesPerCollection;
    private Prefetcher prefetcher;
    private SequentialUuidGenerator uuidGenerator;
    private List`1<IDisposable> toDispose;
    private TransportState transportState;
    private WorkContext workContext;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) indexingWorkersStoppedManually;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed;
    private DocumentDatabaseInitializer initializer;
    public FixedSizeConcurrentQueue`1<AutoTunerDecisionDescription> AutoTuningTrace;
    [CompilerGeneratedAttribute]
private RavenThreadPool <ThreadPool>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler Disposing;
    [CompilerGeneratedAttribute]
private EventHandler DisposingEnded;
    [CompilerGeneratedAttribute]
private EventHandler StorageInaccessible;
    [CompilerGeneratedAttribute]
private Action OnIndexingWiringComplete;
    [CompilerGeneratedAttribute]
private Action`1<DocumentDatabase> OnBackupComplete;
    public Action`1<DiskSpaceNotification> OnDiskSpaceChanged;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractAttachmentDeleteTrigger> <AttachmentDeleteTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractAttachmentPutTrigger> <AttachmentPutTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractAttachmentReadTrigger> <AttachmentReadTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private PutSerialLock <DocumentLock>k__BackingField;
    [CompilerGeneratedAttribute]
private PutSerialLock <IdentityLock>k__BackingField;
    [CompilerGeneratedAttribute]
private AttachmentActions <Attachments>k__BackingField;
    [CompilerGeneratedAttribute]
private InMemoryRavenConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationRetriever <ConfigurationRetriever>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractDeleteTrigger> <DeleteTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractDocumentCodec> <DocumentCodecs>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentActions <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractDynamicCompilationExtension> <Extensions>k__BackingField;
    [CompilerGeneratedAttribute]
private AtomicDictionary`1<object> <ExtensionsState>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractIndexCodec> <IndexCodecs>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexDefinitionStorage <IndexDefinitionStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractIndexQueryTrigger> <IndexQueryTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractIndexReaderWarmer> <IndexReaderWarmers>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexStorage <IndexStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractIndexUpdateTrigger> <IndexUpdateTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexActions <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private MaintenanceActions <Maintenance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private NotificationActions <Notifications>k__BackingField;
    [CompilerGeneratedAttribute]
private SubscriptionActions <Subscriptions>k__BackingField;
    [CompilerGeneratedAttribute]
private PatchActions <Patches>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractPutTrigger> <PutTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryActions <Queries>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractReadTrigger> <ReadTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private ReducingExecuter <ReducingExecuter>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceTimerManager <TimerManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexReplacer <IndexReplacer>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<IStartupTask> <StartupTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskActions <Tasks>k__BackingField;
    [CompilerGeneratedAttribute]
private ITransactionalStorage <TransactionalStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private TransformerActions <Transformers>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestManager <RequestManager>k__BackingField;
    [CompilerGeneratedAttribute]
private Reference`1<ClusterManager> <ClusterManager>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <MappingTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <ReducingTask>k__BackingField;
    public RavenThreadPool ThreadPool { get; public set; }
    public static int BuildVersion { get; }
    public static string ProductVersion { get; }
    public long ApproximateTaskCount { get; }
    [ImportManyAttribute]
[ObsoleteAttribute("Use RavenFS instead.")]
public OrderedPartCollection`1<AbstractAttachmentDeleteTrigger> AttachmentDeleteTriggers { get; public set; }
    [ImportManyAttribute]
[ObsoleteAttribute("Use RavenFS instead.")]
public OrderedPartCollection`1<AbstractAttachmentPutTrigger> AttachmentPutTriggers { get; public set; }
    [ImportManyAttribute]
[ObsoleteAttribute("Use RavenFS instead.")]
public OrderedPartCollection`1<AbstractAttachmentReadTrigger> AttachmentReadTriggers { get; public set; }
    internal PutSerialLock DocumentLock { get; private set; }
    internal PutSerialLock IdentityLock { get; private set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public AttachmentActions Attachments { get; private set; }
    public TaskScheduler BackgroundTaskScheduler { get; }
    public InMemoryRavenConfiguration Configuration { get; private set; }
    public ConfigurationRetriever ConfigurationRetriever { get; private set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractDeleteTrigger> DeleteTriggers { get; public set; }
    public bool Disposed { get; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractDocumentCodec> DocumentCodecs { get; public set; }
    public DocumentActions Documents { get; private set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractDynamicCompilationExtension> Extensions { get; public set; }
    public AtomicDictionary`1<object> ExtensionsState { get; private set; }
    public bool HasTasks { get; }
    [CLSCompliantAttribute("False")]
public InFlightTransactionalState InFlightTransactionalState { get; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractIndexCodec> IndexCodecs { get; public set; }
    public IndexDefinitionStorage IndexDefinitionStorage { get; private set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractIndexQueryTrigger> IndexQueryTriggers { get; public set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractIndexReaderWarmer> IndexReaderWarmers { get; public set; }
    public IndexStorage IndexStorage { get; public set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractIndexUpdateTrigger> IndexUpdateTriggers { get; public set; }
    public IndexActions Indexes { get; private set; }
    [CLSCompliantAttribute("False")]
public IndexingExecuter IndexingExecuter { get; }
    public LastCollectionEtags LastCollectionEtags { get; }
    public LastMapCompletedDatesPerCollection LastMapCompletedDatesPerCollection { get; }
    public MaintenanceActions Maintenance { get; private set; }
    public string Name { get; private set; }
    public string ResourceName { get; private set; }
    public NotificationActions Notifications { get; private set; }
    public SubscriptionActions Subscriptions { get; private set; }
    public PatchActions Patches { get; private set; }
    public Prefetcher Prefetcher { get; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractPutTrigger> PutTriggers { get; public set; }
    public QueryActions Queries { get; private set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractReadTrigger> ReadTriggers { get; public set; }
    [CLSCompliantAttribute("False")]
public ReducingExecuter ReducingExecuter { get; private set; }
    public ResourceTimerManager TimerManager { get; private set; }
    public IndexReplacer IndexReplacer { get; private set; }
    public string ServerUrl { get; }
    [ImportManyAttribute]
public OrderedPartCollection`1<IStartupTask> StartupTasks { get; public set; }
    public PluginsInfo PluginsInfo { get; }
    public IndexingPerformanceStatistics[] IndexingPerformanceStatistics { get; }
    public DatabaseStatistics Statistics { get; }
    public ReducedDatabaseStatistics ReducedStatistics { get; }
    public IndexStats[] IndexesStatistics { get; }
    public TaskActions Tasks { get; private set; }
    [CLSCompliantAttribute("False")]
public ITransactionalStorage TransactionalStorage { get; private set; }
    [CLSCompliantAttribute("False")]
public TransformerActions Transformers { get; private set; }
    public TransportState TransportState { get; }
    public WorkContext WorkContext { get; }
    public RequestManager RequestManager { get; public set; }
    public Reference`1<ClusterManager> ClusterManager { get; public set; }
    public Task MappingTask { get; private set; }
    public Task ReducingTask { get; private set; }
    public DocumentDatabase(InMemoryRavenConfiguration configuration, DocumentDatabase systemDatabase, TransportState recievedTransportState, Action`2<object, Exception> onError);
    private static DocumentDatabase();
    [CompilerGeneratedAttribute]
public RavenThreadPool get_ThreadPool();
    [CompilerGeneratedAttribute]
public void set_ThreadPool(RavenThreadPool value);
    private void EnsureAllIndexDefinitionsHaveIndexes();
    [CompilerGeneratedAttribute]
public void add_Disposing(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposing(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_DisposingEnded(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DisposingEnded(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_StorageInaccessible(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StorageInaccessible(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_OnIndexingWiringComplete(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnIndexingWiringComplete(Action value);
    [CompilerGeneratedAttribute]
public void add_OnBackupComplete(Action`1<DocumentDatabase> value);
    [CompilerGeneratedAttribute]
public void remove_OnBackupComplete(Action`1<DocumentDatabase> value);
    public static int get_BuildVersion();
    public static string get_ProductVersion();
    public long get_ApproximateTaskCount();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractAttachmentDeleteTrigger> get_AttachmentDeleteTriggers();
    [CompilerGeneratedAttribute]
public void set_AttachmentDeleteTriggers(OrderedPartCollection`1<AbstractAttachmentDeleteTrigger> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractAttachmentPutTrigger> get_AttachmentPutTriggers();
    [CompilerGeneratedAttribute]
public void set_AttachmentPutTriggers(OrderedPartCollection`1<AbstractAttachmentPutTrigger> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractAttachmentReadTrigger> get_AttachmentReadTriggers();
    [CompilerGeneratedAttribute]
public void set_AttachmentReadTriggers(OrderedPartCollection`1<AbstractAttachmentReadTrigger> value);
    [CompilerGeneratedAttribute]
internal PutSerialLock get_DocumentLock();
    [CompilerGeneratedAttribute]
private void set_DocumentLock(PutSerialLock value);
    [CompilerGeneratedAttribute]
internal PutSerialLock get_IdentityLock();
    [CompilerGeneratedAttribute]
private void set_IdentityLock(PutSerialLock value);
    [CompilerGeneratedAttribute]
public AttachmentActions get_Attachments();
    [CompilerGeneratedAttribute]
private void set_Attachments(AttachmentActions value);
    public TaskScheduler get_BackgroundTaskScheduler();
    [CompilerGeneratedAttribute]
public sealed virtual InMemoryRavenConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(InMemoryRavenConfiguration value);
    [CompilerGeneratedAttribute]
public ConfigurationRetriever get_ConfigurationRetriever();
    [CompilerGeneratedAttribute]
private void set_ConfigurationRetriever(ConfigurationRetriever value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractDeleteTrigger> get_DeleteTriggers();
    [CompilerGeneratedAttribute]
public void set_DeleteTriggers(OrderedPartCollection`1<AbstractDeleteTrigger> value);
    public bool get_Disposed();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractDocumentCodec> get_DocumentCodecs();
    [CompilerGeneratedAttribute]
public void set_DocumentCodecs(OrderedPartCollection`1<AbstractDocumentCodec> value);
    [CompilerGeneratedAttribute]
public DocumentActions get_Documents();
    [CompilerGeneratedAttribute]
private void set_Documents(DocumentActions value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractDynamicCompilationExtension> get_Extensions();
    [CompilerGeneratedAttribute]
public void set_Extensions(OrderedPartCollection`1<AbstractDynamicCompilationExtension> value);
    [CompilerGeneratedAttribute]
public sealed virtual AtomicDictionary`1<object> get_ExtensionsState();
    [CompilerGeneratedAttribute]
private void set_ExtensionsState(AtomicDictionary`1<object> value);
    public bool get_HasTasks();
    public InFlightTransactionalState get_InFlightTransactionalState();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractIndexCodec> get_IndexCodecs();
    [CompilerGeneratedAttribute]
public void set_IndexCodecs(OrderedPartCollection`1<AbstractIndexCodec> value);
    [CompilerGeneratedAttribute]
public IndexDefinitionStorage get_IndexDefinitionStorage();
    [CompilerGeneratedAttribute]
private void set_IndexDefinitionStorage(IndexDefinitionStorage value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractIndexQueryTrigger> get_IndexQueryTriggers();
    [CompilerGeneratedAttribute]
public void set_IndexQueryTriggers(OrderedPartCollection`1<AbstractIndexQueryTrigger> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractIndexReaderWarmer> get_IndexReaderWarmers();
    [CompilerGeneratedAttribute]
public void set_IndexReaderWarmers(OrderedPartCollection`1<AbstractIndexReaderWarmer> value);
    [CompilerGeneratedAttribute]
public IndexStorage get_IndexStorage();
    [CompilerGeneratedAttribute]
public void set_IndexStorage(IndexStorage value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractIndexUpdateTrigger> get_IndexUpdateTriggers();
    [CompilerGeneratedAttribute]
public void set_IndexUpdateTriggers(OrderedPartCollection`1<AbstractIndexUpdateTrigger> value);
    [CompilerGeneratedAttribute]
public IndexActions get_Indexes();
    [CompilerGeneratedAttribute]
private void set_Indexes(IndexActions value);
    public IndexingExecuter get_IndexingExecuter();
    public LastCollectionEtags get_LastCollectionEtags();
    public LastMapCompletedDatesPerCollection get_LastMapCompletedDatesPerCollection();
    [CompilerGeneratedAttribute]
public MaintenanceActions get_Maintenance();
    [CompilerGeneratedAttribute]
private void set_Maintenance(MaintenanceActions value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResourceName();
    [CompilerGeneratedAttribute]
private void set_ResourceName(string value);
    [CompilerGeneratedAttribute]
public NotificationActions get_Notifications();
    [CompilerGeneratedAttribute]
private void set_Notifications(NotificationActions value);
    [CompilerGeneratedAttribute]
public SubscriptionActions get_Subscriptions();
    [CompilerGeneratedAttribute]
private void set_Subscriptions(SubscriptionActions value);
    [CompilerGeneratedAttribute]
public PatchActions get_Patches();
    [CompilerGeneratedAttribute]
private void set_Patches(PatchActions value);
    public Prefetcher get_Prefetcher();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractPutTrigger> get_PutTriggers();
    [CompilerGeneratedAttribute]
public void set_PutTriggers(OrderedPartCollection`1<AbstractPutTrigger> value);
    [CompilerGeneratedAttribute]
public QueryActions get_Queries();
    [CompilerGeneratedAttribute]
private void set_Queries(QueryActions value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractReadTrigger> get_ReadTriggers();
    [CompilerGeneratedAttribute]
public void set_ReadTriggers(OrderedPartCollection`1<AbstractReadTrigger> value);
    [CompilerGeneratedAttribute]
public ReducingExecuter get_ReducingExecuter();
    [CompilerGeneratedAttribute]
private void set_ReducingExecuter(ReducingExecuter value);
    [CompilerGeneratedAttribute]
public ResourceTimerManager get_TimerManager();
    [CompilerGeneratedAttribute]
private void set_TimerManager(ResourceTimerManager value);
    [CompilerGeneratedAttribute]
public IndexReplacer get_IndexReplacer();
    [CompilerGeneratedAttribute]
private void set_IndexReplacer(IndexReplacer value);
    public string get_ServerUrl();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<IStartupTask> get_StartupTasks();
    [CompilerGeneratedAttribute]
public void set_StartupTasks(OrderedPartCollection`1<IStartupTask> value);
    public PluginsInfo get_PluginsInfo();
    private List`1<string> FindPluginBundles(Type[] types);
    public IndexingPerformanceStatistics[] get_IndexingPerformanceStatistics();
    public DatabaseStatistics get_Statistics();
    public ReducedDatabaseStatistics get_ReducedStatistics();
    public IndexStats[] get_IndexesStatistics();
    private void GetMoreIndexesStats(IndexStats[] indexes);
    private IndexStats[] GetIndexesStats(IStorageActionsAccessor actions, Etag lastDocEtag);
    private int GetNumberOfAlerts();
    public Dictionary`2<string, RemainingReductionPerLevel> GetRemainingScheduledReductions();
    [CompilerGeneratedAttribute]
public TaskActions get_Tasks();
    [CompilerGeneratedAttribute]
private void set_Tasks(TaskActions value);
    [CompilerGeneratedAttribute]
public ITransactionalStorage get_TransactionalStorage();
    [CompilerGeneratedAttribute]
private void set_TransactionalStorage(ITransactionalStorage value);
    [CompilerGeneratedAttribute]
public TransformerActions get_Transformers();
    [CompilerGeneratedAttribute]
private void set_Transformers(TransformerActions value);
    public sealed virtual TransportState get_TransportState();
    public WorkContext get_WorkContext();
    [CompilerGeneratedAttribute]
public RequestManager get_RequestManager();
    [CompilerGeneratedAttribute]
public void set_RequestManager(RequestManager value);
    [CompilerGeneratedAttribute]
public Reference`1<ClusterManager> get_ClusterManager();
    [CompilerGeneratedAttribute]
public void set_ClusterManager(Reference`1<ClusterManager> value);
    public BatchResult[] Batch(IList`1<ICommandData> commands, CancellationToken token);
    public void PrepareTransaction(string txId, Nullable`1<Guid> resourceManagerId, Byte[] recoveryInformation);
    public void Commit(string txId);
    public DatabaseMetrics CreateMetrics();
    public IDisposable DisableAllTriggersForCurrentThread(HashSet`1<Type> except);
    public sealed virtual void Dispose();
    public long GetIndexStorageSizeOnDisk();
    public long GetTotalSizeOnDisk();
    public DatabaseSizeInformation GetTransactionalStorageSizeOnDisk();
    public bool HasTransaction(string txId);
    public void Rollback(string txId);
    public void RunIdleOperations();
    public void SpinBackgroundWorkers(bool manualStart);
    public void StopBackgroundWorkers();
    public void StopIndexingWorkers(bool manualStop);
    public void ForceLicenseUpdate();
    protected void RaiseIndexingWiringComplete();
    private BatchResult[] BatchWithRetriesOnConcurrencyErrorsAndNoTransactionMerging(IList`1<ICommandData> commands, CancellationToken token);
    private void CompleteWorkContextSetup();
    private static decimal ConvertBytesToMBs(long bytes);
    private void ExecuteStartupTasks();
    internal void LogErrorAndAddAlertOnStartupTaskException(string taskTypeName, Exception e);
    private void InitializeIndexCodecTriggers();
    private void InitializeTriggersExceptIndexCodecs();
    private static bool IsScriptedPatchCommandDataWithoutEtagProperty(ICommandData commandData);
    private BatchResult[] ProcessBatch(IList`1<ICommandData> commands, CancellationToken token);
    private void SecondStageInitialization();
    public void RaiseBackupComplete();
    [CompilerGeneratedAttribute]
public Task get_MappingTask();
    [CompilerGeneratedAttribute]
private void set_MappingTask(Task value);
    [CompilerGeneratedAttribute]
public Task get_ReducingTask();
    [CompilerGeneratedAttribute]
private void set_ReducingTask(Task value);
    private void SpinMappingWorker();
    private void RunMapIndexes();
    public void SpinReduceWorker();
    private void RunReduceIndexes();
    public void StopReduceWorkers();
    public bool IsIndexingDisabled();
    [CompilerGeneratedAttribute]
private void <.ctor>b__24_0(IStorageActionsAccessor actions);
    [CompilerGeneratedAttribute]
private PutResult <.ctor>b__24_1(string key, Etag etag, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__24_2(string key, Etag etag, TransactionInformation transactionInformation);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType91`2<KeyValuePair`2<int, IndexDefinition>, IndexingPerformanceStats[]> <get_IndexingPerformanceStatistics>b__202_0(KeyValuePair`2<int, IndexDefinition> pair);
    [CompilerGeneratedAttribute]
private void <InitializeIndexCodecTriggers>b__260_0(IRequiresDocumentDatabaseInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__261_0(IRequiresDocumentDatabaseInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__261_1(IRequiresDocumentDatabaseInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__261_2(IRequiresDocumentDatabaseInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__261_3(IRequiresDocumentDatabaseInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__261_4(IRequiresDocumentDatabaseInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__261_5(IRequiresDocumentDatabaseInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__261_6(IRequiresDocumentDatabaseInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__261_7(IRequiresDocumentDatabaseInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__261_8(IRequiresDocumentDatabaseInitialization initialization);
}
public class Raven.Database.Embedded.OwinClientHandler : HttpMessageHandler {
    private Func`2<IDictionary`2<string, object>, Task> _next;
    private bool _enableLogging;
    private int _responseStreamMaxCachedBlocks;
    public OwinClientHandler(Func`2<IDictionary`2<string, object>, Task> next, bool enableLogging, int responseStreamMaxCachedBlocks);
    [AsyncStateMachineAttribute("Raven.Database.Embedded.OwinClientHandler/<SendAsync>d__4")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class Raven.Database.Embedded.OwinEmbeddedHost : object {
    private Func`2<IDictionary`2<string, object>, Task> _next;
    private IDisposable _started;
    private bool _disposed;
    public sealed virtual void Dispose();
    public static OwinEmbeddedHost Create(Action`1<IAppBuilder> startup);
    private void Configure(Action`1<IAppBuilder> startup, StartOptions options);
    [AsyncStateMachineAttribute("Raven.Database.Embedded.OwinEmbeddedHost/<Invoke>d__7")]
public Task Invoke(IDictionary`2<string, object> environment);
}
internal class Raven.Database.Embedded.ResponseStream : Stream {
    private ILog log;
    private SemaphoreSlim tryTakeDataLock;
    private CancellationTokenSource abort;
    private BlockingCollection`1<Byte[]> blocks;
    private Guid id;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed;
    private Action onFirstWrite;
    private bool firstWrite;
    private bool enableLogging;
    private Byte[] currentBlock;
    private int currentBlockIndex;
    private Exception abortException;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ResponseStream(Action onFirstWrite, bool enableLogging, int responseStreamMaxCachedBlocks);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Raven.Database.Embedded.ResponseStream/<ReadAsync>d__29")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private void FirstWrite();
    private static void VerifyBuffer(Byte[] buffer, int offset, int count, bool allowEmpty);
    protected virtual void Dispose(bool disposing);
    internal void Abort(Exception exception);
}
public class Raven.Database.Extensions.CancellationTimeout : object {
    [CompilerGeneratedAttribute]
private CancellationTokenSource <CancellationTokenSource>k__BackingField;
    private Timer timer;
    private long dueTime;
    private object locker;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isTimerDisposed;
    private Stopwatch sp;
    public CancellationTokenSource CancellationTokenSource { get; private set; }
    public CancellationTimeout(CancellationTokenSource cancellationTokenSource, TimeSpan dueTime);
    [CompilerGeneratedAttribute]
public CancellationTokenSource get_CancellationTokenSource();
    [CompilerGeneratedAttribute]
private void set_CancellationTokenSource(CancellationTokenSource value);
    public void ThrowIfCancellationRequested();
    protected virtual override void Finalize();
    public void Delay();
    public void Pause();
    public void Resume();
    public sealed virtual void Dispose();
    private void DisposeInternal();
}
[ExtensionAttribute]
public static class Raven.Database.Extensions.CancellationTokenSourceExtensions : object {
    [ExtensionAttribute]
public static CancellationTimeout TimeoutAfter(CancellationTokenSource cts, TimeSpan dueTime);
}
[ExtensionAttribute]
public static class Raven.Database.Extensions.CommandExtensions : object {
    [ExtensionAttribute]
public static void Execute(ICommandData self, DocumentDatabase database);
    [ExtensionAttribute]
public static BatchResult ExecuteBatch(ICommandData self, DocumentDatabase database, IEnumerable`1<string> participatingIds);
    private static void Execute(ICommandData self, DocumentDatabase database, BatchResult batchResult, IEnumerable`1<string> participatingIds);
}
[ExtensionAttribute]
public static class Raven.Database.Extensions.DocDbExtensions : object {
    private static ILog Logger;
    private static int MaxTries;
    private static DocDbExtensions();
    [ExtensionAttribute]
public static void AddAlert(DocumentDatabase self, Alert alert);
}
[ExtensionAttribute]
public static class Raven.Database.Extensions.EnumerableExtensions : object {
    [ExtensionAttribute]
public static void Apply(IEnumerable`1<T> self, Action`1<T> action);
    [ExtensionAttribute]
public static IEnumerable`1<T> EmptyIfNull(IEnumerable`1<T> self);
    [ExtensionAttribute]
public static void ApplyAndIgnoreAllErrors(IEnumerable`1<T> self, Action`1<Exception> errorAction, Action`1<T> action);
}
public class Raven.Database.Extensions.FeatureNotSupportedOnPosixException : Exception {
    public FeatureNotSupportedOnPosixException(string message);
    public FeatureNotSupportedOnPosixException(string message, Exception inner);
    protected FeatureNotSupportedOnPosixException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class Raven.Database.Extensions.GuidExtensions : object {
    [ExtensionAttribute]
public static Guid TransformToGuidWithProperSorting(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] TransformToValueForEsentSorting(Guid guid);
}
[ExtensionAttribute]
public static class Raven.Database.Extensions.HttpExtensions : object {
    public static RavenJToken MinimizeToken(RavenJToken obj, int depth);
    [ExtensionAttribute]
public static HttpResponseMessage WithNoCache(HttpResponseMessage message);
}
[ExtensionAttribute]
public static class Raven.Database.Extensions.IndexingExtensions : object {
    private static string _Range;
    private static string _SortHint;
    private static CompareInfo InvariantCompare;
    private static IndexingExtensions();
    public static Analyzer CreateAnalyzerInstance(string name, string analyzerTypeAsString);
    public static Type GetAnalyzerType(string name, string analyzerTypeAsString);
    [ExtensionAttribute]
public static Index GetIndex(IndexDefinition self, string name, Nullable`1<Index> defaultIndex);
    [ExtensionAttribute]
public static Index GetIndex(IndexDefinition self, string name, Nullable`1<Index> defaultIndex, Nullable`1& fieldIndexing);
    [ExtensionAttribute]
public static Store GetStorage(IndexDefinition self, string name, Store defaultStorage);
    [ExtensionAttribute]
public static TermVector GetTermVector(IndexDefinition self, string name, TermVector defaultTermVector);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Sort GetSort(IndexQuery self, IndexDefinition indexDefinition, AbstractViewGenerator viewGenerator);
    [ExtensionAttribute]
public static Nullable`1<SortOptions> GetSortOption(IndexDefinition self, string name, IndexQuery query);
}
[ExtensionAttribute]
public static class Raven.Database.Extensions.IOExtensions : object {
    private static int retries;
    public static void CreateDirectoryIfNotExists(string dirPath);
    public static void DeleteFile(string file);
    public static void DeleteDirectory(string directory);
    private static void TryHandlingError(string directory, int i, Exception e);
    [ExtensionAttribute]
public static string ToFullPath(string path, string basePath);
    public static void CopyDirectory(string from, string to);
    private static void CopyDirectory(DirectoryInfo source, DirectoryInfo target);
    private static void CopyDirectory(DirectoryInfo source, DirectoryInfo target, String[] skip);
    public static string GetMD5Hex(Byte[] input);
    [ExtensionAttribute]
public static string GetMD5Hash(Stream stream);
}
[ExtensionAttribute]
internal static class Raven.Database.Extensions.MetricExtensions : object {
    [ExtensionAttribute]
public static HistogramData CreateHistogramData(HistogramMetric self);
    [ExtensionAttribute]
public static MeterData CreateMeterData(MeterMetric self);
    [ExtensionAttribute]
public static Dictionary`2<string, HistogramData> ToHistogramDataDictionary(ConcurrentDictionary`2<string, HistogramMetric> self);
    [ExtensionAttribute]
public static Dictionary`2<string, MeterData> ToMeterDataDictionary(ConcurrentDictionary`2<string, MeterMetric> self);
}
public class Raven.Database.Extensions.MonoHttpEncoder : object {
    private static Char[] hexChars;
    private static object entitiesLock;
    private static SortedDictionary`2<string, char> entities;
    private static Lazy`1<MonoHttpEncoder> defaultEncoder;
    private static Lazy`1<MonoHttpEncoder> currentEncoderLazy;
    private static MonoHttpEncoder currentEncoder;
    private static IDictionary`2<string, char> Entities { get; }
    public static MonoHttpEncoder Current { get; public set; }
    public static MonoHttpEncoder Default { get; }
    private static MonoHttpEncoder();
    private static IDictionary`2<string, char> get_Entities();
    public static MonoHttpEncoder get_Current();
    public static void set_Current(MonoHttpEncoder value);
    public static MonoHttpEncoder get_Default();
    protected internal virtual void HeaderNameValueEncode(string headerName, string headerValue, String& encodedHeaderName, String& encodedHeaderValue);
    private static void StringBuilderAppend(string s, StringBuilder& sb);
    private static string EncodeHeaderString(string input);
    protected internal virtual void HtmlAttributeEncode(string value, TextWriter output);
    protected internal virtual void HtmlDecode(string value, TextWriter output);
    protected internal virtual void HtmlEncode(string value, TextWriter output);
    protected internal virtual Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    private static MonoHttpEncoder GetCustomEncoderFromConfig();
    protected internal virtual string UrlPathEncode(string value);
    internal static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    internal static string HtmlEncode(string s);
    internal static string HtmlAttributeEncode(string s);
    internal static string HtmlDecode(string s);
    internal static bool NotEncoded(char c);
    internal static void UrlEncodeChar(char c, Stream result, bool isUnicode);
    internal static void UrlPathEncodeChar(char c, Stream result);
    private static void InitEntities();
}
public class Raven.Database.Extensions.MonoHttpUtility : object {
    public static string UrlDecode(string str);
    private static Char[] GetChars(MemoryStream b, Encoding e);
    private static void WriteCharBytes(IList buf, char ch, Encoding e);
    public static string UrlDecode(string s, Encoding e);
    public static string UrlDecode(Byte[] bytes, Encoding e);
    private static int GetInt(byte b);
    private static int GetChar(Byte[] bytes, int offset, int length);
    private static int GetChar(string str, int offset, int length);
    public static string UrlDecode(Byte[] bytes, int offset, int count, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes);
    public static Byte[] UrlDecodeToBytes(string str);
    public static Byte[] UrlDecodeToBytes(string str, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlEncode(string str);
    public static string UrlEncode(string s, Encoding Enc);
    public static string UrlEncode(Byte[] bytes);
    public static string UrlEncode(Byte[] bytes, int offset, int count);
    public static Byte[] UrlEncodeToBytes(string str);
    public static Byte[] UrlEncodeToBytes(string str, Encoding e);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlEncodeUnicode(string str);
    public static Byte[] UrlEncodeUnicodeToBytes(string str);
}
[ExtensionAttribute]
public static class Raven.Database.Extensions.RoleFinder : object {
    private static CachingRoleFinder cachingRoleFinder;
    private static RoleFinder();
    [ExtensionAttribute]
public static bool IsInRole(IPrincipal principal, AnonymousUserAccessMode mode, WindowsBuiltInRole role);
    [ExtensionAttribute]
public static bool IsAdministrator(IPrincipal principal, AnonymousUserAccessMode mode);
    [ExtensionAttribute]
public static bool IsBackupOperator(IPrincipal principal, AnonymousUserAccessMode mode);
    [ExtensionAttribute]
public static bool IsAdministrator(IPrincipal principal, DocumentDatabase database);
    [ExtensionAttribute]
public static bool IsAdministrator(IPrincipal principal, string databaseName);
    [ExtensionAttribute]
public static bool IsReadOnly(IPrincipal principal, string databaseName);
}
[ExtensionAttribute]
public static class Raven.Database.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static List`1<string> GetSemicolonSeparatedValues(string self);
    [ExtensionAttribute]
public static string NormalizeLineEnding(string script);
}
public static class Raven.Database.Extensions.WhoIsLocking : object {
    private static int RmRebootReasonNone;
    private static int CCH_RM_MAX_APP_NAME;
    private static int CCH_RM_MAX_SVC_NAME;
    public static string ThisFile(string path);
    public static IList`1<Process> GetProcessesUsingFile(string filePath);
    private static int RmStartSession(UInt32& pSessionHandle, int dwSessionFlags, string strSessionKey);
    private static int RmEndSession(UInt32 pSessionHandle);
    private static int RmRegisterResources(UInt32 pSessionHandle, UInt32 nFiles, String[] rgsFilenames, UInt32 nApplications, RM_UNIQUE_PROCESS[] rgApplications, UInt32 nServices, String[] rgsServiceNames);
    private static int RmGetList(UInt32 dwSessionHandle, UInt32& pnProcInfoNeeded, UInt32& pnProcInfo, RM_PROCESS_INFO[] rgAffectedApps, UInt32& lpdwRebootReasons);
}
public abstract class Raven.Database.FileSystem.Actions.ActionsBase : object {
    [CompilerGeneratedAttribute]
private RavenFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private ILog <Log>k__BackingField;
    protected RavenFileSystem FileSystem { get; private set; }
    protected NotificationPublisher Publisher { get; }
    protected BufferPool BufferPool { get; }
    protected SigGenerator SigGenerator { get; }
    protected Historian Historian { get; }
    protected SynchronizationTask SynchronizationTask { get; }
    protected FileLockManager FileLockManager { get; }
    protected ITransactionalStorage Storage { get; }
    protected IndexStorage Search { get; }
    protected ILog Log { get; private set; }
    protected ActionsBase(RavenFileSystem fileSystem, ILog log);
    [CompilerGeneratedAttribute]
protected RavenFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(RavenFileSystem value);
    protected NotificationPublisher get_Publisher();
    protected BufferPool get_BufferPool();
    protected SigGenerator get_SigGenerator();
    protected Historian get_Historian();
    protected SynchronizationTask get_SynchronizationTask();
    protected FileLockManager get_FileLockManager();
    protected ITransactionalStorage get_Storage();
    protected IndexStorage get_Search();
    [CompilerGeneratedAttribute]
protected ILog get_Log();
    [CompilerGeneratedAttribute]
private void set_Log(ILog value);
}
public class Raven.Database.FileSystem.Actions.FileActions : ActionsBase {
    internal static int MaxNumberOfFilesToDeleteByCleanupTaskRun;
    private ConcurrentDictionary`2<string, Task> deleteFileTasks;
    private ConcurrentDictionary`2<string, Task> renameFileTasks;
    private ConcurrentDictionary`2<string, Task> copyFileTasks;
    private ConcurrentDictionary`2<string, FileHeader> uploadingFiles;
    private SemaphoreSlim maxNumberOfConcurrentDeletionsInBackground;
    public FileActions(RavenFileSystem fileSystem, ILog log);
    public void InitializeTimer();
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Actions.FileActions/<PutAsync>d__8")]
public Task PutAsync(string name, Etag etag, RavenJObject metadata, Func`1<Task`1<Stream>> streamAsync, PutOperationOptions options);
    internal void AssertPutOperationNotVetoed(string name, RavenJObject metadata);
    private void AssertMetadataUpdateOperationNotVetoed(string name, RavenJObject metadata);
    private void AssertRenameOperationNotVetoed(string name, string newName);
    private void AssertDeleteOperationNotVetoed(string name);
    public void UpdateMetadata(string name, RavenJObject metadata, Etag etag);
    public void ExecuteRenameOperation(RenameFileOperation operation);
    public void ExecuteCopyOperation(CopyFileOperation operation);
    public void IndicateFileToDelete(string fileName, Etag etag);
    public void PutTombstone(string fileName, RavenJObject metadata);
    public Task CleanupDeletedFilesAsync();
    public Task ResumeFileRenamingAsync();
    public Task ResumeFileCopyingAsync();
    private static string SynchronizedFileName(string originalFileName);
    private bool IsSynchronizationInProgress(string originalFileName);
    private bool IsUploadInProgress(string originalFileName);
    private bool IsDeleteInProgress(string deletingFileName);
    private bool IsRenameInProgress(string fileName);
    private bool IsCopyInProgress(string fileName);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <InitializeTimer>b__7_0(object state);
}
public class Raven.Database.FileSystem.Actions.ReadFileToDatabase : object {
    private Byte[] buffer;
    private BufferPool bufferPool;
    private string filename;
    private RavenJObject headers;
    private Stream inputStream;
    private ITransactionalStorage storage;
    private OrderedPartCollection`1<AbstractFilePutTrigger> putTriggers;
    private IHashEncryptor md5Hasher;
    public long TotalSizeRead;
    private int pos;
    [CompilerGeneratedAttribute]
private string <FileHash>k__BackingField;
    public string FileHash { get; private set; }
    public ReadFileToDatabase(BufferPool bufferPool, ITransactionalStorage storage, OrderedPartCollection`1<AbstractFilePutTrigger> putTriggers, Stream inputStream, string filename, RavenJObject headers);
    [CompilerGeneratedAttribute]
public string get_FileHash();
    [CompilerGeneratedAttribute]
private void set_FileHash(string value);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Actions.ReadFileToDatabase/<Execute>d__16")]
public Task Execute();
    [CompilerGeneratedAttribute]
private void <Execute>b__16_0(IStorageActionsAccessor accessor);
    [CompilerGeneratedAttribute]
private void <Execute>b__16_2(AbstractFilePutTrigger trigger);
}
public class Raven.Database.FileSystem.Actions.SynchronizationActions : ActionsBase {
    private ConcurrentDictionary`2<Guid, ReaderWriterLockSlim> synchronizationFinishLocks;
    public SynchronizationActions(RavenFileSystem fileSystem, ILog log);
    public void AssertFileIsNotBeingSynced(string fileName);
    public void FinishSynchronization(string fileName, SynchronizationReport report, FileSystemInfo sourceFileSystem, Etag sourceFileETag);
    private void SaveSynchronizationSourceInformation(FileSystemInfo sourceFileSystem, Etag lastSourceEtag, bool force);
    private void SaveSynchronizationReport(string fileName, IStorageActionsAccessor accessor, SynchronizationReport report);
    public SourceSynchronizationInformation GetLastSynchronization(Guid from);
    public void IncrementLastEtag(Guid sourceServerId, string sourceFileSystemUrl, string sourceFileETag, bool force);
    public void DeleteSynchronizationReport(string fileName, IStorageActionsAccessor accessor);
    public SynchronizationReport GetSynchronizationReport(string fileName);
    public RavenJObject GetLocalMetadata(string fileName);
}
public class Raven.Database.FileSystem.Actions.TaskActions : ActionsBase {
    private ConcurrentDictionary`2<long, PendingTaskWithStateAndDescription> pendingTasks;
    private long pendingTaskCounter;
    public TaskActions(RavenFileSystem fileSystem, ILog log);
    public void InitializeTimer();
    private void ClearCompletedPendingTasks();
    public List`1<PendingTaskDescriptionAndStatus> GetAll();
    public void AddTask(Task task, IOperationState state, PendingTaskDescription description, Int64& id, CancellationTokenSource tokenSource);
    public void AddTask(Task task, IOperationState state, PendingTaskDescription description, long id, CancellationTokenSource tokenSource, bool skipStatusCheck);
    public long GetNextTaskId();
    public void RemoveTask(long taskId);
    public IOperationState KillTask(long id);
    public IOperationState GetTaskState(long id);
    public void Dispose(ExceptionAggregator exceptionAggregator);
    [CompilerGeneratedAttribute]
private void <InitializeTimer>b__3_0(object state);
}
[ExportMetadataAttribute("Order", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.FileSystem.Plugins.AbstractFileCodec")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.FileSystem.Bundles.Encryption.Plugin.FileEncryption : AbstractFileCodec {
    private static string PageEncryptionMarker;
    private EncryptionSettings settings;
    public virtual void Initialize();
    public virtual void SecondStageInit();
    public virtual Stream EncodePage(Stream data);
    public virtual Stream DecodePage(Stream encodedDataStream);
    public void SetSettings(EncryptionSettings newSettings);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.FileSystem.Plugins.AbstractFileReadTrigger")]
public class Raven.Database.FileSystem.Bundles.Versioning.Plugins.HideVersionedFilesFromIndexingTrigger : AbstractFileReadTrigger {
    public virtual ReadVetoResult AllowRead(string name, RavenJObject metadata, ReadOperation operation);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.FileSystem.Plugins.AbstractFileDeleteTrigger")]
public class Raven.Database.FileSystem.Bundles.Versioning.Plugins.VersioningDeleteTrigger : AbstractFileDeleteTrigger {
    private VersioningTriggerActions actions;
    public virtual void Initialize();
    public virtual VetoResult AllowDelete(string name);
    public virtual void AfterDelete(string name);
}
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
[InheritedExportAttribute("Raven.Database.FileSystem.Plugins.AbstractFileMetadataUpdateTrigger")]
public class Raven.Database.FileSystem.Bundles.Versioning.Plugins.VersioningMetadataUpdateTrigger : AbstractFileMetadataUpdateTrigger {
    private VersioningTriggerActions actions;
    public virtual void Initialize();
    public virtual VetoResult AllowUpdate(string name, RavenJObject metadata);
    public virtual void OnUpdate(string name, RavenJObject metadata);
    public virtual void AfterUpdate(string name, RavenJObject metadata);
}
[InheritedExportAttribute("Raven.Database.FileSystem.Plugins.AbstractFilePutTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.FileSystem.Bundles.Versioning.Plugins.VersioningPutTrigger : AbstractFilePutTrigger {
    private VersioningTriggerActions actions;
    public virtual void Initialize();
    public virtual VetoResult AllowPut(string name, RavenJObject metadata);
    public virtual void OnPut(string name, RavenJObject metadata);
    public virtual void AfterPut(string name, Nullable`1<long> size, RavenJObject metadata);
    public virtual void OnUpload(string name, RavenJObject metadata, int pageId, int pagePositionInFile, int pageSize);
    public virtual void AfterUpload(string name, RavenJObject metadata);
}
[InheritedExportAttribute("Raven.Database.FileSystem.Plugins.AbstractFileRenameTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.FileSystem.Bundles.Versioning.Plugins.VersioningRenameTrigger : AbstractFileRenameTrigger {
    private VersioningTriggerActions actions;
    public virtual void Initialize();
    public virtual VetoResult AllowRename(string name, string newName);
    public virtual void AfterRename(string name, string renamed, RavenJObject metadata);
}
[InheritedExportAttribute("Raven.Database.FileSystem.Plugins.AbstractSynchronizationTrigger")]
[ExportMetadataAttribute("Bundle", "Mono.Cecil.CustomAttributeArgument")]
public class Raven.Database.FileSystem.Bundles.Versioning.Plugins.VersioningSynchronizationTrigger : AbstractSynchronizationTrigger {
    private VersioningTriggerActions actions;
    public virtual void Initialize();
    public virtual void BeforeSynchronization(string name, RavenJObject metadata, SynchronizationType type);
    public virtual void AfterSynchronization(string name, RavenJObject metadata, SynchronizationType type, object additionalData);
}
public class Raven.Database.FileSystem.Bundles.Versioning.Plugins.VersioningTriggerActions : object {
    internal static string CreationOfHistoricalRevisionIsNotAllowed;
    internal static string ModificationOfHistoricalRevisionIsNotAllowed;
    private RavenFileSystem fileSystem;
    public VersioningTriggerActions(RavenFileSystem fileSystem);
    public VetoResult AllowOperation(string name, RavenJObject metadata);
    public void InitializeMetadata(string name, RavenJObject metadata);
    public string PutRevisionFile(string name, Nullable`1<long> size, RavenJObject metadata);
    public bool TryGetVersioningConfiguration(string name, RavenJObject metadata, IStorageActionsAccessor accessor, FileVersioningConfiguration& versioningConfiguration);
    public void RemoveOldRevisions(string name, long revision, FileVersioningConfiguration versioningConfiguration);
    public long GetNextRevisionNumber(string name, IStorageActionsAccessor accessor);
    private bool TryGetLatestRevisionNumber(string name, IStorageActionsAccessor accessor, Int32& latestRevision);
}
[ExtensionAttribute]
public static class Raven.Database.FileSystem.Bundles.Versioning.VersioningUtil : object {
    public static string RavenFileRevision;
    public static string RavenFileParentRevision;
    public static string RavenFileRevisionStatus;
    public static string DefaultConfigurationName;
    [ExtensionAttribute]
public static bool ChangesToRevisionsAllowed(RavenFileSystem fileSystem);
    [ExtensionAttribute]
public static bool IsVersioningDisabledForImport(IStorageActionsAccessor accessor, RavenJObject metadata);
    [ExtensionAttribute]
public static bool IsVersioningActive(RavenFileSystem fileSystem, string filePath);
    [ExtensionAttribute]
public static bool IsVersioningActive(IStorageActionsAccessor accessor, string filePath);
    [ExtensionAttribute]
public static FileVersioningConfiguration GetVersioningConfiguration(IStorageActionsAccessor accessor, string filePath);
    private static bool TryGetDeserializedConfig(IStorageActionsAccessor accessor, string configurationName, FileVersioningConfiguration& fileVersioningConfiguration);
}
public class Raven.Database.FileSystem.Controllers.AdminFileSystemController : BaseAdminFileSystemApiController {
    private static Char[] ExistingDriveLetters;
    private static string ToggleDisablePrefix;
    private static TimeSpan ReportProgressInterval;
    private static string EsentProgressString;
    private static string VoronProgressString;
    private static AdminFileSystemController();
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.AdminFileSystemController/<Put>d__1")]
[HttpPutAttribute]
[RavenRouteAttribute("admin/fs/{*id}")]
public Task`1<HttpResponseMessage> Put(string id, bool update);
    private static void EnsureFileSystemHasRequiredSettings(string id, FileSystemDocument fsDoc);
    [HttpDeleteAttribute]
[RavenRouteAttribute("admin/fs/{*id}")]
public HttpResponseMessage Delete(string id);
    [HttpDeleteAttribute]
[RavenRouteAttribute("admin/fs-batch-delete")]
public HttpResponseMessage BatchDelete();
    [HttpPostAttribute]
[RavenRouteAttribute("admin/fs/{*id}")]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.AdminFileSystemController/<OldToggleDisable>d__6")]
public Task`1<HttpResponseMessage> OldToggleDisable(string id);
    [HttpPostAttribute]
[RavenRouteAttribute("admin/fs-toggle-disable")]
public HttpResponseMessage ToggleDisable(string id, bool isSettingDisabled);
    [HttpPostAttribute]
[RavenRouteAttribute("admin/fs-batch-toggle-disable")]
public HttpResponseMessage BatchToggleDisable(bool isSettingDisabled);
    private MessageWithStatusCode<RavenFileSystem, FileSystemsLandlord> DeleteFileSystem(string id, bool isHardDeleteNeeded);
    private MessageWithStatusCode<RavenFileSystem, FileSystemsLandlord> ToggleFileSystemDisabled(string id, bool isSettingDisabled);
    [HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/admin/reset-index")]
public HttpResponseMessage ResetIndex();
    [HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/admin/optimize-index")]
public HttpResponseMessage Optimize();
    [HttpPostAttribute]
[RavenRouteAttribute("fs/admin/backup")]
[RavenRouteAttribute("fs/{fileSystemName}/admin/backup")]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.AdminFileSystemController/<Backup>d__13")]
public Task`1<HttpResponseMessage> Backup();
    [HttpPostAttribute]
[RavenRouteAttribute("admin/fs-compact")]
public HttpResponseMessage Compact();
    private static bool IsUpdateMessage(string msg);
    private bool IsValidPath(string path, HttpResponseMessage& message);
    private bool IsOnValidDrive(string path, HttpResponseMessage& message);
    [RavenRouteAttribute("fs/{fileSystemName}/admin-restore")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.AdminFileSystemController/<Restore>d__21")]
[RavenRouteAttribute("admin/fs-restore")]
public Task`1<HttpResponseMessage> Restore();
    private string FindFilesystemDocument(string rootBackupPath);
    private string ResolveTenantDataDirectory(string filesystemLocation, string filesystemName, String& documentDataDir);
    [HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/admin/synchronization/topology/view")]
public Task`1<HttpResponseMessage> SynchronizationTopology();
    [HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/admin/changedbid")]
public HttpResponseMessage ChangeDbId();
}
public class Raven.Database.FileSystem.Controllers.BaseAdminFileSystemApiController : AdminResourceApiController`2<RavenFileSystem, FileSystemsLandlord> {
    public string FileSystemName { get; }
    public RavenFileSystem FileSystem { get; }
    public ResourceType ResourceType { get; }
    public string get_FileSystemName();
    public RavenFileSystem get_FileSystem();
    public virtual ResourceType get_ResourceType();
    public virtual void MarkRequestDuration(long duration);
}
public abstract class Raven.Database.FileSystem.Controllers.BaseFileSystemApiController : ResourceApiController`2<RavenFileSystem, FileSystemsLandlord> {
    private PagingInfo paging;
    private NameValueCollection queryString;
    public string FileSystemName { get; }
    public RavenFileSystem FileSystem { get; }
    public ResourceType ResourceType { get; }
    public NotificationPublisher Publisher { get; }
    public BufferPool BufferPool { get; }
    public SigGenerator SigGenerator { get; }
    public Historian Historian { get; }
    protected NameValueCollection QueryString { get; }
    protected ITransactionalStorage Storage { get; }
    protected IndexStorage Search { get; }
    protected FileActions Files { get; }
    protected SynchronizationActions Synchronizations { get; }
    protected FileLockManager FileLockManager { get; }
    protected ConflictArtifactManager ConflictArtifactManager { get; }
    protected ConflictDetector ConflictDetector { get; }
    protected ConflictResolver ConflictResolver { get; }
    protected SynchronizationTask SynchronizationTask { get; }
    protected PagingInfo Paging { get; }
    public string get_FileSystemName();
    public RavenFileSystem get_FileSystem();
    public virtual ResourceType get_ResourceType();
    public virtual void MarkRequestDuration(long duration);
    public NotificationPublisher get_Publisher();
    public BufferPool get_BufferPool();
    public SigGenerator get_SigGenerator();
    public Historian get_Historian();
    protected NameValueCollection get_QueryString();
    protected ITransactionalStorage get_Storage();
    protected IndexStorage get_Search();
    protected FileActions get_Files();
    protected SynchronizationActions get_Synchronizations();
    protected FileLockManager get_FileLockManager();
    protected ConflictArtifactManager get_ConflictArtifactManager();
    protected ConflictDetector get_ConflictDetector();
    protected ConflictResolver get_ConflictResolver();
    protected SynchronizationTask get_SynchronizationTask();
    protected PagingInfo get_Paging();
    protected HttpResponseMessage StreamResult(string filename, Stream resultContent);
    protected FileSystemInfo GetSourceFileSystemInfo();
    protected virtual RavenJObject GetFilteredMetadataFromHeaders(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> headers);
}
public class Raven.Database.FileSystem.Controllers.ConfigController : BaseFileSystemApiController {
    private static ILog Log;
    private static ConfigController();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/config")]
public HttpResponseMessage Get();
    [RavenRouteAttribute("fs/{fileSystemName}/config")]
[HttpGetAttribute]
public HttpResponseMessage Get(string name);
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/config/non-generated")]
public HttpResponseMessage NonGeneratedConfigNames();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/config/search")]
public HttpResponseMessage ConfigNamesStartingWith(string prefix);
    [RavenRouteAttribute("fs/{fileSystemName}/config")]
[HttpPutAttribute]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.ConfigController/<Put>d__5")]
public Task`1<HttpResponseMessage> Put(string name);
    [RavenRouteAttribute("fs/{fileSystemName}/config")]
[HttpDeleteAttribute]
public HttpResponseMessage Delete(string name);
}
public class Raven.Database.FileSystem.Controllers.FilesChangesController : BaseFileSystemApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/changes/config")]
public HttpResponseMessage GetChangeConfig();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/changes/events")]
public HttpResponseMessage GetChangesEvents();
}
public class Raven.Database.FileSystem.Controllers.FilesController : BaseFileSystemApiController {
    private static ILog log;
    private static string CopyPrefix;
    private static FilesController();
    [RavenRouteAttribute("fs/{fileSystemName}/files")]
[HttpGetAttribute]
public HttpResponseMessage Get(String[] fileNames);
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/debug/files/count")]
public HttpResponseMessage Count();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/files/{*name}")]
public HttpResponseMessage Get(string name);
    private static string GetFileName(string name, RavenJObject metadata);
    [HttpDeleteAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/files/{*name}")]
public HttpResponseMessage Delete(string name);
    [HttpHeadAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/files/{*name}")]
public HttpResponseMessage Head(string name);
    [HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/files/{*name}")]
public HttpResponseMessage Post(string name);
    [HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/files-copy/{*name}")]
public HttpResponseMessage Copy(string name, string targetFilename);
    [RavenRouteAttribute("fs/{fileSystemName}/files/{*name}")]
[HttpPatchAttribute]
public HttpResponseMessage Patch(string name, string rename);
    [RavenRouteAttribute("fs/{fileSystemName}/files/{*name}")]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.FilesController/<Put>d__11")]
[HttpPutAttribute]
public Task`1<HttpResponseMessage> Put(string name, bool preserveTimestamps);
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/files-touch")]
public HttpResponseMessage TouchFiles();
    [CompilerGeneratedAttribute]
private Task`1<Stream> <Put>b__11_0();
}
public class Raven.Database.FileSystem.Controllers.FilesStreamsController : BaseFileSystemApiController {
    private static ILog log;
    private static FilesStreamsController();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/streams/files")]
public HttpResponseMessage StreamFilesGet();
    private void StreamToClient(Stream stream, int pageSize, Etag etag, OrderedPartCollection`1<AbstractFileReadTrigger> readTriggers);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.FilesStreamsController/<Export>d__3")]
[HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/streams/Export")]
public Task`1<HttpResponseMessage> Export();
    private void StreamExportToClient(Stream stream, String[] fileNames);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.FilesStreamsController/<Import>d__5")]
[HttpPutAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/streams/Import")]
public Task`1<HttpResponseMessage> Import();
    private static void ReadFromStreamToMemoryStream(Stream sourceStream, long bytesToCopy, Byte[] copyBuffer, MemoryStream destinationStream);
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/streams/query")]
public HttpResponseMessage StreamQueryGet(string query, String[] sort);
    private void StreamQueryResultsToClient(Stream stream, String[] files, OrderedPartCollection`1<AbstractFileReadTrigger> readTriggers);
}
public class Raven.Database.FileSystem.Controllers.FileSystemsController : BaseDatabaseApiController {
    [RavenRouteAttribute("fs")]
[HttpGetAttribute]
public HttpResponseMessage FileSystems(bool getAdditionalData);
    private List`1<FileSystemData> GetFileSystemsData(IEnumerable`1<RavenJToken> fileSystems);
    [RavenRouteAttribute("fs/status")]
[HttpGetAttribute]
public HttpResponseMessage Status();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/stats")]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.FileSystemsController/<Stats>d__4")]
public Task`1<HttpResponseMessage> Stats();
    [CompilerGeneratedAttribute]
private FileSystemData <GetFileSystemsData>b__1_0(RavenJToken fileSystem);
}
public class Raven.Database.FileSystem.Controllers.FileSystemsStatsController : BaseFileSystemApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/stats")]
public HttpResponseMessage Get();
}
public class Raven.Database.FileSystem.Controllers.FoldersController : BaseFileSystemApiController {
    [RavenRouteAttribute("fs/{fileSystemName}/folders/Subdirectories/{*directory}")]
[HttpGetAttribute]
public HttpResponseMessage Subdirectories(string directory);
}
[RoutePrefixAttribute("")]
public class Raven.Database.FileSystem.Controllers.FsOperationsController : BaseFileSystemApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/operation/status")]
public HttpResponseMessage OperationStatusGet();
    [RavenRouteAttribute("fs/{fileSystemName}/operation/kill")]
[HttpGetAttribute]
public HttpResponseMessage OperationKill();
    [RavenRouteAttribute("fs/{fileSystemName}/operations")]
[HttpGetAttribute]
public HttpResponseMessage CurrentOperations();
    private HttpResponseMessage GetOperationStatusMessage(IOperationState status);
}
public class Raven.Database.FileSystem.Controllers.FsSingleAuthTokenController : BaseFileSystemApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/singleAuthToken")]
public HttpResponseMessage SingleAuthGet();
}
public class Raven.Database.FileSystem.Controllers.FsStudioTasksController : BaseFileSystemApiController {
    [RavenRouteAttribute("fs/{fileSystemName}/studio-tasks/check-sufficient-diskspace")]
[HttpGetAttribute]
public HttpResponseMessage CheckSufficientDiskspaceBeforeImport(long fileSize);
    [RavenRouteAttribute("fs/{fileSystemName}/studio-tasks/import")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.FsStudioTasksController/<ImportFilesystem>d__1")]
public Task`1<HttpResponseMessage> ImportFilesystem(int batchSize, bool stripReplicationInformation, bool shouldDisableVersioningBundle);
    [RavenRouteAttribute("fs/{fileSystemName}/studio-tasks/exportFilesystem")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> ExportFilesystem(ExportData smugglerOptionsJson);
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/studio-tasks/next-operation-id")]
public HttpResponseMessage GetNextTaskId();
}
public class Raven.Database.FileSystem.Controllers.HttpTraceFsController : BaseFileSystemApiController {
    [RavenRouteAttribute("fs/{fileSystemName}/traffic-watch/events")]
[HttpGetAttribute]
public HttpResponseMessage HttpTrace();
}
public class Raven.Database.FileSystem.Controllers.RdcController : BaseFileSystemApiController {
    private static ILog Log;
    private static RdcController();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/rdc/Signatures/{*id}")]
public HttpResponseMessage Signatures(string id);
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/rdc/Stats")]
public HttpResponseMessage Stats();
    [HttpGetAttribute]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.RdcController/<Manifest>d__3")]
[RavenRouteAttribute("fs/{fileSystemName}/rdc/Manifest/{*id}")]
public Task`1<HttpResponseMessage> Manifest(string id);
}
public class Raven.Database.FileSystem.Controllers.SearchController : BaseFileSystemApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/search/Terms")]
public HttpResponseMessage Terms(string query);
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/search")]
public HttpResponseMessage Get(string query, String[] sort);
    [HttpDeleteAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/search")]
public HttpResponseMessage DeleteByQuery(string query);
    private void DeleteFiles(IEnumerable`1<string> keys, int totalResults, Action`1<string> progress);
}
public class Raven.Database.FileSystem.Controllers.StaticFSController : BaseFileSystemApiController {
    [RavenRouteAttribute("fs/{fileSystemName}/static/FavIcon")]
[HttpGetAttribute]
public HttpResponseMessage FavIcon();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/static/id")]
public HttpResponseMessage Id();
}
public class Raven.Database.FileSystem.Controllers.StorageController : BaseFileSystemApiController {
    [HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/storage/cleanup")]
public Task CleanUp();
    [HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/storage/retryRenaming")]
public Task RetryRenaming();
    [HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/storage/retryCopying")]
public Task RetryCopying();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/storage/debug/esent/current-autoincrement-table-values")]
public HttpResponseMessage EsentCurrentAutoincrementTableValues();
}
public class Raven.Database.FileSystem.Controllers.SynchronizationController : BaseFileSystemApiController {
    private static ILog Log;
    private static SynchronizationController();
    [HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/ToDestinations")]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<ToDestinations>d__1")]
public Task`1<HttpResponseMessage> ToDestinations(bool forceSyncingAll);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<ToDestination>d__2")]
[HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/ToDestination")]
public Task`1<HttpResponseMessage> ToDestination(string destination, bool forceSyncingAll);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<Start>d__3")]
[HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/start/{*filename}")]
public Task`1<HttpResponseMessage> Start(string filename);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<MultipartProceed>d__4")]
[HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/MultipartProceed")]
public Task`1<HttpResponseMessage> MultipartProceed();
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<UpdateMetadata>d__5")]
[HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/UpdateMetadata/{*fileName}")]
public Task`1<HttpResponseMessage> UpdateMetadata(string fileName);
    [RavenRouteAttribute("fs/{fileSystemName}/synchronization")]
[HttpDeleteAttribute]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<Delete>d__6")]
public Task`1<HttpResponseMessage> Delete(string fileName);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<Rename>d__7")]
[HttpPatchAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/Rename")]
public Task`1<HttpResponseMessage> Rename(string fileName, string rename);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<Confirm>d__8")]
[HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/Confirm")]
public Task`1<HttpResponseMessage> Confirm();
    [RavenRouteAttribute("fs/{fileSystemName}/synchronization/Status")]
[HttpGetAttribute]
public HttpResponseMessage Status(string fileName);
    [RavenRouteAttribute("fs/{fileSystemName}/synchronization/Finished")]
[HttpGetAttribute]
public HttpResponseMessage Finished();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/Active")]
public HttpResponseMessage Active();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/Pending")]
public HttpResponseMessage Pending();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/Incoming")]
public HttpResponseMessage Incoming();
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/Conflicts")]
public HttpResponseMessage Conflicts();
    [HttpPatchAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/ResolveConflicts")]
public HttpResponseMessage ResolveConflicts(ConflictResolutionStrategy strategy);
    [HttpPatchAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/ResolveConflict/{*filename}")]
public HttpResponseMessage ResolveConflict(string filename, ConflictResolutionStrategy strategy);
    [RavenRouteAttribute("fs/{fileSystemName}/synchronization/ResolutionStrategyFromServerResolvers")]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<ResolutionStrategyFromServerResolvers>d__17")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> ResolutionStrategyFromServerResolvers();
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<ApplyConflict>d__18")]
[HttpPatchAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/applyConflict/{*fileName}")]
public Task`1<HttpResponseMessage> ApplyConflict(string filename, long remoteVersion, string remoteServerId, string remoteServerUrl);
    [HttpGetAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/LastSynchronization")]
public HttpResponseMessage LastSynchronization(Guid from);
    [RavenRouteAttribute("fs/{fileSystemName}/synchronization/IncrementLastETag")]
[HttpPostAttribute]
public HttpResponseMessage IncrementLastETag(Guid sourceServerId, string sourceFileSystemUrl, string sourceFileETag);
    private FileStatus CheckSynchronizedFileStatus(string filename, Etag etag);
    protected virtual RavenJObject GetFilteredMetadataFromHeaders(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> headers);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationController/<ResetDestinations>d__23")]
[HttpPostAttribute]
[RavenRouteAttribute("fs/{fileSystemName}/synchronization/resetDestinations")]
public Task`1<HttpResponseMessage> ResetDestinations();
    [CompilerGeneratedAttribute]
private SynchronizationConfirmation <Confirm>b__8_0(Tuple`2<string, Etag> x);
}
public class Raven.Database.FileSystem.Controllers.SynchronizationTopologyController : BaseFileSystemApiController {
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Controllers.SynchronizationTopologyController/<ReplicationTopologyDiscover>d__0")]
[RavenRouteAttribute("fs/{fileSystemName}/admin/replication/topology/discover")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> ReplicationTopologyDiscover();
}
[ExtensionAttribute]
public static class Raven.Database.FileSystem.Extensions.ConfigurationExtension : object {
    [ExtensionAttribute]
public static T GetConfigurationValue(IStorageActionsAccessor accessor, string key);
    [ExtensionAttribute]
public static bool TryGetConfigurationValue(IStorageActionsAccessor accessor, string key, T& result);
    [ExtensionAttribute]
public static void SetConfigurationValue(IStorageActionsAccessor accessor, string key, T objectToSave);
}
[ExtensionAttribute]
public static class Raven.Database.FileSystem.Extensions.EnumExtensions : object {
    [ExtensionAttribute]
public static string GetDescription(object enumerationValue);
}
[ExtensionAttribute]
public static class Raven.Database.FileSystem.Extensions.MetadataExtensions : object {
    [ExtensionAttribute]
public static RavenJObject DropRenameMarkers(RavenJObject metadata);
    [ExtensionAttribute]
public static RavenJObject WithRenameMarkers(RavenJObject metadata, string rename);
    [ExtensionAttribute]
public static RavenJObject WithDeleteMarker(RavenJObject metadata);
    [ExtensionAttribute]
public static T ValueOrDefault(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> self, string name, T default);
    [ExtensionAttribute]
public static T Value(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> self, string name);
    [ExtensionAttribute]
public static void AddHeaders(HttpWebRequest request, RavenJObject metadata);
}
[ExtensionAttribute]
public static class Raven.Database.FileSystem.Extensions.StreamExtensions : object {
    [ExtensionAttribute]
[AsyncStateMachineAttribute("Raven.Database.FileSystem.Extensions.StreamExtensions/<ReadAsync>d__0")]
private static Task ReadAsync(Stream self, Byte[] buffer, int start, List`1<int> reads);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Extensions.StreamExtensions/<ReadAsync>d__1")]
[ExtensionAttribute]
private static Task`1<int> ReadAsync(Stream self, Byte[] buffer, int start);
    [ExtensionAttribute]
public static Task`1<int> ReadAsync(Stream self, Byte[] buffer);
    [ExtensionAttribute]
public static Task CopyToAsync(Stream self, Stream destination, long from, long to);
}
public class Raven.Database.FileSystem.Infrastructure.Historian : object {
    private ITransactionalStorage storage;
    private SynchronizationHiLo synchronizationHiLo;
    public Historian(ITransactionalStorage storage, SynchronizationHiLo synchronizationHiLo);
    public void Update(string fileName, RavenJObject sourceMetadata);
    public void UpdateLastModified(RavenJObject metadata);
    public void UpdateLastModified(RavenJObject metadata, DateTimeOffset when);
    private RavenJObject GetMetadata(string fileName);
    public static List`1<HistoryItem> DeserializeHistory(RavenJObject metadata);
    public static RavenJArray SerializeHistory(List`1<HistoryItem> history);
    public static bool IsDirectChildOfCurrent(RavenJObject destinationMetadata, RavenJObject sourceMetadata);
}
public class Raven.Database.FileSystem.Infrastructure.LimitedStream : Stream {
    private Stream inner;
    private long end;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public LimitedStream(Stream inner, long start, long end);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
}
public class Raven.Database.FileSystem.Infrastructure.SequenceActions : object {
    private static string SequencesKeyPrefix;
    private ITransactionalStorage storage;
    public SequenceActions(ITransactionalStorage storage);
    public long GetNextValue(string name);
    private static string SequenceName(string name);
}
public class Raven.Database.FileSystem.Infrastructure.TempDirectoryTools : object {
    public static string Create(InMemoryRavenConfiguration configuration);
}
public class Raven.Database.FileSystem.Infrastructure.UuidGenerator : object {
    private long currentEtagBase;
    private long sequentialUuidCounter;
    unknown long EtagBase {public set; }
    public void set_EtagBase(long value);
    public Etag CreateSequentialUuid();
}
public interface Raven.Database.FileSystem.Notifications.INotificationPublisher {
    public abstract virtual void Publish(FileSystemNotification change);
}
public class Raven.Database.FileSystem.Notifications.NotificationPublisher : object {
    private TransportState transportState;
    public NotificationPublisher(TransportState transportState);
    public sealed virtual void Publish(FileSystemNotification change);
}
internal class Raven.Database.FileSystem.Notifications.TypeHidingBinder : SerializationBinder {
    private ConcurrentDictionary`2<string, Type> cachedTypes;
    public virtual Type BindToType(string assemblyName, string typeName);
    public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
[InheritedExportAttribute]
public abstract class Raven.Database.FileSystem.Plugins.AbstractFileCodec : object {
    [CompilerGeneratedAttribute]
private RavenFileSystem <FileSystem>k__BackingField;
    public RavenFileSystem FileSystem { get; public set; }
    [CompilerGeneratedAttribute]
public RavenFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
public void set_FileSystem(RavenFileSystem value);
    public virtual void Initialize(RavenFileSystem fileSystem);
    public virtual void Initialize();
    public virtual void SecondStageInit();
    public abstract virtual Stream EncodePage(Stream data);
    public abstract virtual Stream DecodePage(Stream encodedDataStream);
}
[InheritedExportAttribute]
public abstract class Raven.Database.FileSystem.Plugins.AbstractFileDeleteTrigger : object {
    [CompilerGeneratedAttribute]
private RavenFileSystem <FileSystem>k__BackingField;
    public RavenFileSystem FileSystem { get; private set; }
    [CompilerGeneratedAttribute]
public RavenFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(RavenFileSystem value);
    public sealed virtual void Initialize(RavenFileSystem fileSystem);
    public virtual void SecondStageInit();
    public virtual void Initialize();
    public virtual VetoResult AllowDelete(string name);
    public virtual void AfterDelete(string name);
}
[InheritedExportAttribute]
public abstract class Raven.Database.FileSystem.Plugins.AbstractFileMetadataUpdateTrigger : object {
    [CompilerGeneratedAttribute]
private RavenFileSystem <FileSystem>k__BackingField;
    public RavenFileSystem FileSystem { get; private set; }
    [CompilerGeneratedAttribute]
public RavenFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(RavenFileSystem value);
    public virtual void Initialize(RavenFileSystem fileSystem);
    public virtual void Initialize();
    public virtual void SecondStageInit();
    public virtual VetoResult AllowUpdate(string name, RavenJObject metadata);
    public virtual void OnUpdate(string name, RavenJObject metadata);
    public virtual void AfterUpdate(string name, RavenJObject metadata);
}
[InheritedExportAttribute]
public abstract class Raven.Database.FileSystem.Plugins.AbstractFilePutTrigger : object {
    [CompilerGeneratedAttribute]
private RavenFileSystem <FileSystem>k__BackingField;
    public RavenFileSystem FileSystem { get; private set; }
    [CompilerGeneratedAttribute]
public RavenFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(RavenFileSystem value);
    public virtual void Initialize(RavenFileSystem fileSystem);
    public virtual void Initialize();
    public virtual void SecondStageInit();
    public virtual VetoResult AllowPut(string name, RavenJObject metadata);
    public virtual void OnPut(string name, RavenJObject metadata);
    public virtual void AfterPut(string name, Nullable`1<long> size, RavenJObject metadata);
    public virtual void OnUpload(string name, RavenJObject metadata, int pageId, int pagePositionInFile, int pageSize);
    public virtual void AfterUpload(string name, RavenJObject metadata);
}
[InheritedExportAttribute]
public abstract class Raven.Database.FileSystem.Plugins.AbstractFileReadTrigger : object {
    [CompilerGeneratedAttribute]
private RavenFileSystem <FileSystem>k__BackingField;
    public RavenFileSystem FileSystem { get; private set; }
    [CompilerGeneratedAttribute]
public RavenFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(RavenFileSystem value);
    public sealed virtual void Initialize(RavenFileSystem fileSystem);
    public virtual void SecondStageInit();
    public virtual void Initialize();
    public virtual ReadVetoResult AllowRead(string name, RavenJObject metadata, ReadOperation operation);
}
[InheritedExportAttribute]
public abstract class Raven.Database.FileSystem.Plugins.AbstractFileRenameTrigger : object {
    [CompilerGeneratedAttribute]
private RavenFileSystem <FileSystem>k__BackingField;
    public RavenFileSystem FileSystem { get; private set; }
    [CompilerGeneratedAttribute]
public RavenFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(RavenFileSystem value);
    public virtual void Initialize(RavenFileSystem fileSystem);
    public virtual void Initialize();
    public virtual void SecondStageInit();
    public virtual VetoResult AllowRename(string name, string newName);
    public virtual void OnRename(string name, RavenJObject metadata);
    public virtual void AfterRename(string name, string newName, RavenJObject metadata);
}
[InheritedExportAttribute]
public abstract class Raven.Database.FileSystem.Plugins.AbstractSynchronizationTrigger : object {
    [CompilerGeneratedAttribute]
private RavenFileSystem <FileSystem>k__BackingField;
    public RavenFileSystem FileSystem { get; private set; }
    [CompilerGeneratedAttribute]
public RavenFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(RavenFileSystem value);
    public virtual void Initialize(RavenFileSystem fileSystem);
    public virtual void Initialize();
    public virtual void SecondStageInit();
    public virtual void BeforeSynchronization(string name, RavenJObject metadata, SynchronizationType type);
    public virtual void AfterSynchronization(string name, RavenJObject metadata, SynchronizationType type, object additionalData);
}
[InheritedExportAttribute("Raven.Database.FileSystem.Plugins.AbstractFileReadTrigger")]
public class Raven.Database.FileSystem.Plugins.Builtins.HideDeletingFilesTrigger : AbstractFileReadTrigger {
    public virtual ReadVetoResult AllowRead(string name, RavenJObject metadata, ReadOperation operation);
}
[InheritedExportAttribute("Raven.Database.FileSystem.Plugins.AbstractFileReadTrigger")]
public class Raven.Database.FileSystem.Plugins.Builtins.HideDownloadingFileTrigger : AbstractFileReadTrigger {
    public virtual ReadVetoResult AllowRead(string name, RavenJObject metadata, ReadOperation operation);
}
public interface Raven.Database.FileSystem.Plugins.IRequiresFileSystemInitialization {
    public abstract virtual void Initialize(RavenFileSystem fileSystem);
    public abstract virtual void SecondStageInit();
}
[ExtensionAttribute]
public static class Raven.Database.FileSystem.Plugins.TriggerExtensions : object {
    private static ILog Log;
    private static TriggerExtensions();
    [ExtensionAttribute]
public static bool CanReadFile(OrderedPartCollection`1<AbstractFileReadTrigger> triggers, string name, RavenJObject metadata, ReadOperation operation);
}
public class Raven.Database.FileSystem.RavenFileSystem : object {
    private static ILog Log;
    private ConflictArtifactManager conflictArtifactManager;
    private ConflictDetector conflictDetector;
    private ConflictResolver conflictResolver;
    private FileLockManager fileLockManager;
    private NotificationPublisher notificationPublisher;
    private IndexStorage search;
    private SigGenerator sigGenerator;
    private ITransactionalStorage storage;
    private SynchronizationTask synchronizationTask;
    private InMemoryRavenConfiguration configuration;
    private TransportState transportState;
    private MetricsCountersManager metricsCounters;
    private ThreadLocal`1<DisableTriggerState> disableAllTriggers;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed;
    private Historian historian;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskActions <Tasks>k__BackingField;
    [CompilerGeneratedAttribute]
private FileActions <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private SynchronizationActions <Synchronizations>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceTimerManager <TimerManager>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSynchronizationLock <FileLock>k__BackingField;
    [CompilerGeneratedAttribute]
private AtomicDictionary`1<object> <ExtensionsState>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractFileCodec> <FileCodecs>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractFilePutTrigger> <PutTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractFileMetadataUpdateTrigger> <MetadataUpdateTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractFileRenameTrigger> <RenameTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractFileDeleteTrigger> <DeleteTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractFileReadTrigger> <ReadTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractSynchronizationTrigger> <SynchronizationTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private BufferPool <BufferPool>k__BackingField;
    public string Name { get; private set; }
    public string ResourceName { get; private set; }
    public TaskActions Tasks { get; private set; }
    public FileActions Files { get; private set; }
    public SynchronizationActions Synchronizations { get; private set; }
    public ResourceTimerManager TimerManager { get; private set; }
    internal FileSynchronizationLock FileLock { get; private set; }
    public static bool IsRemoteDifferentialCompressionInstalled { get; }
    public AtomicDictionary`1<object> ExtensionsState { get; private set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractFileCodec> FileCodecs { get; public set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractFilePutTrigger> PutTriggers { get; public set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractFileMetadataUpdateTrigger> MetadataUpdateTriggers { get; public set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractFileRenameTrigger> RenameTriggers { get; public set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractFileDeleteTrigger> DeleteTriggers { get; public set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractFileReadTrigger> ReadTriggers { get; public set; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractSynchronizationTrigger> SynchronizationTriggers { get; public set; }
    public ITransactionalStorage Storage { get; }
    public IndexStorage Search { get; }
    public BufferPool BufferPool { get; private set; }
    public InMemoryRavenConfiguration Configuration { get; }
    public SigGenerator SigGenerator { get; }
    public NotificationPublisher Publisher { get; }
    public Historian Historian { get; }
    public FileLockManager FileLockManager { get; }
    public SynchronizationTask SynchronizationTask { get; }
    public ConflictArtifactManager ConflictArtifactManager { get; }
    public ConflictDetector ConflictDetector { get; }
    public ConflictResolver ConflictResolver { get; }
    [CLSCompliantAttribute("False")]
public MetricsCountersManager MetricsCounters { get; }
    public TransportState TransportState { get; }
    public RavenFileSystem(InMemoryRavenConfiguration config, string name, TransportState receivedTransportState);
    private static RavenFileSystem();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResourceName();
    [CompilerGeneratedAttribute]
private void set_ResourceName(string value);
    [CompilerGeneratedAttribute]
public TaskActions get_Tasks();
    [CompilerGeneratedAttribute]
private void set_Tasks(TaskActions value);
    [CompilerGeneratedAttribute]
public FileActions get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(FileActions value);
    [CompilerGeneratedAttribute]
public SynchronizationActions get_Synchronizations();
    [CompilerGeneratedAttribute]
private void set_Synchronizations(SynchronizationActions value);
    [CompilerGeneratedAttribute]
public ResourceTimerManager get_TimerManager();
    [CompilerGeneratedAttribute]
private void set_TimerManager(ResourceTimerManager value);
    [CompilerGeneratedAttribute]
internal FileSynchronizationLock get_FileLock();
    [CompilerGeneratedAttribute]
private void set_FileLock(FileSynchronizationLock value);
    public void Initialize();
    public static bool get_IsRemoteDifferentialCompressionInstalled();
    private void ValidateStorage();
    public static ITransactionalStorage CreateTransactionalStorage(InMemoryRavenConfiguration configuration);
    public IDisposable DisableAllTriggersForCurrentThread(HashSet`1<Type> except);
    private void InitializeTriggersExceptIndexCodecs();
    private void SecondStageInitialization();
    [CompilerGeneratedAttribute]
public sealed virtual AtomicDictionary`1<object> get_ExtensionsState();
    [CompilerGeneratedAttribute]
private void set_ExtensionsState(AtomicDictionary`1<object> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractFileCodec> get_FileCodecs();
    [CompilerGeneratedAttribute]
public void set_FileCodecs(OrderedPartCollection`1<AbstractFileCodec> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractFilePutTrigger> get_PutTriggers();
    [CompilerGeneratedAttribute]
public void set_PutTriggers(OrderedPartCollection`1<AbstractFilePutTrigger> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractFileMetadataUpdateTrigger> get_MetadataUpdateTriggers();
    [CompilerGeneratedAttribute]
public void set_MetadataUpdateTriggers(OrderedPartCollection`1<AbstractFileMetadataUpdateTrigger> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractFileRenameTrigger> get_RenameTriggers();
    [CompilerGeneratedAttribute]
public void set_RenameTriggers(OrderedPartCollection`1<AbstractFileRenameTrigger> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractFileDeleteTrigger> get_DeleteTriggers();
    [CompilerGeneratedAttribute]
public void set_DeleteTriggers(OrderedPartCollection`1<AbstractFileDeleteTrigger> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractFileReadTrigger> get_ReadTriggers();
    [CompilerGeneratedAttribute]
public void set_ReadTriggers(OrderedPartCollection`1<AbstractFileReadTrigger> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractSynchronizationTrigger> get_SynchronizationTriggers();
    [CompilerGeneratedAttribute]
public void set_SynchronizationTriggers(OrderedPartCollection`1<AbstractSynchronizationTrigger> value);
    public ITransactionalStorage get_Storage();
    public IndexStorage get_Search();
    [CompilerGeneratedAttribute]
public BufferPool get_BufferPool();
    [CompilerGeneratedAttribute]
private void set_BufferPool(BufferPool value);
    public sealed virtual InMemoryRavenConfiguration get_Configuration();
    public SigGenerator get_SigGenerator();
    public NotificationPublisher get_Publisher();
    public Historian get_Historian();
    public FileLockManager get_FileLockManager();
    public SynchronizationTask get_SynchronizationTask();
    public ConflictArtifactManager get_ConflictArtifactManager();
    public ConflictDetector get_ConflictDetector();
    public ConflictResolver get_ConflictResolver();
    public MetricsCountersManager get_MetricsCounters();
    public sealed virtual TransportState get_TransportState();
    public sealed virtual void Dispose();
    public FileSystemMetrics CreateMetrics();
    private void ShouldDispose(object sender, EventArgs eventArgs);
    public FileSystemStats GetFileSystemStats();
    [CompilerGeneratedAttribute]
private void <Initialize>b__45_0(string storagePath);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__51_0(IRequiresFileSystemInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__51_1(IRequiresFileSystemInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__51_2(IRequiresFileSystemInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__51_3(IRequiresFileSystemInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__51_4(IRequiresFileSystemInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__51_5(IRequiresFileSystemInitialization initialization);
    [CompilerGeneratedAttribute]
private void <InitializeTriggersExceptIndexCodecs>b__51_6(IRequiresFileSystemInitialization initialization);
}
public class Raven.Database.FileSystem.Search.IndexSearcherHolder : object {
    private IndexSearcherHoldingState modreq(System.Runtime.CompilerServices.IsVolatile) current;
    public void SetIndexSearcher(IndexSearcher searcher);
    public IDisposable GetSearcher(IndexSearcher& searcher);
}
public class Raven.Database.FileSystem.Search.IndexStorage : CriticalFinalizerObject {
    private static string IndexVersion;
    private static ILog Log;
    private static ILog StartupLog;
    private static string DateIndexFormat;
    public static Regex IsNumeric;
    private static String[] ExcludeNumericFields;
    private string name;
    private InMemoryRavenConfiguration configuration;
    private object writerLock;
    private IndexSearcherHolder currentIndexSearcherHolder;
    private string indexDirectory;
    private Directory directory;
    private RavenFileSystem filesystem;
    private LowerCaseKeywordAnalyzer analyzer;
    private SnapshotDeletionPolicy snapshotter;
    private IndexWriter writer;
    private FileStream crashMarker;
    private bool resetIndexOnUncleanShutdown;
    private static string IndexVersionFilename;
    public IndexStorage(string name, InMemoryRavenConfiguration configuration);
    private static IndexStorage();
    public void Initialize(RavenFileSystem filesystem);
    internal Directory MakeRAMDirectoryPhysical(RAMDirectory ramDir, string indexFolder);
    private void OpenIndexOnStartup();
    private bool IsIndexStateValid(Directory luceneDirectory);
    protected Etag GetLastEtagForIndex();
    public void ForceIndexReset();
    internal void TryResettingIndex();
    private Directory OpenOrCreateLuceneDirectory(string path);
    private void EnsureIndexVersionMatches(Directory directory);
    private void WriteIndexVersion(Directory directory);
    private void CheckIndexAndTryToFix(Directory directory);
    public String[] Query(string query, String[] sortFields, int start, int pageSize, Int32& totalResults, Int64& durationInMs);
    private TopDocs ExecuteQuery(IndexSearcher searcher, String[] sortFields, Query q, int size);
    private void Index(IndexWriter writer, string key, RavenJObject metadata, Etag etag, bool recreateSearcher);
    private static void AddField(Document doc, string key, string value);
    public virtual void Index(string key, RavenJObject metadata, Etag etag);
    private static Document CreateDocument(string lowerKey, RavenJObject metadata);
    internal IDisposable GetSearcher(IndexSearcher& searcher);
    private void SafeDispose(IDisposable disposable);
    public sealed virtual void Dispose();
    public void Delete(string key);
    public void OptimizeIndex();
    private void ReplaceSearcher(IndexWriter writer);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Search.IndexStorage/<GetTermsFor>d__43")]
public IEnumerable`1<string> GetTermsFor(string field, string fromValue);
    public void Backup(string backupDirectory, CancellationToken token);
    private static void TryDelete(string neededFilePath);
    [CompilerGeneratedAttribute]
private void <Dispose>b__39_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__39_1();
    [CompilerGeneratedAttribute]
private void <Dispose>b__39_2();
    [CompilerGeneratedAttribute]
private void <Dispose>b__39_3();
    [CompilerGeneratedAttribute]
private void <Dispose>b__39_4();
}
public class Raven.Database.FileSystem.Search.SimpleFilesQueryParser : QueryParser {
    public static Regex NumericRangeValue;
    public static Regex DateTimeValue;
    private RavenPerFieldAnalyzerWrapper fieldAnalyzer;
    public SimpleFilesQueryParser(Analyzer analyzer);
    private static SimpleFilesQueryParser();
    protected virtual Query GetRangeQuery(string field, string lower, string upper, bool inclusive);
    public virtual Query Parse(string originalQuery);
}
public class Raven.Database.FileSystem.Smuggler.FilesystemDataDumper : SmugglerFilesApiBase {
    public Action`1<string> Progress { get; public set; }
    public FilesystemDataDumper(RavenFileSystem fileSystem, SmugglerFilesOptions options);
    public virtual Task Between(SmugglerBetweenOptions`1<FilesConnectionStringOptions> betweenOptions);
    public Action`1<string> get_Progress();
    public void set_Progress(Action`1<string> value);
}
public class Raven.Database.FileSystem.Smuggler.SmugglerEmbeddedFilesOperations : object {
    private RavenFileSystem filesystem;
    [CompilerGeneratedAttribute]
private Action`1<string> <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private SmugglerFilesOptions <Options>k__BackingField;
    public Action`1<string> Progress { get; public set; }
    public SmugglerFilesOptions Options { get; private set; }
    public bool IsEmbedded { get; }
    public SmugglerEmbeddedFilesOperations(RavenFileSystem filesystem);
    [CompilerGeneratedAttribute]
public Action`1<string> get_Progress();
    [CompilerGeneratedAttribute]
public void set_Progress(Action`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual SmugglerFilesOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(SmugglerFilesOptions value);
    public sealed virtual Task`1<FileSystemStats[]> GetStats();
    public sealed virtual Task`1<BuildNumber> GetVersion(FilesConnectionStringOptions server);
    public sealed virtual LastFilesEtagsInfo FetchCurrentMaxEtags();
    public sealed virtual Task`1<IAsyncEnumerator`1<FileHeader>> GetFiles(Etag lastEtag, int take);
    public sealed virtual Task`1<IEnumerable`1<KeyValuePair`2<string, RavenJObject>>> GetConfigurations(int start, int take);
    public sealed virtual Task PutConfig(string name, RavenJObject value);
    public sealed virtual Task`1<Stream> DownloadFile(FileHeader file);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Smuggler.SmugglerEmbeddedFilesOperations/<PutFile>d__17")]
public sealed virtual Task PutFile(FileHeader file, Stream data, long dataSize);
    public sealed virtual void Initialize(SmugglerFilesOptions options);
    public sealed virtual void Configure(SmugglerFilesOptions options);
    public sealed virtual void ShowProgress(string format, Object[] args);
    public sealed virtual string CreateIncrementalKey();
    public sealed virtual Task`1<ExportFilesDestinations> GetIncrementalExportKey();
    public sealed virtual Task PutIncrementalExportKey(ExportFilesDestinations destinations);
    public sealed virtual RavenJObject StripReplicationInformationFromMetadata(RavenJObject metadata);
    public sealed virtual RavenJObject DisableVersioning(RavenJObject metadata);
    public sealed virtual Task`1<Stream> ReceiveFilesInStream(List`1<string> filePaths);
    public sealed virtual bool get_IsEmbedded();
    public sealed virtual Task UploadFilesInStream(FileUploadUnitOfWork[] files);
}
public abstract class Raven.Database.FileSystem.Storage.BaseBackupOperation : object {
    protected static ILog log;
    protected RavenFileSystem filesystem;
    protected string backupSourceDirectory;
    protected string backupDestinationDirectory;
    protected bool incrementalBackup;
    protected FileSystemDocument filesystemDocument;
    protected ResourceBackupState state;
    protected CancellationToken token;
    protected bool BackupAlreadyExists { get; }
    protected BaseBackupOperation(RavenFileSystem filesystem, string backupSourceDirectory, string backupDestinationDirectory, bool incrementalBackup, FileSystemDocument filesystemDocument, ResourceBackupState state, CancellationToken token);
    private static BaseBackupOperation();
    protected abstract virtual bool get_BackupAlreadyExists();
    protected abstract virtual void ExecuteBackup(string backupPath, bool isIncrementalBackup, CancellationToken token);
    protected virtual void OperationFinishedSuccessfully();
    public void Execute();
    protected abstract virtual bool CanPerformIncrementalBackup();
    private void EnsureBackupDestinationExists();
    protected string DirectoryForIncrementalBackup();
    private BackupStatus GetBackupStatus();
    private void SetBackupStatus(BackupStatus backupStatus);
    private void DeleteBackupStatus();
    protected void CompleteBackup();
    protected void UpdateBackupStatus(string newMsg, Exception exception, BackupMessageSeverity severity);
}
internal abstract class Raven.Database.FileSystem.Storage.BaseRestoreOperation : object {
    private static string IndexesSubfolder;
    protected static ILog log;
    protected Action`1<string> output;
    protected string backupLocation;
    protected FilesystemRestoreRequest _restoreRequest;
    protected InMemoryRavenConfiguration Configuration;
    protected string databaseLocation;
    protected string indexLocation;
    protected string journalLocation;
    protected BaseRestoreOperation(FilesystemRestoreRequest restoreRequest, InMemoryRavenConfiguration configuration, Action`1<string> output);
    private static BaseRestoreOperation();
    public abstract virtual void Execute();
    protected void ValidateRestorePreconditionsAndReturnLogsPath(string backupFilename);
    protected virtual void CheckBackupOwner();
    protected abstract virtual bool IsValidBackup(string backupFilename);
    protected string BackupIndexesPath();
    private void CopyAll(DirectoryInfo source, DirectoryInfo target);
    private void ForceIndexReset(string indexPath, Exception ex);
    protected void CopyIndexes();
    protected string BackupFilenamePath(string backupFilename);
}
public class Raven.Database.FileSystem.Storage.CopyFileOperation : object {
    [CompilerGeneratedAttribute]
private string <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFilename>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFilename>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <MetadataAfterOperation>k__BackingField;
    public string FileSystem { get; public set; }
    public string SourceFilename { get; public set; }
    public string TargetFilename { get; public set; }
    public RavenJObject MetadataAfterOperation { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FileSystem();
    [CompilerGeneratedAttribute]
public void set_FileSystem(string value);
    [CompilerGeneratedAttribute]
public string get_SourceFilename();
    [CompilerGeneratedAttribute]
public void set_SourceFilename(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFilename();
    [CompilerGeneratedAttribute]
public void set_TargetFilename(string value);
    [CompilerGeneratedAttribute]
public RavenJObject get_MetadataAfterOperation();
    [CompilerGeneratedAttribute]
public void set_MetadataAfterOperation(RavenJObject value);
}
public class Raven.Database.FileSystem.Storage.DeleteFileOperation : object {
    [CompilerGeneratedAttribute]
private string <OriginalFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentFileName>k__BackingField;
    public string OriginalFileName { get; public set; }
    public string CurrentFileName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OriginalFileName();
    [CompilerGeneratedAttribute]
public void set_OriginalFileName(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentFileName();
    [CompilerGeneratedAttribute]
public void set_CurrentFileName(string value);
}
public class Raven.Database.FileSystem.Storage.Esent.Backup.BackupOperation : BaseBackupOperation {
    private JET_INSTANCE instance;
    private string backupConfigPath;
    protected bool BackupAlreadyExists { get; }
    public BackupOperation(RavenFileSystem filesystem, string backupSourceDirectory, string backupDestinationDirectory, bool incrementalBackup, FileSystemDocument filesystemDocument, ResourceBackupState state, CancellationToken token);
    protected virtual bool get_BackupAlreadyExists();
    protected virtual void ExecuteBackup(string backupPath, bool isIncrementalBackup, CancellationToken token);
    protected virtual void OperationFinishedSuccessfully();
    protected virtual bool CanPerformIncrementalBackup();
}
internal class Raven.Database.FileSystem.Storage.Esent.Backup.RestoreOperation : BaseRestoreOperation {
    public RestoreOperation(FilesystemRestoreRequest restoreRequest, InMemoryRavenConfiguration configuration, Action`1<string> operationOutputCallback);
    protected virtual bool IsValidBackup(string backupFilename);
    protected virtual void CheckBackupOwner();
    public virtual void Execute();
    private void CombineIncrementalBackups();
    private JET_err RestoreStatusCallback(JET_SESID sesid, JET_SNP snp, JET_SNT snt, object data);
    private JET_err CompactStatusCallback(JET_SESID sesid, JET_SNP snp, JET_SNT snt, object data);
}
[ExtensionAttribute]
public static class Raven.Database.FileSystem.Storage.Esent.EsentExtension : object {
    [ExtensionAttribute]
public static void WithDatabase(JET_INSTANCE instance, string database, Action`2<Session, JET_DBID> action);
}
[InheritedExportAttribute]
public interface Raven.Database.FileSystem.Storage.Esent.Schema.IFileSystemSchemaUpdate {
    public string FromSchemaVersion { get; }
    public abstract virtual string get_FromSchemaVersion();
    public abstract virtual void Init(InMemoryRavenConfiguration configuration);
    public abstract virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Database.FileSystem.Storage.Esent.Schema.Updates.From03To04 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Database.FileSystem.Storage.Esent.Schema.Updates.From04To05 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
    private static string GuidToEtagMigrationInConfigurations(string metadata, string name);
}
public class Raven.Database.FileSystem.Storage.Esent.Schema.Updates.From05To06 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Database.FileSystem.Storage.Esent.Schema.Updates.From06To07 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Database.FileSystem.Storage.Esent.SchemaCreator : object {
    public static string SchemaVersion;
    private Session session;
    public SchemaCreator(Session session);
    public void Create(string database);
    private void CreateDetailsTable(JET_DBID dbid);
    private void CreatePagesTable(JET_DBID dbid);
    private void CreateSignaturesTable(JET_DBID dbid);
    private void CreateUsageTable(JET_DBID dbid);
    private void CreateFilesTable(JET_DBID dbid);
    private void CreateConfigTable(JET_DBID dbid);
    public static void UpdateVersion(Session session, JET_DBID dbid, string newVersion);
}
public class Raven.Database.FileSystem.Storage.Esent.StorageActionsAccessor : object {
    private static ILog log;
    private JET_DBID database;
    private Session session;
    private TableColumnsCache tableColumnsCache;
    private UuidGenerator uuidGenerator;
    private OrderedPartCollection`1<AbstractFileCodec> fileCodecs;
    private Table config;
    private Table details;
    private Table files;
    private Table pages;
    private Table signatures;
    private Transaction transaction;
    private Table usage;
    private static int bookmarkMost;
    [CompilerGeneratedAttribute]
private bool <IsNested>k__BackingField;
    private Table Files { get; }
    private Table Signatures { get; }
    private Table Config { get; }
    private Table Usage { get; }
    private Table Pages { get; }
    private Table Details { get; }
    public bool IsNested { get; public set; }
    public StorageActionsAccessor(TableColumnsCache tableColumnsCache, JET_INSTANCE instance, string databaseName, UuidGenerator uuidGenerator, OrderedPartCollection`1<AbstractFileCodec> fileCodecs);
    private static StorageActionsAccessor();
    private Table get_Files();
    private Table get_Signatures();
    private Table get_Config();
    private Table get_Usage();
    private Table get_Pages();
    private Table get_Details();
    [DebuggerNonUserCodeAttribute]
[DebuggerHiddenAttribute]
public sealed virtual void Dispose();
    [DebuggerNonUserCodeAttribute]
[DebuggerHiddenAttribute]
public sealed virtual void Commit();
    public sealed virtual void PulseTransaction();
    public sealed virtual int InsertPage(Byte[] buffer, int size);
    public sealed virtual FileUpdateResult PutFile(string filename, Nullable`1<long> totalSize, RavenJObject metadata, bool tombstone);
    private static string ToQueryString(RavenJObject metadata);
    public sealed virtual void AssociatePage(string filename, int pageId, int pagePositionInFile, int pageSize, bool incrementUsageCount);
    private void IncrementUsageCount(int pageId);
    private Nullable`1<long> GetTotalSize();
    public sealed virtual int ReadPage(int pageId, Byte[] buffer);
    public sealed virtual FileHeader ReadFile(string filename);
    public sealed virtual FileAndPagesInformation GetFile(string filename, int start, int pagesToLoad);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Esent.StorageActionsAccessor/<ReadFiles>d__39")]
public sealed virtual IEnumerable`1<FileHeader> ReadFiles(int start, int size);
    private RavenJObject RetrieveMetadata();
    public sealed virtual IEnumerable`1<FileHeader> GetFilesAfter(Etag etag, int take);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Esent.StorageActionsAccessor/<GetFilesStartingWith>d__42")]
public sealed virtual IEnumerable`1<FileHeader> GetFilesStartingWith(string namePrefix, int start, int take);
    public sealed virtual Etag GetLastEtag();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsNested();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsNested(bool value);
    public sealed virtual void Delete(string filename);
    public sealed virtual FileUpdateResult UpdateFileMetadata(string filename, RavenJObject metadata, Etag etag);
    public sealed virtual FileUpdateResult TouchFile(string filename, Etag etag);
    public sealed virtual void CompleteFileUpload(string filename);
    public sealed virtual int GetFileCount();
    public sealed virtual void DecrementFileCount(string nameOfFileThatShouldNotBeCounted);
    public sealed virtual void RenameFile(string filename, string rename, bool commitPeriodically);
    public sealed virtual void CopyFile(string sourceFilename, string targetFilename, bool commitPeriodically);
    public sealed virtual RavenJObject GetConfig(string name);
    public sealed virtual void SetConfig(string name, RavenJObject metadata);
    public sealed virtual void DeleteConfig(string name);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Esent.StorageActionsAccessor/<GetSignatures>d__59")]
public sealed virtual IEnumerable`1<SignatureLevels> GetSignatures(string name);
    public sealed virtual void ClearSignatures(string name);
    public sealed virtual long GetSignatureSize(int id, int level);
    public sealed virtual void GetSignatureStream(int id, int level, Action`1<Stream> action);
    public sealed virtual void AddSignature(string name, int level, Action`1<Stream> action);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Esent.StorageActionsAccessor/<GetConfigNames>d__64")]
public sealed virtual IEnumerable`1<string> GetConfigNames(int start, int pageSize);
    public sealed virtual bool ConfigExists(string name);
    public sealed virtual IList`1<RavenJObject> GetConfigsStartWithPrefix(string prefix, int start, int take, Int32& totalCount);
    public sealed virtual IList`1<string> GetConfigNamesStartingWithPrefix(string prefix, int start, int take, Int32& total);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Esent.StorageActionsAccessor/<IterateConfigsWithPrefix>d__68")]
private IEnumerable`1<object> IterateConfigsWithPrefix(string prefix, int start, int take, Reference`1<int> totalCount);
    private Etag EnsureFileEtagMatch(string key, Etag etag);
    public sealed virtual Dictionary`2<string, long> Esent_GetCurrentAutoIncrementValues();
}
public class Raven.Database.FileSystem.Storage.Esent.TableColumnsCache : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <UsageColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <PagesColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <FilesColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <DetailsColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <ConfigColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <SignaturesColumns>k__BackingField;
    public IDictionary`2<string, JET_COLUMNID> UsageColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> PagesColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> FilesColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> DetailsColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> ConfigColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> SignaturesColumns { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_UsageColumns();
    [CompilerGeneratedAttribute]
public void set_UsageColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_PagesColumns();
    [CompilerGeneratedAttribute]
public void set_PagesColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_FilesColumns();
    [CompilerGeneratedAttribute]
public void set_FilesColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_DetailsColumns();
    [CompilerGeneratedAttribute]
public void set_DetailsColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_ConfigColumns();
    [CompilerGeneratedAttribute]
public void set_ConfigColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_SignaturesColumns();
    [CompilerGeneratedAttribute]
public void set_SignaturesColumns(IDictionary`2<string, JET_COLUMNID> value);
    public void InitColumDictionaries(JET_INSTANCE instance, string database);
}
public class Raven.Database.FileSystem.Storage.Esent.TransactionalStorage : CriticalFinalizerObject {
    private InMemoryRavenConfiguration configuration;
    private OrderedPartCollection`1<AbstractFileCodec> fileCodecs;
    private ThreadLocal`1<IStorageActionsAccessor> current;
    private ThreadLocal`1<object> disableBatchNesting;
    private string database;
    private ReaderWriterLockSlim disposerLock;
    private string path;
    private TableColumnsCache tableColumnsCache;
    private bool disposed;
    private ILog log;
    private JET_INSTANCE instance;
    private UuidGenerator uuidGenerator;
    private static object UpdateLocker;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<IFileSystemSchemaUpdate> <Updaters>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    private static object locker;
    [ImportManyAttribute]
public OrderedPartCollection`1<IFileSystemSchemaUpdate> Updaters { get; public set; }
    public string FriendlyName { get; }
    public TableColumnsCache TableColumnsCache { get; }
    public JET_INSTANCE Instance { get; }
    public Guid Id { get; private set; }
    public TransactionalStorage(InMemoryRavenConfiguration configuration);
    private static TransactionalStorage();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<IFileSystemSchemaUpdate> get_Updaters();
    [CompilerGeneratedAttribute]
public void set_Updaters(OrderedPartCollection`1<IFileSystemSchemaUpdate> value);
    public sealed virtual string get_FriendlyName();
    public TableColumnsCache get_TableColumnsCache();
    public JET_INSTANCE get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    public sealed virtual void Dispose();
    public sealed virtual void Initialize(UuidGenerator generator, OrderedPartCollection`1<AbstractFileCodec> codecs, Action`1<string> putResourceMarker);
    private void SetIdFromDb();
    private bool EnsureDatabaseIsCreatedAndAttachToDatabase();
    protected virtual override void Finalize();
    [CLSCompliantAttribute("False")]
public sealed virtual void Batch(Action`1<IStorageActionsAccessor> action);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
private void ExecuteBatch(Action`1<IStorageActionsAccessor> action);
    public static void Compact(InMemoryRavenConfiguration ravenConfiguration, JET_PFNSTATUS statusCallback);
    private static void RecoverFromFailedCompact(string file);
    public static void CreateInstance(JET_INSTANCE& compactInstance, string name);
    public static void DisableIndexChecking(JET_INSTANCE jetInstance);
    public sealed virtual Task StartBackupOperation(DocumentDatabase systemDatabase, RavenFileSystem filesystem, string backupDestinationDirectory, bool incrementalBackup, FileSystemDocument fileSystemDocument, ResourceBackupState state, CancellationToken token);
    public sealed virtual void Restore(FilesystemRestoreRequest restoreRequest, Action`1<string> output);
    private sealed virtual override void Raven.Database.FileSystem.Storage.ITransactionalStorage.Compact(InMemoryRavenConfiguration cfg, Action`1<string> output);
    public sealed virtual IDisposable DisableBatchNesting();
    private void Output(string message);
    public sealed virtual Guid ChangeId();
    [CompilerGeneratedAttribute]
private void <SetIdFromDb>b__31_0(Session session, JET_DBID dbid);
    [CompilerGeneratedAttribute]
private void <SetIdFromDb>b__31_1();
    [CompilerGeneratedAttribute]
private void <SetIdFromDb>b__31_2();
    [CompilerGeneratedAttribute]
private JET_err <EnsureDatabaseIsCreatedAndAttachToDatabase>b__32_0(JET_SESID sesid, JET_SNP snp, JET_SNT snt, object data);
    [CompilerGeneratedAttribute]
private void <DisableBatchNesting>b__43_0();
}
public class Raven.Database.FileSystem.Storage.Esent.TransactionalStorageConfigurator : StorageConfigurator {
    protected string BaseName { get; }
    protected string EventSource { get; }
    public TransactionalStorageConfigurator(InMemoryRavenConfiguration configuration);
    protected virtual void ConfigureInstanceInternal(int maxVerPages);
    protected virtual string get_BaseName();
    protected virtual string get_EventSource();
}
public class Raven.Database.FileSystem.Storage.Exceptions.FileExistsException : Exception {
    public FileExistsException(string message);
    public FileExistsException(string message, Exception inner);
    protected FileExistsException(SerializationInfo info, StreamingContext context);
}
public class Raven.Database.FileSystem.Storage.FileAndPagesInformation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <TotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UploadedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PageInformation> <Pages>k__BackingField;
    public string Name { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public int Start { get; public set; }
    public Nullable`1<long> TotalSize { get; public set; }
    public long UploadedSize { get; public set; }
    public List`1<PageInformation> Pages { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_TotalSize();
    [CompilerGeneratedAttribute]
public void set_TotalSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public long get_UploadedSize();
    [CompilerGeneratedAttribute]
public void set_UploadedSize(long value);
    [CompilerGeneratedAttribute]
public List`1<PageInformation> get_Pages();
    [CompilerGeneratedAttribute]
public void set_Pages(List`1<PageInformation> value);
}
public class Raven.Database.FileSystem.Storage.FileUpdateResult : object {
    public Etag Etag;
    public Etag PrevEtag;
}
public interface Raven.Database.FileSystem.Storage.IStorageActionsAccessor {
    public bool IsNested { get; public set; }
    [DebuggerHiddenAttribute]
[DebuggerNonUserCodeAttribute]
public abstract virtual void Commit();
    public abstract virtual void PulseTransaction();
    public abstract virtual int InsertPage(Byte[] buffer, int size);
    public abstract virtual FileUpdateResult PutFile(string filename, Nullable`1<long> totalSize, RavenJObject metadata, bool tombstone);
    public abstract virtual void AssociatePage(string filename, int pageId, int pagePositionInFile, int pageSize, bool incrementUsageCount);
    public abstract virtual int ReadPage(int pageId, Byte[] buffer);
    public abstract virtual FileHeader ReadFile(string filename);
    public abstract virtual FileAndPagesInformation GetFile(string filename, int start, int pagesToLoad);
    public abstract virtual IEnumerable`1<FileHeader> ReadFiles(int start, int size);
    public abstract virtual IEnumerable`1<FileHeader> GetFilesAfter(Etag etag, int take);
    public abstract virtual IEnumerable`1<FileHeader> GetFilesStartingWith(string namePrefix, int start, int take);
    public abstract virtual void Delete(string filename);
    public abstract virtual FileUpdateResult UpdateFileMetadata(string filename, RavenJObject metadata, Etag etag);
    public abstract virtual void CompleteFileUpload(string filename);
    public abstract virtual int GetFileCount();
    public abstract virtual void DecrementFileCount(string nameOfFileThatShouldNotBeCounted);
    public abstract virtual void RenameFile(string filename, string rename, bool commitPeriodically);
    public abstract virtual void CopyFile(string sourceFilename, string targetFilename, bool commitPeriodically);
    public abstract virtual FileUpdateResult TouchFile(string filename, Etag etag);
    public abstract virtual RavenJObject GetConfig(string name);
    public abstract virtual void SetConfig(string name, RavenJObject metadata);
    public abstract virtual void DeleteConfig(string name);
    public abstract virtual IEnumerable`1<SignatureLevels> GetSignatures(string name);
    public abstract virtual void ClearSignatures(string name);
    public abstract virtual long GetSignatureSize(int id, int level);
    public abstract virtual void GetSignatureStream(int id, int level, Action`1<Stream> action);
    public abstract virtual void AddSignature(string name, int level, Action`1<Stream> action);
    public abstract virtual IEnumerable`1<string> GetConfigNames(int start, int pageSize);
    public abstract virtual bool ConfigExists(string name);
    public abstract virtual IList`1<RavenJObject> GetConfigsStartWithPrefix(string prefix, int start, int take, Int32& total);
    public abstract virtual IList`1<string> GetConfigNamesStartingWithPrefix(string prefix, int start, int take, Int32& total);
    public abstract virtual Etag GetLastEtag();
    public abstract virtual bool get_IsNested();
    public abstract virtual void set_IsNested(bool value);
    public abstract virtual Dictionary`2<string, long> Esent_GetCurrentAutoIncrementValues();
}
public interface Raven.Database.FileSystem.Storage.ITransactionalStorage {
    public Guid Id { get; }
    public string FriendlyName { get; }
    public abstract virtual Guid get_Id();
    public abstract virtual void Initialize(UuidGenerator generator, OrderedPartCollection`1<AbstractFileCodec> fileCodecs, Action`1<string> putResourceMarker);
    [DebuggerHiddenAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public abstract virtual void Batch(Action`1<IStorageActionsAccessor> action);
    public abstract virtual string get_FriendlyName();
    public abstract virtual Task StartBackupOperation(DocumentDatabase systemDatabase, RavenFileSystem filesystem, string backupDestinationDirectory, bool incrementalBackup, FileSystemDocument fileSystemDocument, ResourceBackupState state, CancellationToken token);
    public abstract virtual void Restore(FilesystemRestoreRequest restoreRequest, Action`1<string> output);
    public abstract virtual void Compact(InMemoryRavenConfiguration configuration, Action`1<string> output);
    public abstract virtual IDisposable DisableBatchNesting();
    public abstract virtual Guid ChangeId();
}
public class Raven.Database.FileSystem.Storage.PageInformation : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PositionInFile>k__BackingField;
    public int Id { get; public set; }
    public int Size { get; public set; }
    public int PositionInFile { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public int get_PositionInFile();
    [CompilerGeneratedAttribute]
public void set_PositionInFile(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Database.FileSystem.Storage.RenameFileOperation : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Rename>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <MetadataAfterOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceExistingFileRemoval>k__BackingField;
    public string Name { get; private set; }
    public string Rename { get; private set; }
    public Etag Etag { get; private set; }
    public RavenJObject MetadataAfterOperation { get; private set; }
    public bool ForceExistingFileRemoval { get; public set; }
    public RenameFileOperation(string name, string rename, Etag currentEtag, RavenJObject metadataAfterOperation);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Rename();
    [CompilerGeneratedAttribute]
private void set_Rename(string value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
private void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public RavenJObject get_MetadataAfterOperation();
    [CompilerGeneratedAttribute]
private void set_MetadataAfterOperation(RavenJObject value);
    [CompilerGeneratedAttribute]
public bool get_ForceExistingFileRemoval();
    [CompilerGeneratedAttribute]
public void set_ForceExistingFileRemoval(bool value);
}
public class Raven.Database.FileSystem.Storage.SignatureReadOnlyStream : Stream {
    private ITransactionalStorage storage;
    private int id;
    private int level;
    private Nullable`1<long> length;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SignatureReadOnlyStream(ITransactionalStorage storage, int id, int level);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    [CompilerGeneratedAttribute]
public virtual long get_Position();
    [CompilerGeneratedAttribute]
public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
private void <get_Length>b__17_0(IStorageActionsAccessor accessor);
    [CompilerGeneratedAttribute]
private void <get_Length>b__17_1(Stream sigContent);
}
public class Raven.Database.FileSystem.Storage.StorageConstants : object {
    public static int MaxPageSize;
}
internal class Raven.Database.FileSystem.Storage.Voron.Backup.BackupOperation : BaseBackupOperation {
    private StorageEnvironment env;
    protected bool BackupAlreadyExists { get; }
    public BackupOperation(RavenFileSystem filesystem, string backupSourceDirectory, string backupDestinationDirectory, StorageEnvironment env, bool incrementalBackup, FileSystemDocument fileSystemDocument, ResourceBackupState state, CancellationToken token);
    protected virtual bool get_BackupAlreadyExists();
    protected virtual void ExecuteBackup(string backupPath, bool isIncrementalBackup, CancellationToken token);
    public sealed virtual void Dispose();
    protected virtual bool CanPerformIncrementalBackup();
    [CompilerGeneratedAttribute]
private void <ExecuteBackup>b__4_0(string s);
    [CompilerGeneratedAttribute]
private void <ExecuteBackup>b__4_1(string s);
}
internal class Raven.Database.FileSystem.Storage.Voron.Backup.RestoreOperation : BaseRestoreOperation {
    public RestoreOperation(FilesystemRestoreRequest restoreRequest, InMemoryRavenConfiguration configuration, Action`1<string> operationOutputCallback);
    protected virtual bool IsValidBackup(string backupFilename);
    public virtual void Execute();
}
internal class Raven.Database.FileSystem.Storage.Voron.IdGenerator : object {
    private ConcurrentDictionary`2<string, int> tableIds;
    public IdGenerator(TableStorage storage);
    public int GetNextIdForTable(Table table);
    private static int ReadLastIdFromTable(Table table, SnapshotReader snapshot);
}
internal class Raven.Database.FileSystem.Storage.Voron.Impl.Index : TableBase {
    public Index(string indexName, IBufferPool bufferPool);
}
internal class Raven.Database.FileSystem.Storage.Voron.Impl.Table : TableBase {
    private ConcurrentDictionary`2<string, Index> tableIndexes;
    public Table(string tableName, IBufferPool bufferPool, String[] indexNames);
    public Index GetIndex(string indexName);
    public string GetIndexKey(string indexName);
    [CompilerGeneratedAttribute]
private Index <GetIndex>b__2_0(string indexTreeName);
}
internal abstract class Raven.Database.FileSystem.Storage.Voron.Impl.TableBase : object {
    [CompilerGeneratedAttribute]
private IBufferPool <BufferPool>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    protected IBufferPool BufferPool { get; private set; }
    public string TableName { get; private set; }
    protected TableBase(string tableName, IBufferPool bufferPool);
    [CompilerGeneratedAttribute]
protected IBufferPool get_BufferPool();
    [CompilerGeneratedAttribute]
private void set_BufferPool(IBufferPool value);
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
private void set_TableName(string value);
    public virtual void Add(WriteBatch writeBatch, string key, string value, Nullable`1<ushort> expectedVersion);
    public virtual void Add(WriteBatch writeBatch, string key, Byte[] value, Nullable`1<ushort> expectedVersion);
    public virtual void Add(WriteBatch writeBatch, Slice key, Stream value, Nullable`1<ushort> expectedVersion, bool shouldIgnoreConcurrencyExceptions);
    public virtual void Add(WriteBatch writeBatch, Slice key, RavenJToken value, Nullable`1<ushort> expectedVersion);
    public virtual void Add(WriteBatch writeBatch, Slice key, string value, Nullable`1<ushort> expectedVersion);
    public virtual void Add(WriteBatch writeBatch, Slice key, Byte[] value, Nullable`1<ushort> expectedVersion);
    public virtual void Increment(WriteBatch writeBatch, Slice key, long delta, Nullable`1<ushort> expectedVersion);
    public virtual void MultiAdd(WriteBatch writeBatch, Slice key, Slice value, Nullable`1<ushort> expectedVersion);
    public virtual ReadResult Read(SnapshotReader snapshot, Slice key, WriteBatch writeBatch);
    public virtual IIterator MultiRead(SnapshotReader snapshot, Slice key);
    public virtual IIterator Iterate(SnapshotReader snapshot, WriteBatch writeBatch);
    public bool Contains(SnapshotReader snapshot, Slice key, WriteBatch writeBatch);
    public bool Contains(SnapshotReader snapshot, Slice key, WriteBatch writeBatch, Nullable`1& version);
    public int GetDataSize(SnapshotReader snapshot, Slice key);
    public virtual void Delete(WriteBatch writeBatch, string key, Nullable`1<ushort> expectedVersion);
    public virtual void Delete(WriteBatch writeBatch, Slice key, Nullable`1<ushort> expectedVersion);
    public virtual void MultiDelete(WriteBatch writeBatch, Slice key, Slice value, Nullable`1<ushort> expectedVersion);
    public virtual Nullable`1<ushort> ReadVersion(SnapshotReader snapshot, Slice key, WriteBatch writeBatch);
    public Dictionary`2<string, string> Dump(SnapshotReader snapshot);
}
public class Raven.Database.FileSystem.Storage.Voron.Impl.Tables : object {
}
internal class Raven.Database.FileSystem.Storage.Voron.Impl.TableStorage : object {
    private StorageEnvironmentOptions _options;
    private IBufferPool bufferPool;
    private StorageEnvironment env;
    [CompilerGeneratedAttribute]
private Table <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Signatures>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Usage>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Pages>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Table Files { get; private set; }
    public Table Signatures { get; private set; }
    public Table Config { get; private set; }
    public Table Usage { get; private set; }
    public Table Pages { get; private set; }
    public Table Details { get; private set; }
    public StorageEnvironment Environment { get; }
    public string SchemaVersion { get; private set; }
    public Guid Id { get; private set; }
    public TableStorage(StorageEnvironmentOptions options, IBufferPool bufferPool);
    internal Dictionary`2<string, object> GenerateReportOnStorage();
    public SnapshotReader CreateSnapshot();
    [CompilerGeneratedAttribute]
public Table get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(Table value);
    [CompilerGeneratedAttribute]
public Table get_Signatures();
    [CompilerGeneratedAttribute]
private void set_Signatures(Table value);
    [CompilerGeneratedAttribute]
public Table get_Config();
    [CompilerGeneratedAttribute]
private void set_Config(Table value);
    [CompilerGeneratedAttribute]
public Table get_Usage();
    [CompilerGeneratedAttribute]
private void set_Usage(Table value);
    [CompilerGeneratedAttribute]
public Table get_Pages();
    [CompilerGeneratedAttribute]
private void set_Pages(Table value);
    [CompilerGeneratedAttribute]
public Table get_Details();
    [CompilerGeneratedAttribute]
private void set_Details(Table value);
    public StorageEnvironment get_Environment();
    public void Write(WriteBatch writeBatch);
    public long GetEntriesCount(TableBase table);
    public void RenderAndShow(TableBase table, int showEntries);
    public void RenderAndShow(Transaction tx, TableBase table, int showEntries);
    public sealed virtual void Dispose();
    private void Initialize();
    public void SetDatabaseIdAndSchemaVersion(Guid id, string schemaVersion);
    [CompilerGeneratedAttribute]
public string get_SchemaVersion();
    [CompilerGeneratedAttribute]
private void set_SchemaVersion(string value);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
}
[InheritedExportAttribute]
internal interface Raven.Database.FileSystem.Storage.Voron.Schema.ISchemaUpdate {
    public string FromSchemaVersion { get; }
    public string ToSchemaVersion { get; }
    public abstract virtual string get_FromSchemaVersion();
    public abstract virtual string get_ToSchemaVersion();
    public abstract virtual void Update(TableStorage tableStorage, Action`1<string> output);
    public abstract virtual void UpdateSchemaVersion(TableStorage tableStorage, Action`1<string> output);
}
internal class Raven.Database.FileSystem.Storage.Voron.Schema.SchemaCreator : object {
    private TableStorage storage;
    private Action`1<string> output;
    private ILog log;
    public static string SchemaVersion;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<ISchemaUpdate> <Updaters>k__BackingField;
    private static object UpdateLocker;
    [ImportManyAttribute]
public OrderedPartCollection`1<ISchemaUpdate> Updaters { get; public set; }
    public SchemaCreator(InMemoryRavenConfiguration configuration, TableStorage storage, Action`1<string> output, ILog log);
    private static SchemaCreator();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<ISchemaUpdate> get_Updaters();
    [CompilerGeneratedAttribute]
public void set_Updaters(OrderedPartCollection`1<ISchemaUpdate> value);
    public void CreateSchema();
    public void SetupDatabaseIdAndSchemaVersion();
    public void UpdateSchemaIfNecessary();
    private static void CreatePagesSchema(Transaction tx, TableStorage storage);
    private static void CreateUsageSchema(Transaction tx, TableStorage storage);
    private static void CreateConfigSchema(Transaction tx, TableStorage storage);
    private static void CreatSignaturesSchema(Transaction tx, TableStorage storage);
    private static void CreateFilesSchema(Transaction tx, TableStorage storage);
    private static void CreateDetailsSchema(Transaction tx, TableStorage storage);
    [CompilerGeneratedAttribute]
private void <UpdateSchemaIfNecessary>b__12_0();
    [CompilerGeneratedAttribute]
private void <UpdateSchemaIfNecessary>b__12_1();
    [CompilerGeneratedAttribute]
private bool <UpdateSchemaIfNecessary>b__12_2(Lazy`2<ISchemaUpdate, IPartMetadata> update);
}
internal class Raven.Database.FileSystem.Storage.Voron.Schema.Updates.From10To11 : SchemaUpdateBase {
    public string FromSchemaVersion { get; }
    public string ToSchemaVersion { get; }
    public virtual string get_FromSchemaVersion();
    public virtual string get_ToSchemaVersion();
    public virtual void Update(TableStorage tableStorage, Action`1<string> output);
    private static void Migrate(StorageEnvironment env, string tableName, Action`1<string> output, Action`2<Slice, RavenJObject> modifyTableRecord, Func`3<Slice, ValueReader, Tuple`2<Slice, Stream>> modifyIndexRecord);
}
internal abstract class Raven.Database.FileSystem.Storage.Voron.Schema.Updates.SchemaUpdateBase : object {
    public string FromSchemaVersion { get; }
    public string ToSchemaVersion { get; }
    public abstract virtual string get_FromSchemaVersion();
    public abstract virtual string get_ToSchemaVersion();
    public abstract virtual void Update(TableStorage tableStorage, Action`1<string> output);
    public sealed virtual void UpdateSchemaVersion(TableStorage tableStorage, Action`1<string> output);
}
internal class Raven.Database.FileSystem.Storage.Voron.StorageActionsAccessor : StorageActionsBase {
    private TableStorage storage;
    private Reference`1<WriteBatch> writeBatch;
    private UuidGenerator uuidGenerator;
    private OrderedPartCollection`1<AbstractFileCodec> fileCodecs;
    [CompilerGeneratedAttribute]
private bool <IsNested>k__BackingField;
    public bool IsNested { get; public set; }
    public StorageActionsAccessor(TableStorage storage, Reference`1<WriteBatch> writeBatch, Reference`1<SnapshotReader> snapshot, IdGenerator generator, IBufferPool bufferPool, UuidGenerator uuidGenerator, OrderedPartCollection`1<AbstractFileCodec> fileCodecs);
    public sealed virtual void Dispose();
    public sealed virtual void Commit();
    public sealed virtual void PulseTransaction();
    public sealed virtual int InsertPage(Byte[] buffer, int size);
    public sealed virtual FileUpdateResult PutFile(string filename, Nullable`1<long> totalSize, RavenJObject metadata, bool tombstone);
    public sealed virtual void AssociatePage(string filename, int pageId, int pagePositionInFile, int pageSize, bool incrementUsageCount);
    private void IncrementUsageCount(int pageId);
    public sealed virtual int ReadPage(int pageId, Byte[] buffer);
    public sealed virtual FileHeader ReadFile(string filename);
    public sealed virtual FileAndPagesInformation GetFile(string filename, int start, int pagesToLoad);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Voron.StorageActionsAccessor/<ReadFiles>d__15")]
public sealed virtual IEnumerable`1<FileHeader> ReadFiles(int start, int size);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Voron.StorageActionsAccessor/<GetFilesAfter>d__16")]
public sealed virtual IEnumerable`1<FileHeader> GetFilesAfter(Etag etag, int take);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Voron.StorageActionsAccessor/<GetFilesStartingWith>d__17")]
public sealed virtual IEnumerable`1<FileHeader> GetFilesStartingWith(string namePrefix, int start, int take);
    public sealed virtual void Delete(string filename);
    public sealed virtual FileUpdateResult UpdateFileMetadata(string filename, RavenJObject metadata, Etag etag);
    public sealed virtual FileUpdateResult TouchFile(string filename, Etag etag);
    public sealed virtual void CompleteFileUpload(string filename);
    public sealed virtual Etag GetLastEtag();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsNested();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsNested(bool value);
    public sealed virtual int GetFileCount();
    public sealed virtual void DecrementFileCount(string nameOfFileThatShouldNotBeCounted);
    public sealed virtual void RenameFile(string filename, string rename, bool commitPeriodically);
    private void RenameUsage(string fileName, string rename, bool commitPeriodically);
    public sealed virtual void CopyFile(string sourceFilename, string targetFilename, bool commitPeriodically);
    private void CopyUsage(string sourceFilename, string targetFilename, bool commitPeriodically);
    public sealed virtual RavenJObject GetConfig(string name);
    public sealed virtual void SetConfig(string name, RavenJObject metadata);
    public sealed virtual void DeleteConfig(string name);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Voron.StorageActionsAccessor/<GetSignatures>d__36")]
public sealed virtual IEnumerable`1<SignatureLevels> GetSignatures(string name);
    public sealed virtual void ClearSignatures(string name);
    public sealed virtual long GetSignatureSize(int id, int level);
    public sealed virtual void GetSignatureStream(int id, int level, Action`1<Stream> action);
    public sealed virtual void AddSignature(string name, int level, Action`1<Stream> action);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Voron.StorageActionsAccessor/<GetConfigNames>d__41")]
public sealed virtual IEnumerable`1<string> GetConfigNames(int start, int pageSize);
    public sealed virtual bool ConfigExists(string name);
    public sealed virtual IList`1<RavenJObject> GetConfigsStartWithPrefix(string prefix, int start, int take, Int32& total);
    public sealed virtual IList`1<string> GetConfigNamesStartingWithPrefix(string prefix, int start, int take, Int32& total);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Storage.Voron.StorageActionsAccessor/<GetConfigsWithPrefix>d__45")]
private IEnumerable`1<RavenJObject> GetConfigsWithPrefix(string prefix, int start, int take, Reference`1<int> totalCount);
    private void RemoveSignature(string id, string name);
    private void DeleteFile(string fileName);
    private void DeleteUsage(string fileName);
    private void DeletePage(int pageId);
    private RavenJObject LoadFileByKey(string key, UInt16& version);
    private RavenJObject LoadSignatureByKey(string key);
    private static SignatureLevels ConvertToSignature(RavenJObject signature);
    private static FileHeader ConvertToFile(RavenJObject file);
    private Etag EnsureDocumentEtagMatch(string key, Etag etag, RavenJObject file);
    public sealed virtual Dictionary`2<string, long> Esent_GetCurrentAutoIncrementValues();
}
internal abstract class Raven.Database.FileSystem.Storage.Voron.StorageActionsBase : object {
    private Reference`1<SnapshotReader> snapshotReference;
    private IBufferPool bufferPool;
    [CompilerGeneratedAttribute]
private IdGenerator <IdGenerator>k__BackingField;
    protected SnapshotReader Snapshot { get; }
    protected IdGenerator IdGenerator { get; private set; }
    protected StorageActionsBase(Reference`1<SnapshotReader> snapshotReference, IdGenerator idGenerator, IBufferPool bufferPool);
    protected SnapshotReader get_Snapshot();
    [CompilerGeneratedAttribute]
protected IdGenerator get_IdGenerator();
    [CompilerGeneratedAttribute]
private void set_IdGenerator(IdGenerator value);
    protected string ConvertToKey(HashKey hashKey);
    protected string CreateKey(Object[] values);
    protected RavenJObject LoadJson(Table table, Slice key, WriteBatch writeBatch, UInt16& version);
    protected BufferPoolMemoryStream CreateStream();
    private static string ConvertValueToString(object value);
}
public class Raven.Database.FileSystem.Storage.Voron.TransactionalStorage : object {
    private InMemoryRavenConfiguration configuration;
    private static ILog Log;
    private string path;
    private NameValueCollection settings;
    private ThreadLocal`1<IStorageActionsAccessor> current;
    private ThreadLocal`1<object> disableBatchNesting;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed;
    private ReaderWriterLockSlim disposerLock;
    private BufferPool bufferPool;
    private TableStorage tableStorage;
    private IdGenerator idGenerator;
    private OrderedPartCollection`1<AbstractFileCodec> fileCodecs;
    private UuidGenerator uuidGenerator;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public string FriendlyName { get; }
    public Guid Id { get; private set; }
    public TransactionalStorage(InMemoryRavenConfiguration configuration);
    private static TransactionalStorage();
    public sealed virtual string get_FriendlyName();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    private static StorageEnvironmentOptions CreateStorageOptionsFromConfiguration(string path, NameValueCollection settings);
    public sealed virtual void Initialize(UuidGenerator generator, OrderedPartCollection`1<AbstractFileCodec> codecs, Action`1<string> putResourceMarker);
    private void SetupDatabaseId();
    public sealed virtual IDisposable DisableBatchNesting();
    public sealed virtual void Batch(Action`1<IStorageActionsAccessor> action);
    private void ExecuteBatch(Action`1<IStorageActionsAccessor> action);
    public sealed virtual Task StartBackupOperation(DocumentDatabase systemDatabase, RavenFileSystem filesystem, string backupDestinationDirectory, bool incrementalBackup, FileSystemDocument fileSystemDocument, ResourceBackupState state, CancellationToken token);
    public sealed virtual void Restore(FilesystemRestoreRequest restoreRequest, Action`1<string> output);
    public sealed virtual void Compact(InMemoryRavenConfiguration ravenConfiguration, Action`1<string> output);
    private static void RecoverFromFailedCompact(string sourcePath);
    private void Output(string message);
    public sealed virtual Guid ChangeId();
    [CompilerGeneratedAttribute]
private void <DisableBatchNesting>b__24_0();
}
public class Raven.Database.FileSystem.Synchronization.ConflictResolvedInFavourOfCurrentVersionException : Exception {
    public ConflictResolvedInFavourOfCurrentVersionException(string message);
    public ConflictResolvedInFavourOfCurrentVersionException(string message, Exception inner);
    protected ConflictResolvedInFavourOfCurrentVersionException(SerializationInfo info, StreamingContext context);
}
public class Raven.Database.FileSystem.Synchronization.Conflictuality.ConflictArtifactManager : object {
    private IndexStorage index;
    private ITransactionalStorage storage;
    private RavenFileSystem fs;
    public ConflictArtifactManager(ITransactionalStorage storage, IndexStorage index, RavenFileSystem fs);
    public void Create(string fileName, ConflictItem conflict);
    public void Delete(string fileName, IStorageActionsAccessor actionsAccessor);
}
public class Raven.Database.FileSystem.Synchronization.Conflictuality.ConflictDetector : object {
    public ConflictItem Check(string fileName, RavenJObject localMetadata, RavenJObject remoteMetadata, string remoteServerUrl);
    public ConflictItem CheckOnSource(string fileName, RavenJObject localMetadata, RavenJObject remoteMetadata, string localServerUrl);
    private static List`1<HistoryItem> TransformToFullConflictHistory(RavenJObject metadata);
}
public class Raven.Database.FileSystem.Synchronization.Conflictuality.ConflictResolution : object {
    [CompilerGeneratedAttribute]
private ConflictResolutionStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteServerId>k__BackingField;
    public ConflictResolutionStrategy Strategy { get; public set; }
    public long Version { get; public set; }
    public string RemoteServerId { get; public set; }
    [CompilerGeneratedAttribute]
public ConflictResolutionStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(ConflictResolutionStrategy value);
    [CompilerGeneratedAttribute]
public long get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(long value);
    [CompilerGeneratedAttribute]
public string get_RemoteServerId();
    [CompilerGeneratedAttribute]
public void set_RemoteServerId(string value);
}
public class Raven.Database.FileSystem.Synchronization.Conflictuality.ConflictResolver : object {
    private static ILog Log;
    private CompositionContainer container;
    private ITransactionalStorage storage;
    public IEnumerable`1<AbstractFileSynchronizationConflictResolver> Resolvers { get; }
    public ConflictResolver(ITransactionalStorage storage, CompositionContainer container);
    private static ConflictResolver();
    public IEnumerable`1<AbstractFileSynchronizationConflictResolver> get_Resolvers();
    public bool TryResolveConflict(string fileName, ConflictItem conflict, RavenJObject localMetadata, RavenJObject remoteMetadata, ConflictResolutionStrategy& strategy);
    public bool CheckIfResolvedByRemoteStrategy(RavenJObject destinationMetadata, ConflictItem conflict);
    public void ApplyCurrentStrategy(string fileName, ConflictItem conflict, RavenJObject localMetadata);
    public void ApplyRemoteStrategy(string fileName, ConflictItem conflict, RavenJObject localMetadata);
}
[InheritedExportAttribute]
public abstract class Raven.Database.FileSystem.Synchronization.Conflictuality.Resolvers.AbstractFileSynchronizationConflictResolver : object {
    public abstract virtual bool TryResolve(string fileName, RavenJObject localMedatada, RavenJObject remoteMetadata, ConflictResolutionStrategy& resolutionStrategy);
}
[PartNotDiscoverableAttribute]
public class Raven.Database.FileSystem.Synchronization.Conflictuality.Resolvers.LatestFileSynchronizationConflictResolver : AbstractFileSynchronizationConflictResolver {
    public static LatestFileSynchronizationConflictResolver Instance;
    private static LatestFileSynchronizationConflictResolver();
    public virtual bool TryResolve(string fileName, RavenJObject localMedatada, RavenJObject remoteMetadata, ConflictResolutionStrategy& resolutionStrategy);
    private static DateTimeOffset GetLastModified(RavenJObject metadata);
}
[PartNotDiscoverableAttribute]
public class Raven.Database.FileSystem.Synchronization.Conflictuality.Resolvers.LocalFileSynchronizationConflictResolver : AbstractFileSynchronizationConflictResolver {
    public static LocalFileSynchronizationConflictResolver Instance;
    private static LocalFileSynchronizationConflictResolver();
    public virtual bool TryResolve(string fileName, RavenJObject localMedatada, RavenJObject remoteMetadata, ConflictResolutionStrategy& resolutionStrategy);
}
[PartNotDiscoverableAttribute]
public class Raven.Database.FileSystem.Synchronization.Conflictuality.Resolvers.RemoveFileSynchronizationConflictResolver : AbstractFileSynchronizationConflictResolver {
    public static RemoveFileSynchronizationConflictResolver Instance;
    private static RemoveFileSynchronizationConflictResolver();
    public virtual bool TryResolve(string fileName, RavenJObject localMedatada, RavenJObject remoteMetadata, ConflictResolutionStrategy& resolutionStrategy);
}
public class Raven.Database.FileSystem.Synchronization.ContentUpdateWorkItem : SynchronizationWorkItem {
    private ILog log;
    private SigGenerator sigGenerator;
    private InMemoryRavenConfiguration configuration;
    private DataInfo fileDataInfo;
    private SynchronizationMultipartRequest multipartRequest;
    public SynchronizationType SynchronizationType { get; }
    private DataInfo FileDataInfo { get; }
    public ContentUpdateWorkItem(string file, string sourceServerUrl, ITransactionalStorage storage, SigGenerator sigGenerator, InMemoryRavenConfiguration configuration);
    public virtual SynchronizationType get_SynchronizationType();
    private DataInfo get_FileDataInfo();
    public virtual void Cancel();
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.ContentUpdateWorkItem/<PerformAsync>d__11")]
public virtual Task`1<SynchronizationReport> PerformAsync(ISynchronizationServerClient synchronizationServerClient);
    private bool IsRemoteRdcCompatible(RdcStats destinationServerRdcStats);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.ContentUpdateWorkItem/<SynchronizeTo>d__13")]
private Task`1<SynchronizationReport> SynchronizeTo(ISynchronizationServerClient synchronizationServerClient, ISignatureRepository localSignatureRepository, ISignatureRepository remoteSignatureRepository, SignatureManifest sourceSignatureManifest, SignatureManifest destinationSignatureManifest);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.ContentUpdateWorkItem/<UploadToAsync>d__14")]
public Task`1<SynchronizationReport> UploadToAsync(ISynchronizationServerClient synchronizationServerClient);
    private Task`1<SynchronizationReport> PushByUsingMultipartRequest(ISynchronizationServerClient synchronizationServerClient, Stream sourceFileStream, IList`1<RdcNeed> needList);
    private DataInfo GetLocalFileDataInfo(string fileName);
    public virtual bool Equals(object obj);
    public bool Equals(ContentUpdateWorkItem other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Raven.Database.FileSystem.Synchronization.DataInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public string Name { get; public set; }
    public DateTime LastModified { get; public set; }
    public long Length { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(DateTime value);
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(long value);
}
public class Raven.Database.FileSystem.Synchronization.DeleteWorkItem : SynchronizationWorkItem {
    public SynchronizationType SynchronizationType { get; }
    public DeleteWorkItem(string fileName, string sourceServerUrl, ITransactionalStorage storage);
    public virtual SynchronizationType get_SynchronizationType();
    public virtual Task`1<SynchronizationReport> PerformAsync(ISynchronizationServerClient synchronizationServerClient);
    public virtual bool Equals(object obj);
    public bool Equals(DeleteWorkItem other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Raven.Database.FileSystem.Synchronization.FileHeaderNameEqualityComparer : object {
    public static FileHeaderNameEqualityComparer Instance;
    private static FileHeaderNameEqualityComparer();
    public sealed virtual bool Equals(FileHeader x, FileHeader y);
    public sealed virtual int GetHashCode(FileHeader header);
}
public class Raven.Database.FileSystem.Synchronization.FileLockManager : object {
    private ILog log;
    public void LockByCreatingSyncConfiguration(string fileName, FileSystemInfo sourceFileSystem, IStorageActionsAccessor accessor);
    public void UnlockByDeletingSyncConfiguration(string fileName, IStorageActionsAccessor accessor);
    public bool TimeoutExceeded(string fileName, IStorageActionsAccessor accessor);
    public bool TimeoutExceeded(string fileName, ITransactionalStorage storage);
}
public class Raven.Database.FileSystem.Synchronization.MetadataUpdateWorkItem : SynchronizationWorkItem {
    private RavenJObject destinationMetadata;
    private ILog log;
    public SynchronizationType SynchronizationType { get; }
    public MetadataUpdateWorkItem(string fileName, string sourceServerUrl, ITransactionalStorage storage);
    public MetadataUpdateWorkItem(string fileName, string sourceServerUrl, RavenJObject destinationMetadata, ITransactionalStorage storage);
    public virtual SynchronizationType get_SynchronizationType();
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.MetadataUpdateWorkItem/<PerformAsync>d__6")]
public virtual Task`1<SynchronizationReport> PerformAsync(ISynchronizationServerClient synchronizationServerClient);
    public virtual bool Equals(object obj);
    public bool Equals(MetadataUpdateWorkItem other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Raven.Database.FileSystem.Synchronization.Multipart.MultipartSyncStreamProvider : MultipartStreamProvider {
    private StorageStream localFile;
    private SynchronizingFileStream synchronizingFile;
    [CompilerGeneratedAttribute]
private long <BytesTransfered>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesCopied>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfFileParts>k__BackingField;
    public long BytesTransfered { get; private set; }
    public long BytesCopied { get; private set; }
    public long NumberOfFileParts { get; private set; }
    public MultipartSyncStreamProvider(SynchronizingFileStream synchronizingFile, StorageStream localFile);
    [CompilerGeneratedAttribute]
public long get_BytesTransfered();
    [CompilerGeneratedAttribute]
private void set_BytesTransfered(long value);
    [CompilerGeneratedAttribute]
public long get_BytesCopied();
    [CompilerGeneratedAttribute]
private void set_BytesCopied(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfFileParts();
    [CompilerGeneratedAttribute]
private void set_NumberOfFileParts(long value);
    public virtual Stream GetStream(HttpContent parent, HttpContentHeaders headers);
}
public class Raven.Database.FileSystem.Synchronization.Multipart.SeedFilePart : HttpContent {
    public string SyncingNeedType { get; }
    public SeedFilePart(long from, long to);
    public string get_SyncingNeedType();
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
}
public class Raven.Database.FileSystem.Synchronization.Multipart.SourceFilePart : StreamContent {
    private NarrowedStream sourceChunk;
    public string SyncingNeedType { get; }
    public SourceFilePart(NarrowedStream sourceChunk);
    public string get_SyncingNeedType();
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
}
internal class Raven.Database.FileSystem.Synchronization.Multipart.SynchronizationMultipartRequest : object {
    private ISynchronizationServerClient synchronizationServerClient;
    private string fileName;
    private IList`1<RdcNeed> needList;
    private SynchronizationType synchronizationType;
    private FileSystemInfo fileSystemInfo;
    private RavenJObject sourceMetadata;
    private Stream sourceStream;
    private string syncingBoundary;
    [CompilerGeneratedAttribute]
private ProfilingInformation <ProfilingInformation>k__BackingField;
    public ProfilingInformation ProfilingInformation { get; private set; }
    public SynchronizationMultipartRequest(ISynchronizationServerClient synchronizationServerClient, FileSystemInfo fileSystemInfo, string fileName, RavenJObject sourceMetadata, Stream sourceStream, IList`1<RdcNeed> needList, SynchronizationType synchronizationType);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.Multipart.SynchronizationMultipartRequest/<PushChangesAsync>d__9")]
public Task`1<SynchronizationReport> PushChangesAsync(CancellationToken token);
    internal MultipartContent PrepareMultipartContent(CancellationToken token);
    [CompilerGeneratedAttribute]
public sealed virtual ProfilingInformation get_ProfilingInformation();
    [CompilerGeneratedAttribute]
private void set_ProfilingInformation(ProfilingInformation value);
}
public enum Raven.Database.FileSystem.Synchronization.NoSyncReason : Enum {
    public int value__;
    public static NoSyncReason Unknown;
    [DescriptionAttribute("There were the same content and metadata")]
public static NoSyncReason SameContentAndMetadata;
    [DescriptionAttribute("Destination server had this file in the past")]
public static NoSyncReason ContainedInDestinationHistory;
    [DescriptionAttribute("File was conflicted on our side")]
public static NoSyncReason SourceFileConflicted;
    [DescriptionAttribute("File was conflicted on a destination side and had no resolution")]
public static NoSyncReason DestinationFileConflicted;
    [DescriptionAttribute("File did not exist locally")]
public static NoSyncReason SourceFileNotExist;
    [DescriptionAttribute("No need to delete a file on a destination side. It didn't exist there")]
public static NoSyncReason NoNeedToDeleteNonExistigFile;
    [DescriptionAttribute("File does not exist")]
public static NoSyncReason FileNotFound;
}
public interface Raven.Database.FileSystem.Synchronization.Rdc.IPartialDataAccess {
    public abstract virtual Task CopyToAsync(Stream target, long from, long length);
}
public class Raven.Database.FileSystem.Synchronization.Rdc.LocalRdcManager : object {
    private static ConcurrentDictionary`2<string, ReaderWriterLockSlim> signatureBuidInProgress;
    private SigGenerator _sigGenerator;
    private ISignatureRepository _signatureRepository;
    private ITransactionalStorage _transactionalStorage;
    public LocalRdcManager(ISignatureRepository signatureRepository, ITransactionalStorage transactionalStorage, SigGenerator sigGenerator);
    private static LocalRdcManager();
    public Task`1<SignatureManifest> GetSignatureManifestAsync(DataInfo dataInfo);
    public Stream GetSignatureContentForReading(string sigName);
    private IEnumerable`1<SignatureInfo> PrepareSignatures(string filename);
    private static IList`1<Signature> SignatureInfosToSignatures(IEnumerable`1<SignatureInfo> signatureInfos);
}
internal class Raven.Database.FileSystem.Synchronization.Rdc.NeedListParser : object {
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.Rdc.NeedListParser/<ParseAsync>d__0")]
public static Task ParseAsync(IPartialDataAccess source, IPartialDataAccess seed, Stream output, IEnumerable`1<RdcNeed> needList, CancellationToken token);
}
public class Raven.Database.FileSystem.Synchronization.Rdc.RemoteRdcManager : object {
    private ISynchronizationServerClient synchronizationServerClient;
    private ISignatureRepository localSignatureRepository;
    private ISignatureRepository remoteCacheSignatureRepository;
    public RemoteRdcManager(ISynchronizationServerClient synchronizationServerClient, ISignatureRepository localSignatureRepository, ISignatureRepository remoteCacheSignatureRepository);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.Rdc.RemoteRdcManager/<SynchronizeSignaturesAsync>d__4")]
public Task`1<SignatureManifest> SynchronizeSignaturesAsync(DataInfo dataInfo, CancellationToken token);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.Rdc.RemoteRdcManager/<SynchronizePairAsync>d__5")]
private Task SynchronizePairAsync(IList`1<LocalRemotePair> sigPairs, CancellationToken token);
    private IList`1<LocalRemotePair> PrepareSigPairs(SignatureManifest signatureManifest);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.Rdc.RemoteRdcManager/<SynchronizeAsync>d__7")]
private Task SynchronizeAsync(string localSigName, string localSigSigName, string remoteSigName, string remoteSigSigName, CancellationToken token);
}
public class Raven.Database.FileSystem.Synchronization.Rdc.RemoteSignaturePartialAccess : object {
    private string _fileName;
    private ISynchronizationServerClient synchronizationServerClient;
    public RemoteSignaturePartialAccess(ISynchronizationServerClient synchronizationServerClient, string fileName);
    public sealed virtual Task CopyToAsync(Stream target, long from, long length);
}
public class Raven.Database.FileSystem.Synchronization.Rdc.SignatureLevels : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    public int Id { get; public set; }
    public int Level { get; public set; }
    public DateTime CreatedAt { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(int value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
}
public class Raven.Database.FileSystem.Synchronization.Rdc.SignaturePartialAccess : object {
    private string _sigName;
    private ISignatureRepository _signatureRepository;
    public SignaturePartialAccess(string sigName, ISignatureRepository signatureRepository);
    public sealed virtual Task CopyToAsync(Stream target, long from, long length);
}
public interface Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.ISignatureRepository {
    public abstract virtual Stream GetContentForReading(string sigName);
    public abstract virtual Stream CreateContent(string sigName);
    public abstract virtual void Flush(IEnumerable`1<SignatureInfo> signatureInfos);
    public abstract virtual IEnumerable`1<SignatureInfo> GetByFileName();
    public abstract virtual Nullable`1<DateTime> GetLastUpdate();
}
internal class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.NeedListGenerator : CriticalFinalizerObject {
    private static int ComparatorBufferSize;
    private static int InputBufferSize;
    private ReaderWriterLockSlim _disposerLock;
    private IRdcLibrary _rdcLibrary;
    private ISignatureRepository _seedSignatureRepository;
    private ISignatureRepository _sourceSignatureRepository;
    private bool _disposed;
    public NeedListGenerator(ISignatureRepository seedSignatureRepository, ISignatureRepository sourceSignatureRepository);
    public sealed virtual void Dispose();
    public IList`1<RdcNeed> CreateNeedsList(SignatureInfo seedSignature, SignatureInfo sourceSignature);
    public IList`1<RdcNeed> CreateNeedsList(SignatureInfo seedSignature, SignatureInfo sourceSignature, CancellationToken token);
    private static RdcNeed[] GetRdcNeedList(RdcNeedPointer pointer);
    protected virtual override void Finalize();
    private void DisposeInternal();
}
public class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.RdcException : Exception {
    public RdcException(string message);
    public RdcException(string message, Exception inner);
    public RdcException(string format, Object[] args);
    public RdcException(string message, int hr, Nullable`1<RdcError> rdcError);
    protected RdcException(SerializationInfo info, StreamingContext context);
}
[ClassInterfaceAttribute("0")]
[GuidAttribute("96236A89-9DBC-11DA-9E3F-0011114AE311")]
[ComVisibleAttribute("True")]
internal class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.RdcFileReader : object {
    private Stream _stream;
    public RdcFileReader(Stream stream);
    public sealed virtual void GetFileSize(UInt64& fileSize);
    public sealed virtual void Read(ulong offsetFileStart, UInt32 bytesToRead, UInt32& bytesRead, IntPtr buffer, Boolean& eof);
    public sealed virtual void GetFilePosition(UInt64& offsetFromStart);
}
internal class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.RdcNeed : ValueType {
    public RdcNeedType BlockType;
    public ulong FileOffset;
    public ulong BlockLength;
}
public enum Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.RdcNeedType : Enum {
    public int value__;
    public static RdcNeedType Source;
    public static RdcNeedType Target;
    public static RdcNeedType Seed;
    public static RdcNeedType SeedMax;
}
public class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.RdcVersion : object {
    [CompilerGeneratedAttribute]
private int <CurrentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumCompatibleAppVersion>k__BackingField;
    public int CurrentVersion { get; public set; }
    public int MinimumCompatibleAppVersion { get; public set; }
    [CompilerGeneratedAttribute]
public int get_CurrentVersion();
    [CompilerGeneratedAttribute]
public void set_CurrentVersion(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumCompatibleAppVersion();
    [CompilerGeneratedAttribute]
public void set_MinimumCompatibleAppVersion(int value);
}
public class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.RdcVersionChecker : CriticalFinalizerObject {
    private static ILog log;
    private ReaderWriterLockSlim _disposerLock;
    private IRdcLibrary _rdcLibrary;
    private bool _disposed;
    private static RdcVersionChecker();
    public sealed virtual void Dispose();
    public RdcVersion GetRdcVersion();
    private void DisposeInternal();
    protected virtual override void Finalize();
}
public class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.SigGenerator : CriticalFinalizerObject {
    private static UInt32 OutputBufferSize;
    private static int InputBufferSize;
    private static ILog log;
    private ReaderWriterLockSlim _disposerLock;
    private IRdcLibrary _rdcLibrary;
    private bool _disposed;
    private int _recursionDepth;
    private static SigGenerator();
    public sealed virtual void Dispose();
    public IList`1<SignatureInfo> GenerateSignatures(Stream source, string fileName, ISignatureRepository signatureRepository);
    private IList`1<SignatureInfo> Process(Stream source, IRdcGenerator rdcGenerator, string fileName, ISignatureRepository signatureRepository);
    private static RdcBufferPointer GetInputBuffer(Stream source, int inputBufferSize, RdcBufferPointer inputBuffer, Boolean& eof);
    private static void RdcBufferTranslate(RdcBufferPointer[] source, IntPtr[] dest);
    private static void RdcBufferTranslate(IntPtr[] source, RdcBufferPointer[] dest);
    private static IntPtr[] PrepareOutputPointers(RdcBufferPointer[] rdcBufferPointers);
    private RdcBufferPointer[] PrepareRdcBufferPointers();
    private IntPtr[] PrepareOutputBuffers();
    private IRdcGenerator InitializeRdcGenerator();
    public int EvaluateRecursionDepth(Stream source);
    private IRdcGeneratorParameters[] InitializeGeneratorParameterses();
    protected virtual override void Finalize();
    private void DisposeInternal();
}
public class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.SignatureInfo : object {
    private static Regex SigFileNamePattern;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public string FileName { get; private set; }
    public int Level { get; private set; }
    public string Name { get; }
    public long Length { get; public set; }
    public SignatureInfo(int level, string fileName);
    private static SignatureInfo();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(int value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(long value);
    public static SignatureInfo Parse(string sigName);
    private static Tuple`2<string, int> ExtractFileNameAndLevel(string sigName);
}
public class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.StorageSignatureRepository : object {
    private static ILog log;
    private string _fileName;
    private ITransactionalStorage _storage;
    private string _tempDirectory;
    private IDictionary`2<string, FileStream> _createdFiles;
    public StorageSignatureRepository(ITransactionalStorage storage, string fileName, InMemoryRavenConfiguration configuration);
    private static StorageSignatureRepository();
    public sealed virtual Stream GetContentForReading(string sigName);
    public sealed virtual Stream CreateContent(string sigName);
    public sealed virtual void Flush(IEnumerable`1<SignatureInfo> signatureInfos);
    public sealed virtual IEnumerable`1<SignatureInfo> GetByFileName();
    public sealed virtual Nullable`1<DateTime> GetLastUpdate();
    public sealed virtual void Dispose();
    public SignatureInfo GetByName(string sigName);
    private static SignatureLevels GetSignatureLevel(string sigName, IStorageActionsAccessor accessor);
    private static SignatureInfo ExtractFileNameAndLevel(string sigName);
    private string NameToPath(string name);
    private void CloseCreatedStreams();
    [CompilerGeneratedAttribute]
private void <Flush>b__8_0(IStorageActionsAccessor accessor);
}
public enum Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.GeneratorParametersType : Enum {
    public int value__;
    public static GeneratorParametersType Unused;
    public static GeneratorParametersType FilterMax;
}
[GuidAttribute("96236A77-9DBC-11DA-9E3F-0011114AE311")]
[InterfaceTypeAttribute("1")]
internal interface Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.IRdcComparator {
    public abstract virtual int Process(bool endOfInput, Boolean& endOfOutput, RdcBufferPointer& inputBuffer, RdcNeedPointer& outputBuffer, RdcError& errorCode);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("96236A74-9DBC-11DA-9E3F-0011114AE311")]
internal interface Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.IRdcFileReader {
    public abstract virtual void GetFileSize(UInt64& fileSize);
    public abstract virtual void Read(ulong offsetFileStart, UInt32 bytesToRead, UInt32& bytesRead, IntPtr buffer, Boolean& eof);
    public abstract virtual void GetFilePosition(UInt64& offsetFromStart);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("96236A73-9DBC-11DA-9E3F-0011114AE311")]
internal interface Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.IRdcGenerator {
    public abstract virtual int GetGeneratorParameters(UInt32 level, IRdcGeneratorParameters& iGeneratorParameters);
    public abstract virtual int Process(bool endOfInput, Boolean& endOfOutput, RdcBufferPointer& inputBuffer, UInt32 depth, IntPtr[] outputBuffers, RdcError& errorCode);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("96236A72-9DBC-11DA-9E3F-0011114AE311")]
internal interface Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.IRdcGeneratorFilterMaxParameters {
    public abstract virtual int GetHorizonSize(UInt32& horizonSize);
    public abstract virtual int SetHorizonSize(UInt32 horizonSize);
    public abstract virtual int GetHashWindowSize(UInt32& hashWindowSize);
    public abstract virtual int SetHashWindowSize(UInt32 hashWindowSize);
}
[GuidAttribute("96236A71-9DBC-11DA-9E3F-0011114AE311")]
[InterfaceTypeAttribute("1")]
internal interface Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.IRdcGeneratorParameters {
    public abstract virtual int GetGeneratorParametersType(GeneratorParametersType& parametersType);
    public abstract virtual int GetParametersVersion(UInt32& currentVersion, UInt32& minimumCompatabileAppVersion);
    public abstract virtual int GetSerializeSize(UInt32& size);
    public abstract virtual int Serialize(UInt32 size, IntPtr& parametersBlob, UInt32& bytesWritten);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("96236A78-9DBC-11DA-9E3F-0011114AE311")]
internal interface Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.IRdcLibrary {
    public abstract virtual int ComputeDefaultRecursionDepth(long fileSize, Int32& depth);
    public abstract virtual int CreateGeneratorParameters(GeneratorParametersType parametersType, UInt32 level, IRdcGeneratorParameters& iGeneratorParameters);
    public abstract virtual int OpenGeneratorParameters(UInt32 size, IntPtr parametersBlob, IRdcGeneratorParameters& iGeneratorParameters);
    public abstract virtual int CreateGenerator(UInt32 depth, IRdcGeneratorParameters[] iGeneratorParametersArray, IRdcGenerator& iGenerator);
    public abstract virtual int CreateComparator(IRdcFileReader iSeedSignatureFiles, UInt32 comparatorBufferSize, IRdcComparator& iComparator);
    public abstract virtual int CreateSignatureReader(IRdcFileReader iFileReader, IRdcSignatureReader& iSignatureReader);
    public abstract virtual int GetRDCVersion(UInt32& currentVersion, UInt32& minimumCompatibileAppVersion);
}
[GuidAttribute("96236A76-9DBC-11DA-9E3F-0011114AE311")]
[InterfaceTypeAttribute("1")]
internal interface Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.IRdcSignatureReader {
    public abstract virtual int ReaderHeader(RdcError& errorCode);
    public abstract virtual int ReadSignatures(RdcSignaturePointer& rdcSignaturePointer, Boolean& endOfOutput);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("96236A80-9DBC-11DA-9E3F-0011114AE311")]
internal interface Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.IRdcSimilarityGenerator {
    public abstract virtual int EnableSimilarity();
    public abstract virtual int Results(SimilarityData& similarityData);
}
internal class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.Msrdc : ValueType {
    public static UInt32 Version;
    public static UInt32 MinimumCompatibleAppVersion;
    public static UInt32 MinimumDepth;
    public static UInt32 MaximumDepth;
    public static UInt32 MinimumComparebuffer;
    public static UInt32 MaximumComparebuffer;
    public static UInt32 DefaultComparebuffer;
    public static UInt32 MinimumInputbuffersize;
    public static UInt32 MinimumHorizonsize;
    public static UInt32 MaximumHorizonsize;
    public static UInt32 MinimumHashwindowsize;
    public static UInt32 MaximumHashwindowsize;
    public static UInt32 DefaultHashwindowsize1;
    public static UInt32 DefaultHorizonsize1;
    public static UInt32 DefaultHashwindowsizeN;
    public static UInt32 DefaultHorizonsizeN;
    public static UInt32 MaximumTraitvalue;
    public static UInt32 MinimumMatchesrequired;
    public static UInt32 MaximumMatchesrequired;
}
internal class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.RdcBufferPointer : ValueType {
    public UInt32 Size;
    public UInt32 Used;
    public IntPtr Data;
}
public static class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.RdcBufferTools : object {
    public static int IntPtrCopy(IntPtr source, Stream dest, int length);
    public static int IntPtrCopy(Stream source, IntPtr dest, int length);
}
public enum Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.RdcError : Enum {
    public UInt32 value__;
    public static RdcError NoError;
    public static RdcError HeaderVersionNewer;
    public static RdcError HeaderVersionOlder;
    public static RdcError HeaderMissingOrCorrupt;
    public static RdcError HeaderWrongType;
    public static RdcError DataMissingOrCorrupt;
    public static RdcError DataTooManyRecords;
    public static RdcError FileChecksumMismatch;
    public static RdcError ApplicationError;
    public static RdcError Aborted;
    public static RdcError Win32Error;
}
[GuidAttribute("96236A85-9DBC-11DA-9E3F-0011114AE311")]
[ClassInterfaceAttribute("0")]
public class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.RdcLibrary : object {
}
internal class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.RdcNeedPointer : ValueType {
    public UInt32 Size;
    public UInt32 Used;
    public IntPtr Data;
}
internal class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.RdcSignature : ValueType {
    public IntPtr Signature;
    public ushort BlockLength;
}
internal class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.RdcSignaturePointer : ValueType {
    public UInt32 Size;
    public UInt32 Used;
    public RdcSignature Data;
}
public class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.Unmanaged.SimilarityData : ValueType {
    public Char[] Data;
}
public class Raven.Database.FileSystem.Synchronization.Rdc.Wrapper.VolatileSignatureRepository : object {
    private static ILog log;
    private IDictionary`2<string, FileStream> _createdFiles;
    private string _fileName;
    private string _tempDirectory;
    public VolatileSignatureRepository(string fileName, InMemoryRavenConfiguration configuration);
    private static VolatileSignatureRepository();
    public sealed virtual Stream GetContentForReading(string sigName);
    public sealed virtual Stream CreateContent(string sigName);
    public sealed virtual void Flush(IEnumerable`1<SignatureInfo> signatureInfos);
    public sealed virtual IEnumerable`1<SignatureInfo> GetByFileName();
    public sealed virtual Nullable`1<DateTime> GetLastUpdate();
    public sealed virtual void Dispose();
    private IEnumerable`1<string> GetSigFileNamesByFileName();
    private string NameToPath(string name);
    private void CloseCreatedStreams();
}
public class Raven.Database.FileSystem.Synchronization.RenameWorkItem : SynchronizationWorkItem {
    private string rename;
    public SynchronizationType SynchronizationType { get; }
    public RenameWorkItem(string name, string rename, string sourceServerUrl, ITransactionalStorage storage);
    public virtual SynchronizationType get_SynchronizationType();
    public virtual Task`1<SynchronizationReport> PerformAsync(ISynchronizationServerClient synchronizationServerClient);
    public virtual bool Equals(object obj);
    public bool Equals(RenameWorkItem other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationBehavior : object {
    private static ILog Log;
    private string fileName;
    private Etag sourceFileEtag;
    private RavenJObject sourceMetadata;
    private FileSystemInfo sourceFs;
    private SynchronizationType type;
    private RavenFileSystem fs;
    [CompilerGeneratedAttribute]
private string <Rename>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpContent <MultipartContent>k__BackingField;
    public string Rename { get; public set; }
    public HttpContent MultipartContent { get; public set; }
    public SynchronizationBehavior(string fileName, Etag sourceFileEtag, RavenJObject sourceMetadata, FileSystemInfo sourceFs, SynchronizationType type, RavenFileSystem fs);
    private static SynchronizationBehavior();
    [CompilerGeneratedAttribute]
public string get_Rename();
    [CompilerGeneratedAttribute]
public void set_Rename(string value);
    [CompilerGeneratedAttribute]
public HttpContent get_MultipartContent();
    [CompilerGeneratedAttribute]
public void set_MultipartContent(HttpContent value);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationBehavior/<Execute>d__16")]
public Task`1<SynchronizationReport> Execute();
    private void AssertOperationAndLockFile();
    private void NotifyStart();
    private void NotifyEnd();
    private void Prepare();
    private void AssertConflictDetection(RavenJObject localMetadata, Boolean& isConflictResolved);
    private void ExecuteDelete(RavenJObject localMetadata);
    private void ExecuteMetadataUpdate();
    private void ExecuteRename(string rename);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationBehavior/<ExecuteContentUpdate>d__25")]
private Task ExecuteContentUpdate(RavenJObject localMetadata, SynchronizationReport report);
    private static bool ShouldAddExceptionToReport(Exception ex);
    [CompilerGeneratedAttribute]
private void <Execute>b__16_0(AbstractSynchronizationTrigger trigger);
    [CompilerGeneratedAttribute]
private void <AssertOperationAndLockFile>b__17_0(IStorageActionsAccessor accessor);
    [CompilerGeneratedAttribute]
private void <Prepare>b__20_0(IStorageActionsAccessor accessor);
}
public static class Raven.Database.FileSystem.Synchronization.SynchronizationConfigAccessor : object {
    private static ILog Log;
    private static SynchronizationConfigAccessor();
    public static SynchronizationConfig GetOrDefault(IStorageActionsAccessor accessor);
    public static SynchronizationConfig GetOrDefault(ITransactionalStorage storage);
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationHiLo : object {
    private static long Capacity;
    private object generatorLock;
    private ITransactionalStorage storage;
    private long currentHi;
    private long currentLo;
    public SynchronizationHiLo(ITransactionalStorage storage);
    public long NextId();
    private long GetNextHi();
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationLock : object {
    [CompilerGeneratedAttribute]
private FileSystemInfo <SourceFileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <FileLockedAt>k__BackingField;
    public FileSystemInfo SourceFileSystem { get; public set; }
    public DateTime FileLockedAt { get; public set; }
    [CompilerGeneratedAttribute]
public FileSystemInfo get_SourceFileSystem();
    [CompilerGeneratedAttribute]
public void set_SourceFileSystem(FileSystemInfo value);
    [CompilerGeneratedAttribute]
public DateTime get_FileLockedAt();
    [CompilerGeneratedAttribute]
public void set_FileLockedAt(DateTime value);
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationQueue : object {
    private static ILog Log;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, SynchronizationWorkItem>> activeSynchronizations;
    private ConcurrentDictionary`2<string, ReaderWriterLockSlim> pendingRemoveLocks;
    private ConcurrentDictionary`2<string, ConcurrentQueue`1<SynchronizationWorkItem>> pendingSynchronizations;
    public IEnumerable`1<SynchronizationDetails> Pending { get; }
    public IEnumerable`1<SynchronizationDetails> Active { get; }
    private static SynchronizationQueue();
    public IEnumerable`1<SynchronizationDetails> get_Pending();
    public IEnumerable`1<SynchronizationDetails> get_Active();
    public int GetTotalPendingTasks();
    public int GetTotalActiveTasks();
    public int NumberOfActiveSynchronizationsFor(string destinationFileSystemUrl);
    public int NumberOfPendingSynchronizationsFor(string destinationFileSystemUrl);
    public bool EnqueueSynchronization(string destinationFileSystemUrl, SynchronizationWorkItem workItem);
    public bool TryDequePending(string destinationFileSystemUrl, SynchronizationWorkItem& workItem);
    public bool IsDifferentWorkForTheSameFileBeingPerformed(SynchronizationWorkItem work, string destinationFileSystemUrl);
    public void SynchronizationStarted(SynchronizationWorkItem work, string destinationFileSystemUrl);
    public void SynchronizationFinished(SynchronizationWorkItem work, string destinationFileSystemUrl);
    public void CancelActiveSynchronizations(string fileName);
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationStrategy : object {
    private static ILog Log;
    private SigGenerator sigGenerator;
    private InMemoryRavenConfiguration configuration;
    private ITransactionalStorage storage;
    private static String[] MetadataToIgnore;
    public SynchronizationStrategy(ITransactionalStorage storage, SigGenerator sigGenerator, InMemoryRavenConfiguration configuration);
    private static SynchronizationStrategy();
    public bool Filter(FileHeader file, Guid destinationId, IEnumerable`1<FileHeader> candidatesToSynchronization);
    private static bool ExistsRenameTombstone(string name, IEnumerable`1<FileHeader> candidatesToSynchronization);
    public SynchronizationWorkItem DetermineWork(string file, RavenJObject localMetadata, RavenJObject destinationMetadata, string localServerUrl, Func`2<string, RavenJObject> getDestinationMetadata, NoSyncReason& reason);
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationTask : object {
    private static ILog Log;
    internal static int NumberOfFilesToCheckForSynchronization;
    private static int DefaultNumberOfCachedRequests;
    private NotificationPublisher publisher;
    private ITransactionalStorage storage;
    private SynchronizationQueue synchronizationQueue;
    private SynchronizationStrategy synchronizationStrategy;
    private InMemoryRavenConfiguration systemConfiguration;
    private SynchronizationTaskContext context;
    private ConcurrentDictionary`2<string, DestinationRequest> _requestFactories;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, SynchronizationDetails>> activeIncomingSynchronizations;
    private int failedAttemptsToGetDestinationsConfig;
    private long workCounter;
    private Task task;
    [CompilerGeneratedAttribute]
private bool <HasActiveDestinations>k__BackingField;
    private ConcurrentDictionary`2<string, LastReplicatedEtagRecord> _lastReplicatedEtags;
    public string FileSystemUrl { get; }
    public SynchronizationQueue Queue { get; }
    public SynchronizationTaskContext Context { get; }
    public bool HasActiveDestinations { get; private set; }
    public IEnumerable`1<SynchronizationDetails> IncomingQueue { get; }
    public SynchronizationTask(ITransactionalStorage storage, SigGenerator sigGenerator, NotificationPublisher publisher, InMemoryRavenConfiguration systemConfiguration);
    private static SynchronizationTask();
    public string get_FileSystemUrl();
    public SynchronizationQueue get_Queue();
    public SynchronizationTaskContext get_Context();
    [CompilerGeneratedAttribute]
public bool get_HasActiveDestinations();
    [CompilerGeneratedAttribute]
private void set_HasActiveDestinations(bool value);
    public void IncomingSynchronizationStarted(string fileName, FileSystemInfo sourceFileSystemInfo, Guid sourceFileETag, SynchronizationType type);
    public void IncomingSynchronizationFinished(string fileName, FileSystemInfo sourceFileSystemInfo, Guid sourceFileETag);
    public IEnumerable`1<SynchronizationDetails> get_IncomingQueue();
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationTask/<SynchronizeDestinationAsync>d__29")]
public Task`1<DestinationSyncResult> SynchronizeDestinationAsync(string fileSystemDestination, bool forceSyncingAll);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationTask/<CreateDestinationResult>d__30")]
public Task`1<DestinationSyncResult> CreateDestinationResult(SynchronizationDestination destination, IEnumerable`1<Task`1<SynchronizationReport>> synchronizations);
    public void Start();
    public Dictionary`2<SynchronizationDestination, Task`1<IEnumerable`1<Task`1<SynchronizationReport>>>> Execute(bool forceSyncingAll);
    private DestinationRequest GetDestinationRequest(SynchronizationDestination destination);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationTask/<SynchronizeFileToAsync>d__34")]
public Task`1<SynchronizationReport> SynchronizeFileToAsync(string fileName, SynchronizationDestination destination);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationTask/<SynchronizeDestinationAsync>d__35")]
private Task`1<IEnumerable`1<Task`1<SynchronizationReport>>> SynchronizeDestinationAsync(SynchronizationDestination destination, bool forceSyncingAll);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationTask/<EnqueueMissingUpdatesAsync>d__38")]
private Task`1<bool> EnqueueMissingUpdatesAsync(ISynchronizationServerClient destinationSyncClient, SourceSynchronizationInformation synchronizationInfo, IList`1<FileHeader> needSyncingAgain);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationTask/<SynchronizePendingFilesAsync>d__39")]
private IEnumerable`1<Task`1<SynchronizationReport>> SynchronizePendingFilesAsync(ISynchronizationServerClient destinationCommands, bool forceSyncingAll);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationTask/<PerformSynchronizationAsync>d__40")]
private Task`1<SynchronizationReport> PerformSynchronizationAsync(ISynchronizationServerClient synchronizationServerClient, SynchronizationWorkItem work);
    private IEnumerable`1<FileHeader> GetFilesToSynchronization(Etag from, int take);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationTask/<ConfirmPushedFiles>d__42")]
private Task`1<SynchronizationConfirmation[]> ConfirmPushedFiles(IList`1<SynchronizationDetails> filesNeedConfirmation, ISynchronizationServerClient synchronizationServerClient);
    private IEnumerable`1<SynchronizationDetails> GetSyncingConfigurations(SynchronizationDestination destination);
    private void CreateSyncingConfiguration(string fileName, Guid etag, string destinationFileSystemUrl, SynchronizationType synchronizationType);
    private void RemoveSyncingConfiguration(string fileName, string destination);
    private RavenJObject GetLocalMetadata(string fileName);
    [IteratorStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationTask/<GetSynchronizationDestinations>d__47")]
internal IEnumerable`1<SynchronizationDestination> GetSynchronizationDestinations();
    private int AvailableSynchronizationRequestsTo(string destinationFileSystemUrl);
    public void Cancel(string fileName);
    private static void LogFilesInfo(string message, ICollection`1<FileHeader> files);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationTask/<ResetDestinations>d__53")]
public Task ResetDestinations();
    [CompilerGeneratedAttribute]
private void <Start>b__31_0();
    [CompilerGeneratedAttribute]
private void <SynchronizePendingFilesAsync>b__39_0(Task`1<SynchronizationReport> _);
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationTaskContext : object {
    private static ILog Log;
    private CancellationTokenSource cancellationTokenSource;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) doWork;
    private object waitForWork;
    private long workCounter;
    [CompilerGeneratedAttribute]
private DateTime <LastSuccessfulSynchronizationTime>k__BackingField;
    public bool DoWork { get; }
    public CancellationToken CancellationToken { get; }
    public DateTime LastSuccessfulSynchronizationTime { get; private set; }
    private static SynchronizationTaskContext();
    public bool get_DoWork();
    public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public DateTime get_LastSuccessfulSynchronizationTime();
    [CompilerGeneratedAttribute]
private void set_LastSuccessfulSynchronizationTime(DateTime value);
    public void UpdateSuccessfulSynchronizationTime();
    public bool WaitForWork(TimeSpan timeout, Int64& workerWorkCounter);
    public void NotifyAboutWork();
    public void StopWork();
    public sealed virtual void Dispose();
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationTopology : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Servers>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<SynchronizationTopologyConnection> <Connections>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <SkippedResources>k__BackingField;
    public HashSet`1<string> Servers { get; public set; }
    public HashSet`1<SynchronizationTopologyConnection> Connections { get; public set; }
    public HashSet`1<string> SkippedResources { get; public set; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Servers();
    [CompilerGeneratedAttribute]
public void set_Servers(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<SynchronizationTopologyConnection> get_Connections();
    [CompilerGeneratedAttribute]
public void set_Connections(HashSet`1<SynchronizationTopologyConnection> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SkippedResources();
    [CompilerGeneratedAttribute]
public void set_SkippedResources(HashSet`1<string> value);
    public SynchronizationTopologyConnection GetConnection(Guid fromServerId, Nullable`1<Guid> toServerId, string fromUrl, string toUrl);
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationTopologyConnection : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <SourceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <DestinationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <DestinationServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SendServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <StoredServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastSourceFileEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicatonNodeState <SourceToDestinationState>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplicatonNodeState <DestinationToSourceState>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    public HashSet`1<string> SourceUrl { get; public set; }
    public HashSet`1<string> DestinationUrl { get; public set; }
    public Guid SourceServerId { get; }
    public Nullable`1<Guid> DestinationServerId { get; public set; }
    public Guid SendServerId { get; public set; }
    public Guid StoredServerId { get; public set; }
    public Etag LastSourceFileEtag { get; public set; }
    public ReplicatonNodeState SourceToDestinationState { get; public set; }
    public ReplicatonNodeState DestinationToSourceState { get; public set; }
    public List`1<string> Errors { get; public set; }
    public string Source { get; public set; }
    public string Destination { get; public set; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SourceUrl();
    [CompilerGeneratedAttribute]
public void set_SourceUrl(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_DestinationUrl();
    [CompilerGeneratedAttribute]
public void set_DestinationUrl(HashSet`1<string> value);
    public Guid get_SourceServerId();
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_DestinationServerId();
    [CompilerGeneratedAttribute]
public void set_DestinationServerId(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Guid get_SendServerId();
    [CompilerGeneratedAttribute]
public void set_SendServerId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_StoredServerId();
    [CompilerGeneratedAttribute]
public void set_StoredServerId(Guid value);
    [CompilerGeneratedAttribute]
public Etag get_LastSourceFileEtag();
    [CompilerGeneratedAttribute]
public void set_LastSourceFileEtag(Etag value);
    [CompilerGeneratedAttribute]
public ReplicatonNodeState get_SourceToDestinationState();
    [CompilerGeneratedAttribute]
public void set_SourceToDestinationState(ReplicatonNodeState value);
    [CompilerGeneratedAttribute]
public ReplicatonNodeState get_DestinationToSourceState();
    [CompilerGeneratedAttribute]
public void set_DestinationToSourceState(ReplicatonNodeState value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationTopologyDestinationNode : SynchronizationTopologyNode {
    [CompilerGeneratedAttribute]
private Guid <SendServerId>k__BackingField;
    public Guid SendServerId { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_SendServerId();
    [CompilerGeneratedAttribute]
public void set_SendServerId(Guid value);
    public static SynchronizationTopologyDestinationNode Online(string serverUrl, Guid sourceServerId, Nullable`1<Guid> destinationServerId);
    public static SynchronizationTopologyDestinationNode Offline(string serverUrl, Guid sourceServerId, Nullable`1<Guid> destinationServerId);
    public static SynchronizationTopologyDestinationNode Disabled(string serverUrl, Guid sourceServerId, Nullable`1<Guid> destinationServerId);
}
internal class Raven.Database.FileSystem.Synchronization.SynchronizationTopologyDiscoverer : object {
    private RavenFileSystem filesystem;
    private int ttl;
    private ILog log;
    private RavenJArray from;
    private HttpRavenRequestFactory requestFactory;
    private Guid currentServerId;
    public SynchronizationTopologyDiscoverer(RavenFileSystem filesystem, RavenJArray from, int ttl, ILog log);
    public SynchronizationTopologyRootNode Discover();
    private List`1<SynchronizationTopologySourceNode> HandleSources(IEnumerable`1<string> sources, SynchronizationTopologyRootNode root);
    private SynchronizationTopologySourceNode HandleSource(SourceSynchronizationInformation source, Guid sourceDatabaseId);
    private List`1<SynchronizationTopologyDestinationNode> HandleDestinations(IList`1<SynchronizationDestination> destinations);
    private SynchronizationTopologyDestinationNode HandleDestination(SynchronizationDestination synchronizationDestination);
    private bool FetchTargetServerUrl(string serverUrl, RavenConnectionStringOptions connectionStringOptions, String& targetServerUrl, Nullable`1& fileSystemId, String& error);
    private Nullable`1<Guid> GetFileSystemId(string serverUrl, RavenConnectionStringOptions connectionStringOptions);
    private bool TryGetSchema(string serverUrl, RavenConnectionStringOptions connectionStringOptions, SynchronizationTopologyRootNode& rootNode, String& error);
    private void FindVisitedNodes(SynchronizationTopologyNodeBase rootNode, HashSet`1<string> visitedNodes);
    private ReplicatonNodeState CheckSourceConnectionState(string sourceUrl);
    private ReplicatonNodeState CheckConnectionState(string serverUrl, RavenConnectionStringOptions connectionStringOptions);
}
public abstract class Raven.Database.FileSystem.Synchronization.SynchronizationTopologyNode : SynchronizationTopologyNodeBase {
    [CompilerGeneratedAttribute]
private ReplicatonNodeState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <DestinationServerId>k__BackingField;
    public ReplicatonNodeState State { get; protected set; }
    public Nullable`1<Guid> DestinationServerId { get; public set; }
    [CompilerGeneratedAttribute]
public ReplicatonNodeState get_State();
    [CompilerGeneratedAttribute]
protected void set_State(ReplicatonNodeState value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_DestinationServerId();
    [CompilerGeneratedAttribute]
public void set_DestinationServerId(Nullable`1<Guid> value);
}
public abstract class Raven.Database.FileSystem.Synchronization.SynchronizationTopologyNodeBase : object {
    [CompilerGeneratedAttribute]
private string <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SynchronizationTopologySourceNode> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SynchronizationTopologyDestinationNode> <Destinations>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    public string ServerUrl { get; protected set; }
    public List`1<SynchronizationTopologySourceNode> Sources { get; public set; }
    public List`1<SynchronizationTopologyDestinationNode> Destinations { get; public set; }
    public List`1<string> Errors { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServerUrl();
    [CompilerGeneratedAttribute]
protected void set_ServerUrl(string value);
    [CompilerGeneratedAttribute]
public List`1<SynchronizationTopologySourceNode> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(List`1<SynchronizationTopologySourceNode> value);
    [CompilerGeneratedAttribute]
public List`1<SynchronizationTopologyDestinationNode> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(List`1<SynchronizationTopologyDestinationNode> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<string> value);
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationTopologyRootNode : SynchronizationTopologyNodeBase {
    private Dictionary`2<Guid, string> resourceIdToUrl;
    private Dictionary`2<string, Guid> urlToResourceId;
    [CompilerGeneratedAttribute]
private Guid <ServerId>k__BackingField;
    public Guid ServerId { get; public set; }
    public SynchronizationTopologyRootNode(string serverUrl, Guid serverId);
    [CompilerGeneratedAttribute]
public Guid get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(Guid value);
    private void HandleLink(SynchronizationTopology topology, SynchronizationTopologyNodeBase source, SynchronizationTopologyNodeBase target);
    private string AddToCache(Nullable`1<Guid> resourceId, string url);
    private Nullable`1<Guid> GetResourceId(Nullable`1<Guid> resourceId, string url);
    private string GetUrlByResourceId(Nullable`1<Guid> resourceId, string url);
    public SynchronizationTopology Flatten();
}
public class Raven.Database.FileSystem.Synchronization.SynchronizationTopologySourceNode : SynchronizationTopologyNode {
    [CompilerGeneratedAttribute]
private Guid <StoredServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastSourceFileEtag>k__BackingField;
    public Guid StoredServerId { get; public set; }
    public Etag LastSourceFileEtag { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_StoredServerId();
    [CompilerGeneratedAttribute]
public void set_StoredServerId(Guid value);
    [CompilerGeneratedAttribute]
public Etag get_LastSourceFileEtag();
    [CompilerGeneratedAttribute]
public void set_LastSourceFileEtag(Etag value);
    public static SynchronizationTopologySourceNode Online(string serverUrl, Guid sourceServerId, Nullable`1<Guid> destinationServerId, Etag lastSourceFileEtag);
    public static SynchronizationTopologySourceNode Offline(string serverUrl, Guid sourceServerId, Nullable`1<Guid> destinationServerId, Etag lastSourceFileEtag);
}
public abstract class Raven.Database.FileSystem.Synchronization.SynchronizationWorkItem : object {
    private ConflictDetector conflictDetector;
    private ConflictResolver conflictResolver;
    protected CancellationTokenSource Cts;
    protected FilesConvention Convention;
    private Etag forcedEtag;
    [CompilerGeneratedAttribute]
private ITransactionalStorage <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <FileMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemInfo <FileSystemInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ProfilingInformation <ProfilingInformation>k__BackingField;
    protected ITransactionalStorage Storage { get; private set; }
    public string FileName { get; private set; }
    public Etag FileETag { get; }
    public bool IsCancelled { get; }
    protected RavenJObject FileMetadata { get; protected set; }
    protected FileSystemInfo FileSystemInfo { get; private set; }
    public SynchronizationType SynchronizationType { get; }
    public ProfilingInformation ProfilingInformation { get; private set; }
    protected SynchronizationWorkItem(string fileName, string sourceServerUrl, ITransactionalStorage storage);
    [CompilerGeneratedAttribute]
protected ITransactionalStorage get_Storage();
    [CompilerGeneratedAttribute]
private void set_Storage(ITransactionalStorage value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    public Etag get_FileETag();
    public void ForceSetEtag(Etag etag);
    public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
protected RavenJObject get_FileMetadata();
    [CompilerGeneratedAttribute]
protected void set_FileMetadata(RavenJObject value);
    [CompilerGeneratedAttribute]
protected FileSystemInfo get_FileSystemInfo();
    [CompilerGeneratedAttribute]
private void set_FileSystemInfo(FileSystemInfo value);
    public abstract virtual SynchronizationType get_SynchronizationType();
    public abstract virtual Task`1<SynchronizationReport> PerformAsync(ISynchronizationServerClient destination);
    public virtual void Cancel();
    protected void AssertLocalFileExistsAndIsNotConflicted(RavenJObject sourceMetadata);
    protected ConflictItem CheckConflictWithDestination(RavenJObject sourceMetadata, RavenJObject destinationMetadata, string localServerUrl);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationWorkItem/<ApplyConflictOnDestinationAsync>d__33")]
private Task`1<SynchronizationReport> ApplyConflictOnDestinationAsync(ConflictItem conflict, RavenJObject remoteMetadata, ISynchronizationServerClient synchronizationServerClient, string localServerUrl, ILog log);
    [AsyncStateMachineAttribute("Raven.Database.FileSystem.Synchronization.SynchronizationWorkItem/<HandleConflict>d__34")]
protected Task`1<SynchronizationReport> HandleConflict(ISynchronizationServerClient synchronizationServerClient, ConflictItem conflict, ILog log);
    public void RefreshMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual ProfilingInformation get_ProfilingInformation();
    [CompilerGeneratedAttribute]
private void set_ProfilingInformation(ProfilingInformation value);
}
public class Raven.Database.FileSystem.Util.AwaitableQueue`1 : object {
    private Queue`1<T> queue;
    private Queue`1<TaskCompletionSource`1<T>> waitingTasks;
    private object gate;
    private bool completed;
    public bool TryEnqueue(T item);
    public bool TryDequeue(T& item);
    public Task`1<T> DequeueOrWaitAsync();
    public void SignalCompletion();
    private void FulfillWaitingTasks();
    private Tuple`2<T, TaskCompletionSource`1<T>> GetNextItemAndTask();
}
public class Raven.Database.FileSystem.Util.CombinedStream : Stream {
    private Stream[] underlyingStreams;
    private Int64[] underlyingStartingPositions;
    private long position;
    private long totalLength;
    private int index;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CombinedStream(Stream[] underlyingStreams);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public static class Raven.Database.FileSystem.Util.FilePathTools : object {
    public static string MakeSureEndsWithSlash(string filePath);
    public static string StripWorkingDirectory(string workDir, string dir);
    public static string ApplyWorkingDirectoryToPathAndMakeSureThatItEndsWithSlash(string workingDirectory, string path);
}
public class Raven.Database.FileSystem.Util.HashKey : object {
    [CompilerGeneratedAttribute]
private Byte[] <Strong>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Weak>k__BackingField;
    public Byte[] Strong { get; public set; }
    public int Weak { get; public set; }
    public HashKey(Byte[] buffer, int size);
    [CompilerGeneratedAttribute]
public Byte[] get_Strong();
    [CompilerGeneratedAttribute]
public void set_Strong(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Weak();
    [CompilerGeneratedAttribute]
public void set_Weak(int value);
}
public class Raven.Database.FileSystem.Util.NarrowedStream : Stream {
    [CompilerGeneratedAttribute]
private Stream <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private long <From>k__BackingField;
    [CompilerGeneratedAttribute]
private long <To>k__BackingField;
    public Stream Source { get; private set; }
    public long From { get; private set; }
    public long To { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public NarrowedStream(Stream source, long from, long to);
    [CompilerGeneratedAttribute]
public Stream get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(Stream value);
    [CompilerGeneratedAttribute]
public long get_From();
    [CompilerGeneratedAttribute]
private void set_From(long value);
    [CompilerGeneratedAttribute]
public long get_To();
    [CompilerGeneratedAttribute]
private void set_To(long value);
    public virtual void Flush();
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class Raven.Database.FileSystem.Util.NaveValueCollectionJsonConverterOnlyForConfigFormatters : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Raven.Database.FileSystem.Util.RabinKarpHasher : object {
    private int length;
    private int current;
    private int Q;
    private int R;
    private int RM;
    public RabinKarpHasher(int length);
    public int Init(Byte[] bytes, int position, int size);
    public int Move(byte prev, byte next);
}
public static class Raven.Database.FileSystem.Util.RandomProvider : object {
    private static int seed;
    private static ThreadLocal`1<Random> RandomWrapper;
    private static RandomProvider();
    public static Random GetThreadRandom();
}
public static class Raven.Database.FileSystem.Util.RavenFileNameHelper : object {
    internal static string SyncNamePrefix;
    internal static string SyncLockNamePrefix;
    internal static string ConflictConfigNamePrefix;
    internal static string SyncResultNamePrefix;
    internal static string DownloadingFileSuffix;
    internal static string DeletingFileSuffix;
    internal static string DeleteOperationConfigPrefix;
    internal static string RenameOperationConfigPrefix;
    internal static string CopyOperationConfigPrefix;
    public static string RavenDirectory(string directory);
    public static string SyncNameForFile(string fileName, string destination);
    public static string SyncLockNameForFile(string fileName);
    public static string ConflictConfigNameForFile(string fileName);
    public static string SyncResultNameForFile(string fileName);
    public static string DownloadingFileName(string fileName);
    public static string DeletingFileName(string fileName, int deleteVersion);
    public static string DeleteOperationConfigNameForFile(string fileName);
    public static string RenameOperationConfigNameForFile(string fileName);
    public static string CopyOperationConfigNameForFile(string fileName, string target);
}
public class Raven.Database.FileSystem.Util.StorageStream : Stream {
    private RavenFileSystem fileSystem;
    private ITransactionalStorage storage;
    private static int PagesBatchSize;
    private long currentOffset;
    private long currentPageFrameOffset;
    private bool disposed;
    private FileAndPagesInformation fileAndPages;
    private FileHeader fileHeader;
    protected Byte[] InnerBuffer;
    protected int InnerBufferOffset;
    private int writtingPagePosition;
    [CompilerGeneratedAttribute]
private StorageStreamAccess <StorageStreamAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    public StorageStreamAccess StorageStreamAccess { get; private set; }
    public string Name { get; private set; }
    public RavenJObject Metadata { get; private set; }
    private long CurrentPageFrameSize { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected StorageStream(RavenFileSystem fileSystem, ITransactionalStorage storage, string fileName, RavenJObject metadata, StorageStreamAccess storageStreamAccess);
    [CompilerGeneratedAttribute]
public StorageStreamAccess get_StorageStreamAccess();
    [CompilerGeneratedAttribute]
private void set_StorageStreamAccess(StorageStreamAccess value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(RavenJObject value);
    private long get_CurrentPageFrameSize();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static StorageStream Reading(ITransactionalStorage storage, string fileName);
    public static StorageStream CreatingNewAndWritting(RavenFileSystem fileSystem, string fileName, RavenJObject metadata);
    public virtual long Seek(long offset, SeekOrigin origin);
    private void MovePageFrame(long offset);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public int ReadUsingExternalTempBuffer(Byte[] buffer, int offset, int count, Byte[] temp);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <MovePageFrame>b__40_0(IStorageActionsAccessor accessor);
    [CompilerGeneratedAttribute]
private void <Flush>b__44_0(IStorageActionsAccessor accessor);
    [CompilerGeneratedAttribute]
private void <Dispose>b__46_0(IStorageActionsAccessor accessor);
    [CompilerGeneratedAttribute]
private void <Dispose>b__46_1(AbstractFilePutTrigger trigger);
}
public enum Raven.Database.FileSystem.Util.StorageStreamAccess : Enum {
    public int value__;
    public static StorageStreamAccess Read;
    public static StorageStreamAccess CreateAndWrite;
}
public class Raven.Database.FileSystem.Util.SynchronizingFileStream : StorageStream {
    private IHashEncryptor md5Hasher;
    [CompilerGeneratedAttribute]
private bool <PreventUploadComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileHash>k__BackingField;
    public bool PreventUploadComplete { get; public set; }
    public string FileHash { get; private set; }
    private SynchronizingFileStream(RavenFileSystem fileSystem, string fileName, RavenJObject metadata, StorageStreamAccess storageStreamAccess);
    [CompilerGeneratedAttribute]
public bool get_PreventUploadComplete();
    [CompilerGeneratedAttribute]
public void set_PreventUploadComplete(bool value);
    [CompilerGeneratedAttribute]
public string get_FileHash();
    [CompilerGeneratedAttribute]
private void set_FileHash(string value);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public static SynchronizingFileStream CreatingOrOpeningAndWriting(RavenFileSystem fileSystem, string fileName, RavenJObject metadata);
}
public class Raven.Database.Impl.BackgroundTaskExecuter.RavenThreadPool : object {
    [ThreadStaticAttribute]
private static Thread _selfInformation;
    private ConcurrentQueue`1<CountdownEvent> _concurrentEvents;
    private CancellationTokenSource _createLinkedTokenSource;
    private CancellationToken _ct;
    private object _locker;
    private ConcurrentDictionary`2<ThreadTask, object> _runningTasks;
    private BlockingCollection`1<ThreadTask> _tasks;
    private AutoResetEvent _threadHasNoWorkToDo;
    private ILog logger;
    private int _currentWorkingThreadsAmount;
    public ThreadLocal`1<bool> _freedThreadsValue;
    public int _partialMaxWait;
    private int _partialMaxWaitChangeFlag;
    private int _hasPartialBatchResumption;
    private Thread[] _threads;
    private static int defaultPageSize;
    public Action`1<AutoTunerDecisionDescription> ReportToAutoTuner;
    public Action`1<Alert> ReportAlert;
    public static int DefaultPageSize { get; }
    public int WaitingTasksAmount { get; }
    public int RunningTasksAmount { get; }
    public RavenThreadPool(int maxLevelOfParallelism);
    public static int get_DefaultPageSize();
    public sealed virtual void HandleHighCpuUsage();
    public sealed virtual void HandleLowCpuUsage();
    public sealed virtual void Dispose();
    public ThreadsSummary GetThreadPoolStats();
    public RavenThreadPool Start();
    public void DrainThePendingTasks();
    public ThreadTask[] GetRunningTasks();
    public ThreadTask[] GetAllWaitingTasks();
    public object GetDebugInfo();
    public int get_WaitingTasksAmount();
    public int get_RunningTasksAmount();
    private void ExecutePoolWork(Thread selfData);
    private void ExecuteWorkOnce(bool shouldWaitForWork);
    private void RunThreadTask(ThreadTask threadTask);
    private ThreadTask GetNextTask();
    public void ExecuteBatch(IList`1<T> src, Action`1<IEnumerator`1<T>> action, DocumentDatabase database, int pageSize, string description);
    private void ExecuteSingleBatchSynchronously(IList`1<T> src, Action`1<IEnumerator`1<T>> action, string description, DocumentDatabase database);
    [IteratorStateMachineAttribute("Raven.Database.Impl.BackgroundTaskExecuter.RavenThreadPool/<YieldFromRange>d__40`1")]
private IEnumerator`1<T> YieldFromRange(ConcurrentQueue`1<Tuple`2<int, int>> ranges, Tuple`2<int, int> boundaries, IList`1<T> input, Reference`1<int> numOfBatchesUsed, Nullable`1<CancellationToken> ct);
    public bool ExecuteBatch(IList`1<T> src, Action`1<T> action, DocumentDatabase database, string description, bool allowPartialBatchResumption, Action runAfterCompletion);
    private void ExecuteSingleBatchSynchronously(IList`1<T> src, Action`1<T> action, string description, DocumentDatabase database);
    private void WaitForBatchToCompletion(CountdownEvent completionEvent, List`1<ThreadTask> childTasks, Nullable`1<CancellationToken> workContextCancellationToken);
    private bool WaitForBatchAllowingPartialBatchResumption(CountdownEvent completionEvent, BatchStatistics batch, List`1<ThreadTask> childTasks, DocumentDatabase database);
}
public class Raven.Database.Impl.CachedDocument : object {
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Document>k__BackingField;
    public int Size { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public RavenJObject Document { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(RavenJObject value);
}
public class Raven.Database.Impl.Clustering.ClusterInspecter : object {
    private bool isRavenGenericServiceWorking;
    private bool checkedService;
    private static Regex cmdLineParser;
    private static ClusterInspecter();
    private static IntPtr OpenCluster(string lpszClusterName);
    private static bool CloseCluster(IntPtr hCluster);
    private static UInt32 GetNodeClusterState(string lpszNodeName, UInt32& lpcchClusterName);
    private static ClusterResourceState GetClusterResourceState(IntPtr hResource, string lpszNodeName, UInt32& lpcchNodeName, string lpszGroupName, UInt32& lpcchGroupName);
    private static NodeClusterState GetLocalNodeClusterState();
    private static IntPtr OpenLocalCluster();
    private static ClusterResourceState GetClusterResourceState(IntPtr hResource);
    private static UInt32 ResUtilEnumResources(IntPtr hSelf, string lpszResTypeName, EnumeratedResourceCallback pResCallBack, IntPtr pParameter);
    private static IntPtr LocalFree(IntPtr hMem);
    private static UIntPtr GetClusterResourceKey(IntPtr hResource, RegSam samDesired);
    private static long ClusterRegCloseKey(UIntPtr hKey);
    private static long ClusterRegOpenKey(UIntPtr hKey, string lpszSubKey, RegSam samDesired, UIntPtr& phkResult);
    private static IntPtr ResUtilGetSzValue(UIntPtr hkeyClusterKey, string pszValueName);
    public bool IsRavenRunningAsClusterGenericService();
    private UInt32 EnumResource(IntPtr hSelf, IntPtr hEnum, IntPtr pParameter);
    public static string GetExecutableOfService(string serviceName);
    public static string ParseExePath(string executableOfService);
}
public enum Raven.Database.Impl.Clustering.ClusterResourceState : Enum {
    public int value__;
    public static ClusterResourceState ClusterResourceStateUnknown;
    public static ClusterResourceState ClusterResourceInherited;
    public static ClusterResourceState ClusterResourceInitializing;
    public static ClusterResourceState ClusterResourceOnline;
    public static ClusterResourceState ClusterResourceOffline;
    public static ClusterResourceState ClusterResourceFailed;
    public static ClusterResourceState ClusterResourcePending;
    public static ClusterResourceState ClusterResourceOnlinePending;
    public static ClusterResourceState ClusterResourceOfflinePending;
}
public enum Raven.Database.Impl.Clustering.ErrorCodes : Enum {
    public int value__;
    public static ErrorCodes ERROR_SUCCESS;
    public static ErrorCodes ERROR_NO_MORE_ITEMS;
}
public enum Raven.Database.Impl.Clustering.NodeClusterState : Enum {
    public int value__;
    public static NodeClusterState ClusterStateNotInstalled;
    public static NodeClusterState ClusterStateNotConfigured;
    public static NodeClusterState ClusterStateNotRunning;
    public static NodeClusterState ClusterStateRunning;
}
public enum Raven.Database.Impl.Clustering.RegSam : Enum {
    public int value__;
    public static RegSam QueryValue;
    public static RegSam SetValue;
    public static RegSam CreateSubKey;
    public static RegSam EnumerateSubKeys;
    public static RegSam Notify;
    public static RegSam CreateLink;
    public static RegSam WOW64_32Key;
    public static RegSam WOW64_64Key;
    public static RegSam WOW64_Res;
    public static RegSam Read;
    public static RegSam Write;
    public static RegSam Execute;
    public static RegSam AllAccess;
}
public class Raven.Database.Impl.DatabaseBulkOperations : object {
    private DocumentDatabase database;
    private TransactionInformation transactionInformation;
    private CancellationTokenSource tokenSource;
    private CancellationTimeout timeout;
    public DatabaseBulkOperations(DocumentDatabase database, TransactionInformation transactionInformation, CancellationTokenSource tokenSource, CancellationTimeout timeout);
    public RavenJArray DeleteByIndex(string indexName, IndexQuery queryToDelete, BulkOperationOptions options, Action`1<BulkOperationProgress> reportProgress);
    public RavenJArray UpdateByIndex(string indexName, IndexQuery queryToUpdate, PatchRequest[] patchRequests, BulkOperationOptions options, Action`1<BulkOperationProgress> reportProgress);
    public RavenJArray UpdateByIndex(string indexName, IndexQuery queryToUpdate, ScriptedPatchRequest patch, BulkOperationOptions options, Action`1<BulkOperationProgress> reportProgress);
    private RavenJArray PerformBulkOperation(string index, IndexQuery indexQuery, BulkOperationOptions options, Func`3<string, TransactionInformation, object> batchOperation, Action`1<BulkOperationProgress> reportProgress);
    [CompilerGeneratedAttribute]
private object <DeleteByIndex>b__5_0(string docId, TransactionInformation tx);
}
public class Raven.Database.Impl.DocumentCacher : object {
    private InMemoryRavenConfiguration configuration;
    private MemoryCache cachedSerializedDocuments;
    private static ILog log;
    [ThreadStaticAttribute]
private static bool skipSetAndGetDocumentInCache;
    [ThreadStaticAttribute]
private static bool skipSetDocumentInCache;
    public DocumentCacher(InMemoryRavenConfiguration configuration);
    private static DocumentCacher();
    private MemoryCache CreateCache();
    public sealed virtual LowMemoryHandlerStatistics HandleLowMemory();
    public sealed virtual LowMemoryHandlerStatistics GetStats();
    public static IDisposable SkipSetAndGetDocumentsInDocumentCache();
    public static IDisposable SkipSetDocumentsInDocumentCache();
    public sealed virtual CachedDocument GetCachedDocument(string key, Etag etag, bool metadataOnly);
    public sealed virtual void SetCachedDocument(string key, Etag etag, RavenJObject doc, RavenJObject metadata, int size);
    public sealed virtual void RemoveCachedDocument(string key, Etag etag);
    public sealed virtual object GetStatistics();
    public sealed virtual void Dispose();
}
internal class Raven.Database.Impl.DocumentRetriever : object {
    private static ILog log;
    private IDictionary`2<string, JsonDocument> cache;
    private HashSet`1<string> loadedIdsForRetrieval;
    private HashSet`1<string> loadedIdsForFilter;
    private HashSet`1<string> loadedIdsForProjectionRetrievals;
    private HashSet`1<string> loadedIdsForProjectionFilter;
    private InMemoryRavenConfiguration configuration;
    private IStorageActionsAccessor actions;
    private OrderedPartCollection`1<AbstractReadTrigger> triggers;
    private Dictionary`2<string, RavenJToken> transformerParameters;
    private HashSet`1<string> itemsToInclude;
    private bool hasTransformer;
    private bool disableCache;
    public Etag Etag;
    public Dictionary`2<string, RavenJToken> TransformerParameters { get; }
    public HashSet`1<string> ItemsToInclude { get; }
    public DocumentRetriever(InMemoryRavenConfiguration configuration, IStorageActionsAccessor actions, OrderedPartCollection`1<AbstractReadTrigger> triggers, Dictionary`2<string, RavenJToken> transformerParameters, HashSet`1<string> itemsToInclude, bool hasTransformer);
    private static DocumentRetriever();
    public JsonDocument RetrieveDocumentForQuery(IndexQueryResult queryResult, IndexDefinition indexDefinition, FieldsToFetch fieldsToFetch, bool skipDuplicateCheck);
    public JsonDocument ExecuteReadTriggers(JsonDocument document, TransactionInformation transactionInformation, ReadOperation operation);
    private JsonDocument ExecuteReadTriggersOnRead(JsonDocument resultingDocument, TransactionInformation transactionInformation, ReadOperation operation);
    private JsonDocument RetrieveDocumentInternal(IndexQueryResult queryResult, HashSet`1<string> loadedIds, HashSet`1<string> loadedProjections, FieldsToFetch fieldsToFetch, IndexDefinition indexDefinition, bool skipDuplicateCheck);
    private static RavenJObject GetMetadata(JsonDocument doc);
    private JsonDocument GetDocumentWithCaching(IndexQueryResult iqr);
    private JsonDocument GetDocumentWithCaching(string key);
    public bool ShouldIncludeResultInQuery(IndexQueryResult arg, IndexDefinition indexDefinition, FieldsToFetch fieldsToFetch, bool skipDuplicateCheck);
    public T ProcessReadVetoes(T document, TransactionInformation transactionInformation, ReadOperation operation);
    public sealed virtual object Include(object maybeId);
    public object Include(string id);
    public object Include(IEnumerable`1<string> ids);
    public object Load(string id);
    public sealed virtual object Load(object maybeId);
    public Dictionary`2<string, RavenJToken> get_TransformerParameters();
    public HashSet`1<string> get_ItemsToInclude();
}
public class Raven.Database.Impl.DTC.ChangedDoc : object {
    public string transactionId;
    public Etag currentEtag;
    public Etag committedEtag;
}
internal class Raven.Database.Impl.DTC.DtcNotSupportedTransactionalState : InFlightTransactionalState {
    private string storageName;
    public DtcNotSupportedTransactionalState(string storageName, Func`6<string, Etag, RavenJObject, RavenJObject, TransactionInformation, PutResult> databasePut, Func`4<string, Etag, TransactionInformation, bool> databaseDelete);
    public virtual void Commit(string id);
    public virtual void Prepare(string id, Nullable`1<Guid> resourceManagerId, Byte[] recoveryInformation);
    public virtual void Rollback(string id);
    public virtual Etag AddDocumentInTransaction(string key, Etag etag, RavenJObject data, RavenJObject metadata, TransactionInformation transactionInformation, Etag committedEtag, IUuidGenerator uuidGenerator);
    public virtual void DeleteDocumentInTransaction(TransactionInformation transactionInformation, string key, Etag etag, Etag committedEtag, IUuidGenerator uuidGenerator);
    public virtual bool IsModified(string key);
    public virtual IInFlightStateSnapshot GetSnapshot();
    public virtual bool TryGet(string key, TransactionInformation transactionInformation, JsonDocument& document);
    public virtual bool TryGet(string key, TransactionInformation transactionInformation, JsonDocumentMetadata& document);
    public virtual bool HasTransaction(string txId);
}
public class Raven.Database.Impl.DTC.EmptyInFlightStateSnapshot : object {
    public static EmptyInFlightStateSnapshot Instance;
    private static EmptyInFlightStateSnapshot();
    public sealed virtual Func`2<TDocument, TDocument> GetNonAuthoritativeInformationBehavior(TransactionInformation tx, string key);
}
internal class Raven.Database.Impl.DTC.EsentInFlightTransactionalState : InFlightTransactionalState {
    private DocumentDatabase _database;
    private TransactionalStorage storage;
    private CommitTransactionGrbit txMode;
    private ConcurrentDictionary`2<string, EsentTransactionContext> transactionContexts;
    private long transactionContextNumber;
    private Timer timer;
    public EsentInFlightTransactionalState(DocumentDatabase database, TransactionalStorage storage, CommitTransactionGrbit txMode, Func`6<string, Etag, RavenJObject, RavenJObject, TransactionInformation, PutResult> databasePut, Func`4<string, Etag, TransactionInformation, bool> databaseDelete);
    public EsentTransactionContext CreateEsentTransactionContext();
    private void CleanupOldTransactions(object state);
    public virtual void Commit(string id);
    public virtual void Prepare(string id, Nullable`1<Guid> resourceManagerId, Byte[] recoveryInformation);
    public virtual void Rollback(string id);
    internal List`1<TransactionContextData> GetPreparedTransactions();
    public virtual IInFlightStateSnapshot GetSnapshot();
    public sealed virtual void Dispose();
}
public class Raven.Database.Impl.DTC.EsentTransactionContext : object {
    private IntPtr sessionContext;
    public ItemsToTouch ItemsToTouch;
    [CompilerGeneratedAttribute]
private List`1<Action> <ActionsAfterCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private Session <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlreadyInContext>k__BackingField;
    public List`1<Action> ActionsAfterCommit { get; private set; }
    public Session Session { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public Transaction Transaction { get; private set; }
    public bool AlreadyInContext { get; private set; }
    public EsentTransactionContext(Session session, IntPtr context, DateTime createdAt);
    [CompilerGeneratedAttribute]
public List`1<Action> get_ActionsAfterCommit();
    [CompilerGeneratedAttribute]
private void set_ActionsAfterCommit(List`1<Action> value);
    [CompilerGeneratedAttribute]
public Session get_Session();
    [CompilerGeneratedAttribute]
private void set_Session(Session value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
private void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
private void set_Transaction(Transaction value);
    [CompilerGeneratedAttribute]
public bool get_AlreadyInContext();
    [CompilerGeneratedAttribute]
private void set_AlreadyInContext(bool value);
    public IDisposable EnterSessionContext();
    public void AfterCommit(Action action);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <EnterSessionContext>b__23_1();
}
public interface Raven.Database.Impl.DTC.IInFlightStateSnapshot {
    public abstract virtual Func`2<TDocument, TDocument> GetNonAuthoritativeInformationBehavior(TransactionInformation tx, string key);
}
public class Raven.Database.Impl.DTC.InFlightStateSnapshot : object {
    private ImmutableDictionary`2<string, ChangedDoc> changedInTransaction;
    private ImmutableDictionary`2<string, TransactionState> transactionStates;
    public InFlightStateSnapshot(ImmutableDictionary`2<string, ChangedDoc> changedInTransaction, ImmutableDictionary`2<string, TransactionState> transactionStates);
    public sealed virtual Func`2<TDocument, TDocument> GetNonAuthoritativeInformationBehavior(TransactionInformation tx, string key);
}
public abstract class Raven.Database.Impl.DTC.InFlightTransactionalState : object {
    protected static ILog log;
    protected Func`6<string, Etag, RavenJObject, RavenJObject, TransactionInformation, PutResult> DatabasePut;
    protected Func`4<string, Etag, TransactionInformation, bool> DatabaseDelete;
    private bool replicationEnabled;
    private object modifyChangedInTransaction;
    protected ImmutableDictionary`2<string, ChangedDoc> changedInTransaction;
    private object modifyTransactionStates;
    protected ImmutableDictionary`2<string, TransactionState> transactionStates;
    protected ThreadLocal`1<string> currentlyCommittingTransaction;
    protected InFlightTransactionalState(Func`6<string, Etag, RavenJObject, RavenJObject, TransactionInformation, PutResult> databasePut, Func`4<string, Etag, TransactionInformation, bool> databaseDelete, bool replicationEnabled);
    private static InFlightTransactionalState();
    public object GetInFlightTransactionsInternalStateForDebugOnly();
    public virtual Etag AddDocumentInTransaction(string key, Etag etag, RavenJObject data, RavenJObject metadata, TransactionInformation transactionInformation, Etag committedEtag, IUuidGenerator uuidGenerator);
    public virtual void DeleteDocumentInTransaction(TransactionInformation transactionInformation, string key, Etag etag, Etag committedEtag, IUuidGenerator uuidGenerator);
    public virtual bool IsModified(string key);
    public abstract virtual IInFlightStateSnapshot GetSnapshot();
    public virtual void Rollback(string id);
    public abstract virtual void Commit(string id);
    public abstract virtual void Prepare(string id, Nullable`1<Guid> resourceManagerId, Byte[] recoveryInformation);
    private Etag AddToTransactionState(string key, Etag etag, TransactionInformation transactionInformation, Etag committedEtag, DocumentInTransactionData item);
    private static void EnsureValidEtag(string key, Etag etag, Etag committedEtag, DocumentInTransactionData currentTxVal);
    public virtual bool TryGet(string key, TransactionInformation transactionInformation, JsonDocument& document);
    public virtual bool TryGet(string key, TransactionInformation transactionInformation, JsonDocumentMetadata& document);
    private bool TryGetInternal(string key, TransactionInformation transactionInformation, Func`3<string, DocumentInTransactionData, T> createDoc, T& document);
    public virtual bool HasTransaction(string txId);
    protected ItemsToTouch RunOperationsInTransaction(string id, List`1& changes);
    public bool RecoverTransaction(string id, IEnumerable`1<DocumentInTransactionData> changes);
    public sealed virtual void Dispose();
}
public class Raven.Database.Impl.DTC.ItemsToTouch : object {
    public HashSet`1<string> Documents;
    public HashSet`1<string> DocumentTombstones;
}
public class Raven.Database.Impl.DTC.TransactionState : object {
    public List`1<DocumentInTransactionData> Changes;
    [CLSCompliantAttribute("False")]
public Reference`1 modreq(System.Runtime.CompilerServices.IsVolatile) LastSeen;
    private TimeSpan timeout;
    public TimeSpan Timeout { get; public set; }
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
}
public class Raven.Database.Impl.DummyUuidGenerator : object {
    private byte cur;
    public long LastDocumentTransactionEtag { get; }
    public sealed virtual long get_LastDocumentTransactionEtag();
    public sealed virtual Etag CreateSequentialUuid(UuidType type);
}
public class Raven.Database.Impl.ExceptionAggregator : object {
    private ILog log;
    private string errorMsg;
    private LogLevel level;
    private ConcurrentSet`1<Exception> list;
    public ExceptionAggregator(string errorMsg);
    public ExceptionAggregator(ILog log, string errorMsg, LogLevel level);
    public void Execute(Action action);
    public void ThrowIfNeeded();
    [CompilerGeneratedAttribute]
private string <ThrowIfNeeded>b__7_0();
}
public class Raven.Database.Impl.Generators.JsonCodeGenerator : object {
    private string language;
    private Lazy`1<IDictionary`2<Type, FieldType>> _knownTypes;
    private IDictionary`2<string, ClassType> _generatedTypes;
    private static string codeLayout;
    internal IDictionary`2<Type, FieldType> KnownTypes { get; }
    public JsonCodeGenerator(string lang);
    internal IDictionary`2<Type, FieldType> get_KnownTypes();
    private static IDictionary`2<Type, FieldType> InitializeKnownTypes();
    public string Execute(JsonDocument document);
    private string GenerateClassCodeFromSpec(IEnumerable`1<ClassType> classes);
    internal IEnumerable`1<ClassType> GenerateClassesTypesFromObject(string name, RavenJObject object);
    internal ClassType GenerateClassTypesFromObject(string name, RavenJObject object);
    private ClassType IncludeGeneratedClass(ClassType clazz);
    private FieldType GuessTokenTypeFromArray(string name, RavenJArray array);
    private FieldType GetTokenTypeFromPrimitiveType(RavenJToken token);
    private FieldType GuessTokenTypeFromContent(RavenJToken token);
}
public interface Raven.Database.Impl.IDocumentCacher {
    public abstract virtual CachedDocument GetCachedDocument(string key, Etag etag, bool metadataOnly);
    public abstract virtual void SetCachedDocument(string key, Etag etag, RavenJObject doc, RavenJObject metadata, int size);
    public abstract virtual void RemoveCachedDocument(string key, Etag etag);
    public abstract virtual object GetStatistics();
}
public interface Raven.Database.Impl.IUuidGenerator {
    public long LastDocumentTransactionEtag { get; }
    public abstract virtual long get_LastDocumentTransactionEtag();
    public abstract virtual Etag CreateSequentialUuid(UuidType type);
}
public class Raven.Database.Impl.NullDocumentCacher : object {
    public sealed virtual void Dispose();
    public sealed virtual CachedDocument GetCachedDocument(string key, Etag etag, bool metadataOnly);
    public sealed virtual void SetCachedDocument(string key, Etag etag, RavenJObject doc, RavenJObject metadata, int size);
    public sealed virtual void RemoveCachedDocument(string key, Etag etag);
    public sealed virtual object GetStatistics();
}
public class Raven.Database.Impl.PutSerialLock : object {
    private object locker;
    private TimeSpan lockDuration;
    public PutSerialLock(InMemoryRavenConfiguration configuration);
    public IDisposable Lock();
    public IDisposable TryLock(int timeoutInMilliseconds);
    [CompilerGeneratedAttribute]
private void <Lock>b__3_0();
    [CompilerGeneratedAttribute]
private void <TryLock>b__4_0();
}
public abstract class Raven.Database.Indexing.AbstractIndexingExecuter : object {
    protected WorkContext context;
    protected IndexReplacer indexReplacer;
    protected TaskScheduler scheduler;
    protected ILog Log;
    protected ITransactionalStorage transactionalStorage;
    protected int workCounter;
    protected int lastFlushedWorkCounter;
    protected BaseBatchSizeAutoTuner autoTuner;
    protected ConcurrentDictionary`2<int, Index> currentlyProcessedIndexes;
    public bool ShouldRun { get; }
    protected AbstractIndexingExecuter(WorkContext context, IndexReplacer indexReplacer);
    public void Execute();
    protected bool IsOperationCanceledException(Exception exception);
    protected bool HandleIfOutOfMemory(Exception exception, OutOfMemoryDetails details);
    public abstract virtual bool get_ShouldRun();
    protected virtual bool ExecuteTasks();
    protected virtual void CleanupPrefetchers();
    protected virtual void CleanupScheduledReductions();
    protected virtual void Dispose();
    protected virtual void Init();
    protected string GetIndexName(int indexId);
    private void HandleSystemOutOfMemoryException(Exception oome);
    protected void HandleRavenOutOfMemoryException(Exception exception, OutOfMemoryDetails details);
    private void FlushIndexes();
    protected abstract virtual void FlushAllIndexes();
    protected abstract virtual void UpdateStalenessMetrics(int staleCount);
    protected bool ExecuteIndexing(bool isIdle, Boolean& onlyFoundIdleWork);
    protected abstract virtual bool ShouldSkipIndex(Index index);
    public Index[] GetCurrentlyProcessingIndexes();
    protected abstract virtual IndexToWorkOn GetIndexToWorkOn(IndexStats indexesStat);
    protected abstract virtual bool IsIndexStale(IndexStats indexesStat, IStorageActionsAccessor actions, bool isIdle, Reference`1<bool> onlyFoundIdleWork);
    protected abstract virtual void ExecuteIndexingWork(IList`1<IndexToWorkOn> indexesToWorkOn);
    protected abstract virtual bool IsValidIndex(IndexStats indexesStat);
    [CompilerGeneratedAttribute]
private void <Execute>b__10_0();
}
public class Raven.Database.Indexing.AllDocumentsLuceneASTNode : LuceneASTNodeBase {
    public IEnumerable`1<LuceneASTNodeBase> Children { get; }
    [IteratorStateMachineAttribute("Raven.Database.Indexing.AllDocumentsLuceneASTNode/<get_Children>d__1")]
public virtual IEnumerable`1<LuceneASTNodeBase> get_Children();
    public virtual Query ToQuery(LuceneASTQueryConfiguration configuration);
    public virtual string ToString();
}
public class Raven.Database.Indexing.Analyzers.RavenStandardAnalyzer : StandardAnalyzer {
    private Version matchVersion;
    public RavenStandardAnalyzer(Version matchVersion);
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
}
public class Raven.Database.Indexing.Analyzers.RavenStandardFilter : TokenFilter {
    private TokenStream innerInputStream;
    private static string APOSTROPHE_TYPE;
    private static string ACRONYM_TYPE;
    private ITypeAttribute typeAtt;
    private ITermAttribute termAtt;
    private static bool isAsciiCasingSameAsInvariant;
    private static TextInfo invariantTextInfo;
    private CharArraySet stopWords;
    public RavenStandardFilter(TokenStream input);
    private static RavenStandardFilter();
    public virtual bool IncrementToken();
    protected char ToLower(char c);
    public bool Reset(TextReader reader);
}
internal class Raven.Database.Indexing.AnonymousObjectToLuceneDocumentConverter : object {
    private AbstractViewGenerator viewGenerator;
    private ILog log;
    private DocumentDatabase database;
    private IndexDefinition indexDefinition;
    private List`1<int> multipleItemsSameFieldCount;
    private Dictionary`2<FieldCacheKey, Field> fieldsCache;
    private Dictionary`2<FieldCacheKey, NumericField> numericFieldsCache;
    private static FieldCacheKeyEqualityComparer Comparer;
    public AnonymousObjectToLuceneDocumentConverter(DocumentDatabase database, IndexDefinition indexDefinition, AbstractViewGenerator viewGenerator, ILog log);
    private static AnonymousObjectToLuceneDocumentConverter();
    public IEnumerable`1<AbstractField> Index(object val, PropertyAccessor accessor, Store defaultStorage);
    public IEnumerable`1<AbstractField> Index(RavenJObject document, Store defaultStorage);
    private static object GetPropertyValue(RavenJToken property);
    public IEnumerable`1<AbstractField> CreateFields(string name, object value, Store defaultStorage, bool nestedArray, TermVector defaultTermVector, Nullable`1<Index> analyzed);
    [IteratorStateMachineAttribute("Raven.Database.Indexing.AnonymousObjectToLuceneDocumentConverter/<CreateRegularFields>d__12")]
private IEnumerable`1<AbstractField> CreateRegularFields(string name, object value, Store defaultStorage, bool nestedArray, TermVector defaultTermVector, Nullable`1<Index> analyzed);
    private void CheckIfSortOptionsAndInputTypeMatch(string name, object value);
    private static object GetNullValueForSorting(Nullable`1<SortOptions> sortOptions);
    [IteratorStateMachineAttribute("Raven.Database.Indexing.AnonymousObjectToLuceneDocumentConverter/<CreateNumericFieldWithCaching>d__15")]
private IEnumerable`1<AbstractField> CreateNumericFieldWithCaching(string name, object value, Store defaultStorage, TermVector termVector);
    public static bool ShouldTreatAsEnumerable(object itemsToIndex);
    private Field CreateBinaryFieldWithCaching(string name, Byte[] value, Store store, Index index, TermVector termVector);
    private Field CreateFieldWithCaching(string name, string value, Store store, Index index, TermVector termVector);
    private static bool CanCreateFieldsForNestedArray(object value, Nullable`1<FieldIndexing> fieldIndexing);
}
public class Raven.Database.Indexing.BackgroundTaskExecuter : object {
    public static IBackgroundTaskExecuter Instance;
    private static BackgroundTaskExecuter();
}
public abstract class Raven.Database.Indexing.BaseBatchSizeAutoTuner : object {
    protected WorkContext context;
    private int currentNumber;
    private DateTime lastIncrease;
    private ConcurrentDictionary`2<Guid, long> _currentlyUsedBatchSizesInBytes;
    private int maximumSizeAllowedToFetchFromStorageInMb;
    [CompilerGeneratedAttribute]
private TimeSpan <FetchingDocumentsFromDiskTimeout>k__BackingField;
    public int NumberOfItemsToProcessInSingleBatch { get; public set; }
    public TimeSpan FetchingDocumentsFromDiskTimeout { get; private set; }
    public long MaximumSizeAllowedToFetchFromStorageInBytes { get; }
    public bool IsProcessingUsingTooMuchMemory { get; }
    public int InitialNumberOfItems { get; }
    protected int MaxNumberOfItems { get; }
    protected int CurrentNumberOfItems { get; protected set; }
    protected int LastAmountOfItemsToRemember { get; protected set; }
    public ConcurrentDictionary`2<Guid, long> CurrentlyUsedBatchSizesInBytes { get; }
    protected string Name { get; }
    protected BaseBatchSizeAutoTuner(WorkContext context);
    public sealed virtual LowMemoryHandlerStatistics HandleLowMemory();
    public sealed virtual void HandleTransactionalStorageNotification();
    public virtual LowMemoryHandlerStatistics GetStats();
    public int get_NumberOfItemsToProcessInSingleBatch();
    public void set_NumberOfItemsToProcessInSingleBatch(int value);
    public void AutoThrottleBatchSize(int amountOfItemsToProcess, long size, TimeSpan processingDuration, bool skipIncreasingBatchSize);
    private bool ConsiderIncreasingBatchSize(int amountOfItemsToProcess, long size, TimeSpan processingDuration);
    [CompilerGeneratedAttribute]
public TimeSpan get_FetchingDocumentsFromDiskTimeout();
    [CompilerGeneratedAttribute]
private void set_FetchingDocumentsFromDiskTimeout(TimeSpan value);
    public long get_MaximumSizeAllowedToFetchFromStorageInBytes();
    public bool get_IsProcessingUsingTooMuchMemory();
    private bool ReduceBatchSizeIfCloseToMemoryCeiling(bool forceReducing);
    private bool ConsiderDecreasingBatchSize(int amountOfItemsToProcess, TimeSpan processingDuration);
    public void DecreaseBatchSize();
    private int CalculateReductionOfItemsInSingleBatch();
    public void HandleOutOfMemory();
    public abstract virtual int get_InitialNumberOfItems();
    protected abstract virtual int get_MaxNumberOfItems();
    protected abstract virtual int get_CurrentNumberOfItems();
    protected abstract virtual void set_CurrentNumberOfItems(int value);
    protected abstract virtual int get_LastAmountOfItemsToRemember();
    protected abstract virtual void set_LastAmountOfItemsToRemember(int value);
    public ConcurrentDictionary`2<Guid, long> get_CurrentlyUsedBatchSizesInBytes();
    protected abstract virtual void RecordAmountOfItems(int numberOfItems);
    protected abstract virtual IEnumerable`1<int> GetLastAmountOfItems();
    protected abstract virtual string get_Name();
    [CompilerGeneratedAttribute]
private bool <ConsiderIncreasingBatchSize>b__13_0(int x);
    [CompilerGeneratedAttribute]
private bool <ConsiderDecreasingBatchSize>b__23_0(int x);
}
public class Raven.Database.Indexing.Collation.AbstractCultureCollationAnalyzer : CollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.CollationAnalyzer : Analyzer {
    private CultureInfo cultureInfo;
    public CollationAnalyzer(CultureInfo cultureInfo);
    protected void Init(CultureInfo ci);
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
}
public class Raven.Database.Indexing.Collation.CollationKeyFilter : TokenFilter {
    private TermAttribute termAtt;
    private CultureInfo cultureInfo;
    public CollationKeyFilter(TokenStream input, CultureInfo cultureInfo);
    public virtual bool IncrementToken();
}
public class Raven.Database.Indexing.Collation.Cultures.AfCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.AmCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.ArCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.ArnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.AsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.AzCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.BaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.BeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.BgCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.BnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.BoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.BrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.BsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.CaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.CoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.CsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.CyCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.DaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.DeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.DsbCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.DvCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.ElCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.EnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.EsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.EtCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.EuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.FaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.FiCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.FilCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.FoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.FrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.FyCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.GaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.GdCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.GlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.GswCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.GuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.HaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.HeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.HiCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.HrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.HsbCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.HuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.HyCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.IdCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.IgCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.IiCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.IsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.ItCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.IuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.IvCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.JaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.KaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.KkCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.KlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.KmCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.KnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.KoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.KokCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.KyCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.LbCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.LoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.LtCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.LvCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.MiCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.MkCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.MlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.MnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.MohCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.MrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.MsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.MtCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.NbCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.NeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.NlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.NnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.NsoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.OcCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.OrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.PaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.PlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.PrsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.PsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.PtCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.QutCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.QuzCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.RmCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.RoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.RuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.RwCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SahCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SiCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SkCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SlCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SmaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SmjCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SmnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SmsCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SqCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SvCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SwCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.SyrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.TaCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.TeCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.TgCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.ThCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.TkCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.TnCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.TrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.TtCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.TzmCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.UgCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.UkCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.UrCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.UzCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.ViCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.WoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.XhCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.YoCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.ZhCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.Cultures.ZuCollationAnalyzer : AbstractCultureCollationAnalyzer {
}
public class Raven.Database.Indexing.Collation.IndexableBinaryStringTools_UsingArrays : object {
    private static CodingCase[] CODING_CASES;
    private static IndexableBinaryStringTools_UsingArrays();
    public static int GetEncodedLength(IList`1<byte> original);
    public static int GetDecodedLength(IList`1<char> encoded);
    public static void Encode(Byte[] input, Char[] output);
    private static void Decode(Char[] input, Byte[] output);
    public static Byte[] Decode(Char[] input);
    public static Char[] Encode(Byte[] input);
}
public class Raven.Database.Indexing.CurrentIndexingScope : object {
    private ILog log;
    private DocumentDatabase database;
    private string index;
    [CompilerGeneratedAttribute]
private int <LoadDocumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <LoadDocumentDuration>k__BackingField;
    [ThreadStaticAttribute]
private static CurrentIndexingScope current;
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private object <Source>k__BackingField;
    private IDictionary`2<string, HashSet`1<string>> referencedDocuments;
    private IDictionary`2<string, Etag> referencesEtags;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, object> docsCache;
    public int LoadDocumentCount { get; private set; }
    public Stopwatch LoadDocumentDuration { get; private set; }
    public static CurrentIndexingScope Current { get; public set; }
    public IDictionary`2<string, HashSet`1<string>> ReferencedDocuments { get; }
    public IDictionary`2<string, Etag> ReferencesEtags { get; }
    [DynamicAttribute]
public object Source { get; public set; }
    public CurrentIndexingScope(DocumentDatabase database, string index);
    [CompilerGeneratedAttribute]
public int get_LoadDocumentCount();
    [CompilerGeneratedAttribute]
private void set_LoadDocumentCount(int value);
    [CompilerGeneratedAttribute]
public Stopwatch get_LoadDocumentDuration();
    [CompilerGeneratedAttribute]
private void set_LoadDocumentDuration(Stopwatch value);
    public static CurrentIndexingScope get_Current();
    public static void set_Current(CurrentIndexingScope value);
    public IDictionary`2<string, HashSet`1<string>> get_ReferencedDocuments();
    public IDictionary`2<string, Etag> get_ReferencesEtags();
    [CompilerGeneratedAttribute]
public object get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(object value);
    public object LoadDocument(string key);
    public sealed virtual void Dispose();
}
internal class Raven.Database.Indexing.CurrentTransformationScope : object {
    private DocumentDatabase database;
    private DocumentRetriever retriever;
    [ThreadStaticAttribute]
private static CurrentTransformationScope current;
    private CurrentTransformationScope old;
    private HashSet`1<string> nested;
    public static CurrentTransformationScope Current { get; }
    public DocumentDatabase Database { get; }
    public DocumentRetriever Retriever { get; }
    public HashSet`1<string> Nested { get; }
    public CurrentTransformationScope(DocumentDatabase database, DocumentRetriever documentRetriever);
    public static CurrentTransformationScope get_Current();
    public sealed virtual void Dispose();
    public DocumentDatabase get_Database();
    public DocumentRetriever get_Retriever();
    public HashSet`1<string> get_Nested();
}
public class Raven.Database.Indexing.DefaultBackgroundTaskExecuter : object {
    private static ILog logger;
    private double maxNumberOfParallelProcessingTasksRatio;
    public double MaxNumberOfParallelProcessingTasksRatio { get; }
    private static DefaultBackgroundTaskExecuter();
    public sealed virtual IList`1<TResult> Apply(WorkContext context, IEnumerable`1<T> source, Func`2<T, TResult> func);
    public sealed virtual void ExecuteAllBuffered(WorkContext context, IList`1<T> source, Action`1<IEnumerator`1<T>> action);
    [IteratorStateMachineAttribute("Raven.Database.Indexing.DefaultBackgroundTaskExecuter/<Yield>d__5`1")]
private IEnumerator`1<T> Yield(IList`1<T> source, int start, int end);
    public sealed virtual void ExecuteAll(WorkContext context, IList`1<T> source, Action`2<T, long> action);
    [IteratorStateMachineAttribute("Raven.Database.Indexing.DefaultBackgroundTaskExecuter/<Partition>d__7`1")]
private static IEnumerable`1<IList`1<T>> Partition(IList`1<T> source, int size);
    public sealed virtual void ExecuteAllInterleaved(WorkContext context, IList`1<T> result, Action`1<T> action);
    public sealed virtual void HandleHighCpuUsage();
    public sealed virtual void HandleLowCpuUsage();
    public sealed virtual double get_MaxNumberOfParallelProcessingTasksRatio();
}
public class Raven.Database.Indexing.DefaultIndexingClassifier : object {
    private Dictionary`2<Etag, List`1<IndexToWorkOn>> empty;
    public sealed virtual Dictionary`2<Etag, List`1<IndexToWorkOn>> GroupMapIndexes(IList`1<IndexToWorkOn> indexes);
}
public class Raven.Database.Indexing.DynamicGetter : MulticastDelegate {
    public DynamicGetter(object object, IntPtr method);
    public virtual object Invoke(object target);
    public virtual IAsyncResult BeginInvoke(object target, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[JsonObjectAttribute]
internal class Raven.Database.Indexing.DynamicLuceneOrParentDocumntObject : DynamicJsonObject {
    private DocumentRetriever retriever;
    [DynamicAttribute]
private object parentDoc;
    public DynamicLuceneOrParentDocumntObject(DocumentRetriever retriever, RavenJObject inner);
    public virtual void WriteTo(JsonWriter writer);
    public virtual object GetValue(string name);
    private bool TryLoadParentDoc();
}
public class Raven.Database.Indexing.ErrorLoggingConcurrentMergeScheduler : ConcurrentMergeScheduler {
    private static ILog log;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    public string IndexName { get; }
    public ErrorLoggingConcurrentMergeScheduler(string indexName);
    private static ErrorLoggingConcurrentMergeScheduler();
    [CompilerGeneratedAttribute]
public string get_IndexName();
    protected virtual void HandleMergeException(Exception exc);
}
public class Raven.Database.Indexing.FieldLuceneASTNode : LuceneASTNodeBase {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private LuceneASTNodeBase <Node>k__BackingField;
    public string FieldName { get; public set; }
    public LuceneASTNodeBase Node { get; public set; }
    public IEnumerable`1<LuceneASTNodeBase> Children { get; }
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public LuceneASTNodeBase get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(LuceneASTNodeBase value);
    [IteratorStateMachineAttribute("Raven.Database.Indexing.FieldLuceneASTNode/<get_Children>d__9")]
public virtual IEnumerable`1<LuceneASTNodeBase> get_Children();
    public virtual Query ToQuery(LuceneASTQueryConfiguration configuration);
    public virtual string ToString();
}
public class Raven.Database.Indexing.FieldsToFetch : object {
    private bool isDistinct;
    private string additionalField;
    private HashSet`1<string> fieldsToFetch;
    private HashSet`1<string> ensuredFieldNames;
    [CompilerGeneratedAttribute]
private bool <FetchAllStoredFields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDistinctQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsProjection>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexQuery <Query>k__BackingField;
    public bool FetchAllStoredFields { get; public set; }
    public bool IsDistinctQuery { get; private set; }
    public bool IsProjection { get; private set; }
    public bool HasExplicitFieldsToFetch { get; }
    public IEnumerable`1<string> Fields { get; }
    public IndexQuery Query { get; private set; }
    public FieldsToFetch(IndexQuery query, string additionalField);
    public FieldsToFetch(String[] fieldsToFetch, bool isDistinct, string additionalField);
    [CompilerGeneratedAttribute]
public bool get_FetchAllStoredFields();
    [CompilerGeneratedAttribute]
public void set_FetchAllStoredFields(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDistinctQuery();
    [CompilerGeneratedAttribute]
private void set_IsDistinctQuery(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsProjection();
    [CompilerGeneratedAttribute]
private void set_IsProjection(bool value);
    public bool get_HasExplicitFieldsToFetch();
    [IteratorStateMachineAttribute("Raven.Database.Indexing.FieldsToFetch/<get_Fields>d__21")]
public IEnumerable`1<string> get_Fields();
    [CompilerGeneratedAttribute]
public IndexQuery get_Query();
    [CompilerGeneratedAttribute]
private void set_Query(IndexQuery value);
    [IteratorStateMachineAttribute("Raven.Database.Indexing.FieldsToFetch/<GetFieldsToReturn>d__26")]
private IEnumerable`1<string> GetFieldsToReturn();
    public FieldsToFetch CloneWith(String[] newFieldsToFetch);
    public void EnsureHasField(string ensuredFieldName);
    public bool HasField(string name);
}
public class Raven.Database.Indexing.FilteredDocument : object {
    [CompilerGeneratedAttribute]
private string <__document_id>k__BackingField;
    [CLSCompliantAttribute("False")]
public string __document_id { get; public set; }
    public FilteredDocument(IJsonDocumentMetadata doc);
    [CompilerGeneratedAttribute]
public string get___document_id();
    [CompilerGeneratedAttribute]
public void set___document_id(string value);
}
public class Raven.Database.Indexing.GatherAllCollector : Collector {
    private int _docBase;
    private List`1<int> documents;
    public bool AcceptsDocsOutOfOrder { get; }
    public List`1<int> Documents { get; }
    public virtual void SetScorer(Scorer scorer);
    public virtual void Collect(int doc);
    public virtual void SetNextReader(IndexReader reader, int docBase);
    public virtual bool get_AcceptsDocsOutOfOrder();
    public List`1<int> get_Documents();
    public TopDocs ToTopDocs();
}
public interface Raven.Database.Indexing.IBackgroundTaskExecuter {
    public double MaxNumberOfParallelProcessingTasksRatio { get; }
    public abstract virtual IList`1<TResult> Apply(WorkContext context, IEnumerable`1<T> source, Func`2<T, TResult> func);
    public abstract virtual double get_MaxNumberOfParallelProcessingTasksRatio();
    public abstract virtual void ExecuteAllBuffered(WorkContext context, IList`1<T> source, Action`1<IEnumerator`1<T>> action);
    public abstract virtual void ExecuteAllInterleaved(WorkContext context, IList`1<T> result, Action`1<T> action);
    public abstract virtual void ExecuteAll(WorkContext context, IList`1<T> source, Action`2<T, long> action);
}
public interface Raven.Database.Indexing.IIndexExtension {
    public string Name { get; }
    public abstract virtual void OnDocumentsIndexed(IEnumerable`1<Document> documents, Analyzer searchAnalyzer);
    public abstract virtual string get_Name();
}
public interface Raven.Database.Indexing.IIndexingClassifier {
    public abstract virtual Dictionary`2<Etag, List`1<IndexToWorkOn>> GroupMapIndexes(IList`1<IndexToWorkOn> indexes);
}
public class Raven.Database.Indexing.IndependentBatchSizeAutoTuner : BaseBatchSizeAutoTuner {
    [CompilerGeneratedAttribute]
private PrefetchingUser <User>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentNumberOfItems>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastAmountOfItemsToRemember>k__BackingField;
    private int lastAmount;
    public PrefetchingUser User { get; public set; }
    public int InitialNumberOfItems { get; }
    protected int MaxNumberOfItems { get; }
    protected int CurrentNumberOfItems { get; protected set; }
    protected int LastAmountOfItemsToRemember { get; protected set; }
    protected string Name { get; }
    public IndependentBatchSizeAutoTuner(WorkContext context, PrefetchingUser user);
    [CompilerGeneratedAttribute]
public PrefetchingUser get_User();
    [CompilerGeneratedAttribute]
public void set_User(PrefetchingUser value);
    private void InstallGauges();
    public virtual int get_InitialNumberOfItems();
    protected virtual int get_MaxNumberOfItems();
    [CompilerGeneratedAttribute]
protected virtual int get_CurrentNumberOfItems();
    [CompilerGeneratedAttribute]
protected virtual void set_CurrentNumberOfItems(int value);
    [CompilerGeneratedAttribute]
protected virtual int get_LastAmountOfItemsToRemember();
    [CompilerGeneratedAttribute]
protected virtual void set_LastAmountOfItemsToRemember(int value);
    protected virtual void RecordAmountOfItems(int numberOfItems);
    [IteratorStateMachineAttribute("Raven.Database.Indexing.IndependentBatchSizeAutoTuner/<GetLastAmountOfItems>d__20")]
protected virtual IEnumerable`1<int> GetLastAmountOfItems();
    protected virtual string get_Name();
    [CompilerGeneratedAttribute]
private int <InstallGauges>b__5_0();
    [CompilerGeneratedAttribute]
private int <InstallGauges>b__5_1();
    [CompilerGeneratedAttribute]
private int <InstallGauges>b__5_2();
}
public abstract class Raven.Database.Indexing.Index : object {
    protected static ILog logIndexing;
    protected static ILog logQuerying;
    private static long WriteErrorsLimit;
    private long writeErrors;
    private static long OutOfMemoryErrorsLimit;
    private long indexingOutOfMemoryErrors;
    private long reducingOutOfMemoryErrors;
    private static long ErrorsLimit;
    private long errors;
    private List`1<Document> currentlyIndexDocuments;
    protected Directory directory;
    protected IndexDefinition indexDefinition;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) waitReason;
    private long flushSize;
    private int maxActualIndexOutput;
    [CompilerGeneratedAttribute]
private IndexingPriority <Priority>k__BackingField;
    private Nullable`1<DateTime> lastQueryTime;
    private ConcurrentDictionary`2<string, IIndexExtension> indexExtensions;
    internal int indexId;
    private AbstractViewGenerator viewGenerator;
    protected WorkContext context;
    private object writeLock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed;
    private RavenIndexWriter indexWriter;
    private SnapshotDeletionPolicy snapshotter;
    private IndexSearcherHolder currentIndexSearcherHolder;
    private ConcurrentDictionary`2<string, IndexingPerformanceStats> currentlyIndexing;
    private ConcurrentQueue`1<IndexingPerformanceStats> indexingPerformanceStats;
    private static StopAnalyzer stopAnalyzer;
    private bool forceWriteToDisk;
    private bool indexIsBeingWatched;
    private TaskCompletionSource`1<object> indexindDone;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractAnalyzerGenerator> <AnalyzerGenerators>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastIndexTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <PreviousIndexTime>k__BackingField;
    [CLSCompliantAttribute("False")]
public Boolean modreq(System.Runtime.CompilerServices.IsVolatile) IsMapIndexingInProgress;
    private DateTime _indexCreationTime;
    internal bool FailedToSetIndexStateToError;
    public long OutOfMemoryErrorsCount { get; }
    public IndexingPriority Priority { get; public set; }
    public int IndexId { get; }
    public AbstractViewGenerator ViewGenerator { get; }
    public Task NextIndexingRound { get; }
    [ImportManyAttribute]
public OrderedPartCollection`1<AbstractAnalyzerGenerator> AnalyzerGenerators { get; public set; }
    public bool IsMapReduce { get; }
    public Nullable`1<DateTime> LastQueryTime { get; }
    public DateTime LastIndexTime { get; public set; }
    protected DateTime PreviousIndexTime { get; protected set; }
    public string IsOnRam { get; }
    public string PublicName { get; }
    public bool IsTestIndex { get; }
    public Nullable`1<int> MaxIndexOutputsPerDocument { get; }
    [CLSCompliantAttribute("False")]
protected Index(Directory directory, int id, IndexDefinition indexDefinition, AbstractViewGenerator viewGenerator, WorkContext context);
    private static Index();
    public long get_OutOfMemoryErrorsCount();
    [CompilerGeneratedAttribute]
public IndexingPriority get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(IndexingPriority value);
    public int get_IndexId();
    public AbstractViewGenerator get_ViewGenerator();
    public Task get_NextIndexingRound();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractAnalyzerGenerator> get_AnalyzerGenerators();
    [CompilerGeneratedAttribute]
public void set_AnalyzerGenerators(OrderedPartCollection`1<AbstractAnalyzerGenerator> value);
    public abstract virtual bool get_IsMapReduce();
    public Nullable`1<DateTime> get_LastQueryTime();
    [CompilerGeneratedAttribute]
public DateTime get_LastIndexTime();
    [CompilerGeneratedAttribute]
public void set_LastIndexTime(DateTime value);
    [CompilerGeneratedAttribute]
protected DateTime get_PreviousIndexTime();
    [CompilerGeneratedAttribute]
protected void set_PreviousIndexTime(DateTime value);
    public string get_IsOnRam();
    public string get_PublicName();
    public bool get_IsTestIndex();
    public Nullable`1<int> get_MaxIndexOutputsPerDocument();
    protected IndexingPerformanceStats RecordCurrentBatch(string indexingStep, string operation, int itemsCount);
    protected void BatchCompleted(string indexingStep, string operation, int inputCount, int outputCount, List`1<BasePerformanceStats> operationStats);
    public void AddIndexingPerformanceStats(IndexingPerformanceStats stats);
    public sealed virtual void Dispose();
    public void EnsureIndexWriter(bool isDisposing);
    public void Flush(Etag highestETag, bool forceFlush, bool considerLastCommitedTime);
    public void MergeSegments();
    public abstract virtual IndexingPerformanceStats IndexDocuments(AbstractViewGenerator viewGenerator, IndexingBatch batch, IStorageActionsAccessor actions, DateTime minimumTimestamp, CancellationToken token);
    protected virtual IndexQueryResult RetrieveDocument(Document document, FieldsToFetch fieldsToFetch, ScoreDoc score);
    public static RavenJObject CreateDocumentFromFields(Document document, FieldsToFetch fieldsToFetch);
    protected static void AddFieldsToDocument(Document document, HashSet`1<string> fieldNames, RavenJObject documentFromFields);
    protected void InvokeOnIndexEntryDeletedOnAllBatchers(List`1<AbstractIndexUpdateTriggerBatcher> batchers, Term term);
    private static RavenJToken CreateProperty(Field fld, Document document);
    protected void Write(Func`4<RavenIndexWriter, Analyzer, IndexingWorkStats, IndexedItemsInfo> action, List`1<PerformanceStats> writePerformanceStats);
    private IndexSegmentsInfo GetCurrentSegmentsInfo();
    protected abstract virtual void HandleCommitPoints(IndexedItemsInfo itemsInfo, IndexSegmentsInfo segmentsInfo);
    protected void UpdateIndexingStats(WorkContext workContext, IndexingWorkStats stats);
    private void CreateIndexWriter(bool isDisposing);
    internal void WriteInMemoryIndexToDiskIfNecessary(Etag highestETag, bool isDisposing);
    protected abstract virtual bool IsUpToDateEnoughToWriteToDisk(Etag highestETag);
    public RavenPerFieldAnalyzerWrapper CreateAnalyzer(Analyzer defaultAnalyzer, ICollection`1<Action> toDispose, bool forQuerying);
    protected IEnumerable`1<object> RobustEnumerationIndex(IEnumerator`1<object> input, List`1<IndexingFunc> funcs, IndexingWorkStats stats, Stopwatch linqExecutionDuration);
    protected IEnumerable`1<object> RobustEnumerationIndex(IEnumerator`1<object> input, List`1<IndexingFunc> funcs, IndexingWorkStats stats, Action`2& onErrorFunc, Stopwatch linqExecutionDuration);
    protected IEnumerable`1<object> RobustEnumerationReduce(IEnumerator`1<object> input, IndexingFunc func, IndexingWorkStats stats, Stopwatch linqExecutionDuration);
    protected IEnumerable`1<object> RobustEnumerationReduceDuringMapPhase(IEnumerator`1<object> input, IndexingFunc func, Stopwatch reduceDuringMapLinqExecution);
    private static IEnumerable`1<string> TryGetDocKeys(IEnumerator`1<object> input, object current);
    public static string TryGetDocKey(object current);
    public abstract virtual void Remove(String[] keys, WorkContext context);
    internal IndexSearcherHoldingState GetCurrentStateHolder();
    internal IDisposable GetSearcher(IndexSearcher& searcher);
    internal IDisposable GetSearcherAndTermsDocs(IndexSearcher& searcher, RavenJObject[]& termsDocs);
    private void RecreateSearcher();
    protected void AddDocumentToIndex(RavenIndexWriter currentIndexWriter, Document luceneDoc, Analyzer analyzer);
    public void MarkQueried();
    public void MarkQueried(DateTime time);
    public IIndexExtension GetExtension(string indexExtensionKey);
    public IIndexExtension GetExtensionByPrefix(string indexExtensionKeyPrefix);
    public void SetExtension(string indexExtensionKey, IIndexExtension extension);
    private static Document CloneDocument(Document luceneDoc);
    protected void LogIndexedDocument(string key, Document luceneDoc);
    [CLSCompliantAttribute("False")]
public static void AssertQueryDoesNotContainFieldsThatAreNotIndexed(IndexQuery indexQuery, AbstractViewGenerator viewGenerator);
    public IndexingPerformanceStats[] GetIndexingPerformance();
    public IndexingPerformanceStats[] GetCurrentIndexingPerformance();
    public void Backup(string backupDirectory, string path, string incrementalTag, Action`3<string, Exception, BackupMessageSeverity> notifyCallback, CancellationToken token);
    private static void LogErrorAndNotifyStudio(Action`3<string, Exception, BackupMessageSeverity> notifyCallback, string failureMessage, Exception e);
    public Etag GetLastEtagFromStats();
    private static void TryDelete(string neededFilePath);
    protected void UpdateDocumentReferences(IStorageActionsAccessor actions, ConcurrentQueue`1<IDictionary`2<string, HashSet`1<string>>> allReferencedDocs, ConcurrentQueue`1<IDictionary`2<string, Etag>> missingReferencedDocs);
    public void ForceWriteToDisk();
    protected bool EnsureValidNumberOfOutputsForDocument(string sourceDocumentId, int numberOfAlreadyProducedOutputs);
    public void AddIndexingError(Exception e, string message, string documentId);
    public void TryDisable(Exception e, long outOfMemoryErrorCount, int failedToProcessCount);
    public long IncrementOutOfMemoryErrors(bool isReducing);
    public void DecrementIndexingOutOfMemoryErrors();
    public void DecrementReducingOutOfMemoryErrors();
    public void AddOutOfMemoryDatabaseAlert(Exception e);
    public void HandleWriteError(Exception e);
    private void AddIndexError(Exception e, string msg, string title, IndexingPriority priority, IndexChangeTypes changeType);
    public void AddIndexCorruptError(Exception e);
    public void AddIndexFailedFlushError(Exception e);
    private void ResetWriteErrors();
    public sealed virtual LowMemoryHandlerStatistics HandleLowMemory();
    public sealed virtual LowMemoryHandlerStatistics GetStats();
}
public class Raven.Database.Indexing.IndexBatchSizeAutoTuner : BaseBatchSizeAutoTuner {
    [CompilerGeneratedAttribute]
private int <LastAmountOfItemsToRemember>k__BackingField;
    private List`1<int> lastAmountOfItemsToIndex;
    public int InitialNumberOfItems { get; }
    protected int MaxNumberOfItems { get; }
    protected int CurrentNumberOfItems { get; protected set; }
    protected int LastAmountOfItemsToRemember { get; protected set; }
    protected string Name { get; }
    public IndexBatchSizeAutoTuner(WorkContext context);
    private void InstallGauges();
    public virtual int get_InitialNumberOfItems();
    protected virtual int get_MaxNumberOfItems();
    protected virtual int get_CurrentNumberOfItems();
    protected virtual void set_CurrentNumberOfItems(int value);
    [CompilerGeneratedAttribute]
protected sealed virtual int get_LastAmountOfItemsToRemember();
    [CompilerGeneratedAttribute]
protected sealed virtual void set_LastAmountOfItemsToRemember(int value);
    protected virtual void RecordAmountOfItems(int numberOfItems);
    protected virtual IEnumerable`1<int> GetLastAmountOfItems();
    protected virtual string get_Name();
    public IDisposable ConsiderLimitingNumberOfItemsToProcessForThisBatch(Nullable`1<int> maxIndexOutputsPerDoc, bool containsMapReduceIndexes);
    [CompilerGeneratedAttribute]
private int <InstallGauges>b__1_0();
    [CompilerGeneratedAttribute]
private int <InstallGauges>b__1_1();
    [CompilerGeneratedAttribute]
private int <InstallGauges>b__1_2();
}
public class Raven.Database.Indexing.IndexCommitPoint : object {
    [CompilerGeneratedAttribute]
private Etag <HighestCommitedETag>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexSegmentsInfo <SegmentsInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    public Etag HighestCommitedETag { get; public set; }
    public IndexSegmentsInfo SegmentsInfo { get; public set; }
    public DateTime TimeStamp { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_HighestCommitedETag();
    [CompilerGeneratedAttribute]
public void set_HighestCommitedETag(Etag value);
    [CompilerGeneratedAttribute]
public IndexSegmentsInfo get_SegmentsInfo();
    [CompilerGeneratedAttribute]
public void set_SegmentsInfo(IndexSegmentsInfo value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
}
public class Raven.Database.Indexing.IndexCommitPointDirectory : object {
    private static string DirectoryName;
    private static string File;
    private static string KeysToDeleteFile;
    [CompilerGeneratedAttribute]
private string <IndexFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AllCommitPointsFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeletedKeysFile>k__BackingField;
    public string IndexFullPath { get; private set; }
    public string AllCommitPointsFullPath { get; private set; }
    public string Name { get; private set; }
    public string FullPath { get; private set; }
    public string FileFullPath { get; private set; }
    public string DeletedKeysFile { get; private set; }
    public IndexCommitPointDirectory(string indexStoragePath, string directoryName, string name);
    [CompilerGeneratedAttribute]
public string get_IndexFullPath();
    [CompilerGeneratedAttribute]
private void set_IndexFullPath(string value);
    [CompilerGeneratedAttribute]
public string get_AllCommitPointsFullPath();
    [CompilerGeneratedAttribute]
private void set_AllCommitPointsFullPath(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
private void set_FullPath(string value);
    [CompilerGeneratedAttribute]
public string get_FileFullPath();
    [CompilerGeneratedAttribute]
private void set_FileFullPath(string value);
    [CompilerGeneratedAttribute]
public string get_DeletedKeysFile();
    [CompilerGeneratedAttribute]
private void set_DeletedKeysFile(string value);
    public static string GetAllCommitPointsFullPath(string indexFullPath);
    public static String[] ScanAllCommitPointsDirectory(string indexFullPath);
}
public class Raven.Database.Indexing.IndexDefinitionCodeGenerator : object {
    private IndexDefinition _indexDefinition;
    public IndexDefinitionCodeGenerator(IndexDefinition indexDefinition);
    public string Generate();
    private static ArrayInitializerExpression CreateExpressionFromStringToEnumDictionary(IEnumerable`1<KeyValuePair`2<string, T>> dictionary);
    private static ArrayInitializerExpression CreateAnalizersExpression(IndexDefinition indexDefinition);
    private static ArrayInitializerExpression CreateSuggestionsExpression(IndexDefinition indexDefinition);
    private static ArrayInitializerExpression CreateSpatialIndexesExpression(IndexDefinition indexDefinition);
}
public class Raven.Database.Indexing.IndexedItemsInfo : object {
    [CompilerGeneratedAttribute]
private int <ChangedDocs>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <HighestETag>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <DeletedKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableCommitPoint>k__BackingField;
    public int ChangedDocs { get; public set; }
    public Etag HighestETag { get; private set; }
    public String[] DeletedKeys { get; public set; }
    public bool DisableCommitPoint { get; public set; }
    public IndexedItemsInfo(Etag highestEtag);
    [CompilerGeneratedAttribute]
public int get_ChangedDocs();
    [CompilerGeneratedAttribute]
public void set_ChangedDocs(int value);
    [CompilerGeneratedAttribute]
public Etag get_HighestETag();
    [CompilerGeneratedAttribute]
private void set_HighestETag(Etag value);
    [CompilerGeneratedAttribute]
public String[] get_DeletedKeys();
    [CompilerGeneratedAttribute]
public void set_DeletedKeys(String[] value);
    [CompilerGeneratedAttribute]
public bool get_DisableCommitPoint();
    [CompilerGeneratedAttribute]
public void set_DisableCommitPoint(bool value);
}
internal static class Raven.Database.Indexing.IndexedTerms : object {
    private static WeakCache CacheInstance;
    private static IndexedTerms();
    public static Dictionary`2<string, Int32[]> GetTermsAndDocumentsFor(IndexReader reader, int docBase, string field, string databaseName, string indexName);
    private static Dictionary`2<string, Int32[]> FillCache(IndexReader reader, int docBase, string field);
    private static bool LowPrecisionNumber(string field, string val);
    public static RavenJObject[] ReadAllEntriesFromIndex(IndexReader reader);
}
public class Raven.Database.Indexing.IndexingBatch : object {
    public List`1<string> Ids;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<object> Docs;
    public List`1<bool> SkipDeleteFromIndex;
    public Nullable`1<DateTime> DateTime;
    public Etag HighestEtagBeforeFiltering;
    public HashSet`1<string> Collections;
    public IndexingBatch(Etag highestEtagBeforeFiltering);
    public void Add(JsonDocument doc, object asJson, bool skipDeleteFromIndex);
}
public class Raven.Database.Indexing.IndexingExecuter : AbstractIndexingExecuter {
    private ConcurrentSet`1<PrefetchingBehavior> prefetchingBehaviors;
    private Prefetcher prefetcher;
    private PrefetchingBehavior defaultPrefetchingBehavior;
    private Dictionary`2<IComparable, int> tasksFailureCount;
    public List`1<PrefetchingBehavior> PrefetchingBehaviors { get; }
    public bool ShouldRun { get; }
    public IndexingExecuter(WorkContext context, Prefetcher prefetcher, IndexReplacer indexReplacer);
    public List`1<PrefetchingBehavior> get_PrefetchingBehaviors();
    protected virtual bool IsIndexStale(IndexStats indexesStat, IStorageActionsAccessor actions, bool isIdle, Reference`1<bool> onlyFoundIdleWork);
    protected virtual void UpdateStalenessMetrics(int staleCount);
    protected virtual bool ShouldSkipIndex(Index index);
    protected virtual bool ExecuteTasks();
    private bool ExecuteTasksInternal();
    private int ExecuteTask(HashSet`1<int> indexIds, HashSet`1<IComparable> alreadySeen);
    private DatabaseTask GetApplicableTask(IStorageActionsAccessor actions, HashSet`1<IComparable> alreadySeen);
    protected virtual void FlushAllIndexes();
    protected virtual IndexToWorkOn GetIndexToWorkOn(IndexStats indexesStat);
    public static HashSet`1<string> GetEntityNamesToIndex(List`1<IndexToWorkOn> indexes, DocumentDatabase database);
    protected virtual void ExecuteIndexingWork(IList`1<IndexToWorkOn> indexes);
    private void SetPrefetcherForIndexingGroup(IndexingGroup groupIndex, ConcurrentSet`1<PrefetchingBehavior> usedPrefetchers);
    private PrefetchingBehavior TryGetPrefetcherFor(Etag fromEtag, ConcurrentSet`1<PrefetchingBehavior> usedPrefetchers, HashSet`1<string> entityNames);
    private PrefetchingBehavior TryGetDefaultPrefetcher(Etag fromEtag, ConcurrentSet`1<PrefetchingBehavior> usedPrefetchers, HashSet`1<string> entityNames);
    private PrefetchingBehavior GetPrefetcherFor(Etag fromEtag, ConcurrentSet`1<PrefetchingBehavior> usedPrefetchers, HashSet`1<string> entityNames);
    private void ReleasePrefetchersAndUpdateStatistics(IndexingGroup indexingGroup, TimeSpan elapsedTimeSpan);
    private bool PerformIndexingOnIndexBatches(ConcurrentDictionary`2<IndexingBatchOperation, object> indexBatchOperations);
    private bool GenerateIndexingBatchesAndPrefetchDocuments(List`1<IndexingGroup> groupedIndexes, ConcurrentDictionary`2<IndexingBatchOperation, object> indexBatchOperations);
    private bool GenerateIndexingGroupsByEtagRanges(IList`1<IndexToWorkOn> indexes, ConcurrentSet`1& usedPrefetchers, List`1& indexingGroups);
    private void RemoveUnusedPrefetchers(IEnumerable`1<PrefetchingBehavior> usedPrefetchingBehaviors);
    public virtual bool get_ShouldRun();
    protected virtual void CleanupPrefetchers();
    public void IndexPrecomputedBatch(PrecomputedIndexingBatch precomputedBatch, CancellationToken token);
    private IndexingPerformanceStats HandleIndexingFor(IndexingBatchForIndex batchForIndex, Etag lastEtag, DateTime lastModified, CancellationToken token);
    private IndexingPerformanceStats ExecuteIndexingBatch(IndexingBatchForIndex batchForIndex, Etag lastEtag, DateTime lastModified, CancellationToken token);
    private IEnumerable`1<IndexingBatchForIndex> FilterIndexes(IList`1<IndexToWorkOn> indexesToWorkOn, List`1<JsonDocument> jsonDocs, Etag highestETagInBatch, List`1& filteredOutIndexes);
    protected virtual bool IsValidIndex(IndexStats indexesStat);
    private IndexingPerformanceStats IndexDocuments(IStorageActionsAccessor actions, IndexingBatchForIndex indexingBatchForIndex, CancellationToken token);
    protected virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <PerformIndexingOnIndexBatches>b__25_0(IndexingBatchOperation indexBatchOperation);
}
public class Raven.Database.Indexing.IndexingUtil : object {
    public static string FixupIndexName(string indexName, string path);
    public static int StableInvariantIgnoreCaseStringHash(string s);
    public static int MapBucket(string docId);
}
public class Raven.Database.Indexing.IndexingWorkStats : object {
    public int IndexingAttempts;
    public int IndexingSuccesses;
    public int IndexingErrors;
    public int ReduceAttempts;
    public int ReduceSuccesses;
    public int ReduceErrors;
    public Status Operation;
    public IndexingWorkStats(IEnumerable`1<IndexingWorkStats> stream);
}
internal class Raven.Database.Indexing.IndexMerging.ChangeRootReferenceVisitor : DepthFirstAstVisitor {
    private string _fromIdentifier;
    public ChangeRootReferenceVisitor(string fromIdentifier);
    public virtual void VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression);
}
internal class Raven.Database.Indexing.IndexMerging.IndexData : object {
    private IndexDefinition index;
    public Dictionary`2<string, Expression> SelectExpressions;
    [CompilerGeneratedAttribute]
private Expression <FromExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfFromClauses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfSelectClauses>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalMap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasWhere>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAlreadyMerged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuitedForMerge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMapReduceOrMultiMap>k__BackingField;
    public Expression FromExpression { get; public set; }
    public string FromIdentifier { get; public set; }
    public int NumberOfFromClauses { get; public set; }
    public int NumberOfSelectClauses { get; public set; }
    public string OriginalMap { get; public set; }
    public bool HasWhere { get; public set; }
    public bool HasLet { get; public set; }
    public bool HasGroup { get; public set; }
    public bool HasOrder { get; public set; }
    public int IndexId { get; public set; }
    public string IndexName { get; public set; }
    public bool IsAlreadyMerged { get; public set; }
    public bool IsSuitedForMerge { get; public set; }
    public string Comment { get; public set; }
    public string Collection { get; public set; }
    public IDictionary`2<string, FieldStorage> Stores { get; }
    public IDictionary`2<string, FieldIndexing> Indexes { get; }
    public IDictionary`2<string, SortOptions> SortOptions { get; }
    public IDictionary`2<string, string> Analyzers { get; }
    public ISet`1<string> SuggestionsOptions { get; }
    public IDictionary`2<string, FieldTermVector> TermVectors { get; }
    public IDictionary`2<string, SpatialOptions> SpatialIndexes { get; }
    public IndexDefinition Index { get; }
    public bool IsMapReduceOrMultiMap { get; public set; }
    public IndexData(IndexDefinition index);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Expression get_FromExpression();
    [CompilerGeneratedAttribute]
public void set_FromExpression(Expression value);
    [CompilerGeneratedAttribute]
public string get_FromIdentifier();
    [CompilerGeneratedAttribute]
public void set_FromIdentifier(string value);
    [CompilerGeneratedAttribute]
public int get_NumberOfFromClauses();
    [CompilerGeneratedAttribute]
public void set_NumberOfFromClauses(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfSelectClauses();
    [CompilerGeneratedAttribute]
public void set_NumberOfSelectClauses(int value);
    [CompilerGeneratedAttribute]
public string get_OriginalMap();
    [CompilerGeneratedAttribute]
public void set_OriginalMap(string value);
    [CompilerGeneratedAttribute]
public bool get_HasWhere();
    [CompilerGeneratedAttribute]
public void set_HasWhere(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasLet();
    [CompilerGeneratedAttribute]
public void set_HasLet(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasGroup();
    [CompilerGeneratedAttribute]
public void set_HasGroup(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasOrder();
    [CompilerGeneratedAttribute]
public void set_HasOrder(bool value);
    [CompilerGeneratedAttribute]
public int get_IndexId();
    [CompilerGeneratedAttribute]
public void set_IndexId(int value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAlreadyMerged();
    [CompilerGeneratedAttribute]
public void set_IsAlreadyMerged(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSuitedForMerge();
    [CompilerGeneratedAttribute]
public void set_IsSuitedForMerge(bool value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    public IDictionary`2<string, FieldStorage> get_Stores();
    public IDictionary`2<string, FieldIndexing> get_Indexes();
    public IDictionary`2<string, SortOptions> get_SortOptions();
    public IDictionary`2<string, string> get_Analyzers();
    public ISet`1<string> get_SuggestionsOptions();
    public IDictionary`2<string, FieldTermVector> get_TermVectors();
    public IDictionary`2<string, SpatialOptions> get_SpatialIndexes();
    public IndexDefinition get_Index();
    [CompilerGeneratedAttribute]
public bool get_IsMapReduceOrMultiMap();
    [CompilerGeneratedAttribute]
public void set_IsMapReduceOrMultiMap(bool value);
    public string BuildExpression(Dictionary`2<string, Expression> selectExpressions);
}
public class Raven.Database.Indexing.IndexMerging.IndexMerger : object {
    private Dictionary`2<int, IndexDefinition> indexDefinitions;
    public IndexMerger(Dictionary`2<int, IndexDefinition> indexDefinitions);
    private List`1<MergeProposal> MergeIndexes(List`1<IndexData> indexes);
    private static List`1<string> CheckForUnsuitableIndexForMerging(IndexData indexData);
    private List`1<IndexData> ParseIndexesAndGetReadyToMerge();
    private bool CanMergeIndexes(IndexData other, IndexData current);
    private bool CompareIndexFieldOptions(IndexData index1Data, IndexData index2Data);
    private bool IsDefaultValue(FieldStorage val);
    private bool IsDefaultValue(SortOptions val);
    private bool IsDefaultValue(FieldTermVector val);
    private bool IsDefaultValue(FieldIndexing val);
    private bool IsDefaultValue(string val);
    private bool IsDefaultValue(SuggestionOptions val);
    private bool IsDefaultValue(T val);
    private bool DataDictionaryCompare(IDictionary`2<string, T> dataDict1, IDictionary`2<string, T> dataDict2, IEnumerable`1<string> names);
    private static void DataDictionaryMerge(IDictionary`2<TKey, TVal> dest, IDictionary`2<TKey, TVal> src);
    private static void DataSetMerge(ISet`1<string> dest, ISet`1<string> src);
    private static bool AreSelectClausesCompatible(IndexData x, IndexData y);
    private static bool AreSelectClausesTheSame(IndexData index, Dictionary`2<string, Expression> selectExpressionDict);
    private IndexMergeResults CreateMergeIndexDefinition(List`1<MergeProposal> indexDataForMerge);
    private bool SortOptionsMatch(IDictionary`2<string, SortOptions> a, IDictionary`2<string, SortOptions> b);
    private IndexMergeResults ExcludePartialResults(IndexMergeResults originalIndexes);
    private static string ExtractValueFromExpression(Expression expression);
    private static string ExtractIdentifierFromExpression(Expression expression);
    public IndexMergeResults ProposeIndexMergeSuggestions();
}
internal class Raven.Database.Indexing.IndexMerging.IndexVisitor : DepthFirstAstVisitor {
    private IndexData indexData;
    public IndexVisitor(IndexData indexData);
    public virtual void VisitQueryFromClause(QueryFromClause queryFromClause);
    public virtual void VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression);
    public virtual void VisitInvocationExpression(InvocationExpression invocationExpression);
    public virtual void VisitQuerySelectClause(QuerySelectClause querySelectClause);
    public virtual void VisitQueryWhereClause(QueryWhereClause queryWhereClause);
    public virtual void VisitQueryOrderClause(QueryOrderClause queryOrderClause);
    public virtual void VisitQueryOrdering(QueryOrdering queryOrdering);
    public virtual void VisitQueryGroupClause(QueryGroupClause queryGroupClause);
    public virtual void VisitQueryLetClause(QueryLetClause queryLetClause);
}
internal class Raven.Database.Indexing.IndexMerging.MergeProposal : object {
    public List`1<IndexData> ProposedForMerge;
    [CompilerGeneratedAttribute]
private IndexData <MergedData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexMergeSuggestion>k__BackingField;
    public IndexData MergedData { get; public set; }
    public string IndexMergeSuggestion { get; public set; }
    [CompilerGeneratedAttribute]
public IndexData get_MergedData();
    [CompilerGeneratedAttribute]
public void set_MergedData(IndexData value);
    [CompilerGeneratedAttribute]
public string get_IndexMergeSuggestion();
    [CompilerGeneratedAttribute]
public void set_IndexMergeSuggestion(string value);
}
public class Raven.Database.Indexing.IndexReaderWarmersWrapper : IndexReaderWarmer {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    private OrderedPartCollection`1<AbstractIndexReaderWarmer> _indexReaderWarmers;
    public string IndexName { get; private set; }
    public IndexReaderWarmersWrapper(string indexName, OrderedPartCollection`1<AbstractIndexReaderWarmer> indexReaderWarmers);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
private void set_IndexName(string value);
    public virtual void Warm(IndexReader reader);
}
public class Raven.Database.Indexing.IndexReplacer : object {
    private ILog log;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    private ConcurrentDictionary`2<int, IndexReplaceInformation> indexesToReplace;
    [CompilerGeneratedAttribute]
private Action`1<string> IndexReplaced;
    public DocumentDatabase Database { get; public set; }
    public IndexReplacer(DocumentDatabase database);
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    private void Initialize();
    private Nullable`1<int> HandleIndexReplaceDocument(JsonDocument document);
    private void DeleteIndexReplaceDocument(string documentKey);
    private void HandleIndexReplaceDocumentDelete(string replaceIndexName);
    public void ReplaceIndexes(ICollection`1<int> indexIds);
    private bool ShouldReplace(IndexReplaceInformation indexReplaceInformation, int indexId);
    public void ForceReplacement(IndexDefinition indexDefiniton);
    [CompilerGeneratedAttribute]
public void add_IndexReplaced(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_IndexReplaced(Action`1<string> value);
    private void InternalReplaceIndexes(Dictionary`2<int, IndexReplaceInformation> indexes);
    private void ReplaceSingleIndex(IndexReplaceInformation indexReplaceInformation);
    private void HandleSideBySideFailureBecauseLockError(IndexReplaceInformation indexReplaceInformation, string key, Etag etag);
    private void DeleteIndexReplaceDocument(string key, Etag etag);
    private void HandleIndexReplaceError(IndexReplaceInformation indexReplaceInformation);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(DocumentDatabase db, DocumentChangeNotification notification, RavenJObject metadata);
}
public class Raven.Database.Indexing.IndexSearcherHolder : object {
    private int indexId;
    private WorkContext context;
    private static ILog Log;
    private IndexSearcherHoldingState modreq(System.Runtime.CompilerServices.IsVolatile) current;
    public IndexSearcherHolder(int indexId, WorkContext context);
    private static IndexSearcherHolder();
    public ManualResetEvent SetIndexSearcher(IndexSearcher searcher, string publicName, bool wait);
    public IDisposable GetSearcher(IndexSearcher& searcher);
    public IDisposable GetSearcherAndTermDocs(IndexSearcher& searcher, RavenJObject[]& termDocs);
    internal IndexSearcherHoldingState GetCurrentStateHolder();
}
public class Raven.Database.Indexing.IndexSegmentsInfo : object {
    [CompilerGeneratedAttribute]
private long <Generation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SegmentsFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <ReferencedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIndexCorrupted>k__BackingField;
    public long Generation { get; public set; }
    public string SegmentsFileName { get; public set; }
    public ICollection`1<string> ReferencedFiles { get; public set; }
    public bool IsIndexCorrupted { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Generation();
    [CompilerGeneratedAttribute]
public void set_Generation(long value);
    [CompilerGeneratedAttribute]
public string get_SegmentsFileName();
    [CompilerGeneratedAttribute]
public void set_SegmentsFileName(string value);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_ReferencedFiles();
    [CompilerGeneratedAttribute]
public void set_ReferencedFiles(ICollection`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_IsIndexCorrupted();
    [CompilerGeneratedAttribute]
public void set_IsIndexCorrupted(bool value);
    protected bool Equals(IndexSegmentsInfo other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Raven.Database.Indexing.IndexStorage : CriticalFinalizerObject {
    private DocumentDatabase documentDatabase;
    private static string IndexVersion;
    private static string MapReduceIndexVersion;
    private IndexDefinitionStorage indexDefinitionStorage;
    private InMemoryRavenConfiguration configuration;
    private string path;
    private static ILog log;
    private static ILog startupLog;
    private Analyzer dummyAnalyzer;
    private DateTime latestPersistedQueryTime;
    private FileStream crashMarker;
    private ConcurrentDictionary`2<int, Index> indexes;
    private object deleteIndexLock;
    public Int32[] Indexes { get; }
    public String[] IndexNames { get; }
    public IndexStorage(IndexDefinitionStorage indexDefinitionStorage, InMemoryRavenConfiguration configuration, DocumentDatabase documentDatabase);
    private static IndexStorage();
    private Index OpenIndex(string indexName, bool onStartup, bool forceFullIndexCheck);
    private void CheckIndexState(Directory directory, IndexDefinition indexDefinition, Index index, bool resetTried);
    private void CheckMapIndexState(IDictionary`2<string, string> commitData, IndexDefinition indexDefinition, Index index);
    private static void CheckMapReduceIndexState(IDictionary`2<string, string> commitData, bool resetTried);
    private static bool IsIdleAutoIndex(Index index);
    private void TryResettingIndex(string indexName, IndexDefinition indexDefinition, bool onStartup);
    private String[] TryRecoveringIndex(IndexDefinition indexDefinition, Directory luceneDirectory);
    private void LoadExistingSuggestionsExtentions(string indexName, Index indexImplementation);
    internal static void HandleLegacySuggestions(String[] directories);
    protected Directory OpenOrCreateLuceneDirectory(IndexDefinition indexDefinition, bool createIfMissing, bool forceFullExistingIndexCheck);
    private void RegenerateMapReduceIndex(Directory directory, IndexDefinition indexDefinition);
    private void ResetLastIndexedEtag(IndexDefinition indexDefinition, Etag lastIndexedEtag, DateTime timestamp);
    internal Etag GetLastEtagForIndex(Index index);
    public static string IndexVersionFileName(IndexDefinition indexDefinition);
    public static void WriteIndexVersion(Directory directory, IndexDefinition indexDefinition);
    private static void EnsureIndexVersionMatches(Directory directory, IndexDefinition indexDefinition);
    private static void CheckIndexAndTryToFix(Directory directory, IndexDefinition indexDefinition);
    public void StoreCommitPoint(string indexName, IndexCommitPoint indexCommit);
    public void AddDeletedKeysToCommitPoints(IndexDefinition indexDefinition, String[] deletedKeys);
    private bool TryReusePreviousCommitPointsToRecoverIndex(Directory directory, IndexDefinition indexDefinition, string indexStoragePath, IndexCommitPoint& indexCommit, String[]& keysToDelete);
    public static IndexSegmentsInfo GetCurrentSegmentsInfo(string indexName, Directory directory);
    public static bool TryGetCommitPoint(IndexCommitPointDirectory commitPointDirectory, IndexCommitPoint& indexCommit);
    internal Directory MakeRAMDirectoryPhysical(RAMDirectory ramDir, IndexDefinition indexDefinition);
    private Index CreateIndexImplementation(IndexDefinition indexDefinition, Directory directory);
    public Int32[] get_Indexes();
    public String[] get_IndexNames();
    public bool HasIndex(string index);
    public sealed virtual void Dispose();
    public void DeleteIndex(string name);
    public void DeleteIndex(int id);
    public void RenameIndex(IndexDefinition existingIndex, string newIndexName);
    public void DeleteIndexData(int id);
    public void DeleteSuggestionsData(string indexName);
    public Index ReopenCorruptedIndex(Index index);
    public void CreateIndexImplementation(IndexDefinition indexDefinition);
    public Query GetDocumentQuery(string index, IndexQuery query, OrderedPartCollection`1<AbstractIndexQueryTrigger> indexQueryTriggers);
    private Index TryIndexByName(string name);
    public IEnumerable`1<IndexQueryResult> Query(string index, IndexQuery query, Func`2<IndexQueryResult, bool> shouldIncludeInResults, FieldsToFetch fieldsToFetch, OrderedPartCollection`1<AbstractIndexQueryTrigger> indexQueryTriggers, CancellationToken token, Action`1<double> parseTiming);
    public IEnumerable`1<RavenJObject> IndexEntires(string indexName, IndexQuery query, List`1<string> reduceKeys, OrderedPartCollection`1<AbstractIndexQueryTrigger> indexQueryTriggers, Reference`1<int> totalResults);
    public void RemoveFromIndex(int index, String[] keys, WorkContext context);
    [CLSCompliantAttribute("False")]
public IndexingPerformanceStats Index(int index, AbstractViewGenerator viewGenerator, IndexingBatch batch, WorkContext context, IStorageActionsAccessor actions, DateTime minimumTimestamp, CancellationToken token);
    [CLSCompliantAttribute("False")]
public IndexingPerformanceStats Reduce(int index, AbstractViewGenerator viewGenerator, IEnumerable`1<IGrouping`2<int, object>> mappedResults, int level, WorkContext context, IStorageActionsAccessor actions, HashSet`1<string> reduceKeys, int inputCount);
    internal IndexSearcherHoldingState GetCurrentStateHolder(string indexName);
    public IDisposable GetCurrentIndexSearcher(int indexId, IndexSearcher& searcher);
    public IDisposable GetCurrentIndexSearcherAndTermDocs(string indexName, IndexSearcher& searcher, RavenJObject[]& termsDocs);
    private Index GetIndexByName(string indexName);
    public void RunIdleOperations();
    public bool IsIndexStale(string indexName, LastCollectionEtags lastCollectionEtags);
    public bool IsIndexStale(int indexId, LastCollectionEtags lastCollectionEtags);
    private void DeleteSurpassedAutoIndexes();
    private void UpdateLatestPersistedQueryTime();
    private void SetUnusedIndexesToIdle();
    private IndexStats GetIndexStats(IStorageActionsAccessor accessor, int indexId);
    private void HandleIdleIndex(double age, double lastQuery, UnusedIndexState thisItem, IStorageActionsAccessor accessor);
    private void HandleActiveIndex(UnusedIndexState thisItem, double age, double lastQuery, IStorageActionsAccessor accessor, double timeToWaitForIdle);
    private void UpdateIndexMappingFile();
    public void FlushMapIndexes();
    public void FlushReduceIndexes();
    public void FlushIndexes(HashSet`1<int> indexIds, bool onlyAddIndexError);
    public void FlushIndex(int indexId, bool onlyAddIndexError);
    private static void FlushIndex(Index value, bool onlyAddIndexError);
    private static string GetIndexType(bool isMapReduce);
    public List`1<int> GetDisabledIndexIds();
    public IIndexExtension GetIndexExtension(string index, string indexExtensionKey);
    public IIndexExtension GetIndexExtensionByPrefix(string index, string indexExtensionKeyPrefix);
    public void SetIndexExtension(string indexName, string indexExtensionKey, IIndexExtension suggestionQueryIndexExtension);
    public Index GetIndexInstance(string indexName);
    public IEnumerable`1<Index> GetAllIndexes();
    public Index GetIndexInstance(int indexId);
    public void MarkCachedQuery(string indexName);
    internal void SetLastQueryTime(string indexName, DateTime lastQueryTime);
    public Nullable`1<DateTime> GetLastQueryTime(int index);
    public Nullable`1<DateTime> GetLastQueryTime(string index);
    public IndexingPerformanceStats[] GetIndexingPerformance(int index);
    public void Backup(string directory, string incrementalTag, Action`3<string, Exception, BackupMessageSeverity> notifyCallback, CancellationToken token);
    public void MergeAllIndexes();
    public string IndexOnRam(int id);
    public void ForceWriteToDiskAndWriteInMemoryIndexToDiskIfNecessary(string indexName);
    internal bool TryReplaceIndex(string indexName, string indexToReplaceName);
    [CompilerGeneratedAttribute]
private void <CreateIndexImplementation>b__38_0(AbstractAnalyzerGenerator initialization);
    [CompilerGeneratedAttribute]
private void <UpdateLatestPersistedQueryTime>b__67_0(IStorageActionsAccessor accessor);
    [CompilerGeneratedAttribute]
private void <SetUnusedIndexesToIdle>b__69_0(IStorageActionsAccessor accessor);
}
public class Raven.Database.Indexing.IndexToWorkOn : object {
    [CompilerGeneratedAttribute]
private int <IndexId>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <LastIndexedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastIndexedTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <Index>k__BackingField;
    public int IndexId { get; public set; }
    public Etag LastIndexedEtag { get; public set; }
    public DateTime LastIndexedTimestamp { get; public set; }
    public Index Index { get; public set; }
    [CompilerGeneratedAttribute]
public int get_IndexId();
    [CompilerGeneratedAttribute]
public void set_IndexId(int value);
    [CompilerGeneratedAttribute]
public Etag get_LastIndexedEtag();
    [CompilerGeneratedAttribute]
public void set_LastIndexedEtag(Etag value);
    [CompilerGeneratedAttribute]
public DateTime get_LastIndexedTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastIndexedTimestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Index get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Index value);
    public virtual string ToString();
}
public class Raven.Database.Indexing.IntersectionCollector : Collector {
    private Dictionary`2<string, SubQueryResult> results;
    private int currentBase;
    private IndexReader currentReader;
    private Scorer currentScorer;
    public bool AcceptsDocsOutOfOrder { get; }
    public IntersectionCollector(Searchable indexSearcher, IEnumerable`1<ScoreDoc> scoreDocs);
    public virtual void SetScorer(Scorer scorer);
    public virtual void Collect(int doc);
    public virtual void SetNextReader(IndexReader reader, int docBase);
    public virtual bool get_AcceptsDocsOutOfOrder();
    public IEnumerable`1<SubQueryResult> DocumentsIdsForCount(int expectedCount);
}
public class Raven.Database.Indexing.LowerCaseKeywordAnalyzer : Analyzer {
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
}
public class Raven.Database.Indexing.LowerCaseKeywordTokenizer : Tokenizer {
    private static bool isAsciiCasingSameAsInvariant;
    private static TextInfo invariantTextInfo;
    private int offset;
    private int bufferIndex;
    private int dataLen;
    private static int IO_BUFFER_SIZE;
    private ITermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private Char[] ioBuffer;
    public LowerCaseKeywordTokenizer(TextReader input);
    protected LowerCaseKeywordTokenizer(AttributeSource source, TextReader input);
    protected LowerCaseKeywordTokenizer(AttributeFactory factory, TextReader input);
    private static LowerCaseKeywordTokenizer();
    protected internal virtual bool IsTokenChar(char c);
    protected internal virtual char Normalize(char c);
    public virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset(TextReader input);
}
public class Raven.Database.Indexing.LowerCaseWhitespaceAnalyzer : LowerCaseKeywordAnalyzer {
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
}
public class Raven.Database.Indexing.LowerCaseWhitespaceTokenizer : LowerCaseKeywordTokenizer {
    public LowerCaseWhitespaceTokenizer(TextReader input);
    protected internal virtual bool IsTokenChar(char c);
}
public abstract class Raven.Database.Indexing.LuceneASTNodeBase : object {
    [CompilerGeneratedAttribute]
private PrefixOperator <Prefix>k__BackingField;
    public IEnumerable`1<LuceneASTNodeBase> Children { get; }
    public PrefixOperator Prefix { get; public set; }
    public abstract virtual IEnumerable`1<LuceneASTNodeBase> get_Children();
    public abstract virtual Query ToQuery(LuceneASTQueryConfiguration configuration);
    public virtual void AddQueryToBooleanQuery(BooleanQuery b, LuceneASTQueryConfiguration configuration, Occur o);
    public virtual Query ToGroupFieldQuery(LuceneASTQueryConfiguration configuration);
    [CompilerGeneratedAttribute]
public PrefixOperator get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(PrefixOperator value);
    protected string GetPrefixString();
}
public class Raven.Database.Indexing.LuceneASTQueryConfiguration : object {
    [CompilerGeneratedAttribute]
private RavenPerFieldAnalyzerWrapper <Analayzer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryOperator <DefaultOperator>k__BackingField;
    public RavenPerFieldAnalyzerWrapper Analayzer { get; public set; }
    public string FieldName { get; public set; }
    public QueryOperator DefaultOperator { get; public set; }
    [CompilerGeneratedAttribute]
public RavenPerFieldAnalyzerWrapper get_Analayzer();
    [CompilerGeneratedAttribute]
public void set_Analayzer(RavenPerFieldAnalyzerWrapper value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public QueryOperator get_DefaultOperator();
    [CompilerGeneratedAttribute]
public void set_DefaultOperator(QueryOperator value);
}
public class Raven.Database.Indexing.LuceneCodecDirectory : FSDirectory {
    private List`1<AbstractIndexCodec> codecs;
    public LuceneCodecDirectory(string path, IEnumerable`1<AbstractIndexCodec> codecs);
    public virtual IndexInput OpenInput(string name, int bufferSize);
    private CodecIndexInput OpenInputInner(string name);
    public virtual IndexOutput CreateOutput(string name);
    public virtual long FileLength(string name);
    private Stream ApplyReadCodecs(string key, Stream stream);
    private Stream ApplyWriteCodecs(string key, Stream stream);
    private FileInfo GetFile(string name);
    private void CreateDirectory();
    private void DeleteFile(FileInfo file);
}
public interface Raven.Database.Indexing.LuceneIntegration.IRavenLuceneMethodQuery {
    public string Field { get; }
    public abstract virtual IRavenLuceneMethodQuery Merge(IRavenLuceneMethodQuery other);
    public abstract virtual string get_Field();
}
public class Raven.Database.Indexing.LuceneIntegration.TermsMatchQuery : MultiTermQuery {
    private string field;
    private List`1<string> matches;
    public List`1<string> Matches { get; }
    public string Field { get; }
    public TermsMatchQuery(string field, List`1<string> matches);
    public List`1<string> get_Matches();
    public sealed virtual string get_Field();
    public virtual string ToString(string fld);
    protected virtual FilteredTermEnum GetEnum(IndexReader reader);
    public sealed virtual IRavenLuceneMethodQuery Merge(IRavenLuceneMethodQuery other);
}
[GeneratedCodeAttribute("Gardens Point Parser Generator", "1.5.2")]
internal class Raven.Database.Indexing.LuceneQueryParser : ShiftReduceParser`2<ValueType, LexLocation> {
    private bool inMethod;
    [CompilerGeneratedAttribute]
private bool <IsDefaultOperatorAnd>k__BackingField;
    [CompilerGeneratedAttribute]
private LuceneASTNodeBase <LuceneAST>k__BackingField;
    private static Dictionary`2<int, string> aliases;
    private static Rule[] rules;
    private static State[] states;
    private static String[] nonTerms;
    public bool IsDefaultOperatorAnd { get; public set; }
    public bool InMethod { get; public set; }
    public LuceneASTNodeBase LuceneAST { get; public set; }
    private static LuceneQueryParser();
    [CompilerGeneratedAttribute]
public bool get_IsDefaultOperatorAnd();
    [CompilerGeneratedAttribute]
public void set_IsDefaultOperatorAnd(bool value);
    public bool get_InMethod();
    public void set_InMethod(bool value);
    public void Parse(string s);
    [CompilerGeneratedAttribute]
public LuceneASTNodeBase get_LuceneAST();
    [CompilerGeneratedAttribute]
public void set_LuceneAST(LuceneASTNodeBase value);
    protected virtual void Initialize();
    protected virtual void DoAction(int action);
    protected virtual string TerminalToString(int terminal);
}
internal class Raven.Database.Indexing.LuceneQueryScanner : ScanBase {
    private bool inMethod;
    private Stack`1<BufferContext> bStack;
    private ScanBuff buffer;
    private int currentScOrd;
    private static int parserMax;
    private static int maxAccept;
    private static int initial;
    private static int eofNum;
    private static int goStart;
    private static int INITIAL;
    private int state;
    private int currentStart;
    private int code;
    private int cCol;
    private int lNum;
    private int tokPos;
    private int tokCol;
    private int tokLin;
    private int tokEPos;
    private int tokECol;
    private int tokELin;
    private string tokTxt;
    private Stack`1<int> scStack;
    private static Int32[] startState;
    private static Table[] NxS;
    private Context ctx;
    private int readPos;
    public bool InMethod { get; public set; }
    public ScanBuff Buffer { get; }
    private int yypos { get; }
    private int yyline { get; }
    private int yycol { get; }
    public string yytext { get; }
    public int yyleng { get; }
    internal int YY_START { get; internal set; }
    internal LuceneQueryScanner(Stream file);
    private static LuceneQueryScanner();
    public bool get_InMethod();
    public void set_InMethod(bool value);
    public void PublicSetSource(string source);
    protected virtual bool yywrap();
    public virtual void yyerror(string format, Object[] args);
    private string DiscardEscapeChar(string input);
    private static int HexToInt(char c);
    public static int URShift(int number, int bits);
    public ScanBuff get_Buffer();
    private static int GetMaxParseToken();
    private int NextState();
    private BufferContext MkBuffCtx();
    private void RestoreBuffCtx(BufferContext value);
    private void GetCode();
    private void MarkToken();
    private void MarkEnd();
    private int Peek();
    public void SetSource(string source, int offset);
    public void SetSource(IList`1<string> source);
    public void SetSource(Stream source);
    public virtual int yylex();
    private int get_yypos();
    private int get_yyline();
    private int get_yycol();
    public string get_yytext();
    private void yyless(int n);
    private void _yytrunc(int n);
    public int get_yyleng();
    internal int get_YY_START();
    internal void set_YY_START(int value);
    internal void BEGIN(int next);
    private int Scan();
    private void SaveStateAndPos(Context& ctx);
    private void RestoreStateAndPos(Context& ctx);
    internal void yy_clear_stack();
    internal int yy_top_state();
    internal void yy_push_state(int state);
    internal void yy_pop_state();
    internal void ECHO();
}
internal class Raven.Database.Indexing.MapReduceIndex : Index {
    private JsonSerializer jsonSerializer;
    private static JsonConverterCollection MapReduceConverters;
    private static ConcurrentDictionary`2<Type, Func`2<object, object>> documentIdFetcherCache;
    public bool IsMapReduce { get; }
    private static MapReduceIndex();
    public MapReduceIndex(Directory directory, int id, IndexDefinition indexDefinition, AbstractViewGenerator viewGenerator, WorkContext context);
    public virtual bool get_IsMapReduce();
    public virtual IndexingPerformanceStats IndexDocuments(AbstractViewGenerator viewGenerator, IndexingBatch batch, IStorageActionsAccessor actions, DateTime minimumTimestamp, CancellationToken token);
    private int ProcessBatch(AbstractViewGenerator viewGenerator, List`1<object> currentDocumentResults, string currentKey, HashSet`1<ReduceKeyAndBucket> changes, IStorageActionsAccessor actions, IDictionary`2<string, int> statsPerKey, Stopwatch reduceDuringMapLinqExecution, Stopwatch putMappedResultsDuration, Stopwatch convertToRavenJObjectDuration);
    private RavenJObject GetMappedData(object doc);
    private static string GetDocumentId(object doc);
    internal static string ReduceKeyToString(object reduceValue);
    protected virtual IndexQueryResult RetrieveDocument(Document document, FieldsToFetch fieldsToFetch, ScoreDoc score);
    protected virtual void HandleCommitPoints(IndexedItemsInfo itemsInfo, IndexSegmentsInfo segmentsInfo);
    protected virtual bool IsUpToDateEnoughToWriteToDisk(Etag highestETag);
    public virtual void Remove(String[] keys, WorkContext context);
}
public class Raven.Database.Indexing.MethodLuceneASTNode : LuceneASTNodeBase {
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TermLuceneASTNode> <Matches>k__BackingField;
    public string MethodName { get; public set; }
    public string FieldName { get; public set; }
    public List`1<TermLuceneASTNode> Matches { get; public set; }
    public IEnumerable`1<LuceneASTNodeBase> Children { get; }
    public MethodLuceneASTNode(string rawMethodStr, List`1<TermLuceneASTNode> matches);
    public MethodLuceneASTNode(string rawMethodStr, TermLuceneASTNode match);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public List`1<TermLuceneASTNode> get_Matches();
    [CompilerGeneratedAttribute]
public void set_Matches(List`1<TermLuceneASTNode> value);
    public virtual IEnumerable`1<LuceneASTNodeBase> get_Children();
    public virtual Query ToQuery(LuceneASTQueryConfiguration configuration);
    public virtual string ToString();
}
public class Raven.Database.Indexing.NotForQueryingAttribute : Attribute {
}
public class Raven.Database.Indexing.OperatorLuceneASTNode : LuceneASTNodeBase {
    [CompilerGeneratedAttribute]
private LuceneASTNodeBase <RightNode>k__BackingField;
    [CompilerGeneratedAttribute]
private LuceneASTNodeBase <LeftNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Operator <Op>k__BackingField;
    public IEnumerable`1<LuceneASTNodeBase> Children { get; }
    public LuceneASTNodeBase RightNode { get; public set; }
    public LuceneASTNodeBase LeftNode { get; public set; }
    public Operator Op { get; public set; }
    public OperatorLuceneASTNode(LuceneASTNodeBase leftNode, LuceneASTNodeBase rightNode, Operator op, bool isDefaultOperatorAnd);
    [IteratorStateMachineAttribute("Raven.Database.Indexing.OperatorLuceneASTNode/<get_Children>d__2")]
public virtual IEnumerable`1<LuceneASTNodeBase> get_Children();
    public virtual Query ToQuery(LuceneASTQueryConfiguration configuration);
    private Occur PrefixToOccurance(LuceneASTNodeBase node, Occur defaultOccurance);
    public virtual void AddQueryToBooleanQuery(BooleanQuery query, LuceneASTQueryConfiguration configuration, Occur o);
    [CompilerGeneratedAttribute]
public LuceneASTNodeBase get_RightNode();
    [CompilerGeneratedAttribute]
public void set_RightNode(LuceneASTNodeBase value);
    [CompilerGeneratedAttribute]
public LuceneASTNodeBase get_LeftNode();
    [CompilerGeneratedAttribute]
public void set_LeftNode(LuceneASTNodeBase value);
    [CompilerGeneratedAttribute]
public Operator get_Op();
    [CompilerGeneratedAttribute]
public void set_Op(Operator value);
    public virtual string ToString();
}
public class Raven.Database.Indexing.ParenthesistLuceneASTNode : LuceneASTNodeBase {
    [CompilerGeneratedAttribute]
private LuceneASTNodeBase <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Boost>k__BackingField;
    public IEnumerable`1<LuceneASTNodeBase> Children { get; }
    public LuceneASTNodeBase Node { get; public set; }
    public string Boost { get; public set; }
    [IteratorStateMachineAttribute("Raven.Database.Indexing.ParenthesistLuceneASTNode/<get_Children>d__1")]
public virtual IEnumerable`1<LuceneASTNodeBase> get_Children();
    public virtual Query ToQuery(LuceneASTQueryConfiguration configuration);
    public virtual Query ToGroupFieldQuery(LuceneASTQueryConfiguration configuration);
    [CompilerGeneratedAttribute]
public LuceneASTNodeBase get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(LuceneASTNodeBase value);
    [CompilerGeneratedAttribute]
public string get_Boost();
    [CompilerGeneratedAttribute]
public void set_Boost(string value);
    public virtual string ToString();
    public float GetBoost();
}
public class Raven.Database.Indexing.PostfixModifiers : object {
    [CompilerGeneratedAttribute]
private string <Boost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Similerity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Proximity>k__BackingField;
    public string Boost { get; public set; }
    public string Similerity { get; public set; }
    public string Proximity { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Boost();
    [CompilerGeneratedAttribute]
public void set_Boost(string value);
    [CompilerGeneratedAttribute]
public string get_Similerity();
    [CompilerGeneratedAttribute]
public void set_Similerity(string value);
    [CompilerGeneratedAttribute]
public string get_Proximity();
    [CompilerGeneratedAttribute]
public void set_Proximity(string value);
}
public class Raven.Database.Indexing.PrecomputedIndexingBatch : object {
    public Etag LastIndexed;
    public DateTime LastModified;
    public List`1<JsonDocument> Documents;
    public Index Index;
}
public class Raven.Database.Indexing.PropertyAccessor : object {
    public Dictionary`2<string, DynamicGetter> Properies;
    public static PropertyAccessor Create(Type type);
    public object GetValue(string name, object target);
    private static DynamicGetter CreateGetMethod(PropertyInfo propertyInfo, Type type);
}
public static class Raven.Database.Indexing.QueryBuilder : object {
    private static string FieldRegexVal;
    private static string MethodRegexVal;
    private static string DateTimeVal;
    private static Regex fieldQuery;
    private static Regex untokenizedQuery;
    private static Regex searchQuery;
    private static Regex dateQuery;
    private static Regex inDatesQuery;
    private static Regex rightOpenRangeQuery;
    private static Regex leftOpenRangeQuery;
    private static Regex commentsRegex;
    private static bool useLuceneASTParser;
    private static Dictionary`2<string, Func`3<string, List`1<string>, Query>> queryMethods;
    private static Regex unescapedSplitter;
    public static bool UseLuceneASTParser { get; public set; }
    private static QueryBuilder();
    public static bool get_UseLuceneASTParser();
    public static void set_UseLuceneASTParser(bool value);
    public static Query BuildQuery(string query, RavenPerFieldAnalyzerWrapper analyzer);
    public static Query BuildQuery(string query, IndexQuery indexQuery, RavenPerFieldAnalyzerWrapper analyzer);
    private static bool MightMatchComments(string query);
    internal static string PreProcessComments(string query);
    internal static Query HandleMethods(Query query, RavenPerFieldAnalyzerWrapper analyzer);
    internal static Query HandleMethodsForQueryAndTerm(Query query, Term term);
    internal static Query HandleMethodsForQueryAndTerm(Query query, Term[] terms);
    private static bool TryHandlingMethodForQueryAndTerm(String& field, Func`3& value);
    private static bool MightMatchDateTerms(string query);
    internal static string PreProcessDateTerms(string query, RangeQueryParser queryParser);
    private static string TokenReplace(string query, MatchCollection searchMatches, Func`3<string, string, string> replacFunc);
    private static bool MightMatchSearchTerms(string query);
    internal static string PreProcessSearchTerms(string query);
    private static bool MightMatchUntokenizedTerms(string query);
    private static string PreProcessUntokenizedTerms(string query, RangeQueryParser queryParser);
    public static string Unescape(string term);
    private static bool MightMatchMixedInclusiveExclusiveRangeQueries(string query);
    public static string PreProcessMixedInclusiveExclusiveRangeQueries(string query);
    public static string GetQueryForAllMatchingDocumentsForIndex(DocumentDatabase database, HashSet`1<string> entityNames);
    private static void GetQueryForAllMatchingDocumentsForIndex(DocumentDatabase database, HashSet`1<string> entityNames, StringBuilder sb);
    private static void AppendTermToQuery(string term, StringBuilder sb);
}
public class Raven.Database.Indexing.RangeLuceneASTNode : LuceneASTNodeBase {
    [CompilerGeneratedAttribute]
private TermLuceneASTNode <RangeMin>k__BackingField;
    [CompilerGeneratedAttribute]
private TermLuceneASTNode <RangeMax>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InclusiveMin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InclusiveMax>k__BackingField;
    public IEnumerable`1<LuceneASTNodeBase> Children { get; }
    public TermLuceneASTNode RangeMin { get; public set; }
    public TermLuceneASTNode RangeMax { get; public set; }
    public bool InclusiveMin { get; public set; }
    public bool InclusiveMax { get; public set; }
    [IteratorStateMachineAttribute("Raven.Database.Indexing.RangeLuceneASTNode/<get_Children>d__1")]
public virtual IEnumerable`1<LuceneASTNodeBase> get_Children();
    public virtual Query ToQuery(LuceneASTQueryConfiguration configuration);
    private void OverideInclusive();
    private bool shouldOverideInclusive(TermLuceneASTNode min, TermLuceneASTNode max);
    [CompilerGeneratedAttribute]
public TermLuceneASTNode get_RangeMin();
    [CompilerGeneratedAttribute]
public void set_RangeMin(TermLuceneASTNode value);
    [CompilerGeneratedAttribute]
public TermLuceneASTNode get_RangeMax();
    [CompilerGeneratedAttribute]
public void set_RangeMax(TermLuceneASTNode value);
    [CompilerGeneratedAttribute]
public bool get_InclusiveMin();
    [CompilerGeneratedAttribute]
public void set_InclusiveMin(bool value);
    [CompilerGeneratedAttribute]
public bool get_InclusiveMax();
    [CompilerGeneratedAttribute]
public void set_InclusiveMax(bool value);
    public virtual string ToString();
}
public class Raven.Database.Indexing.RangeQueryParser : QueryParser {
    public static Regex NumericRangeValue;
    public static Regex DateTimeValue;
    private Dictionary`2<string, HashSet`1<string>> untokenized;
    private Dictionary`2<Tuple`2<string, string>, string> replacedTokens;
    public RangeQueryParser(Version matchVersion, string f, Analyzer a);
    private static RangeQueryParser();
    public string ReplaceToken(string fieldName, string replacement);
    public string ReplaceDateTimeTokensInMethod(string fieldName, string collection);
    protected virtual Query GetPrefixQuery(string field, string termStr);
    protected virtual Query GetWildcardQuery(string field, string termStr);
    protected virtual Query GetFuzzyQuery(string field, string termStr, float minSimilarity);
    protected virtual Query GetFieldQuery(string field, string queryText);
    protected virtual Query GetRangeQuery(string field, string lower, string upper, bool inclusive);
    public void SetUntokenized(string field, string value);
}
public class Raven.Database.Indexing.RavenIndexWriter : object {
    public static long CommitMarker;
    private static ILog LogIndexing;
    private int maximumNumberOfWritesBeforeRecreate;
    private IndexWriter indexWriter;
    private Directory directory;
    private Analyzer analyzer;
    private IndexDeletionPolicy indexDeletionPolicy;
    private MaxFieldLength maxFieldLength;
    private int currentNumberOfWrites;
    private IndexReaderWarmer _indexReaderWarmer;
    private int changesSinceCommit;
    private Field forceCommitField;
    private Term forceCommitTerm;
    private Document forceCommitDoc;
    private DateTime lastCommitDataStoreTime;
    private string indexName;
    public Directory Directory { get; }
    public Analyzer Analyzer { get; }
    public RavenIndexWriter(Directory d, Analyzer a, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl, int maximumNumberOfWritesBeforeRecreate, IndexReaderWarmer indexReaderWarmer, string indexName);
    private static RavenIndexWriter();
    public Directory get_Directory();
    public Analyzer get_Analyzer();
    public void AddDocument(Document doc);
    public void AddDocument(Document doc, Analyzer a);
    public void DeleteDocuments(Term term);
    public void DeleteDocuments(Term[] terms);
    public IndexReader GetReader();
    public void Commit(Etag lastEtag, bool forceCommit, bool considerLastCommitedTime);
    private void ForceCommitDataStore();
    public long RamSizeInBytes();
    public void Optimize();
    private void RecreateIfNecessary(bool force);
    private void CreateIndexWriter();
    private void DisposeIndexWriter(bool waitForMerges);
    public sealed virtual void Dispose();
    public void Dispose(bool waitForMerges);
    public RavenIndexWriter CreateRamWriter();
    public void AddIndexesNoOptimize(Directory[] directories, int count);
    public int NumDocs();
}
public class Raven.Database.Indexing.RavenPerFieldAnalyzerWrapper : Analyzer {
    private Analyzer defaultAnalyzer;
    private IDictionary`2<string, Analyzer> analyzerMap;
    public RavenPerFieldAnalyzerWrapper(Analyzer defaultAnalyzer);
    public void AddAnalyzer(string fieldName, Analyzer analyzer);
    public virtual TokenStream TokenStream(string fieldName, TextReader reader);
    private Analyzer GetAnalyzer(string fieldName);
    public virtual TokenStream ReusableTokenStream(string fieldName, TextReader reader);
    public virtual int GetPositionIncrementGap(string fieldName);
    public virtual int GetOffsetGap(IFieldable field);
    public virtual string ToString();
}
public class Raven.Database.Indexing.ReduceBatchSizeAutoTuner : BaseBatchSizeAutoTuner {
    [CompilerGeneratedAttribute]
private int <LastAmountOfItemsToRemember>k__BackingField;
    private List`1<int> lastAmountOfItemsToReduce;
    public int InitialNumberOfItems { get; }
    protected int MaxNumberOfItems { get; }
    protected int CurrentNumberOfItems { get; protected set; }
    protected int LastAmountOfItemsToRemember { get; protected set; }
    protected string Name { get; }
    public ReduceBatchSizeAutoTuner(WorkContext context);
    private void InstallGauges();
    public virtual int get_InitialNumberOfItems();
    protected virtual int get_MaxNumberOfItems();
    protected virtual int get_CurrentNumberOfItems();
    protected virtual void set_CurrentNumberOfItems(int value);
    [CompilerGeneratedAttribute]
protected sealed virtual int get_LastAmountOfItemsToRemember();
    [CompilerGeneratedAttribute]
protected sealed virtual void set_LastAmountOfItemsToRemember(int value);
    protected virtual void RecordAmountOfItems(int numberOfItems);
    protected virtual IEnumerable`1<int> GetLastAmountOfItems();
    protected virtual string get_Name();
    [CompilerGeneratedAttribute]
private int <InstallGauges>b__1_0();
    [CompilerGeneratedAttribute]
private int <InstallGauges>b__1_1();
    [CompilerGeneratedAttribute]
private int <InstallGauges>b__1_2();
}
public class Raven.Database.Indexing.ReducingExecuter : AbstractIndexingExecuter {
    public bool ShouldRun { get; }
    public ReducingExecuter(WorkContext context, IndexReplacer indexReplacer);
    protected ReducingPerformanceStats[] HandleReduceForIndex(IndexToWorkOn indexToWorkOn, bool skipIncreasingBatchSize, CancellationToken token);
    protected virtual void UpdateStalenessMetrics(int staleCount);
    protected virtual bool ShouldSkipIndex(Index index);
    private ReducingPerformanceStats MultiStepReduce(IndexToWorkOn index, List`1<string> keysToReduce, AbstractViewGenerator viewGenerator, ConcurrentSet`1<object> itemsToDelete, bool skipIncreasingBatchSize, CancellationToken token);
    private ReducingPerformanceStats SingleStepReduce(IndexToWorkOn index, List`1<string> keysToReduce, AbstractViewGenerator viewGenerator, ConcurrentSet`1<object> itemsToDelete, bool skipIncreasingBatchSize, CancellationToken token);
    private void UpdatePerformedSingleStep(int indexId, ConcurrentQueue`1<HashSet`1<string>> queue, bool skipAdd);
    private void UpdatePerformedReduceType(int indexId, HashSet`1<string> reduceKeys, ReduceType reduceType, bool skipAdd);
    protected virtual bool IsIndexStale(IndexStats indexesStat, IStorageActionsAccessor actions, bool isIdle, Reference`1<bool> onlyFoundIdleWork);
    public virtual bool get_ShouldRun();
    protected virtual void FlushAllIndexes();
    protected virtual IndexToWorkOn GetIndexToWorkOn(IndexStats indexesStat);
    protected virtual void ExecuteIndexingWork(IList`1<IndexToWorkOn> mapReduceIndexes);
    protected virtual bool IsValidIndex(IndexStats indexesStat);
    protected virtual void CleanupScheduledReductions();
    [CompilerGeneratedAttribute]
private void <CleanupScheduledReductions>b__15_0(IStorageActionsAccessor actions);
}
public class Raven.Database.Indexing.RobustEnumerator : object {
    private Action BeforeMoveNext;
    private Action CancelMoveNext;
    private Action`2<Exception, object> OnError;
    private CancellationToken cancellationToken;
    private int numberOfConsecutiveErrors;
    public Stopwatch MoveNextDuration;
    public RobustEnumerator(CancellationToken cancellationToken, int numberOfConsecutiveErrors, Action beforeMoveNext, Action cancelMoveNext, Action`2<Exception, object> onError);
    [IteratorStateMachineAttribute("Raven.Database.Indexing.RobustEnumerator/<RobustEnumeration>d__7")]
public IEnumerable`1<object> RobustEnumeration(IEnumerator`1<object> input, IndexingFunc func);
    [IteratorStateMachineAttribute("Raven.Database.Indexing.RobustEnumerator/<RobustEnumeration>d__8")]
public IEnumerable`1<object> RobustEnumeration(IEnumerator`1<object> input, List`1<IndexingFunc> funcs);
    private Nullable`1<bool> MoveNext(IEnumerator en, StatefulEnumerableWrapper`1<object> innerEnumerator);
}
[GeneratedCodeAttribute("Gardens Point Parser Generator", "1.5.2")]
internal abstract class Raven.Database.Indexing.ScanBase : AbstractScanner`2<ValueType, LexLocation> {
    private LexLocation __yylloc;
    public LexLocation yylloc { get; public set; }
    public virtual LexLocation get_yylloc();
    public virtual void set_yylloc(LexLocation value);
    protected virtual bool yywrap();
}
[GeneratedCodeAttribute("Gardens Point Parser Generator", "1.5.2")]
internal class Raven.Database.Indexing.ScanObj : object {
    public int token;
    public ValueType yylval;
    public LexLocation yylloc;
    public ScanObj(int t, ValueType val, LexLocation loc);
}
internal class Raven.Database.Indexing.SimpleIndex : Index {
    [CompilerGeneratedAttribute]
private DateTime <LastCommitPointStoreTime>k__BackingField;
    private ConcurrentDictionary`2<Type, PropertyAccessor> propertyAccessorCache;
    public bool IsMapReduce { get; }
    public DateTime LastCommitPointStoreTime { get; private set; }
    public SimpleIndex(Directory directory, int id, IndexDefinition indexDefinition, AbstractViewGenerator viewGenerator, WorkContext context);
    public virtual bool get_IsMapReduce();
    [CompilerGeneratedAttribute]
public DateTime get_LastCommitPointStoreTime();
    [CompilerGeneratedAttribute]
private void set_LastCommitPointStoreTime(DateTime value);
    public virtual IndexingPerformanceStats IndexDocuments(AbstractViewGenerator viewGenerator, IndexingBatch batch, IStorageActionsAccessor actions, DateTime minimumTimestamp, CancellationToken token);
    private void InitializeIndexingPerformanceCompleteDelegate(IndexingPerformanceStats performance, int sourceCount, int count, List`1<BasePerformanceStats> performanceStats);
    protected virtual bool IsUpToDateEnoughToWriteToDisk(Etag highestETag);
    protected virtual void HandleCommitPoints(IndexedItemsInfo itemsInfo, IndexSegmentsInfo segmentsInfo);
    private bool ShouldStoreCommitPoint(IndexedItemsInfo itemsInfo);
    private IndexingResult GetIndexingResult(object doc, AnonymousObjectToLuceneDocumentConverter anonymousObjectToLuceneDocumentConverter, Single& boost);
    private IndexingResult ExtractIndexDataFromDocument(AnonymousObjectToLuceneDocumentConverter anonymousObjectToLuceneDocumentConverter, DynamicJsonObject dynamicJsonObject);
    private IndexingResult ExtractIndexDataFromDocument(AnonymousObjectToLuceneDocumentConverter anonymousObjectToLuceneDocumentConverter, object doc);
    private string GetDocumentId(object doc, PropertyAccessor& accessor);
    public virtual void Remove(String[] keys, WorkContext context);
    internal void RemoveDirectlyFromIndex(String[] keys, Etag lastEtag);
}
public class Raven.Database.Indexing.SimpleQueryParser : object {
    private static RavenPerFieldAnalyzerWrapper perFieldAnalyzerWrapper;
    private static SimpleQueryParser();
    public static HashSet`1<string> GetFields(IndexQuery query);
    private static void PopulateFields(Query query, HashSet`1<string> fields);
    private static bool PopulateField(Query query, HashSet`1<string> fields);
    public static HashSet`1<Tuple`2<string, string>> GetFieldsForDynamicQuery(IndexQuery query);
    public static string TranslateField(string field);
}
public class Raven.Database.Indexing.Sorting.AlphaNumeric.AlphaNumericComparatorSource : FieldComparatorSource {
    public virtual FieldComparator NewComparator(string fieldname, int numHits, int sortPos, bool reversed);
}
[DefaultMemberAttribute("Item")]
public class Raven.Database.Indexing.Sorting.AlphaNumeric.AlphaNumericFieldComparator : FieldComparator {
    private String[] values;
    private string field;
    private string bottom;
    private Int32[] order;
    private String[] lookup;
    public IComparable Item { get; }
    public AlphaNumericFieldComparator(int numHits, string field);
    public virtual int Compare(int slot1, int slot2);
    public virtual void SetBottom(int slot);
    public virtual int CompareBottom(int doc);
    public virtual void Copy(int slot, int doc);
    public virtual void SetNextReader(IndexReader reader, int docBase);
    public virtual IComparable get_Item(int slot);
}
public class Raven.Database.Indexing.Sorting.Custom.CustomSortField : SortField {
    private IndexEntriesToComparablesGenerator generator;
    public FieldComparatorSource ComparatorSource { get; }
    public CustomSortField(string typeName, IndexQuery indexQuery, bool reverse);
    public virtual FieldComparator GetComparator(int numHits, int sortPos);
    public virtual FieldComparatorSource get_ComparatorSource();
}
[DefaultMemberAttribute("Item")]
public class Raven.Database.Indexing.Sorting.Custom.CustomSortFieldCompartor : FieldComparator {
    private IndexEntriesToComparablesGenerator generator;
    private IComparable[] values;
    private IComparable bottom;
    private IndexReader currentReader;
    public IComparable Item { get; }
    public CustomSortFieldCompartor(IndexEntriesToComparablesGenerator generator, int numHits);
    public virtual int Compare(int slot1, int slot2);
    public virtual void SetBottom(int slot);
    public virtual int CompareBottom(int doc);
    public virtual void Copy(int slot, int doc);
    public virtual void SetNextReader(IndexReader reader, int docBase);
    public virtual IComparable get_Item(int slot);
}
public abstract class Raven.Database.Indexing.Sorting.Custom.IndexEntriesToComparablesGenerator : object {
    protected IndexQuery IndexQuery;
    protected IndexEntriesToComparablesGenerator(IndexQuery indexQuery);
    public abstract virtual IComparable Generate(IndexReader reader, int doc);
}
public class Raven.Database.Indexing.Sorting.DistanceValue : ValueType {
    public double Value;
    public sealed virtual int CompareTo(object obj);
}
[ExtensionAttribute]
public static class Raven.Database.Indexing.Sorting.DocumentIdSet : object {
    private static ConditionalWeakTable`2<IndexReader, ConcurrentDictionary`2<Tuple`2<string, Predicate`1<string>>, Predicate`1<int>>> documentIdsSetBuildersCache;
    private static ConditionalWeakTable`2<IndexReader, ConcurrentDictionary`2<string, Dictionary`2<int, string>>> fieldsStringValuesInReadersCache;
    private static DocumentIdSetCleaner documentIdSetCleaner;
    private static ConcurrentSet`1<WeakReference`1<IndexReader>> _keys;
    private static DocumentIdSet();
    [ExtensionAttribute]
public static Predicate`1<int> GetDocsExistenceVerificationMethodInSet(IndexReader reader, string field, Predicate`1<string> termAcceptanceFunction);
    [ExtensionAttribute]
public static Dictionary`2<int, string> GetDocsAndValuesDictionary(IndexReader reader, string field);
}
[DefaultMemberAttribute("Item")]
public class Raven.Database.Indexing.Sorting.RandomFieldComparator : FieldComparator {
    private Random random;
    private Int32[] values;
    private int bottom;
    private Int32[] currentReaderValues;
    public IComparable Item { get; }
    internal RandomFieldComparator(int numHits, string field);
    public virtual int Compare(int slot1, int slot2);
    public virtual int CompareBottom(int doc);
    public virtual void Copy(int slot, int doc);
    public virtual void SetNextReader(IndexReader reader, int docBase);
    public virtual IComparable get_Item(int slot);
    public virtual void SetBottom(int bottom);
}
public class Raven.Database.Indexing.Sorting.RandomFieldComparatorSource : FieldComparatorSource {
    public virtual FieldComparator NewComparator(string fieldname, int numHits, int sortPos, bool reversed);
}
public class Raven.Database.Indexing.Sorting.RandomSortField : SortField {
    public FieldComparatorSource ComparatorSource { get; }
    public RandomSortField(string field);
    public virtual FieldComparator GetComparator(int numHits, int sortPos);
    public virtual FieldComparatorSource get_ComparatorSource();
}
public class Raven.Database.Indexing.Sorting.SpatialDistanceFieldComparatorSource : FieldComparatorSource {
    private Point center;
    private SpatialField spatialField;
    public SpatialDistanceFieldComparatorSource(SpatialField spatialField, Point center);
    public virtual FieldComparator NewComparator(string fieldname, int numHits, int sortPos, bool reversed);
}
internal class Raven.Database.Indexing.Spatial.BBoxStrategyThatSupportsAllShapes : BBoxStrategy {
    public BBoxStrategyThatSupportsAllShapes(SpatialContext ctx, string fieldNamePrefix);
    private Rectangle GetRectangle(Shape shape);
    public virtual AbstractField[] CreateIndexableFields(Shape shape);
    public virtual ConstantScoreQuery MakeQuery(SpatialArgs args);
    public virtual Filter MakeFilter(SpatialArgs args);
}
internal class Raven.Database.Indexing.Spatial.RecursivePrefixTreeStrategyThatSupportsWithin : PrefixTreeStrategy {
    private int prefixGridScanLevel;
    public RecursivePrefixTreeStrategyThatSupportsWithin(SpatialPrefixTree grid, string fieldName);
    public void SetPrefixGridScanLevel(int prefixGridScanLevel);
    public virtual Filter MakeFilter(SpatialArgs args);
    public virtual string ToString();
}
public class Raven.Database.Indexing.Spatial.ShapeStringConverter : object {
    private SpatialOptions options;
    private static Regex RegexBox;
    private static Regex RegexGeoUriCoord;
    private static Regex RegexGeoUriUncert;
    private static double KmToMiles;
    public ShapeStringConverter(SpatialOptions options);
    private static ShapeStringConverter();
    public string ConvertToWKT(string shape);
    private bool TryParseBox(string value, String& shape);
    private bool TryParseGeoUri(string uriString, String& shape);
    protected string MakePoint(double x, double y);
    protected string MakeCircle(double x, double y, double radius);
}
public class Raven.Database.Indexing.Spatial.ShapeStringReadWriter : object {
    private static WktSanitizer WktSanitizer;
    private static NtsShapeReadWriter geoShapeReadWriter;
    private SpatialOptions options;
    private NtsShapeReadWriter ntsShapeReadWriter;
    private ShapeStringConverter shapeStringConverter;
    private static double DegreesToRadians;
    private static double RadiansToDegrees;
    private static Regex CircleShape;
    public ShapeStringReadWriter(SpatialOptions options, NtsSpatialContext context);
    private static ShapeStringReadWriter();
    private NtsShapeReadWriter CreateNtsShapeReadWriter(SpatialOptions opt, NtsSpatialContext ntsContext);
    public Shape ReadShape(string shape, Nullable`1<SpatialUnits> unitOverride);
    public string WriteShape(Shape shape);
    private double TranslateCircleRadius(double radius, SpatialUnits units);
    private string TranslateCircleRadius(string shapeWKT, SpatialUnits units);
}
public class Raven.Database.Indexing.SpatialField : object {
    private static NtsSpatialContext GeoContext;
    private static ShapeConverter ShapeConverter;
    private SpatialOptions options;
    private NtsSpatialContext ntsContext;
    private SpatialStrategy strategy;
    private ShapeStringReadWriter shapeStringReadWriter;
    private static SpatialField();
    public SpatialField(string fieldName, SpatialOptions options);
    private NtsSpatialContext CreateNtsContext(SpatialOptions opt);
    [CLSCompliantAttribute("False")]
public SpatialStrategy GetStrategy();
    public NtsSpatialContext GetContext();
    private SpatialStrategy CreateStrategy(string fieldName, SpatialOptions opt, NtsSpatialContext context);
    public IEnumerable`1<AbstractField> CreateIndexableFields(object value);
    [CLSCompliantAttribute("False")]
public Query MakeQuery(Query existingQuery, SpatialStrategy spatialStrategy, SpatialIndexQuery spatialQuery);
    [CLSCompliantAttribute("False")]
public Query MakeQuery(Query existingQuery, SpatialStrategy spatialStrategy, string shapeWKT, SpatialRelation relation, double distanceErrorPct, Nullable`1<SpatialUnits> unitOverride);
    [CLSCompliantAttribute("False")]
public Filter MakeFilter(SpatialStrategy spatialStrategy, IndexQuery indexQuery);
    public bool TryReadShape(object value, Shape& shape);
    public Shape ReadShape(string shapeWKT, Nullable`1<SpatialUnits> unitOverride);
    public string WriteShape(Shape shape);
}
public class Raven.Database.Indexing.StatefulEnumerableWrapper`1 : object {
    private IEnumerator`1<T> inner;
    private bool calledMoveNext;
    private bool enumerationCompleted;
    public T Current { get; }
    public StatefulEnumerableWrapper`1(IEnumerator`1<T> inner);
    public T get_Current();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Dispose();
}
public class Raven.Database.Indexing.TermLuceneASTNode : LuceneASTNodeBase {
    [CompilerGeneratedAttribute]
private string <Boost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Similarity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Proximity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Term>k__BackingField;
    [CompilerGeneratedAttribute]
private TermType <Type>k__BackingField;
    public IEnumerable`1<LuceneASTNodeBase> Children { get; }
    public string Boost { get; public set; }
    public string Similarity { get; public set; }
    public string Proximity { get; public set; }
    public string Term { get; public set; }
    public TermType Type { get; public set; }
    [IteratorStateMachineAttribute("Raven.Database.Indexing.TermLuceneASTNode/<get_Children>d__1")]
public virtual IEnumerable`1<LuceneASTNodeBase> get_Children();
    [IteratorStateMachineAttribute("Raven.Database.Indexing.TermLuceneASTNode/<GetAnalyzedTerm>d__2")]
public IEnumerable`1<string> GetAnalyzedTerm(LuceneASTQueryConfiguration configuration);
    private Term GetWildcardTerm(LuceneASTQueryConfiguration configuration);
    private Query AnalyzedWildCardQueries(LuceneASTQueryConfiguration configuration);
    public virtual Query ToQuery(LuceneASTQueryConfiguration configuration);
    [CompilerGeneratedAttribute]
public string get_Boost();
    [CompilerGeneratedAttribute]
public void set_Boost(string value);
    [CompilerGeneratedAttribute]
public string get_Similarity();
    [CompilerGeneratedAttribute]
public void set_Similarity(string value);
    [CompilerGeneratedAttribute]
public string get_Proximity();
    [CompilerGeneratedAttribute]
public void set_Proximity(string value);
    [CompilerGeneratedAttribute]
public string get_Term();
    [CompilerGeneratedAttribute]
public void set_Term(string value);
    [CompilerGeneratedAttribute]
public TermType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TermType value);
    public virtual string ToString();
    public void SetPostfixOperators(PostfixModifiers modifiers);
}
internal enum Raven.Database.Indexing.Token : Enum {
    public int value__;
    public static Token error;
    public static Token EOF;
    public static Token NOT;
    public static Token OR;
    public static Token AND;
    public static Token INTERSECT;
    public static Token PLUS;
    public static Token MINUS;
    public static Token OPEN_CURLY_BRACKET;
    public static Token CLOSE_CURLY_BRACKET;
    public static Token OPEN_SQUARE_BRACKET;
    public static Token CLOSE_SQUARE_BRACKET;
    public static Token TILDA;
    public static Token BOOST;
    public static Token QUOTE;
    public static Token TO;
    public static Token COLON;
    public static Token OPEN_PAREN;
    public static Token CLOSE_PAREN;
    public static Token ALL_DOC;
    public static Token UNANALIZED_TERM;
    public static Token METHOD;
    public static Token UNQUOTED_TERM;
    public static Token QUOTED_TERM;
    public static Token QUOTED_WILDCARD_TERM;
    public static Token FLOAT_NUMBER;
    public static Token INT_NUMBER;
    public static Token DOUBLE_NUMBER;
    public static Token LONG_NUMBER;
    public static Token DATETIME;
    public static Token NULL;
    public static Token PREFIX_TERM;
    public static Token WILDCARD_TERM;
    public static Token HEX_NUMBER;
}
internal class Raven.Database.Indexing.ValueType : ValueType {
    public string s;
    public FieldLuceneASTNode fn;
    public ParenthesistLuceneASTNode pn;
    public PostfixModifiers pm;
    public LuceneASTNodeBase nb;
    public Operator o;
    public RangeLuceneASTNode rn;
    public TermLuceneASTNode tn;
    public MethodLuceneASTNode mn;
    public List`1<TermLuceneASTNode> ltn;
    public PrefixOperator npo;
}
public class Raven.Database.Indexing.WorkContext : object {
    private SizeLimitedConcurrentSet`1<FilteredOutIndexStat> recentlyFilteredOutIndexes;
    private ConcurrentSet`1<FutureBatchStats> futureBatchStats;
    private SizeLimitedConcurrentSet`1<string> recentlyDeleted;
    private long nextIndexingBatchInfoId;
    private long nextReducingBatchInfoId;
    private long nextDeletionBatchInfoId;
    private SizeLimitedConcurrentSet`1<IndexingBatchInfo> lastActualIndexingBatchInfo;
    private SizeLimitedConcurrentSet`1<ReducingBatchInfo> lastActualReducingBatchInfo;
    private SizeLimitedConcurrentSet`1<DeletionBatchInfo> lastActualDeletionBatchInfo;
    private ConcurrentQueue`1<IndexingError> indexingErrors;
    private ConcurrentDictionary`2<int, object> indexingErrorLocks;
    private object waitForWork;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) doWork;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) doIndexing;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) doReducing;
    private int workCounter;
    private CancellationTokenSource cancellationTokenSource;
    private static ILog log;
    private ThreadLocal`1<Stack`1<List`1<Func`1<string>>>> shouldNotifyOnWork;
    private long errorsCounter;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractIndexUpdateTrigger> <IndexUpdateTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractReadTrigger> <ReadTriggers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractIndexReaderWarmer> <IndexReaderWarmers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastIdleTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, ConcurrentSet`1<ExecutingQueryInfo>> <CurrentlyRunningQueries>k__BackingField;
    private int nextQueryId;
    [CompilerGeneratedAttribute]
private InMemoryRavenConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexStorage <IndexStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskScheduler <TaskScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexDefinitionStorage <IndexDefinitionStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private ITransactionalStorage <TransactionalStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentNumberOfItemsToIndexInSingleBatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentNumberOfItemsToReduceInSingleBatch>k__BackingField;
    public ManualResetEventSlim ReplicationResetEvent;
    [CompilerGeneratedAttribute]
private Action`1<IndexChangeNotification> <RaiseIndexChangeNotification>k__BackingField;
    private bool disposed;
    private long lastWorkTimeTicks;
    [CompilerGeneratedAttribute]
private MetricsCountersManager <MetricsCounters>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ShowTimingByDefaultUntil>k__BackingField;
    public OrderedPartCollection`1<AbstractIndexUpdateTrigger> IndexUpdateTriggers { get; public set; }
    public OrderedPartCollection`1<AbstractReadTrigger> ReadTriggers { get; public set; }
    public OrderedPartCollection`1<AbstractIndexReaderWarmer> IndexReaderWarmers { get; public set; }
    public string DatabaseName { get; public set; }
    public DateTime LastWorkTime { get; }
    public DateTime LastIdleTime { get; public set; }
    public bool DoWork { get; }
    public bool RunIndexing { get; }
    public bool RunReducing { get; }
    public ConcurrentDictionary`2<string, ConcurrentSet`1<ExecutingQueryInfo>> CurrentlyRunningQueries { get; private set; }
    public InMemoryRavenConfiguration Configuration { get; public set; }
    public IndexStorage IndexStorage { get; public set; }
    public TaskScheduler TaskScheduler { get; public set; }
    public IndexDefinitionStorage IndexDefinitionStorage { get; public set; }
    [CLSCompliantAttribute("False")]
public ITransactionalStorage TransactionalStorage { get; public set; }
    public IndexingError[] Errors { get; }
    public int CurrentNumberOfParallelTasks { get; }
    public int CurrentNumberOfItemsToIndexInSingleBatch { get; public set; }
    public int CurrentNumberOfItemsToReduceInSingleBatch { get; public set; }
    public int NumberOfItemsToExecuteReduceInSingleStep { get; }
    public CancellationToken CancellationToken { get; }
    public Action`1<IndexChangeNotification> RaiseIndexChangeNotification { get; public set; }
    [CLSCompliantAttribute("False")]
public MetricsCountersManager MetricsCounters { get; private set; }
    public ConcurrentSet`1<FutureBatchStats> FutureBatchStats { get; }
    public SizeLimitedConcurrentSet`1<FilteredOutIndexStat> RecentlyFilteredOutIndexes { get; }
    public SizeLimitedConcurrentSet`1<IndexingBatchInfo> LastActualIndexingBatchInfo { get; }
    public SizeLimitedConcurrentSet`1<ReducingBatchInfo> LastActualReducingBatchInfo { get; }
    public SizeLimitedConcurrentSet`1<DeletionBatchInfo> LastActualDeletionBatchInfo { get; }
    public DocumentDatabase Database { get; public set; }
    public Nullable`1<DateTime> ShowTimingByDefaultUntil { get; public set; }
    private static WorkContext();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractIndexUpdateTrigger> get_IndexUpdateTriggers();
    [CompilerGeneratedAttribute]
public void set_IndexUpdateTriggers(OrderedPartCollection`1<AbstractIndexUpdateTrigger> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractReadTrigger> get_ReadTriggers();
    [CompilerGeneratedAttribute]
public void set_ReadTriggers(OrderedPartCollection`1<AbstractReadTrigger> value);
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<AbstractIndexReaderWarmer> get_IndexReaderWarmers();
    [CompilerGeneratedAttribute]
public void set_IndexReaderWarmers(OrderedPartCollection`1<AbstractIndexReaderWarmer> value);
    [CompilerGeneratedAttribute]
public string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    public DateTime get_LastWorkTime();
    [CompilerGeneratedAttribute]
public DateTime get_LastIdleTime();
    [CompilerGeneratedAttribute]
public void set_LastIdleTime(DateTime value);
    public bool get_DoWork();
    public bool get_RunIndexing();
    public bool get_RunReducing();
    public void UpdateFoundWork();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, ConcurrentSet`1<ExecutingQueryInfo>> get_CurrentlyRunningQueries();
    [CompilerGeneratedAttribute]
private void set_CurrentlyRunningQueries(ConcurrentDictionary`2<string, ConcurrentSet`1<ExecutingQueryInfo>> value);
    [CompilerGeneratedAttribute]
public InMemoryRavenConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(InMemoryRavenConfiguration value);
    [CompilerGeneratedAttribute]
public IndexStorage get_IndexStorage();
    [CompilerGeneratedAttribute]
public void set_IndexStorage(IndexStorage value);
    [CompilerGeneratedAttribute]
public TaskScheduler get_TaskScheduler();
    [CompilerGeneratedAttribute]
public void set_TaskScheduler(TaskScheduler value);
    [CompilerGeneratedAttribute]
public IndexDefinitionStorage get_IndexDefinitionStorage();
    [CompilerGeneratedAttribute]
public void set_IndexDefinitionStorage(IndexDefinitionStorage value);
    [CompilerGeneratedAttribute]
public ITransactionalStorage get_TransactionalStorage();
    [CompilerGeneratedAttribute]
public void set_TransactionalStorage(ITransactionalStorage value);
    public IndexingError[] get_Errors();
    public int get_CurrentNumberOfParallelTasks();
    [CompilerGeneratedAttribute]
public int get_CurrentNumberOfItemsToIndexInSingleBatch();
    [CompilerGeneratedAttribute]
public void set_CurrentNumberOfItemsToIndexInSingleBatch(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentNumberOfItemsToReduceInSingleBatch();
    [CompilerGeneratedAttribute]
public void set_CurrentNumberOfItemsToReduceInSingleBatch(int value);
    public int get_NumberOfItemsToExecuteReduceInSingleStep();
    public bool WaitForWork(TimeSpan timeout, Int32& workerWorkCounter, string name);
    private void InstallGauges();
    public void RecoverIndexingErrors();
    public bool WaitForWork(TimeSpan timeout, Int32& workerWorkCounter, Action beforeWait, string name);
    public void ShouldNotifyAboutWork(Func`1<string> why);
    public void HandleWorkNotifications();
    public void NestedTransactionEnter();
    public void NestedTransactionExit();
    public int GetWorkCount();
    public void NotifyAboutWork();
    public void StartWork();
    public void StopWork();
    public void AddError(int index, string indexName, string key, Exception exception);
    public void AddError(int index, string indexName, string key, Exception exception, string component);
    public void AddError(int index, string indexName, string key, string error);
    private void AddError(int index, string indexName, string key, string error, string component);
    public void StopWorkRude();
    public CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public void HandleIndexRename(string oldIndexName, string newIndexName, int newIndexId, IStorageActionsAccessor accessor);
    public void ClearErrorsFor(string indexName);
    public void ReplaceIndexingErrors(string indexToReplaceName, Nullable`1<int> indexToReplaceId, string indexName, int newIndexId);
    [CompilerGeneratedAttribute]
public Action`1<IndexChangeNotification> get_RaiseIndexChangeNotification();
    [CompilerGeneratedAttribute]
public void set_RaiseIndexChangeNotification(Action`1<IndexChangeNotification> value);
    [CompilerGeneratedAttribute]
public MetricsCountersManager get_MetricsCounters();
    [CompilerGeneratedAttribute]
private void set_MetricsCounters(MetricsCountersManager value);
    public IndexingBatchInfo ReportIndexingBatchStarted(int documentsCount, long documentsSize, List`1<string> indexesToWorkOn);
    public void ReportIndexingBatchCompleted(IndexingBatchInfo batchInfo);
    public ReducingBatchInfo ReportReducingBatchStarted(List`1<string> indexesToWorkOn);
    public void ReportReducingBatchCompleted(ReducingBatchInfo batchInfo);
    public DeletionBatchInfo ReportDeletionBatchStarted(string indexName, int documentCount);
    public void ReportDeletionBatchCompleted(DeletionBatchInfo batchInfo);
    public ConcurrentSet`1<FutureBatchStats> get_FutureBatchStats();
    public SizeLimitedConcurrentSet`1<FilteredOutIndexStat> get_RecentlyFilteredOutIndexes();
    public SizeLimitedConcurrentSet`1<IndexingBatchInfo> get_LastActualIndexingBatchInfo();
    public SizeLimitedConcurrentSet`1<ReducingBatchInfo> get_LastActualReducingBatchInfo();
    public SizeLimitedConcurrentSet`1<DeletionBatchInfo> get_LastActualDeletionBatchInfo();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ShowTimingByDefaultUntil();
    [CompilerGeneratedAttribute]
public void set_ShowTimingByDefaultUntil(Nullable`1<DateTime> value);
    public void AddFutureBatch(FutureBatchStats futureBatchStat);
    public void StopIndexing();
    public void StopReducing();
    public void StartReducing();
    public void StartMapping();
    public void StartIndexing();
    public void MarkAsRemovedFromIndex(HashSet`1<string> keys);
    public bool IndexRemovalQueueContainsAnyFrom(IEnumerable`1<string> keys);
    public bool ShouldRemoveFromIndex(string key);
    public void MarkDeleted(string key);
    public int GetNextQueryId();
    public void MarkIndexFilteredOut(string indexName);
    [CompilerGeneratedAttribute]
private int <InstallGauges>b__90_0();
}
public class Raven.Database.JsConsole.AdminJsConsole : object {
    private DocumentDatabase database;
    private static ILog _log;
    public AdminJsConsole(DocumentDatabase database);
    private static AdminJsConsole();
    public RavenJToken ApplyScript(AdminJsScript script);
    private Engine CreateEngine(AdminJsScript script);
}
public class Raven.Database.JsConsole.AdminJsScript : object {
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    public string Script { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Script();
    [CompilerGeneratedAttribute]
public void set_Script(string value);
}
internal class Raven.Database.Json.DefaultScriptedJsonPatcherOperationScope : ScriptedJsonPatcherOperationScope {
    private Dictionary`2<string, JsonDocument> documentKeyContext;
    private List`1<JsonDocument> incompleteDocumentKeyContext;
    private static String[] EtagKeyNames;
    public DefaultScriptedJsonPatcherOperationScope(DocumentDatabase database, bool debugMode);
    private static DefaultScriptedJsonPatcherOperationScope();
    public virtual JsValue LoadDocument(string documentKey, Engine engine, Int32& totalStatements);
    public virtual string PutDocument(string key, object documentAsObject, object metadataAsObject, Engine engine);
    private void GenerateKeyForPutDocument(string key, JsonDocument newDocument);
    public virtual void DeleteDocument(string documentKey);
    public virtual void Dispose();
    protected void AddToContext(string key, JsonDocument document);
    protected void DeleteFromContext(string key);
    public IEnumerable`1<Operation> GetOperations();
    public IEnumerable`1<JsonDocument> GetPutOperations();
}
[ExtensionAttribute]
public static class Raven.Database.Json.DynamicObjectExtensions : object {
    [ExtensionAttribute]
public static string Days(DateTime self);
    [ExtensionAttribute]
public static string Hours(DateTime self);
    [ExtensionAttribute]
public static string Minutes(DateTime self);
    [ExtensionAttribute]
public static string Seconds(DateTime self);
}
internal abstract class Raven.Database.Json.JintOperationScope : object {
    private Dictionary`2<string, KeyValuePair`2<RavenJValue, JsValue>> propertiesByValue;
    private static List`1<string> InheritedProperties;
    private static JintOperationScope();
    public RavenJObject ToRavenJObject(JsValue jsObject, string propertyKey, bool recursiveCall);
    private RavenJToken ToRavenJToken(JsValue v, string propertyKey, bool recursiveCall);
    public JsValue ToJsObject(Engine engine, RavenJObject doc, string propertyName);
    private static string CreatePropertyKey(string key, string property);
    public JsValue ToJsInstance(Engine engine, RavenJToken value, string propertyKey);
    private JsValue ToJsArray(Engine engine, RavenJArray array, string propertyKey);
    public virtual RavenJObject ConvertReturnValue(JsValue jsObject);
    public virtual void Dispose();
}
public class Raven.Database.Json.JsonPatcher : object {
    private RavenJObject document;
    public JsonPatcher(RavenJObject document);
    public RavenJObject Apply(PatchRequest[] patch);
    private void Apply(PatchRequest patchCmd);
    private void RenameProperty(PatchRequest patchCmd, string propName, RavenJToken property);
    private void CopyProperty(PatchRequest patchCmd, RavenJToken property);
    private static void ModifyValue(PatchRequest patchCmd, string propName, RavenJToken property);
    private void RemoveValue(PatchRequest patchCmd, string propName, RavenJToken token);
    private void InsertValue(PatchRequest patchCmd, string propName, RavenJToken property);
    private void AddValue(PatchRequest patchCmd, string propName, RavenJToken token);
    private static RavenJArray GetArray(RavenJToken property, string propName);
    private static RavenJArray TryGetArray(RavenJToken token);
    private static void RemoveProperty(PatchRequest patchCmd, string propName, RavenJToken token, RavenJToken parent);
    private void SetProperty(PatchRequest patchCmd, string propName, RavenJToken property);
    private void IncrementProperty(PatchRequest patchCmd, string propName, RavenJToken property);
    private static void EnsurePreviousValueMatchCurrentValue(PatchRequest patchCmd, RavenJToken property);
}
public static class Raven.Database.Json.JsonToExpando : object {
    public static object Convert(RavenJObject obj);
}
public class Raven.Database.Json.OptimisticConcurrencyViolationException : Exception {
    public OptimisticConcurrencyViolationException(string message);
    protected OptimisticConcurrencyViolationException(SerializationInfo info, StreamingContext context);
}
public class Raven.Database.Json.ParseException : Exception {
    public ParseException(string message);
    public ParseException(string message, Exception inner);
    protected ParseException(SerializationInfo info, StreamingContext context);
}
internal class Raven.Database.Json.ScriptedJsonPatcher : object {
    private static ScriptsCache ScriptsCache;
    public List`1<string> Debug;
    private int maxSteps;
    private int additionalStepsPerSize;
    private int totalScriptSteps;
    private DocumentDatabase database;
    private static int MaxRecursionDepth;
    public int TotalScriptSteps { get; }
    public ScriptedJsonPatcher(DocumentDatabase database);
    private static ScriptedJsonPatcher();
    public int get_TotalScriptSteps();
    public virtual RavenJObject Apply(ScriptedJsonPatcherOperationScope scope, RavenJObject document, ScriptedPatchRequest patch, int size, string docId);
    private RavenJObject ApplySingleScript(RavenJObject doc, ScriptedPatchRequest patch, int size, string docId, ScriptedJsonPatcherOperationScope scope);
    private void CleanupEngine(ScriptedPatchRequest patch, Engine jintEngine, ScriptedJsonPatcherOperationScope scope);
    private void PrepareEngine(ScriptedPatchRequest patch, string docId, int size, ScriptedJsonPatcherOperationScope scope, Engine jintEngine);
    private Engine CreateEngine(ScriptedPatchRequest patch);
    private static void AddScript(Engine jintEngine, string ravenDatabaseJsonMapJs);
    protected virtual void CustomizeEngine(Engine engine, ScriptedJsonPatcherOperationScope scope);
    protected virtual void RemoveEngineCustomizations(Engine engine, ScriptedJsonPatcherOperationScope scope);
    private void OutputLog(Engine engine);
    private static string GetFromResources(string resourceName);
}
internal abstract class Raven.Database.Json.ScriptedJsonPatcherOperationScope : JintOperationScope {
    private bool debugMode;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <CustomFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <DebugActions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AdditionalStepsPerSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private JsValue <ActualPatchResult>k__BackingField;
    internal bool DebugMode { get; }
    protected DocumentDatabase Database { get; private set; }
    public RavenJObject CustomFunctions { get; public set; }
    public RavenJObject DebugActions { get; private set; }
    public int AdditionalStepsPerSize { get; public set; }
    public int MaxSteps { get; public set; }
    public JsValue ActualPatchResult { get; public set; }
    protected ScriptedJsonPatcherOperationScope(DocumentDatabase database, bool debugMode);
    internal bool get_DebugMode();
    [CompilerGeneratedAttribute]
protected DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
private void set_Database(DocumentDatabase value);
    [CompilerGeneratedAttribute]
public RavenJObject get_CustomFunctions();
    [CompilerGeneratedAttribute]
public void set_CustomFunctions(RavenJObject value);
    [CompilerGeneratedAttribute]
public RavenJObject get_DebugActions();
    [CompilerGeneratedAttribute]
private void set_DebugActions(RavenJObject value);
    [CompilerGeneratedAttribute]
public int get_AdditionalStepsPerSize();
    [CompilerGeneratedAttribute]
public void set_AdditionalStepsPerSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxSteps();
    [CompilerGeneratedAttribute]
public void set_MaxSteps(int value);
    [CompilerGeneratedAttribute]
public JsValue get_ActualPatchResult();
    [CompilerGeneratedAttribute]
public void set_ActualPatchResult(JsValue value);
    protected virtual void ValidateDocument(JsonDocument newDocument);
    public abstract virtual JsValue LoadDocument(string documentKey, Engine engine, Int32& totalStatements);
    public abstract virtual string PutDocument(string documentKey, object data, object meta, Engine jintEngine);
    public abstract virtual void DeleteDocument(string documentKey);
    protected void RecordActionForDebug(string actionName, string documentKey, RavenJObject documentData, RavenJObject documentMetadata);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Json.ScriptsCache : object {
    private static int CacheMaxSize;
    private ConcurrentDictionary`2<ScriptedPatchRequestAndCustomFunctionsToken, CachedResult> cacheDic;
    public void CheckinScript(ScriptedPatchRequest request, Engine context, RavenJObject customFunctions);
    public Engine CheckoutScript(Func`2<ScriptedPatchRequest, Engine> createEngine, ScriptedPatchRequest request, RavenJObject customFunctions);
}
public abstract class Raven.Database.Linq.AbstractTransformer : object {
    private TransformerDefinition transformerDefinition;
    private Byte[] cachedBytes;
    [CompilerGeneratedAttribute]
private IndexingFunc <TransformResultsDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ViewText>k__BackingField;
    [CLSCompliantAttribute("False")]
protected DynamicNullObject __dynamic_null;
    public IndexingFunc TransformResultsDefinition { get; public set; }
    public string SourceCode { get; public set; }
    public string Name { get; }
    public string ViewText { get; public set; }
    [CompilerGeneratedAttribute]
public IndexingFunc get_TransformResultsDefinition();
    [CompilerGeneratedAttribute]
public void set_TransformResultsDefinition(IndexingFunc value);
    [CompilerGeneratedAttribute]
public string get_SourceCode();
    [CompilerGeneratedAttribute]
public void set_SourceCode(string value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public string get_ViewText();
    [CompilerGeneratedAttribute]
public void set_ViewText(string value);
    public IEnumerable`1<object> TransformWith(IEnumerable`1<string> transformers, object maybeItems);
    [IteratorStateMachineAttribute("Raven.Database.Linq.AbstractTransformer/<TransformWith>d__18")]
public IEnumerable`1<object> TransformWith(string transformer, object maybeItems);
    [IteratorStateMachineAttribute("Raven.Database.Linq.AbstractTransformer/<AllowAccessToResultsEvenIfTheyAreStupidInternalAnonymousTypes>d__19")]
private IEnumerable`1<object> AllowAccessToResultsEvenIfTheyAreStupidInternalAnonymousTypes(IEnumerable`1<object> items);
    protected object LoadDocument(object key);
    protected object LoadDocument(object key);
    [ObsoleteAttribute("Use Parameter instead.")]
protected RavenJToken Query(string key);
    [ObsoleteAttribute("Use ParameterOrDefault instead.")]
protected RavenJToken QueryOrDefault(string key, object val);
    protected RavenJToken Parameter(string key);
    protected RavenJToken ParameterOrDefault(string key, object val);
    public object Include(object key);
    protected IEnumerable`1<object> Recurse(object item, Func`2<object, object> func);
    public void Init(TransformerDefinition def);
    public Byte[] GetHashCodeBytes();
    protected bool Equals(AbstractTransformer other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private object <TransformWith>b__17_0(object items, string transformer);
}
[InheritedExportAttribute]
public abstract class Raven.Database.Linq.AbstractViewGenerator : object {
    private HashSet`1<string> fields;
    private Nullable`1<bool> containsProjection;
    private Nullable`1<int> countOfSelectMany;
    private Nullable`1<bool> hasWhereClause;
    private HashSet`1<string> mapFields;
    private HashSet`1<string> reduceFields;
    [CLSCompliantAttribute("False")]
protected DynamicNullObject __dynamic_null;
    private static Regex selectManyOrFrom;
    private IndexDefinition indexDefinition;
    [CompilerGeneratedAttribute]
private string <SourceCode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IndexingFunc> <MapDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexingFunc <ReduceDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private GroupByKeyFunc <GroupByExtraction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ViewText>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldStorage> <Stores>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldIndexing> <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, FieldTermVector> <TermVectors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, SpatialOptions> <SpatialIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ForEntityNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, SpatialField> <SpatialFields>k__BackingField;
    public string SourceCode { get; public set; }
    public string Name { get; }
    public int CountOfSelectMany { get; }
    public int CountOfFields { get; }
    public List`1<IndexingFunc> MapDefinitions { get; private set; }
    public IndexingFunc ReduceDefinition { get; public set; }
    public GroupByKeyFunc GroupByExtraction { get; public set; }
    public string ViewText { get; public set; }
    public IDictionary`2<string, FieldStorage> Stores { get; public set; }
    public IDictionary`2<string, FieldIndexing> Indexes { get; public set; }
    public IDictionary`2<string, FieldTermVector> TermVectors { get; public set; }
    public IDictionary`2<string, SpatialOptions> SpatialIndexes { get; public set; }
    public HashSet`1<string> ForEntityNames { get; public set; }
    public String[] Fields { get; }
    public bool HasWhereClause { get; }
    private ConcurrentDictionary`2<string, SpatialField> SpatialFields { get; private set; }
    private static AbstractViewGenerator();
    [CompilerGeneratedAttribute]
public string get_SourceCode();
    [CompilerGeneratedAttribute]
public void set_SourceCode(string value);
    public string get_Name();
    public int get_CountOfSelectMany();
    public int get_CountOfFields();
    [CompilerGeneratedAttribute]
public List`1<IndexingFunc> get_MapDefinitions();
    [CompilerGeneratedAttribute]
private void set_MapDefinitions(List`1<IndexingFunc> value);
    [CompilerGeneratedAttribute]
public IndexingFunc get_ReduceDefinition();
    [CompilerGeneratedAttribute]
public void set_ReduceDefinition(IndexingFunc value);
    [CompilerGeneratedAttribute]
public GroupByKeyFunc get_GroupByExtraction();
    [CompilerGeneratedAttribute]
public void set_GroupByExtraction(GroupByKeyFunc value);
    [CompilerGeneratedAttribute]
public string get_ViewText();
    [CompilerGeneratedAttribute]
public void set_ViewText(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, FieldStorage> get_Stores();
    [CompilerGeneratedAttribute]
public void set_Stores(IDictionary`2<string, FieldStorage> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, FieldIndexing> get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(IDictionary`2<string, FieldIndexing> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, FieldTermVector> get_TermVectors();
    [CompilerGeneratedAttribute]
public void set_TermVectors(IDictionary`2<string, FieldTermVector> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, SpatialOptions> get_SpatialIndexes();
    [CompilerGeneratedAttribute]
public void set_SpatialIndexes(IDictionary`2<string, SpatialOptions> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ForEntityNames();
    [CompilerGeneratedAttribute]
public void set_ForEntityNames(HashSet`1<string> value);
    public String[] get_Fields();
    public bool get_HasWhereClause();
    public void Init(IndexDefinition definition);
    protected IEnumerable`1<AbstractField> CreateField(string name, object value, bool stored, Nullable`1<bool> analyzed);
    [ObsoleteAttribute("Use RavenFS instead.")]
protected object LoadAttachmentForIndexing(object item);
    protected object LoadDocument(object item);
    protected object LoadDocument(object item);
    public void AddQueryParameterForMap(string field);
    public void AddQueryParameterForReduce(string field);
    public void AddField(string field);
    public virtual bool ContainsFieldOnMap(string field);
    public virtual bool ContainsField(string field);
    protected void AddMapDefinition(IndexingFunc mapDef);
    protected IEnumerable`1<object> Recurse(object item, Func`2<object, object> func);
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, SpatialField> get_SpatialFields();
    [CompilerGeneratedAttribute]
private void set_SpatialFields(ConcurrentDictionary`2<string, SpatialField> value);
    public IEnumerable`1<IFieldable> SpatialClustering(string fieldName, object lat, object lng, int minPrecision, int maxPrecision);
    [IteratorStateMachineAttribute("Raven.Database.Linq.AbstractViewGenerator/<SpatialClustering>d__77")]
public IEnumerable`1<IFieldable> SpatialClustering(string fieldName, Nullable`1<double> lat, Nullable`1<double> lng, int minPrecision, int maxPrecision);
    public IEnumerable`1<IFieldable> SpatialGenerate(object lat, object lng);
    public IEnumerable`1<IFieldable> SpatialGenerate(Nullable`1<double> lat, Nullable`1<double> lng);
    public IEnumerable`1<IFieldable> SpatialGenerate(string fieldName, object lat, object lng);
    public IEnumerable`1<IFieldable> SpatialGenerate(string fieldName, Nullable`1<double> lat, Nullable`1<double> lng);
    public IEnumerable`1<IFieldable> SpatialGenerate(string fieldName, string shapeWKT, SpatialSearchStrategy spatialSearchStrategy, int maxTreeLevel, double distanceErrorPct);
    [CLSCompliantAttribute("False")]
public SpatialField GetSpatialField(string fieldName, SpatialSearchStrategy spatialSearchStrategy, int maxTreeLevel);
    public bool IsSpatialField(string fieldName);
    private static Nullable`1<double> ConvertToDouble(object value);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.Ast.CaptureQueryParameterNamesVisitor : DepthFirstAstVisitor`2<object, object> {
    private HashSet`1<string> queryParameters;
    private Dictionary`2<string, string> aliasToName;
    public HashSet`1<string> QueryParameters { get; }
    public HashSet`1<string> get_QueryParameters();
    public virtual object VisitQueryFromClause(QueryFromClause queryFromClause, object data);
    private void ProcessQuery(Expression queryExpressionSelectClause);
    private string GenerateExpression(Expression expression);
    public virtual object VisitQuerySelectClause(QuerySelectClause querySelectClause, object data);
    public virtual object VisitQueryLetClause(QueryLetClause queryExpressionLetClause, object data);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.Ast.CaptureSelectNewFieldNamesVisitor : DepthFirstAstVisitor`2<object, object> {
    private bool _outerMostRequired;
    private HashSet`1<string> fieldNames;
    private Dictionary`2<string, Expression> selectExpressions;
    private bool queryProcessed;
    public HashSet`1<string> FieldNames { get; }
    public CaptureSelectNewFieldNamesVisitor(bool outerMostRequired, HashSet`1<string> fieldNames, Dictionary`2<string, Expression> selectExpressions);
    public HashSet`1<string> get_FieldNames();
    public virtual object VisitQuerySelectClause(QuerySelectClause querySelectClause, object data);
    public void Clear();
    public void ProcessQuery(AstNode queryExpressionSelectClause);
    public virtual object VisitInvocationExpression(InvocationExpression invocationExpression, object data);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.Ast.DynamicExtensionMethodsTranslator : DepthFirstAstVisitor`2<object, object> {
    private static String[] methodNames;
    private static DynamicExtensionMethodsTranslator();
    public virtual object VisitInvocationExpression(InvocationExpression invocationExpression, object data);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.Ast.ThrowOnInvalidMethodCalls : DepthFirstAstVisitor`2<object, object> {
    private string groupByIdentifier;
    public List`1<ForbiddenMethod> Members;
    public ThrowOnInvalidMethodCalls(string groupByIdentifier);
    public virtual object VisitQueryOrderClause(QueryOrderClause queryOrderClause, object data);
    public virtual object VisitQueryLetClause(QueryLetClause queryLetClause, object data);
    public virtual object VisitInvocationExpression(InvocationExpression invocationExpression, object data);
    protected virtual void AssertInvocationExpression(InvocationExpression invocation);
    private Expression SimplifyLetExpression(Expression expression);
    public virtual object VisitLambdaExpression(LambdaExpression lambdaExpression, object data);
    public virtual object VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression, object data);
    public virtual object VisitSimpleType(SimpleType simpleType, object data);
    public virtual object VisitQueryContinuationClause(QueryContinuationClause queryContinuationClause, object data);
    private void HandleGroupBy(SimpleType simpleType);
    protected virtual void AssertInvocationExpression(InvocationExpression invocation, string name);
    private static bool ContainsGroupBy(MemberReferenceExpression possibleGroupByExpression);
    private static string GetTarget(MemberReferenceExpression memberReferenceExpression);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.Ast.ThrowOnInvalidMethodCallsForTransformResults : DepthFirstAstVisitor`2<object, object> {
    public virtual object VisitInvocationExpression(InvocationExpression invocationExpression, object data);
}
internal class Raven.Database.Linq.Ast.ThrowOnInvalidMethodCallsInReduce : ThrowOnInvalidMethodCalls {
    public ThrowOnInvalidMethodCallsInReduce(string groupByIdentifier);
    protected virtual void AssertInvocationExpression(InvocationExpression invocation);
    protected virtual void AssertInvocationExpression(InvocationExpression invocation, string parameter);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.Ast.TransformDynamicInvocationExpressions : DepthFirstAstVisitor`2<object, object> {
    public virtual object VisitInvocationExpression(InvocationExpression invocationExpression, object data);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.Ast.TransformDynamicLambdaExpressions : DepthFirstAstVisitor`2<object, object> {
    public virtual object VisitLambdaExpression(LambdaExpression lambdaExpression, object data);
    private static AstNode ModifyLambdaForSelect(ParenthesizedExpression parenthesizedlambdaExpression, MemberReferenceExpression target);
    private static AstNode ModifyLambdaForSelectMany(LambdaExpression lambdaExpression, ParenthesizedExpression parenthesizedlambdaExpression, InvocationExpression invocationExpression);
    private static bool ShouldSkipCastingToDynamicEnumerable(AstNode body, String& type);
    private static AstNode ModifyLambdaForMinMax(LambdaExpression lambdaExpression, ParenthesizedExpression parenthesizedlambdaExpression);
    private static CastExpression GetAsCastExpression(INode expressionBody);
    private static AstNode ModifyLambdaForNumerics(LambdaExpression lambdaExpression, ParenthesizedExpression parenthesizedlambdaExpression);
}
internal class Raven.Database.Linq.Ast.TransformFromClauses : DepthFirstAstVisitor`2<object, object> {
    public virtual object VisitQueryFromClause(QueryFromClause fromClause, object data);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.Ast.TransformNullCoalescingOperatorTransformer : DepthFirstAstVisitor`2<object, object> {
    public virtual object VisitBinaryOperatorExpression(BinaryOperatorExpression binaryOperatorExpression, object data);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.Ast.TransformObsoleteMethods : DepthFirstAstVisitor`2<object, object> {
    public virtual object VisitInvocationExpression(InvocationExpression invocationExpression, object data);
}
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Database.Linq.AttachmentForIndexing : object {
    private string key;
    public string Key { get; }
    public AttachmentForIndexing(string key);
    public string get_Key();
}
public static class Raven.Database.Linq.CodeVerifier : object {
    [CompilerGeneratedAttribute]
private static bool <Active>k__BackingField;
    private static String[] forbiddenNamespaces;
    private static Type[] forbiddenTypes;
    public static bool Active { get; public set; }
    private static CodeVerifier();
    [CompilerGeneratedAttribute]
public static bool get_Active();
    [CompilerGeneratedAttribute]
public static void set_Active(bool value);
    public static void AssertNoSecurityCriticalCalls(Assembly asm);
    private static IEnumerable`1<object> GetAttributesForMethodAndType(MemberInfo memberInfo, Type type);
    private static string PrepareSecurityMessage(MemberInfo memberInfo);
    private static bool HasSecurityIssue(object arg);
}
internal class Raven.Database.Linq.DynamicCompilerBase : object {
    protected static string uniqueTextToken;
    protected OrderedPartCollection`1<AbstractDynamicCompilationExtension> extensions;
    protected string basePath;
    protected InMemoryRavenConfiguration configuration;
    protected string name;
    private string cSharpSafeName;
    [CompilerGeneratedAttribute]
private string <CompiledQueryText>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <GeneratedType>k__BackingField;
    public string CompiledQueryText { get; public set; }
    public Type GeneratedType { get; public set; }
    public string Name { get; }
    public string CSharpSafeName { get; public set; }
    public DynamicCompilerBase(InMemoryRavenConfiguration configuration, OrderedPartCollection`1<AbstractDynamicCompilationExtension> extensions, string name, string basePath);
    [CompilerGeneratedAttribute]
public string get_CompiledQueryText();
    [CompilerGeneratedAttribute]
public void set_CompiledQueryText(string value);
    [CompilerGeneratedAttribute]
public Type get_GeneratedType();
    [CompilerGeneratedAttribute]
public void set_GeneratedType(Type value);
    public string get_Name();
    public string get_CSharpSafeName();
    public void set_CSharpSafeName(string value);
}
internal class Raven.Database.Linq.DynamicTransformerCompiler : DynamicCompilerBase {
    private TransformerDefinition transformerDefinition;
    public DynamicTransformerCompiler(TransformerDefinition transformerDefinition, InMemoryRavenConfiguration configuration, OrderedPartCollection`1<AbstractDynamicCompilationExtension> extensions, string name, string basePath);
    public AbstractTransformer GenerateInstance();
    private void TransformToClass();
}
internal class Raven.Database.Linq.DynamicViewCompiler : DynamicCompilerBase {
    private IndexDefinition indexDefinition;
    private HashSet`1<string> _fieldNames;
    private Dictionary`2<string, Expression> _selectExpressions;
    private CaptureQueryParameterNamesVisitor captureQueryParameterNamesVisitorForMap;
    private CaptureQueryParameterNamesVisitor captureQueryParameterNamesVisitorForReduce;
    private TransformFromClauses transformFromClauses;
    private bool firstMap;
    [CompilerGeneratedAttribute]
private bool <RequiresSelectNewAnonymousType>k__BackingField;
    public bool RequiresSelectNewAnonymousType { get; public set; }
    public DynamicViewCompiler(string name, IndexDefinition indexDefinition, string basePath);
    public DynamicViewCompiler(string name, IndexDefinition indexDefinition, OrderedPartCollection`1<AbstractDynamicCompilationExtension> extensions, string basePath, InMemoryRavenConfiguration configuration);
    private void TransformQueryToClass();
    private void HandleMapFunctions(ConstructorDeclaration ctor);
    private void HandleMapFunction(ConstructorDeclaration ctor, string map);
    private void HandleReduceDefinition(ConstructorDeclaration ctor);
    private static QueryContinuationClause GetQueryContinuationClauseForGroupBy(QueryExpression queryExpression);
    private static LambdaExpression GetLambdaExpression(InvocationExpression invocation);
    private void ValidateMapReduceFields(List`1<string> mapFields);
    private void AddAdditionalInformation(ConstructorDeclaration ctor);
    private static void AddInformation(ConstructorDeclaration ctor, HashSet`1<string> fieldNames, string methodToCall);
    [CompilerGeneratedAttribute]
public bool get_RequiresSelectNewAnonymousType();
    [CompilerGeneratedAttribute]
public void set_RequiresSelectNewAnonymousType(bool value);
    private VariableInitializer TransformMapDefinitionFromLinqMethodSyntax(string query, String& entityName);
    private void AddEntityNameFilteringIfNeeded(VariableInitializer variableDeclaration, String& entityName);
    private VariableInitializer TransformMapDefinitionFromLinqQuerySyntax(string query, String& entityName);
    private static QueryFromClause GetFromClause(QueryExpression queryExpression);
    private static void HandleCollectionName(Expression expression, QueryFromClause fromClause, QueryExpression queryExpression, String& entityName);
    public AbstractViewGenerator GenerateInstance();
}
public class Raven.Database.Linq.GroupByKeyFunc : MulticastDelegate {
    public GroupByKeyFunc(object object, IntPtr method);
    public virtual object Invoke(object source);
    public virtual IAsyncResult BeginInvoke(object source, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class Raven.Database.Linq.IndexingFunc : MulticastDelegate {
    public IndexingFunc(object object, IntPtr method);
    public virtual IEnumerable`1<object> Invoke(IEnumerable`1<object> source);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<object> source, AsyncCallback callback, object object);
    public virtual IEnumerable`1<object> EndInvoke(IAsyncResult result);
}
public interface Raven.Database.Linq.ITranslatorDatabaseAccessor {
    public abstract virtual object Load(object maybeId);
    public abstract virtual object Include(object maybeId);
}
public static class Raven.Database.Linq.PrivateExtensions.DynamicEnumerable : object {
    public static IEnumerable`1<object> ToArray(IEnumerable`1<TSource> source);
    public static IEnumerable`1<object> Union(object source, object other);
    public static object First(IEnumerable`1<TSource> source);
    public static object First(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static object FirstOrDefault(IEnumerable`1<TSource> source);
    public static object FirstOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static object Last(IEnumerable`1<TSource> source);
    public static object Last(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static object LastOrDefault(IEnumerable`1<TSource> source);
    public static object LastOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static object Single(IEnumerable`1<TSource> source);
    public static object Single(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static object SingleOrDefault(IEnumerable`1<TSource> source);
    public static object SingleOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    public static object ElementAt(IEnumerable`1<TSource> source, int index);
    public static object ElementAtOrDefault(IEnumerable`1<TSource> source, int index);
    [IteratorStateMachineAttribute("Raven.Database.Linq.PrivateExtensions.DynamicEnumerable/<Yield>d__16`1")]
private static IEnumerable`1<T> Yield(IEnumerator`1<T> enumerator);
    public static object Min(IEnumerable`1<TSource> source);
    public static object Min(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    public static object Max(IEnumerable`1<TSource> source);
    public static object Max(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    public static IEnumerable`1<object> Concat(object source, object other);
    public static IEnumerable`1<object> Intersect(object source, object other);
}
public class Raven.Database.Linq.PrivateExtensions.DynamicExtensionMethods : object {
    public static object StripHtml(object o);
    public static object ParseInt(object o);
    public static object ParseInt(object o, int defaultValue);
    public static object ParseDouble(object o);
    public static object ParseDouble(object o, double defaultValue);
    public static object ParseDecimal(object o);
    public static object ParseDecimal(object o, decimal defaultValue);
    public static object ParseShort(object o);
    public static object ParseShort(object o, short defaultValue);
    public static object ParseLong(object o);
    public static object ParseLong(object o, long defaultValue);
    public static BoostedValue Boost(object o, object value);
    public static object IfEntityIs(object o, string entityName);
    public static object Reverse(object o);
    private static string Reverse(string str);
    private static IEnumerable`1<object> Reverse(IEnumerable`1<object> self);
}
[ExtensionAttribute]
public static class Raven.Database.Linq.PrivateExtensions.LinqOnDynamic : object {
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<object, object>> GroupBy(IEnumerable`1<object> source, Func`2<object, object> keySelector);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<object, object>> GroupBy(IEnumerable`1<object> source, Func`2<object, object> keySelector, Func`2<object, object> resultSelector);
    [IteratorStateMachineAttribute("Raven.Database.Linq.PrivateExtensions.LinqOnDynamic/<Select>d__2")]
[ExtensionAttribute]
private static IEnumerable`1<object> Select(object self);
    [ExtensionAttribute]
public static IEnumerable`1<object> DefaultIfEmpty(IEnumerable`1<object> self);
    [ExtensionAttribute]
public static IEnumerable`1<object> SelectMany(object source, Func`3<object, int, IEnumerable`1<object>> collectionSelector, Func`3<object, object, object> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<object> SelectMany(object source, Func`2<object, IEnumerable`1<object>> collectionSelector, Func`3<object, object, object> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<object> SelectMany(object source, Func`2<object, IEnumerable`1<object>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<object> SelectMany(IGrouping`2<object, object> source, Func`3<object, int, IEnumerable`1<object>> collectionSelector, Func`3<object, object, object> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<object> SelectMany(IGrouping`2<object, object> source, Func`2<object, IEnumerable`1<object>> collectionSelector, Func`3<object, object, object> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<object> SelectMany(IGrouping`2<object, object> source, Func`2<object, IEnumerable`1<object>> selector);
    [ExtensionAttribute]
public static object FirstOrDefault(IGrouping`2<object, object> source, Func`2<object, bool> predicate);
    [ExtensionAttribute]
public static object SingleOrDefault(IGrouping`2<object, object> source, Func`2<object, bool> predicate);
}
[ExtensionAttribute]
public static class Raven.Database.Linq.PrivateExtensions.MetadataExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<object> WhereEntityIs(IEnumerable`1<object> self, String[] metadata);
    [ExtensionAttribute]
public static object IfEntityIs(object self, string name);
}
[ExtensionAttribute]
public static class Raven.Database.Linq.QueryParsingUtils : object {
    private static ConcurrentDictionary`2<int, object> Locks;
    private static ILog _logger;
    private static ConcurrentDictionary`2<string, CacheEntry> cacheEntries;
    private static QueryParsingUtils();
    [CLSCompliantAttribute("False")]
public static string GenerateText(TypeDeclaration type, OrderedPartCollection`1<AbstractDynamicCompilationExtension> extensions, HashSet`1<string> namespaces);
    [CLSCompliantAttribute("False")]
public static string ToText(AstNode node);
    [CLSCompliantAttribute("False")]
public static VariableInitializer GetVariableDeclarationForLinqQuery(string query, bool requiresSelectNewAnonymousType);
    [CLSCompliantAttribute("False")]
public static VariableInitializer GetVariableDeclarationForLinqMethods(string query, bool requiresSelectNewAnonymousType);
    private static string ToQueryStatement(string query);
    public static INode GetAnonymousCreateExpression(INode expression);
    [CLSCompliantAttribute("False")]
[ExtensionAttribute]
public static LambdaExpression AsLambdaExpression(Expression expression);
    public static Type Compile(string source, string name, string queryText, OrderedPartCollection`1<AbstractDynamicCompilationExtension> extensions, string basePath, InMemoryRavenConfiguration configuration);
    private static bool ShouldIndexCacheBeRecompiled(string indexFilePath);
    private static void AddResultToCache(string source, Type result, bool shouldUpdateIfExists);
    private static bool TryGetDiskCacheResult(string source, string name, InMemoryRavenConfiguration configuration, string indexFilePath, Type& type);
    private static string GetIndexFilePath(string source, string indexCacheDir, Int32& numberHash);
    private static string GetIndexCacheDir(InMemoryRavenConfiguration configuration);
    private static Type DoActualCompilation(string source, string name, string queryText, OrderedPartCollection`1<AbstractDynamicCompilationExtension> extensions, string basePath, string indexFilePath, InMemoryRavenConfiguration configuration);
    private static Type TryGetIndexFromDisk(string indexFilePath, string typeName);
}
public class Raven.Database.Linq.RecursiveFunction : object {
    private object item;
    private Func`2<object, object> func;
    private List`1<object> resultsOrdered;
    private HashSet`1<object> results;
    private Queue`1<object> queue;
    public RecursiveFunction(object item, Func`2<object, object> func);
    public IEnumerable`1<object> Execute();
    private void AddItem(object current);
    private static object NullIfEmptyEnumerable(object item);
    [IteratorStateMachineAttribute("Raven.Database.Linq.RecursiveFunction/<Yield>d__9")]
private static IEnumerable`1<object> Yield(IEnumerator`1<object> enumerator);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.StringLiteralExpression : PrimitiveExpression {
    public StringLiteralExpression(string value);
}
public class Raven.Database.Linq.TranslatorFunc : MulticastDelegate {
    public TranslatorFunc(object object, IntPtr method);
    public virtual IEnumerable`1<object> Invoke(ITranslatorDatabaseAccessor database, IEnumerable`1<object> source);
    public virtual IAsyncResult BeginInvoke(ITranslatorDatabaseAccessor database, IEnumerable`1<object> source, AsyncCallback callback, object object);
    public virtual IEnumerable`1<object> EndInvoke(IAsyncResult result);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Linq.VerbatimStringLiteralExpression : PrimitiveExpression {
    public VerbatimStringLiteralExpression(string value);
}
public class Raven.Database.MemoryStatisticsPosix : object {
}
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractAnalyzerGenerator : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    protected internal DocumentDatabase Database { get; protected internal set; }
    public abstract virtual Analyzer GenerateAnalyzerForIndexing(string indexName, Document document, Analyzer previousAnalyzer);
    public abstract virtual Analyzer GenerateAnalyzerForQuerying(string indexName, string query, Analyzer previousAnalyzer);
    [CompilerGeneratedAttribute]
protected internal DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
protected internal void set_Database(DocumentDatabase value);
    public sealed virtual void Initialize(DocumentDatabase database);
    public virtual void Initialize();
    public virtual void SecondStageInit();
}
[InheritedExportAttribute]
[ObsoleteAttribute("Use RavenFS instead.")]
public abstract class Raven.Database.Plugins.AbstractAttachmentDeleteTrigger : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    public virtual VetoResult AllowDelete(string key);
    public virtual void OnDelete(string key);
    public virtual void AfterDelete(string key);
    public virtual void AfterCommit(string key);
    public sealed virtual void Initialize(DocumentDatabase database);
    public virtual void SecondStageInit();
    public virtual void Initialize();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    public virtual void Dispose();
}
[ObsoleteAttribute("Use RavenFS instead.")]
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractAttachmentPutTrigger : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    public virtual VetoResult AllowPut(string key, Stream data, RavenJObject metadata);
    public virtual void OnPut(string key, Stream data, RavenJObject metadata);
    public virtual void AfterPut(string key, Stream data, RavenJObject metadata, Etag etag);
    public virtual void AfterCommit(string key, Stream data, RavenJObject metadata, Etag etag);
    public sealed virtual void Initialize(DocumentDatabase database);
    public virtual void SecondStageInit();
    public virtual void Initialize();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
}
[InheritedExportAttribute]
[ObsoleteAttribute("Use RavenFS instead.")]
public abstract class Raven.Database.Plugins.AbstractAttachmentReadTrigger : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    public virtual ReadVetoResult AllowRead(string key, Stream data, RavenJObject metadata, ReadOperation operation);
    public virtual void OnRead(string key, Attachment attachment);
    public virtual void OnRead(AttachmentInformation information);
    public sealed virtual void Initialize(DocumentDatabase database);
    public virtual void SecondStageInit();
    public virtual void Initialize();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
}
public abstract class Raven.Database.Plugins.AbstractBackgroundTask : object {
    private static ILog log;
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    private int workCounter;
    public DocumentDatabase Database { get; public set; }
    private static AbstractBackgroundTask();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    public sealed virtual void Execute(DocumentDatabase database);
    protected virtual void Initialize();
    public void BackgroundTask();
    protected virtual TimeSpan TimeoutForNextWork();
    protected abstract virtual bool HandleWork();
}
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractDeleteTrigger : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    public virtual VetoResult AllowDelete(string key, TransactionInformation transactionInformation);
    public virtual void OnDelete(string key, TransactionInformation transactionInformation);
    public virtual void AfterDelete(string key, TransactionInformation transactionInformation, RavenJObject metaData);
    public virtual void AfterDelete(string key, TransactionInformation transactionInformation);
    public virtual void AfterCommit(string key);
    public sealed virtual void Initialize(DocumentDatabase database);
    public virtual void SecondStageInit();
    public virtual void Initialize();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    public virtual void Dispose();
}
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractDocumentCodec : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    public virtual void Initialize(DocumentDatabase database);
    public virtual void Initialize();
    public virtual void SecondStageInit();
    public abstract virtual Stream Encode(string key, RavenJObject data, RavenJObject metadata, Stream dataStream);
    public abstract virtual Stream Decode(string key, RavenJObject metadata, Stream dataStream);
}
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractDynamicCompilationExtension : object {
    public abstract virtual String[] GetNamespacesToImport();
    public abstract virtual String[] GetAssembliesToReference();
}
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractIndexCodec : object {
    public virtual void Initialize(DocumentDatabase database);
    public virtual void SecondStageInit();
    public abstract virtual Stream Encode(string key, Stream dataStream);
    public abstract virtual Stream Decode(string key, Stream dataStream);
}
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractIndexQueryTrigger : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    public sealed virtual void Initialize(DocumentDatabase database);
    public virtual void Initialize();
    public virtual void SecondStageInit();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    public abstract virtual Query ProcessQuery(string indexName, Query query, IndexQuery originalQuery);
}
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractIndexReaderWarmer : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    public sealed virtual void Initialize(DocumentDatabase database);
    public sealed virtual void SecondStageInit();
    public virtual void Initialize();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    public abstract virtual void WarmIndexReader(string indexName, IndexReader indexReader);
}
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractIndexUpdateTrigger : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    public sealed virtual void Initialize(DocumentDatabase database);
    public virtual void Initialize();
    public virtual void SecondStageInit();
    public abstract virtual AbstractIndexUpdateTriggerBatcher CreateBatcher(int indexId);
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
}
public abstract class Raven.Database.Plugins.AbstractIndexUpdateTriggerBatcher : object {
    public bool RequiresDocumentOnIndexEntryDeleted { get; }
    public virtual void OnIndexEntryDeleted(string entryKey, Document document);
    public virtual bool get_RequiresDocumentOnIndexEntryDeleted();
    public virtual void OnIndexEntryCreated(string entryKey, Document document);
    public virtual void Dispose();
    public virtual void AnErrorOccured(Exception exception);
}
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractPutTrigger : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <GeneratedMetadataNames>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    public IEnumerable`1<string> GeneratedMetadataNames { get; protected set; }
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
    public virtual void OnPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
    public virtual void AfterPut(string key, RavenJObject document, RavenJObject metadata, Etag etag, TransactionInformation transactionInformation);
    public virtual void AfterCommit(string key, RavenJObject document, RavenJObject metadata, Etag etag);
    public sealed virtual void Initialize(DocumentDatabase database);
    public virtual void Initialize();
    public virtual void SecondStageInit();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<string> get_GeneratedMetadataNames();
    [CompilerGeneratedAttribute]
protected virtual void set_GeneratedMetadataNames(IEnumerable`1<string> value);
}
[InheritedExportAttribute]
public abstract class Raven.Database.Plugins.AbstractReadTrigger : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    public DocumentDatabase Database { get; public set; }
    public virtual ReadVetoResult AllowRead(string key, RavenJObject metadata, ReadOperation operation, TransactionInformation transactionInformation);
    public virtual void OnRead(string key, RavenJObject document, RavenJObject metadata, ReadOperation operation, TransactionInformation transactionInformation);
    public sealed virtual void Initialize(DocumentDatabase database);
    public virtual void Initialize();
    public virtual void SecondStageInit();
    [CompilerGeneratedAttribute]
public DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
public void set_Database(DocumentDatabase value);
}
public class Raven.Database.Plugins.Builtins.ActiveBundlesProtection : AbstractPutTrigger {
    private static string RavenDatabasesPrefix;
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
}
public class Raven.Database.Plugins.Builtins.CheckFreeDiskSpace : object {
    private static ILog log;
    private RavenDBOptions options;
    private Timer timer;
    private static double FreeThreshold;
    private static CheckFreeDiskSpace();
    private static bool GetDiskFreeSpaceEx(string lpDirectoryName, UInt64& lpFreeBytesAvailable, UInt64& lpTotalNumberOfBytes, UInt64& lpTotalNumberOfFreeBytes);
    public sealed virtual void Execute(RavenDBOptions serverOptions);
    private void ExecuteCheck(object state);
    public sealed virtual void Dispose();
}
public class Raven.Database.Plugins.Builtins.CheckIncrementalBackupStatus : object {
    private TimeSpan frequency;
    private RavenDBOptions options;
    public sealed virtual void Execute(RavenDBOptions serverOptions);
    private void ExecuteCheck(object state);
    private static bool GetStorageFileInfo(string dbFolder, FileInfo& fi);
    private static bool IsIncrementalBackupIsAllowed(DatabasesLandlord databaseLandlord, DatabaseDocument dbDoc);
    public sealed virtual void Dispose();
}
public class Raven.Database.Plugins.Builtins.CheckPageFileOnHdd : object {
    private static ILog log;
    private static string PageFileName;
    private static UInt32 GENERIC_READ;
    private static UInt32 GENERIC_WRITE;
    private static UInt32 FILE_SHARE_READ;
    private static UInt32 FILE_SHARE_WRITE;
    private static UInt32 OPEN_EXISTING;
    private static UInt32 FILE_ATTRIBUTE_NORMAL;
    private static UInt32 FILE_DEVICE_MASS_STORAGE;
    private static UInt32 IOCTL_STORAGE_BASE;
    private static UInt32 FILE_DEVICE_CONTROLLER;
    private static UInt32 IOCTL_SCSI_BASE;
    private static UInt32 METHOD_BUFFERED;
    private static UInt32 FILE_ANY_ACCESS;
    private static UInt32 FILE_READ_ACCESS;
    private static UInt32 FILE_WRITE_ACCESS;
    private static UInt32 IOCTL_VOLUME_BASE;
    private static UInt32 StorageDeviceSeekPenaltyProperty;
    private static UInt32 PropertyStandardQuery;
    private static UInt32 ATA_FLAGS_DATA_IN;
    private static UInt32 FORMAT_MESSAGE_FROM_SYSTEM;
    private static CheckPageFileOnHdd();
    public sealed virtual void Execute(RavenDBOptions serverOptions);
    public sealed virtual void Dispose();
    private static DriveType GetDriveType(UInt32 physicalDriveNumber);
    private static SafeFileHandle CreateFileW(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    private static UInt32 CTL_CODE(UInt32 DeviceType, UInt32 Function, UInt32 Method, UInt32 Access);
    private static bool DeviceIoControl(SafeFileHandle hDevice, UInt32 dwIoControlCode, STORAGE_PROPERTY_QUERY& lpInBuffer, UInt32 nInBufferSize, DEVICE_SEEK_PENALTY_DESCRIPTOR& lpOutBuffer, UInt32 nOutBufferSize, UInt32& lpBytesReturned, IntPtr lpOverlapped);
    private static bool DeviceIoControl(SafeFileHandle hDevice, UInt32 dwIoControlCode, ATAIdentifyDeviceQuery& lpInBuffer, UInt32 nInBufferSize, ATAIdentifyDeviceQuery& lpOutBuffer, UInt32 nOutBufferSize, UInt32& lpBytesReturned, IntPtr lpOverlapped);
    private static UInt32 FormatMessage(UInt32 dwFlags, IntPtr lpSource, UInt32 dwMessageId, UInt32 dwLanguageId, StringBuilder lpBuffer, UInt32 nSize, IntPtr Arguments);
    private static DriveType HasNoSeekPenalty(string sDrive);
    private static DriveType HasNominalMediaRotationRate(string sDrive);
    private static string GetErrorMessage(int code);
    private static bool DeviceIoControl(SafeFileHandle hDevice, UInt32 dwIoControlCode, IntPtr lpInBuffer, UInt32 nInBufferSize, VOLUME_DISK_EXTENTS& lpOutBuffer, UInt32 nOutBufferSize, UInt32& lpBytesReturned, IntPtr lpOverlapped);
    private static Nullable`1<UInt32> GetPhysicalDriveNumber(string driveLetter);
}
public class Raven.Database.Plugins.Builtins.CreateFolderIcon : object {
    private static ILog log;
    private static CreateFolderIcon();
    public sealed virtual void Execute(DocumentDatabase database);
    private static void SetIconForFolder(string dataDirectory);
}
public class Raven.Database.Plugins.Builtins.CreateSilverlightIndexes : object {
    public sealed virtual void SilverlightWasRequested(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.FilterRavenInternalDocumentsReadTrigger : AbstractReadTrigger {
    public virtual ReadVetoResult AllowRead(string key, RavenJObject metadata, ReadOperation operation, TransactionInformation transactionInformation);
}
public class Raven.Database.Plugins.Builtins.HighestEtagsPerCollection : AbstractPutTrigger {
    public virtual void AfterCommit(string key, RavenJObject document, RavenJObject metadata, Etag etag);
}
public class Raven.Database.Plugins.Builtins.HotSpareReplicationBehavior : object {
    private DatabasesLandlord landlord;
    private RequestManager requestManger;
    private LicensingStatus licensingStatus;
    private ILog log;
    private HttpJsonRequestFactory requestFactory;
    private static Timer modreq(System.Runtime.CompilerServices.IsVolatile) licensingTimer;
    private static Timer modreq(System.Runtime.CompilerServices.IsVolatile) pollingLicenseStateTimer;
    private static string multipleActivationMessage;
    private static string multipleActivationTitle;
    private static string RanOutOfTestAllowanceMessage;
    private static string RanOutOfTestAllowanceTitle;
    private static string NoIdTitle;
    private DocumentConvention conventions;
    private static string noIdMessage;
    private static string failedToDeserialize;
    private static string FailureToDeserializeHotSpareDocument;
    private static string ExpiredHotSpareLicensingUssageMessage;
    private static string ExpiredHotSpareLicenseTitle;
    private static int MaxTestAllowance;
    private static TimeSpan TestActivationTime;
    private static TimeSpan ActivationTime;
    private static TimeSpan NonRecurringTimeSpan;
    private static string HotSpareList;
    private static string HotSpareKeyPrefix;
    private static HotSpareReplicationBehavior();
    public sealed virtual void Dispose();
    private void DeactivateTimer();
    public sealed virtual void Execute(RavenDBOptions serverOptions);
    private void OnCurrentLicenseChanged(LicensingStatus newLicense);
    internal void ClearHotSpareData();
    [AsyncStateMachineAttribute("Raven.Database.Plugins.Builtins.HotSpareReplicationBehavior/<ActivateHotSpareLicense>d__12")]
public Task ActivateHotSpareLicense();
    [AsyncStateMachineAttribute("Raven.Database.Plugins.Builtins.HotSpareReplicationBehavior/<ChangeHotSpareModeWithinCluster>d__13")]
private Task ChangeHotSpareModeWithinCluster(bool hotSpareMode);
    public bool IsActivationExpired(string id);
    private bool IsActivationExpired(HotSpareLicenseDocument doc);
    [AsyncStateMachineAttribute("Raven.Database.Plugins.Builtins.HotSpareReplicationBehavior/<EnableTestModeForHotSpareLicense>d__18")]
public Task EnableTestModeForHotSpareLicense();
    private bool IsTestAllowanceOut(HotSpareLicenseDocument doc);
    private bool ChangeHotSpareModeWithinClusterForCheckHotSpareLicenseStats(bool hotSpareMode);
    public void CheckHotSpareLicenseStats(object state);
    private void ReportLicensingUsage(string id, ActivationMode mode);
    private string GetLicenseId();
    public HotSpareLicenseDocument GetOrCreateLicenseDocument(string id, bool checkIfTesting);
    private HotSpareLicenseDocument GetLicenseDocument(string id);
    private void PutLicenseDocument(string id, HotSpareLicenseDocument doc);
    private void RaiseAlert(string message, string title, AlertLevel alertLevel);
    private static string GenerateHotSpareDocKey(string id);
    public bool IsHotSpareLicense();
    private bool CheckForHotSpareFootprintAndReport();
    private void ReportUsageOfExpiredHotSpareLicense(ActivationMode mode, string licenseId);
    private void ActivationTimeoutCallback(object state);
    private void TestTimeoutCallback(object state);
    private static HotSpareLicenseDocument CreateDefaultHotSpareLicenseDocument(string id);
    private LicensingStatus GetLicensingStatus();
    private static bool LicenseEqual(LicensingStatus license1, LicensingStatus license2);
    [CompilerGeneratedAttribute]
private Task <ActivationTimeoutCallback>b__41_0();
    [CompilerGeneratedAttribute]
private Task <TestTimeoutCallback>b__42_0();
}
public class Raven.Database.Plugins.Builtins.InvalidDocumentNames : AbstractPutTrigger {
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Bundles.Replication.ReplicationBundleEnabled : DatabaseScalarObjectBase`1<OctetString> {
    public ReplicationBundleEnabled(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Bundles.Replication.ReplicationDestinationEnabled : ReplicationDestinationScalarObjectBase`1<OctetString> {
    public ReplicationDestinationEnabled(string databaseName, DatabasesLandlord landlord, int databaseIndex, string destinationUrl, int destinationIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
    public virtual OctetString GetData(DocumentDatabase database, ReplicationTask task, ReplicationStrategy destination);
    [CompilerGeneratedAttribute]
private bool <GetData>b__1_0(ReplicationDestination destination);
}
public abstract class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Bundles.Replication.ReplicationDestinationScalarObjectBase`1 : DatabaseBundleScalarObjectBase`1<TData> {
    [CompilerGeneratedAttribute]
private string <DestinationUrl>k__BackingField;
    protected string DestinationUrl { get; private set; }
    protected ReplicationDestinationScalarObjectBase`1(string databaseName, DatabasesLandlord landlord, int databaseIndex, string destinationUrl, int destinationIndex, string dots);
    [CompilerGeneratedAttribute]
protected string get_DestinationUrl();
    [CompilerGeneratedAttribute]
private void set_DestinationUrl(string value);
    protected virtual TData GetData(DocumentDatabase database);
    public abstract virtual TData GetData(DocumentDatabase database, ReplicationTask task, ReplicationStrategy destination);
    [CompilerGeneratedAttribute]
private bool <GetData>b__5_0(ReplicationDestination destination);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Bundles.Replication.ReplicationDestinationTimeSinceLastReplication : ReplicationDestinationScalarObjectBase`1<TimeTicks> {
    public ReplicationDestinationTimeSinceLastReplication(string databaseName, DatabasesLandlord landlord, int databaseIndex, string destinationUrl, int destinationIndex);
    public virtual TimeTicks GetData(DocumentDatabase database, ReplicationTask task, ReplicationStrategy destination);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Bundles.Replication.ReplicationDestinationUrl : ReplicationDestinationScalarObjectBase`1<OctetString> {
    public ReplicationDestinationUrl(string databaseName, DatabasesLandlord landlord, int databaseIndex, string destinationUrl, int destinationIndex);
    public virtual OctetString GetData(DocumentDatabase database, ReplicationTask task, ReplicationStrategy destination);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.DatabaseLoadedCount : ScalarObjectBase`1<Integer32> {
    private DatabasesLandlord databasesLandlord;
    public DatabaseLoadedCount(DatabasesLandlord databasesLandlord);
    protected virtual Integer32 GetData();
    private static int GetCount(AbstractLandlord`1<DocumentDatabase> landlord);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.DatabaseTotalCount : ScalarObjectBase`1<Integer32> {
    private DocumentDatabase systemDatabase;
    public DatabaseTotalCount(DocumentDatabase systemDatabase);
    protected virtual Integer32 GetData();
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexAttempts : DatabaseIndexScalarObjectBase`1<Integer32> {
    public DatabaseIndexAttempts(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexErrors : DatabaseIndexScalarObjectBase`1<Integer32> {
    public DatabaseIndexErrors(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexExists : DatabaseIndexScalarObjectBase`1<OctetString> {
    public ISnmpData Data { get; }
    public DatabaseIndexExists(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    public virtual ISnmpData get_Data();
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexId : DatabaseIndexScalarObjectBase`1<Integer32> {
    public DatabaseIndexId(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexName : DatabaseIndexScalarObjectBase`1<OctetString> {
    private OctetString name;
    public DatabaseIndexName(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexPriority : DatabaseIndexScalarObjectBase`1<OctetString> {
    public DatabaseIndexPriority(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexReduceAttempts : DatabaseIndexScalarObjectBase`1<Integer32> {
    public DatabaseIndexReduceAttempts(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexReduceErrors : DatabaseIndexScalarObjectBase`1<Integer32> {
    public DatabaseIndexReduceErrors(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexReduceSuccesses : DatabaseIndexScalarObjectBase`1<Integer32> {
    public DatabaseIndexReduceSuccesses(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexSuccesses : DatabaseIndexScalarObjectBase`1<Integer32> {
    public DatabaseIndexSuccesses(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Indexes.DatabaseIndexTimeSinceLastQuery : DatabaseIndexScalarObjectBase`1<TimeTicks> {
    public DatabaseIndexTimeSinceLastQuery(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex);
    protected virtual TimeTicks GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Requests.DatabaseDocsWritePerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseDocsWritePerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Requests.DatabaseIndexedPerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseIndexedPerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Requests.DatabaseReducedPerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseReducedPerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Requests.DatabaseRequestDurationLastMinuteAvg : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseRequestDurationLastMinuteAvg(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Requests.DatabaseRequestDurationLastMinuteMax : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseRequestDurationLastMinuteMax(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Requests.DatabaseRequestDurationLastMinuteMin : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseRequestDurationLastMinuteMin(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Requests.DatabaseRequestsPerSecond : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseRequestsPerSecond(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static int GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseActiveBundles : DatabaseScalarObjectBase`1<OctetString> {
    public DatabaseActiveBundles(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseApproximateTaskCount : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseApproximateTaskCount(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static long GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseCountOfAttachments : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCountOfAttachments(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static long GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseCountOfDocuments : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCountOfDocuments(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
    private static long GetCount(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseCountOfIndexes : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCountOfIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseCountOfTransformers : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCountOfTransformers(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseCurrentNumberOfItemsToIndexInSingleBatch : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCurrentNumberOfItemsToIndexInSingleBatch(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseCurrentNumberOfItemsToReduceInSingleBatch : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseCurrentNumberOfItemsToReduceInSingleBatch(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseErrors : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseErrors(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseId : DatabaseScalarObjectBase`1<OctetString> {
    private OctetString id;
    public DatabaseId(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseLoaded : DatabaseScalarObjectBase`1<OctetString> {
    private string databaseName;
    public ISnmpData Data { get; }
    public DatabaseLoaded(string databaseName, DatabasesLandlord landlord, int index);
    public virtual ISnmpData get_Data();
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseName : DatabaseScalarObjectBase`1<OctetString> {
    private OctetString name;
    public DatabaseName(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual OctetString GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseNumberOfAbandonedIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfAbandonedIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseNumberOfAutoIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfAutoIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseNumberOfDisabledIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfDisabledIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseNumberOfErrorIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfErrorIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseNumberOfIdleIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfIdleIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseNumberOfIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseNumberOfStaticIndexes : DatabaseScalarObjectBase`1<Integer32> {
    public DatabaseNumberOfStaticIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Integer32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Statistics.DatabaseStaleIndexes : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseStaleIndexes(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Storage.DatabaseIndexStorageDiskRemainingSpace : DatabaseScalarObjectBase`1<Gauge32> {
    private static Gauge32 Empty;
    public DatabaseIndexStorageDiskRemainingSpace(string databaseName, DatabasesLandlord landlord, int index);
    private static DatabaseIndexStorageDiskRemainingSpace();
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Storage.DatabaseIndexStorageSize : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseIndexStorageSize(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Storage.DatabaseTotalStorageSize : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseTotalStorageSize(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Storage.DatabaseTransactionalStorageAllocatedSize : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseTransactionalStorageAllocatedSize(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Storage.DatabaseTransactionalStorageDiskRemainingSpace : DatabaseScalarObjectBase`1<Gauge32> {
    private static Gauge32 Empty;
    public DatabaseTransactionalStorageDiskRemainingSpace(string databaseName, DatabasesLandlord landlord, int index);
    private static DatabaseTransactionalStorageDiskRemainingSpace();
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Database.Storage.DatabaseTransactionalStorageUsedSize : DatabaseScalarObjectBase`1<Gauge32> {
    public DatabaseTransactionalStorageUsedSize(string databaseName, DatabasesLandlord landlord, int index);
    protected virtual Gauge32 GetData(DocumentDatabase database);
}
public abstract class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.DatabaseBundleScalarObjectBase`1 : DatabaseScalarObjectBase`1<TData> {
    [CompilerGeneratedAttribute]
private string <BundleName>k__BackingField;
    public string BundleName { get; private set; }
    public ISnmpData Data { get; }
    protected DatabaseBundleScalarObjectBase`1(string databaseName, string bundleName, DatabasesLandlord landlord, int databaseIndex, int bundleIndex, string dots);
    [CompilerGeneratedAttribute]
public string get_BundleName();
    [CompilerGeneratedAttribute]
private void set_BundleName(string value);
    public virtual ISnmpData get_Data();
    [CompilerGeneratedAttribute]
private bool <get_Data>b__6_0(string x);
}
public abstract class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.DatabaseIndexScalarObjectBase`1 : DatabaseScalarObjectBase`1<TData> {
    protected string IndexName;
    [CompilerGeneratedAttribute]
private IndexDefinition <IndexDefinition>k__BackingField;
    protected IndexDefinition IndexDefinition { get; private set; }
    public ISnmpData Data { get; }
    protected DatabaseIndexScalarObjectBase`1(string databaseName, string indexName, DatabasesLandlord landlord, int databaseIndex, int indexIndex, string dots);
    [CompilerGeneratedAttribute]
protected IndexDefinition get_IndexDefinition();
    [CompilerGeneratedAttribute]
private void set_IndexDefinition(IndexDefinition value);
    public virtual ISnmpData get_Data();
    protected IndexStats GetIndexStats(DocumentDatabase database);
}
public abstract class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.DatabaseScalarObjectBase`1 : ScalarObjectBase`1<TData> {
    protected string DatabaseName;
    protected DatabasesLandlord Landlord;
    protected DatabaseScalarObjectBase`1(string databaseName, DatabasesLandlord landlord, string dots, int index);
    protected abstract virtual TData GetData(DocumentDatabase database);
    protected virtual TData GetData();
}
public abstract class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.ScalarObjectBase`1 : ScalarObject {
    private static string RootOid;
    private static TimeTicks DefaultTimeTicks;
    private static Gauge32 DefaultGauge32;
    private static Integer32 DefaultInteger32;
    private static OctetString DefaultOctetString;
    public ISnmpData Data { get; public set; }
    protected ScalarObjectBase`1(string dots);
    protected ScalarObjectBase`1(string dots, int index);
    private static ScalarObjectBase`1();
    protected abstract virtual TData GetData();
    public virtual ISnmpData get_Data();
    public virtual void set_Data(ISnmpData value);
    protected ISnmpData DefaultValue();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerBuildVersion : ScalarObjectBase`1<OctetString> {
    private OctetString buildVersion;
    protected virtual OctetString GetData();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerConcurrentRequests : ScalarObjectBase`1<Gauge32> {
    private RequestManager requestManager;
    public ServerConcurrentRequests(RequestManager requestManager);
    protected virtual Gauge32 GetData();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerCpu : ScalarObjectBase`1<Gauge32> {
    protected virtual Gauge32 GetData();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerIndexingErrors : ScalarObjectBase`1<Gauge32> {
    private DatabasesLandlord landlord;
    public ServerIndexingErrors(DatabasesLandlord landlord);
    protected virtual Gauge32 GetData();
}
internal class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerLastRequestTime : ScalarObjectBase`1<TimeTicks> {
    private RequestManager requestManager;
    public ServerLastRequestTime(RequestManager requestManager);
    protected virtual TimeTicks GetData();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerName : ScalarObjectBase`1<OctetString> {
    private OctetString name;
    public ServerName(InMemoryRavenConfiguration configuration);
    protected virtual OctetString GetData();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerPid : ScalarObjectBase`1<Integer32> {
    private Integer32 pid;
    protected virtual Integer32 GetData();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerProductVersion : ScalarObjectBase`1<OctetString> {
    private OctetString productVersion;
    protected virtual OctetString GetData();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerTotalMemory : ScalarObjectBase`1<Gauge32> {
    protected virtual Gauge32 GetData();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerTotalRequests : ScalarObjectBase`1<Integer32> {
    private RequestManager requestManager;
    public ServerTotalRequests(RequestManager requestManager);
    protected virtual Integer32 GetData();
}
internal class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerUpTime : ScalarObjectBase`1<TimeTicks> {
    private RequestManager requestManager;
    public ServerUpTime(RequestManager requestManager);
    protected virtual TimeTicks GetData();
}
internal class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerUpTimeGlobal : ScalarObjectBase`1<TimeTicks> {
    private RequestManager requestManager;
    public ServerUpTimeGlobal(RequestManager requestManager);
    protected virtual TimeTicks GetData();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.Objects.Server.ServerUrl : ScalarObjectBase`1<OctetString> {
    private OctetString url;
    public ServerUrl(InMemoryRavenConfiguration configuration);
    protected virtual OctetString GetData();
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.SnmpDatabase : object {
    private ConcurrentDictionary`2<string, int> loadedIndexes;
    private ConcurrentDictionary`2<string, int> loadedReplicationDestinations;
    private DatabasesLandlord databaseLandlord;
    private ObjectStore store;
    private string databaseName;
    private int databaseIndex;
    private object locker;
    private bool attached;
    public SnmpDatabase(DatabasesLandlord databaseLandlord, ObjectStore store, string databaseName, int databaseIndex);
    private void Initialize();
    private void Attach(bool force);
    private void AddReplicationDestinationsFromDatabase();
    private int AddReplicationDestination(string replicationDestinationUrl);
    private void AddIndexesFromDatabase(DocumentDatabase database);
    private int AddIndex(string indexName);
    private void AddIndexesFromMappingDocument();
    private void AddReplicationDestinationsFromMappingDocument();
    private JsonDocument GetMappingDocument(MappingDocumentType type);
    private long GetOrAddIndex(string name, MappingDocumentType mappingDocumentType, DocumentDatabase systemDatabase);
}
public class Raven.Database.Plugins.Builtins.Monitoring.Snmp.SnmpTask : object {
    private ConcurrentDictionary`2<string, SnmpDatabase> loadedDatabases;
    private object locker;
    private ILog log;
    private DocumentDatabase systemDatabase;
    private DatabasesLandlord databaseLandlord;
    private SnmpEngine snmpEngine;
    private ObjectStore objectStore;
    public sealed virtual void Dispose();
    public sealed virtual void Execute(RavenDBOptions serverOptions);
    private static bool IsLicenseValid();
    private void AddDatabaseIfNecessary(string databaseName);
    private SnmpEngine CreateSnmpEngine(RavenDBOptions serverOptions, ObjectStore store);
    private ObjectStore CreateStore(RavenDBOptions serverOptions);
    private void AddDatabases();
    private void AddDatabase(ObjectStore store, string databaseName);
    private long GetOrAddDatabaseIndex(string databaseName);
    [CompilerGeneratedAttribute]
private void <CreateSnmpEngine>b__11_0(object sender, ExceptionRaisedEventArgs e);
    [CompilerGeneratedAttribute]
private void <AddDatabases>b__13_0(string databaseName);
}
public class Raven.Database.Plugins.Builtins.PurgeOutdatedTombstones : object {
    public sealed virtual void Execute(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.ReadOnlyDeleteTrigger : AbstractDeleteTrigger {
    public virtual VetoResult AllowDelete(string key, TransactionInformation transactionInformation);
}
public class Raven.Database.Plugins.Builtins.ReadOnlyPutTrigger : AbstractPutTrigger {
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
}
public class Raven.Database.Plugins.Builtins.RecoverPendingTransactions : object {
    private ILog logger;
    public sealed virtual void Execute(DocumentDatabase database);
}
public class Raven.Database.Plugins.Builtins.RecoveryEnlistment : object {
    private DocumentDatabase database;
    private string transactionId;
    public RecoveryEnlistment(DocumentDatabase database, string transactionId);
    public sealed virtual void Prepare(PreparingEnlistment preparingEnlistment);
    public sealed virtual void Commit(Enlistment enlistment);
    public sealed virtual void Rollback(Enlistment enlistment);
    public sealed virtual void InDoubt(Enlistment enlistment);
}
public class Raven.Database.Plugins.Builtins.SpatialDynamicCompilationExtension : AbstractDynamicCompilationExtension {
    public virtual String[] GetNamespacesToImport();
    public virtual String[] GetAssembliesToReference();
}
public class Raven.Database.Plugins.Catalogs.BuiltinFilteringCatalog : FilteredCatalog {
    public BuiltinFilteringCatalog(ComposablePartCatalog catalogToFilter);
    protected virtual bool IsMatch(ComposablePartDefinition composablePartDefinition);
}
public class Raven.Database.Plugins.Catalogs.BundlesFilteredCatalog : FilteredCatalog {
    [CompilerGeneratedAttribute]
private String[] <Bundles>k__BackingField;
    public String[] Bundles { get; public set; }
    public BundlesFilteredCatalog(ComposablePartCatalog catalogToFilter, String[] bundles);
    [CompilerGeneratedAttribute]
public String[] get_Bundles();
    [CompilerGeneratedAttribute]
public void set_Bundles(String[] value);
    protected virtual bool IsMatch(ExportDefinition exportDefinition);
}
public abstract class Raven.Database.Plugins.Catalogs.FilteredCatalog : ComposablePartCatalog {
    private static object locker;
    private ComposablePartCatalog catalogToFilter;
    public ComposablePartCatalog CatalogToFilter { get; }
    public IQueryable`1<ComposablePartDefinition> Parts { get; }
    protected FilteredCatalog(ComposablePartCatalog catalogToFilter);
    private static FilteredCatalog();
    public ComposablePartCatalog get_CatalogToFilter();
    protected virtual void Dispose(bool disposing);
    public virtual IQueryable`1<ComposablePartDefinition> get_Parts();
    public virtual IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition);
    protected virtual bool IsMatch(ComposablePartDefinition composablePartDefinition);
    protected virtual bool IsMatch(ExportDefinition exportDefinition);
    [CompilerGeneratedAttribute]
private bool <GetExports>b__8_0(Tuple`2<ComposablePartDefinition, ExportDefinition> x);
}
[InheritedExportAttribute]
public interface Raven.Database.Plugins.IAlterConfiguration {
    public abstract virtual void AlterConfiguration(InMemoryRavenConfiguration configuration);
}
internal interface Raven.Database.Plugins.IRequiresDocumentDatabaseInitialization {
    public abstract virtual void Initialize(DocumentDatabase database);
    public abstract virtual void SecondStageInit();
}
[InheritedExportAttribute]
public interface Raven.Database.Plugins.IServerStartupTask {
    public abstract virtual void Execute(RavenDBOptions serverOptions);
}
[InheritedExportAttribute]
public interface Raven.Database.Plugins.ISilverlightRequestedAware {
    public abstract virtual void SilverlightWasRequested(DocumentDatabase database);
}
[InheritedExportAttribute]
public interface Raven.Database.Plugins.IStartupTask {
    public abstract virtual void Execute(DocumentDatabase database);
}
public class Raven.Database.Plugins.PluginsStatus : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Plugins>k__BackingField;
    public List`1<string> Plugins { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Plugins();
    [CompilerGeneratedAttribute]
public void set_Plugins(List`1<string> value);
}
public enum Raven.Database.Plugins.ReadOperation : Enum {
    public int value__;
    public static ReadOperation Load;
    public static ReadOperation Query;
    public static ReadOperation Index;
}
public class Raven.Database.Plugins.ReadVetoResult : object {
    [CompilerGeneratedAttribute]
private ReadAllow <Veto>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public static ReadVetoResult Allowed { get; }
    public static ReadVetoResult Ignore { get; }
    public ReadAllow Veto { get; private set; }
    public string Reason { get; private set; }
    private ReadVetoResult(ReadAllow allowed, string reason);
    public static ReadVetoResult get_Allowed();
    public static ReadVetoResult get_Ignore();
    public static ReadVetoResult Deny(string reason);
    [CompilerGeneratedAttribute]
public ReadAllow get_Veto();
    [CompilerGeneratedAttribute]
private void set_Veto(ReadAllow value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
private void set_Reason(string value);
}
public class Raven.Database.Plugins.VetoResult : object {
    [CompilerGeneratedAttribute]
private bool <IsAllowed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public static VetoResult Allowed { get; }
    public bool IsAllowed { get; private set; }
    public string Reason { get; private set; }
    private VetoResult(bool allowed, string reason);
    public static VetoResult get_Allowed();
    public static VetoResult Deny(string reason);
    [CompilerGeneratedAttribute]
public bool get_IsAllowed();
    [CompilerGeneratedAttribute]
private void set_IsAllowed(bool value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
private void set_Reason(string value);
}
public class Raven.Database.Prefetching.ConcurrentJsonDocumentSortedList : object {
    private ReaderWriterLockSlim slim;
    private SortedList`2<Etag, JsonDocument> innerList;
    private Dictionary`2<Etag, JsonDocument> relevantDocuments;
    private int loadedSize;
    public int Count { get; }
    public int RelevantDocumentsCount { get; }
    public int LoadedSize { get; }
    public SortedList`2<Etag, JsonDocument> Clone();
    public int get_Count();
    public int get_RelevantDocumentsCount();
    public IDisposable EnterWriteLock();
    public void Add(JsonDocument value);
    public bool TryPeek(JsonDocument& result);
    public bool TryPeekLastDocument(JsonDocument& result);
    public bool TryDequeue(JsonDocument& result);
    public Etag NextDocumentETag();
    public int get_LoadedSize();
    public void RemoveAfter(Etag etag);
    public void Clear();
    public bool DocumentExists(Etag etag);
}
public class Raven.Database.Prefetching.DiskFetchPerformanceStats : object {
    public int NumberOfDocuments;
    public int RelevantNumberOfDocuments;
    public long TotalSize;
    public long LoadingTimeInMillseconds;
    public long LargestDocSize;
    public string LargestDocKey;
}
public class Raven.Database.Prefetching.FutureBatchesSummary : object {
    [CompilerGeneratedAttribute]
private List`1<object> <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Total>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Canceled>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Faulted>k__BackingField;
    public List`1<object> Summary { get; public set; }
    public int Total { get; public set; }
    public int Canceled { get; public set; }
    public int Faulted { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<object> get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(List`1<object> value);
    [CompilerGeneratedAttribute]
public int get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(int value);
    [CompilerGeneratedAttribute]
public int get_Canceled();
    [CompilerGeneratedAttribute]
public void set_Canceled(int value);
    [CompilerGeneratedAttribute]
public int get_Faulted();
    [CompilerGeneratedAttribute]
public void set_Faulted(int value);
}
public class Raven.Database.Prefetching.IoDebugSummary : object {
    [CompilerGeneratedAttribute]
private List`1<object> <LoadTimes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CurrentlySplitting>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentSplitCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfIOWaits>k__BackingField;
    public List`1<object> LoadTimes { get; public set; }
    public bool CurrentlySplitting { get; public set; }
    public int CurrentSplitCount { get; public set; }
    public int NumberOfIOWaits { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<object> get_LoadTimes();
    [CompilerGeneratedAttribute]
public void set_LoadTimes(List`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_CurrentlySplitting();
    [CompilerGeneratedAttribute]
public void set_CurrentlySplitting(bool value);
    [CompilerGeneratedAttribute]
public int get_CurrentSplitCount();
    [CompilerGeneratedAttribute]
public void set_CurrentSplitCount(int value);
    [CompilerGeneratedAttribute]
public int get_NumberOfIOWaits();
    [CompilerGeneratedAttribute]
public void set_NumberOfIOWaits(int value);
}
public class Raven.Database.Prefetching.Prefetcher : object {
    private WorkContext workContext;
    private List`1<PrefetchingBehavior> prefetchingBehaviors;
    public Prefetcher(WorkContext workContext);
    public PrefetchingBehavior CreatePrefetchingBehavior(PrefetchingUser user, BaseBatchSizeAutoTuner autoTuner, string prefetchingUserDescription, HashSet`1<string> entityNames, bool isDefault);
    public void RemovePrefetchingBehavior(PrefetchingBehavior prefetchingBehavior);
    public void AfterDelete(string key, Etag deletedEtag);
    public Int32[] GetInMemoryIndexingQueueSizes(PrefetchingUser user);
    public void AfterStorageCommitBeforeWorkNotifications(PrefetchingUser user, JsonDocument[] documents);
    private int GetPrefetchintBehavioursCount();
    private PrefetchingSummary GetPrefetchingBehaviourSummary();
    public void Dispose();
    public sealed virtual LowMemoryHandlerStatistics HandleLowMemory();
    public sealed virtual LowMemoryHandlerStatistics GetStats();
}
public class Raven.Database.Prefetching.PrefetchingBehavior : object {
    private static int MaxDeletedDocumentsToTrack;
    private static ILog log;
    private BaseBatchSizeAutoTuner autoTuner;
    private WorkContext context;
    private ConcurrentDictionary`2<string, ImmutableAppendOnlyList`1<Etag>> documentsToRemove;
    private ConcurrentDictionary`2<Etag, FutureIndexBatch> futureIndexBatches;
    private ConcurrentJsonDocumentSortedList prefetchingQueue;
    private ConcurrentQueue`1<DiskFetchPerformanceStats> loadTimes;
    private int numberOfTimesWaitedHadToWaitForIO;
    private int splitPrefetchingCount;
    private int currentlyTrackedDeletedItems;
    private DocAddedAfterCommit lowestInMemoryDocumentAddedAfterCommit;
    private int currentIndexingAge;
    private long futureBatchChecks;
    public Action`1<int> FutureBatchCompleted;
    private MeterMetric ingestMeter;
    private MeterMetric returnedDocsMeter;
    private int numberOfTimesIngestRateWasTooHigh;
    private string userDescription;
    private Etag recentEtag;
    [CompilerGeneratedAttribute]
private PrefetchingUser <PrefetchingUser>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ForEntityNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    private Func`1<int> getPrefetchintBehavioursCount;
    private Func`1<PrefetchingSummary> getPrefetcherSummary;
    private static string MeterContext;
    private string ingestMeterName;
    private string returnedDocsMeterName;
    [CompilerGeneratedAttribute]
private List`1<IndexToWorkOn> <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastIndexedEtag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastTimeUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableCollectingDocumentsAfterCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldHandleUnusedDocumentsAddedAfterCommit>k__BackingField;
    public PrefetchingUser PrefetchingUser { get; private set; }
    public HashSet`1<string> ForEntityNames { get; private set; }
    public bool IsDefault { get; }
    public List`1<IndexToWorkOn> Indexes { get; public set; }
    public string LastIndexedEtag { get; public set; }
    public DateTime LastTimeUsed { get; private set; }
    public string AdditionalInfo { get; public set; }
    public bool DisableCollectingDocumentsAfterCommit { get; public set; }
    public bool ShouldHandleUnusedDocumentsAddedAfterCommit { get; public set; }
    public int InMemoryIndexingQueueSize { get; }
    public int InMemoryFutureIndexBatchesSize { get; }
    public PrefetchingBehavior(PrefetchingUser prefetchingUser, WorkContext context, BaseBatchSizeAutoTuner autoTuner, string prefetchingUserDescription, HashSet`1<string> forEntityNames, bool isDefault, Func`1<int> getPrefetchintBehavioursCount, Func`1<PrefetchingSummary> getPrefetcherSummary);
    private static PrefetchingBehavior();
    [CompilerGeneratedAttribute]
public PrefetchingUser get_PrefetchingUser();
    [CompilerGeneratedAttribute]
private void set_PrefetchingUser(PrefetchingUser value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ForEntityNames();
    [CompilerGeneratedAttribute]
private void set_ForEntityNames(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public List`1<IndexToWorkOn> get_Indexes();
    [CompilerGeneratedAttribute]
public void set_Indexes(List`1<IndexToWorkOn> value);
    [CompilerGeneratedAttribute]
public string get_LastIndexedEtag();
    [CompilerGeneratedAttribute]
public void set_LastIndexedEtag(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastTimeUsed();
    [CompilerGeneratedAttribute]
private void set_LastTimeUsed(DateTime value);
    [CompilerGeneratedAttribute]
public string get_AdditionalInfo();
    [CompilerGeneratedAttribute]
public void set_AdditionalInfo(string value);
    [CompilerGeneratedAttribute]
public bool get_DisableCollectingDocumentsAfterCommit();
    [CompilerGeneratedAttribute]
public void set_DisableCollectingDocumentsAfterCommit(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldHandleUnusedDocumentsAddedAfterCommit();
    [CompilerGeneratedAttribute]
public void set_ShouldHandleUnusedDocumentsAddedAfterCommit(bool value);
    public int get_InMemoryIndexingQueueSize();
    public int get_InMemoryFutureIndexBatchesSize();
    public sealed virtual void Dispose();
    public IDisposable DocumentBatchFrom(Etag etag, List`1& documents);
    public IDisposable DocumentBatchFrom(Etag etag, int take, List`1& documents);
    public List`1<JsonDocument> GetDocumentsBatchFrom(Etag etag, Nullable`1<int> take);
    private void HandleCollectingDocumentsAfterCommit(Etag requestedEtag);
    private void RemoveOutdatedFutureIndexBatches(Etag etag);
    private static void DisposeCancellationToken(CancellationTokenSource cts);
    private void HandleCleanupOfUnusedDocumentsInQueue();
    private bool CanBeConsideredAsDuplicate(JsonDocument document);
    public bool CanUsePrefetcherToLoadFromUsingExistingData(Etag fromEtag, HashSet`1<string> entityNames);
    public bool CanUseDefaultPrefetcher(Etag fromEtag, HashSet`1<string> entityNames);
    public bool IsEmpty();
    private List`1<JsonDocument> GetDocsFromBatchWithPossibleDuplicates(Etag etag, Nullable`1<int> take);
    private int GetNumberOfItemsToProcessInSingleBatch();
    private bool LoadDocumentsFromDisk(Etag etag, Etag untilEtag, List`1<JsonDocument> items, Nullable`1<int> take);
    private bool TryGetDocumentsFromQueue(Etag nextDocEtag, List`1<JsonDocument> items, Nullable`1<int> take);
    public IEnumerable`1<JsonDocument> DebugGetDocumentsInPrefetchingQueue();
    public FutureBatchesSummary DebugGetDocumentsInFutureBatches();
    public IoDebugSummary DebugIOSummary();
    private Nullable`1<TaskStatus> CanLoadDocumentsFromFutureBatches(Etag nextDocEtag);
    private bool TryLoadDocumentsFromFutureBatches(Etag nextDocEtag, bool allowWaiting);
    private List`1<JsonDocument> GetJsonDocsFromDisk(CancellationToken cancellationToken, Etag etag, Etag untilEtag, Reference`1<int> relevantDocsCount, Reference`1<bool> earlyExit);
    public PrefetchingSummary GetSummary();
    private void MaybeAddFutureBatch(JsonDocument lastDocumentFromResult);
    private void MaybeAddFutureBatch(List`1<JsonDocument> past);
    private bool CanPrefetchMoreDocs(bool isFutureBatch);
    private int GetActualFutureIndexBatchesCount(int numberOfSplitTasks, Int32& active);
    private void TryScheduleFutureIndexBatch(List`1<JsonDocument> past, int numberOfSplitTasks);
    private void SplitFutureBatches(int numberOfSplitTasks, Etag nextEtag);
    private FutureIndexBatch GetCompletedFutureBatchWithMaxStartingEtag();
    private void CalculateAverageLoadTimes(Double& loadTimePerDocMs, Int64& largestDocSize, String& largestDocKey);
    private bool AddFutureBatch(Etag nextEtag, Etag untilEtag, FutureBatchType batchType);
    private static void LogEarlyExit(Etag nextEtag, Etag untilEtag, bool isEarlyExitBatch, List`1<JsonDocument> jsonDocuments, long timeElapsed);
    private Etag GetNextDocEtag(Etag etag);
    private Etag GetNextDocumentEtagFromDisk(Etag etag);
    private static Etag GetHighestEtag(List`1<JsonDocument> past);
    public static JsonDocument GetHighestJsonDocumentByEtag(List`1<JsonDocument> past);
    private static Task ObserveDiscardedTask(FutureIndexBatch source);
    public void BatchProcessingComplete();
    public void AfterStorageCommitBeforeWorkNotifications(JsonDocument[] docs);
    public void CleanupDocuments(Etag lastIndexedEtag);
    public bool FilterDocuments(JsonDocument document);
    public void AfterDelete(string key, Etag deletedEtag);
    public bool ShouldSkipDeleteFromIndex(JsonDocument item);
    public IDisposable UpdateCurrentlyUsedBatches(List`1<JsonDocument> docBatch);
    public void UpdateAutoThrottler(List`1<JsonDocument> jsonDocs, TimeSpan indexingDuration, bool skipIncreasingBatchSize);
    public void OutOfMemoryExceptionHappened();
    public sealed virtual LowMemoryHandlerStatistics HandleLowMemory();
    public sealed virtual LowMemoryHandlerStatistics GetStats();
    public void ClearQueueAndFutureBatches();
    public void SetEntityNames(HashSet`1<string> entityNames);
    [CompilerGeneratedAttribute]
private void <.ctor>b__21_1(IStorageActionsAccessor accessor);
}
public class Raven.Database.Prefetching.PrefetchingSummary : object {
    [CompilerGeneratedAttribute]
private int <PrefetchingQueueLoadedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PrefetchingQueueDocsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FutureIndexBatchesLoadedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FutureIndexBatchesDocsCount>k__BackingField;
    public int PrefetchingQueueLoadedSize { get; public set; }
    public int PrefetchingQueueDocsCount { get; public set; }
    public long FutureIndexBatchesLoadedSize { get; public set; }
    public int FutureIndexBatchesDocsCount { get; public set; }
    [CompilerGeneratedAttribute]
public int get_PrefetchingQueueLoadedSize();
    [CompilerGeneratedAttribute]
public void set_PrefetchingQueueLoadedSize(int value);
    [CompilerGeneratedAttribute]
public int get_PrefetchingQueueDocsCount();
    [CompilerGeneratedAttribute]
public void set_PrefetchingQueueDocsCount(int value);
    [CompilerGeneratedAttribute]
public long get_FutureIndexBatchesLoadedSize();
    [CompilerGeneratedAttribute]
public void set_FutureIndexBatchesLoadedSize(long value);
    [CompilerGeneratedAttribute]
public int get_FutureIndexBatchesDocsCount();
    [CompilerGeneratedAttribute]
public void set_FutureIndexBatchesDocsCount(int value);
}
[ExtensionAttribute]
public static class Raven.Database.Queries.DynamicQueryExtensions : object {
    [ExtensionAttribute]
public static QueryResultWithIncludes ExecuteDynamicQuery(DocumentDatabase self, string entityName, IndexQuery indexQuery, CancellationToken token);
    [ExtensionAttribute]
public static string FindDynamicIndexName(DocumentDatabase self, string entityName, IndexQuery query);
    [ExtensionAttribute]
public static List`1<Explanation> ExplainDynamicIndexSelection(DocumentDatabase self, string entityName, IndexQuery query);
}
public enum Raven.Database.Queries.DynamicQueryMatchType : Enum {
    public int value__;
    public static DynamicQueryMatchType Complete;
    public static DynamicQueryMatchType Partial;
    public static DynamicQueryMatchType Failure;
}
public class Raven.Database.Queries.DynamicQueryOptimizer : object {
    private DocumentDatabase database;
    public DynamicQueryOptimizer(DocumentDatabase database);
    public DynamicQueryOptimizerResult SelectAppropriateIndex(string entityName, IndexQuery indexQuery, List`1<Explanation> explanations);
}
public class Raven.Database.Queries.DynamicQueryOptimizerResult : object {
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicQueryMatchType <MatchType>k__BackingField;
    public string IndexName { get; public set; }
    public DynamicQueryMatchType MatchType { get; public set; }
    public DynamicQueryOptimizerResult(string match, DynamicQueryMatchType matchType);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public DynamicQueryMatchType get_MatchType();
    [CompilerGeneratedAttribute]
public void set_MatchType(DynamicQueryMatchType value);
}
public class Raven.Database.Queries.DynamicQueryRunner : object {
    private DocumentDatabase documentDatabase;
    private object createIndexLock;
    public DynamicQueryRunner(DocumentDatabase database);
    public QueryResultWithIncludes ExecuteDynamicQuery(string entityName, IndexQuery query, CancellationToken token);
    private static void UpdateFieldNamesForSortedFields(IndexQuery query, DynamicQueryMapping map);
    private QueryResultWithIncludes ExecuteActualQuery(IndexQuery query, DynamicQueryMapping map, Tuple`2<string, bool> touchTemporaryIndexResult, string realQuery, CancellationToken token);
    private static IndexQuery CreateIndexQuery(IndexQuery query, DynamicQueryMapping map, string realQuery);
    private Tuple`2<string, bool> GetAppropriateIndexToQuery(string entityName, IndexQuery query, DynamicQueryMapping map);
    private Tuple`2<string, bool> CreateAutoIndex(string permanentIndexName, Func`1<IndexDefinition> createDefinition);
}
public class Raven.Database.Queries.FacetedQueryRunner : object {
    private DocumentDatabase database;
    public FacetedQueryRunner(DocumentDatabase database);
    public FacetResults GetFacets(string index, IndexQuery indexQuery, List`1<Facet> facets, int start, Nullable`1<int> pageSize);
    private static ParsedRange ParseRange(string field, string range);
    private static string UnescapeValueIfNecessary(string value);
    private static string NumericStringToSortableNumeric(string value);
    private static bool IsInclusive(char ch);
}
[ExtensionAttribute]
public static class Raven.Database.Queries.FacetedQueryRunnerExtensions : object {
    [ExtensionAttribute]
public static FacetResults ExecuteGetTermsQuery(DocumentDatabase self, string index, IndexQuery query, string facetSetupDoc);
    [ExtensionAttribute]
public static FacetResults ExecuteGetTermsQuery(DocumentDatabase self, string index, IndexQuery query, string facetSetupDoc, int start, Nullable`1<int> pageSize);
    [ExtensionAttribute]
public static FacetResults ExecuteGetTermsQuery(DocumentDatabase self, string index, IndexQuery query, List`1<Facet> facets);
    [ExtensionAttribute]
public static FacetResults ExecuteGetTermsQuery(DocumentDatabase self, string index, IndexQuery query, List`1<Facet> facets, int start, Nullable`1<int> pageSize);
}
public class Raven.Database.Queries.MatchNoDocsQuery : Query {
    public static MatchNoDocsQuery INSTANCE;
    private static int HASH_CODE;
    private static MatchNoDocsQuery();
    public virtual Weight CreateWeight(Searcher searcher);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual object Clone();
}
[ExtensionAttribute]
public static class Raven.Database.Queries.MoreLikeThisQueryExtensions : object {
    [ExtensionAttribute]
public static MoreLikeThisQueryResult ExecuteMoreLikeThisQuery(DocumentDatabase self, MoreLikeThisQuery query, TransactionInformation transactionInformation, int pageSize, OrderedPartCollection`1<AbstractIndexQueryTrigger> databaseIndexQueryTriggers);
}
public class Raven.Database.Queries.MoreLikeThisQueryRunner : object {
    private DocumentDatabase database;
    private HashSet`1<string> idsToLoad;
    private DocumentRetriever documentRetriever;
    public MoreLikeThisQueryRunner(DocumentDatabase database);
    public MoreLikeThisQueryResult ExecuteMoreLikeThisQuery(MoreLikeThisQuery query, TransactionInformation transactionInformation, int pageSize, OrderedPartCollection`1<AbstractIndexQueryTrigger> databaseIndexQueryTriggers);
    private IEnumerable`1<RavenJObject> ProcessResults(MoreLikeThisQuery query, IEnumerable`1<JsonDocument> documents, CancellationToken token);
    private JsonDocument[] GetJsonDocuments(MoreLikeThisQuery parameters, IndexSearcher searcher, Index index, string indexName, IEnumerable`1<ScoreDoc> hits, int baseDocId);
    private JsonDocument[] GetJsonDocuments(IndexSearcher searcher, Index index, string indexName, ScoreDoc[] scoreDocs);
    private static void AssignParameters(MoreLikeThis mlt, MoreLikeThisQuery parameters);
    private static String[] GetFieldNames(IndexReader indexReader);
}
[ExtensionAttribute]
public static class Raven.Database.Queries.SuggestionQueryExtensions : object {
    [ExtensionAttribute]
public static SuggestionQueryResult ExecuteSuggestionQuery(DocumentDatabase self, string index, SuggestionQuery suggestionQuery);
}
public class Raven.Database.Queries.SuggestionQueryIndexExtension : object {
    private Index _indexInstance;
    private WorkContext workContext;
    private string field;
    private Directory directory;
    private SpellChecker spellChecker;
    private string _operationText;
    public string Name { get; }
    [CLSCompliantAttribute("False")]
public SuggestionQueryIndexExtension(Index indexInstance, WorkContext workContext, string key, bool isRunInMemory, string field);
    public void Init(IndexReader reader);
    public SuggestionQueryResult Query(SuggestionQuery suggestionQuery, IndexReader indexReader);
    private SuggestionQueryResult QueryOverMultipleWords(SuggestionQuery suggestionQuery, IndexReader indexReader, string queryText);
    public sealed virtual void OnDocumentsIndexed(IEnumerable`1<Document> documents, Analyzer searchAnalyzer);
    public sealed virtual string get_Name();
    public sealed virtual void Dispose();
}
public class Raven.Database.Queries.SuggestionQueryRunner : object {
    private DocumentDatabase database;
    public SuggestionQueryRunner(DocumentDatabase database);
    public SuggestionQueryResult ExecuteSuggestionQuery(string indexName, SuggestionQuery suggestionQuery);
    [CLSCompliantAttribute("False")]
public static StringDistance GetStringDistance(StringDistanceTypes distanceAlg);
}
public class Raven.Database.Queries.TermsQueryRunner : object {
    private DocumentDatabase database;
    public TermsQueryRunner(DocumentDatabase database);
    public ISet`1<string> GetTerms(string index, string field, string fromValue, int pageSize);
}
[ExtensionAttribute]
public static class Raven.Database.Queries.TermsQueryRunnerExtensions : object {
    [ExtensionAttribute]
public static ISet`1<string> ExecuteGetTermsQuery(DocumentDatabase self, string index, string field, string fromValue, int pageSize);
}
public enum Raven.Database.Raft.CanJoinResult : Enum {
    public int value__;
    public static CanJoinResult CanJoin;
    public static CanJoinResult AlreadyJoined;
    public static CanJoinResult InAnotherCluster;
    public static CanJoinResult IsNonEmpty;
    public static CanJoinResult CanJoinAsNonVoter;
}
public class Raven.Database.Raft.ClusterKeeperTask : object {
    private DocumentDatabase systemDatabase;
    private ClusterManager clusterManager;
    public sealed virtual void Execute(RavenDBOptions serverOptions);
    private static bool IsValidLicense();
    public sealed virtual void Dispose();
    private void HandleTopologyChanges(TopologyChangeCommand command);
    private void HandleClusterConfigurationChanges(List`1<string> removedNodeUrls);
    private void HandleClusterReplicationChanges(List`1<string> removedNodes, bool enableReplication);
    [CompilerGeneratedAttribute]
private void <Execute>b__2_0(DocumentDatabase db, DocumentChangeNotification notification, RavenJObject metadata);
}
public class Raven.Database.Raft.ClusterManagementHttpClient : object {
    private static int WaitForLeaderTimeoutInSeconds;
    private RaftEngine raftEngine;
    private ConcurrentDictionary`2<string, ConcurrentQueue`1<HttpClient>> _httpClientsCache;
    private ConcurrentDictionary`2<string, SecuredAuthenticator> _securedAuthenticatorCache;
    private static int MaxSecondsToWaitForLeaderWhileChangingVoteMode;
    public ClusterManagementHttpClient(RaftEngine raftEngine);
    private static ClusterManagementHttpClient();
    private HttpRaftRequest CreateRequest(NodeConnectionInfo node, string url, HttpMethod httpMethod);
    internal Task`1<Action`1<HttpClient>> HandleUnauthorizedResponseAsync(HttpResponseMessage unauthorizedResponse, NodeConnectionInfo nodeConnectionInfo);
    private void AssertUnauthorizedCredentialSupportWindowsAuth(HttpResponseMessage response, NodeConnectionInfo nodeConnectionInfo);
    internal Task`1<Action`1<HttpClient>> HandleForbiddenResponseAsync(HttpResponseMessage forbiddenResponse, NodeConnectionInfo nodeConnection);
    private void AssertForbiddenCredentialSupportWindowsAuth(HttpResponseMessage response, NodeConnectionInfo nodeConnection);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendJoinServerAsync>d__10")]
public Task SendJoinServerAsync(NodeConnectionInfo nodeConnectionInfo);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendJoinServerInternalAsync>d__11")]
public Task`1<CanJoinResult> SendJoinServerInternalAsync(NodeConnectionInfo leaderNode, NodeConnectionInfo newNode);
    public Task SendClusterConfigurationAsync(ClusterConfiguration configuration);
    public Task SendDatabaseUpdateAsync(string databaseName, DatabaseDocument document);
    public Task SendDatabaseDeleteAsync(string databaseName, bool hardDelete);
    public Task SendReplicationStateAsync(ReplicationState replicationState);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendReplicationStateAsync>d__16")]
private Task SendReplicationStateAsync(NodeConnectionInfo node, ReplicationState replicationState);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<CheckConnectivity>d__17")]
public Task`1<Tuple`2<ConnectivityStatus, string>> CheckConnectivity(NodeConnectionInfo node);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendDatabaseDeleteInternalAsync>d__18")]
private Task SendDatabaseDeleteInternalAsync(NodeConnectionInfo node, string databaseName, bool hardDelete);
    private Task SendClusterConfigurationInternalAsync(NodeConnectionInfo leaderNode, ClusterConfiguration configuration);
    private Task SendDatabaseUpdateInternalAsync(NodeConnectionInfo leaderNode, string databaseName, DatabaseDocument document);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<PutAsync>d__21")]
private Task PutAsync(NodeConnectionInfo node, string action, object content);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendCanJoinAsync>d__22")]
public Task`1<CanJoinResult> SendCanJoinAsync(NodeConnectionInfo nodeConnectionInfo);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendNodeUpdateAsync>d__23")]
public Task SendNodeUpdateAsync(NodeConnectionInfo node);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendNodeUpdateInternalAsync>d__24")]
public Task SendNodeUpdateInternalAsync(NodeConnectionInfo leaderNode, NodeConnectionInfo nodeToUpdate);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendLeaveAsync>d__25")]
public Task SendLeaveAsync(NodeConnectionInfo node);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendLeaveClusterInternalAsync>d__26")]
public Task SendLeaveClusterInternalAsync(NodeConnectionInfo leaderNode, NodeConnectionInfo leavingNode);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<CreateErrorResponseExceptionAsync>d__27")]
private static Task`1<ErrorResponseException> CreateErrorResponseExceptionAsync(HttpResponseMessage response);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<GetDatabaseId>d__28")]
public Task`1<Guid> GetDatabaseId(NodeConnectionInfo nodeConnectionInfo);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendInitializeNewClusterForAsync>d__29")]
public Task SendInitializeNewClusterForAsync(NodeConnectionInfo node);
    public sealed virtual void Dispose();
    internal SecuredAuthenticator GetAuthenticator(NodeConnectionInfo info);
    internal ReturnToQueue GetConnection(NodeConnectionInfo nodeConnection, HttpClient& result);
    [AsyncStateMachineAttribute("Raven.Database.Raft.ClusterManagementHttpClient/<SendVotingModeChangeRequestAsync>d__35")]
public Task`1<bool> SendVotingModeChangeRequestAsync(NodeConnectionInfo nodeConnectionInfo, bool isVoting);
    [CompilerGeneratedAttribute]
private Tuple`2<IDisposable, HttpClient> <CreateRequest>b__5_0(NodeConnectionInfo info);
}
public class Raven.Database.Raft.ClusterManager : object {
    private static ILog Log;
    [CompilerGeneratedAttribute]
private RaftEngine <Engine>k__BackingField;
    [CompilerGeneratedAttribute]
private ClusterManagementHttpClient <Client>k__BackingField;
    private Timer timer;
    private TimeSpan maxReplicationLatency;
    private DateTime clusterManagerStartTime;
    [CompilerGeneratedAttribute]
private DatabasesLandlord <DatabasesLandlord>k__BackingField;
    private static int newLeaderTimerCallbackLocker;
    private bool disableReplicationStateChecks;
    private int disableReplicationStateChecksLocker;
    public RaftEngine Engine { get; private set; }
    public ClusterManagementHttpClient Client { get; private set; }
    public bool HasNonEmptyTopology { get; }
    private DatabasesLandlord DatabasesLandlord { get; private set; }
    public ClusterManager(RaftEngine engine, DatabasesLandlord databasesLandlord);
    private static ClusterManager();
    [CompilerGeneratedAttribute]
public RaftEngine get_Engine();
    [CompilerGeneratedAttribute]
private void set_Engine(RaftEngine value);
    [CompilerGeneratedAttribute]
public ClusterManagementHttpClient get_Client();
    [CompilerGeneratedAttribute]
private void set_Client(ClusterManagementHttpClient value);
    public bool get_HasNonEmptyTopology();
    private void OnProposingCandidacy(object sender, ProposingCandidacyResult e);
    [CompilerGeneratedAttribute]
private DatabasesLandlord get_DatabasesLandlord();
    [CompilerGeneratedAttribute]
private void set_DatabasesLandlord(DatabasesLandlord value);
    private void OnRaftEngineStateChanged(RaftEngineState state);
    private void SaflyDisposeOfTimer();
    private void NewLeaderTimerCallback(object state);
    public ClusterTopology GetTopology();
    public void InitializeTopology(NodeConnectionInfo nodeConnection, bool isPartOfExistingCluster, bool forceCandidateState);
    public void InitializeEmptyTopologyWithId(Guid id);
    public void CleanupAllClusteringData(DocumentDatabase systemDatabase);
    public sealed virtual void Dispose();
    public void HandleClusterConfigurationChanged(ClusterConfiguration configuration);
    [CompilerGeneratedAttribute]
private void <Dispose>b__28_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__28_1();
    [CompilerGeneratedAttribute]
private void <Dispose>b__28_2();
}
public static class Raven.Database.Raft.ClusterManagerFactory : object {
    public static NodeConnectionInfo CreateSelfConnection(DocumentDatabase database);
    public static ClusterManager Create(DocumentDatabase systemDatabase, DatabasesLandlord databasesLandlord, bool nullifyLastAppliedIndex);
}
public class Raven.Database.Raft.ClusterTopology : object {
    [CompilerGeneratedAttribute]
private string <CurrentLeader>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentTerm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <State>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CommitIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeConnectionInfo[] <AllVotingNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeConnectionInfo[] <PromotableNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeConnectionInfo[] <NonVotingNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TopologyId>k__BackingField;
    public string CurrentLeader { get; public set; }
    public long CurrentTerm { get; public set; }
    public string State { get; public set; }
    public long CommitIndex { get; public set; }
    public NodeConnectionInfo[] AllVotingNodes { get; public set; }
    public NodeConnectionInfo[] PromotableNodes { get; public set; }
    public NodeConnectionInfo[] NonVotingNodes { get; public set; }
    public Guid TopologyId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CurrentLeader();
    [CompilerGeneratedAttribute]
public void set_CurrentLeader(string value);
    [CompilerGeneratedAttribute]
public long get_CurrentTerm();
    [CompilerGeneratedAttribute]
public void set_CurrentTerm(long value);
    [CompilerGeneratedAttribute]
public string get_State();
    [CompilerGeneratedAttribute]
public void set_State(string value);
    [CompilerGeneratedAttribute]
public long get_CommitIndex();
    [CompilerGeneratedAttribute]
public void set_CommitIndex(long value);
    [CompilerGeneratedAttribute]
public NodeConnectionInfo[] get_AllVotingNodes();
    [CompilerGeneratedAttribute]
public void set_AllVotingNodes(NodeConnectionInfo[] value);
    [CompilerGeneratedAttribute]
public NodeConnectionInfo[] get_PromotableNodes();
    [CompilerGeneratedAttribute]
public void set_PromotableNodes(NodeConnectionInfo[] value);
    [CompilerGeneratedAttribute]
public NodeConnectionInfo[] get_NonVotingNodes();
    [CompilerGeneratedAttribute]
public void set_NonVotingNodes(NodeConnectionInfo[] value);
    [CompilerGeneratedAttribute]
public Guid get_TopologyId();
    [CompilerGeneratedAttribute]
public void set_TopologyId(Guid value);
}
public class Raven.Database.Raft.Commands.ClusterConfigurationUpdateCommand : Command {
    [CompilerGeneratedAttribute]
private ClusterConfiguration <Configuration>k__BackingField;
    public ClusterConfiguration Configuration { get; public set; }
    [CompilerGeneratedAttribute]
public ClusterConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(ClusterConfiguration value);
    public static ClusterConfigurationUpdateCommand Create(ClusterConfiguration configuration);
}
public class Raven.Database.Raft.Commands.DatabaseDeletedCommand : Command {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HardDelete>k__BackingField;
    public string Name { get; public set; }
    public bool HardDelete { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_HardDelete();
    [CompilerGeneratedAttribute]
public void set_HardDelete(bool value);
    public static DatabaseDeletedCommand Create(string databaseName, bool hardDelete);
}
public class Raven.Database.Raft.Commands.DatabaseUpdateCommand : Command {
    [CompilerGeneratedAttribute]
private DatabaseDocument <Document>k__BackingField;
    public DatabaseDocument Document { get; public set; }
    [CompilerGeneratedAttribute]
public DatabaseDocument get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(DatabaseDocument value);
    public static DatabaseUpdateCommand Create(string databaseName, DatabaseDocument document);
}
public class Raven.Database.Raft.Commands.ReplicationStateCommand : Command {
    [CompilerGeneratedAttribute]
private ReplicationState <DatabaseToLastModified>k__BackingField;
    public ReplicationState DatabaseToLastModified { get; public set; }
    [CompilerGeneratedAttribute]
public ReplicationState get_DatabaseToLastModified();
    [CompilerGeneratedAttribute]
public void set_DatabaseToLastModified(ReplicationState value);
    public static ReplicationStateCommand Create(ReplicationState databaseToLastModified);
}
public enum Raven.Database.Raft.ConnectivityStatus : Enum {
    public int value__;
    public static ConnectivityStatus Online;
    public static ConnectivityStatus Offline;
    public static ConnectivityStatus WrongCredentials;
}
public class Raven.Database.Raft.Controllers.ClusterAdminController : BaseAdminDatabaseApiController {
    [RavenRouteAttribute("admin/cluster/commands/configuration")]
[HttpPutAttribute]
[AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterAdminController/<ClusterConfiguration>d__0")]
public Task`1<HttpResponseMessage> ClusterConfiguration();
    private bool ConfigurationsAreEqualExceptReplicationCheck(ClusterConfiguration configuration, ClusterConfiguration localConfiguration);
    [RavenRouteAttribute("admin/cluster/commands/database/{*id}")]
[HttpPutAttribute]
[AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterAdminController/<CreateDatabase>d__2")]
public Task`1<HttpResponseMessage> CreateDatabase(string id);
    [RavenRouteAttribute("admin/cluster/commands/database/{*id}")]
[HttpDeleteAttribute]
[AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterAdminController/<DeleteDatabase>d__3")]
public Task`1<HttpResponseMessage> DeleteDatabase(string id);
    [AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterAdminController/<Create>d__4")]
[HttpPostAttribute]
[RavenRouteAttribute("admin/cluster/create")]
public Task`1<HttpResponseMessage> Create();
    [HttpPatchAttribute]
[RavenRouteAttribute("admin/cluster/initialize-new-cluster")]
public HttpResponseMessage InitializeNewCluster();
    private ClusterManager SetClusterManagerToNullAndGetOldValue();
    [HttpPatchAttribute]
[RavenRouteAttribute("admin/cluster/remove-clustering")]
public HttpResponseMessage RemoveClustering();
    [HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterAdminController/<JoinToCluster>d__8")]
[RavenRouteAttribute("admin/cluster/join")]
public Task`1<HttpResponseMessage> JoinToCluster();
    [RavenRouteAttribute("admin/cluster/update")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterAdminController/<Update>d__9")]
public Task`1<HttpResponseMessage> Update();
    [RavenRouteAttribute("admin/cluster/canJoin")]
[HttpGetAttribute]
public Task`1<HttpResponseMessage> CanJoin(Guid topologyId);
    [AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterAdminController/<Leave>d__11")]
[HttpGetAttribute]
[RavenRouteAttribute("admin/cluster/leave")]
public Task`1<HttpResponseMessage> Leave(Guid name);
    [AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterAdminController/<ChangeVotingMode>d__12")]
[HttpPostAttribute]
[RavenRouteAttribute("admin/cluster/changeVotingMode")]
public Task`1<HttpResponseMessage> ChangeVotingMode(bool isVoting);
}
public class Raven.Database.Raft.Controllers.ClusterController : BaseDatabaseApiController {
    private HttpTransport Transport { get; }
    private HttpTransportBus Bus { get; }
    private HttpTransport get_Transport();
    private HttpTransportBus get_Bus();
    [RavenRouteAttribute("cluster/status")]
[HttpGetAttribute]
public HttpResponseMessage Status();
    private Task`1<Tuple`2<ConnectivityStatus, string>> FetchNodeStatus(NodeConnectionInfo nci);
    [RavenRouteAttribute("cluster/topology")]
[HttpGetAttribute]
public HttpResponseMessage Topology();
    [HttpPostAttribute]
[RavenRouteAttribute("raft/installSnapshot")]
[AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterController/<InstallSnapshot>d__7")]
public Task`1<HttpResponseMessage> InstallSnapshot(InstallSnapshotRequest request, string topology);
    [AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterController/<AppendEntries>d__8")]
[RavenRouteAttribute("raft/appendEntries")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> AppendEntries();
    private bool VerifyContentHash(Stream stream, ulong receivedHash, int bodyContentLength, HttpResponseMessage& responseMessage);
    private bool TryParseAppendEntriesRequestFromUri(AppendEntriesRequest& request, Int32& entriesCount, HttpResponseMessage& responseMessage);
    private bool TryGetParamFromUri(string name, TParam& value);
    [HttpGetAttribute]
[RavenRouteAttribute("raft/requestVote")]
public Task`1<HttpResponseMessage> RequestVote(RequestVoteRequest request);
    [HttpGetAttribute]
[RavenRouteAttribute("raft/timeoutNow")]
public Task`1<HttpResponseMessage> TimeoutNow(TimeoutNowRequest request);
    [HttpGetAttribute]
[RavenRouteAttribute("raft/disconnectFromCluster")]
public Task`1<HttpResponseMessage> DisconnectFromCluster(DisconnectedFromCluster request);
    [RavenRouteAttribute("raft/canInstallSnapshot")]
[HttpGetAttribute]
public Task`1<HttpResponseMessage> CanInstallSnapshot(CanInstallSnapshotRequest request);
    [AsyncStateMachineAttribute("Raven.Database.Raft.Controllers.ClusterController/<ReplicationState>d__16")]
[RavenRouteAttribute("cluster/replicationState")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> ReplicationState();
    [CompilerGeneratedAttribute]
private <>f__AnonymousType18`2<string, Task`1<Tuple`2<ConnectivityStatus, string>>> <Status>b__4_0(NodeConnectionInfo x);
}
public class Raven.Database.Raft.Dto.ClusterConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <DisableReplicationStateChecks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableReplication>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <DatabaseSettings>k__BackingField;
    public bool DisableReplicationStateChecks { get; public set; }
    public bool EnableReplication { get; public set; }
    public Dictionary`2<string, string> DatabaseSettings { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DisableReplicationStateChecks();
    [CompilerGeneratedAttribute]
public void set_DisableReplicationStateChecks(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableReplication();
    [CompilerGeneratedAttribute]
public void set_EnableReplication(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_DatabaseSettings();
    [CompilerGeneratedAttribute]
public void set_DatabaseSettings(Dictionary`2<string, string> value);
}
public class Raven.Database.Raft.Dto.LastModificationTimeAndTransactionalId : object {
    [CompilerGeneratedAttribute]
private DateTime <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseId>k__BackingField;
    public DateTime LastModified { get; public set; }
    public string DatabaseId { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(DateTime value);
    [CompilerGeneratedAttribute]
public string get_DatabaseId();
    [CompilerGeneratedAttribute]
public void set_DatabaseId(string value);
}
public class Raven.Database.Raft.Dto.ReplicationState : object {
    public Dictionary`2<string, LastModificationTimeAndTransactionalId> DatabasesToLastModification;
    public ReplicationState(Dictionary`2<string, LastModificationTimeAndTransactionalId> databasesToLastModification);
}
public class Raven.Database.Raft.Storage.ClusterStateMachine : object {
    private ILog log;
    private PutSerialLock locker;
    private DocumentDatabase database;
    private Dictionary`2<Type, CommandHandler> handlers;
    private long lastAppliedIndex;
    [CompilerGeneratedAttribute]
private RaftEngine <RaftEngine>k__BackingField;
    internal RaftEngine RaftEngine { get; internal set; }
    public long LastAppliedIndex { get; private set; }
    public bool SupportSnapshots { get; }
    public ClusterStateMachine(DocumentDatabase systemDatabase, DatabasesLandlord databasesLandlord);
    [CompilerGeneratedAttribute]
internal RaftEngine get_RaftEngine();
    [CompilerGeneratedAttribute]
internal void set_RaftEngine(RaftEngine value);
    private long ReadLastAppliedIndex();
    public sealed virtual void Dispose();
    public sealed virtual long get_LastAppliedIndex();
    private void set_LastAppliedIndex(long value);
    public sealed virtual void Apply(LogEntry entry, Command cmd);
    public sealed virtual bool get_SupportSnapshots();
    public sealed virtual void CreateSnapshot(long index, long term, ManualResetEventSlim allowFurtherModifications);
    private static void WriteDatabaseDocumentsToSnapshot(IStorageActionsAccessor accessor, JsonTextWriter jsonTextWriter);
    private static void WriteClusterDocumentToSnapshot(JsonTextWriter jsonTextWriter, IStorageActionsAccessor accessor, string docName);
    public sealed virtual ISnapshotWriter GetSnapshotWriter();
    public sealed virtual void ApplySnapshot(long term, long index, Stream stream);
    public sealed virtual void Danger__SetLastApplied(long postion);
    private void UpdateLastAppliedIndex(long index, IStorageActionsAccessor accessor);
}
public class Raven.Database.Raft.Storage.Handlers.ClusterConfigurationUpdateCommandHandler : CommandHandler`1<ClusterConfigurationUpdateCommand> {
    public ClusterConfigurationUpdateCommandHandler(DocumentDatabase database, DatabasesLandlord landlord);
    public virtual void Handle(ClusterConfigurationUpdateCommand command);
}
public abstract class Raven.Database.Raft.Storage.Handlers.CommandHandler : object {
    [CompilerGeneratedAttribute]
private DocumentDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private DatabasesLandlord <Landlord>k__BackingField;
    protected DocumentDatabase Database { get; private set; }
    protected DatabasesLandlord Landlord { get; private set; }
    protected CommandHandler(DocumentDatabase database, DatabasesLandlord landlord);
    [CompilerGeneratedAttribute]
protected DocumentDatabase get_Database();
    [CompilerGeneratedAttribute]
private void set_Database(DocumentDatabase value);
    [CompilerGeneratedAttribute]
protected DatabasesLandlord get_Landlord();
    [CompilerGeneratedAttribute]
private void set_Landlord(DatabasesLandlord value);
    public abstract virtual void Handle(object command);
}
public abstract class Raven.Database.Raft.Storage.Handlers.CommandHandler`1 : CommandHandler {
    public Type HandledCommandType { get; }
    protected CommandHandler`1(DocumentDatabase database, DatabasesLandlord landlord);
    public Type get_HandledCommandType();
    public abstract virtual void Handle(TCommand command);
    public virtual void Handle(object command);
}
public class Raven.Database.Raft.Storage.Handlers.DatabaseDeletedCommandHandler : CommandHandler`1<DatabaseDeletedCommand> {
    public DatabaseDeletedCommandHandler(DocumentDatabase database, DatabasesLandlord landlord);
    public virtual void Handle(DatabaseDeletedCommand command);
}
public class Raven.Database.Raft.Storage.Handlers.DatabaseUpdateCommandHandler : CommandHandler`1<DatabaseUpdateCommand> {
    private ILog log;
    public DatabaseUpdateCommandHandler(DocumentDatabase database, DatabasesLandlord landlord);
    public virtual void Handle(DatabaseUpdateCommand command);
}
public class Raven.Database.Raft.Storage.Handlers.ReplicationStateCommandHandler : CommandHandler`1<ReplicationStateCommand> {
    public ReplicationStateCommandHandler(DocumentDatabase database, DatabasesLandlord landlord);
    public virtual void Handle(ReplicationStateCommand command);
}
[ExtensionAttribute]
public static class Raven.Database.Raft.Util.RaftHelper : object {
    [ExtensionAttribute]
public static bool IsActive(ClusterManager engine);
    [ExtensionAttribute]
public static NodeConnectionInfo GetLeaderNode(RaftEngine engine, int waitTimeoutInMiliseconds);
    [ExtensionAttribute]
public static bool IsLeader(ClusterManager engine);
    [ExtensionAttribute]
public static bool IsClusterDatabase(DocumentDatabase database);
    [ExtensionAttribute]
public static bool IsClusterDatabase(CounterStorage counter);
    [ExtensionAttribute]
public static bool IsClusterDatabase(DatabaseDocument document);
    [ExtensionAttribute]
public static bool IsClusterDatabase(CounterStorageDocument document);
    [ExtensionAttribute]
public static void AssertClusterDatabase(DatabaseDocument document);
    public static string GetNormalizedNodeUrl(string url);
    public static Uri GetNodeUrl(string url);
    public static string GetNodeName(Guid name);
    public static bool HasDifferentNodes(TopologyChangeCommand command);
}
internal class Raven.Database.Server.Abstractions.PrincipalWithDatabaseAccess : object {
    public WindowsPrincipal Principal;
    [CompilerGeneratedAttribute]
private IIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AdminDatabases>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ReadOnlyDatabases>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ReadWriteDatabases>k__BackingField;
    public IIdentity Identity { get; private set; }
    public HashSet`1<string> AdminDatabases { get; private set; }
    public HashSet`1<string> ReadOnlyDatabases { get; private set; }
    public HashSet`1<string> ReadWriteDatabases { get; private set; }
    public PrincipalWithDatabaseAccess(WindowsPrincipal principal);
    public sealed virtual bool IsInRole(string role);
    [CompilerGeneratedAttribute]
public sealed virtual IIdentity get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(IIdentity value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_AdminDatabases();
    [CompilerGeneratedAttribute]
private void set_AdminDatabases(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ReadOnlyDatabases();
    [CompilerGeneratedAttribute]
private void set_ReadOnlyDatabases(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ReadWriteDatabases();
    [CompilerGeneratedAttribute]
private void set_ReadWriteDatabases(HashSet`1<string> value);
}
public static class Raven.Database.Server.Abstractions.UrlExtension : object {
    public static string GetRequestUrlFromRawUrl(string rawUrl, InMemoryRavenConfiguration configuration);
}
public enum Raven.Database.Server.AnonymousUserAccessMode : Enum {
    public int value__;
    [ObsoleteAttribute("Will be removed in 4.0")]
public static AnonymousUserAccessMode All;
    [ObsoleteAttribute("Will be removed in 4.0")]
public static AnonymousUserAccessMode Get;
    public static AnonymousUserAccessMode None;
    public static AnonymousUserAccessMode Admin;
}
public static class Raven.Database.Server.AssemblyExtractor : object {
    private static object locker;
    private static string AssemblySuffix;
    private static string CompressedAssemblySuffix;
    private static AssemblyExtractor();
    public static string GetExtractedAssemblyLocationFor(Type type, InMemoryRavenConfiguration configuration);
    public static void ExtractEmbeddedAssemblies(InMemoryRavenConfiguration configuration);
    private static Dictionary`2<string, AssemblyToExtract> FindAssembliesToExtract(Assembly currentAssembly, HashSet`1<string> assembliesToFind);
    private static void Extract(Assembly assemblyToExtractFrom, IEnumerable`1<KeyValuePair`2<string, AssemblyToExtract>> assembliesToExtract, string location);
    private static Assembly GetAssemblyByName(string name);
}
public class Raven.Database.Server.Connections.AdminLogsConnectionState : object {
    private EasyReaderWriterLock slim;
    private SortedDictionary`2<string, LogConfig> logConfig;
    private IEventsTransport logsTransport;
    public object DebugStatus { get; }
    public AdminLogsConnectionState(IEventsTransport logsTransport);
    public void Reconnect(IEventsTransport transport);
    public object get_DebugStatus();
    public void EnableLogging(string category, LogLevel minLevel, bool watchStack);
    public bool DisableLogging(string category);
    public void Send(LogEventInfo logEvent);
    public sealed virtual void Dispose();
}
public class Raven.Database.Server.Connections.AdminLogsTarget : Target {
    private ILog logger;
    private TimeSensitiveStore`1<string> timeSensitiveStore;
    private ConcurrentDictionary`2<string, AdminLogsConnectionState> connections;
    public TimeSensitiveStore`1<string> TimeSensitiveStore { get; }
    public TimeSensitiveStore`1<string> get_TimeSensitiveStore();
    private void AlterEnabled();
    public void OnIdle();
    public void Disconnect(string id);
    public AdminLogsConnectionState Register(IEventsTransport transport);
    public virtual void Write(LogEventInfo logEvent);
    public virtual bool ShouldLog(ILog log, LogLevel level);
    public AdminLogsConnectionState For(string id, RavenBaseApiController controller);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <OnIdle>b__6_0(string s);
}
public class Raven.Database.Server.Connections.AdminLogsWebSocketsRequestParser : WebSocketsRequestParser {
    public AdminLogsWebSocketsRequestParser(DatabasesLandlord databasesLandlord, TimeSeriesLandlord timeSeriesLandlord, CountersLandlord countersLandlord, FileSystemsLandlord fileSystemsLandlord, MixedModeRequestAuthorizer authorizer, string expectedRequestSuffix);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.AdminLogsWebSocketsRequestParser/<ValidateRequest>d__1")]
protected virtual Task ValidateRequest(WebSocketRequest request);
    protected virtual void AuthenticateRequest(WebSocketRequest request);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(WebSocketRequest request);
}
public class Raven.Database.Server.Connections.AdminLogsWebsocketTransport : WebSocketsTransport {
    public AdminLogsWebsocketTransport(RavenDBOptions options, IOwinContext context, CancellationToken disconnectBecauseOfGcToken);
    protected virtual WebSocketsRequestParser CreateWebSocketsRequestParser();
    protected virtual Task SendMessage(MemoryStream memoryStream, JsonSerializer serializer, object message, Func`5<ArraySegment`1<byte>, int, bool, CancellationToken, Task> sendAsync, CancellationToken callCancelled);
    protected virtual void RegisterTransportState();
}
public class Raven.Database.Server.Connections.ChangesPushContent : HttpContent {
    private ILog log;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    private DateTime _started;
    [CompilerGeneratedAttribute]
private Action Disconnected;
    [CompilerGeneratedAttribute]
private long <CoolDownWithDataLossInMiliseconds>k__BackingField;
    private long lastMessageSentTick;
    private object lastMessageEnqueuedAndNotSent;
    private ConcurrentQueue`1<object> msgs;
    private AsyncManualResetEvent manualResetEvent;
    private CancellationTokenSource cancellationTokenSource;
    private bool connected;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    public string Id { get; private set; }
    public bool Connected { get; public set; }
    public TimeSpan Age { get; }
    public long CoolDownWithDataLossInMiliseconds { get; public set; }
    public string ResourceName { get; public set; }
    public ChangesPushContent(RavenBaseApiController controller);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    public sealed virtual bool get_Connected();
    public sealed virtual void set_Connected(bool value);
    public sealed virtual TimeSpan get_Age();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disconnected(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disconnected(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_CoolDownWithDataLossInMiliseconds();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CoolDownWithDataLossInMiliseconds(long value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResourceName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ResourceName(string value);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.ChangesPushContent/<SerializeToStreamAsync>d__29")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.ChangesPushContent/<SendMessage>d__30")]
private Task SendMessage(object message, StreamWriter writer);
    protected virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void SendAsync(object msg);
}
public class Raven.Database.Server.Connections.ConnectionState : object {
    private ConcurrentSet`1<string> matchingIndexes;
    private ConcurrentSet`1<string> matchingDocuments;
    private ConcurrentSet`1<string> matchingDocumentPrefixes;
    private ConcurrentSet`1<string> matchingDocumentsInCollection;
    private ConcurrentSet`1<string> matchingDocumentsOfType;
    private ConcurrentSet`1<string> matchingBulkInserts;
    private ConcurrentSet`1<string> matchingFolders;
    private IEventsTransport eventsTransport;
    private int watchAllDocuments;
    private int watchAllIndexes;
    private int watchAllTransformers;
    private int watchAllReplicationConflicts;
    private int watchConfig;
    private int watchConflicts;
    private int watchSync;
    [CompilerGeneratedAttribute]
private DocumentsConnectionState <DocumentStore>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemConnectionState <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterStorageConnectionState <CounterStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSeriesConnectionState <TimeSeries>k__BackingField;
    public DocumentsConnectionState DocumentStore { get; private set; }
    public FileSystemConnectionState FileSystem { get; private set; }
    public CounterStorageConnectionState CounterStorage { get; private set; }
    public TimeSeriesConnectionState TimeSeries { get; private set; }
    public object DebugStatus { get; }
    public ConnectionState(IEventsTransport eventsTransport);
    [CompilerGeneratedAttribute]
public DocumentsConnectionState get_DocumentStore();
    [CompilerGeneratedAttribute]
private void set_DocumentStore(DocumentsConnectionState value);
    [CompilerGeneratedAttribute]
public FileSystemConnectionState get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(FileSystemConnectionState value);
    [CompilerGeneratedAttribute]
public CounterStorageConnectionState get_CounterStorage();
    [CompilerGeneratedAttribute]
private void set_CounterStorage(CounterStorageConnectionState value);
    [CompilerGeneratedAttribute]
public TimeSeriesConnectionState get_TimeSeries();
    [CompilerGeneratedAttribute]
private void set_TimeSeries(TimeSeriesConnectionState value);
    public object get_DebugStatus();
    public void WatchIndex(string name);
    public void UnwatchIndex(string name);
    public void WatchBulkInsert(string operationId);
    public void UnwatchBulkInsert(string operationId);
    public void WatchTransformers();
    public void UnwatchTransformers();
    public void WatchAllIndexes();
    public void UnwatchAllIndexes();
    public void WatchConflicts();
    public void UnwatchConflicts();
    public void WatchSync();
    public void UnwatchSync();
    public void WatchFolder(string folder);
    public void UnwatchFolder(string folder);
    public void WatchConfig();
    public void UnwatchConfig();
    public void Send(BulkInsertChangeNotification bulkInsertChangeNotification);
    public void Send(DocumentChangeNotification documentChangeNotification);
    public void Send(IndexChangeNotification indexChangeNotification);
    public void Send(TransformerChangeNotification transformerChangeNotification);
    public void Send(ReplicationConflictNotification replicationConflictNotification);
    private void Enqueue(object msg);
    public void WatchAllDocuments();
    public void UnwatchAllDocuments();
    public void WatchDocument(string name);
    public void UnwatchDocument(string name);
    public void WatchDocumentPrefix(string name);
    public void UnwatchDocumentPrefix(string name);
    public void WatchDocumentInCollection(string name);
    public void UnwatchDocumentInCollection(string name);
    public void WatchDocumentOfType(string name);
    public void UnwatchDocumentOfType(string name);
    public void WatchAllReplicationConflicts();
    public void UnwatchAllReplicationConflicts();
    public void Reconnect(IEventsTransport transport);
    public void Dispose();
}
public class Raven.Database.Server.Connections.CounterStorageConnectionState : object {
    private Action`1<object> enqueue;
    private ConcurrentSet`1<string> matchingChanges;
    private ConcurrentSet`1<string> matchingPrefixes;
    private ConcurrentSet`1<string> matchingGroups;
    private ConcurrentSet`1<string> matchingBulkOperations;
    private string changeNotificationType;
    private string startingWithNotification;
    private string inGroupNotificationType;
    private string bulkOperationNotification;
    private int watchAllCounters;
    public object DebugStatus { get; }
    public CounterStorageConnectionState(Action`1<object> enqueue);
    public object get_DebugStatus();
    public void WatchAllCounters();
    public void UnwatchAllCounters();
    public void WatchChange(string name);
    public void UnwatchChange(string name);
    public void WatchPrefix(string prefix);
    public void UnwatchPrefix(string prefix);
    public void WatchCountersInGroup(string group);
    public void UnwatchCountersInGroup(string group);
    public void WatchCounterBulkOperation(string operationId);
    public void UnwatchCounterBulkOperation(string operationId);
    public void Send(ChangeNotification notification);
    public void Send(BulkOperationNotification notification);
}
public class Raven.Database.Server.Connections.DocumentsConnectionState : object {
    private Action`1<object> enqueue;
    private ConcurrentSet`1<string> matchingIndexes;
    private ConcurrentSet`1<string> matchingDocuments;
    private ConcurrentSet`1<string> matchingDocumentPrefixes;
    private ConcurrentSet`1<string> matchingDocumentsInCollection;
    private ConcurrentSet`1<string> matchingDocumentsOfType;
    private ConcurrentSet`1<string> matchingBulkInserts;
    private ConcurrentSet`1<long> matchingDataSubscriptions;
    private int watchAllDocuments;
    private int watchAllIndexes;
    private int watchAllTransformers;
    private int watchAllReplicationConflicts;
    private int watchAllDataSubscriptions;
    public object DebugStatus { get; }
    public DocumentsConnectionState(Action`1<object> enqueue);
    public object get_DebugStatus();
    public void WatchIndex(string name);
    public void UnwatchIndex(string name);
    public void WatchAllIndexes();
    public void UnwatchAllIndexes();
    public void WatchTransformers();
    public void UnwatchTransformers();
    public void WatchDocument(string name);
    public void UnwatchDocument(string name);
    public void WatchAllDocuments();
    public void UnwatchAllDocuments();
    public void WatchDocumentPrefix(string name);
    public void UnwatchDocumentPrefix(string name);
    public void WatchDocumentInCollection(string name);
    public void UnwatchDocumentInCollection(string name);
    public void WatchDocumentOfType(string name);
    public void UnwatchDocumentOfType(string name);
    public void WatchAllReplicationConflicts();
    public void UnwatchAllReplicationConflicts();
    public void WatchBulkInsert(string operationId);
    public void UnwatchBulkInsert(string operationId);
    public void WatchAllDataSubscriptions();
    public void UnwatchAllDataSubscriptions();
    public void WatchDataSubscription(long id);
    public void UnwatchDataSubscription(long id);
    public void Send(BulkInsertChangeNotification bulkInsertChangeNotification);
    public void Send(DocumentChangeNotification documentChangeNotification);
    public void Send(IndexChangeNotification indexChangeNotification);
    public void Send(TransformerChangeNotification transformerChangeNotification);
    public void Send(ReplicationConflictNotification replicationConflictNotification);
    public void Send(DataSubscriptionChangeNotification dataSubscriptionChangeNotification);
}
public class Raven.Database.Server.Connections.FileSystemConnectionState : object {
    private Action`1<object> enqueue;
    private ConcurrentSet`1<string> matchingFolders;
    private int watchConflicts;
    private int watchSync;
    private int watchCancellations;
    private int watchConfig;
    public object DebugStatus { get; }
    public FileSystemConnectionState(Action`1<object> enqueue);
    public object get_DebugStatus();
    public void WatchConflicts();
    public void UnwatchConflicts();
    public void WatchSync();
    public void UnwatchSync();
    public void WatchFolder(string folder);
    public void UnwatchFolder(string folder);
    public void WatchCancellations();
    public void UnwatchCancellations();
    public void WatchConfig();
    public void UnwatchConfig();
    public void Send(FileSystemNotification fileSystemNotification);
    private bool ShouldSend(FileSystemNotification fileSystemNotification);
}
public class Raven.Database.Server.Connections.HttpTracePushContent : PushContentBase {
}
public interface Raven.Database.Server.Connections.IEventsTransport {
    public string Id { get; }
    public string ResourceName { get; public set; }
    public bool Connected { get; public set; }
    public long CoolDownWithDataLossInMiliseconds { get; public set; }
    public TimeSpan Age { get; }
    public abstract virtual string get_Id();
    public abstract virtual string get_ResourceName();
    public abstract virtual void set_ResourceName(string value);
    public abstract virtual bool get_Connected();
    public abstract virtual void set_Connected(bool value);
    public abstract virtual long get_CoolDownWithDataLossInMiliseconds();
    public abstract virtual void set_CoolDownWithDataLossInMiliseconds(long value);
    public abstract virtual TimeSpan get_Age();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Disconnected(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Disconnected(Action value);
    public abstract virtual void SendAsync(object msg);
}
public interface Raven.Database.Server.Connections.ILogsTransport {
    public string Id { get; }
    public bool Connected { get; public set; }
    public abstract virtual string get_Id();
    public abstract virtual bool get_Connected();
    public abstract virtual void set_Connected(bool value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Disconnected(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Disconnected(Action value);
    public abstract virtual void SendAsync(LogEventInfo msg);
}
public class Raven.Database.Server.Connections.LogsPushContent : HttpContent {
    private static int QueueCapacity;
    private ILog log;
    private bool hitCapacity;
    private DateTime _started;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Connected>k__BackingField;
    [CompilerGeneratedAttribute]
private Action Disconnected;
    private BlockingCollection`1<LogEventInfo> msgs;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CoolDownWithDataLossInMiliseconds>k__BackingField;
    public TimeSpan Age { get; }
    public string Id { get; private set; }
    public bool Connected { get; public set; }
    public string ResourceName { get; public set; }
    public long CoolDownWithDataLossInMiliseconds { get; public set; }
    public LogsPushContent(RavenBaseApiController controller);
    public sealed virtual TimeSpan get_Age();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Connected();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Connected(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disconnected(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disconnected(Action value);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.LogsPushContent/<SerializeToStreamAsync>d__19")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.LogsPushContent/<SendMessage>d__20")]
private Task SendMessage(LogEventInfo message, StreamWriter writer);
    protected virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void SendAsync(object msg);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResourceName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ResourceName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_CoolDownWithDataLossInMiliseconds();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CoolDownWithDataLossInMiliseconds(long value);
}
public abstract class Raven.Database.Server.Connections.PushContentBase : HttpContent {
    private DateTime _started;
    private BlockingCollection`1<object> msgs;
    private static int QueueCapacity;
    private ILog log;
    private bool hitCapacity;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Connected>k__BackingField;
    [CompilerGeneratedAttribute]
private Action Disconnected;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CoolDownWithDataLossInMiliseconds>k__BackingField;
    public TimeSpan Age { get; }
    public string Id { get; private set; }
    public bool Connected { get; public set; }
    public string ResourceName { get; public set; }
    public long CoolDownWithDataLossInMiliseconds { get; public set; }
    public sealed virtual TimeSpan get_Age();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Connected();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Connected(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disconnected(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disconnected(Action value);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.PushContentBase/<SerializeToStreamAsync>d__19")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.PushContentBase/<SendMessage>d__20")]
private Task SendMessage(object message, StreamWriter writer);
    protected virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void SendAsync(object msg);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResourceName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ResourceName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_CoolDownWithDataLossInMiliseconds();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CoolDownWithDataLossInMiliseconds(long value);
}
internal class Raven.Database.Server.Connections.ReverseStringComparer : object {
    private StringComparer comparer;
    public sealed virtual int Compare(string x, string y);
}
public class Raven.Database.Server.Connections.TimeSensitiveStore`1 : object {
    private TimeSpan timeout;
    private ConcurrentDictionary`2<T, DateTime> lastSeen;
    public TimeSensitiveStore`1(TimeSpan timeout);
    public void Seen(T item);
    public void Missing(T item);
    public void ForAllExpired(Action`1<T> action);
}
public class Raven.Database.Server.Connections.TimeSeriesConnectionState : object {
    private Action`1<object> enqueue;
    private ConcurrentSet`1<string> matchingKeyChanges;
    private ConcurrentSet`1<string> matchingBulkOperations;
    private string keyChangeNotificationType;
    private string bulkOperationNotificationType;
    private int watchAllTimeSeries;
    public object DebugStatus { get; }
    public TimeSeriesConnectionState(Action`1<object> enqueue);
    public object get_DebugStatus();
    public void WatchAllTimeSeries();
    public void UnwatchAllTimeSeries();
    public void WatchKeyChange(string name);
    public void UnwatchKeyChange(string name);
    public void WatchTimeSeriesBulkOperation(string operationId);
    public void UnwatchTimeSeriesBulkOperation(string operationId);
    public void Send(TimeSeriesChangeNotification notification);
    public void Send(BulkOperationNotification notification);
}
public class Raven.Database.Server.Connections.TransportState : object {
    private static ILog Logger;
    private TimeSensitiveStore`1<string> timeSensitiveStore;
    private ConcurrentDictionary`2<string, ConnectionState> connections;
    [CompilerGeneratedAttribute]
private Action`2<object, IndexChangeNotification> OnIndexChangeNotification;
    [CompilerGeneratedAttribute]
private Action`2<object, TransformerChangeNotification> OnTransformerChangeNotification;
    [CompilerGeneratedAttribute]
private Action`2<object, DocumentChangeNotification> OnDocumentChangeNotification;
    [CompilerGeneratedAttribute]
private Action`2<object, BulkInsertChangeNotification> OnBulkInsertChangeNotification;
    [CompilerGeneratedAttribute]
private Action`2<object, ReplicationConflictNotification> OnReplicationConflictNotification;
    [CompilerGeneratedAttribute]
private Action`2<object, FileSystemNotification> OnFileSystemNotification;
    [CompilerGeneratedAttribute]
private Action`2<object, ChangeNotification> OnChangeNotification;
    [CompilerGeneratedAttribute]
private Action`2<object, TimeSeriesChangeNotification> OnTimeSeriesChangeNotification;
    [CompilerGeneratedAttribute]
private Action`2<object, BulkOperationNotification> OnCounterBulkOperationNotification;
    [CompilerGeneratedAttribute]
private Action`2<object, BulkOperationNotification> OnTimeSeriesBulkOperationNotification;
    [CompilerGeneratedAttribute]
private Action`2<object, DataSubscriptionChangeNotification> OnDataSubscriptionChangeNotification;
    private TimeSensitiveStore`1<string> TimeSensitiveStore { get; }
    public Object[] DebugStatuses { get; }
    private static TransportState();
    private TimeSensitiveStore`1<string> get_TimeSensitiveStore();
    public void OnIdle();
    public void Disconnect(string id);
    public ConnectionState Register(IEventsTransport transport);
    [CompilerGeneratedAttribute]
public void add_OnIndexChangeNotification(Action`2<object, IndexChangeNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnIndexChangeNotification(Action`2<object, IndexChangeNotification> value);
    public void Send(IndexChangeNotification indexChangeNotification);
    [CompilerGeneratedAttribute]
public void add_OnTransformerChangeNotification(Action`2<object, TransformerChangeNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnTransformerChangeNotification(Action`2<object, TransformerChangeNotification> value);
    public void Send(TransformerChangeNotification transformerChangeNotification);
    [CompilerGeneratedAttribute]
public void add_OnDocumentChangeNotification(Action`2<object, DocumentChangeNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnDocumentChangeNotification(Action`2<object, DocumentChangeNotification> value);
    public void Send(DocumentChangeNotification documentChangeNotification);
    [CompilerGeneratedAttribute]
public void add_OnBulkInsertChangeNotification(Action`2<object, BulkInsertChangeNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnBulkInsertChangeNotification(Action`2<object, BulkInsertChangeNotification> value);
    public void Send(BulkInsertChangeNotification bulkInsertChangeNotification);
    [CompilerGeneratedAttribute]
public void add_OnReplicationConflictNotification(Action`2<object, ReplicationConflictNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnReplicationConflictNotification(Action`2<object, ReplicationConflictNotification> value);
    public void Send(ReplicationConflictNotification replicationConflictNotification);
    [CompilerGeneratedAttribute]
public void add_OnFileSystemNotification(Action`2<object, FileSystemNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnFileSystemNotification(Action`2<object, FileSystemNotification> value);
    public void Send(FileSystemNotification fileSystemNotification);
    [CompilerGeneratedAttribute]
public void add_OnChangeNotification(Action`2<object, ChangeNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnChangeNotification(Action`2<object, ChangeNotification> value);
    [CompilerGeneratedAttribute]
public void add_OnTimeSeriesChangeNotification(Action`2<object, TimeSeriesChangeNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnTimeSeriesChangeNotification(Action`2<object, TimeSeriesChangeNotification> value);
    public void Send(ChangeNotification localChangeNotification);
    public void Send(TimeSeriesChangeNotification localChangeNotification);
    [CompilerGeneratedAttribute]
public void add_OnCounterBulkOperationNotification(Action`2<object, BulkOperationNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnCounterBulkOperationNotification(Action`2<object, BulkOperationNotification> value);
    [CompilerGeneratedAttribute]
public void add_OnTimeSeriesBulkOperationNotification(Action`2<object, BulkOperationNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnTimeSeriesBulkOperationNotification(Action`2<object, BulkOperationNotification> value);
    public void Send(BulkOperationNotification bulkOperationNotification);
    public void Send(BulkOperationNotification bulkOperationNotification);
    [CompilerGeneratedAttribute]
public void add_OnDataSubscriptionChangeNotification(Action`2<object, DataSubscriptionChangeNotification> value);
    [CompilerGeneratedAttribute]
public void remove_OnDataSubscriptionChangeNotification(Action`2<object, DataSubscriptionChangeNotification> value);
    public void Send(DataSubscriptionChangeNotification dataSubscriptionChangeNotification);
    public ConnectionState For(string id, RavenBaseApiController controller);
    public Object[] get_DebugStatuses();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <OnIdle>b__5_0(string s);
}
public class Raven.Database.Server.Connections.WatchTrafficWebSocketsRequestParser : WebSocketsRequestParser {
    public WatchTrafficWebSocketsRequestParser(DatabasesLandlord databasesLandlord, TimeSeriesLandlord timeSeriesLandlord, CountersLandlord countersLandlord, FileSystemsLandlord fileSystemsLandlord, MixedModeRequestAuthorizer authorizer, string expectedRequestSuffix);
    protected virtual void AuthenticateRequest(WebSocketRequest request);
}
public class Raven.Database.Server.Connections.WatchTrafficWebsocketTransport : WebSocketsTransport {
    public WatchTrafficWebsocketTransport(RavenDBOptions options, IOwinContext context, CancellationToken disconnectBecauseOfGcToken);
    protected virtual WebSocketsRequestParser CreateWebSocketsRequestParser();
    protected virtual void RegisterTransportState();
}
public class Raven.Database.Server.Connections.WebSocketBufferPool : object {
    private static int BufferSize;
    public static WebSocketBufferPool Instance;
    private PinnableBufferCache pinnableBufferCache;
    private WebSocketBufferPool(int webSocketPoolSizeInBytes);
    public static void Initialize(int webSocketPoolSizeInBytes);
    public ArraySegment`1<byte> TakeBuffer();
    public void ReturnBuffer(ArraySegment`1<byte> buffer);
}
public class Raven.Database.Server.Connections.WebSocketRequest : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private IResourceStore <ActiveResource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrincipal <User>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    public string Id { get; public set; }
    public Uri Uri { get; public set; }
    public IResourceStore ActiveResource { get; public set; }
    public string ResourceName { get; public set; }
    public IPrincipal User { get; public set; }
    public string Token { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(Uri value);
    [CompilerGeneratedAttribute]
public IResourceStore get_ActiveResource();
    [CompilerGeneratedAttribute]
public void set_ActiveResource(IResourceStore value);
    [CompilerGeneratedAttribute]
public string get_ResourceName();
    [CompilerGeneratedAttribute]
public void set_ResourceName(string value);
    [CompilerGeneratedAttribute]
public IPrincipal get_User();
    [CompilerGeneratedAttribute]
public void set_User(IPrincipal value);
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(string value);
}
public class Raven.Database.Server.Connections.WebSocketsRequestParser : object {
    private static string CountersUrlPrefix;
    private static string TimeSeriesUrlPrefix;
    private static string DatabasesUrlPrefix;
    private static string FileSystemsUrlPrefix;
    [CompilerGeneratedAttribute]
private DatabasesLandlord <DatabasesLandlord>k__BackingField;
    private TimeSeriesLandlord timeSeriesLandlord;
    private CountersLandlord countersLandlord;
    private FileSystemsLandlord fileSystemsLandlord;
    private MixedModeRequestAuthorizer authorizer;
    private string expectedRequestSuffix;
    protected DatabasesLandlord DatabasesLandlord { get; private set; }
    public WebSocketsRequestParser(DatabasesLandlord databasesLandlord, TimeSeriesLandlord timeSeriesLandlord, CountersLandlord countersLandlord, FileSystemsLandlord fileSystemsLandlord, MixedModeRequestAuthorizer authorizer, string expectedRequestSuffix);
    [CompilerGeneratedAttribute]
protected DatabasesLandlord get_DatabasesLandlord();
    [CompilerGeneratedAttribute]
private void set_DatabasesLandlord(DatabasesLandlord value);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.WebSocketsRequestParser/<ParseWebSocketRequestAsync>d__14")]
public Task`1<WebSocketRequest> ParseWebSocketRequestAsync(Uri uri, string token);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.WebSocketsRequestParser/<ValidateRequest>d__15")]
protected virtual Task ValidateRequest(WebSocketRequest request);
    protected virtual void AuthenticateRequest(WebSocketRequest request);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.WebSocketsRequestParser/<GetActiveResource>d__17")]
private Task`1<IResourceStore> GetActiveResource(WebSocketRequest request);
    private string NormalizeLocalPath(string localPath);
}
public class Raven.Database.Server.Connections.WebSocketsTransport : object {
    protected static ILog Log;
    [CLSCompliantAttribute("False")]
protected IOwinContext _context;
    private CancellationToken disconnectBecauseOfGcToken;
    [CLSCompliantAttribute("False")]
protected RavenDBOptions _options;
    private AsyncManualResetEvent manualResetEvent;
    private ConcurrentQueue`1<object> msgs;
    protected static int WebSocketCloseMessageType;
    protected static int NormalClosureCode;
    protected static string NormalClosureMessage;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Connected>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CoolDownWithDataLossInMiliseconds>k__BackingField;
    private long lastMessageSentTick;
    private object lastMessageEnqueuedAndNotSent;
    private WebSocketsRequestParser webSocketsRequestParser;
    [CompilerGeneratedAttribute]
private IResourceStore <ActiveTenant>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    public ArraySegment`1<byte> PreAllocatedBuffer;
    private DateTime _started;
    private CancellationTokenSource cancellationTokenSource;
    [CompilerGeneratedAttribute]
private Action Disconnected;
    public string Id { get; private set; }
    public bool Connected { get; public set; }
    public long CoolDownWithDataLossInMiliseconds { get; public set; }
    protected IResourceStore ActiveTenant { get; protected set; }
    public string ResourceName { get; public set; }
    public WebSocketsRequestParser WebSocketsRequestParser { get; }
    public TimeSpan Age { get; }
    public WebSocketsTransport(RavenDBOptions options, IOwinContext context, CancellationToken disconnectBecauseOfGcToken);
    private static WebSocketsTransport();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Connected();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Connected(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_CoolDownWithDataLossInMiliseconds();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CoolDownWithDataLossInMiliseconds(long value);
    [CompilerGeneratedAttribute]
protected IResourceStore get_ActiveTenant();
    [CompilerGeneratedAttribute]
protected void set_ActiveTenant(IResourceStore value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResourceName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ResourceName(string value);
    protected virtual WebSocketsRequestParser CreateWebSocketsRequestParser();
    public WebSocketsRequestParser get_WebSocketsRequestParser();
    public sealed virtual void Dispose();
    public sealed virtual TimeSpan get_Age();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Disconnected(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Disconnected(Action value);
    public sealed virtual void SendAsync(object msg);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.WebSocketsTransport/<Run>d__46")]
public virtual Task Run(IDictionary`2<string, object> websocketContext);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.WebSocketsTransport/<RunInternal>d__47")]
private Task RunInternal(IDictionary`2<string, object> websocketContext);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.WebSocketsTransport/<CloseConnection>d__48")]
private Task CloseConnection(IDictionary`2<string, object> websocketContext);
    private void CreateWaitForClientCloseTask(IDictionary`2<string, object> websocketContext);
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.WebSocketsTransport/<SendMessage>d__50")]
protected virtual Task SendMessage(MemoryStream memoryStream, JsonSerializer serializer, object message, Func`5<ArraySegment`1<byte>, int, bool, CancellationToken, Task> sendAsync, CancellationToken callCancelled);
    private void OnDisconnection();
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.WebSocketsTransport/<TrySetupRequest>d__52")]
public virtual Task`1<bool> TrySetupRequest();
    protected virtual void RegisterTransportState();
}
public class Raven.Database.Server.Connections.WebSocketsValidateTransport : WebSocketsTransport {
    public WebSocketsValidateTransport(RavenDBOptions options, IOwinContext context, CancellationToken disconnectBecauseOfGcToken);
    protected virtual WebSocketsRequestParser CreateWebSocketsRequestParser();
    [AsyncStateMachineAttribute("Raven.Database.Server.Connections.WebSocketsValidateTransport/<Run>d__2")]
public virtual Task Run(IDictionary`2<string, object> websocketContext);
    public virtual Task`1<bool> TrySetupRequest();
}
public static class Raven.Database.Server.Connections.WebSocketTransportFactory : object {
    public static string ChangesApiWebsocketSuffix;
    public static string WatchTrafficWebsocketSuffix;
    public static string AdminLogsWebsocketSuffix;
    public static string WebsocketValidateSuffix;
    private static CancellationTokenSource ravenGcCancellation;
    private static int webSocektTransportsCount;
    public static CancellationTokenSource RavenGcCancellation { get; }
    private static WebSocketTransportFactory();
    public static CancellationTokenSource get_RavenGcCancellation();
    public static void DecrementWebSocketTransportsCount();
    public static WebSocketsTransport CreateWebSocketTransport(RavenDBOptions options, IOwinContext context);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.Admin.AdminController : BaseAdminDatabaseApiController {
    private static HashSet`1<string> TasksToFilterOut;
    private static TimeSpan ReportProgressInterval;
    private static string EsentProgressString;
    private static string VoronProgressString;
    private static Lazy`1<string> CurrentProcessName;
    protected WindowsBuiltInRole[] AdditionalSupportedRoles { get; }
    private static AdminController();
    [HttpGetAttribute]
[RavenRouteAttribute("admin/generate-oauth-certificate")]
public HttpResponseMessage GenerateOAuthCertificate();
    [HttpGetAttribute]
[RavenRouteAttribute("admin/cluster-statistics")]
public HttpResponseMessage GetClusterStatistics();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminController/<ServerSmuggling>d__3")]
[HttpPostAttribute]
[RavenRouteAttribute("admin/serverSmuggling")]
public Task`1<HttpResponseMessage> ServerSmuggling();
    private static DocumentStore CreateStore(ServerConnectionInfo connection);
    [RavenRouteAttribute("databases/{databaseName}/admin/backup")]
[RavenRouteAttribute("admin/backup")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminController/<Backup>d__6")]
public Task`1<HttpResponseMessage> Backup();
    protected virtual WindowsBuiltInRole[] get_AdditionalSupportedRoles();
    [RavenRouteAttribute("databases/{databaseName}/admin/restore")]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminController/<Restore>d__9")]
[HttpPostAttribute]
[RavenRouteAttribute("admin/restore")]
public Task`1<HttpResponseMessage> Restore();
    private void GenerateNewDatabaseId(string databaseName);
    private static bool TryRemoveReplicationBundle(DatabaseDocument databaseDocument);
    private void AddReplicationBundleAndDisableReplicationDestinations(string databaseName);
    private string ResolveTenantDataDirectory(string databaseLocation, string databaseName, String& documentDataDir);
    [RavenRouteAttribute("admin/changedbid")]
[HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/admin/changedbid")]
public HttpResponseMessage ChangeDbId();
    [HttpGetAttribute]
[RavenRouteAttribute("admin/license/connectivity")]
public HttpResponseMessage CheckConnectivityToLicenseServer();
    [HttpGetAttribute]
[RavenRouteAttribute("admin/license/forceUpdate")]
public HttpResponseMessage ForceLicenseUpdate();
    [HttpPostAttribute]
[RavenRouteAttribute("admin/compact")]
public HttpResponseMessage Compact();
    private static bool IsUpdateMessage(string msg);
    [HttpGetAttribute]
[RavenRouteAttribute("admin/indexingStatus")]
[RavenRouteAttribute("databases/{databaseName}/admin/indexingStatus")]
public HttpResponseMessage IndexingStatus();
    [RavenRouteAttribute("databases/{databaseName}/admin/optimize")]
[RavenRouteAttribute("admin/optimize")]
[HttpPostAttribute]
public void Optimize();
    [RavenRouteAttribute("databases/{databaseName}/admin/startIndexing")]
[HttpPostAttribute]
[RavenRouteAttribute("admin/startIndexing")]
public void StartIndexing();
    [HttpPostAttribute]
[RavenRouteAttribute("admin/stopIndexing")]
[RavenRouteAttribute("databases/{databaseName}/admin/stopIndexing")]
public void StopIndexing();
    [RavenRouteAttribute("databases/{databaseName}/admin/startReducing")]
[HttpPostAttribute]
[RavenRouteAttribute("admin/startReducing")]
public void StartReducing();
    [HttpPostAttribute]
[RavenRouteAttribute("admin/stopReducing")]
[RavenRouteAttribute("databases/{databaseName}/admin/stopReducing")]
public void StopReducing();
    [RavenRouteAttribute("databases/{databaseName}/admin/debug/auto-tuning-info")]
[RavenRouteAttribute("admin/debug/auto-tuning-info")]
[HttpGetAttribute]
public HttpResponseMessage DebugAutoTuningInfo();
    [RavenRouteAttribute("admin/stats")]
[HttpGetAttribute]
public HttpResponseMessage Stats();
    private AdminStatistics CreateAdminStats();
    [IteratorStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminController/<LoadedDatabasesStats>d__31")]
private IEnumerable`1<LoadedDatabaseStatistics> LoadedDatabasesStats(IEnumerable`1<DocumentDatabase> allDbs);
    private decimal ConvertBytesToMBs(long bytes);
    private static long GetCurrentProcessPrivateMemorySize64();
    private static long GetCurrentManagedMemorySize();
    [HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/admin/detailed-storage-breakdown")]
[RavenRouteAttribute("admin/detailed-storage-breakdown")]
public HttpResponseMessage DetailedStorageBreakdown();
    [HttpGetAttribute]
[RavenRouteAttribute("admin/gc")]
[HttpPostAttribute]
public HttpResponseMessage Gc();
    [HttpGetAttribute]
[HttpPostAttribute]
[RavenRouteAttribute("admin/loh-compaction")]
public HttpResponseMessage LohCompaction();
    [HttpGetAttribute]
[RavenRouteAttribute("admin/verify-principal")]
public HttpResponseMessage VerifyPrincipal(string mode, string principal);
    [HttpGetAttribute]
[RavenRouteAttribute("admin/tasks")]
[RavenRouteAttribute("databases/{databaseName}/admin/tasks")]
public HttpResponseMessage Tasks();
    private static IEnumerable`1<string> FilterOutTasks(OrderedPartCollection`1<IStartupTask> tasks);
    [HttpGetAttribute]
[RavenRouteAttribute("admin/killQuery")]
[RavenRouteAttribute("databases/{databaseName}/admin/killQuery")]
public HttpResponseMessage KillQuery();
    [RavenRouteAttribute("admin/debug/info-package")]
[HttpGetAttribute]
public HttpResponseMessage InfoPackage();
    private void DumpStacktrace(ZipArchive package);
    private static void ExtractResource(string resource, string path);
    [HttpGetAttribute]
[RavenRouteAttribute("admin/logs/configure")]
public HttpResponseMessage OnAdminLogsConfig();
    [RavenRouteAttribute("admin/logs/events")]
[HttpGetAttribute]
public HttpResponseMessage OnAdminLogsFetch();
    [RavenRouteAttribute("admin/transactions/rollbackAll")]
[RavenRouteAttribute("databases/{databaseName}/admin/transactions/rollbackAll")]
[HttpPostAttribute]
public HttpResponseMessage Transactions();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminController/<IoTest>d__49")]
[HttpPostAttribute]
[RavenRouteAttribute("admin/ioTest")]
public Task`1<HttpResponseMessage> IoTest();
    [HttpPostAttribute]
[RavenRouteAttribute("admin/low-memory-notification")]
public HttpResponseMessage LowMemoryNotification();
    [HttpGetAttribute]
[RavenRouteAttribute("admin/low-memory-handlers-statistics")]
public HttpResponseMessage GetLowMemoryStatistics();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminController/<GlobalReplicationTopology>d__52")]
[RavenRouteAttribute("admin/replication/topology/global")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> GlobalReplicationTopology();
    private ReplicationTopology CollectReplicationTopology();
    private HashSet`1<string> GetDatabasesNames();
    private SynchronizationTopology CollectFilesystemSynchronizationTopology();
    private CountersReplicationTopology CollectionCountersReplicationTopology();
    [RavenRouteAttribute("admin/dump")]
[HttpGetAttribute]
public HttpResponseMessage Dump();
    [CompilerGeneratedAttribute]
private string <GetDatabasesNames>b__54_0(RavenJToken database);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.Admin.AdminDatabasesController : BaseAdminDatabaseApiController {
    private static string BatchDeleteUrl;
    private static string ToggleIndexing;
    private static string ToggleRejectClients;
    [HttpGetAttribute]
[RavenRouteAttribute("admin/databases/{*id}")]
public HttpResponseMessage Get(string id);
    [RavenRouteAttribute("admin/databases/{*id}")]
[HttpPutAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminDatabasesController/<Put>d__1")]
public Task`1<HttpResponseMessage> Put(string id);
    [RavenRouteAttribute("admin/databases/{*id}")]
[HttpDeleteAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminDatabasesController/<Delete>d__3")]
public Task`1<HttpResponseMessage> Delete(string id);
    [HttpDeleteAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminDatabasesController/<BatchDelete>d__4")]
[RavenRouteAttribute("admin/databases-batch-delete")]
public Task`1<HttpResponseMessage> BatchDelete();
    [HttpPostAttribute]
[RavenRouteAttribute("admin/databases/{*id}")]
public object OldToggleDisable(string id);
    [HttpPostAttribute]
[RavenRouteAttribute("admin/databases-toggle-disable")]
public HttpResponseMessage ToggleDisable(string id, bool isSettingDisabled);
    [HttpPostAttribute]
[RavenRouteAttribute("admin/databases-toggle-indexing")]
public HttpResponseMessage ToggleIndexingDisable(string id, bool isSettingIndexingDisabled);
    [HttpPostAttribute]
[RavenRouteAttribute("admin/databases-toggle-reject-clients")]
public HttpResponseMessage DatabaseToggleRejectClientsEnabled(string id, bool isRejectClientsEnabled);
    [RavenRouteAttribute("admin/activate-hotspare")]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminDatabasesController/<ActivateHotSpare>d__11")]
[HttpGetAttribute]
public Task`1<HttpResponseMessage> ActivateHotSpare();
    [HttpGetAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminDatabasesController/<TestHotSpare>d__12")]
[RavenRouteAttribute("admin/test-hotspare")]
public Task`1<HttpResponseMessage> TestHotSpare();
    [HttpGetAttribute]
[RavenRouteAttribute("admin/get-hotspare-information")]
public HttpResponseMessage GetHotSpareInformation();
    [HttpGetAttribute]
[RavenRouteAttribute("admin/clear-hotspare-information")]
public HttpResponseMessage ClearHotSpareInformation();
    [RavenRouteAttribute("admin/databases/batch-toggle-disable")]
[HttpPostAttribute]
public HttpResponseMessage DatabaseBatchToggleDisable(bool isSettingDisabled);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminDatabasesController/<DeleteDatabase>d__16")]
private Task`1<MessageWithStatusCode<DocumentDatabase, DatabasesLandlord>> DeleteDatabase(string databaseId, bool isHardDeleteNeeded);
    private MessageWithStatusCode<DocumentDatabase, DatabasesLandlord> ToggeleDatabaseDisabled(string databaseId, bool isSettingDisabled);
    private MessageWithStatusCode<DocumentDatabase, DatabasesLandlord> ToggeleDatabaseIndexingDisabled(string databaseId, bool isindexingDisabled);
    private MessageWithStatusCode<DocumentDatabase, DatabasesLandlord> ToggleRejectClientsEnabled(string databaseId, bool isRejectClientsEnabled);
    private string CheckExistingDatabaseName(string id, Etag etag);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.Admin.AdminJsConsoleController : BaseAdminDatabaseApiController {
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.Admin.AdminJsConsoleController/<Console>d__0")]
[HttpPostAttribute]
[RavenRouteAttribute("admin/console/{*id}")]
public Task`1<HttpResponseMessage> Console(string id);
}
public class Raven.Database.Server.Controllers.Admin.BaseAdminDatabaseApiController : AdminResourceApiController`2<DocumentDatabase, DatabasesLandlord> {
    public ResourceType ResourceType { get; }
    public string DatabaseName { get; }
    public DocumentDatabase Database { get; }
    public virtual ResourceType get_ResourceType();
    public string get_DatabaseName();
    public DocumentDatabase get_Database();
    public virtual void MarkRequestDuration(long duration);
}
public class Raven.Database.Server.Controllers.Admin.BenchmarkController : BaseDatabaseApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("Benchmark/EmptyMessage")]
public HttpResponseMessage EmptyMessageTest();
}
public abstract class Raven.Database.Server.Controllers.AdminBundlesApiController : BaseAdminDatabaseApiController {
    public string BundleName { get; }
    public abstract virtual string get_BundleName();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.AdminBundlesApiController/<ExecuteAsync>d__2")]
public virtual Task`1<HttpResponseMessage> ExecuteAsync(HttpControllerContext controllerContext, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <ExecuteAsync>b__2_0(string activeBundleName);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpControllerContext controllerContext, CancellationToken cancellationToken);
}
public abstract class Raven.Database.Server.Controllers.BaseDatabaseApiController : ResourceApiController`2<DocumentDatabase, DatabasesLandlord> {
    private string queryFromPostRequest;
    public string DatabaseName { get; }
    public DocumentDatabase Database { get; }
    public ResourceType ResourceType { get; }
    public string get_DatabaseName();
    public DocumentDatabase get_Database();
    public virtual ResourceType get_ResourceType();
    public virtual void MarkRequestDuration(long duration);
    public void SetPostRequestQuery(string query);
    public void InitializeFrom(BaseDatabaseApiController other);
    public virtual HttpResponseMessage GetEmptyMessage(HttpStatusCode code, Etag etag);
    public virtual HttpResponseMessage GetMessageWithObject(object item, HttpStatusCode code, Etag etag);
    public virtual HttpResponseMessage GetMessageWithString(string msg, HttpStatusCode code, Etag etag);
    protected TransactionInformation GetRequestTransaction();
    protected virtual IndexQuery GetIndexQuery(int maxPageSize);
    private bool IsDistinct();
    private Dictionary`2<string, SortOptions> GetSortHints();
    public Etag GetCutOffEtag();
    private bool GetExplainScores();
    private bool GetWaitForNonStaleResultsAsOfNow();
    public Nullable`1<DateTime> GetCutOff();
    [IteratorStateMachineAttribute("Raven.Database.Server.Controllers.BaseDatabaseApiController/<GetHighlightedFields>d__21")]
public IEnumerable`1<HighlightedField> GetHighlightedFields();
    public Dictionary`2<string, RavenJToken> ExtractTransformerParameters();
    protected bool GetOverwriteExisting();
    protected bool GetCheckReferencesInIndexes();
    protected bool GetAllowStale();
    protected bool GetSkipOverwriteIfUnchanged();
    protected BulkInsertCompression GetCompression();
    protected BulkInsertFormat GetFormat();
    protected Nullable`1<int> GetMaxOpsPerSec();
    protected Nullable`1<TimeSpan> GetStaleTimeout();
    protected bool GetRetrieveDetails();
    protected void HandleReplication(HttpResponseMessage msg);
    protected Etag GetLastDocEtag();
    protected HttpResponseMessage Resources(string prefix, Func`2<RavenJArray, List`1<T>> getResourcesData, bool getAdditionalData);
    protected RavenJArray GetResourcesDocuments(string resourcePrefix);
    protected UserInfo GetUserInfo();
    protected bool CanExposeConfigOverTheWire();
}
public class Raven.Database.Server.Controllers.BuildController : BaseDatabaseApiController {
    [HttpGetAttribute]
public HttpResponseMessage Version();
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.BulkInsertController : BaseDatabaseApiController {
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.BulkInsertController/<BulkInsertPost>d__0")]
[HttpPostAttribute]
[RavenRouteAttribute("bulkInsert")]
[RavenRouteAttribute("databases/{databaseName}/bulkInsert")]
public Task`1<HttpResponseMessage> BulkInsertPost();
    [IteratorStateMachineAttribute("Raven.Database.Server.Controllers.BulkInsertController/<YieldBatches>d__1")]
private IEnumerable`1<IEnumerable`1<JsonDocument>> YieldBatches(CancellationTimeout timeout, Stream inputStream, ManualResetEventSlim mre, BulkInsertOptions options, Action`1<int> increaseDocumentsCount);
    private IEnumerable`1<JsonDocument> YieldDeserializeDocumentsInBatch(CancellationTimeout timeout, Stream partialStream, BulkInsertOptions options, Action`1<int> increaseDocumentsCount);
    private IEnumerable`1<JsonDocument> YieldDocumentsInBatch(CancellationTimeout timeout, Stream partialStream, BulkInsertOptions options, Action`1<int> increaseDocumentsCount);
    [IteratorStateMachineAttribute("Raven.Database.Server.Controllers.BulkInsertController/<YieldBsonDocumentsInBatch>d__4")]
private IEnumerable`1<JsonDocument> YieldBsonDocumentsInBatch(CancellationTimeout timeout, BinaryReader reader, int count, Action`1<int> increaseDocumentsCount);
    [IteratorStateMachineAttribute("Raven.Database.Server.Controllers.BulkInsertController/<YieldJsonDocumentsInBatch>d__5")]
private IEnumerable`1<JsonDocument> YieldJsonDocumentsInBatch(CancellationTimeout timeout, Stream stream, int count, Action`1<int> increaseDocumentsCount);
    private static JsonDocument PrepareJsonDocument(RavenJObject doc);
}
public abstract class Raven.Database.Server.Controllers.BundlesApiController : BaseDatabaseApiController {
    public string BundleName { get; }
    public abstract virtual string get_BundleName();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.BundlesApiController/<ExecuteAsync>d__2")]
public virtual Task`1<HttpResponseMessage> ExecuteAsync(HttpControllerContext controllerContext, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <ExecuteAsync>b__2_0(string activeBundleName);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpControllerContext controllerContext, CancellationToken cancellationToken);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.ChangesController : BaseDatabaseApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("changes/config")]
[RavenRouteAttribute("databases/{databaseName}/changes/config")]
public HttpResponseMessage GetChangeConfig();
    [RavenRouteAttribute("changes/events")]
[RavenRouteAttribute("databases/{databaseName}/changes/events")]
[HttpGetAttribute]
public HttpResponseMessage GetChangesEvents();
}
public class Raven.Database.Server.Controllers.ClusterAwareRavenDbApiController : BaseDatabaseApiController {
    protected bool ForceClusterAwareness { get; }
    protected virtual bool get_ForceClusterAwareness();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.ClusterAwareRavenDbApiController/<ExecuteAsync>d__2")]
public virtual Task`1<HttpResponseMessage> ExecuteAsync(HttpControllerContext controllerContext, CancellationToken cancellationToken);
    private static bool IsReadRequest(HttpControllerContext controllerContext);
    private static string GetClusterHeader(HttpControllerContext controllerContext, string key);
    private HttpResponseMessage RedirectToLeader(HttpRequestMessage request);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpControllerContext controllerContext, CancellationToken cancellationToken);
}
public class Raven.Database.Server.Controllers.ConfigurationController : BaseDatabaseApiController {
    [RavenRouteAttribute("databases/{databaseName}/configuration/document/{*docId}")]
[RavenRouteAttribute("configuration/document/{*docId}")]
[HttpGetAttribute]
public HttpResponseMessage ConfigurationGet(string docId);
    [HttpGetAttribute]
[RavenRouteAttribute("configuration/global/settings")]
public HttpResponseMessage ConfigurationGlobalSettingsGet();
    [HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/configuration/settings")]
[RavenRouteAttribute("configuration/settings")]
public HttpResponseMessage ConfigurationSettingsGet();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.ConfigurationController/<GlobalSettingsPut>d__3")]
[HttpPutAttribute]
[RavenRouteAttribute("configuration/global/settings")]
public Task`1<HttpResponseMessage> GlobalSettingsPut();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.ConfigurationController/<PeriodicExportSettingsPut>d__4")]
[RavenRouteAttribute("databases/{databaseName}/configuration/periodicExportSettings")]
[RavenRouteAttribute("configuration/periodicExportSettings")]
[HttpPutAttribute]
public Task`1<HttpResponseMessage> PeriodicExportSettingsPut();
    [RavenRouteAttribute("databases/{databaseName}/configuration/replication")]
[HttpGetAttribute]
[RavenRouteAttribute("configuration/replication")]
public HttpResponseMessage ReplicationConfigurationGet();
    [HttpGetAttribute]
[RavenRouteAttribute("configuration/versioning")]
[RavenRouteAttribute("databases/{databaseName}/configuration/versioning")]
public HttpResponseMessage VersioningConfigurationGet();
    [CompilerGeneratedAttribute]
private RavenJObject <VersioningConfigurationGet>b__6_2(string id);
}
public class Raven.Database.Server.Controllers.DatabasesController : BaseDatabaseApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("databases")]
public HttpResponseMessage Databases(bool getAdditionalData);
    private List`1<DatabaseData> GetDatabasesData(IEnumerable`1<RavenJToken> databases);
    private static bool GetBooleanSettingStatus(RavenJObject settingsProperty, string propertyName);
    [HttpGetAttribute]
[RavenRouteAttribute("database/size")]
[RavenRouteAttribute("databases/{databaseName}/database/size")]
public HttpResponseMessage DatabaseSize();
    [RavenRouteAttribute("databases/{databaseName}/database/storage/sizes")]
[HttpGetAttribute]
[RavenRouteAttribute("database/storage/sizes")]
public HttpResponseMessage DatabaseStorageSizes();
    [CompilerGeneratedAttribute]
private DatabaseData <GetDatabasesData>b__1_0(RavenJToken database);
}
public class Raven.Database.Server.Controllers.DbSingleAuthTokenController : BaseDatabaseApiController {
    [RavenRouteAttribute("singleAuthToken")]
[HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/singleAuthToken")]
public HttpResponseMessage SingleAuthGet();
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.DebugController : BaseDatabaseApiController {
    [RavenRouteAttribute("cs/debug/counter-storages")]
[HttpGetAttribute]
public HttpResponseMessage GetCounterStoragesInfo();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DebugController/<GetCounterNames>d__2")]
[HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/debug/")]
public Task`1<HttpResponseMessage> GetCounterNames(string counterStorageName, int skip, int take);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DebugController/<GetCounterMetrics>d__3")]
[HttpGetAttribute]
[RavenRouteAttribute("cs/{counterStorageName}/debug/metrics")]
public Task`1<HttpResponseMessage> GetCounterMetrics(string counterStorageName);
    [RavenRouteAttribute("debug/cache-details")]
[HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/debug/cache-details")]
public HttpResponseMessage CacheDetails();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/enable-query-timing")]
[RavenRouteAttribute("databases/{databaseName}/debug/enable-query-timing")]
public HttpResponseMessage EnableQueryTiming();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/disable-query-timing")]
[RavenRouteAttribute("databases/{databaseName}/debug/disable-query-timing")]
public HttpResponseMessage DisableQueryTiming();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/prefetch-status")]
[RavenRouteAttribute("databases/{databaseName}/debug/prefetch-status")]
public HttpResponseMessage PrefetchingQueueStatus();
    [HttpPostAttribute]
[RavenRouteAttribute("debug/format-index")]
[RavenRouteAttribute("databases/{databaseName}/debug/format-index")]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DebugController/<FormatIndex>d__8")]
public Task`1<HttpResponseMessage> FormatIndex();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/sql-replication-perf-stats")]
[RavenRouteAttribute("databases/{databaseName}/debug/sql-replication-perf-stats")]
public HttpResponseMessage SqlReplicationPerfStats();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/replication-perf-stats")]
[RavenRouteAttribute("databases/{databaseName}/debug/replication-perf-stats")]
public HttpResponseMessage ReplicationPerfStats();
    [RavenRouteAttribute("debug/indexing-perf-stats-with-timings")]
[RavenRouteAttribute("databases/{databaseName}/debug/indexing-perf-stats-with-timings")]
[HttpGetAttribute]
public HttpResponseMessage IndexingPerfStatsWthTimings(string format);
    [HttpGetAttribute]
[RavenRouteAttribute("debug/filtered-out-indexes")]
[RavenRouteAttribute("databases/{databaseName}/debug/filtered-out-indexes")]
public HttpResponseMessage FilteredOutIndexes();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/indexing-batch-stats")]
[RavenRouteAttribute("databases/{databaseName}/debug/indexing-batch-stats")]
public HttpResponseMessage IndexingBatchStats(int lastId);
    [RavenRouteAttribute("databases/{databaseName}/debug/reducing-batch-stats")]
[HttpGetAttribute]
[RavenRouteAttribute("debug/reducing-batch-stats")]
public HttpResponseMessage ReducingBatchStats(int lastId);
    [HttpGetAttribute]
[RavenRouteAttribute("debug/deletion-batch-stats")]
[RavenRouteAttribute("databases/{databaseName}/debug/deletion-batch-stats")]
public HttpResponseMessage DeletionBatchStats(int lastId);
    [HttpGetAttribute]
[RavenRouteAttribute("debug/plugins")]
[RavenRouteAttribute("databases/{databaseName}/debug/plugins")]
public HttpResponseMessage Plugins();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/changes")]
[RavenRouteAttribute("databases/{databaseName}/debug/changes")]
public HttpResponseMessage Changes();
    [RavenRouteAttribute("databases/{databaseName}/debug/sql-replication-stats")]
[RavenRouteAttribute("debug/sql-replication-stats")]
[HttpGetAttribute]
public HttpResponseMessage SqlReplicationStats();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/metrics")]
[RavenRouteAttribute("databases/{databaseName}/debug/metrics")]
public HttpResponseMessage Metrics();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/config")]
[RavenRouteAttribute("databases/{databaseName}/debug/config")]
public HttpResponseMessage Config();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/raw-doc")]
[RavenRouteAttribute("databases/{databaseName}/debug/raw-doc")]
public HttpResponseMessage RawDocBytes();
    [RavenRouteAttribute("debug/slow-dump-ref-csv")]
[RavenRouteAttribute("databases/{databaseName}/debug/slow-dump-ref-csv")]
[HttpGetAttribute]
public HttpResponseMessage DumpRefsToCsv(int sampleCount);
    [HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/debug/docrefs")]
[RavenRouteAttribute("debug/docrefs")]
public HttpResponseMessage DocRefs(string id);
    [HttpGetAttribute]
[RavenRouteAttribute("debug/d0crefs-t0ps")]
[RavenRouteAttribute("databases/{databaseName}/debug/d0crefs-t0ps")]
public HttpResponseMessage DocRefsTops();
    [RavenRouteAttribute("databases/{databaseName}/debug/index-fields")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DebugController/<IndexFields>d__25")]
[RavenRouteAttribute("debug/index-fields")]
public Task`1<HttpResponseMessage> IndexFields();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/list")]
[RavenRouteAttribute("databases/{databaseName}/debug/list")]
public HttpResponseMessage List(string id);
    [HttpGetAttribute]
[RavenRouteAttribute("debug/list-all")]
[RavenRouteAttribute("databases/{databaseName}/debug/list-all")]
public HttpResponseMessage ListAll(string id);
    [HttpGetAttribute]
[RavenRouteAttribute("debug/queries")]
[RavenRouteAttribute("databases/{databaseName}/debug/queries")]
public HttpResponseMessage Queries();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/suggest-index-merge")]
[RavenRouteAttribute("databases/{databaseName}/debug/suggest-index-merge")]
public HttpResponseMessage IndexMerge();
    [RavenRouteAttribute("databases/{databaseName}/debug/sl0w-d0c-c0unts")]
[HttpGetAttribute]
[RavenRouteAttribute("debug/sl0w-d0c-c0unts")]
public HttpResponseMessage SlowDocCounts();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/sl0w-lists-breakd0wn")]
[RavenRouteAttribute("databases/{databaseName}/debug/sl0w-lists-breakd0wn")]
public HttpResponseMessage DetailedListsBreakdown();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/auto-tuning-info")]
[RavenRouteAttribute("databases/{databaseName}/debug/auto-tuning-info")]
public HttpResponseMessage DebugAutoTuningInfo();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/user-info")]
[RavenRouteAttribute("databases/{databaseName}/debug/user-info")]
public HttpResponseMessage UserInfo();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/user-info")]
[RavenRouteAttribute("databases/{databaseName}/debug/user-info")]
public HttpResponseMessage GetUserPermission(string database, string method);
    [RavenRouteAttribute("databases/{databaseName}/debug/tasks")]
[HttpGetAttribute]
[RavenRouteAttribute("debug/tasks")]
public HttpResponseMessage Tasks();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/tasks/summary")]
[RavenRouteAttribute("databases/{databaseName}/debug/tasks/summary")]
public HttpResponseMessage TasksSummary();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/routes")]
[DescriptionAttribute("Output the debug information for all the supported routes in Raven Server.")]
public HttpResponseMessage Routes();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/currently-indexing")]
[RavenRouteAttribute("databases/{databaseName}/debug/currently-indexing")]
public HttpResponseMessage CurrentlyIndexing();
    [RavenRouteAttribute("databases/{databaseName}/debug/remaining-reductions")]
[HttpGetAttribute]
[RavenRouteAttribute("debug/remaining-reductions")]
public HttpResponseMessage CurrentlyRemainingReductions();
    [RavenRouteAttribute("databases/{databaseName}/debug/clear-remaining-reductions")]
[RavenRouteAttribute("debug/clear-remaining-reductions")]
[HttpGetAttribute]
public HttpResponseMessage ResetRemainingReductionsTracking();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/request-tracing")]
[RavenRouteAttribute("databases/{databaseName}/debug/request-tracing")]
public HttpResponseMessage RequestTracing();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/identities")]
[RavenRouteAttribute("databases/{databaseName}/debug/identities")]
public HttpResponseMessage Identities();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/resource-drives")]
public HttpResponseMessage ResourceDrives(string name, string type);
    private static String[] FindUniqueDrives(String[] paths);
    [HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/debug/info-package")]
[RavenRouteAttribute("debug/info-package")]
public HttpResponseMessage InfoPackage();
    [RavenRouteAttribute("debug/transactions")]
[RavenRouteAttribute("databases/{databaseName}/debug/transactions")]
[HttpGetAttribute]
public HttpResponseMessage Transactions();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/subscriptions")]
[RavenRouteAttribute("databases/{databaseName}/debug/subscriptions")]
public HttpResponseMessage Subscriptions();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/thread-pool")]
public HttpResponseMessage ThreadPool();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/indexing-perf-stats")]
[RavenRouteAttribute("databases/{databaseName}/debug/indexing-perf-stats")]
public HttpResponseMessage IndexingPerfStats();
    [HttpGetAttribute]
[RavenRouteAttribute("debug/gc-info")]
public HttpResponseMessage GCInfo();
    [CompilerGeneratedAttribute]
private void <Tasks>b__35_0(Stream stream, HttpContent content, TransportContext context);
}
public class Raven.Database.Server.Controllers.DebugVoronController : BaseAdminDatabaseApiController {
    [RavenRouteAttribute("databases/{databaseName}/admin/voron/tree")]
[RavenRouteAttribute("admin/voron/tree")]
[HttpGetAttribute]
public HttpResponseMessage DumpTree(string name);
    [RavenRouteAttribute("databases/{databaseName}/admin/voron/scratch-buffer-pool-info")]
[RavenRouteAttribute("admin/voron/scratch-buffer-pool-info")]
[HttpGetAttribute]
public HttpResponseMessage ScratchBufferPoolInfo();
}
public class Raven.Database.Server.Controllers.DocumentsBatchController : ClusterAwareRavenDbApiController {
    private static long numberOfConcurrentBulkPosts;
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DocumentsBatchController/<BulkPost>d__1")]
[RavenRouteAttribute("databases/{databaseName}/bulk_docs")]
[RavenRouteAttribute("bulk_docs")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> BulkPost();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DocumentsBatchController/<WaitForIndexesAsync>d__2")]
private Task WaitForIndexesAsync(string waitIndexes, Dictionary`2<int, Task> nextIndexingRoundsByIndexId, Index[] existingIndexes, BatchResult[] results);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DocumentsBatchController/<HandleDeletions>d__3")]
private Task HandleDeletions(HashSet`1<string> deletedIds, TimeSpan timeout, bool throwOnTimeout);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DocumentsBatchController/<WaitForReplicationAsync>d__4")]
private Task WaitForReplicationAsync(string writeAssurance, BatchResult lastResultWithEtag);
    [RavenRouteAttribute("databases/{databaseName}/bulk_docs/{*id}")]
[RavenRouteAttribute("bulk_docs/{*id}")]
[HttpDeleteAttribute]
public HttpResponseMessage BulkDelete(string id);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DocumentsBatchController/<BulkPatch>d__6")]
[RavenRouteAttribute("bulk_docs/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/bulk_docs/{*id}")]
[HttpPatchAttribute]
public Task`1<HttpResponseMessage> BulkPatch(string id);
    [RavenRouteAttribute("bulk_docs/{*id}")]
[HttpEvalAttribute]
[RavenRouteAttribute("databases/{databaseName}/bulk_docs/{*id}")]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DocumentsBatchController/<BulkEval>d__7")]
public Task`1<HttpResponseMessage> BulkEval(string id);
    private HttpResponseMessage OnBulkOperation(Func`5<string, IndexQuery, BulkOperationOptions, Action`1<BulkOperationProgress>, RavenJArray> batchOperation, string index, CancellationTimeout timeout);
}
public class Raven.Database.Server.Controllers.DocumentsController : ClusterAwareRavenDbApiController {
    [RavenRouteAttribute("databases/{databaseName}/docs")]
[RavenRouteAttribute("docs")]
[HttpGetAttribute]
public HttpResponseMessage DocsGet(string id);
    [RavenRouteAttribute("databases/{databaseName}/docs")]
[RavenRouteAttribute("docs")]
[HttpHeadAttribute]
public HttpResponseMessage DocsHead(string id);
    [RavenRouteAttribute("docs")]
[HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/docs")]
public HttpResponseMessage DocsGet();
    [RavenRouteAttribute("databases/{databaseName}/docs")]
[RavenRouteAttribute("docs")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DocumentsController/<DocsPost>d__3")]
public Task`1<HttpResponseMessage> DocsPost();
    [RavenRouteAttribute("databases/{databaseName}/docs/{*docId}")]
[RavenRouteAttribute("docs/{*docId}")]
[HttpHeadAttribute]
public HttpResponseMessage DocHead(string docId);
    [RavenRouteAttribute("docs/{*docId}")]
[HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/docs/{*docId}")]
public HttpResponseMessage DocGet(string docId);
    [RavenRouteAttribute("databases/{databaseName}/docs/{*docId}")]
[HttpDeleteAttribute]
[RavenRouteAttribute("docs/{*docId}")]
public HttpResponseMessage DocDelete(string docId);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DocumentsController/<DocPut>d__7")]
[RavenRouteAttribute("databases/{databaseName}/docs/{*docId}")]
[RavenRouteAttribute("docs/{*docId}")]
[HttpPutAttribute]
public Task`1<HttpResponseMessage> DocPut(string docId);
    [RavenRouteAttribute("docs/{*docId}")]
[HttpPatchAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DocumentsController/<DocPatch>d__8")]
[RavenRouteAttribute("databases/{databaseName}/docs/{*docId}")]
public Task`1<HttpResponseMessage> DocPatch(string docId);
    [HttpEvalAttribute]
[RavenRouteAttribute("docs/{*docId}")]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.DocumentsController/<DocEval>d__9")]
[RavenRouteAttribute("databases/{databaseName}/docs/{*docId}")]
public Task`1<HttpResponseMessage> DocEval(string docId);
    private HttpResponseMessage GetDocumentDirectly(string docId, HttpResponseMessage msg);
    private HttpResponseMessage ProcessPatchResult(string docId, PatchResult patchResult, object debug, RavenJObject document);
}
public class Raven.Database.Server.Controllers.FacetsController : ClusterAwareRavenDbApiController {
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.FacetsController/<FacetsGet>d__0")]
[HttpGetAttribute]
[RavenRouteAttribute("facets/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/facets/{*id}")]
public Task`1<HttpResponseMessage> FacetsGet(string id);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.FacetsController/<FacetsPost>d__1")]
[HttpPostAttribute]
[RavenRouteAttribute("facets/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/facets/{*id}")]
public Task`1<HttpResponseMessage> FacetsPost(string id);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.FacetsController/<MultiSearch>d__2")]
[RavenRouteAttribute("facets-multisearch")]
[RavenRouteAttribute("databases/{databaseName}/facets-multisearch")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> MultiSearch();
    private Task`1<HttpResponseMessage> ExecuteFacetsQuery(string index, List`1<Facet> facets, Etag indexEtag);
    private HttpResponseMessage TryGetFacetsFromString(string facetsJson, List`1& facets);
    private Etag GetFacetsEtag(string index, Byte[] additionalEtagBytes);
    private int GetFacetStart();
    private Nullable`1<int> GetFacetPageSize();
    [CompilerGeneratedAttribute]
private FacetResults <MultiSearch>b__2_0(FacetQuery facetedQuery);
}
public class Raven.Database.Server.Controllers.GeneratorsController : BaseDatabaseApiController {
    [RavenRouteAttribute("databases/{databaseName}/generate/code")]
[RavenRouteAttribute("generate/code")]
[HttpGetAttribute]
public HttpResponseMessage GenerateCodeFromDocument(string docId, string lang);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.HardRouteController : BaseDatabaseApiController {
    public static string RootPath;
    [HttpGetAttribute]
[RavenRouteAttribute("favicon.ico")]
public HttpResponseMessage FaviconGet();
    [RavenRouteAttribute("clientaccesspolicy.xml")]
[HttpGetAttribute]
public HttpResponseMessage ClientaccessPolicyGet();
    [HttpGetAttribute]
[RavenRouteAttribute("")]
public HttpResponseMessage RavenRoot();
}
public class Raven.Database.Server.Controllers.HttpTraceController : BaseDatabaseApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("traffic-watch/events")]
[RavenRouteAttribute("databases/{databaseName}/traffic-watch/events")]
public HttpResponseMessage HttpTrace();
}
public class Raven.Database.Server.Controllers.IdentityController : ClusterAwareRavenDbApiController {
    [HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/identity/next")]
[RavenRouteAttribute("identity/next")]
public HttpResponseMessage IdentityNextPost();
    [RavenRouteAttribute("databases/{databaseName}/identity/seed")]
[RavenRouteAttribute("identity/seed")]
[HttpPostAttribute]
public HttpResponseMessage IdentitySeed();
    [RavenRouteAttribute("databases/{databaseName}/identity/seed/bulk")]
[RavenRouteAttribute("identity/seed/bulk")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.IdentityController/<IdentitiesSeed>d__2")]
public Task`1<HttpResponseMessage> IdentitiesSeed();
}
public class Raven.Database.Server.Controllers.IndexController : ClusterAwareRavenDbApiController {
    private static Regex oldDateTimeFormat;
    private static IndexController();
    [HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/indexes")]
[RavenRouteAttribute("indexes")]
public HttpResponseMessage IndexesGet();
    [RavenRouteAttribute("databases/{databaseName}/indexes")]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.IndexController/<IndexMultiPut>d__1")]
[HttpPutAttribute]
[RavenRouteAttribute("indexes")]
public Task`1<HttpResponseMessage> IndexMultiPut();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.IndexController/<SideBySideIndexMultiPut>d__2")]
[HttpPutAttribute]
[RavenRouteAttribute("side-by-side-indexes")]
[RavenRouteAttribute("databases/{databaseName}/side-by-side-indexes")]
public Task`1<HttpResponseMessage> SideBySideIndexMultiPut();
    [HttpGetAttribute]
[RavenRouteAttribute("indexes/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/indexes/{*id}")]
public HttpResponseMessage IndexGet(string id);
    [RavenRouteAttribute("databases/{databaseName}/indexes/last-queried")]
[RavenRouteAttribute("indexes/last-queried")]
[HttpPostAttribute]
public HttpResponseMessage IndexUpdateLastQueried(Dictionary`2<string, DateTime> lastQueriedByIndexId);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.IndexController/<IndexPut>d__5")]
[RavenRouteAttribute("databases/{databaseName}/indexes/{*id}")]
[RavenRouteAttribute("indexes/{*id}")]
[HttpPutAttribute]
public Task`1<HttpResponseMessage> IndexPut(string id);
    [RavenRouteAttribute("databases/{databaseName}/indexes/{*id}")]
[RavenRouteAttribute("indexes/{*id}")]
[HttpHeadAttribute]
public HttpResponseMessage IndexHead(string id);
    [RavenRouteAttribute("databases/{databaseName}/indexes/{*id}")]
[RavenRouteAttribute("indexes/{*id}")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.IndexController/<IndexPost>d__7")]
public Task`1<HttpResponseMessage> IndexPost(string id);
    [RavenRouteAttribute("indexes/{*id}")]
[HttpResetAttribute]
[RavenRouteAttribute("databases/{databaseName}/indexes/{*id}")]
public HttpResponseMessage IndexReset(string id);
    [HttpDeleteAttribute]
[RavenRouteAttribute("indexes/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/indexes/{*id}")]
public HttpResponseMessage IndexDelete(string id);
    [RavenRouteAttribute("indexes-rename/{*id}")]
[HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/indexes-rename/{*id}")]
public HttpResponseMessage Rename(string id);
    [RavenRouteAttribute("indexes/set-priority/{*id}")]
[HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/indexes/set-priority/{*id}")]
public HttpResponseMessage SetPriority(string id);
    [HttpPostAttribute]
[RavenRouteAttribute("indexes-set-priority/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/indexes-set-priority/{*id}")]
public HttpResponseMessage SetPriorityConflicFixed(string id);
    private HttpResponseMessage SetPriorityInternal(string id);
    [HttpPatchAttribute]
[RavenRouteAttribute("indexes/try-recover-corrupted")]
[RavenRouteAttribute("databases/{databaseName}/indexes/try-recover-corrupted")]
public HttpResponseMessage TryRecoverCorruptedIndexes();
    [HttpGetAttribute]
[RavenRouteAttribute("c-sharp-index-definition/{*fullIndexName}")]
[RavenRouteAttribute("databases/{databaseName}/c-sharp-index-definition/{*fullIndexName}")]
public HttpResponseMessage GenerateCSharpIndexDefinition(string fullIndexName);
    private HttpResponseMessage GetIndexDefinition(string index);
    private HttpResponseMessage GetIndexSource(string index);
    private HttpResponseMessage DebugIndex(string index);
    private HttpResponseMessage GetDocsStartsWith(string index);
    private HttpResponseMessage GetIndexMappedResult(string index);
    private HttpResponseMessage GetExplanation(string index);
    private HttpResponseMessage GetIndexQueryResult(string index, CancellationToken token);
    private QueryResultWithIncludes ExecuteQuery(string index, Etag& indexEtag, HttpResponseMessage msg, CancellationToken token);
    private static void ReportQuery(StringBuilder sb, IndexQuery indexQuery, Stopwatch sp, QueryResultWithIncludes result);
    private QueryResultWithIncludes PerformQueryAgainstExistingIndex(string index, IndexQuery indexQuery, Etag& indexEtag, HttpResponseMessage msg, CancellationToken token);
    private QueryResultWithIncludes PerformQueryAgainstDynamicIndex(string index, IndexQuery indexQuery, Etag& indexEtag, HttpResponseMessage msg, CancellationToken token);
    private string GetDynamicIndexName(string index, IndexQuery indexQuery, String& entityName);
    private void RewriteDateQueriesFromOldClients(IndexQuery indexQuery);
    private HttpResponseMessage HandleIndexLockModeChange(string index);
    private HttpResponseMessage GetIndexReducedResult(string index);
    private HttpResponseMessage GetIndexScheduledReduces(string index);
    private HttpResponseMessage GetIndexKeysStats(string index);
    private HttpResponseMessage GetIndexEntries(string index);
    private HttpResponseMessage GetIndexEntriesForDynamicIndex(string index, IndexQuery indexQuery, List`1<string> reduceKeys, Reference`1<int> totalResults);
    private HttpResponseMessage GetIndexEntriesForExistingIndex(string index, IndexQuery indexQuery, List`1<string> reduceKeys, Reference`1<int> totalResults);
    private HttpResponseMessage GetIndexStats(string index);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.LicensingController : BaseDatabaseApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("license/status")]
public HttpResponseMessage LicenseStatusGet();
    [HttpGetAttribute]
[RavenRouteAttribute("license/support")]
public HttpResponseMessage SupportStatus();
}
[RavenRouteAttribute("logs/{action=logsget}")]
[RavenRouteAttribute("databases/{databaseName}/logs/{action=logsget}")]
[RavenRouteAttribute("logs/fs/{action=RavenFSLogsGet}")]
public class Raven.Database.Server.Controllers.LogsController : BaseDatabaseApiController {
    [HttpGetAttribute]
public HttpResponseMessage RavenFsLogsGet(string type);
    [HttpGetAttribute]
public HttpResponseMessage LogsGet();
}
public class Raven.Database.Server.Controllers.Method : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Name { get; public set; }
    public string Description { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
}
public class Raven.Database.Server.Controllers.MoreLikeThisController : ClusterAwareRavenDbApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("morelikethis/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/morelikethis/{*id}")]
public HttpResponseMessage MoreLikeThisGet();
    public static MoreLikeThisQuery GetParametersFromPath(string path, NameValueCollection query);
}
public class Raven.Database.Server.Controllers.MultiGetController : ClusterAwareRavenDbApiController {
    private static ThreadLocal`1<bool> recursive;
    private static MultiGetController();
    [HttpPostAttribute]
[RavenRouteAttribute("multi_get")]
[RavenRouteAttribute("databases/{databaseName}/multi_get")]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.MultiGetController/<MultiGet>d__1")]
public Task`1<HttpResponseMessage> MultiGet();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.MultiGetController/<ExecuteRequests>d__3")]
private Task ExecuteRequests(Tuple`2[] results, GetRequest[] requests);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.MultiGetController/<HandleRequestAsync>d__4")]
private Task HandleRequestAsync(GetRequest[] requests, Tuple`2[] results, int i);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.MultiGetController/<HandleActualRequestAsync>d__5")]
private Task`1<Tuple`2<HttpResponseMessage, List`1<Action`1<StringBuilder>>>> HandleActualRequestAsync(GetRequest request);
    private static bool TryExtractIndexQuery(string query, String& withoutIndexQuery, String& indexQuery);
}
public class Raven.Database.Server.Controllers.OAuthController : BaseDatabaseApiController {
    private static string TokenContentType;
    private static string TokenGrantType;
    private static int MaxOAuthContentLength;
    private static TimeSpan MaxChallengeAge;
    private static OAuthController();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.OAuthController/<ApiKeyPost>d__4")]
[HttpPostAttribute]
[RavenRouteAttribute("OAuth/API-Key")]
public Task`1<HttpResponseMessage> ApiKeyPost();
    public HttpResponseMessage RespondWithChallenge();
    private Tuple`2<string, AccessToken> GetApiKeySecret(string apiKeyName);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.OperationsController : BaseDatabaseApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("operation/status")]
[RavenRouteAttribute("databases/{databaseName}/operation/status")]
public HttpResponseMessage OperationStatusGet();
    [HttpGetAttribute]
[RavenRouteAttribute("operation/kill")]
[RavenRouteAttribute("databases/{databaseName}/operation/kill")]
public HttpResponseMessage OperationKill();
    [RavenRouteAttribute("databases/{databaseName}/operations")]
[HttpGetAttribute]
[RavenRouteAttribute("operations")]
public HttpResponseMessage CurrentOperations();
    [HttpGetAttribute]
[RavenRouteAttribute("operation/alerts")]
[RavenRouteAttribute("databases/{databaseName}/operation/alerts")]
public HttpResponseMessage Alerts();
    [RavenRouteAttribute("operation/alert/dismiss")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.OperationsController/<AlertDismiss>d__4")]
[RavenRouteAttribute("databases/{databaseName}/operation/alert/dismiss")]
public Task`1<HttpResponseMessage> AlertDismiss();
    private HttpResponseMessage GetOperationStatusMessage(IOperationState status);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.PluginController : BaseDatabaseApiController {
    [RavenRouteAttribute("plugins/status")]
[HttpGetAttribute]
public HttpResponseMessage PlugingsStatusGet();
}
public class Raven.Database.Server.Controllers.QueriesController : ClusterAwareRavenDbApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("queries")]
[RavenRouteAttribute("databases/{databaseName}/queries")]
public Task`1<HttpResponseMessage> QueriesGet();
    [RavenRouteAttribute("queries")]
[RavenRouteAttribute("databases/{databaseName}/queries")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> QueriesPost();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.QueriesController/<GetQueriesResponse>d__2")]
private Task`1<HttpResponseMessage> GetQueriesResponse(bool isGet);
}
public abstract class Raven.Database.Server.Controllers.RavenBaseApiController : ApiController {
    protected static ILog Log;
    private HttpRequestMessage request;
    [CompilerGeneratedAttribute]
private bool <SkipAuthorizationSinceThisIsMultiGetRequestAlreadyAuthorized>k__BackingField;
    [CompilerGeneratedAttribute]
private IPrincipal <User>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasAlreadyAuthorizedUsingSingleAuthToken>k__BackingField;
    private static ConcurrentDictionary`2<string, string> ZipLastChangedDate;
    private static string EmbeddedLastChangedDate;
    private int innerRequestsCount;
    [CompilerGeneratedAttribute]
private List`1<Action`1<StringBuilder>> <CustomRequestTraceInfo>k__BackingField;
    private DatabasesLandlord landlord;
    private CountersLandlord countersLandlord;
    private TimeSeriesLandlord timeSeriesLandlord;
    private FileSystemsLandlord fileSystemsLandlord;
    private RequestManager requestManager;
    private ClusterManager clusterManager;
    internal bool SkipAuthorizationSinceThisIsMultiGetRequestAlreadyAuthorized { get; internal set; }
    public HttpRequestMessage InnerRequest { get; }
    public bool IsInternalRequest { get; }
    public HttpHeaders InnerHeaders { get; }
    public IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> ReadInnerHeaders { get; }
    public IPrincipal User { get; public set; }
    public bool WasAlreadyAuthorizedUsingSingleAuthToken { get; public set; }
    public InMemoryRavenConfiguration ResourceConfiguration { get; }
    public InMemoryRavenConfiguration SystemConfiguration { get; }
    public string ResourcePrefix { get; }
    public string ResourceName { get; protected set; }
    public int InnerRequestsCount { get; }
    public List`1<Action`1<StringBuilder>> CustomRequestTraceInfo { get; private set; }
    public DatabasesLandlord DatabasesLandlord { get; }
    public CountersLandlord CountersLandlord { get; }
    public TimeSeriesLandlord TimeSeriesLandlord { get; }
    public FileSystemsLandlord FileSystemsLandlord { get; }
    public RequestManager RequestManager { get; }
    public ClusterManager ClusterManager { get; }
    private static RavenBaseApiController();
    [CompilerGeneratedAttribute]
internal bool get_SkipAuthorizationSinceThisIsMultiGetRequestAlreadyAuthorized();
    [CompilerGeneratedAttribute]
internal void set_SkipAuthorizationSinceThisIsMultiGetRequestAlreadyAuthorized(bool value);
    public sealed virtual HttpRequestMessage get_InnerRequest();
    public sealed virtual bool get_IsInternalRequest();
    public HttpHeaders get_InnerHeaders();
    public static HttpHeaders CloneRequestHttpHeaders(HttpRequestHeaders httpRequestHeaders, HttpContentHeaders httpContentHeaders);
    [IteratorStateMachineAttribute("Raven.Database.Server.Controllers.RavenBaseApiController/<get_ReadInnerHeaders>d__14")]
public IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> get_ReadInnerHeaders();
    [CompilerGeneratedAttribute]
public IPrincipal get_User();
    [CompilerGeneratedAttribute]
public void set_User(IPrincipal value);
    [CompilerGeneratedAttribute]
public bool get_WasAlreadyAuthorizedUsingSingleAuthToken();
    [CompilerGeneratedAttribute]
public void set_WasAlreadyAuthorizedUsingSingleAuthToken(bool value);
    protected bool IsClientV4OrHigher(HttpResponseMessage& message);
    protected virtual void InnerInitialization(HttpControllerContext controllerContext);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.RavenBaseApiController/<ReadJsonObjectAsync>d__25`1")]
public Task`1<T> ReadJsonObjectAsync();
    protected Guid ExtractOperationId();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.RavenBaseApiController/<ReadJsonAsync>d__27")]
protected Task`1<RavenJObject> ReadJsonAsync();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.RavenBaseApiController/<ReadJsonArrayAsync>d__28")]
protected Task`1<RavenJArray> ReadJsonArrayAsync();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.RavenBaseApiController/<ReadStringAsync>d__29")]
protected Task`1<string> ReadStringAsync();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.RavenBaseApiController/<ReadBsonArrayAsync>d__30")]
protected Task`1<RavenJArray> ReadBsonArrayAsync();
    private Encoding GetRequestEncoding();
    protected int GetStart();
    protected int GetNextPageStart();
    protected int GetPageSize(int maxPageSize);
    protected bool MatchEtag(Etag etag);
    private Etag EtagHeaderToEtag();
    public string GetQueryStringValue(string key);
    protected static string GetQueryStringValue(HttpRequestMessage req, string key);
    protected static bool ClientIsV3OrHigher(HttpRequestMessage req);
    protected static bool ClientIsV4OrHigher(HttpRequestMessage req);
    protected static String[] GetQueryStringValues(HttpRequestMessage req, string key);
    protected String[] GetQueryStringValues(string key);
    protected Etag GetEtagFromQueryString();
    protected void WriteETag(Etag etag, HttpResponseMessage msg);
    protected static void WriteETag(string etag, HttpResponseMessage msg);
    protected void WriteHeaders(RavenJObject headers, Etag etag, HttpResponseMessage msg);
    public void AddHeader(string key, string value, HttpResponseMessage msg);
    private string GetDateString(RavenJToken token, string format);
    private static string UnescapeStringIfNeeded(string str, bool shouldDecodeUrl, bool isQueryKey);
    public virtual HttpResponseMessage GetMessageWithObject(object item, HttpStatusCode code, Etag etag);
    public virtual HttpResponseMessage GetMessageWithString(string msg, HttpStatusCode code, Etag etag);
    public virtual HttpResponseMessage GetEmptyMessage(HttpStatusCode code, Etag etag);
    public virtual Task`1<HttpResponseMessage> GetMessageWithObjectAsTask(object item, HttpStatusCode code, Etag etag);
    public Task`1<HttpResponseMessage> GetMessageWithStringAsTask(string msg, HttpStatusCode code, Etag etag);
    public Task`1<HttpResponseMessage> GetEmptyMessageAsTask(HttpStatusCode code, Etag etag);
    public HttpResponseMessage WriteData(RavenJObject data, RavenJObject headers, Etag etag, HttpStatusCode status, HttpResponseMessage msg);
    public Etag GetEtag();
    public string GetHeader(string key);
    public List`1<string> GetHeaders(string key);
    public bool HasCookie(string key);
    public string GetCookie(string key);
    public HttpResponseMessage WriteEmbeddedFile(string ravenPath, string embeddedPath, string zipPath, string docPath);
    private HttpResponseMessage WriteFileFromZip(string zipPath, string docPath);
    public abstract virtual void MarkRequestDuration(long duration);
    public abstract virtual Task`1<RequestWebApiEventArgs> TrySetupRequestToProperResource();
    public abstract virtual InMemoryRavenConfiguration get_ResourceConfiguration();
    public HttpResponseMessage WriteFile(string filePath);
    private HttpResponseMessage WriteEmbeddedFileOfType(string embeddedPath, string docPath);
    private HttpResponseMessage EmbeddedFileNotFound(string docPath);
    private static string GetContentType(string docPath);
    public JsonContent JsonContent(RavenJToken data);
    public string GetRequestUrl();
    public abstract virtual InMemoryRavenConfiguration get_SystemConfiguration();
    protected void AddRavenHeader(HttpResponseMessage msg, Stopwatch sp);
    public abstract virtual string get_ResourcePrefix();
    public abstract virtual string get_ResourceName();
    protected abstract virtual void set_ResourceName(string value);
    public sealed virtual int get_InnerRequestsCount();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<Action`1<StringBuilder>> get_CustomRequestTraceInfo();
    [CompilerGeneratedAttribute]
private void set_CustomRequestTraceInfo(List`1<Action`1<StringBuilder>> value);
    protected void AddRequestTraceInfo(Action`1<StringBuilder> info);
    protected void IncrementInnerRequestsCount();
    protected static bool Match(string x, string y);
    public DatabasesLandlord get_DatabasesLandlord();
    public CountersLandlord get_CountersLandlord();
    public TimeSeriesLandlord get_TimeSeriesLandlord();
    public FileSystemsLandlord get_FileSystemsLandlord();
    public RequestManager get_RequestManager();
    public ClusterManager get_ClusterManager();
}
public class Raven.Database.Server.Controllers.RouteInfo : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Method> <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRunForSpecificDatabase>k__BackingField;
    public string Key { get; public set; }
    public List`1<Method> Methods { get; public set; }
    public bool CanRunForSpecificDatabase { get; public set; }
    public RouteInfo(string key);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public List`1<Method> get_Methods();
    [CompilerGeneratedAttribute]
public void set_Methods(List`1<Method> value);
    [CompilerGeneratedAttribute]
public bool get_CanRunForSpecificDatabase();
    [CompilerGeneratedAttribute]
public void set_CanRunForSpecificDatabase(bool value);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.SilverlightController : BaseDatabaseApiController {
    [RavenRouteAttribute("databases/{databaseName}/silverlight/ensureStartup")]
[HttpGetAttribute]
[RavenRouteAttribute("silverlight/ensureStartup")]
public HttpResponseMessage SilverlightEnsureStartup();
    [HttpGetAttribute]
[RavenRouteAttribute("silverlight/{*id}")]
public HttpResponseMessage SilverlightUi(string id);
    [IteratorStateMachineAttribute("Raven.Database.Server.Controllers.SilverlightController/<GetPaths>d__2")]
public static IEnumerable`1<string> GetPaths(string fileName, string webDir);
    [CompilerGeneratedAttribute]
private object <SilverlightUi>b__1_0(string s);
}
public class Raven.Database.Server.Controllers.SmugglerController : BaseDatabaseApiController {
    [HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/smuggler/export")]
[RavenRouteAttribute("smuggler/export")]
public HttpResponseMessage Export(ExportOptions options);
    private void StreamToClient(Stream stream, ExportOptions options, Lazy`1<NameValueCollection> headers, IPrincipal user);
    private static void WriteToStream(JsonWriter writer, RavenJObject item, CancellationTimeout timeout);
}
[ObsoleteAttribute("Use RavenFS instead.")]
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.StaticController : ClusterAwareRavenDbApiController {
    [RavenRouteAttribute("databases/{databaseName}/static/")]
[RavenRouteAttribute("static/")]
[HttpGetAttribute]
public HttpResponseMessage StaticGet();
    [RavenRouteAttribute("databases/{databaseName}/static/{*id}")]
[RavenRouteAttribute("static/{*id}")]
[HttpGetAttribute]
public HttpResponseMessage StaticGet(string id);
    [RavenRouteAttribute("databases/{databaseName}/static/{*id}")]
[HttpHeadAttribute]
[RavenRouteAttribute("static/{*id}")]
public HttpResponseMessage StaticHead(string id);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.StaticController/<StaticPut>d__3")]
[HttpPutAttribute]
[RavenRouteAttribute("static/{*filename}")]
[RavenRouteAttribute("databases/{databaseName}/static/{*filename}")]
public Task`1<HttpResponseMessage> StaticPut(string filename);
    [RavenRouteAttribute("databases/{databaseName}/static/{*id}")]
[RavenRouteAttribute("static/{*id}")]
[HttpPostAttribute]
public HttpResponseMessage StaticPost(string id);
    [RavenRouteAttribute("databases/{databaseName}/static/{*id}")]
[HttpDeleteAttribute]
[RavenRouteAttribute("static/{*id}")]
public HttpResponseMessage StaticDelete(string id);
}
[ObsoleteAttribute("Use RavenFS instead.")]
public class Raven.Database.Server.Controllers.StaticHeadContent : HttpContent {
    [CompilerGeneratedAttribute]
private int <AttachmentSize>k__BackingField;
    public int AttachmentSize { get; public set; }
    public StaticHeadContent(int size);
    [CompilerGeneratedAttribute]
public int get_AttachmentSize();
    [CompilerGeneratedAttribute]
public void set_AttachmentSize(int value);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
}
public class Raven.Database.Server.Controllers.StatisticsController : BaseDatabaseApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("stats")]
[RavenRouteAttribute("databases/{databaseName}/stats")]
public HttpResponseMessage Get();
    [RavenRouteAttribute("databases/{databaseName}/reduced-database-stats")]
[RavenRouteAttribute("reduced-database-stats")]
[HttpGetAttribute]
public HttpResponseMessage ReducedDatabaseStats();
    [RavenRouteAttribute("indexes-stats")]
[RavenRouteAttribute("databases/{databaseName}/indexes-stats")]
[HttpGetAttribute]
public HttpResponseMessage IndexesStats();
}
public class Raven.Database.Server.Controllers.StreamsController : ClusterAwareRavenDbApiController {
    [RavenRouteAttribute("databases/{databaseName}/streams/docs")]
[RavenRouteAttribute("streams/docs")]
[HttpHeadAttribute]
public HttpResponseMessage StreamDocsHead();
    [RavenRouteAttribute("databases/{databaseName}/streams/docs")]
[HttpGetAttribute]
[RavenRouteAttribute("streams/docs")]
public HttpResponseMessage StreamDocsGet();
    private void StreamToClient(Stream stream, string startsWith, int start, int pageSize, Etag etag, string matches, int nextPageStart, string skipAfter, string transformer, Dictionary`2<string, RavenJToken> transformerParameters, Lazy`1<NameValueCollection> headers, IPrincipal user);
    [HttpHeadAttribute]
[RavenRouteAttribute("streams/query/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/streams/query/{*id}")]
public HttpResponseMessage SteamQueryHead(string id);
    [RavenRouteAttribute("databases/{databaseName}/streams/query/{*id}")]
[RavenRouteAttribute("streams/query/{*id}")]
[HttpGetAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.StreamsController/<SteamQueryGet>d__4")]
public Task`1<HttpResponseMessage> SteamQueryGet(string id);
    [RavenRouteAttribute("streams/exploration")]
[RavenRouteAttribute("databases/{databaseName}/streams/exploration")]
[HttpGetAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.StreamsController/<Exploration>d__5")]
public Task`1<HttpResponseMessage> Exploration(string collection);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.StreamsController/<SteamQueryPost>d__6")]
[RavenRouteAttribute("databases/{databaseName}/streams/query/{*id}")]
[RavenRouteAttribute("streams/query/{*id}")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> SteamQueryPost(string id);
    private static IOutputWriter GetOutputWriter(HttpRequestMessage req, Stream stream);
    private static bool IsCsvDownloadRequest(HttpRequestMessage req);
}
[ExtensionAttribute]
internal static class Raven.Database.Server.Controllers.StringConverter : object {
    [ExtensionAttribute]
public static Nullable`1<int> ToNullableInt(string value);
    [ExtensionAttribute]
public static Nullable`1<bool> ToNullableBool(string value);
    [ExtensionAttribute]
public static Nullable`1<float> ToNullableFloat(string value);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.StudioController : BaseDatabaseApiController {
    private static String[] FieldsToTake;
    public static int DocPreviewMaxColumns;
    public static int DocPreviewColumnTextLimit;
    private static StudioController();
    [RavenRouteAttribute("raven")]
[HttpGetAttribute]
[RavenRouteAttribute("raven/{*id}")]
public HttpResponseMessage RavenUiGet(string id);
    [RavenRouteAttribute("studio/{*path}")]
[HttpGetAttribute]
[RavenRouteAttribute("studio")]
public HttpResponseMessage GetStudioFile(string path);
    [RavenRouteAttribute("databases/{databaseName}/doc-preview")]
[RavenRouteAttribute("doc-preview")]
[HttpGetAttribute]
public HttpResponseMessage GetDocumentsPreview(string collection);
    private List`1<RavenJObject> TrimContents(List`1<RavenJObject> input, BindingGroups bindingGroups);
    private List`1<string> SampleColumnNames(List`1<RavenJObject> input);
}
public class Raven.Database.Server.Controllers.StudioTasksController : BaseDatabaseApiController {
    [RavenRouteAttribute("databases/{databaseName}/studio-tasks/config")]
[RavenRouteAttribute("studio-tasks/config")]
[HttpGetAttribute]
public HttpResponseMessage StudioConfig();
    [RavenRouteAttribute("studio-tasks/server-configs")]
[HttpGetAttribute]
public HttpResponseMessage GerServerConfigs();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.StudioTasksController/<ValidateCustomFunctions>d__2")]
[HttpPostAttribute]
[RavenRouteAttribute("studio-tasks/validateCustomFunctions")]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/validateCustomFunctions")]
public Task`1<HttpResponseMessage> ValidateCustomFunctions();
    private void ValidateCustomFunctions(RavenJObject document);
    [HttpGetAttribute]
[RavenRouteAttribute("studio-tasks/check-sufficient-diskspace")]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/check-sufficient-diskspace")]
public HttpResponseMessage CheckSufficientDiskspaceBeforeImport(long fileSize);
    [HttpPostAttribute]
[RavenRouteAttribute("studio-tasks/import")]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/import")]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.StudioTasksController/<ImportDatabase>d__5")]
public Task`1<HttpResponseMessage> ImportDatabase(int batchSize, bool includeExpiredDocuments, bool stripReplicationInformation, bool shouldDisableVersioningBundle, ItemType operateOnTypes, string filtersPipeDelimited, string transformScript);
    [RavenRouteAttribute("databases/{databaseName}/studio-tasks/exportDatabase")]
[RavenRouteAttribute("studio-tasks/exportDatabase")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> ExportDatabase(ExportData smugglerOptionsJson);
    [HttpGetAttribute]
[RavenRouteAttribute("studio-tasks/next-operation-id")]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/next-operation-id")]
public HttpResponseMessage GetNextTaskId();
    [HttpPostAttribute]
[RavenRouteAttribute("studio-tasks/createSampleData")]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/createSampleData")]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.StudioTasksController/<CreateSampleData>d__8")]
public Task`1<HttpResponseMessage> CreateSampleData();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.StudioTasksController/<SimulateSqlReplication>d__9")]
[HttpPostAttribute]
[RavenRouteAttribute("studio-tasks/simulate-sql-replication")]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/simulate-sql-replication")]
public Task`1<HttpResponseMessage> SimulateSqlReplication();
    [RavenRouteAttribute("studio-tasks/test-sql-replication-connection")]
[HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/test-sql-replication-connection")]
public Task`1<HttpResponseMessage> TestSqlReplicationConnection(string factoryName, string connectionString);
    [HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/sql-replication-toggle-disable")]
[RavenRouteAttribute("studio-tasks/sql-replication-toggle-disable")]
public Task`1<HttpResponseMessage> SqlReplicationToggleDisable(bool disable);
    [HttpGetAttribute]
[RavenRouteAttribute("studio-tasks/createSampleDataClass")]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/createSampleDataClass")]
public Task`1<HttpResponseMessage> CreateSampleDataClass();
    [HttpGetAttribute]
[RavenRouteAttribute("studio-tasks/get-sql-replication-stats")]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/get-sql-replication-stats")]
public HttpResponseMessage GetSQLReplicationStats(string sqlReplicationName);
    [HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/reset-sql-replication")]
[RavenRouteAttribute("studio-tasks/reset-sql-replication")]
public Task`1<HttpResponseMessage> ResetSqlReplication(string sqlReplicationName);
    [RavenRouteAttribute("studio-tasks/latest-server-build-version")]
[HttpGetAttribute]
public HttpResponseMessage GetLatestServerBuildVersion(bool stableOnly, int min, int max);
    [RavenRouteAttribute("studio-tasks/new-encryption-key")]
[HttpGetAttribute]
public HttpResponseMessage GetNewEncryption(string path);
    [HttpPostAttribute]
[RavenRouteAttribute("studio-tasks/is-base-64-key")]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.StudioTasksController/<IsBase64Key>d__17")]
public Task`1<HttpResponseMessage> IsBase64Key(string path);
    private Task FlushBatch(IEnumerable`1<RavenJObject> batch);
    [RavenRouteAttribute("studio-tasks/resolveMerge")]
[HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/resolveMerge")]
public Task`1<HttpResponseMessage> ResolveMerge(string documentId);
    [RavenRouteAttribute("databases/{databaseName}/studio-tasks/loadCsvFile")]
[RavenRouteAttribute("studio-tasks/loadCsvFile")]
[HttpPostAttribute]
[AsyncStateMachineAttribute("Raven.Database.Server.Controllers.StudioTasksController/<LoadCsvFile>d__20")]
public Task`1<HttpResponseMessage> LoadCsvFile();
    private static void SetValueInDocumentForColumn(RavenJObject document, string column, string value);
    [RavenRouteAttribute("databases/{databaseName}/studio-tasks/collection/counts")]
[RavenRouteAttribute("studio-tasks/collection/counts")]
[HttpGetAttribute]
public Task`1<HttpResponseMessage> CollectionCount();
    [RavenRouteAttribute("studio-tasks/replication/conflicts/resolve")]
[HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/replication/conflicts/resolve")]
public Task`1<HttpResponseMessage> ResolveAllConflicts();
    private static JsonDocument GetDocumentToSave(StraightforwardConflictResolution resolution, KeyValuePair`2<JsonDocument, DateTime> local, KeyValuePair`2<JsonDocument, DateTime> remote);
    [HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/studio-tasks/validateExportOptions")]
[RavenRouteAttribute("studio-tasks/validateExportOptions")]
public HttpResponseMessage ValidateExportOptions(SmugglerDatabaseOptions smugglerOptions);
    private static RavenJToken ParseToken(string value);
}
public class Raven.Database.Server.Controllers.SubscriptionsController : BaseDatabaseApiController {
    private static ILog log;
    private static SubscriptionsController();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.SubscriptionsController/<Create>d__1")]
[HttpPostAttribute]
[RavenRouteAttribute("subscriptions/create")]
[RavenRouteAttribute("databases/{databaseName}/subscriptions/create")]
public Task`1<HttpResponseMessage> Create();
    [HttpDeleteAttribute]
[RavenRouteAttribute("subscriptions")]
[RavenRouteAttribute("databases/{databaseName}/subscriptions")]
public HttpResponseMessage Delete(long id);
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.SubscriptionsController/<Open>d__3")]
[HttpPostAttribute]
[RavenRouteAttribute("subscriptions/open")]
[RavenRouteAttribute("databases/{databaseName}/subscriptions/open")]
public Task`1<HttpResponseMessage> Open(long id);
    [HttpGetAttribute]
[RavenRouteAttribute("subscriptions/pull")]
[RavenRouteAttribute("databases/{databaseName}/subscriptions/pull")]
public HttpResponseMessage Pull(long id, string connection);
    [RavenRouteAttribute("databases/{databaseName}/subscriptions/acknowledgeBatch")]
[RavenRouteAttribute("subscriptions/acknowledgeBatch")]
[HttpPostAttribute]
public HttpResponseMessage AcknowledgeBatch(long id, string lastEtag, string connection);
    [HttpPostAttribute]
[RavenRouteAttribute("subscriptions/close")]
[RavenRouteAttribute("databases/{databaseName}/subscriptions/close")]
public HttpResponseMessage Close(long id, string connection, bool force);
    [RavenRouteAttribute("subscriptions/client-alive")]
[RavenRouteAttribute("databases/{databaseName}/subscriptions/client-alive")]
[HttpPatchAttribute]
public HttpResponseMessage ClientAlive(long id, string connection);
    [RavenRouteAttribute("subscriptions/setSubscriptionAckEtag")]
[HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/subscriptions/setSubscriptionAckEtag")]
public HttpResponseMessage SetSubscriptionAckEtag();
    [HttpGetAttribute]
[RavenRouteAttribute("subscriptions")]
[RavenRouteAttribute("databases/{databaseName}/subscriptions")]
public HttpResponseMessage Get();
    private void StreamToClient(long id, SubscriptionActions subscriptions, Stream stream);
    private static bool MatchCriteria(SubscriptionCriteria criteria, JsonDocument doc);
}
public class Raven.Database.Server.Controllers.SuggestionController : ClusterAwareRavenDbApiController {
    [RavenRouteAttribute("suggest/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/suggest/{*id}")]
[HttpGetAttribute]
public HttpResponseMessage SuggestGet(string id);
}
public class Raven.Database.Server.Controllers.TermsController : ClusterAwareRavenDbApiController {
    [RavenRouteAttribute("databases/{databaseName}/terms/{*id}")]
[RavenRouteAttribute("terms/{*id}")]
[HttpGetAttribute]
public HttpResponseMessage TermsGet(string id);
}
[RoutePrefixAttribute("")]
public class Raven.Database.Server.Controllers.TransactionController : BaseDatabaseApiController {
    [RavenRouteAttribute("transaction/rollback")]
[HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/transaction/rollback")]
public HttpResponseMessage Rollback();
    [HttpGetAttribute]
[RavenRouteAttribute("transaction/status")]
[RavenRouteAttribute("databases/{databaseName}/transaction/status")]
public HttpResponseMessage Status();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.TransactionController/<Prepare>d__2")]
[HttpPostAttribute]
[RavenRouteAttribute("transaction/prepare")]
[RavenRouteAttribute("databases/{databaseName}/transaction/prepare")]
public Task`1<HttpResponseMessage> Prepare();
    [HttpPostAttribute]
[RavenRouteAttribute("databases/{databaseName}/transaction/commit")]
[RavenRouteAttribute("transaction/commit")]
public HttpResponseMessage Commit();
}
public class Raven.Database.Server.Controllers.TransformersController : ClusterAwareRavenDbApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("databases/{databaseName}/transformers/{*id}")]
[RavenRouteAttribute("transformers/{*id}")]
public HttpResponseMessage TransformerGet(string id);
    [RavenRouteAttribute("databases/{databaseName}/transformers")]
[RavenRouteAttribute("transformers")]
[HttpGetAttribute]
public HttpResponseMessage TransformerGet();
    [AsyncStateMachineAttribute("Raven.Database.Server.Controllers.TransformersController/<TransformersPut>d__2")]
[HttpPutAttribute]
[RavenRouteAttribute("transformers/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/transformers/{*id}")]
public Task`1<HttpResponseMessage> TransformersPut(string id);
    [HttpPostAttribute]
[RavenRouteAttribute("transformers/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/transformers/{*id}")]
public Task`1<HttpResponseMessage> TransformersPost(string id);
    [HttpDeleteAttribute]
[RavenRouteAttribute("transformers/{*id}")]
[RavenRouteAttribute("databases/{databaseName}/transformers/{*id}")]
public HttpResponseMessage TransformersDelete(string id);
}
public static class Raven.Database.Server.CurrentOperationContext : object {
    public static ThreadLocal`1<List`1<IDisposable>> RequestDisposables;
    public static ThreadLocal`1<IPrincipal> User;
    public static ThreadLocal`1<Lazy`1<NameValueCollection>> Headers;
    private static CurrentOperationContext();
}
public static class Raven.Database.Server.HttpEndpointRegistration : object {
    public static void RegisterHttpEndpointTarget();
    public static void RegisterAdminLogsTarget();
}
public enum Raven.Database.Server.IgnoreSslCertificateErrorsMode : Enum {
    public int value__;
    public static IgnoreSslCertificateErrorsMode None;
    public static IgnoreSslCertificateErrorsMode All;
}
public static class Raven.Database.Server.NonAdminHttp : object {
    public static void EnsureCanListenToWhenInNonAdminContext(int port, bool useSsl);
    public static void UnbindCertificate(int port, X509Certificate2 certificate);
    public static void BindCertificate(int port, X509Certificate2 certificate);
    private static void UnbindCertificates(int port, string certificateThumbprint);
    private static void BindCertificate(int port, string certificateThumbprint);
    private static void GetArgsForHttpSslCertAddCmd(int port, string certificateThumbprint, Guid applicationId, String& args, String& cmd);
    private static void GetArgsForHttpSslCertDeleteCmd(int port, string certificateThumbprint, String& args, String& cmd);
    private static void GetArgsForHttpAclAddCmd(int port, bool useSsl, String& args, String& cmd);
    private static void GetArgsForHttpAclDeleteCmd(int port, bool useSsl, String& args, String& cmd);
    private static bool CanStartHttpListener(int port, bool useSsl, Int32& errorCode, HttpListenerException& listenerException);
    internal static int TryUnregisterHttpPort(int port, bool useSsl, bool hideWindow);
    private static int TryGrantingHttpPrivileges(int port, bool useSsl);
    private static int RunAs(string cmd, string args, int errorCode, bool hideWindow);
}
public class Raven.Database.Server.OwinHttpServer : object {
    private IDisposable server;
    private Startup startup;
    private static Byte[] NotFoundBody;
    private OwinEmbeddedHost owinEmbeddedHost;
    public RavenDBOptions Options { get; }
    public OwinHttpServer(InMemoryRavenConfiguration config, DocumentDatabase db, bool useHttpServer, Action`1<RavenDBOptions> configure);
    private static OwinHttpServer();
    public void EnableHttpServer(InMemoryRavenConfiguration config);
    public void DisableHttpServer();
    public Task Invoke(IDictionary`2<string, object> environment);
    public RavenDBOptions get_Options();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(IAppBuilder app);
}
public class Raven.Database.Server.RavenDBOptions : object {
    private static ILog log;
    private DatabasesLandlord databasesLandlord;
    private MixedModeRequestAuthorizer mixedModeRequestAuthorizer;
    private DocumentDatabase systemDatabase;
    private RequestManager requestManager;
    private FileSystemsLandlord fileSystemLandlord;
    private CountersLandlord countersLandlord;
    private TimeSeriesLandlord timeSeriesLandlord;
    private IList`1<IDisposable> toDispose;
    private IEnumerable`1<IServerStartupTask> serverStartupTasks;
    private bool preventDisposing;
    [CompilerGeneratedAttribute]
private Reference`1<ClusterManager> <ClusterManager>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    public IEnumerable`1<IServerStartupTask> ServerStartupTasks { get; }
    public DocumentDatabase SystemDatabase { get; }
    public MixedModeRequestAuthorizer MixedModeRequestAuthorizer { get; }
    public DatabasesLandlord DatabaseLandlord { get; }
    public FileSystemsLandlord FileSystemLandlord { get; }
    public CountersLandlord CountersLandlord { get; }
    public TimeSeriesLandlord TimeSeriesLandlord { get; }
    public RequestManager RequestManager { get; }
    public Reference`1<ClusterManager> ClusterManager { get; private set; }
    public bool Disposed { get; private set; }
    public RavenDBOptions(InMemoryRavenConfiguration configuration, DocumentDatabase db);
    private static RavenDBOptions();
    public IEnumerable`1<IServerStartupTask> get_ServerStartupTasks();
    public DocumentDatabase get_SystemDatabase();
    public MixedModeRequestAuthorizer get_MixedModeRequestAuthorizer();
    public DatabasesLandlord get_DatabaseLandlord();
    public FileSystemsLandlord get_FileSystemLandlord();
    public CountersLandlord get_CountersLandlord();
    public TimeSeriesLandlord get_TimeSeriesLandlord();
    public RequestManager get_RequestManager();
    [CompilerGeneratedAttribute]
public Reference`1<ClusterManager> get_ClusterManager();
    [CompilerGeneratedAttribute]
private void set_ClusterManager(Reference`1<ClusterManager> value);
    [CompilerGeneratedAttribute]
public bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    public sealed virtual void Dispose();
    public IDisposable PreventDispose();
    private static void SetMaxInstances(InMemoryRavenConfiguration configuration);
    [CompilerGeneratedAttribute]
private void <PreventDispose>b__37_0();
}
public class Raven.Database.Server.RequestWebApiEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenBaseApiController <Controller>k__BackingField;
    [CompilerGeneratedAttribute]
private IResourceStore <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceType <ResourceType>k__BackingField;
    public string TenantId { get; public set; }
    public bool IgnoreRequest { get; public set; }
    public RavenBaseApiController Controller { get; public set; }
    public IResourceStore Resource { get; public set; }
    public ResourceType ResourceType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreRequest();
    [CompilerGeneratedAttribute]
public void set_IgnoreRequest(bool value);
    [CompilerGeneratedAttribute]
public RavenBaseApiController get_Controller();
    [CompilerGeneratedAttribute]
public void set_Controller(RavenBaseApiController value);
    [CompilerGeneratedAttribute]
public IResourceStore get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(IResourceStore value);
    [CompilerGeneratedAttribute]
public ResourceType get_ResourceType();
    [CompilerGeneratedAttribute]
public void set_ResourceType(ResourceType value);
}
public abstract class Raven.Database.Server.Security.AbstractRequestAuthorizer : object {
    [CLSCompliantAttribute("False")]
protected InMemoryRavenConfiguration settings;
    [CLSCompliantAttribute("False")]
protected DocumentDatabase database;
    [CLSCompliantAttribute("False")]
protected IRavenServer server;
    [CLSCompliantAttribute("False")]
protected Func`1<string> tenantId;
    public DocumentDatabase Database { get; }
    public InMemoryRavenConfiguration Settings { get; }
    public string TenantId { get; }
    public DocumentDatabase get_Database();
    public InMemoryRavenConfiguration get_Settings();
    public string get_TenantId();
    public void Initialize(DocumentDatabase database, InMemoryRavenConfiguration settings, Func`1<string> tenantIdGetter, IRavenServer theServer);
    public void Initialize(DocumentDatabase database, IRavenServer theServer);
    protected virtual void Initialize();
    public static bool IsGetRequest(RavenBaseApiController controller);
    public abstract virtual void Dispose();
    public static bool IsGetRequest(HttpListenerRequest request);
}
public static class Raven.Database.Server.Security.AccountVerifier : object {
    public static bool UserExists(string domainAndUserName);
    public static bool GroupExists(string domainAndGroupName);
    private static PrincipalContext GetPrincipalContext(string domain);
    private static String[] SplitDomain(string input);
}
public static class Raven.Database.Server.Security.Authentication : object {
    private static Nullable`1<DateTime> licenseEnabled;
    public static bool IsLicensedForRavenFs { get; }
    public static bool IsLicensedForCounters { get; }
    public static bool IsLicensedForTimeSeries { get; }
    public static bool IsEnabled { get; }
    public static void Disable();
    public static void EnableOnce();
    public static bool get_IsLicensedForRavenFs();
    public static bool get_IsLicensedForCounters();
    public static bool get_IsLicensedForTimeSeries();
    public static bool get_IsEnabled();
    public static void AssertLicensedBundles(IEnumerable`1<string> activeBundles);
}
public class Raven.Database.Server.Security.AuthenticationForCommercialUseOnly : object {
    private static string LicensingListName;
    private static string ValidationMarkerName;
    public sealed virtual void Execute(DocumentDatabase database);
    private ListItem GetLastSeenValidCommercialLicenseMarker(DocumentDatabase database);
    private void SetValidCommercialLicenseMarker(DocumentDatabase database);
}
public class Raven.Database.Server.Security.IgnoreDb : object {
    public static HashSet`1<string> Urls;
    private static IgnoreDb();
}
public class Raven.Database.Server.Security.MixedModeRequestAuthorizer : AbstractRequestAuthorizer {
    private WindowsRequestAuthorizer windowsRequestAuthorizer;
    private OAuthRequestAuthorizer oAuthRequestAuthorizer;
    private ConcurrentDictionary`2<string, OneTimeToken> singleUseAuthTokens;
    protected virtual void Initialize();
    public bool TryAuthorize(RavenBaseApiController controller, HttpResponseMessage& msg);
    public bool TryAuthorizeSingleUseAuthToken(string token, string tenantName, Object& msg, HttpStatusCode& statusCode, IPrincipal& user);
    private bool TryAuthorizeSingleUseAuthToken(RavenBaseApiController controller, string token, HttpResponseMessage& msg);
    public IPrincipal GetUser(RavenBaseApiController controller);
    public List`1<string> GetApprovedResources(IPrincipal user, BaseDatabaseApiController controller, String[] databases);
    public List`1<string> GetApprovedResources(IPrincipal user, string authHeader, String[] databases);
    public virtual void Dispose();
    public string GenerateSingleUseAuthToken(string resourceName, IPrincipal user);
}
public class Raven.Database.Server.Security.NeverSecret : object {
    public static HashSet`1<string> Urls;
    private static NeverSecret();
    public static bool IsNeverSecretUrl(string requestUrl);
    private static bool IsHtml5StudioUrl(string requestUrl);
}
public class Raven.Database.Server.Security.OAuth.AccessToken : object {
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    public string Body { get; public set; }
    public string Signature { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(string value);
    [CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(string value);
    private bool MatchesSignature(Byte[] key);
    public static bool TryParseBody(Byte[] key, string token, AccessTokenBody& body);
    private static bool TryParse(string token, AccessToken& accessToken);
    public static AccessToken Create(Byte[] key, AccessTokenBody tokenBody);
    public static string Sign(string body, Byte[] key);
    public string Serialize();
}
public class Raven.Database.Server.Security.OAuth.OAuthRequestAuthorizer : AbstractRequestAuthorizer {
    public bool TryAuthorize(RavenBaseApiController controller, bool hasApiKey, bool ignoreDbAccess, HttpResponseMessage& msg);
    public List`1<string> GetApprovedResources(IPrincipal user);
    public virtual void Dispose();
    private static string GetToken(RavenBaseApiController controller);
    private HttpResponseMessage WriteAuthorizationChallenge(RavenBaseApiController controller, int statusCode, string error, string errorDescription);
    public IPrincipal GetUser(RavenBaseApiController controller, bool hasApiKey);
}
internal static class Raven.Database.Server.Security.OAuth.OAuthServerHelper : object {
    private static int RsaKeySize;
    private static ThreadLocal`1<RNGCryptoServiceProvider> rng;
    private static ThreadLocal`1<IAsymmetricalEncryptor> rsa;
    private static ThreadLocal`1<ISymmetricalEncryptor> aes;
    private static string rsaExponent;
    private static string rsaModulus;
    public static string RSAExponent { get; }
    public static string RSAModulus { get; }
    private static OAuthServerHelper();
    public static string get_RSAExponent();
    public static string get_RSAModulus();
    public static Byte[] RandomBytes(int count);
    public static string EncryptSymmetric(string data);
    public static string DecryptSymmetric(string data);
    public static string DecryptAsymmetric(string data);
    public static Nullable`1<DateTime> ParseDateTime(string data);
    public static string DateTimeToString(DateTime data);
}
public class Raven.Database.Server.Security.OneTimeTokenPrincipal : object {
    [CompilerGeneratedAttribute]
private bool <IsAdministratorInAnonymouseMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool IsAdministratorInAnonymouseMode { get; public set; }
    public IIdentity Identity { get; }
    public string Name { get; public set; }
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public sealed virtual bool IsInRole(string role);
    [CompilerGeneratedAttribute]
public bool get_IsAdministratorInAnonymouseMode();
    [CompilerGeneratedAttribute]
public void set_IsAdministratorInAnonymouseMode(bool value);
    public sealed virtual IIdentity get_Identity();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool get_IsAuthenticated();
}
public class Raven.Database.Server.Security.Triggers.OAuthPutTrigger : AbstractPutTrigger {
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
}
internal class Raven.Database.Server.Security.Triggers.WindowsAuthDeleteTrigger : AbstractDeleteTrigger {
    public virtual void AfterDelete(string key, TransactionInformation transactionInformation, RavenJObject metadata);
}
internal class Raven.Database.Server.Security.Triggers.WindowsAuthPutTrigger : AbstractPutTrigger {
    public virtual VetoResult AllowPut(string key, RavenJObject document, RavenJObject metadata, TransactionInformation transactionInformation);
    public virtual void AfterPut(string key, RavenJObject document, RavenJObject metadata, Etag etag, TransactionInformation transactionInformation);
}
public class Raven.Database.Server.Security.Windows.WindowsAuthConfigureHttpListener : object {
    public static Regex IsAdminRequest;
    private InMemoryRavenConfiguration configuration;
    private static WindowsAuthConfigureHttpListener();
    public void Configure(HttpListener listener, InMemoryRavenConfiguration config);
    private AuthenticationSchemes AuthenticationSchemeSelectorDelegate(HttpListenerRequest request);
}
public class Raven.Database.Server.Security.Windows.WindowsAuthData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ResourceAccess> <Databases>k__BackingField;
    public string Name { get; public set; }
    public bool Enabled { get; public set; }
    public List`1<ResourceAccess> Databases { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public List`1<ResourceAccess> get_Databases();
    [CompilerGeneratedAttribute]
public void set_Databases(List`1<ResourceAccess> value);
    protected bool Equals(WindowsAuthData other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Raven.Database.Server.Security.Windows.WindowsAuthDocument : object {
    [CompilerGeneratedAttribute]
private List`1<WindowsAuthData> <RequiredGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<WindowsAuthData> <RequiredUsers>k__BackingField;
    public List`1<WindowsAuthData> RequiredGroups { get; public set; }
    public List`1<WindowsAuthData> RequiredUsers { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<WindowsAuthData> get_RequiredGroups();
    [CompilerGeneratedAttribute]
public void set_RequiredGroups(List`1<WindowsAuthData> value);
    [CompilerGeneratedAttribute]
public List`1<WindowsAuthData> get_RequiredUsers();
    [CompilerGeneratedAttribute]
public void set_RequiredUsers(List`1<WindowsAuthData> value);
}
public class Raven.Database.Server.Security.Windows.WindowsRequestAuthorizer : AbstractRequestAuthorizer {
    private List`1<WindowsAuthData> requiredGroups;
    private List`1<WindowsAuthData> requiredUsers;
    [CompilerGeneratedAttribute]
private static Action WindowsSettingsChanged;
    private static WindowsRequestAuthorizer();
    [CompilerGeneratedAttribute]
private static void add_WindowsSettingsChanged(Action value);
    [CompilerGeneratedAttribute]
private static void remove_WindowsSettingsChanged(Action value);
    public static void InvokeWindowsSettingsChanged();
    protected virtual void Initialize();
    public void UpdateSettings();
    public bool TryAuthorize(RavenBaseApiController controller, bool ignoreDb, HttpResponseMessage& msg);
    private bool TryCreateUser(RavenBaseApiController controller, string databaseName, Func`1& onRejectingRequest);
    private static HttpResponseMessage ProvideDebugAuthInfo(RavenBaseApiController controller, object msg);
    private PrincipalWithDatabaseAccess UpdateUserPrincipal(RavenBaseApiController controller, List`1<ResourceAccess> databaseAccessLists);
    public List`1<string> GetApprovedResources(IPrincipal user);
    public virtual void Dispose();
    public IPrincipal GetUser(RavenBaseApiController controller);
}
internal class Raven.Database.Server.Startup : object {
    private RavenDBOptions options;
    public RavenDBOptions Options { get; }
    public Startup(InMemoryRavenConfiguration config, DocumentDatabase db);
    public RavenDBOptions get_Options();
    public void Configuration(IAppBuilder app);
}
public abstract class Raven.Database.Server.Tenancy.AbstractLandlord`1 : object {
    protected static string DisposingLock;
    protected SemaphoreSlim ResourceSemaphore;
    protected static ILog Logger;
    protected ConcurrentSet`1<string> Locks;
    protected ConcurrentDictionary`2<string, ManualResetEvent> Cleanups;
    public AtomicDictionary`1<Task`1<TResource>> ResourcesStoresCache;
    [CompilerGeneratedAttribute]
private Action`1<string> CleanupOccured;
    protected ConcurrentDictionary`2<string, TransportState> ResourseTransportStates;
    protected InMemoryRavenConfiguration systemConfiguration;
    protected DocumentDatabase systemDatabase;
    protected TimeSpan ConcurrentResourceLoadTimeout;
    private ConcurrentDictionary`2<string, DateTime> _lastRecentlyUsed;
    public string ResourcePrefix { get; }
    public int MaxSecondsForTaskToWaitForDatabaseToLoad { get; }
    public ConcurrentDictionary`2<string, DateTime> LastRecentlyUsed { get; }
    protected AbstractLandlord`1(DocumentDatabase systemDatabase);
    private static AbstractLandlord`1();
    [CompilerGeneratedAttribute]
public void add_CleanupOccured(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_CleanupOccured(Action`1<string> value);
    public abstract virtual string get_ResourcePrefix();
    public int get_MaxSecondsForTaskToWaitForDatabaseToLoad();
    public void Unprotect(DatabaseDocument databaseDocument);
    public void Cleanup(string resource, Nullable`1<TimeSpan> skipIfActiveInDuration, Func`2<TResource, bool> shouldSkip, DocumentChangeTypes notificationType);
    protected abstract virtual DateTime LastWork(TResource resource);
    public void Lock(string tenantId, Action actionToTake);
    public sealed virtual void Dispose();
    public abstract virtual Task`1<TResource> GetResourceInternal(string resourceName);
    public abstract virtual bool TryGetOrCreateResourceStore(string resourceName, Task`1& resourceTask);
    public sealed virtual ConcurrentDictionary`2<string, DateTime> get_LastRecentlyUsed();
    public sealed virtual InMemoryRavenConfiguration GetSystemConfiguration();
}
public class Raven.Database.Server.Tenancy.CountersLandlord : AbstractLandlord`1<CounterStorage> {
    private bool initialized;
    [CompilerGeneratedAttribute]
private Action`1<InMemoryRavenConfiguration> SetupTenantConfiguration;
    public string ResourcePrefix { get; }
    public InMemoryRavenConfiguration SystemConfiguration { get; }
    public CountersLandlord(DocumentDatabase systemDatabase);
    public virtual string get_ResourcePrefix();
    [CompilerGeneratedAttribute]
public void add_SetupTenantConfiguration(Action`1<InMemoryRavenConfiguration> value);
    [CompilerGeneratedAttribute]
public void remove_SetupTenantConfiguration(Action`1<InMemoryRavenConfiguration> value);
    public InMemoryRavenConfiguration get_SystemConfiguration();
    public void Init();
    public InMemoryRavenConfiguration CreateTenantConfiguration(string tenantId, bool ignoreDisabledCounterStorage);
    protected InMemoryRavenConfiguration CreateConfiguration(string tenantId, CounterStorageDocument document, string folderPropName, InMemoryRavenConfiguration parentConfiguration);
    private CounterStorageDocument GetTenantDatabaseDocument(string tenantId, bool ignoreDisabledCounterStorage);
    [AsyncStateMachineAttribute("Raven.Database.Server.Tenancy.CountersLandlord/<GetResourceInternal>d__13")]
public virtual Task`1<CounterStorage> GetResourceInternal(string resourceName);
    public virtual bool TryGetOrCreateResourceStore(string tenantId, Task`1& counter);
    public void Unprotect(CounterStorageDocument configDocument);
    public void Protect(CounterStorageDocument configDocument);
    private void AssertLicenseParameters(InMemoryRavenConfiguration config);
    public void ForAllCountersInCacheOnly(Action`1<CounterStorage> action);
    public void ForAllCounters(Action`1<CounterStorage> action);
    private static string GetCounterIdFromDocumentKey(RavenJToken doc);
    protected virtual DateTime LastWork(CounterStorage resource);
    [CompilerGeneratedAttribute]
private void <Init>b__9_0(DocumentDatabase database, DocumentChangeNotification notification, RavenJObject doc);
}
public class Raven.Database.Server.Tenancy.DatabasesLandlord : AbstractLandlord`1<DocumentDatabase> {
    [CompilerGeneratedAttribute]
private Action`1<InMemoryRavenConfiguration> SetupTenantConfiguration;
    [CompilerGeneratedAttribute]
private Action`1<string> OnDatabaseLoaded;
    private bool initialized;
    private static string DATABASES_PREFIX;
    [CompilerGeneratedAttribute]
private int <MaxIdleTimeForTenantDatabaseInSec>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FrequencyToCheckForIdleDatabasesInSec>k__BackingField;
    public string ResourcePrefix { get; }
    public int MaxIdleTimeForTenantDatabaseInSec { get; private set; }
    public int FrequencyToCheckForIdleDatabasesInSec { get; private set; }
    public DocumentDatabase SystemDatabase { get; }
    public InMemoryRavenConfiguration SystemConfiguration { get; }
    public DatabasesLandlord(DocumentDatabase systemDatabase);
    [CompilerGeneratedAttribute]
public void add_SetupTenantConfiguration(Action`1<InMemoryRavenConfiguration> value);
    [CompilerGeneratedAttribute]
public void remove_SetupTenantConfiguration(Action`1<InMemoryRavenConfiguration> value);
    [CompilerGeneratedAttribute]
public void add_OnDatabaseLoaded(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_OnDatabaseLoaded(Action`1<string> value);
    public virtual string get_ResourcePrefix();
    [CompilerGeneratedAttribute]
public int get_MaxIdleTimeForTenantDatabaseInSec();
    [CompilerGeneratedAttribute]
private void set_MaxIdleTimeForTenantDatabaseInSec(int value);
    [CompilerGeneratedAttribute]
public int get_FrequencyToCheckForIdleDatabasesInSec();
    [CompilerGeneratedAttribute]
private void set_FrequencyToCheckForIdleDatabasesInSec(int value);
    public DocumentDatabase get_SystemDatabase();
    public InMemoryRavenConfiguration get_SystemConfiguration();
    public InMemoryRavenConfiguration CreateTenantConfiguration(string tenantId, bool ignoreDisabledDatabase);
    private Dictionary`2<string, string> GetClusterWideSettings();
    private DatabaseDocument GetTenantDatabaseDocument(string tenantId, bool ignoreDisabledDatabase);
    [AsyncStateMachineAttribute("Raven.Database.Server.Tenancy.DatabasesLandlord/<GetResourceInternal>d__26")]
public virtual Task`1<DocumentDatabase> GetResourceInternal(string resourceName);
    public virtual bool TryGetOrCreateResourceStore(string resourceName, Task`1& resourceTask);
    protected InMemoryRavenConfiguration CreateConfiguration(string tenantId, DatabaseDocument document, string folderPropName, InMemoryRavenConfiguration parentConfiguration, Dictionary`2<string, string> clusterSettings);
    public void Protect(DatabaseDocument databaseDocument);
    private void OnDatabaseBackupCompleted(DocumentDatabase db);
    private void AssertLicenseParameters(InMemoryRavenConfiguration config);
    public void ForAllDatabases(Action`1<DocumentDatabase> action, bool excludeSystemDatabase);
    protected virtual DateTime LastWork(DocumentDatabase resource);
    public void Init();
    public bool IsDatabaseLoaded(string tenantName);
    public Nullable`1<Guid> GetDatabaseId(string tenantName);
    private void DocumentDatabaseDisposingStarted(object documentDatabase, EventArgs args);
    private void DocumentDatabaseDisposingEnded(object documentDatabase, EventArgs args);
    private void UnloadDatabaseOnStorageInaccessible(object documentDatabase, EventArgs eventArgs);
    [CompilerGeneratedAttribute]
private void <Init>b__34_0(DocumentDatabase database, DocumentChangeNotification notification, RavenJObject doc);
}
public class Raven.Database.Server.Tenancy.FileSystemsLandlord : AbstractLandlord`1<RavenFileSystem> {
    private bool initialized;
    [CompilerGeneratedAttribute]
private Action`1<InMemoryRavenConfiguration> SetupTenantConfiguration;
    public string ResourcePrefix { get; }
    public InMemoryRavenConfiguration SystemConfiguration { get; }
    public FileSystemsLandlord(DocumentDatabase systemDatabase);
    public virtual string get_ResourcePrefix();
    [CompilerGeneratedAttribute]
public void add_SetupTenantConfiguration(Action`1<InMemoryRavenConfiguration> value);
    [CompilerGeneratedAttribute]
public void remove_SetupTenantConfiguration(Action`1<InMemoryRavenConfiguration> value);
    public InMemoryRavenConfiguration get_SystemConfiguration();
    public void Init();
    public InMemoryRavenConfiguration CreateTenantConfiguration(string tenantId, bool ignoreDisabledFileSystem);
    protected InMemoryRavenConfiguration CreateConfiguration(string tenantId, FileSystemDocument document, string folderPropName, InMemoryRavenConfiguration parentConfiguration);
    public void Unprotect(FileSystemDocument configDocument);
    public void Protect(FileSystemDocument configDocument);
    private FileSystemDocument GetTenantFileSystemDocument(string tenantId, bool ignoreDisabledFileSystem);
    public bool TryGetFileSystem(string tenantId, Task`1& fileSystem);
    [AsyncStateMachineAttribute("Raven.Database.Server.Tenancy.FileSystemsLandlord/<GetResourceInternal>d__16")]
public virtual Task`1<RavenFileSystem> GetResourceInternal(string resourceName);
    public virtual bool TryGetOrCreateResourceStore(string tenantId, Task`1& fileSystem);
    private void AssertLicenseParameters(InMemoryRavenConfiguration config);
    protected virtual DateTime LastWork(RavenFileSystem resource);
    public void ForAllFileSystems(Action`1<RavenFileSystem> action);
    public bool IsFileSystemLoaded(string tenantName);
    [CompilerGeneratedAttribute]
private void <Init>b__9_0(DocumentDatabase database, DocumentChangeNotification notification, RavenJObject doc);
}
public class Raven.Database.Server.Tenancy.TimeSeriesLandlord : AbstractLandlord`1<TimeSeriesStorage> {
    private bool initialized;
    [CompilerGeneratedAttribute]
private Action`1<InMemoryRavenConfiguration> SetupTenantConfiguration;
    public string ResourcePrefix { get; }
    public InMemoryRavenConfiguration SystemConfiguration { get; }
    public TimeSeriesLandlord(DocumentDatabase systemDatabase);
    public virtual string get_ResourcePrefix();
    [CompilerGeneratedAttribute]
public void add_SetupTenantConfiguration(Action`1<InMemoryRavenConfiguration> value);
    [CompilerGeneratedAttribute]
public void remove_SetupTenantConfiguration(Action`1<InMemoryRavenConfiguration> value);
    public InMemoryRavenConfiguration get_SystemConfiguration();
    public void Init();
    public InMemoryRavenConfiguration CreateTenantConfiguration(string tenantId, bool ignoreDisabledTimeSeries);
    protected InMemoryRavenConfiguration CreateConfiguration(string tenantId, TimeSeriesDocument document, string folderPropName, InMemoryRavenConfiguration parentConfiguration);
    private TimeSeriesDocument GetTenantDatabaseDocument(string tenantId, bool ignoreDisabledTimeSeriesStorage);
    [AsyncStateMachineAttribute("Raven.Database.Server.Tenancy.TimeSeriesLandlord/<GetResourceInternal>d__13")]
public virtual Task`1<TimeSeriesStorage> GetResourceInternal(string resourceName);
    public virtual bool TryGetOrCreateResourceStore(string tenantId, Task`1& timeSeries);
    public void Unprotect(TimeSeriesDocument configDocument);
    public void Protect(TimeSeriesDocument configDocument);
    private void AssertLicenseParameters(InMemoryRavenConfiguration config);
    public void ForAllTimeSeries(Action`1<TimeSeriesStorage> action);
    protected virtual DateTime LastWork(TimeSeriesStorage resource);
    [CompilerGeneratedAttribute]
private void <Init>b__9_0(DocumentDatabase database, DocumentChangeNotification notification, RavenJObject doc);
}
[AttributeUsageAttribute("64")]
public class Raven.Database.Server.WebApi.Attributes.HttpEvalAttribute : Attribute {
    private static Collection`1<HttpMethod> SupportedMethods;
    public Collection`1<HttpMethod> HttpMethods { get; }
    private static HttpEvalAttribute();
    public sealed virtual Collection`1<HttpMethod> get_HttpMethods();
}
[AttributeUsageAttribute("64")]
public class Raven.Database.Server.WebApi.Attributes.HttpResetAttribute : Attribute {
    private static Collection`1<HttpMethod> SupportedMethods;
    public Collection`1<HttpMethod> HttpMethods { get; }
    private static HttpResetAttribute();
    public sealed virtual Collection`1<HttpMethod> get_HttpMethods();
}
[AttributeUsageAttribute("68")]
public class Raven.Database.Server.WebApi.Attributes.RavenRouteAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Template>k__BackingField;
    private static RouteEntry FakeRouteEntry;
    public string Name { get; public set; }
    public int Order { get; public set; }
    public string Template { get; private set; }
    public RavenRouteAttribute(string template);
    private static RavenRouteAttribute();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Template();
    [CompilerGeneratedAttribute]
private void set_Template(string value);
    private sealed virtual override RouteEntry System.Web.Http.Routing.IDirectRouteFactory.CreateRoute(DirectRouteFactoryContext context);
}
public class Raven.Database.Server.WebApi.Filters.RavenExceptionFilterAttribute : ExceptionFilterAttribute {
    private static Dictionary`2<Type, Action`2<HttpActionExecutedContext, Exception>> handlers;
    private static RavenExceptionFilterAttribute();
    public virtual void OnException(HttpActionExecutedContext ctx);
    public static void SerializeError(HttpActionExecutedContext ctx, object error);
    private static void DefaultHandler(HttpActionExecutedContext ctx, Exception e);
    private static void HandleOperationCanceledException(HttpActionExecutedContext ctx, OperationCanceledException e);
    private static void HandleTooManyClausesException(HttpActionExecutedContext ctx, TooManyClauses e);
    private static void HandleBadRequest(HttpActionExecutedContext ctx, BadRequestException e);
    private static void HandleConcurrencyException(HttpActionExecutedContext ctx, ConcurrencyException e);
    private static void HandleJintException(HttpActionExecutedContext ctx, JavaScriptException e);
    private static void HandleIndexDoesNotExistsException(HttpActionExecutedContext ctx, IndexDoesNotExistsException e);
    private static void HandleIndexDisabledException(HttpActionExecutedContext ctx, IndexDisabledException e);
    private static void HandleImplicitFetchFieldsFromDocumentNotAllowedException(HttpActionExecutedContext ctx, ImplicitFetchFieldsFromDocumentNotAllowedException e);
    private static void HandleSynchronizationException(HttpActionExecutedContext ctx, SynchronizationException e);
    private static void HandleFileNotFoundException(HttpActionExecutedContext ctx, FileNotFoundException e);
    private static void HandleSubscriptionException(HttpActionExecutedContext ctx, SubscriptionException e);
}
public class Raven.Database.Server.WebApi.Handlers.GZipToJsonAndCompressHandler : DelegatingHandler {
    [ThreadStaticAttribute]
private static Byte[] buffer;
    private void CopyBetween(Stream source, Stream destination);
    [AsyncStateMachineAttribute("Raven.Database.Server.WebApi.Handlers.GZipToJsonAndCompressHandler/<SendAsync>d__2")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    public HttpResponseMessage Compress(HttpResponseMessage response);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class Raven.Database.Server.WebApi.Handlers.ThrottlingHandler : DelegatingHandler {
    private static ILog Logger;
    private SemaphoreSlim concurrentRequestSemaphore;
    private static string _debugStr;
    public ThrottlingHandler(int maxConcurrentServerRequests);
    private static ThrottlingHandler();
    [AsyncStateMachineAttribute("Raven.Database.Server.WebApi.Handlers.ThrottlingHandler/<SendAsync>d__4")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static Task`1<HttpResponseMessage> HandleTooBusyError(HttpRequestMessage request);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public interface Raven.Database.Server.WebApi.IRavenServer {
    public DocumentDatabase SystemDatabase { get; }
    public InMemoryRavenConfiguration SystemConfiguration { get; }
    public abstract virtual DocumentDatabase get_SystemDatabase();
    public abstract virtual InMemoryRavenConfiguration get_SystemConfiguration();
}
public class Raven.Database.Server.WebApi.MultiGetSafeStringContent : StringContent {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public string Content { get; public set; }
    public MultiGetSafeStringContent(string content);
    public MultiGetSafeStringContent(string content, Encoding encoding);
    public MultiGetSafeStringContent(string content, Encoding encoding, string mediaType);
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
}
internal class Raven.Database.Server.WebApi.RavenInlineConstraintResolver : DefaultInlineConstraintResolver {
}
internal class Raven.Database.Server.WebApi.RavenRouteCollectionRoute : object {
    public static string SubRouteDataKey;
    private static IDictionary`2<string, object> Empty;
    private IReadOnlyCollection`1<IHttpRoute> subRoutes;
    private ConcurrentDictionary`2<Tuple`2<string, SubRoute>, IHttpRoute[]> routDataCache;
    private static Char[] RouteSpliter;
    public string RouteTemplate { get; }
    public IDictionary`2<string, object> Defaults { get; }
    public IDictionary`2<string, object> Constraints { get; }
    public IDictionary`2<string, object> DataTokens { get; }
    public HttpMessageHandler Handler { get; }
    public int Count { get; }
    public RavenRouteCollectionRoute(IReadOnlyCollection`1<IHttpRoute> subRoutes);
    private static RavenRouteCollectionRoute();
    public sealed virtual IHttpRouteData GetRouteData(string virtualPathRoot, HttpRequestMessage request);
    private RavenRouteCollectionRouteData LocateRouteData(string virtualPathRoot, HttpRequestMessage request);
    private SubRoute GetSubRout(string localPath);
    public sealed virtual IHttpVirtualPathData GetVirtualPath(HttpRequestMessage request, IDictionary`2<string, object> values);
    public sealed virtual string get_RouteTemplate();
    public sealed virtual IDictionary`2<string, object> get_Defaults();
    public sealed virtual IDictionary`2<string, object> get_Constraints();
    public sealed virtual IDictionary`2<string, object> get_DataTokens();
    public sealed virtual HttpMessageHandler get_Handler();
    public sealed virtual IEnumerator`1<IHttpRoute> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
public class Raven.Database.Server.WebApi.RequestManager : object {
    private DateTime startUpTime;
    private DatabasesLandlord landlord;
    private long reqNum;
    private Timer serverTimer;
    private static ILog Logger;
    private TimeSpan maxTimeDatabaseCanBeIdle;
    private TimeSpan frequencyToCheckForIdleDatabases;
    private ConcurrentDictionary`2<string, ConcurrentQueue`1<LogHttpRequestStatsParams>> tracedRequests;
    private CancellationTokenSource cancellationTokenSource;
    private long concurrentRequests;
    private int physicalRequestsCount;
    private bool initialized;
    private CancellationToken cancellationToken;
    private ConcurrentDictionary`2<string, ConcurrentSet`1<IEventsTransport>> resourceHttpTraces;
    private ConcurrentSet`1<IEventsTransport> serverHttpTrace;
    [CompilerGeneratedAttribute]
private HotSpareReplicationBehavior <HotSpareValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestWebApiEventArgs> BeforeRequest;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestWebApiEventArgs> AfterRequest;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastRequestTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInHotSpareMode>k__BackingField;
    public DateTime StartUpTime { get; }
    public int NumberOfRequests { get; }
    public long NumberOfConcurrentRequests { get; }
    public HotSpareReplicationBehavior HotSpareValidator { get; public set; }
    public Nullable`1<DateTime> LastRequestTime { get; private set; }
    public bool IsInHotSpareMode { get; public set; }
    public RequestManager(DatabasesLandlord landlord);
    private static RequestManager();
    public DateTime get_StartUpTime();
    public int get_NumberOfRequests();
    public long get_NumberOfConcurrentRequests();
    [CompilerGeneratedAttribute]
public HotSpareReplicationBehavior get_HotSpareValidator();
    [CompilerGeneratedAttribute]
public void set_HotSpareValidator(HotSpareReplicationBehavior value);
    [CompilerGeneratedAttribute]
public void add_BeforeRequest(EventHandler`1<RequestWebApiEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeRequest(EventHandler`1<RequestWebApiEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AfterRequest(EventHandler`1<RequestWebApiEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AfterRequest(EventHandler`1<RequestWebApiEventArgs> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastRequestTime();
    [CompilerGeneratedAttribute]
private void set_LastRequestTime(Nullable`1<DateTime> value);
    public virtual void OnBeforeRequest(RequestWebApiEventArgs e);
    public virtual void OnAfterRequest(RequestWebApiEventArgs e);
    private void OnBeforeRequest(object sender, RequestWebApiEventArgs args);
    private void OnAfterRequest(object sender, RequestWebApiEventArgs args);
    public void Init();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Raven.Database.Server.WebApi.RequestManager/<HandleActualRequest>d__42")]
public Task`1<HttpResponseMessage> HandleActualRequest(IResourceApiController controller, HttpControllerContext controllerContext, Func`1<Task`1<HttpResponseMessage>> action, Func`2<HttpException, HttpResponseMessage> onHttpException);
    private void IncrementRequestNumberAndLog(IResourceApiController controller, HttpControllerContext controllerContext);
    [CompilerGeneratedAttribute]
public bool get_IsInHotSpareMode();
    [CompilerGeneratedAttribute]
public void set_IsInHotSpareMode(bool value);
    public void AddAccessControlHeaders(RavenBaseApiController controller, HttpResponseMessage msg);
    public void SetThreadLocalState(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> innerHeaders, string databaseName);
    public void ResetThreadLocalState();
    public void ResetNumberOfRequests();
    public void IncrementRequestCount();
    private void FinalizeRequestProcessing(IResourceApiController controller, HttpResponseMessage response, Stopwatch sw);
    private void MarkRequestDuration(IResourceApiController controller, long elapsedMilliseconds);
    private void RememberRecentRequests(LogHttpRequestStatsParams requestLog, string databaseName);
    public IEnumerable`1<LogHttpRequestStatsParams> GetRecentRequests(string databaseName);
    private void TraceTraffic(IResourceApiController controller, LogHttpRequestStatsParams logHttpRequestStatsParams, string resourceName, HttpResponseMessage response);
    private string NormalizeTennantName(string resourceName);
    private void LogHttpRequestStats(IResourceApiController controller, LogHttpRequestStatsParams logHttpRequestStatsParams, string databaseName, long curReq);
    private bool HasAnyHttpTraceEventTransport();
    private void NotifyTrafficWatch(string resourceName, TrafficWatchNotification trafficWatchNotification);
    public void RegisterServerHttpTraceTransport(IEventsTransport transport);
    public void RegisterResourceHttpTraceTransport(IEventsTransport transport, string resourceName);
    private void IdleOperations(object state);
    private bool DatabaseNeedToRunIdleOperations(DocumentDatabase documentDatabase);
    [CompilerGeneratedAttribute]
private void <Dispose>b__41_0();
    [CompilerGeneratedAttribute]
private bool <IdleOperations>b__64_0(KeyValuePair`2<string, DateTime> x);
}
public static class Raven.Database.Server.WebApi.RouteCacher : object {
    private static string ActionsDataTokenKey;
    private static string InfoDataTokenKey;
    private static Dictionary`2<string, HttpRouteInformation> routeCache;
    public static void ClearCache();
    internal static void CacheRoutesIfNecessary(HttpConfiguration cfg);
    internal static bool TryAddRoutesFromCache(HttpConfiguration cfg);
    private static IHttpRoute RebuildRoutes(HttpRouteInformation routeInformation, HttpConfiguration cfg, Dictionary`2<Type, HttpControllerDescriptor> controllerDescriptors);
    private static IHttpRoute RebuildRouteInternal(HttpRouteInformation routeInformation, HttpConfiguration cfg, Dictionary`2<Type, HttpControllerDescriptor> controllerDescriptors);
    [IteratorStateMachineAttribute("Raven.Database.Server.WebApi.RouteCacher/<CacheRoutes>d__8")]
private static IEnumerable`1<HttpRouteInformation> CacheRoutes(IHttpRoute route);
    private static HttpRouteInformation CacheRouteInternal(IHttpRoute route);
}
public class Raven.Database.Smuggler.DatabaseDataDumper : SmugglerDatabaseApiBase {
    public Action`1<string> Progress { get; public set; }
    public DatabaseDataDumper(DocumentDatabase database, SmugglerDatabaseOptions options);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.DatabaseDataDumper/<ExportDeletions>d__1")]
public virtual Task ExportDeletions(SmugglerJsonTextWriter jsonWriter, OperationState result, LastEtagsInfo maxEtagsToFetch);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.DatabaseDataDumper/<Between>d__2")]
public virtual Task Between(SmugglerBetweenOptions`1<RavenConnectionStringOptions> betweenOptions);
    protected static DocumentStore CreateStore(RavenConnectionStringOptions connectionStringOptions);
    private BulkInsertOperation CreateBulkInsertOperation(DocumentStore documentStore);
    public Action`1<string> get_Progress();
    public void set_Progress(Action`1<string> value);
    [CompilerGeneratedAttribute]
private void <CreateBulkInsertOperation>b__4_0(string text);
}
internal class Raven.Database.Smuggler.ServerValidation : object {
    public static void ValidateThatServerIsUpAndDatabaseExists(RavenConnectionStringOptions server, DocumentStore s);
}
public class Raven.Database.Smuggler.SmugglerCounterApi : object {
    private static string IncrementalExportStateFile;
    private static string CounterIncrementalDump;
    private Action`1<string> showProgress;
    [CompilerGeneratedAttribute]
private SmugglerCounterOptions <Options>k__BackingField;
    public SmugglerCounterOptions Options { get; public set; }
    public Action`1<string> ShowProgress { get; public set; }
    public CancellationToken CancellationToken { get; }
    public SmugglerCounterApi(Action`1<string> showProgress);
    [CompilerGeneratedAttribute]
public sealed virtual SmugglerCounterOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(SmugglerCounterOptions value);
    public Action`1<string> get_ShowProgress();
    public void set_ShowProgress(Action`1<string> value);
    public CancellationToken get_CancellationToken();
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterApi/<ExportData>d__13")]
public sealed virtual Task`1<CounterOperationState> ExportData(SmugglerExportOptions`1<CounterConnectionStringOptions> exportOptions);
    private static string CalculateExportFile(SmugglerExportOptions`1<CounterConnectionStringOptions> exportOptions, string exportFolder);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterApi/<ExportIncrementalData>d__15")]
private Task ExportIncrementalData(ICounterStore counterStore, string exportFilename, JsonTextWriter jsonWriter);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterApi/<GetCounterStatesSinceEtag>d__16")]
private Task`1<IEnumerable`1<CounterState>> GetCounterStatesSinceEtag(ICounterStore counterStore, long etag);
    private static long ReadLastEtagFromStateFile(string exportFilename);
    private static void WriteLastEtagToStateFile(string exportFilename, long lastEtag);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterApi/<ExportFullData>d__19")]
private Task ExportFullData(ICounterStore counterStore, JsonTextWriter jsonWriter);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterApi/<ImportFullData>d__20")]
private Task ImportFullData(CounterConnectionStringOptions connectionString, Stream stream);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterApi/<ImportData>d__21")]
public sealed virtual Task ImportData(SmugglerImportOptions`1<CounterConnectionStringOptions> importOptions);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterApi/<ImportIncrementalData>d__22")]
private Task ImportIncrementalData(CounterConnectionStringOptions connectionString, Stream stream);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterApi/<Between>d__23")]
public sealed virtual Task Between(SmugglerBetweenOptions`1<CounterConnectionStringOptions> betweenOptions);
}
public class Raven.Database.Smuggler.SmugglerCounterOperationDispatcher : SmugglerOperationDispatcher`1<SmugglerCounterOptions> {
    private SmugglerCounterApi api;
    protected string FileExtension { get; }
    public SmugglerCounterOperationDispatcher(SmugglerCounterOptions options);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterOperationDispatcher/<PerformImportAsync>d__2")]
protected virtual Task PerformImportAsync(SmugglerCounterOptions parameters);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterOperationDispatcher/<PerformExportAsync>d__3")]
protected virtual Task PerformExportAsync(SmugglerCounterOptions parameters);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerCounterOperationDispatcher/<PerformBetweenAsync>d__4")]
protected virtual Task PerformBetweenAsync(SmugglerCounterOptions parameters);
    protected virtual string get_FileExtension();
}
public class Raven.Database.Smuggler.SmugglerEmbeddedDatabaseOperations : object {
    private DocumentDatabase database;
    private TimeSpan timeout;
    private long maxSize;
    private List`1<JsonDocument> bulkInsertBatch;
    private SmugglerJintHelper scriptedJsonPatcher;
    private Etag etagEmpty;
    [CompilerGeneratedAttribute]
private Action`1<string> <Progress>k__BackingField;
    private long totalSize;
    private Stopwatch sp;
    [CompilerGeneratedAttribute]
private SmugglerDatabaseOptions <Options>k__BackingField;
    public Action`1<string> Progress { get; public set; }
    public SmugglerDatabaseOptions Options { get; private set; }
    public SmugglerEmbeddedDatabaseOperations(DocumentDatabase database);
    [CompilerGeneratedAttribute]
public Action`1<string> get_Progress();
    [CompilerGeneratedAttribute]
public void set_Progress(Action`1<string> value);
    public sealed virtual Task`1<RavenJArray> GetIndexes(int totalCount);
    public sealed virtual JsonDocument GetDocument(string key);
    public sealed virtual Task`1<IAsyncEnumerator`1<RavenJObject>> GetDocuments(Etag lastEtag, int take);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Task`1<Etag> ExportAttachmentsDeletion(SmugglerJsonTextWriter jsonWriter, Etag startAttachmentsDeletionEtag, Etag maxAttachmentEtag);
    public sealed virtual Task`1<RavenJArray> GetTransformers(int start);
    public sealed virtual Task`1<Etag> ExportDocumentsDeletion(SmugglerJsonTextWriter jsonWriter, Etag startDocsEtag, Etag maxEtag);
    public sealed virtual LastEtagsInfo FetchCurrentMaxEtags();
    public sealed virtual Task PutIndex(string indexName, RavenJToken index);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Task PutAttachment(AttachmentExportInfo attachmentExportInfo);
    public sealed virtual Task PutDocument(RavenJObject document, int size);
    public sealed virtual Task PutTransformer(string transformerName, RavenJToken transformer);
    public sealed virtual Task DeleteDocument(string key);
    [CompilerGeneratedAttribute]
public sealed virtual SmugglerDatabaseOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(SmugglerDatabaseOptions value);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Task DeleteAttachment(string key);
    public sealed virtual void PurgeTombstones(OperationState result);
    public sealed virtual Task`1<BuildNumber> GetVersion(RavenConnectionStringOptions server);
    public sealed virtual Task`1<DatabaseStatistics> GetStats();
    public sealed virtual Task`1<RavenJObject> TransformDocument(RavenJObject document, string transformScript);
    public sealed virtual RavenJObject StripReplicationInformationFromMetadata(RavenJObject metadata);
    public sealed virtual void Initialize(SmugglerDatabaseOptions databaseOptions);
    public sealed virtual void Configure(SmugglerDatabaseOptions databaseOptions);
    public sealed virtual Task`1<List`1<KeyValuePair`2<string, long>>> GetIdentities();
    public sealed virtual Task SeedIdentityFor(string identityName, long identityValue);
    public sealed virtual Task SeedIdentities(List`1<KeyValuePair`2<string, long>> itemsToInsert);
    [AsyncStateMachineAttribute("Raven.Database.Smuggler.SmugglerEmbeddedDatabaseOperations/<WaitForLastBulkInsertTaskToFinish>d__40")]
public sealed virtual Task WaitForLastBulkInsertTaskToFinish();
    public sealed virtual Task`1<IAsyncEnumerator`1<RavenJObject>> ExportItems(ItemType types, OperationState state);
    public RavenJToken DisableVersioning(RavenJObject metadata);
    public sealed virtual void ShowProgress(string format, Object[] args);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Task`1<List`1<AttachmentInformation>> GetAttachments(int start, Etag etag, int maxRecords);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Task`1<Byte[]> GetAttachmentData(AttachmentInformation attachmentInformation);
    public sealed virtual string GetIdentifier();
}
internal class Raven.Database.Smuggler.SmugglerExporter : object {
    private DocumentDatabase database;
    private ExportOptions options;
    private IDictionary`2<SmugglerExportType, string> exportTypes;
    public SmugglerExporter(DocumentDatabase database, ExportOptions options);
    public void Export(Action`1<RavenJObject> write, CancellationToken token);
    private void WriteIdentities(Action`1<RavenJObject> write, CancellationToken token);
    private Etag WriteAttachmentDeletions(Action`1<RavenJObject> write, Etag startEtag, CancellationToken token);
    private Etag WriteDocumentDeletions(Action`1<RavenJObject> write, Etag startEtag, CancellationToken token);
    private Etag WriteAttachments(Action`1<RavenJObject> write, Etag startEtag, int maxNumberOfAttachmentsToWrite, CancellationToken token);
    private Etag WriteDocuments(Action`1<RavenJObject> write, Etag startEtag, int maxNumberOfDocumentsToWrite, CancellationToken token);
    private void FillExportTypes();
}
public class Raven.Database.Smuggler.SmugglerJintHelper : object {
    private Engine jint;
    public void Initialize(SmugglerDatabaseOptions databaseOptions);
    public RavenJObject Transform(string transformScript, RavenJObject input);
}
public class Raven.Database.Storage.AddDocumentResult : object {
    public Etag Etag;
    public Etag PrevEtag;
    public DateTime SavedAt;
    public bool Updated;
}
public abstract class Raven.Database.Storage.BaseBackupOperation : object {
    protected static ILog log;
    protected DocumentDatabase database;
    protected string backupSourceDirectory;
    protected string backupDestinationDirectory;
    protected bool incrementalBackup;
    protected DatabaseDocument databaseDocument;
    protected ResourceBackupState state;
    protected CancellationToken cancellationToken;
    protected bool BackupAlreadyExists { get; }
    protected BaseBackupOperation(DocumentDatabase database, string backupSourceDirectory, string backupDestinationDirectory, bool incrementalBackup, DatabaseDocument databaseDocument, ResourceBackupState state, CancellationToken cancellationToken);
    private static BaseBackupOperation();
    protected abstract virtual bool get_BackupAlreadyExists();
    protected abstract virtual void ExecuteBackup(string backupPath, bool isIncrementalBackup, CancellationToken token);
    protected virtual void OperationFinishedSuccessfully();
    public void Execute();
    private void EnsureBackupDestinationExists();
    protected abstract virtual bool CanPerformIncrementalBackup();
    protected string DirectoryForIncrementalBackup();
    protected void CompleteBackup();
    protected void UpdateBackupStatus(string newMsg, Exception exception, BackupMessageSeverity severity);
}
internal abstract class Raven.Database.Storage.BaseRestoreOperation : object {
    private static string IndexesSubfolder;
    protected static ILog log;
    protected Action`1<string> output;
    protected string backupLocation;
    protected DatabaseRestoreRequest _restoreRequest;
    protected InMemoryRavenConfiguration Configuration;
    protected string databaseLocation;
    protected string indexLocation;
    protected string indexDefinitionLocation;
    protected string journalLocation;
    protected BaseRestoreOperation(DatabaseRestoreRequest restoreRequest, InMemoryRavenConfiguration configuration, InMemoryRavenConfiguration globalConfiguration, Action`1<string> output);
    private static BaseRestoreOperation();
    private string GenerateIndexLocation(DatabaseRestoreRequest databaseRestoreRequest, InMemoryRavenConfiguration configuration, InMemoryRavenConfiguration globalConfiguration);
    public abstract virtual void Execute();
    protected void ValidateRestorePreconditionsAndReturnLogsPath(string backupFilename);
    protected abstract virtual bool IsValidBackup(string backupFilename);
    protected virtual void CheckBackupOwner();
    protected string BackupIndexesPath();
    private void CopyAll(DirectoryInfo source, DirectoryInfo target);
    private void ForceIndexReset(string indexPath, string indexName, Exception ex);
    protected void CopyIndexDefinitions();
    protected void CopyIndexes();
    protected string BackupFilenamePath(string backupFilename);
}
public class Raven.Database.Storage.CollectionDetails : object {
    [CompilerGeneratedAttribute]
private long <TotalSize>k__BackingField;
    public static int TopDocsLimit;
    [JsonIgnoreAttribute]
private HistogramMetric _stats;
    [JsonIgnoreAttribute]
private SortedList`2<int, string> _topDocs;
    public long TotalSize { get; private set; }
    public HistogramData Stats { get; }
    public List`1<DocumentAndSize> TopDocs { get; }
    [CompilerGeneratedAttribute]
public long get_TotalSize();
    [CompilerGeneratedAttribute]
private void set_TotalSize(long value);
    public HistogramData get_Stats();
    public List`1<DocumentAndSize> get_TopDocs();
    public void Update(int documentSize, string docId);
}
public class Raven.Database.Storage.DatabaseSizeInformation : object {
    public static DatabaseSizeInformation Empty;
    [CompilerGeneratedAttribute]
private long <UsedSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AllocatedSizeInBytes>k__BackingField;
    public long UsedSizeInBytes { get; public set; }
    public long AllocatedSizeInBytes { get; public set; }
    private static DatabaseSizeInformation();
    [CompilerGeneratedAttribute]
public long get_UsedSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_UsedSizeInBytes(long value);
    [CompilerGeneratedAttribute]
public long get_AllocatedSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_AllocatedSizeInBytes(long value);
}
public class Raven.Database.Storage.DebugDocumentStats : object {
    [CompilerGeneratedAttribute]
private long <Total>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Tombstones>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionDetails <System>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionDetails <NoCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CollectionDetails> <_collections>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToGenerate>k__BackingField;
    public long Total { get; public set; }
    public long TotalSize { get; public set; }
    public long Tombstones { get; public set; }
    public CollectionDetails System { get; public set; }
    public CollectionDetails NoCollection { get; public set; }
    [JsonIgnoreAttribute]
private Dictionary`2<string, CollectionDetails> _collections { get; private set; }
    public Dictionary`2<string, CollectionDetails> Collections { get; }
    public TimeSpan TimeToGenerate { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(long value);
    [CompilerGeneratedAttribute]
public long get_TotalSize();
    [CompilerGeneratedAttribute]
public void set_TotalSize(long value);
    [CompilerGeneratedAttribute]
public long get_Tombstones();
    [CompilerGeneratedAttribute]
public void set_Tombstones(long value);
    [CompilerGeneratedAttribute]
public CollectionDetails get_System();
    [CompilerGeneratedAttribute]
public void set_System(CollectionDetails value);
    [CompilerGeneratedAttribute]
public CollectionDetails get_NoCollection();
    [CompilerGeneratedAttribute]
public void set_NoCollection(CollectionDetails value);
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CollectionDetails> get__collections();
    [CompilerGeneratedAttribute]
private void set__collections(Dictionary`2<string, CollectionDetails> value);
    public Dictionary`2<string, CollectionDetails> get_Collections();
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToGenerate();
    [CompilerGeneratedAttribute]
public void set_TimeToGenerate(TimeSpan value);
    public void IncrementCollection(string name, int size, string docId);
}
public class Raven.Database.Storage.DebugDocumentStatsState : OperationStateBase {
    [CompilerGeneratedAttribute]
private DebugDocumentStats <Stats>k__BackingField;
    public DebugDocumentStats Stats { get; public set; }
    [CompilerGeneratedAttribute]
public DebugDocumentStats get_Stats();
    [CompilerGeneratedAttribute]
public void set_Stats(DebugDocumentStats value);
}
public class Raven.Database.Storage.DocCountWithSampleDocIds : object {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <SampleDocsIds>k__BackingField;
    public int Count { get; public set; }
    public HashSet`1<string> SampleDocsIds { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SampleDocsIds();
    [CompilerGeneratedAttribute]
public void set_SampleDocsIds(HashSet`1<string> value);
}
public class Raven.Database.Storage.DocumentAndSize : object {
    [CompilerGeneratedAttribute]
private string <DocId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public string DocId { get; public set; }
    public int Size { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DocId();
    [CompilerGeneratedAttribute]
public void set_DocId(string value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
}
public class Raven.Database.Storage.DocumentFetchError : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string Key { get; public set; }
    public Exception Exception { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
}
public class Raven.Database.Storage.DocumentInTransactionData : object {
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Delete>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModified>k__BackingField;
    public Etag Etag { get; public set; }
    public bool Delete { get; public set; }
    public RavenJObject Metadata { get; public set; }
    public RavenJObject Data { get; public set; }
    public string Key { get; public set; }
    public DateTime LastModified { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public bool get_Delete();
    [CompilerGeneratedAttribute]
public void set_Delete(bool value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RavenJObject value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(RavenJObject value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(DateTime value);
}
public class Raven.Database.Storage.Esent.Backup.BackupOperation : BaseBackupOperation {
    private JET_INSTANCE instance;
    private string backupConfigPath;
    protected bool BackupAlreadyExists { get; }
    public BackupOperation(DocumentDatabase database, string backupSourceDirectory, string backupDestinationDirectory, bool incrementalBackup, DatabaseDocument databaseDocument, ResourceBackupState state, CancellationToken cancellationToken);
    protected virtual bool get_BackupAlreadyExists();
    protected virtual void ExecuteBackup(string backupPath, bool isIncrementalBackup, CancellationToken token);
    protected virtual void OperationFinishedSuccessfully();
    protected virtual bool CanPerformIncrementalBackup();
}
internal class Raven.Database.Storage.Esent.Backup.RestoreOperation : BaseRestoreOperation {
    private DateTime lastCompactionProgressStatusUpdate;
    public RestoreOperation(DatabaseRestoreRequest restoreRequest, InMemoryRavenConfiguration configuration, InMemoryRavenConfiguration globalConfiguration, Action`1<string> operationOutputCallback);
    protected virtual bool IsValidBackup(string backupFilename);
    protected virtual void CheckBackupOwner();
    public static void CheckBackupOwner(string backupLocation, Action`1<string> output);
    public virtual void Execute();
    private void CombineIncrementalBackups();
    private JET_err RestoreStatusCallback(JET_SESID sesid, JET_SNP snp, JET_SNT snt, object data);
    private JET_err CompactStatusCallback(JET_SESID sesid, JET_SNP snp, JET_SNT snt, object data);
}
public class Raven.Database.Storage.Esent.Debug.EsentUtil : object {
    public static void ReportOn(string path, string tableName);
    private static void ReportOn(TransactionalStorage transactionalStorage, string tableName, string path);
    public static void DumpTable(Session session, Table table, Stream stream);
    private static object GetvalueFromTable(Session session, Table table, ColumnInfo col);
}
public static class Raven.Database.Storage.Esent.Debug.StorageSizes : object {
    public static List`1<string> ReportOn(string path);
    public static List`1<string> ReportOn(TransactionalStorage transactionalStorage, Action`1<string> progress, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.Debug.StorageSizes/<GetSizes>d__2")]
private static IEnumerable`1<Tuple`2<string, long>> GetSizes(Session session, JET_DBID db, Action`1<string> progress, CancellationToken token);
}
public class Raven.Database.Storage.Esent.SchemaUpdates.Updates.From47To48 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Database.Storage.Esent.SchemaUpdates.Updates.From48To50 : object {
    private InMemoryRavenConfiguration configuration;
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
    private void UpdateLastIdentityForIndexes(Session session, JET_DBID dbid, int lastIdentity);
    public static string FixupIndexName(string index, string path);
}
public class Raven.Database.Storage.Esent.SchemaUpdates.Updates.From50To51 : object {
    private InMemoryRavenConfiguration configuration;
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Database.Storage.Esent.SchemaUpdates.Updates.From51To52 : object {
    private InMemoryRavenConfiguration configuration;
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Database.Storage.Esent.SchemaUpdates.Updates.From52To53 : object {
    private InMemoryRavenConfiguration configuration;
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Database.Storage.Esent.SchemaUpdates.Updates.From53To54 : object {
    private InMemoryRavenConfiguration configuration;
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Database.Storage.Esent.SchemaUpdates.Updates.From54To55 : object {
    private InMemoryRavenConfiguration configuration;
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions : object {
    [ThreadStaticAttribute]
private static Byte[] readBuffer;
    private static RavenJObject EmptyDocument;
    [CompilerGeneratedAttribute]
private Action OnStorageCommit;
    [CompilerGeneratedAttribute]
private Action BeforeStorageCommit;
    [CompilerGeneratedAttribute]
private Action AfterStorageCommit;
    private object maybePulseLock;
    private TableColumnsCache tableColumnsCache;
    private OrderedPartCollection`1<AbstractDocumentCodec> documentCodecs;
    private IUuidGenerator uuidGenerator;
    private IDocumentCacher cacher;
    private TransactionalStorage transactionalStorage;
    protected JET_DBID dbid;
    protected static ILog logger;
    protected Session session;
    private Transaction transaction;
    private Dictionary`2<Etag, Etag> etagTouches;
    private EsentTransactionContext transactionContext;
    private Action sessionAndTransactionDisposer;
    private int maybePulseCount;
    private int totalMaybePulseCount;
    [CompilerGeneratedAttribute]
private bool <UsingLazyCommit>k__BackingField;
    private static ThreadLocal`1<IHashEncryptor> localSha1;
    private ConcurrentDictionary`2<int, RemainingReductionPerLevel> scheduledReductionsPerViewAndLevel;
    private Table documents;
    private Table duplicatedDocuments;
    private Table queue;
    private Table lists;
    private Table directories;
    private Table files;
    private Table indexesStats;
    private Table indexesStatsReduce;
    private Table indexesEtags;
    private Table scheduledReductions;
    private Table mappedResults;
    private Table reducedResults;
    private Table tasks;
    private Table identity;
    private Table details;
    private Table reduceKeysCounts;
    private Table reduceKeysStatus;
    private Table indexedDocumentsReferences;
    private static int bookmarkMost;
    public JET_DBID Dbid { get; }
    public Session Session { get; }
    public bool UsingLazyCommit { get; public set; }
    protected Table Documents { get; }
    protected Table DuplicatedDocuments { get; }
    protected Table Queue { get; }
    protected Table Lists { get; }
    protected internal Table Directories { get; }
    protected Table Files { get; }
    protected Table IndexesStats { get; }
    protected Table IndexesStatsReduce { get; }
    protected Table IndexesEtags { get; }
    protected Table ScheduledReductions { get; }
    protected Table MappedResults { get; }
    protected Table ReducedResults { get; }
    protected Table Tasks { get; }
    protected Table Identity { get; }
    protected Table Details { get; }
    protected Table ReduceKeysCounts { get; }
    protected Table ReduceKeysStatus { get; }
    protected Table IndexedDocumentsReferences { get; }
    public bool HasTasks { get; }
    public long ApproximateTaskCount { get; }
    [CLSCompliantAttribute("False")]
[DebuggerHiddenAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public DocumentStorageActions(JET_INSTANCE instance, string database, TableColumnsCache tableColumnsCache, OrderedPartCollection`1<AbstractDocumentCodec> documentCodecs, IUuidGenerator uuidGenerator, IDocumentCacher cacher, EsentTransactionContext transactionContext, TransactionalStorage transactionalStorage);
    private static DocumentStorageActions();
    public sealed virtual long GetDocumentsCount();
    public sealed virtual JsonDocument DocumentByKey(string key, bool useDifferentTable);
    public sealed virtual Stream RawDocumentByKey(string key);
    public sealed virtual JsonDocumentMetadata DocumentMetadataByKey(string key);
    private T DocumentByKeyInternal(Table table, string key, Func`4<JsonDocumentMetadata, int, Func`6<Table, string, Etag, RavenJObject, Reference`1<int>, RavenJObject>, T> createResult);
    private RavenJObject ReadDocumentMetadata(Table table, string key, Etag existingEtag, Int32& size);
    private RavenJObject ReadDocumentData(Table table, string key, Etag existingEtag, RavenJObject metadata, Reference`1<int> docSize);
    public sealed virtual IEnumerable`1<JsonDocument> GetDocumentsByReverseUpdateOrder(int start, int take, HashSet`1<string> entityNames);
    private Func`1<JsonDocument> ReadDocument(bool hasEntityNames, HashSet`1<string> entityNames);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetDocumentsWithoutBuffering>d__11")]
private IEnumerable`1<JsonDocument> GetDocumentsWithoutBuffering(int take, bool hasEntityNames, HashSet`1<string> entityNames);
    private bool TryMoveTableRecords(Table table, int start, bool backward);
    private JsonDocument ReadCurrentDocument(string key, Etag existingEtag);
    private int GetDocumentFromStorage(Table table, string key, RavenJObject metadata, Etag existingEtag, RavenJObject& dataAsJson);
    private int GetMetadataFromStorage(Table table, RavenJObject& metadata);
    private static void EnsureBuffer(int colSize);
    private JsonDocument ReadCurrentDocument();
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetDocumentsAfterWithIdStartingWith>d__18")]
public sealed virtual IEnumerable`1<JsonDocument> GetDocumentsAfterWithIdStartingWith(Etag etag, string idPrefix, int take, CancellationToken cancellationToken, Nullable`1<long> maxSize, Etag untilEtag, Nullable`1<TimeSpan> timeout, Action`1<Etag> lastProcessedDocument, Reference`1<bool> earlyExit, HashSet`1<string> entityNames, Action`1<List`1<DocumentFetchError>> failedToGetHandler);
    private JsonDocument GetJsonDocument(bool hasEntityNames, string key, Etag docEtag, HashSet`1<string> entityNames);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetDocumentIdsAfterEtag>d__20")]
public sealed virtual IEnumerable`1<string> GetDocumentIdsAfterEtag(Etag etag, int maxTake, Func`4<string, RavenJObject, Func`1<JsonDocument>, bool> filterDocument, Reference`1<bool> earlyExit, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<JsonDocument> GetDocumentsAfter(Etag etag, int take, CancellationToken cancellationToken, Nullable`1<long> maxSize, Etag untilEtag, Nullable`1<TimeSpan> timeout, Action`1<Etag> lastProcessedOnFailure, Reference`1<bool> earlyExit, HashSet`1<string> entityNames, Action`1<List`1<DocumentFetchError>> failedToGetHandler);
    public sealed virtual Etag GetBestNextDocumentEtag(Etag etag);
    public sealed virtual DebugDocumentStats GetDocumentStatsVerySlowly(Action`1<string> progress, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetDocumentsWithIdStartingWith>d__24")]
public sealed virtual IEnumerable`1<JsonDocument> GetDocumentsWithIdStartingWith(string idPrefix, int start, int take, string skipAfter);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetDocuments>d__25")]
public sealed virtual IEnumerable`1<JsonDocument> GetDocuments(int start);
    private bool StartsWithIgnoreCaseAndSymbols(string keyFromDb, string idPrefix);
    public sealed virtual Etag GetEtagAfterSkip(Etag etag, int skip, CancellationToken cancellationToken, Int32& skipped);
    public sealed virtual void TouchDocument(string key, Etag& preTouchEtag, Etag& afterTouchEtag);
    public sealed virtual void IncrementDocumentCount(int value);
    public sealed virtual AddDocumentResult AddDocument(string key, Etag etag, RavenJObject data, RavenJObject metadata, InvokeSource source);
    public sealed virtual AddDocumentResult InsertDocument(string key, RavenJObject data, RavenJObject metadata, bool overwriteExisting);
    public sealed virtual bool DeleteDocument(string key, Etag etag, RavenJObject& metadata, Etag& deletedETag);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Etag AddAttachment(string key, Etag etag, Stream data, RavenJObject headers);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual void DeleteAttachment(string key, Etag etag);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual long GetAttachmentsCount();
    [ObsoleteAttribute("Use RavenFS instead.")]
[IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetAttachmentsByReverseUpdateOrder>d__36")]
public sealed virtual IEnumerable`1<AttachmentInformation> GetAttachmentsByReverseUpdateOrder(int start);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual IEnumerable`1<AttachmentInformation> GetAttachmentsStartingWith(string idPrefix, int start, int pageSize);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual IEnumerable`1<AttachmentInformation> GetAttachmentsAfter(Etag etag, int take, long maxTotalSize);
    [ObsoleteAttribute("Use RavenFS instead.")]
private AttachmentInformation ReadCurrentAttachmentInformation();
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Attachment GetAttachment(string key);
    [ObsoleteAttribute("Use RavenFS instead.")]
private Stream GetAttachmentStream(string key);
    [CompilerGeneratedAttribute]
public void add_OnStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public void add_BeforeStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public void remove_BeforeStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public void add_AfterStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public void remove_AfterStorageCommit(Action value);
    public JET_DBID get_Dbid();
    public Session get_Session();
    [DebuggerHiddenAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual void Dispose();
    internal void ExecuteOnStorageCommit();
    internal void ExecuteBeforeStorageCommit();
    internal void ExecuteAfterStorageCommit();
    public void UseLazyCommit();
    public sealed virtual void PulseTransaction();
    public sealed virtual bool MaybePulseTransaction(int addToPulseCount, Action beforePulseTransaction);
    [CompilerGeneratedAttribute]
public bool get_UsingLazyCommit();
    [CompilerGeneratedAttribute]
public void set_UsingLazyCommit(bool value);
    public Action Commit(CommitTransactionGrbit txMode);
    public sealed virtual void SetIdentityValue(string name, long value);
    public sealed virtual long GetNextIdentityValue(string name, int val);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, long>> GetIdentities(int start, int take, Int64& totalCount);
    private bool SetCurrentIndexStatsToImpl(int index);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetIndexesStats>d__87")]
public sealed virtual IEnumerable`1<IndexStats> GetIndexesStats();
    public sealed virtual IndexStats GetIndexStats(int index);
    private IndexStats GetIndexStats();
    private DateTime GetLastReducedTimestampWithPotentialNull();
    private Etag GetLastReduceIndexWithPotentialNull();
    public sealed virtual void AddIndex(int id, bool createMapReduce);
    public sealed virtual void PrepareIndexForDeletion(int id);
    public sealed virtual void DeleteIndex(int id, CancellationToken cancellationToken);
    public sealed virtual IndexFailureInformation GetFailureRate(int index);
    public sealed virtual void UpdateLastIndexed(int id, Etag etag, DateTime timestamp);
    public sealed virtual void SetIndexPriority(int id, IndexingPriority priority);
    public sealed virtual void SetIndexesPriority(Int32[] ids, IndexingPriority[] priorities);
    public sealed virtual void UpdateIndexingStats(int id, IndexingWorkStats stats);
    public sealed virtual void UpdateReduceStats(int id, IndexingWorkStats stats);
    public sealed virtual void TouchIndexEtag(int id);
    public sealed virtual void UpdateLastReduced(int id, Etag etag, DateTime timestamp);
    public sealed virtual void RemoveAllDocumentReferencesFrom(string key);
    public sealed virtual void UpdateDocumentReferences(int id, string key, HashSet`1<string> references);
    public sealed virtual IEnumerable`1<string> GetDocumentsReferencing(string key);
    public sealed virtual int GetCountOfDocumentsReferencing(string key);
    public sealed virtual Dictionary`2<string, int> GetDocumentReferencesStats();
    public sealed virtual IEnumerable`1<string> GetDocumentsReferencesFrom(string key);
    public sealed virtual void DumpAllReferancesToCSV(StreamWriter writer, int numberOfSampleDocs);
    private IEnumerable`1<string> QueryReferences(string key, string id, string col);
    public sealed virtual Etag Set(string name, string key, RavenJObject data, UuidType uuidType);
    public sealed virtual void Remove(string name, string key);
    public sealed virtual void RemoveAllBefore(string name, Etag etag, Nullable`1<TimeSpan> timeout);
    public sealed virtual void RemoveAllOlderThan(string name, DateTime dateTime);
    public sealed virtual void Touch(string name, string key, UuidType uuidType, Etag& preTouchEtag, Etag& afterTouchEtag);
    public sealed virtual List`1<ListsInfo> GetListsStatsVerySlowly();
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<Read>d__117")]
public sealed virtual IEnumerable`1<ListItem> Read(string name, Etag start, Etag end, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<Read>d__118")]
public sealed virtual IEnumerable`1<ListItem> Read(string name, int start, int take);
    public sealed virtual ListItem Read(string name, string key);
    public sealed virtual ListItem ReadLast(string name);
    public static Byte[] HashReduceKey(string reduceKey);
    public sealed virtual void PutMappedResult(int indexId, string docId, string reduceKey, RavenJObject data);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetKeysStats>d__125")]
public sealed virtual IEnumerable`1<ReduceKeyAndCount> GetKeysStats(int view, int start, int pageSize);
    public sealed virtual void PutReducedResult(int view, string reduceKey, int level, int sourceBucket, int bucket, RavenJObject data);
    public sealed virtual void ScheduleReductions(int view, int level, ReduceKeyAndBucket reduceKeysAndBucket);
    public sealed virtual ScheduledReductionInfo DeleteScheduledReduction(IEnumerable`1<object> itemsToDelete, CancellationToken token);
    public sealed virtual Dictionary`2<int, RemainingReductionPerLevel> GetRemainingScheduledReductionPerIndex();
    public sealed virtual void DeleteScheduledReduction(int view, int level, string reduceKey);
    public sealed virtual Dictionary`2<int, long> DeleteObsoleteScheduledReductions(List`1<int> mapReduceIndexIds, long delete);
    public sealed virtual IList`1<MappedResultInfo> GetItemsToReduce(GetItemsToReduceParams getItemsToReduceParams, CancellationToken cancellationToken);
    private IEnumerable`1<MappedResultInfo> GetResultsForBucket(int view, int level, string reduceKey, int bucket, bool loadData, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetMappedResultsForBucket>d__134")]
private IEnumerable`1<MappedResultInfo> GetMappedResultsForBucket(int view, string reduceKey, int bucket, bool loadData, CancellationToken cancellationToken);
    public sealed virtual void RemoveReduceResults(int view, int level, string reduceKey, int sourceBucket);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetReducedResultsForBucket>d__136")]
private IEnumerable`1<MappedResultInfo> GetReducedResultsForBucket(int view, string reduceKey, int level, int bucket, bool loadData, CancellationToken cancellationToken);
    public sealed virtual bool HasMappedResultsForIndex(int view);
    public sealed virtual void DeleteMappedResultsForDocumentId(string documentId, int view, Dictionary`2<ReduceKeyAndBucket, int> removed);
    public sealed virtual void UpdateRemovedMapReduceStats(int indexId, Dictionary`2<ReduceKeyAndBucket, int> removed, CancellationToken token);
    public sealed virtual void DeleteMappedResultsForView(int indexId, CancellationToken token);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetKeysForIndexForDebug>d__141")]
public sealed virtual IEnumerable`1<string> GetKeysForIndexForDebug(int view, string startsWith, string sourceId, int start, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetSourcesForIndexForDebug>d__142")]
public sealed virtual IEnumerable`1<string> GetSourcesForIndexForDebug(int view, string startsWith, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetMappedResultsForDebug>d__143")]
public sealed virtual IEnumerable`1<MappedResultInfo> GetMappedResultsForDebug(int view, string key, int start, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetScheduledReductionForDebug>d__144")]
public sealed virtual IEnumerable`1<ScheduledReductionDebugInfo> GetScheduledReductionForDebug(int view, int start, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetReducedResultsForDebug>d__145")]
public sealed virtual IEnumerable`1<MappedResultInfo> GetReducedResultsForDebug(int view, string reduceKey, int level, int start, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetReduceTypesPerKeys>d__146")]
public sealed virtual IEnumerable`1<ReduceTypePerKey> GetReduceTypesPerKeys(int view, int take, int limitOfItemsToReduceInSingleStep, Action`1<string> onError, CancellationToken cancellationToken);
    public sealed virtual void UpdatePerformedReduceType(int view, string reduceKey, ReduceType performedReduceType, bool skipAdd);
    private void ExecuteOnReduceKey(int view, string reduceKey, Table table, IDictionary`2<string, JET_COLUMNID> columnids, Action updateAction, Action insertAction);
    public sealed virtual ReduceType GetLastPerformedReduceType(int view, string reduceKey);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetReduceKeysAndTypes>d__150")]
public sealed virtual IEnumerable`1<ReduceTypePerKey> GetReduceKeysAndTypes(int view, int start, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetMappedBuckets>d__151")]
public sealed virtual IEnumerable`1<int> GetMappedBuckets(int view, string reduceKey, CancellationToken cancellationToken);
    public sealed virtual List`1<MappedResultInfo> GetMappedResults(int view, HashSet`1<string> keysLeftToReduce, bool loadData, int take, HashSet`1<string> keysReturned, CancellationToken cancellationToken, List`1<MappedResultInfo> outputCollection);
    private RavenJObject LoadMappedResults(string key);
    private RavenJObject LoadReducedResults(string key);
    public sealed virtual void IncrementReduceKeyCounter(int indexId, string reduceKey, int val);
    private void DecrementReduceKeyCounter(int view, string reduceKey, int value);
    private int GetNumberOfMappedItemsPerReduceKey(int view, string reduceKey);
    public sealed virtual void EnqueueToQueue(string name, Byte[] data);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<PeekFromQueue>d__159")]
public sealed virtual IEnumerable`1<Tuple`2<Byte[], object>> PeekFromQueue(string name);
    public sealed virtual void DeleteFromQueue(string name, object id);
    public sealed virtual bool IsIndexStale(int view, Nullable`1<DateTime> cutOff, Etag cutoffEtag);
    public sealed virtual bool IsIndexStaleByTask(int view, Nullable`1<DateTime> cutOff);
    public sealed virtual bool IsReduceStale(int view);
    public sealed virtual bool IsMapStale(int view);
    public sealed virtual Tuple`2<DateTime, Etag> IndexLastUpdatedAt(int view);
    public sealed virtual Etag GetMostRecentDocumentEtag();
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Etag GetMostRecentAttachmentEtag();
    public sealed virtual int GetIndexTouchCount(int view);
    protected Table get_Documents();
    protected Table get_DuplicatedDocuments();
    protected Table get_Queue();
    protected Table get_Lists();
    protected internal Table get_Directories();
    protected Table get_Files();
    protected Table get_IndexesStats();
    protected Table get_IndexesStatsReduce();
    protected Table get_IndexesEtags();
    protected Table get_ScheduledReductions();
    protected Table get_MappedResults();
    protected Table get_ReducedResults();
    protected Table get_Tasks();
    protected Table get_Identity();
    protected Table get_Details();
    protected Table get_ReduceKeysCounts();
    protected Table get_ReduceKeysStatus();
    protected Table get_IndexedDocumentsReferences();
    public sealed virtual void AddTask(DatabaseTask task, DateTime addedAt);
    public sealed virtual bool get_HasTasks();
    public sealed virtual long get_ApproximateTaskCount();
    public sealed virtual T GetMergedTask(List`1<int> indexesToSkip, Int32[] allIndexes, HashSet`1<IComparable> alreadySeen);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Esent.StorageActions.DocumentStorageActions/<GetPendingTasksForDebug>d__230")]
public sealed virtual IEnumerable`1<TaskMetadata> GetPendingTasksForDebug();
    private void MergeSimilarTasks(DatabaseTask task, HashSet`1<IComparable> alreadySeen, List`1<int> indexesToSkip, Int32[] allIndexes);
    public sealed virtual void DeleteTasks(HashSet`1<IComparable> alreadySeen);
    public sealed virtual int DeleteTasksForIndex(int indexId);
    private Etag EnsureDocumentEtagMatch(string key, Etag etag, string method);
    [CompilerGeneratedAttribute]
private void <.ctor>b__68_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__69_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__69_1();
}
public abstract class Raven.Database.Storage.Esent.StorageConfigurator : object {
    public static int MaxSessions;
    private static ILog Log;
    protected InMemoryRavenConfiguration Configuration;
    private static Lazy`1<int> VersionPageSize;
    protected string BaseName { get; }
    protected string EventSource { get; }
    protected StorageConfigurator(InMemoryRavenConfiguration configuration);
    private static StorageConfigurator();
    public InstanceParameters ConfigureInstance(JET_INSTANCE jetInstance, string path);
    protected abstract virtual void ConfigureInstanceInternal(int maxVerPages);
    protected abstract virtual string get_BaseName();
    protected abstract virtual string get_EventSource();
    public void LimitSystemCache();
    private static int TranslateToSizeInDatabasePages(int sizeInMegabytes, int multiply);
    private static int TranslateToSizeInVersionPages(int sizeInMegabytes, int multiply);
    public static int GetVersionPageSize();
    private int GetValueFromConfiguration(string name, int defaultValue);
    private bool GetValueFromConfiguration(string name, bool defaultValue);
}
public class Raven.Database.Storage.GetItemsToReduceParams : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LoadData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Take>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentSet`1<object> <ItemsToDelete>k__BackingField;
    [CompilerGeneratedAttribute]
private ReduceKeyAndBucket <LastReduceKeyAndBucket>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ReduceKeys>k__BackingField;
    public int Index { get; private set; }
    public int Level { get; private set; }
    public bool LoadData { get; private set; }
    public int Take { get; public set; }
    public ConcurrentSet`1<object> ItemsToDelete { get; private set; }
    public ReduceKeyAndBucket LastReduceKeyAndBucket { get; public set; }
    public HashSet`1<string> ReduceKeys { get; private set; }
    public GetItemsToReduceParams(int index, HashSet`1<string> reduceKeys, int level, bool loadData, ConcurrentSet`1<object> itemsToDelete);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(int value);
    [CompilerGeneratedAttribute]
public bool get_LoadData();
    [CompilerGeneratedAttribute]
private void set_LoadData(bool value);
    [CompilerGeneratedAttribute]
public int get_Take();
    [CompilerGeneratedAttribute]
public void set_Take(int value);
    [CompilerGeneratedAttribute]
public ConcurrentSet`1<object> get_ItemsToDelete();
    [CompilerGeneratedAttribute]
private void set_ItemsToDelete(ConcurrentSet`1<object> value);
    [CompilerGeneratedAttribute]
public ReduceKeyAndBucket get_LastReduceKeyAndBucket();
    [CompilerGeneratedAttribute]
public void set_LastReduceKeyAndBucket(ReduceKeyAndBucket value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ReduceKeys();
    [CompilerGeneratedAttribute]
private void set_ReduceKeys(HashSet`1<string> value);
}
[ObsoleteAttribute("Use RavenFS instead.")]
public interface Raven.Database.Storage.IAttachmentsStorageActions {
    public abstract virtual Etag AddAttachment(string key, Etag etag, Stream data, RavenJObject headers);
    public abstract virtual void DeleteAttachment(string key, Etag etag);
    public abstract virtual Attachment GetAttachment(string key);
    public abstract virtual long GetAttachmentsCount();
    public abstract virtual IEnumerable`1<AttachmentInformation> GetAttachmentsByReverseUpdateOrder(int start);
    public abstract virtual IEnumerable`1<AttachmentInformation> GetAttachmentsAfter(Etag value, int take, long maxTotalSize);
    public abstract virtual IEnumerable`1<AttachmentInformation> GetAttachmentsStartingWith(string idPrefix, int start, int pageSize);
}
public interface Raven.Database.Storage.IDocumentStorageActions {
    public abstract virtual IEnumerable`1<JsonDocument> GetDocumentsByReverseUpdateOrder(int start, int take, HashSet`1<string> entityNames);
    public abstract virtual IEnumerable`1<JsonDocument> GetDocumentsAfter(Etag etag, int take, CancellationToken cancellationToken, Nullable`1<long> maxSize, Etag untilEtag, Nullable`1<TimeSpan> timeout, Action`1<Etag> lastProcessedDocument, Reference`1<bool> earlyExit, HashSet`1<string> entityNames, Action`1<List`1<DocumentFetchError>> failedToGetHandler);
    public abstract virtual IEnumerable`1<JsonDocument> GetDocumentsAfterWithIdStartingWith(Etag etag, string idPrefix, int take, CancellationToken cancellationToken, Nullable`1<long> maxSize, Etag untilEtag, Nullable`1<TimeSpan> timeout, Action`1<Etag> lastProcessedDocument, Reference`1<bool> earlyExit, HashSet`1<string> entityNames, Action`1<List`1<DocumentFetchError>> failedToGetHandler);
    public abstract virtual IEnumerable`1<JsonDocument> GetDocumentsWithIdStartingWith(string idPrefix, int start, int take, string skipAfter);
    public abstract virtual Etag GetEtagAfterSkip(Etag etag, int skip, CancellationToken cancellationToken, Int32& skipped);
    public abstract virtual IEnumerable`1<string> GetDocumentIdsAfterEtag(Etag etag, int maxTake, Func`4<string, RavenJObject, Func`1<JsonDocument>, bool> filterDocument, Reference`1<bool> earlyExit, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<JsonDocument> GetDocuments(int start);
    public abstract virtual long GetDocumentsCount();
    public abstract virtual JsonDocument DocumentByKey(string key, bool useDifferentTable);
    public abstract virtual Stream RawDocumentByKey(string key);
    public abstract virtual JsonDocumentMetadata DocumentMetadataByKey(string key);
    public abstract virtual bool DeleteDocument(string key, Etag etag, RavenJObject& metadata, Etag& deletedETag);
    public abstract virtual AddDocumentResult AddDocument(string key, Etag etag, RavenJObject data, RavenJObject metadata, InvokeSource source);
    public abstract virtual void IncrementDocumentCount(int value);
    public abstract virtual AddDocumentResult InsertDocument(string key, RavenJObject data, RavenJObject metadata, bool overwriteExisting);
    public abstract virtual void TouchDocument(string key, Etag& preTouchEtag, Etag& afterTouchEtag);
    public abstract virtual Etag GetBestNextDocumentEtag(Etag etag);
    public abstract virtual DebugDocumentStats GetDocumentStatsVerySlowly(Action`1<string> progress, CancellationToken token);
}
public interface Raven.Database.Storage.IGeneralStorageActions {
    public abstract virtual long GetNextIdentityValue(string name, int val);
    public abstract virtual void SetIdentityValue(string name, long value);
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, long>> GetIdentities(int start, int take, Int64& totalCount);
    public abstract virtual void PulseTransaction();
    public abstract virtual bool MaybePulseTransaction(int addToPulseCount, Action beforePulseTransaction);
}
public interface Raven.Database.Storage.IIndexingStorageActions {
    public abstract virtual IEnumerable`1<IndexStats> GetIndexesStats();
    public abstract virtual IndexStats GetIndexStats(int index);
    public abstract virtual void AddIndex(int id, bool createMapReduce);
    public abstract virtual void PrepareIndexForDeletion(int id);
    public abstract virtual void DeleteIndex(int id, CancellationToken cancellationToken);
    public abstract virtual void SetIndexPriority(int id, IndexingPriority priority);
    public abstract virtual void SetIndexesPriority(Int32[] ids, IndexingPriority[] priorities);
    public abstract virtual IndexFailureInformation GetFailureRate(int id);
    public abstract virtual void UpdateLastIndexed(int id, Etag etag, DateTime timestamp);
    public abstract virtual void UpdateLastReduced(int id, Etag etag, DateTime timestamp);
    public abstract virtual void TouchIndexEtag(int id);
    public abstract virtual void UpdateIndexingStats(int id, IndexingWorkStats stats);
    public abstract virtual void UpdateReduceStats(int id, IndexingWorkStats stats);
    public abstract virtual void RemoveAllDocumentReferencesFrom(string key);
    public abstract virtual void UpdateDocumentReferences(int id, string key, HashSet`1<string> references);
    public abstract virtual IEnumerable`1<string> GetDocumentsReferencing(string key);
    public abstract virtual int GetCountOfDocumentsReferencing(string key);
    public abstract virtual Dictionary`2<string, int> GetDocumentReferencesStats();
    public abstract virtual IEnumerable`1<string> GetDocumentsReferencesFrom(string key);
    public abstract virtual void DumpAllReferancesToCSV(StreamWriter writer, int numberOfSampleDocs);
}
public interface Raven.Database.Storage.IListsStorageActions {
    public abstract virtual Etag Set(string name, string key, RavenJObject data, UuidType uuidType);
    public abstract virtual void Remove(string name, string key);
    public abstract virtual IEnumerable`1<ListItem> Read(string name, Etag start, Etag end, int take);
    public abstract virtual IEnumerable`1<ListItem> Read(string name, int start, int take);
    public abstract virtual ListItem Read(string name, string key);
    public abstract virtual ListItem ReadLast(string name);
    public abstract virtual void RemoveAllBefore(string name, Etag etag, Nullable`1<TimeSpan> timeout);
    public abstract virtual void RemoveAllOlderThan(string name, DateTime dateTime);
    public abstract virtual void Touch(string name, string key, UuidType uuidType, Etag& preTouchEtag, Etag& afterTouchEtag);
    public abstract virtual List`1<ListsInfo> GetListsStatsVerySlowly();
}
public interface Raven.Database.Storage.IMappedResultsStorageAction {
    public abstract virtual IEnumerable`1<ReduceKeyAndCount> GetKeysStats(int view, int start, int pageSize);
    public abstract virtual void PutMappedResult(int indexId, string docId, string reduceKey, RavenJObject data);
    public abstract virtual void IncrementReduceKeyCounter(int indexId, string reduceKey, int val);
    public abstract virtual bool HasMappedResultsForIndex(int view);
    public abstract virtual void DeleteMappedResultsForDocumentId(string documentId, int view, Dictionary`2<ReduceKeyAndBucket, int> removed);
    public abstract virtual void UpdateRemovedMapReduceStats(int indexId, Dictionary`2<ReduceKeyAndBucket, int> removed, CancellationToken token);
    public abstract virtual void DeleteMappedResultsForView(int indexId, CancellationToken token);
    public abstract virtual IEnumerable`1<string> GetKeysForIndexForDebug(int index, string startsWith, string sourceId, int start, int take);
    public abstract virtual IEnumerable`1<string> GetSourcesForIndexForDebug(int index, string startsWith, int take);
    public abstract virtual IEnumerable`1<MappedResultInfo> GetMappedResultsForDebug(int index, string key, int start, int take);
    public abstract virtual IEnumerable`1<MappedResultInfo> GetReducedResultsForDebug(int index, string reduceKey, int level, int start, int take);
    public abstract virtual IEnumerable`1<ScheduledReductionDebugInfo> GetScheduledReductionForDebug(int index, int start, int take);
    public abstract virtual void ScheduleReductions(int index, int level, ReduceKeyAndBucket reduceKeysAndBuckets);
    public abstract virtual IList`1<MappedResultInfo> GetItemsToReduce(GetItemsToReduceParams getItemsToReduceParams, CancellationToken cancellationToken);
    public abstract virtual ScheduledReductionInfo DeleteScheduledReduction(IEnumerable`1<object> itemsToDelete, CancellationToken token);
    public abstract virtual Dictionary`2<int, RemainingReductionPerLevel> GetRemainingScheduledReductionPerIndex();
    public abstract virtual void DeleteScheduledReduction(int index, int level, string reduceKey);
    public abstract virtual void PutReducedResult(int index, string reduceKey, int level, int sourceBucket, int bucket, RavenJObject data);
    public abstract virtual void RemoveReduceResults(int index, int level, string reduceKey, int sourceBucket);
    public abstract virtual IEnumerable`1<ReduceTypePerKey> GetReduceTypesPerKeys(int index, int take, int limitOfItemsToReduceInSingleStep, Action`1<string> onError, CancellationToken cancellationToken);
    public abstract virtual void UpdatePerformedReduceType(int index, string reduceKey, ReduceType performedReduceType, bool skipAdd);
    public abstract virtual ReduceType GetLastPerformedReduceType(int index, string reduceKey);
    public abstract virtual IEnumerable`1<int> GetMappedBuckets(int index, string reduceKey, CancellationToken cancellationToken);
    public abstract virtual List`1<MappedResultInfo> GetMappedResults(int view, HashSet`1<string> keysLeftToReduce, bool loadData, int take, HashSet`1<string> keysReturned, CancellationToken cancellationToken, List`1<MappedResultInfo> outputCollection);
    public abstract virtual IEnumerable`1<ReduceTypePerKey> GetReduceKeysAndTypes(int view, int start, int take);
    public abstract virtual Dictionary`2<int, long> DeleteObsoleteScheduledReductions(List`1<int> mapReduceIndexIds, long delete);
}
public class Raven.Database.Storage.IncrementalBackupState : object {
    [CompilerGeneratedAttribute]
private Guid <ResourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    public Guid ResourceId { get; public set; }
    public string ResourceName { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_ResourceId();
    [CompilerGeneratedAttribute]
public void set_ResourceId(Guid value);
    [CompilerGeneratedAttribute]
public string get_ResourceName();
    [CompilerGeneratedAttribute]
public void set_ResourceName(string value);
}
public enum Raven.Database.Storage.IndexCreationOptions : Enum {
    public int value__;
    public static IndexCreationOptions Noop;
    public static IndexCreationOptions Update;
    public static IndexCreationOptions Create;
    public static IndexCreationOptions UpdateWithoutUpdatingCompiledIndex;
}
public class Raven.Database.Storage.IndexDefinitionStorage : object {
    public static string IndexVersionKey;
    public static string TransformerVersionKey;
    private static string IndexDefDir;
    private ReaderWriterLockSlim currentlyIndexingLock;
    public long currentlyIndexing;
    private ConcurrentDictionary`2<int, AbstractViewGenerator> indexCache;
    private ConcurrentDictionary`2<int, AbstractTransformer> transformCache;
    private ConcurrentDictionary`2<string, int> indexNameToId;
    private ConcurrentDictionary`2<string, int> transformNameToId;
    private ConcurrentDictionary`2<int, TransformerDefinition> transformDefinitions;
    private ConcurrentDictionary`2<int, IndexDefinition> indexDefinitions;
    private ConcurrentDictionary`2<int, IndexDefinition> newDefinitionsThisSession;
    private static ILog logger;
    private string path;
    private InMemoryRavenConfiguration configuration;
    private ITransactionalStorage transactionalStorage;
    private OrderedPartCollection`1<AbstractDynamicCompilationExtension> extensions;
    public int IndexesCount { get; }
    public int ResultTransformersCount { get; }
    public String[] IndexNames { get; }
    public Int32[] Indexes { get; }
    public string IndexDefinitionsPath { get; }
    public String[] TransformerNames { get; }
    public ConcurrentDictionary`2<int, IndexDefinition> IndexDefinitions { get; }
    [CLSCompliantAttribute("False")]
public IndexDefinitionStorage(InMemoryRavenConfiguration configuration, ITransactionalStorage transactionalStorage, string path, OrderedPartCollection`1<AbstractDynamicCompilationExtension> extensions);
    private static IndexDefinitionStorage();
    internal Dictionary`2<int, IndexFailDetails> Initialize();
    public bool IsNewThisSession(IndexDefinition definition);
    private Dictionary`2<int, IndexFailDetails> ReadFromDisk();
    private IEnumerable`1<IndexDefinition> ReadIndexDefinitionsFromDisk();
    private IEnumerable`1<TransformerDefinition> ReadTransformerDefinitionsFromDisk();
    private void RemoveIndexAndCleanup(string name);
    public int get_IndexesCount();
    public int get_ResultTransformersCount();
    public String[] get_IndexNames();
    public Int32[] get_Indexes();
    public string get_IndexDefinitionsPath();
    public String[] get_TransformerNames();
    public ConcurrentDictionary`2<int, IndexDefinition> get_IndexDefinitions();
    public string CreateAndPersistIndex(IndexDefinition indexDefinition);
    private void WriteIndexDefinition(IndexDefinition indexDefinition);
    private void WriteTransformerDefinition(TransformerDefinition transformerDefinition);
    [CLSCompliantAttribute("False")]
public string CreateTransform(TransformerDefinition transformerDefinition, AbstractTransformer transformer);
    [CLSCompliantAttribute("False")]
public void PersistTransform(TransformerDefinition transformerDefinition);
    public void UpdateIndexDefinitionWithoutUpdatingCompiledIndex(IndexDefinition definition);
    private DynamicViewCompiler AddAndCompileIndex(IndexDefinition indexDefinition);
    [CLSCompliantAttribute("False")]
public AbstractTransformer CompileTransform(TransformerDefinition transformerDefinition);
    public void RegisterNewIndexInThisSession(string name, IndexDefinition definition);
    public void AddIndex(int id, IndexDefinition definition);
    public void AddTransform(int id, TransformerDefinition definition);
    public void RemoveIndex(int id, bool removeByNameMapping);
    private string GetIndexSourcePath(int id);
    public IndexDefinition GetIndexDefinition(string name);
    public IndexDefinition GetIndexDefinition(int id);
    public TransformerDefinition GetTransformerDefinition(string name);
    public IEnumerable`1<TransformerDefinition> GetAllTransformerDefinitions();
    public IndexMergeResults ProposeIndexMergeSuggestions();
    public TransformerDefinition GetTransformerDefinition(int id);
    [CLSCompliantAttribute("False")]
public AbstractViewGenerator GetViewGenerator(string name);
    [CLSCompliantAttribute("False")]
public AbstractViewGenerator GetViewGenerator(int id);
    public IndexCreationOptions FindIndexCreationOptions(IndexDefinition newIndexDef);
    private bool CheckIfIndexHasBeenDeleted(IndexDefinition definition);
    private bool CheckIfIndexVersionIsEqualOrSmaller(string listName, string listKey, int currentIndexVersion, string indexName, Int32& oldIndexVersion);
    public int GetDeletedIndexVersion(string indexName, int indexId);
    public bool Contains(string indexName);
    public static void ResolveAnalyzers(IndexDefinition indexDefinition);
    public IDisposable TryRemoveIndexContext();
    public bool IsCurrentlyIndexing();
    [CLSCompliantAttribute("False")]
public IDisposable CurrentlyIndexing();
    public bool RemoveTransformer(string name);
    public void RemoveIndex(string name);
    public void RemoveTransformer(int id);
    [CLSCompliantAttribute("False")]
public AbstractTransformer GetTransformer(int id);
    [CLSCompliantAttribute("False")]
public AbstractTransformer GetTransformer(string name);
    internal bool RenameIndex(string existingIndexName, string newIndexName);
    internal bool ReplaceIndex(string indexName, string indexToSwapName, Action replaceIndexingErrors);
    private void UpdateIndexMappingFile();
    private void UpdateTransformerMappingFile();
    public void UpdateTransformerDefinitionWithoutUpdatingCompiledTransformer(TransformerDefinition definition);
    [CompilerGeneratedAttribute]
private void <CurrentlyIndexing>b__67_0();
}
internal class Raven.Database.Storage.IntDescComparer : object {
    public sealed virtual int Compare(int x, int y);
}
public enum Raven.Database.Storage.InvokeSource : Enum {
    public int value__;
    public static InvokeSource Default;
    public static InvokeSource FromConflictAtReplication;
}
public interface Raven.Database.Storage.IQueueStorageActions {
    public abstract virtual void EnqueueToQueue(string name, Byte[] data);
    public abstract virtual IEnumerable`1<Tuple`2<Byte[], object>> PeekFromQueue(string name);
    public abstract virtual void DeleteFromQueue(string name, object id);
}
public interface Raven.Database.Storage.IStalenessStorageActions {
    public abstract virtual bool IsIndexStale(int view, Nullable`1<DateTime> cutOff, Etag cutoffEtag);
    public abstract virtual bool IsIndexStaleByTask(int view, Nullable`1<DateTime> cutOff);
    public abstract virtual bool IsReduceStale(int view);
    public abstract virtual bool IsMapStale(int view);
    public abstract virtual Tuple`2<DateTime, Etag> IndexLastUpdatedAt(int view);
    public abstract virtual Etag GetMostRecentDocumentEtag();
    [ObsoleteAttribute("Use RavenFS instead.")]
public abstract virtual Etag GetMostRecentAttachmentEtag();
    public abstract virtual int GetIndexTouchCount(int view);
}
public interface Raven.Database.Storage.IStorageActionsAccessor {
    public IDocumentStorageActions Documents { get; }
    public IQueueStorageActions Queue { get; }
    public IListsStorageActions Lists { get; }
    public ITasksStorageActions Tasks { get; }
    public IStalenessStorageActions Staleness { get; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public IAttachmentsStorageActions Attachments { get; }
    public IIndexingStorageActions Indexing { get; }
    public IGeneralStorageActions General { get; }
    public IMappedResultsStorageAction MapReduce { get; }
    public IInFlightStateSnapshot InFlightStateSnapshot { get; }
    public bool IsNested { get; public set; }
    public abstract virtual IDocumentStorageActions get_Documents();
    public abstract virtual IQueueStorageActions get_Queue();
    public abstract virtual IListsStorageActions get_Lists();
    public abstract virtual ITasksStorageActions get_Tasks();
    public abstract virtual IStalenessStorageActions get_Staleness();
    public abstract virtual IAttachmentsStorageActions get_Attachments();
    public abstract virtual IIndexingStorageActions get_Indexing();
    public abstract virtual IGeneralStorageActions get_General();
    public abstract virtual IMappedResultsStorageAction get_MapReduce();
    public abstract virtual IInFlightStateSnapshot get_InFlightStateSnapshot();
    public abstract virtual bool get_IsNested();
    public abstract virtual void set_IsNested(bool value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterStorageCommit(Action value);
    public abstract virtual T GetTask(Func`2<T, bool> predicate, T newTask);
    public abstract virtual void AfterStorageCommitBeforeWorkNotifications(JsonDocument doc, Action`1<JsonDocument[]> afterCommit);
}
public interface Raven.Database.Storage.ITasksStorageActions {
    public bool HasTasks { get; }
    public long ApproximateTaskCount { get; }
    public abstract virtual void AddTask(DatabaseTask task, DateTime addedAt);
    public abstract virtual bool get_HasTasks();
    public abstract virtual long get_ApproximateTaskCount();
    public abstract virtual T GetMergedTask(List`1<int> indexesToSkip, Int32[] allIndexes, HashSet`1<IComparable> alreadySeen);
    public abstract virtual IEnumerable`1<TaskMetadata> GetPendingTasksForDebug();
    public abstract virtual void DeleteTasks(HashSet`1<IComparable> alreadySeen);
    public abstract virtual int DeleteTasksForIndex(int indexId);
}
public interface Raven.Database.Storage.ITransactionalStorage {
    public Guid Id { get; }
    public IDocumentCacher DocumentCacher { get; }
    public bool SkipConsistencyCheck { get; }
    public string FriendlyName { get; }
    public bool IsAlreadyInBatch { get; }
    public bool SupportsDtc { get; }
    public abstract virtual Guid get_Id();
    public abstract virtual IDocumentCacher get_DocumentCacher();
    public abstract virtual IDisposable DisableBatchNesting();
    public abstract virtual IStorageActionsAccessor CreateAccessor();
    public abstract virtual bool get_SkipConsistencyCheck();
    public abstract virtual void Batch(Action`1<IStorageActionsAccessor> action);
    public abstract virtual void ExecuteImmediatelyOrRegisterForSynchronization(Action action);
    public abstract virtual void Initialize(IUuidGenerator generator, OrderedPartCollection`1<AbstractDocumentCodec> documentCodecs, Action`1<string> putResourceMarker, Action`2<object, Exception> onError);
    public abstract virtual Task StartBackupOperation(DocumentDatabase database, string backupDestinationDirectory, bool incrementalBackup, DatabaseDocument documentDatabase, ResourceBackupState state, CancellationToken cts);
    public abstract virtual void Restore(DatabaseRestoreRequest restoreRequest, Action`1<string> output, InMemoryRavenConfiguration globalConfiguration);
    public abstract virtual DatabaseSizeInformation GetDatabaseSize();
    public abstract virtual long GetDatabaseCacheSizeInBytes();
    public abstract virtual long GetDatabaseTransactionVersionSizeInBytes();
    public abstract virtual StorageStats GetStorageStats();
    public abstract virtual string get_FriendlyName();
    public abstract virtual bool HandleException(Exception exception);
    public abstract virtual bool get_IsAlreadyInBatch();
    public abstract virtual bool get_SupportsDtc();
    public abstract virtual void Compact(InMemoryRavenConfiguration configuration, Action`1<string> output);
    public abstract virtual Guid ChangeId();
    public abstract virtual void ClearCaches();
    public abstract virtual void DumpAllStorageTables();
    public abstract virtual InFlightTransactionalState InitializeInFlightTransactionalState(DocumentDatabase self, Func`6<string, Etag, RavenJObject, RavenJObject, TransactionInformation, PutResult> put, Func`4<string, Etag, TransactionInformation, bool> delete);
    public abstract virtual IList`1<string> ComputeDetailedStorageInformation(bool computeExactSizes, Action`1<string> progress, CancellationToken token);
    public abstract virtual List`1<TransactionContextData> GetPreparedTransactions();
    public abstract virtual object GetInFlightTransactionsInternalStateForDebugOnly();
    public abstract virtual void DropAllIndexingInformation();
    public abstract virtual ConcurrentDictionary`2<int, RemainingReductionPerLevel> GetScheduledReductionsPerViewAndLevel();
    public abstract virtual void ResetScheduledReductionsTracking();
    public abstract virtual void RegisterTransactionalStorageNotificationHandler(ITransactionalStorageNotificationHandler handler);
}
public interface Raven.Database.Storage.ITransactionalStorageNotificationHandler {
    public abstract virtual void HandleTransactionalStorageNotification();
}
public class Raven.Database.Storage.ListItem : object {
    public string Key;
    public Etag Etag;
    public RavenJObject Data;
    public DateTime CreatedAt;
}
public class Raven.Database.Storage.MappedResultInfo : object {
    [CompilerGeneratedAttribute]
private string <ReduceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Bucket>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private RavenJObject <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    public string ReduceKey { get; public set; }
    public int Bucket { get; public set; }
    public DateTime Timestamp { get; public set; }
    public Etag Etag { get; public set; }
    public RavenJObject Data { get; public set; }
    public string Source { get; public set; }
    [JsonIgnoreAttribute]
public int Size { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ReduceKey();
    [CompilerGeneratedAttribute]
public void set_ReduceKey(string value);
    [CompilerGeneratedAttribute]
public int get_Bucket();
    [CompilerGeneratedAttribute]
public void set_Bucket(int value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public RavenJObject get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(RavenJObject value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    public virtual string ToString();
}
public class Raven.Database.Storage.ReduceKeyAndBucket : object {
    public int Bucket;
    public string ReduceKey;
    public ReduceKeyAndBucket(int bucket, string reduceKey);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Raven.Database.Storage.ReduceKeyAndBucketEqualityComparer : object {
    public static ReduceKeyAndBucketEqualityComparer Instance;
    private static ReduceKeyAndBucketEqualityComparer();
    public sealed virtual bool Equals(ReduceKeyAndBucket x, ReduceKeyAndBucket y);
    public sealed virtual int GetHashCode(ReduceKeyAndBucket obj);
}
public class Raven.Database.Storage.ReduceKeyAndCount : object {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public int Count { get; public set; }
    public string Key { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
}
public class Raven.Database.Storage.ReduceTypePerKey : object {
    [CompilerGeneratedAttribute]
private string <ReduceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private ReduceType <OperationTypeToPerform>k__BackingField;
    public string ReduceKey { get; public set; }
    public ReduceType OperationTypeToPerform { get; public set; }
    public ReduceTypePerKey(string reduceKey, ReduceType type);
    [CompilerGeneratedAttribute]
public string get_ReduceKey();
    [CompilerGeneratedAttribute]
public void set_ReduceKey(string value);
    [CompilerGeneratedAttribute]
public ReduceType get_OperationTypeToPerform();
    [CompilerGeneratedAttribute]
public void set_OperationTypeToPerform(ReduceType value);
}
public class Raven.Database.Storage.RemainingReductionPerLevel : object {
    private long remainingReductionsLevel0;
    private long remainingReductionsLevel1;
    private long remainingReductionsLevel2;
    public long RemainingReductionsLevel0 { get; }
    public long RemainingReductionsLevel1 { get; }
    public long RemainingReductionsLevel2 { get; }
    public RemainingReductionPerLevel(int level);
    public long get_RemainingReductionsLevel0();
    public long get_RemainingReductionsLevel1();
    public long get_RemainingReductionsLevel2();
    public RemainingReductionPerLevel IncrementPerLevelCounters(int level);
    public RemainingReductionPerLevel DecrementPerLevelCounters(int level);
    public RemainingReductionPerLevel Add(RemainingReductionPerLevel other);
}
public class Raven.Database.Storage.ScheduledReductionDebugInfo : object {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Bucket>k__BackingField;
    public DateTime Timestamp { get; public set; }
    public Guid Etag { get; public set; }
    public string Key { get; public set; }
    public int Level { get; public set; }
    public int Bucket { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Guid get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Guid value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(int value);
    [CompilerGeneratedAttribute]
public int get_Bucket();
    [CompilerGeneratedAttribute]
public void set_Bucket(int value);
}
public class Raven.Database.Storage.ScheduledReductionInfo : object {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    public DateTime Timestamp { get; public set; }
    public Etag Etag { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
}
internal static class Raven.Database.Storage.StringHelper : object {
    public static bool Compare(string startsWith, string docId, bool exactMatch);
}
public static class Raven.Database.Storage.TransactionalStorageHelper : object {
    public static bool IsWriteConflict(Exception exception, Exception& conflictException);
    private static bool IsVoronWriteConflict(Exception exception);
    public static bool IsEsentWriteConflict(Exception exception);
    public static bool IsOutOfMemoryException(Exception exception);
    public static bool IsVoronOutOfMemoryException(Exception exception);
    private static bool IsEsentOutOfMemoryException(Exception exception);
}
public class Raven.Database.Storage.TransactionContextData : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfActionsAfterCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAlreadyInContext>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <DocumentIdsToTouch>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <DocumentTombstonesToTouch>k__BackingField;
    public string Id { get; public set; }
    public DateTime CreatedAt { get; public set; }
    public int NumberOfActionsAfterCommit { get; public set; }
    public bool IsAlreadyInContext { get; public set; }
    public List`1<string> DocumentIdsToTouch { get; public set; }
    public List`1<string> DocumentTombstonesToTouch { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public DateTime get_CreatedAt();
    [CompilerGeneratedAttribute]
public void set_CreatedAt(DateTime value);
    [CompilerGeneratedAttribute]
public int get_NumberOfActionsAfterCommit();
    [CompilerGeneratedAttribute]
public void set_NumberOfActionsAfterCommit(int value);
    [CompilerGeneratedAttribute]
public bool get_IsAlreadyInContext();
    [CompilerGeneratedAttribute]
public void set_IsAlreadyInContext(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_DocumentIdsToTouch();
    [CompilerGeneratedAttribute]
public void set_DocumentIdsToTouch(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_DocumentTombstonesToTouch();
    [CompilerGeneratedAttribute]
public void set_DocumentTombstonesToTouch(List`1<string> value);
}
internal class Raven.Database.Storage.Voron.Backup.BackupOperation : BaseBackupOperation {
    private StorageEnvironment env;
    protected bool BackupAlreadyExists { get; }
    public BackupOperation(DocumentDatabase database, string backupSourceDirectory, string backupDestinationDirectory, StorageEnvironment env, bool incrementalBackup, DatabaseDocument databaseDocument, ResourceBackupState state, CancellationToken cancellationToken);
    protected virtual bool get_BackupAlreadyExists();
    protected virtual void ExecuteBackup(string backupPath, bool isIncrementalBackup, CancellationToken token);
    public sealed virtual void Dispose();
    protected virtual bool CanPerformIncrementalBackup();
    [CompilerGeneratedAttribute]
private void <ExecuteBackup>b__4_0(string s);
    [CompilerGeneratedAttribute]
private void <ExecuteBackup>b__4_1(string s);
}
internal class Raven.Database.Storage.Voron.Backup.RestoreOperation : BaseRestoreOperation {
    public RestoreOperation(DatabaseRestoreRequest restoreRequest, InMemoryRavenConfiguration configuration, InMemoryRavenConfiguration globalConfiguration, Action`1<string> operationOutputCallback);
    private string GenerateJournalLocation(DatabaseRestoreRequest databaseRestoreRequest, InMemoryRavenConfiguration configuration);
    protected virtual bool IsValidBackup(string backupFilename);
    public virtual void Execute();
}
internal class Raven.Database.Storage.Voron.Impl.Index : TableBase {
    public Index(string indexName, IBufferPool bufferPool);
}
internal class Raven.Database.Storage.Voron.Impl.Table : TableBase {
    private ConcurrentDictionary`2<string, Index> tableIndexes;
    public Table(string tableName, IBufferPool bufferPool, String[] indexNames);
    public Index GetIndex(string indexName);
    public string GetIndexKey(string indexName);
    [CompilerGeneratedAttribute]
private Index <GetIndex>b__2_0(string indexTreeName);
}
internal abstract class Raven.Database.Storage.Voron.Impl.TableBase : object {
    [CompilerGeneratedAttribute]
private IBufferPool <BufferPool>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    protected IBufferPool BufferPool { get; private set; }
    public string TableName { get; private set; }
    protected TableBase(string tableName, IBufferPool bufferPool);
    [CompilerGeneratedAttribute]
protected IBufferPool get_BufferPool();
    [CompilerGeneratedAttribute]
private void set_BufferPool(IBufferPool value);
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
private void set_TableName(string value);
    public virtual void Add(WriteBatch writeBatch, string key, string value, Nullable`1<ushort> expectedVersion);
    public virtual void Add(WriteBatch writeBatch, string key, Byte[] value, Nullable`1<ushort> expectedVersion);
    public virtual void Add(WriteBatch writeBatch, Slice key, Stream value, Nullable`1<ushort> expectedVersion, bool shouldIgnoreConcurrencyExceptions);
    public virtual void Add(WriteBatch writeBatch, Slice key, RavenJToken value, Nullable`1<ushort> expectedVersion);
    public virtual void Add(WriteBatch writeBatch, Slice key, string value, Nullable`1<ushort> expectedVersion);
    public virtual void Add(WriteBatch writeBatch, Slice key, Byte[] value, Nullable`1<ushort> expectedVersion);
    public virtual void Increment(WriteBatch writeBatch, Slice key, long delta, Nullable`1<ushort> expectedVersion);
    public virtual void MultiAdd(WriteBatch writeBatch, Slice key, Slice value, Nullable`1<ushort> expectedVersion);
    public virtual ReadResult Read(SnapshotReader snapshot, Slice key, WriteBatch writeBatch);
    public virtual IIterator MultiRead(SnapshotReader snapshot, Slice key);
    public virtual IIterator Iterate(SnapshotReader snapshot, WriteBatch writeBatch);
    public bool Contains(SnapshotReader snapshot, Slice key, WriteBatch writeBatch);
    public bool Contains(SnapshotReader snapshot, Slice key, WriteBatch writeBatch, Nullable`1& version);
    public int GetDataSize(SnapshotReader snapshot, Slice key);
    public virtual void Delete(WriteBatch writeBatch, string key, Nullable`1<ushort> expectedVersion);
    public virtual void Delete(WriteBatch writeBatch, Slice key, Nullable`1<ushort> expectedVersion, bool shouldIgnoreConcurrencyExceptions);
    public virtual void MultiDelete(WriteBatch writeBatch, Slice key, Slice value, Nullable`1<ushort> expectedVersion);
    public virtual Nullable`1<ushort> ReadVersion(SnapshotReader snapshot, Slice key, WriteBatch writeBatch);
    protected void AssertKey(Slice key);
    public Dictionary`2<string, string> Dump(SnapshotReader snapshot);
}
internal class Raven.Database.Storage.Voron.Impl.TableOfStructures`1 : Table {
    public StructureSchema`1<T> Schema;
    public TableOfStructures`1(string tableName, StructureSchema`1<T> schema, IBufferPool bufferPool, String[] indexNames);
    public virtual StructReadResult`1<T> ReadStruct(SnapshotReader snapshot, Slice key, WriteBatch writeBatch);
    public virtual void AddStruct(WriteBatch writeBatch, Slice key, IStructure value, Nullable`1<ushort> expectedVersion, bool shouldIgnoreConcurrencyExceptions);
}
public class Raven.Database.Storage.Voron.Impl.Tables : object {
}
internal class Raven.Database.Storage.Voron.Impl.TableStorage : object {
    private StorageEnvironmentOptions _options;
    private IBufferPool bufferPool;
    private StorageEnvironment env;
    [CompilerGeneratedAttribute]
private Table <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOfStructures`1<IndexingWorkStatsFields> <IndexingStats>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOfStructures`1<ReducingWorkStatsFields> <ReduceStats>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <IndexingMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOfStructures`1<LastIndexedStatsFields> <LastIndexedEtags>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOfStructures`1<DocumentReferencesFields> <DocumentReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Queues>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Lists>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOfStructures`1<TaskFields> <Tasks>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOfStructures`1<ScheduledReductionFields> <ScheduledReductions>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOfStructures`1<MappedResultFields> <MappedResults>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOfStructures`1<ReduceResultFields> <ReduceResults>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Attachments>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOfStructures`1<ReduceKeyCountFields> <ReduceKeyCounts>k__BackingField;
    [CompilerGeneratedAttribute]
private TableOfStructures`1<ReduceKeyTypeFields> <ReduceKeyTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <General>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Table Details { get; private set; }
    public Table Documents { get; private set; }
    public TableOfStructures`1<IndexingWorkStatsFields> IndexingStats { get; private set; }
    public TableOfStructures`1<ReducingWorkStatsFields> ReduceStats { get; private set; }
    public Table IndexingMetadata { get; private set; }
    public TableOfStructures`1<LastIndexedStatsFields> LastIndexedEtags { get; private set; }
    public TableOfStructures`1<DocumentReferencesFields> DocumentReferences { get; private set; }
    public Table Queues { get; private set; }
    public Table Lists { get; private set; }
    public TableOfStructures`1<TaskFields> Tasks { get; private set; }
    public TableOfStructures`1<ScheduledReductionFields> ScheduledReductions { get; private set; }
    public TableOfStructures`1<MappedResultFields> MappedResults { get; private set; }
    public TableOfStructures`1<ReduceResultFields> ReduceResults { get; private set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public Table Attachments { get; private set; }
    public TableOfStructures`1<ReduceKeyCountFields> ReduceKeyCounts { get; private set; }
    public TableOfStructures`1<ReduceKeyTypeFields> ReduceKeyTypes { get; private set; }
    public Table General { get; private set; }
    public StorageEnvironment Environment { get; }
    public string SchemaVersion { get; private set; }
    public Guid Id { get; private set; }
    public TableStorage(StorageEnvironmentOptions options, IBufferPool bufferPool);
    internal StorageReport GenerateReportOnStorage(bool computeExactSizes, Action`1<string> progress, CancellationToken token);
    public SnapshotReader CreateSnapshot();
    [CompilerGeneratedAttribute]
public Table get_Details();
    [CompilerGeneratedAttribute]
private void set_Details(Table value);
    [CompilerGeneratedAttribute]
public Table get_Documents();
    [CompilerGeneratedAttribute]
private void set_Documents(Table value);
    [CompilerGeneratedAttribute]
public TableOfStructures`1<IndexingWorkStatsFields> get_IndexingStats();
    [CompilerGeneratedAttribute]
private void set_IndexingStats(TableOfStructures`1<IndexingWorkStatsFields> value);
    [CompilerGeneratedAttribute]
public TableOfStructures`1<ReducingWorkStatsFields> get_ReduceStats();
    [CompilerGeneratedAttribute]
private void set_ReduceStats(TableOfStructures`1<ReducingWorkStatsFields> value);
    [CompilerGeneratedAttribute]
public Table get_IndexingMetadata();
    [CompilerGeneratedAttribute]
private void set_IndexingMetadata(Table value);
    [CompilerGeneratedAttribute]
public TableOfStructures`1<LastIndexedStatsFields> get_LastIndexedEtags();
    [CompilerGeneratedAttribute]
private void set_LastIndexedEtags(TableOfStructures`1<LastIndexedStatsFields> value);
    [CompilerGeneratedAttribute]
public TableOfStructures`1<DocumentReferencesFields> get_DocumentReferences();
    [CompilerGeneratedAttribute]
private void set_DocumentReferences(TableOfStructures`1<DocumentReferencesFields> value);
    [CompilerGeneratedAttribute]
public Table get_Queues();
    [CompilerGeneratedAttribute]
private void set_Queues(Table value);
    [CompilerGeneratedAttribute]
public Table get_Lists();
    [CompilerGeneratedAttribute]
private void set_Lists(Table value);
    [CompilerGeneratedAttribute]
public TableOfStructures`1<TaskFields> get_Tasks();
    [CompilerGeneratedAttribute]
private void set_Tasks(TableOfStructures`1<TaskFields> value);
    [CompilerGeneratedAttribute]
public TableOfStructures`1<ScheduledReductionFields> get_ScheduledReductions();
    [CompilerGeneratedAttribute]
private void set_ScheduledReductions(TableOfStructures`1<ScheduledReductionFields> value);
    [CompilerGeneratedAttribute]
public TableOfStructures`1<MappedResultFields> get_MappedResults();
    [CompilerGeneratedAttribute]
private void set_MappedResults(TableOfStructures`1<MappedResultFields> value);
    [CompilerGeneratedAttribute]
public TableOfStructures`1<ReduceResultFields> get_ReduceResults();
    [CompilerGeneratedAttribute]
private void set_ReduceResults(TableOfStructures`1<ReduceResultFields> value);
    [CompilerGeneratedAttribute]
public Table get_Attachments();
    [CompilerGeneratedAttribute]
private void set_Attachments(Table value);
    [CompilerGeneratedAttribute]
public TableOfStructures`1<ReduceKeyCountFields> get_ReduceKeyCounts();
    [CompilerGeneratedAttribute]
private void set_ReduceKeyCounts(TableOfStructures`1<ReduceKeyCountFields> value);
    [CompilerGeneratedAttribute]
public TableOfStructures`1<ReduceKeyTypeFields> get_ReduceKeyTypes();
    [CompilerGeneratedAttribute]
private void set_ReduceKeyTypes(TableOfStructures`1<ReduceKeyTypeFields> value);
    [CompilerGeneratedAttribute]
public Table get_General();
    [CompilerGeneratedAttribute]
private void set_General(Table value);
    public StorageEnvironment get_Environment();
    public void Write(WriteBatch writeBatch);
    public long GetEntriesCount(TableBase table);
    public void RenderAndShow(TableBase table, int showEntries);
    public void RenderAndShow(Transaction tx, TableBase table, int showEntries);
    public sealed virtual void Dispose();
    private void Initialize();
    private static string FindGraphviz();
    public void SetDatabaseIdAndSchemaVersion(Guid id, string schemaVersion);
    [CompilerGeneratedAttribute]
public string get_SchemaVersion();
    [CompilerGeneratedAttribute]
private void set_SchemaVersion(string value);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
}
[InheritedExportAttribute]
internal interface Raven.Database.Storage.Voron.Schema.ISchemaUpdate {
    public string FromSchemaVersion { get; }
    public string ToSchemaVersion { get; }
    public abstract virtual string get_FromSchemaVersion();
    public abstract virtual string get_ToSchemaVersion();
    public abstract virtual void Update(TableStorage tableStorage, Action`1<string> output);
    public abstract virtual void UpdateSchemaVersion(TableStorage tableStorage, Action`1<string> output);
}
internal class Raven.Database.Storage.Voron.Schema.SchemaCreator : object {
    internal TableStorage storage;
    private Action`1<string> output;
    private ILog log;
    public static string SchemaVersion;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<ISchemaUpdate> <Updaters>k__BackingField;
    private static object UpdateLocker;
    [ImportManyAttribute]
public OrderedPartCollection`1<ISchemaUpdate> Updaters { get; public set; }
    public SchemaCreator(InMemoryRavenConfiguration configuration, TableStorage storage, Action`1<string> output, ILog log);
    private static SchemaCreator();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<ISchemaUpdate> get_Updaters();
    [CompilerGeneratedAttribute]
public void set_Updaters(OrderedPartCollection`1<ISchemaUpdate> value);
    public void CreateSchema();
    public void SetupDatabaseIdAndSchemaVersion();
    public void UpdateSchemaIfNecessary();
    internal static void CreateIndexingMetadataSchema(Transaction tx, TableStorage storage);
    internal static void CreateReduceStatsSchema(Transaction tx, TableStorage storage);
    internal static void CreateReduceResultsSchema(Transaction tx, TableStorage storage);
    internal static void CreateReduceKeyCountsSchema(Transaction tx, TableStorage storage);
    internal static void CreateReduceKeyTypesSchema(Transaction tx, TableStorage storage);
    [ObsoleteAttribute("Use RavenFS instead.")]
private static void CreateAttachmentsSchema(Transaction tx, TableStorage storage);
    internal static void CreateMappedResultsSchema(Transaction tx, TableStorage storage);
    internal static void CreateScheduledReductionsSchema(Transaction tx, TableStorage storage);
    internal static void CreateStalenessSchema(Transaction tx, TableStorage storage);
    internal static void CreateTasksSchema(Transaction tx, TableStorage storage);
    private static void CreateListsSchema(Transaction tx, TableStorage storage);
    private static void CreateQueuesSchema(Transaction tx, TableStorage storage);
    internal static void CreateDocumentReferencesSchema(Transaction tx, TableStorage storage);
    internal static void CreateLastIndexedEtagsSchema(Transaction tx, TableStorage storage);
    internal static void CreateIndexingStatsSchema(Transaction tx, TableStorage storage);
    private static void CreateDetailsSchema(Transaction tx, TableStorage storage);
    private static void CreateDocumentsSchema(Transaction tx, TableStorage storage);
    private static void CreateGeneralSchema(Transaction tx, TableStorage storage);
    [CompilerGeneratedAttribute]
private void <UpdateSchemaIfNecessary>b__12_0();
    [CompilerGeneratedAttribute]
private void <UpdateSchemaIfNecessary>b__12_1();
    [CompilerGeneratedAttribute]
private bool <UpdateSchemaIfNecessary>b__12_2(Lazy`2<ISchemaUpdate, IPartMetadata> update);
}
internal class Raven.Database.Storage.Voron.Schema.Updates.From10To11 : SchemaUpdateBase {
    public string FromSchemaVersion { get; }
    public string ToSchemaVersion { get; }
    public virtual string get_FromSchemaVersion();
    public virtual string get_ToSchemaVersion();
    public virtual void Update(TableStorage tableStorage, Action`1<string> output);
}
internal class Raven.Database.Storage.Voron.Schema.Updates.From11To12 : SchemaUpdateBase {
    public string FromSchemaVersion { get; }
    public string ToSchemaVersion { get; }
    public virtual string get_FromSchemaVersion();
    public virtual string get_ToSchemaVersion();
    public virtual void Update(TableStorage tableStorage, Action`1<string> output);
    public void MigrateToStructures(StorageEnvironment env, TableOfStructures`1<T> table, Action`1<string> output, Action`2<RavenJObject, Structure`1<T>> copyToStructure);
}
internal class Raven.Database.Storage.Voron.Schema.Updates.From12To13 : SchemaUpdateBase {
    public string FromSchemaVersion { get; }
    public string ToSchemaVersion { get; }
    public virtual string get_FromSchemaVersion();
    public virtual string get_ToSchemaVersion();
    public virtual void Update(TableStorage tableStorage, Action`1<string> output);
    private void MigrateIndexes(TableStorage tableStorage, Action`1<string> output, string tableName, Func`2<Transaction, TState> initState, Action`2<TState, TreeIterator> processEntry);
    protected Slice CreateViewKey(int view);
    private Slice CreateBucketAndEtagKey(int bucket, Etag id);
    private Slice CreateScheduleReductionKey(int view, int level, string reduceKey);
    private Slice CreateReduceResultsKey(int view, string reduceKey, int level);
    private Slice CreateReduceResultsWithBucketKey(int view, string reduceKey, int level, int bucket);
    private Slice CreateMappedResultKey(int view, string reduceKey);
    private Slice CreateMappedResultWithBucketKey(int view, string reduceKey, int bucket);
}
internal class Raven.Database.Storage.Voron.Schema.Updates.From13To14 : SchemaUpdateBase {
    public string FromSchemaVersion { get; }
    public string ToSchemaVersion { get; }
    public virtual string get_FromSchemaVersion();
    public virtual string get_ToSchemaVersion();
    public virtual void Update(TableStorage tableStorage, Action`1<string> output);
}
internal class Raven.Database.Storage.Voron.Schema.Updates.From14To15 : SchemaUpdateBase {
    public string FromSchemaVersion { get; }
    public string ToSchemaVersion { get; }
    public virtual string get_FromSchemaVersion();
    public virtual string get_ToSchemaVersion();
    public virtual void Update(TableStorage tableStorage, Action`1<string> output);
}
internal abstract class Raven.Database.Storage.Voron.Schema.Updates.SchemaUpdateBase : object {
    public string FromSchemaVersion { get; }
    public string ToSchemaVersion { get; }
    public abstract virtual string get_FromSchemaVersion();
    public abstract virtual string get_ToSchemaVersion();
    public abstract virtual void Update(TableStorage tableStorage, Action`1<string> output);
    public sealed virtual void UpdateSchemaVersion(TableStorage tableStorage, Action`1<string> output);
}
[ObsoleteAttribute("Use RavenFS instead.")]
internal class Raven.Database.Storage.Voron.StorageActions.AttachmentsStorageActions : StorageActionsBase {
    private Table attachmentsTable;
    private Reference`1<WriteBatch> writeBatch;
    private IUuidGenerator uuidGenerator;
    private TableStorage tableStorage;
    private Index metadataIndex;
    private TransactionalStorage transactionalStorage;
    private static ILog logger;
    public AttachmentsStorageActions(Table attachmentsTable, Reference`1<WriteBatch> writeBatch, Reference`1<SnapshotReader> snapshot, IUuidGenerator uuidGenerator, TableStorage tableStorage, TransactionalStorage transactionalStorage, IBufferPool bufferPool);
    private static AttachmentsStorageActions();
    public sealed virtual Etag AddAttachment(string key, Etag etag, Stream data, RavenJObject headers);
    public sealed virtual void DeleteAttachment(string key, Etag etag);
    public sealed virtual Attachment GetAttachment(string key);
    public sealed virtual long GetAttachmentsCount();
    internal Stream GetAttachmentStream(Slice key);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.AttachmentsStorageActions/<GetAttachmentsByReverseUpdateOrder>d__13")]
public sealed virtual IEnumerable`1<AttachmentInformation> GetAttachmentsByReverseUpdateOrder(int start);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.AttachmentsStorageActions/<GetAttachmentsAfter>d__14")]
public sealed virtual IEnumerable`1<AttachmentInformation> GetAttachmentsAfter(Etag value, int take, long maxTotalSize);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.AttachmentsStorageActions/<GetAttachmentsStartingWith>d__15")]
public sealed virtual IEnumerable`1<AttachmentInformation> GetAttachmentsStartingWith(string idPrefix, int start, int pageSize);
    private AttachmentInformation AttachmentInfoByKey(string key);
    private Etag ReadCurrentEtag(Slice key);
    private RavenJObject ReadAttachmentMetadata(Slice key, Etag& etag);
    private void WriteAttachmentMetadata(Slice key, Etag etag, RavenJObject headers);
    private bool IsAttachmentEtagMatch(Slice key, Etag etag, Etag& existingEtag);
}
internal class Raven.Database.Storage.Voron.StorageActions.DocumentsStorageActions : StorageActionsBase {
    private Reference`1<WriteBatch> writeBatch;
    private IUuidGenerator uuidGenerator;
    private OrderedPartCollection`1<AbstractDocumentCodec> documentCodecs;
    private IDocumentCacher documentCacher;
    private static ILog logger;
    private Dictionary`2<Etag, Etag> etagTouches;
    private TableStorage tableStorage;
    private Index metadataIndex;
    private static RavenJObject EmptyDocument;
    [CompilerGeneratedAttribute]
private bool <SkipConsistencyCheck>k__BackingField;
    public bool SkipConsistencyCheck { get; public set; }
    public DocumentsStorageActions(IUuidGenerator uuidGenerator, OrderedPartCollection`1<AbstractDocumentCodec> documentCodecs, IDocumentCacher documentCacher, Reference`1<WriteBatch> writeBatch, Reference`1<SnapshotReader> snapshot, TableStorage tableStorage, IBufferPool bufferPool, bool skipConsistencyCheck);
    private static DocumentsStorageActions();
    [CompilerGeneratedAttribute]
public bool get_SkipConsistencyCheck();
    [CompilerGeneratedAttribute]
public void set_SkipConsistencyCheck(bool value);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.DocumentsStorageActions/<GetDocumentsByReverseUpdateOrder>d__14")]
public sealed virtual IEnumerable`1<JsonDocument> GetDocumentsByReverseUpdateOrder(int start, int take, HashSet`1<string> entityNames);
    public sealed virtual Etag GetEtagAfterSkip(Etag etag, int skip, CancellationToken cancellationToken, Int32& skipped);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.DocumentsStorageActions/<GetDocumentsAfterWithIdStartingWith>d__16")]
public sealed virtual IEnumerable`1<JsonDocument> GetDocumentsAfterWithIdStartingWith(Etag etag, string idPrefix, int take, CancellationToken cancellationToken, Nullable`1<long> maxSize, Etag untilEtag, Nullable`1<TimeSpan> timeout, Action`1<Etag> lastProcessedDocument, Reference`1<bool> earlyExit, HashSet`1<string> entityNames, Action`1<List`1<DocumentFetchError>> failedToGetHandler);
    private JsonDocument GetJsonDocument(bool hasEntityNames, string key, HashSet`1<string> entityNames);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.DocumentsStorageActions/<GetDocumentIdsAfterEtag>d__18")]
public sealed virtual IEnumerable`1<string> GetDocumentIdsAfterEtag(Etag etag, int maxTake, Func`4<string, RavenJObject, Func`1<JsonDocument>, bool> filterDocument, Reference`1<bool> earlyExit, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<JsonDocument> GetDocumentsAfter(Etag etag, int take, CancellationToken cancellationToken, Nullable`1<long> maxSize, Etag untilEtag, Nullable`1<TimeSpan> timeout, Action`1<Etag> lastProcessedOnFailure, Reference`1<bool> earlyExit, HashSet`1<string> entityNames, Action`1<List`1<DocumentFetchError>> failedToGetHandler);
    private static string GetKeyFromCurrent(IIterator iterator);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.DocumentsStorageActions/<GetDocumentsWithIdStartingWith>d__21")]
public sealed virtual IEnumerable`1<JsonDocument> GetDocumentsWithIdStartingWith(string idPrefix, int start, int take, string skipAfter);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.DocumentsStorageActions/<GetDocuments>d__22")]
public sealed virtual IEnumerable`1<JsonDocument> GetDocuments(int start);
    public sealed virtual long GetDocumentsCount();
    public sealed virtual Stream RawDocumentByKey(string key);
    public sealed virtual JsonDocument DocumentByKey(string key, bool useDifferentTable);
    public sealed virtual JsonDocumentMetadata DocumentMetadataByKey(string key);
    public sealed virtual bool DeleteDocument(string key, Etag etag, RavenJObject& metadata, Etag& deletedETag);
    public sealed virtual AddDocumentResult AddDocument(string key, Etag etag, RavenJObject data, RavenJObject metadata, InvokeSource source);
    private bool PutDocumentMetadataInternal(string key, Slice normalizedKey, RavenJObject metadata, Etag newEtag, DateTime savedAt);
    public sealed virtual void IncrementDocumentCount(int value);
    public sealed virtual AddDocumentResult InsertDocument(string key, RavenJObject data, RavenJObject metadata, bool overwriteExisting);
    public sealed virtual void TouchDocument(string key, Etag& preTouchEtag, Etag& afterTouchEtag);
    public sealed virtual Etag GetBestNextDocumentEtag(Etag etag);
    private Etag EnsureDocumentEtagMatch(string key, Etag etag, string method);
    private bool WriteDocumentMetadata(JsonDocumentMetadata metadata, Slice key, bool shouldIgnoreConcurrencyExceptions);
    private JsonDocumentMetadata ReadDocumentMetadata(string normalizedKey, Slice sliceKey, Int32& size);
    private bool WriteDocumentData(string key, string normalizedKey, Etag etag, RavenJObject data, RavenJObject metadata, InvokeSource source, Etag& newEtag, Etag& existingEtag, DateTime& savedAt);
    private RavenJObject ReadDocumentData(string normalizedKey, Slice sliceKey, Etag existingEtag, RavenJObject metadata, Int32& size);
    public sealed virtual DebugDocumentStats GetDocumentStatsVerySlowly(Action`1<string> progress, CancellationToken token);
}
internal class Raven.Database.Storage.Voron.StorageActions.GeneralStorageActions : StorageActionsBase {
    private static int PulseTreshold;
    private static ILog logger;
    private TableStorage storage;
    private Reference`1<WriteBatch> writeBatch;
    private Reference`1<SnapshotReader> snapshot;
    private StorageActionsAccessor storageActionsAccessor;
    private int maybePulseCount;
    public GeneralStorageActions(TableStorage storage, Reference`1<WriteBatch> writeBatch, Reference`1<SnapshotReader> snapshot, IBufferPool bufferPool, StorageActionsAccessor storageActionsAccessor);
    private static GeneralStorageActions();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, long>> GetIdentities(int start, int take, Int64& totalCount);
    public sealed virtual long GetNextIdentityValue(string name, int val);
    public sealed virtual void SetIdentityValue(string name, long value);
    public sealed virtual void PulseTransaction();
    public bool MaybePulseTransaction(IIterator before, int addToPulseCount, Action beforePulseTransaction);
    public sealed virtual bool MaybePulseTransaction(int addToPulseCount, Action beforePulseTransaction);
}
internal class Raven.Database.Storage.Voron.StorageActions.IndexingStorageActions : StorageActionsBase {
    private TableStorage tableStorage;
    private Reference`1<WriteBatch> writeBatch;
    private IUuidGenerator generator;
    private IStorageActionsAccessor currentStorageActionsAccessor;
    private GeneralStorageActions generalStorageActions;
    public IndexingStorageActions(TableStorage tableStorage, IUuidGenerator generator, Reference`1<SnapshotReader> snapshot, Reference`1<WriteBatch> writeBatch, IStorageActionsAccessor storageActionsAccessor, IBufferPool bufferPool, GeneralStorageActions generalStorageActions);
    public sealed virtual void Dispose();
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.IndexingStorageActions/<GetIndexesStats>d__7")]
public sealed virtual IEnumerable`1<IndexStats> GetIndexesStats();
    public sealed virtual IndexStats GetIndexStats(int id);
    public sealed virtual void AddIndex(int id, bool createMapReduce);
    public sealed virtual void PrepareIndexForDeletion(int id);
    public sealed virtual void DeleteIndex(int id, CancellationToken token);
    public sealed virtual void SetIndexPriority(int id, IndexingPriority priority);
    public sealed virtual void SetIndexesPriority(Int32[] ids, IndexingPriority[] priorities);
    public sealed virtual IndexFailureInformation GetFailureRate(int id);
    public sealed virtual void UpdateLastIndexed(int id, Etag etag, DateTime timestamp);
    public sealed virtual void UpdateLastReduced(int id, Etag etag, DateTime timestamp);
    public sealed virtual void TouchIndexEtag(int id);
    public sealed virtual void UpdateIndexingStats(int id, IndexingWorkStats stats);
    public sealed virtual void UpdateReduceStats(int id, IndexingWorkStats stats);
    public sealed virtual void RemoveAllDocumentReferencesFrom(string key);
    public void RemoveAllDocumentReferencesByView(int view, CancellationToken token);
    public sealed virtual void UpdateDocumentReferences(int id, string key, HashSet`1<string> references);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.IndexingStorageActions/<GetDocumentsReferencing>d__23")]
public sealed virtual IEnumerable`1<string> GetDocumentsReferencing(string reference);
    public sealed virtual int GetCountOfDocumentsReferencing(string reference);
    public sealed virtual Dictionary`2<string, int> GetDocumentReferencesStats();
    public sealed virtual IEnumerable`1<string> GetDocumentsReferencesFrom(string key);
    public sealed virtual void DumpAllReferancesToCSV(StreamWriter writer, int numberOfSampleDocs);
    private StructureReader`1<T> LoadStruct(TableOfStructures`1<T> table, Slice name, UInt16& version);
    private static IndexStats GetIndexStats(StructureReader`1<IndexingWorkStatsFields> indexingStats, StructureReader`1<ReducingWorkStatsFields> reduceStats, StructureReader`1<LastIndexedStatsFields> lastIndexedEtags, int priority, int touches);
    private void RemoveDocumentReferenceByKey(Slice key);
    private void RemoveDocumentReference(Func`1<IIterator> createIterator, bool tryPulseTransaction, CancellationToken token);
    private int ReadPriority(string key);
    private int ReadTouches(string key);
}
internal class Raven.Database.Storage.Voron.StorageActions.ListsStorageActions : StorageActionsBase {
    private TableStorage tableStorage;
    private IUuidGenerator generator;
    private Reference`1<WriteBatch> writeBatch;
    private GeneralStorageActions generalStorageActions;
    private static ILog Logger;
    public ListsStorageActions(TableStorage tableStorage, IUuidGenerator generator, Reference`1<SnapshotReader> snapshot, Reference`1<WriteBatch> writeBatch, IBufferPool bufferPool, GeneralStorageActions generalStorageActions);
    private static ListsStorageActions();
    public sealed virtual Etag Set(string name, string key, RavenJObject data, UuidType type);
    public sealed virtual void Remove(string name, string key);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.ListsStorageActions/<Read>d__8")]
public sealed virtual IEnumerable`1<ListItem> Read(string name, Etag start, Etag end, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.ListsStorageActions/<Read>d__9")]
public sealed virtual IEnumerable`1<ListItem> Read(string name, int start, int take);
    public sealed virtual ListItem Read(string name, string key);
    public sealed virtual ListItem ReadLast(string name);
    public sealed virtual void RemoveAllBefore(string name, Etag etag, Nullable`1<TimeSpan> timeout);
    public sealed virtual void RemoveAllOlderThan(string name, DateTime cutoff);
    public sealed virtual void Touch(string name, string key, UuidType uuidType, Etag& preTouchEtag, Etag& afterTouchEtag);
    public sealed virtual List`1<ListsInfo> GetListsStatsVerySlowly();
    private ListItem ReadInternal(string id);
}
internal class Raven.Database.Storage.Voron.StorageActions.MappedResultsStorageActions : StorageActionsBase {
    private TableStorage tableStorage;
    private IUuidGenerator generator;
    private Reference`1<WriteBatch> writeBatch;
    private IStorageActionsAccessor storageActionsAccessor;
    private OrderedPartCollection`1<AbstractDocumentCodec> documentCodecs;
    private ConcurrentDictionary`2<int, RemainingReductionPerLevel> scheduledReductionsPerViewAndLevel;
    private GeneralStorageActions generalStorageActions;
    public MappedResultsStorageActions(TableStorage tableStorage, IUuidGenerator generator, OrderedPartCollection`1<AbstractDocumentCodec> documentCodecs, Reference`1<SnapshotReader> snapshot, Reference`1<WriteBatch> writeBatch, IBufferPool bufferPool, IStorageActionsAccessor storageActionsAccessor, ConcurrentDictionary`2<int, RemainingReductionPerLevel> ScheduledReductionsPerViewAndLevel, GeneralStorageActions generalStorageActions);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.MappedResultsStorageActions/<GetKeysStats>d__8")]
public sealed virtual IEnumerable`1<ReduceKeyAndCount> GetKeysStats(int view, int start, int pageSize);
    public sealed virtual void PutMappedResult(int view, string docId, string reduceKey, RavenJObject data);
    public sealed virtual void IncrementReduceKeyCounter(int view, string reduceKey, int val);
    private void DecrementReduceKeyCounter(int view, string reduceKey, int val);
    public sealed virtual bool HasMappedResultsForIndex(int view);
    public sealed virtual void DeleteMappedResultsForDocumentId(string documentId, int view, Dictionary`2<ReduceKeyAndBucket, int> removed);
    public sealed virtual void UpdateRemovedMapReduceStats(int view, Dictionary`2<ReduceKeyAndBucket, int> removed, CancellationToken token);
    public sealed virtual void DeleteMappedResultsForView(int view, CancellationToken token);
    public sealed virtual IEnumerable`1<string> GetKeysForIndexForDebug(int view, string startsWith, string sourceId, int start, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.MappedResultsStorageActions/<GetMappedResultsForDebug>d__17")]
public sealed virtual IEnumerable`1<MappedResultInfo> GetMappedResultsForDebug(int view, string reduceKey, int start, int take);
    public sealed virtual IEnumerable`1<string> GetSourcesForIndexForDebug(int view, string startsWith, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.MappedResultsStorageActions/<GetReducedResultsForDebug>d__19")]
public sealed virtual IEnumerable`1<MappedResultInfo> GetReducedResultsForDebug(int view, string reduceKey, int level, int start, int take);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.MappedResultsStorageActions/<GetScheduledReductionForDebug>d__20")]
public sealed virtual IEnumerable`1<ScheduledReductionDebugInfo> GetScheduledReductionForDebug(int view, int start, int take);
    public sealed virtual void ScheduleReductions(int view, int level, ReduceKeyAndBucket reduceKeysAndBuckets);
    private Slice CreateBucketAndEtagKey(int bucket, Etag id);
    public sealed virtual IList`1<MappedResultInfo> GetItemsToReduce(GetItemsToReduceParams getItemsToReduceParams, CancellationToken cancellationToken);
    private IEnumerable`1<MappedResultInfo> GetResultsForBucket(int view, int level, string reduceKey, int bucket, bool loadData, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.MappedResultsStorageActions/<GetReducedResultsForBucket>d__25")]
private IEnumerable`1<MappedResultInfo> GetReducedResultsForBucket(int view, string reduceKey, int level, int bucket, bool loadData, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.MappedResultsStorageActions/<GetMappedResultsForBucket>d__26")]
private IEnumerable`1<MappedResultInfo> GetMappedResultsForBucket(int view, string reduceKey, int bucket, bool loadData, CancellationToken cancellationToken);
    public sealed virtual ScheduledReductionInfo DeleteScheduledReduction(IEnumerable`1<object> itemsToDelete, CancellationToken token);
    private Slice CreateScheduleReductionKey(int view, int level, string reduceKey);
    private Slice CreateReduceResultsKey(int view, string reduceKey, int level);
    private Slice CreateReduceResultsWithBucketKey(int view, string reduceKey, int level, int bucket);
    private Slice CreateMappedResultKey(int view, string reduceKey);
    private Slice CreateMappedResultWithBucketKey(int view, string reduceKey, int bucket);
    public sealed virtual Dictionary`2<int, RemainingReductionPerLevel> GetRemainingScheduledReductionPerIndex();
    public sealed virtual void PutReducedResult(int view, string reduceKey, int level, int sourceBucket, int bucket, RavenJObject data);
    public sealed virtual void RemoveReduceResults(int view, int level, string reduceKey, int sourceBucket);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.MappedResultsStorageActions/<GetReduceTypesPerKeys>d__36")]
public sealed virtual IEnumerable`1<ReduceTypePerKey> GetReduceTypesPerKeys(int view, int take, int limitOfItemsToReduceInSingleStep, Action`1<string> onError, CancellationToken cancellationToken);
    private int GetNumberOfMappedItemsPerReduceKey(Slice key);
    public sealed virtual void UpdatePerformedReduceType(int view, string reduceKey, ReduceType reduceType, bool skipAdd);
    private void DeleteReduceKeyCount(Slice key, Slice viewKey, Nullable`1<ushort> expectedVersion, bool shouldIgnoreConcurrencyExceptions);
    private void DeleteReduceKeyType(Slice key, Slice viewKey, Nullable`1<ushort> expectedVersion);
    private void AddReduceKeyCount(Slice key, int view, Slice viewKey, string reduceKey, int count, Nullable`1<ushort> expectedVersion, bool shouldIgnoreConcurrencyExceptions);
    private void AddReduceKeyType(Slice key, int view, string reduceKey, ReduceType status, Nullable`1<ushort> expectedVersion);
    public sealed virtual ReduceType GetLastPerformedReduceType(int view, string reduceKey);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.MappedResultsStorageActions/<GetMappedBuckets>d__44")]
public sealed virtual IEnumerable`1<int> GetMappedBuckets(int view, string reduceKey, CancellationToken cancellationToken);
    public sealed virtual List`1<MappedResultInfo> GetMappedResults(int view, HashSet`1<string> keysLeftToReduce, bool loadData, int take, HashSet`1<string> keysReturned, CancellationToken cancellationToken, List`1<MappedResultInfo> outputCollection);
    private RavenJObject LoadMappedResult(Slice key, string reduceKey, Index dataIndex);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.MappedResultsStorageActions/<GetReduceKeysAndTypes>d__47")]
public sealed virtual IEnumerable`1<ReduceTypePerKey> GetReduceKeysAndTypes(int view, int start, int take);
    public sealed virtual Dictionary`2<int, long> DeleteObsoleteScheduledReductions(List`1<int> mapReduceIndexIds, long delete);
    private List`1<ScheduleReductionData> GetScheduledReductionsToDelete(List`1<int> mapReduceIndexIds, long delete);
    public void DeleteScheduledReductionForView(int view, CancellationToken token);
    public void RemoveReduceResultsForView(int view, CancellationToken token);
    private void DeleteScheduledReduction(Etag etag, Slice etagAsString, Slice scheduleReductionKey, Slice viewKey, int bucket);
    public sealed virtual void DeleteScheduledReduction(int view, int level, string reduceKey);
    private void RemoveReduceResults(Func`1<IIterator> createIterator, bool tryPulseTransaction, CancellationToken token);
}
internal class Raven.Database.Storage.Voron.StorageActions.QueueStorageActions : StorageActionsBase {
    private TableStorage tableStorage;
    private Reference`1<WriteBatch> writeBatch;
    private IUuidGenerator generator;
    public QueueStorageActions(TableStorage tableStorage, IUuidGenerator generator, Reference`1<SnapshotReader> snapshot, Reference`1<WriteBatch> writeBatch, IBufferPool bufferPool);
    public sealed virtual void EnqueueToQueue(string name, Byte[] data);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.QueueStorageActions/<PeekFromQueue>d__5")]
public sealed virtual IEnumerable`1<Tuple`2<Byte[], object>> PeekFromQueue(string name);
    public sealed virtual void DeleteFromQueue(string name, object id);
    private void DeleteQueue(Slice key, string name);
    private Byte[] ReadDataFromQueue(Slice key);
}
internal class Raven.Database.Storage.Voron.StorageActions.ScheduledReductionDeleter : object {
    private ConcurrentSet`1<object> innerSet;
    private HashSet`1<Etag> state;
    public ScheduledReductionDeleter(ConcurrentSet`1<object> set);
    public bool Delete(Slice key, Etag value);
}
internal class Raven.Database.Storage.Voron.StorageActions.ScheduleReductionData : object {
    [CompilerGeneratedAttribute]
private Etag <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private Slice <EtagAsSlice>k__BackingField;
    [CompilerGeneratedAttribute]
private int <View>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReduceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Bucket>k__BackingField;
    public Etag Etag { get; public set; }
    public Slice EtagAsSlice { get; public set; }
    public int View { get; public set; }
    public int Level { get; public set; }
    public string ReduceKey { get; public set; }
    public int Bucket { get; public set; }
    [CompilerGeneratedAttribute]
public Etag get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(Etag value);
    [CompilerGeneratedAttribute]
public Slice get_EtagAsSlice();
    [CompilerGeneratedAttribute]
public void set_EtagAsSlice(Slice value);
    [CompilerGeneratedAttribute]
public int get_View();
    [CompilerGeneratedAttribute]
public void set_View(int value);
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(int value);
    [CompilerGeneratedAttribute]
public string get_ReduceKey();
    [CompilerGeneratedAttribute]
public void set_ReduceKey(string value);
    [CompilerGeneratedAttribute]
public int get_Bucket();
    [CompilerGeneratedAttribute]
public void set_Bucket(int value);
}
internal class Raven.Database.Storage.Voron.StorageActions.StalenessStorageActions : StorageActionsBase {
    private TableStorage tableStorage;
    private Reference`1<WriteBatch> writeBatch;
    public StalenessStorageActions(TableStorage tableStorage, Reference`1<SnapshotReader> snapshot, Reference`1<WriteBatch> writeBatch, IBufferPool bufferPool);
    public sealed virtual bool IsIndexStale(int id, Nullable`1<DateTime> cutOff, Etag cutoffEtag);
    public sealed virtual bool IsIndexStaleByTask(int view, Nullable`1<DateTime> cutOff);
    public sealed virtual bool IsReduceStale(int id);
    public sealed virtual bool IsMapStale(int id);
    public sealed virtual Tuple`2<DateTime, Etag> IndexLastUpdatedAt(int id);
    public sealed virtual Etag GetMostRecentDocumentEtag();
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Etag GetMostRecentAttachmentEtag();
    public sealed virtual int GetIndexTouchCount(int id);
}
internal abstract class Raven.Database.Storage.Voron.StorageActions.StorageActionsBase : object {
    private Reference`1<SnapshotReader> snapshotReference;
    private IBufferPool bufferPool;
    private static CultureInfo Invariant;
    protected SnapshotReader Snapshot { get; }
    protected StorageActionsBase(Reference`1<SnapshotReader> snapshotReference, IBufferPool bufferPool);
    private static StorageActionsBase();
    protected SnapshotReader get_Snapshot();
    protected static string AppendToKey(string key, T item1, U item2, W item3);
    protected static string AppendToKey(string key, T item1, U item2);
    protected static string AppendToKey(string key, T value);
    protected static string AppendToKey(string key, string value);
    protected static string AppendToKey(string key, string item1, string item2);
    protected static string AppendToKey(string key, string item1, string item2, string item3);
    protected static string CreateKey(T item1, U item2, W item3, X item4);
    protected static string CreateKey(T item1, U item2, W item3);
    protected static string CreateKey(T item1, U item2);
    protected Slice CreateViewKey(int view);
    protected static string CreateKey(T value);
    protected static string CreateKey(string value);
    protected static string CreateKey(string item1, string item2);
    protected static string CreateKey(string item1, string item2, string item3);
    protected static string CreateKey(string item1, string item2, string item3, string item4);
    protected static string AppendToKey(string key, String[] values);
    protected string CreateKey(String[] values);
    protected string CreateKey(Object[] values);
    protected RavenJObject LoadJson(Table table, Slice key, WriteBatch writeBatch, UInt16& version);
    protected StructureReader`1<T> LoadStruct(TableOfStructures`1<T> table, Slice key, WriteBatch writeBatch, UInt16& version);
    protected BufferPoolMemoryStream CreateStream();
}
public enum Raven.Database.Storage.Voron.StorageActions.StructureSchemas.DocumentReferencesFields : Enum {
    public int value__;
    public static DocumentReferencesFields IndexId;
    public static DocumentReferencesFields Key;
    public static DocumentReferencesFields Reference;
}
public enum Raven.Database.Storage.Voron.StorageActions.StructureSchemas.IndexingWorkStatsFields : Enum {
    public int value__;
    public static IndexingWorkStatsFields IndexingAttempts;
    public static IndexingWorkStatsFields IndexingSuccesses;
    public static IndexingWorkStatsFields IndexingErrors;
    public static IndexingWorkStatsFields LastIndexingTime;
    public static IndexingWorkStatsFields IndexId;
    public static IndexingWorkStatsFields CreatedTimestamp;
}
public enum Raven.Database.Storage.Voron.StorageActions.StructureSchemas.LastIndexedStatsFields : Enum {
    public int value__;
    public static LastIndexedStatsFields IndexId;
    public static LastIndexedStatsFields LastEtag;
    public static LastIndexedStatsFields LastTimestamp;
}
public enum Raven.Database.Storage.Voron.StorageActions.StructureSchemas.MappedResultFields : Enum {
    public int value__;
    public static MappedResultFields IndexId;
    public static MappedResultFields Bucket;
    public static MappedResultFields Timestamp;
    public static MappedResultFields ReduceKey;
    public static MappedResultFields DocId;
    public static MappedResultFields Etag;
}
public enum Raven.Database.Storage.Voron.StorageActions.StructureSchemas.ReduceKeyCountFields : Enum {
    public int value__;
    public static ReduceKeyCountFields IndexId;
    public static ReduceKeyCountFields MappedItemsCount;
    public static ReduceKeyCountFields ReduceKey;
}
public enum Raven.Database.Storage.Voron.StorageActions.StructureSchemas.ReduceKeyTypeFields : Enum {
    public int value__;
    public static ReduceKeyTypeFields IndexId;
    public static ReduceKeyTypeFields ReduceType;
    public static ReduceKeyTypeFields ReduceKey;
}
public enum Raven.Database.Storage.Voron.StorageActions.StructureSchemas.ReduceResultFields : Enum {
    public int value__;
    public static ReduceResultFields IndexId;
    public static ReduceResultFields Level;
    public static ReduceResultFields SourceBucket;
    public static ReduceResultFields Bucket;
    public static ReduceResultFields Timestamp;
    public static ReduceResultFields ReduceKey;
    public static ReduceResultFields Etag;
}
public enum Raven.Database.Storage.Voron.StorageActions.StructureSchemas.ReducingWorkStatsFields : Enum {
    public int value__;
    public static ReducingWorkStatsFields ReduceAttempts;
    public static ReducingWorkStatsFields ReduceSuccesses;
    public static ReducingWorkStatsFields ReduceErrors;
    public static ReducingWorkStatsFields LastReducedEtag;
    public static ReducingWorkStatsFields LastReducedTimestamp;
}
public enum Raven.Database.Storage.Voron.StorageActions.StructureSchemas.ScheduledReductionFields : Enum {
    public int value__;
    public static ScheduledReductionFields IndexId;
    public static ScheduledReductionFields Bucket;
    public static ScheduledReductionFields Level;
    public static ScheduledReductionFields Timestamp;
    public static ScheduledReductionFields ReduceKey;
    public static ScheduledReductionFields Etag;
}
public enum Raven.Database.Storage.Voron.StorageActions.StructureSchemas.TaskFields : Enum {
    public int value__;
    public static TaskFields TaskId;
    public static TaskFields IndexId;
    public static TaskFields AddedAt;
    public static TaskFields Type;
    public static TaskFields SerializedTask;
}
internal class Raven.Database.Storage.Voron.StorageActions.TasksStorageActions : StorageActionsBase {
    private static ILog Logger;
    private TableStorage tableStorage;
    private IUuidGenerator generator;
    private Reference`1<WriteBatch> writeBatch;
    public bool HasTasks { get; }
    public long ApproximateTaskCount { get; }
    public TasksStorageActions(TableStorage tableStorage, IUuidGenerator generator, Reference`1<SnapshotReader> snapshot, Reference`1<WriteBatch> writeBatch, IBufferPool bufferPool);
    private static TasksStorageActions();
    public sealed virtual void AddTask(DatabaseTask task, DateTime addedAt);
    public sealed virtual bool get_HasTasks();
    public sealed virtual long get_ApproximateTaskCount();
    public sealed virtual T GetMergedTask(List`1<int> indexesToSkip, Int32[] allIndexes, HashSet`1<IComparable> alreadySeen);
    private void MergeSimilarTasks(DatabaseTask task, HashSet`1<IComparable> alreadySeen, List`1<int> indexesToSkip, Int32[] allIndexes);
    private void RemoveTask(Slice taskId, int index, string type);
    [IteratorStateMachineAttribute("Raven.Database.Storage.Voron.StorageActions.TasksStorageActions/<GetPendingTasksForDebug>d__13")]
public sealed virtual IEnumerable`1<TaskMetadata> GetPendingTasksForDebug();
    public sealed virtual void DeleteTasks(HashSet`1<IComparable> alreadySeen);
    public sealed virtual int DeleteTasksForIndex(int indexId);
}
internal class Raven.Database.Storage.Voron.StorageActionsAccessor : object {
    private DateTime createdAt;
    [CompilerGeneratedAttribute]
private Action OnDispose;
    [CompilerGeneratedAttribute]
private IDocumentStorageActions <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueueStorageActions <Queue>k__BackingField;
    [CompilerGeneratedAttribute]
private IListsStorageActions <Lists>k__BackingField;
    [CompilerGeneratedAttribute]
private ITasksStorageActions <Tasks>k__BackingField;
    [CompilerGeneratedAttribute]
private IStalenessStorageActions <Staleness>k__BackingField;
    [CompilerGeneratedAttribute]
private IAttachmentsStorageActions <Attachments>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndexingStorageActions <Indexing>k__BackingField;
    [CompilerGeneratedAttribute]
private IGeneralStorageActions <General>k__BackingField;
    [CompilerGeneratedAttribute]
private IMappedResultsStorageAction <MapReduce>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNested>k__BackingField;
    [CompilerGeneratedAttribute]
private Action OnStorageCommit;
    [CompilerGeneratedAttribute]
private Action BeforeStorageCommit;
    [CompilerGeneratedAttribute]
private Action AfterStorageCommit;
    private List`1<DatabaseTask> tasks;
    private Action`1<JsonDocument[]> afterCommitAction;
    private List`1<JsonDocument> docsForCommit;
    public IDocumentStorageActions Documents { get; private set; }
    public IQueueStorageActions Queue { get; private set; }
    public IListsStorageActions Lists { get; private set; }
    public ITasksStorageActions Tasks { get; private set; }
    public IStalenessStorageActions Staleness { get; private set; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public IAttachmentsStorageActions Attachments { get; private set; }
    public IIndexingStorageActions Indexing { get; private set; }
    public IGeneralStorageActions General { get; private set; }
    public IMappedResultsStorageAction MapReduce { get; private set; }
    public IInFlightStateSnapshot InFlightStateSnapshot { get; }
    public bool IsNested { get; public set; }
    public StorageActionsAccessor(IUuidGenerator generator, OrderedPartCollection`1<AbstractDocumentCodec> documentCodecs, IDocumentCacher documentCacher, Reference`1<WriteBatch> writeBatchReference, Reference`1<SnapshotReader> snapshotReference, TableStorage storage, TransactionalStorage transactionalStorage, IBufferPool bufferPool);
    [CompilerGeneratedAttribute]
public void add_OnDispose(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnDispose(Action value);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual IDocumentStorageActions get_Documents();
    [CompilerGeneratedAttribute]
private void set_Documents(IDocumentStorageActions value);
    [CompilerGeneratedAttribute]
public sealed virtual IQueueStorageActions get_Queue();
    [CompilerGeneratedAttribute]
private void set_Queue(IQueueStorageActions value);
    [CompilerGeneratedAttribute]
public sealed virtual IListsStorageActions get_Lists();
    [CompilerGeneratedAttribute]
private void set_Lists(IListsStorageActions value);
    [CompilerGeneratedAttribute]
public sealed virtual ITasksStorageActions get_Tasks();
    [CompilerGeneratedAttribute]
private void set_Tasks(ITasksStorageActions value);
    [CompilerGeneratedAttribute]
public sealed virtual IStalenessStorageActions get_Staleness();
    [CompilerGeneratedAttribute]
private void set_Staleness(IStalenessStorageActions value);
    [CompilerGeneratedAttribute]
public sealed virtual IAttachmentsStorageActions get_Attachments();
    [CompilerGeneratedAttribute]
private void set_Attachments(IAttachmentsStorageActions value);
    [CompilerGeneratedAttribute]
public sealed virtual IIndexingStorageActions get_Indexing();
    [CompilerGeneratedAttribute]
private void set_Indexing(IIndexingStorageActions value);
    [CompilerGeneratedAttribute]
public sealed virtual IGeneralStorageActions get_General();
    [CompilerGeneratedAttribute]
private void set_General(IGeneralStorageActions value);
    [CompilerGeneratedAttribute]
public sealed virtual IMappedResultsStorageAction get_MapReduce();
    [CompilerGeneratedAttribute]
private void set_MapReduce(IMappedResultsStorageAction value);
    public sealed virtual IInFlightStateSnapshot get_InFlightStateSnapshot();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsNested();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsNested(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AfterStorageCommit(Action value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AfterStorageCommit(Action value);
    public sealed virtual T GetTask(Func`2<T, bool> predicate, T newTask);
    internal void ExecuteOnStorageCommit();
    internal void ExecuteBeforeStorageCommit();
    internal void ExecuteAfterStorageCommit();
    public sealed virtual void AfterStorageCommitBeforeWorkNotifications(JsonDocument doc, Action`1<JsonDocument[]> afterCommit);
    [DebuggerHiddenAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public void SaveAllTasks();
    [CompilerGeneratedAttribute]
private void <AfterStorageCommitBeforeWorkNotifications>b__64_0();
}
public class Raven.Database.Tasks.CleanupTestIndexesTask : object {
    private ILog log;
    private bool _disposed;
    private DocumentDatabase database;
    public sealed virtual void Execute(DocumentDatabase db);
    private void ExecuteCleanup(object state);
    public sealed virtual void Dispose();
}
public abstract class Raven.Database.Tasks.DatabaseTask : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparable <Id>k__BackingField;
    public int Index { get; private set; }
    public IComparable Id { get; public set; }
    public int NumberOfKeys { get; }
    public bool SeparateTasksByIndex { get; }
    protected DatabaseTask(int indexId);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    [CompilerGeneratedAttribute]
public IComparable get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(IComparable value);
    public abstract virtual int get_NumberOfKeys();
    public abstract virtual bool get_SeparateTasksByIndex();
    public abstract virtual void Merge(DatabaseTask task);
    public abstract virtual void Execute(WorkContext context);
    public Byte[] AsBytes();
    public static DatabaseTask ToTask(string taskType, Byte[] task);
    public abstract virtual DatabaseTask Clone();
}
public class Raven.Database.Tasks.RemoveFromIndexTask : DatabaseTask {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Keys>k__BackingField;
    private HashSet`1<string> Keys { get; private set; }
    public int NumberOfKeys { get; }
    public bool SeparateTasksByIndex { get; }
    public RemoveFromIndexTask(int indexId);
    [CompilerGeneratedAttribute]
private HashSet`1<string> get_Keys();
    [CompilerGeneratedAttribute]
private void set_Keys(HashSet`1<string> value);
    public virtual int get_NumberOfKeys();
    public virtual bool get_SeparateTasksByIndex();
    public virtual string ToString();
    public virtual void Merge(DatabaseTask task);
    public virtual void Execute(WorkContext context);
    private bool FilterDocuments(WorkContext context, IStorageActionsAccessor accessor, string key);
    public virtual DatabaseTask Clone();
    public void AddKey(string key);
}
public class Raven.Database.Tasks.TaskMetadata : object {
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <AddedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public object Id { get; public set; }
    public int IndexId { get; public set; }
    public string IndexName { get; public set; }
    public DateTime AddedTime { get; public set; }
    public string Type { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(object value);
    [CompilerGeneratedAttribute]
public int get_IndexId();
    [CompilerGeneratedAttribute]
public void set_IndexId(int value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public DateTime get_AddedTime();
    [CompilerGeneratedAttribute]
public void set_AddedTime(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
}
public class Raven.Database.Tasks.TouchReferenceDocumentIfChangedTask : DatabaseTask {
    private static ILog logger;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Etag> <ReferencesToCheck>k__BackingField;
    private IDictionary`2<string, Etag> ReferencesToCheck { get; private set; }
    public int NumberOfKeys { get; }
    public bool SeparateTasksByIndex { get; }
    public TouchReferenceDocumentIfChangedTask(int indexId);
    private static TouchReferenceDocumentIfChangedTask();
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Etag> get_ReferencesToCheck();
    [CompilerGeneratedAttribute]
private void set_ReferencesToCheck(IDictionary`2<string, Etag> value);
    public virtual int get_NumberOfKeys();
    public virtual string ToString();
    public virtual bool get_SeparateTasksByIndex();
    public virtual void Merge(DatabaseTask task);
    public virtual void Execute(WorkContext context);
    public virtual DatabaseTask Clone();
    public void UpdateReferenceToCheck(KeyValuePair`2<string, Etag> doc);
    public IEnumerable`1<string> GetReferencesForDebug();
}
public class Raven.Database.TimeSeries.AggregationRange : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <End>k__BackingField;
    public string Type { get; public set; }
    public string Key { get; public set; }
    public DateTimeOffset Start { get; public set; }
    public DateTimeOffset End { get; public set; }
    public AggregationRange(string type, string key, DateTimeOffset time);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_End();
    [CompilerGeneratedAttribute]
public void set_End(DateTimeOffset value);
}
public class Raven.Database.TimeSeries.Backup.BackupOperation : object {
    private DocumentDatabase database;
    private string backupDestinationDirectory;
    private StorageEnvironment env;
    private bool incrementalBackup;
    private TimeSeriesDocument timeSeriesDocument;
    private static ILog _log;
    private string backupFilename;
    private string backupSourceDirectory;
    public bool BackupAlreadyExists { get; }
    public BackupOperation(DocumentDatabase database, string backupSourceDirectory, string backupDestinationDirectory, StorageEnvironment env, bool incrementalBackup, TimeSeriesDocument timeSeriesDocument);
    private static BackupOperation();
    public void Execute();
    private void PrepareForIncrementalBackup();
    private string DirectoryForIncrementalBackup();
    private void CompleteBackup();
    private void UpdateBackupStatus(string newMsg, string details, BackupMessageSeverity severity);
    private void EnsureBackupDestinationExists(string backupDestination);
    public bool get_BackupAlreadyExists();
    [CompilerGeneratedAttribute]
private void <Execute>b__9_1(string s);
    [CompilerGeneratedAttribute]
private void <Execute>b__9_0(string s);
}
public class Raven.Database.TimeSeries.Backup.RestoreOperation : object {
    private static ILog log;
    private Action`1<string> output;
    private string backupPath;
    private TimeSeriesRestoreRequest restoreRequest;
    private string restoreToPath;
    private string backupFilename;
    public RestoreOperation(TimeSeriesRestoreRequest restoreRequest, Action`1<string> output);
    private static RestoreOperation();
    public bool IsValidBackup();
    private string GetBackupFilenamePath();
    private void ValidateRestorePreconditionsAndReturnLogsPath();
    public void Execute();
    [CompilerGeneratedAttribute]
private string <Execute>b__10_1(string dir);
}
public class Raven.Database.TimeSeries.CasCommand : Command {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public JToken Value;
    public JToken PrevValue;
    public string Key { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
}
public class Raven.Database.TimeSeries.Controllers.AdminTimeSeriesController : BaseAdminTimeSeriesApiController {
    [RavenRouteAttribute("admin/ts/{*id}")]
[HttpPutAttribute]
[AsyncStateMachineAttribute("Raven.Database.TimeSeries.Controllers.AdminTimeSeriesController/<Put>d__0")]
public Task`1<HttpResponseMessage> Put(string id);
    [RavenRouteAttribute("admin/ts/{*id}")]
[HttpDeleteAttribute]
public HttpResponseMessage Delete(string id);
    [HttpDeleteAttribute]
[RavenRouteAttribute("admin/ts/batch-delete")]
public HttpResponseMessage BatchDelete();
    [HttpPostAttribute]
[RavenRouteAttribute("admin/ts/{*id}")]
public HttpResponseMessage Disable(string id, bool isSettingDisabled);
    [HttpPostAttribute]
[RavenRouteAttribute("admin/ts/batch-toggle-disable")]
public HttpResponseMessage ToggleDisable(bool isSettingDisabled);
    private MessageWithStatusCode<TimeSeriesStorage, TimeSeriesLandlord> DeleteTimeSeries(string id, bool isHardDeleteNeeded);
    private MessageWithStatusCode<TimeSeriesStorage, TimeSeriesLandlord> ToggleTimeSeriesDisabled(string id, bool isSettingDisabled);
}
public class Raven.Database.TimeSeries.Controllers.BaseAdminTimeSeriesApiController : AdminResourceApiController`2<TimeSeriesStorage, TimeSeriesLandlord> {
    public string TimeSeriesName { get; }
    public TimeSeriesStorage TimeSeries { get; }
    public ResourceType ResourceType { get; }
    public string get_TimeSeriesName();
    public TimeSeriesStorage get_TimeSeries();
    public virtual ResourceType get_ResourceType();
    public virtual void MarkRequestDuration(long duration);
}
public abstract class Raven.Database.TimeSeries.Controllers.BaseTimeSeriesApiController : ResourceApiController`2<TimeSeriesStorage, TimeSeriesLandlord> {
    protected string TimeSeriesName { get; }
    protected TimeSeriesStorage TimeSeries { get; }
    public ResourceType ResourceType { get; }
    protected string get_TimeSeriesName();
    protected TimeSeriesStorage get_TimeSeries();
    public virtual ResourceType get_ResourceType();
    public virtual void MarkRequestDuration(long duration);
}
public class Raven.Database.TimeSeries.Controllers.TimeSeriesChangesController : BaseTimeSeriesApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("ts/{timeSeriesName}/changes/config")]
public HttpResponseMessage GetChangeConfig();
    [HttpGetAttribute]
[RavenRouteAttribute("ts/{timeSeriesName}/changes/events")]
public HttpResponseMessage GetChangesEvents();
}
public class Raven.Database.TimeSeries.Controllers.TimeSeriesController : BaseDatabaseApiController {
    [RavenRouteAttribute("ts")]
[HttpGetAttribute]
public HttpResponseMessage TimeSeries(bool getAdditionalData);
    private static List`1<TimeSeriesData> GetTimeSeriesData(IEnumerable`1<RavenJToken> timeSeries);
}
[RoutePrefixAttribute("ts/debug")]
public class Raven.Database.TimeSeries.Controllers.TimeSeriesDebugController : BaseDatabaseApiController {
    [HttpGetAttribute]
[RavenRouteAttribute("time-serieses")]
public HttpResponseMessage GetTimeSeriesInfo();
    [RavenRouteAttribute("ts/{timeSeriesName}/debug/metrics")]
[AsyncStateMachineAttribute("Raven.Database.TimeSeries.Controllers.TimeSeriesDebugController/<GetTimeSeriesMetrics>d__2")]
[HttpGetAttribute]
public Task`1<HttpResponseMessage> GetTimeSeriesMetrics(string timeSeriesName);
}
public class Raven.Database.TimeSeries.Controllers.TimeSeriesOperationsController : BaseTimeSeriesApiController {
    [RavenRouteAttribute("ts/{timeSeriesName}/types/{type}")]
[HttpPutAttribute]
public HttpResponseMessage PutType(TimeSeriesType type);
    [HttpDeleteAttribute]
[RavenRouteAttribute("ts/{timeSeriesName}/types/{type}")]
public HttpResponseMessage DeleteType(string type);
    [RavenRouteAttribute("ts/{timeSeriesName}/append/{type}")]
[AsyncStateMachineAttribute("Raven.Database.TimeSeries.Controllers.TimeSeriesOperationsController/<AppendPoint>d__2")]
[HttpPutAttribute]
public Task`1<HttpResponseMessage> AppendPoint();
    [AsyncStateMachineAttribute("Raven.Database.TimeSeries.Controllers.TimeSeriesOperationsController/<TimeSeriesBatch>d__3")]
[RavenRouteAttribute("ts/{timeSeriesName}/batch")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> TimeSeriesBatch();
    [IteratorStateMachineAttribute("Raven.Database.TimeSeries.Controllers.TimeSeriesOperationsController/<YieldChangeBatches>d__4")]
private IEnumerable`1<IEnumerable`1<TimeSeriesAppend>> YieldChangeBatches(Stream requestStream, CancellationTimeout timeout, Action`1<int> changeTimeSeriesFunc);
    [IteratorStateMachineAttribute("Raven.Database.TimeSeries.Controllers.TimeSeriesOperationsController/<YieldBatchItems>d__5")]
private IEnumerable`1<TimeSeriesAppend> YieldBatchItems(Stream partialStream, JsonSerializer serializer, CancellationTimeout timeout, Action`1<int> changeTimeSeriesFunc);
    [RavenRouteAttribute("ts/{timeSeriesName}/delete-key/{type}")]
[HttpDeleteAttribute]
public HttpResponseMessage DeleteKey(string type, string key);
    [AsyncStateMachineAttribute("Raven.Database.TimeSeries.Controllers.TimeSeriesOperationsController/<DeletePoints>d__8")]
[RavenRouteAttribute("ts/{timeSeriesName}/delete-points")]
[HttpDeleteAttribute]
public Task`1<HttpResponseMessage> DeletePoints();
    [RavenRouteAttribute("ts/{timeSeriesName}/delete-range/{type}")]
[HttpDeleteAttribute]
[AsyncStateMachineAttribute("Raven.Database.TimeSeries.Controllers.TimeSeriesOperationsController/<DeleteRange>d__9")]
public Task`1<HttpResponseMessage> DeleteRange();
    [HttpGetAttribute]
[RavenRouteAttribute("ts/{timeSeriesName}/types")]
public HttpResponseMessage GetTypes(int skip, int take);
    [RavenRouteAttribute("ts/{timeSeriesName}/key/{type}")]
[HttpGetAttribute]
public HttpResponseMessage GetKey(string type, string key);
    [RavenRouteAttribute("ts/{timeSeriesName}/keys/{type}")]
[HttpGetAttribute]
public HttpResponseMessage GetKeys(string type, int skip, int take);
    [RavenRouteAttribute("ts/{timeSeriesName}/points/{type}")]
[HttpGetAttribute]
public HttpResponseMessage GetPoints(string type, string key, int skip, int take, string start, string end);
    private Nullable`1<DateTimeOffset> ParseDateTimeOffset(string date);
    [RavenRouteAttribute("ts/{timeSeriesName}/aggregated-points/{type}")]
[HttpGetAttribute]
public HttpResponseMessage GetAggregatedPoints(string type, string key, AggregationDurationType durationType, int duration, int skip, int take, string start, string end);
}
public class Raven.Database.TimeSeries.Controllers.TimeSeriesReplicationController : BaseTimeSeriesApiController {
    [RavenRouteAttribute("ts/{timeSeriesName}/lastEtag")]
[HttpGetAttribute]
public HttpResponseMessage GetLastEtag(Guid serverId);
    [AsyncStateMachineAttribute("Raven.Database.TimeSeries.Controllers.TimeSeriesReplicationController/<Post>d__1")]
[RavenRouteAttribute("ts/{timeSeriesName}/replication")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> Post();
    [RavenRouteAttribute("ts/{timeSeriesName}/replication/heartbeat")]
[HttpPostAttribute]
public HttpResponseMessage HeartbeatPost(string sourceServer);
    [HttpGetAttribute]
[RavenRouteAttribute("ts/{timeSeriesName}/replications/get")]
public HttpResponseMessage ReplicationsGet();
    [AsyncStateMachineAttribute("Raven.Database.TimeSeries.Controllers.TimeSeriesReplicationController/<ReplicationsSave>d__4")]
[RavenRouteAttribute("ts/{timeSeriesName}/replications/save")]
[HttpPostAttribute]
public Task`1<HttpResponseMessage> ReplicationsSave();
}
public class Raven.Database.TimeSeries.Controllers.TimeSeriesSingleAuthTokenController : BaseTimeSeriesApiController {
    [RavenRouteAttribute("ts/{timeSeriesName}/singleAuthToken")]
[HttpGetAttribute]
public HttpResponseMessage SingleAuthGet();
}
public class Raven.Database.TimeSeries.Controllers.TimeSeriesStatsController : BaseTimeSeriesApiController {
    [RavenRouteAttribute("ts/{timeSeriesName}/stats")]
[HttpGetAttribute]
public HttpResponseMessage TimeSeriesStats();
}
public class Raven.Database.TimeSeries.GetCommand : Command {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
}
public class Raven.Database.TimeSeries.KeyValueOperation : object {
    public KeyValueOperationTypes Type;
    public string Key;
    public JToken Value;
}
public enum Raven.Database.TimeSeries.KeyValueOperationTypes : Enum {
    public int value__;
    public static KeyValueOperationTypes Add;
    public static KeyValueOperationTypes Del;
}
public class Raven.Database.TimeSeries.KeyValueStateMachine : object {
    private StorageEnvironment _storageEnvironment;
    private long _lastAppliedIndex;
    [CompilerGeneratedAttribute]
private EventHandler`1<KeyValueOperation> OperatonExecuted;
    public long LastAppliedIndex { get; private set; }
    public bool SupportSnapshots { get; }
    public KeyValueStateMachine(StorageEnvironmentOptions options);
    [CompilerGeneratedAttribute]
public void add_OperatonExecuted(EventHandler`1<KeyValueOperation> value);
    [CompilerGeneratedAttribute]
public void remove_OperatonExecuted(EventHandler`1<KeyValueOperation> value);
    protected void OnOperatonExecuted(KeyValueOperation e);
    public JToken Read(string key);
    public bool Cas(CasCommand op);
    public sealed virtual long get_LastAppliedIndex();
    private void set_LastAppliedIndex(long value);
    public sealed virtual void Apply(LogEntry entry, Command cmd);
    public sealed virtual bool get_SupportSnapshots();
    public sealed virtual void CreateSnapshot(long index, long term, ManualResetEventSlim allowFurtherModifications);
    private static int GetFullBackupIndex(String[] files);
    private void DoFullBackup(long index, long term, ManualResetEventSlim allowFurtherModifications);
    private static void DeleteOldSnapshots(IEnumerable`1<string> snapshotsToDelete);
    public sealed virtual ISnapshotWriter GetSnapshotWriter();
    public sealed virtual void ApplySnapshot(long term, long index, Stream stream);
    public sealed virtual void Danger__SetLastApplied(long postion);
    private void Apply(IEnumerable`1<KeyValueOperation> ops, long commandIndex);
    public sealed virtual void Dispose();
}
public class Raven.Database.TimeSeries.Notifications.NotificationPublisher : object {
    private TransportState transportState;
    public NotificationPublisher(TransportState transportState);
    public void RaiseNotification(TimeSeriesChangeNotification notification);
    public void RaiseNotification(BulkOperationNotification change);
}
public class Raven.Database.TimeSeries.OperationBatchCommand : Command {
    [CompilerGeneratedAttribute]
private KeyValueOperation[] <Batch>k__BackingField;
    public KeyValueOperation[] Batch { get; public set; }
    [CompilerGeneratedAttribute]
public KeyValueOperation[] get_Batch();
    [CompilerGeneratedAttribute]
public void set_Batch(KeyValueOperation[] value);
}
public class Raven.Database.TimeSeries.ReplicationLogItem : object {
    [CompilerGeneratedAttribute]
private long <Etag>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <BinaryData>k__BackingField;
    public long Etag { get; public set; }
    public Byte[] BinaryData { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Etag();
    [CompilerGeneratedAttribute]
public void set_Etag(long value);
    [CompilerGeneratedAttribute]
public Byte[] get_BinaryData();
    [CompilerGeneratedAttribute]
public void set_BinaryData(Byte[] value);
}
public class Raven.Database.TimeSeries.ReplicationMessage : object {
    [CompilerGeneratedAttribute]
private string <SendingServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ReplicationLogItem> <Logs>k__BackingField;
    public string SendingServerName { get; public set; }
    public Guid ServerId { get; public set; }
    public List`1<ReplicationLogItem> Logs { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SendingServerName();
    [CompilerGeneratedAttribute]
public void set_SendingServerName(string value);
    [CompilerGeneratedAttribute]
public Guid get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(Guid value);
    [CompilerGeneratedAttribute]
public List`1<ReplicationLogItem> get_Logs();
    [CompilerGeneratedAttribute]
public void set_Logs(List`1<ReplicationLogItem> value);
}
public class Raven.Database.TimeSeries.ReplicationTask : object {
    private static ILog Log;
    private object waitForTimeSeriesUpdate;
    private int actualWorkTimeSeries;
    private int replicatedWorkTimeSeries;
    private ConcurrentDictionary`2<string, TimeSeriesDestinationStats> destinationsStats;
    private int replicationAttempts;
    private ConcurrentDictionary`2<string, SemaphoreSlim> activeReplicationTasks;
    private ConcurrentQueue`1<Task> activeTasks;
    private HttpRavenRequestFactory httpRavenRequestFactory;
    private TimeSeriesStorage storage;
    private CancellationTokenSource cancellation;
    public ConcurrentDictionary`2<string, TimeSeriesDestinationStats> DestinationStats { get; }
    public ReplicationTask(TimeSeriesStorage storage);
    private static ReplicationTask();
    public void SignalUpdate();
    public void StartReplication();
    private void ReplicationAction();
    private bool WaitForTimeSeriesUpdate(TimeSpan timeout);
    public void HandleHeartbeat(string src);
    private void ResetFailureForHeartbeat(string src);
    public void SendReplicationToAllServers(bool runningBecauseOfDataModifications);
    private void ReplicateToDestination(TimeSeriesReplicationDestination destination);
    private bool ReplicateTo(TimeSeriesReplicationDestination destination);
    private ReplicationResult TryReplicate(TimeSeriesReplicationDestination destination, Int64& lastEtagSent, String& lastError);
    private bool GetLastReplicatedEtagFrom(RavenConnectionStringOptions connectionStringOptions, string timeSeriesUrl, Int64& lastEtag, String& lastError);
    private bool TryGetLastReplicatedEtagFrom(RavenConnectionStringOptions connectionStringOptions, string timeSeriesUrl, Int64& lastEtag, String& lastError);
    private bool PerformReplicationToServer(RavenConnectionStringOptions connectionStringOptions, string timeSeriesUrl, ReplicationMessage message, String& lastError);
    private bool TryPerformReplicationToServer(RavenConnectionStringOptions connectionStringOptions, string timeSeriesUrl, ReplicationMessage message, String& lastError);
    private List`1<TimeSeriesReplicationDestination> GetReplicationDestinations();
    private bool IsNotFailing(string destServerName, int currentReplicationAttempts);
    private ReplicationMessage GetTimeSeriesDataSinceEtag(long etag, Int64& lastEtagSent);
    private RavenConnectionStringOptions GetConnectionOptionsSafe(TimeSeriesReplicationDestination destination, String& lastError);
    private bool IsFirstFailure(string destinationUrl);
    private void NotifySiblings();
    private void NotifySibling(BlockingCollection`1<RavenConnectionStringOptions> collection);
    private void RecordSuccess(string url, Nullable`1<DateTime> lastSuccessTimestamp, Nullable`1<long> lastReplicatedEtag, Nullable`1<DateTime> lastReplicatedLastModified, Nullable`1<DateTime> lastHeartbeatReceived, string lastError);
    private void RecordFailure(string url, string lastError);
    private string HandleReplicationDistributionWebException(WebException e, string destinationUrl);
    public int GetActiveTasksCount();
    public ConcurrentDictionary`2<string, TimeSeriesDestinationStats> get_DestinationStats();
    public sealed virtual void Dispose();
}
public class Raven.Database.TimeSeries.TimeSeriesLogStorage : object {
    private static ILog log;
    private Byte[] keyBuffer;
    private Tree openLog;
    private long lastEtag;
    public TimeSeriesLogStorage(Transaction tx);
    private static TimeSeriesLogStorage();
    public long GetLastEtag();
    [IteratorStateMachineAttribute("Raven.Database.TimeSeries.TimeSeriesLogStorage/<GetLogsSinceEtag>d__6")]
public IEnumerable`1<ReplicationLogItem> GetLogsSinceEtag(long etag);
    private void WriteToLog(LogTypes logType, Action`1<BinaryWriter> writeAction);
    private Slice GetNextEtagKey();
    public void Append(string type, string key, long time, Double[] values);
    public void DeleteKey(string type, string key);
    public void DeletePoint(string type, string key, long time);
    public void DeleteRange(string type, string key, long start, long end);
    public void CreateType(string type, String[] fields);
    public void DeleteType(string type);
    public void PostReplicationLogItem(ReplicationLogItem logItem, Writer writer);
    public string ReadType(BinaryReader reader);
    private void ReplicationDeleteType(BinaryReader reader, Writer writer);
    private void ReplicationCreateType(BinaryReader reader, Writer writer);
}
[CLSCompliantAttribute("False")]
public class Raven.Database.TimeSeries.TimeSeriesMetricsManager : object {
    private Metrics timeSeriesMetrics;
    [CompilerGeneratedAttribute]
private PerSecondCounterMetric <RequestsPerSecondCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <Appends>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <Deletes>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <ClientRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <IncomingReplications>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <OutgoingReplications>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramMetric <RequestDurationMetric>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, MeterMetric> <ReplicationBatchSizeMeter>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, HistogramMetric> <ReplicationBatchSizeHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, HistogramMetric> <ReplicationDurationHistogram>k__BackingField;
    public long ConcurrentRequestsCount;
    public PerSecondCounterMetric RequestsPerSecondCounter { get; private set; }
    public MeterMetric Appends { get; private set; }
    public MeterMetric Deletes { get; private set; }
    public MeterMetric ClientRequests { get; private set; }
    public MeterMetric IncomingReplications { get; private set; }
    public MeterMetric OutgoingReplications { get; private set; }
    public HistogramMetric RequestDurationMetric { get; private set; }
    public ConcurrentDictionary`2<string, MeterMetric> ReplicationBatchSizeMeter { get; private set; }
    public ConcurrentDictionary`2<string, HistogramMetric> ReplicationBatchSizeHistogram { get; private set; }
    public ConcurrentDictionary`2<string, HistogramMetric> ReplicationDurationHistogram { get; private set; }
    public Dictionary`2<string, Dictionary`2<string, string>> Gauges { get; }
    [CompilerGeneratedAttribute]
public PerSecondCounterMetric get_RequestsPerSecondCounter();
    [CompilerGeneratedAttribute]
private void set_RequestsPerSecondCounter(PerSecondCounterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_Appends();
    [CompilerGeneratedAttribute]
private void set_Appends(MeterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_Deletes();
    [CompilerGeneratedAttribute]
private void set_Deletes(MeterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_ClientRequests();
    [CompilerGeneratedAttribute]
private void set_ClientRequests(MeterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_IncomingReplications();
    [CompilerGeneratedAttribute]
private void set_IncomingReplications(MeterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_OutgoingReplications();
    [CompilerGeneratedAttribute]
private void set_OutgoingReplications(MeterMetric value);
    [CompilerGeneratedAttribute]
public HistogramMetric get_RequestDurationMetric();
    [CompilerGeneratedAttribute]
private void set_RequestDurationMetric(HistogramMetric value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, MeterMetric> get_ReplicationBatchSizeMeter();
    [CompilerGeneratedAttribute]
private void set_ReplicationBatchSizeMeter(ConcurrentDictionary`2<string, MeterMetric> value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, HistogramMetric> get_ReplicationBatchSizeHistogram();
    [CompilerGeneratedAttribute]
private void set_ReplicationBatchSizeHistogram(ConcurrentDictionary`2<string, HistogramMetric> value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, HistogramMetric> get_ReplicationDurationHistogram();
    [CompilerGeneratedAttribute]
private void set_ReplicationDurationHistogram(ConcurrentDictionary`2<string, HistogramMetric> value);
    public void AddGauge(Type type, string name, Func`1<T> function);
    public Dictionary`2<string, Dictionary`2<string, string>> get_Gauges();
    public void Dispose();
    public MeterMetric GetReplicationBatchSizeMetric(string serverUrl);
    public HistogramMetric GetReplicationBatchSizeHistogram(string serverUrl);
    public HistogramMetric GetReplicationDurationHistogram(string serverUrl);
    [CompilerGeneratedAttribute]
private MeterMetric <GetReplicationBatchSizeMetric>b__47_0(string s);
    [CompilerGeneratedAttribute]
private HistogramMetric <GetReplicationBatchSizeHistogram>b__48_0(string s);
    [CompilerGeneratedAttribute]
private HistogramMetric <GetReplicationDurationHistogram>b__49_0(string s);
}
public class Raven.Database.TimeSeries.TimeSeriesServer : object {
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DataPath>k__BackingField;
    public int Port { get; public set; }
    public string NodeName { get; public set; }
    public string DataPath { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public string get_NodeName();
    [CompilerGeneratedAttribute]
public void set_NodeName(string value);
    [CompilerGeneratedAttribute]
public string get_DataPath();
    [CompilerGeneratedAttribute]
public void set_DataPath(string value);
}
public class Raven.Database.TimeSeries.TimeSeriesStorage : object {
    private static ILog Log;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed;
    private StorageEnvironment storageEnvironment;
    private NotificationPublisher notificationPublisher;
    private TimeSeriesMetricsManager metricsTimeSeries;
    [CompilerGeneratedAttribute]
private ReplicationTask <ReplicationTask>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplicationTimeoutInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Action TimeSeriesUpdated;
    internal static int AggregationPointStorageItemsLength;
    [CompilerGeneratedAttribute]
private Guid <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimeSeriesUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportState <TransportState>k__BackingField;
    [CompilerGeneratedAttribute]
private AtomicDictionary`1<object> <ExtensionsState>k__BackingField;
    [CompilerGeneratedAttribute]
private InMemoryRavenConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWrite>k__BackingField;
    internal static string SeriesTreePrefix;
    internal static string PeriodTreePrefix;
    internal static char PeriodsKeySeparator;
    internal static string TypesPrefix;
    internal static string StatsPrefix;
    public ReplicationTask ReplicationTask { get; }
    public int ReplicationTimeoutInMs { get; }
    public Guid ServerId { get; public set; }
    public string TimeSeriesUrl { get; private set; }
    public string Name { get; private set; }
    public string ResourceName { get; private set; }
    public TransportState TransportState { get; private set; }
    public AtomicDictionary`1<object> ExtensionsState { get; private set; }
    public InMemoryRavenConfiguration Configuration { get; private set; }
    public DateTime LastWrite { get; public set; }
    [CLSCompliantAttribute("False")]
public TimeSeriesMetricsManager MetricsTimeSeries { get; }
    public NotificationPublisher Publisher { get; }
    public StorageEnvironment TimeSeriesEnvironment { get; }
    public TimeSeriesStorage(string serverUrl, string timeSeriesName, InMemoryRavenConfiguration configuration, TransportState receivedTransportState);
    private static TimeSeriesStorage();
    [CompilerGeneratedAttribute]
public ReplicationTask get_ReplicationTask();
    [CompilerGeneratedAttribute]
public int get_ReplicationTimeoutInMs();
    [CompilerGeneratedAttribute]
public void add_TimeSeriesUpdated(Action value);
    [CompilerGeneratedAttribute]
public void remove_TimeSeriesUpdated(Action value);
    [CompilerGeneratedAttribute]
public Guid get_ServerId();
    [CompilerGeneratedAttribute]
public void set_ServerId(Guid value);
    [CompilerGeneratedAttribute]
public string get_TimeSeriesUrl();
    [CompilerGeneratedAttribute]
private void set_TimeSeriesUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ResourceName();
    [CompilerGeneratedAttribute]
private void set_ResourceName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual TransportState get_TransportState();
    [CompilerGeneratedAttribute]
private void set_TransportState(TransportState value);
    [CompilerGeneratedAttribute]
public sealed virtual AtomicDictionary`1<object> get_ExtensionsState();
    [CompilerGeneratedAttribute]
private void set_ExtensionsState(AtomicDictionary`1<object> value);
    [CompilerGeneratedAttribute]
public sealed virtual InMemoryRavenConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(InMemoryRavenConfiguration value);
    [CompilerGeneratedAttribute]
public DateTime get_LastWrite();
    [CompilerGeneratedAttribute]
public void set_LastWrite(DateTime value);
    public TimeSeriesMetricsManager get_MetricsTimeSeries();
    private void Initialize();
    private static StorageEnvironmentOptions CreateStorageOptionsFromConfiguration(string path, NameValueCollection settings);
    public Reader CreateReader();
    public Writer CreateWriter();
    public sealed virtual void Dispose();
    private void ShouldDispose(object sender, EventArgs eventArgs);
    public TimeSeriesMetrics CreateMetrics();
    public TimeSeriesStats CreateStats(Reader reader);
    public NotificationPublisher get_Publisher();
    public StorageEnvironment get_TimeSeriesEnvironment();
    private TimeSeriesType GetTimeSeriesType(Tree metadata, string type);
    private TimeSeriesType ReadTypeInternal(ValueReader reader);
}
public class Raven.Database.Util.ActiveEnumerable`1 : object {
    private T first;
    private bool isNotEmpty;
    private bool isOnFirst;
    private IEnumerator`1<T> enumerator;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    public ActiveEnumerable`1(IEnumerable`1<T> enumerable);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(T value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class Raven.Database.Util.BindingGroups : object {
    [CompilerGeneratedAttribute]
private List`1<string> <SimpleBindings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <CompoundBindings>k__BackingField;
    public List`1<string> SimpleBindings { get; public set; }
    public List`1<string> CompoundBindings { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_SimpleBindings();
    [CompilerGeneratedAttribute]
public void set_SimpleBindings(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_CompoundBindings();
    [CompilerGeneratedAttribute]
public void set_CompoundBindings(List`1<string> value);
}
public static class Raven.Database.Util.BindingsHelper : object {
    public static Regex SimpleBinding;
    public static Regex WordBinding;
    private static BindingsHelper();
    public static BindingGroups AnalyzeBindings(String[] bindings);
    public static HashSet`1<string> ExtractTokens(string binding);
}
public static class Raven.Database.Util.BundlesHelper : object {
    public static string ProcessActiveBundles(string activeBundles);
}
public static class Raven.Database.Util.CultureHelper : object {
    internal static IDisposable EnsureInvariantCulture();
}
[ExtensionAttribute]
public static class Raven.Database.Util.DatabaseHelper : object {
    [ExtensionAttribute]
public static bool IsSystemDatabase(DocumentDatabase database);
    public static void AssertSystemDatabase(DocumentDatabase database);
    public static string GetDatabaseKey(string key);
    public static string GetDatabaseName(string key);
    public static void DeleteDatabaseFiles(InMemoryRavenConfiguration configuration);
}
[DefaultMemberAttribute("Item")]
public class Raven.Database.Util.DatabaseMemoryTarget : Target {
    private ConcurrentDictionary`2<string, BoundedMemoryTarget> databaseTargets;
    public BoundedMemoryTarget Item { get; }
    public int DatabaseTargetCount { get; }
    public BoundedMemoryTarget get_Item(string databaseName);
    public int get_DatabaseTargetCount();
    public virtual void Write(LogEventInfo logEvent);
    public void Clear(string databaseName);
    public void ClearAll();
    public virtual bool ShouldLog(ILog logger, LogLevel level);
}
public static class Raven.Database.Util.DebugInfoProvider : object {
    private static CompressionLevel CompressionLevel;
    public static void CreateInfoPackageForDatabase(ZipArchive package, DocumentDatabase database, RequestManager requestManager, ClusterManager clusterManager, string zipEntryPrefix);
    internal static object GetExpectedRangeWarnings(DocumentDatabase database);
    private static Dictionary`2<string, ExpectedRange> CreateRangeIndexesWarnings(DocumentDatabase database);
    private static Dictionary`2<string, ExpectedRange> CreateRangeConfigWarnings(DocumentDatabase database);
    private static void CheckForRangeWarnings(Dictionary`2<string, ExpectedRange> rangeWarnings, IntegerSetting propertyValue, string name);
    internal static object GetRequestTrackingForDebug(RequestManager requestManager, string databaseName);
    internal static RavenJObject GetConfigForDebug(DocumentDatabase database);
    internal static IList`1<TaskMetadata> GetTasksForDebug(DocumentDatabase database);
    internal static object GetCurrentlyIndexingForDebug(DocumentDatabase database);
    internal static object GetPrefetchingQueueStatusForDebug(DocumentDatabase database);
}
internal static class Raven.Database.Util.DevelopmentHelper : object {
    public static void TimeBomb();
}
[CLSCompliantAttribute("False")]
public class Raven.Database.Util.MetricsCountersManager : object {
    private Metrics dbMetrics;
    [CompilerGeneratedAttribute]
private HistogramMetric <StaleIndexMaps>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramMetric <StaleIndexReduces>k__BackingField;
    [CompilerGeneratedAttribute]
private HistogramMetric <RequestDurationMetric>k__BackingField;
    [CompilerGeneratedAttribute]
private OneMinuteMetric <RequestDurationLastMinute>k__BackingField;
    [CompilerGeneratedAttribute]
private PerSecondCounterMetric <DocsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private PerSecondCounterMetric <FilesPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private PerSecondCounterMetric <IndexedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private PerSecondCounterMetric <ReducedPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private MeterMetric <ConcurrentRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private PerSecondCounterMetric <RequestsPerSecondCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private PerSecondCounterMetric <RequestsPerSecondTimeSeries>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, MeterMetric> <ReplicationBatchSizeMeter>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, HistogramMetric> <ReplicationBatchSizeHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, HistogramMetric> <ReplicationDurationHistogram>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, ConcurrentQueue`1<ReplicationPerformanceStats>> <ReplicationPerformanceStats>k__BackingField;
    public long ConcurrentRequestsCount;
    public HistogramMetric StaleIndexMaps { get; private set; }
    public HistogramMetric StaleIndexReduces { get; private set; }
    public HistogramMetric RequestDurationMetric { get; private set; }
    public OneMinuteMetric RequestDurationLastMinute { get; public set; }
    public PerSecondCounterMetric DocsPerSecond { get; private set; }
    public PerSecondCounterMetric FilesPerSecond { get; private set; }
    public PerSecondCounterMetric IndexedPerSecond { get; private set; }
    public PerSecondCounterMetric ReducedPerSecond { get; private set; }
    public MeterMetric ConcurrentRequests { get; private set; }
    public PerSecondCounterMetric RequestsPerSecondCounter { get; private set; }
    public PerSecondCounterMetric RequestsPerSecondTimeSeries { get; private set; }
    public ConcurrentDictionary`2<string, MeterMetric> ReplicationBatchSizeMeter { get; private set; }
    public ConcurrentDictionary`2<string, HistogramMetric> ReplicationBatchSizeHistogram { get; private set; }
    public ConcurrentDictionary`2<string, HistogramMetric> ReplicationDurationHistogram { get; private set; }
    public ConcurrentDictionary`2<string, ConcurrentQueue`1<ReplicationPerformanceStats>> ReplicationPerformanceStats { get; private set; }
    public Metrics DbMetrics { get; }
    public Dictionary`2<string, Dictionary`2<string, string>> Gauges { get; }
    [CompilerGeneratedAttribute]
public HistogramMetric get_StaleIndexMaps();
    [CompilerGeneratedAttribute]
private void set_StaleIndexMaps(HistogramMetric value);
    [CompilerGeneratedAttribute]
public HistogramMetric get_StaleIndexReduces();
    [CompilerGeneratedAttribute]
private void set_StaleIndexReduces(HistogramMetric value);
    [CompilerGeneratedAttribute]
public HistogramMetric get_RequestDurationMetric();
    [CompilerGeneratedAttribute]
private void set_RequestDurationMetric(HistogramMetric value);
    [CompilerGeneratedAttribute]
public OneMinuteMetric get_RequestDurationLastMinute();
    [CompilerGeneratedAttribute]
public void set_RequestDurationLastMinute(OneMinuteMetric value);
    [CompilerGeneratedAttribute]
public PerSecondCounterMetric get_DocsPerSecond();
    [CompilerGeneratedAttribute]
private void set_DocsPerSecond(PerSecondCounterMetric value);
    [CompilerGeneratedAttribute]
public PerSecondCounterMetric get_FilesPerSecond();
    [CompilerGeneratedAttribute]
private void set_FilesPerSecond(PerSecondCounterMetric value);
    [CompilerGeneratedAttribute]
public PerSecondCounterMetric get_IndexedPerSecond();
    [CompilerGeneratedAttribute]
private void set_IndexedPerSecond(PerSecondCounterMetric value);
    [CompilerGeneratedAttribute]
public PerSecondCounterMetric get_ReducedPerSecond();
    [CompilerGeneratedAttribute]
private void set_ReducedPerSecond(PerSecondCounterMetric value);
    [CompilerGeneratedAttribute]
public MeterMetric get_ConcurrentRequests();
    [CompilerGeneratedAttribute]
private void set_ConcurrentRequests(MeterMetric value);
    [CompilerGeneratedAttribute]
public PerSecondCounterMetric get_RequestsPerSecondCounter();
    [CompilerGeneratedAttribute]
private void set_RequestsPerSecondCounter(PerSecondCounterMetric value);
    [CompilerGeneratedAttribute]
public PerSecondCounterMetric get_RequestsPerSecondTimeSeries();
    [CompilerGeneratedAttribute]
private void set_RequestsPerSecondTimeSeries(PerSecondCounterMetric value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, MeterMetric> get_ReplicationBatchSizeMeter();
    [CompilerGeneratedAttribute]
private void set_ReplicationBatchSizeMeter(ConcurrentDictionary`2<string, MeterMetric> value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, HistogramMetric> get_ReplicationBatchSizeHistogram();
    [CompilerGeneratedAttribute]
private void set_ReplicationBatchSizeHistogram(ConcurrentDictionary`2<string, HistogramMetric> value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, HistogramMetric> get_ReplicationDurationHistogram();
    [CompilerGeneratedAttribute]
private void set_ReplicationDurationHistogram(ConcurrentDictionary`2<string, HistogramMetric> value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, ConcurrentQueue`1<ReplicationPerformanceStats>> get_ReplicationPerformanceStats();
    [CompilerGeneratedAttribute]
private void set_ReplicationPerformanceStats(ConcurrentDictionary`2<string, ConcurrentQueue`1<ReplicationPerformanceStats>> value);
    public void AddGauge(Type type, string name, Func`1<T> function);
    public Metrics get_DbMetrics();
    public Dictionary`2<string, Dictionary`2<string, string>> get_Gauges();
    public sealed virtual void Dispose();
    public MeterMetric GetReplicationBatchSizeMetric(ReplicationStrategy destination);
    public HistogramMetric GetReplicationBatchSizeHistogram(ReplicationStrategy destination);
    public HistogramMetric GetReplicationDurationHistogram(ReplicationStrategy destination);
    public ConcurrentQueue`1<ReplicationPerformanceStats> GetReplicationPerformanceStats(ReplicationStrategy destination);
    [CompilerGeneratedAttribute]
private MeterMetric <GetReplicationBatchSizeMetric>b__69_0(string s);
    [CompilerGeneratedAttribute]
private HistogramMetric <GetReplicationBatchSizeHistogram>b__70_0(string s);
    [CompilerGeneratedAttribute]
private HistogramMetric <GetReplicationDurationHistogram>b__71_0(string s);
}
public class Raven.Database.Util.MetricsTicker : object {
    public static MetricsTicker Instance;
    private Task perSecondCounterMetricsTask;
    private Task fiveSecondsTickCounterMetricsTask;
    private Task fifteenSecondsTickCounterMetricsTask;
    private ConcurrentSet`1<ICounterMetric> oneSecondIntervalMetrics;
    private ConcurrentSet`1<ICounterMetric> fiveSecondsTickIntervalMetrics;
    private ConcurrentSet`1<ICounterMetric> fifteenSecondsIntervalMeterMetrics;
    private CancellationTokenSource cts;
    private static MetricsTicker();
    public void AddPerSecondCounterMetric(ICounterMetric newPerSecondCounterMetric);
    public void RemovePerSecondCounterMetric(ICounterMetric perSecondCounterMetricToRemove);
    public void AddFiveSecondsIntervalMeterMetric(ICounterMetric newMeterMetric);
    public void RemoveFiveSecondsIntervalMeterMetric(ICounterMetric meterMetricToRemove);
    public void AddFifteenSecondsIntervalMeterMetric(ICounterMetric newMeterMetric);
    public void RemoveFifteenSecondsIntervalMeterMetric(ICounterMetric meterMetricToRemove);
    private Task CreateTask(int baseInterval, ConcurrentSet`1<ICounterMetric> concurrentSet);
    public sealed virtual void Dispose();
}
public class Raven.Database.Util.MiniDumper : object {
    private Timer timer;
    private int counts;
    private int period;
    private int currentCount;
    private bool additionalStats;
    private string url;
    private Option options;
    private static MiniDumper modreq(System.Runtime.CompilerServices.IsVolatile) instance;
    private static object syncRoot;
    public static MiniDumper Instance { get; }
    private static MiniDumper();
    public static MiniDumper get_Instance();
    public static string PrintUsage();
    public static Option StringToOption(string id);
    private static bool MiniDumpWriteDump(IntPtr hProcess, UInt32 processId, SafeHandle hFile, UInt32 dumpType, MiniDumpExceptionInformation& expParam, IntPtr userStreamParam, IntPtr callbackParam);
    private static bool MiniDumpWriteDump(IntPtr hProcess, UInt32 processId, SafeHandle hFile, UInt32 dumpType, IntPtr expParam, IntPtr userStreamParam, IntPtr callbackParam);
    private static UInt32 GetCurrentThreadId();
    private static bool Write(SafeHandle fileHandle, Option options, ExceptionInfo exceptionInfo, Process process);
    public string Write(Nullable`1<Option> passedOptions, string pathForDump, Nullable`1<int> pid);
    public string StartTimer(int count, int period, Option options, bool addAddtionalStats, string url);
    private void Execute(object state);
    public void StopTimer();
    public sealed virtual void Dispose();
}
public class Raven.Database.Util.OneMinuteMetric : object {
    private ConcurrentQueue`1<OneMinuteMetricRecord> records;
    [IgnoreDataMemberAttribute]
public IMetric Copy { get; }
    private void CleanupQueue();
    public void AddRecord(long value);
    public OneMinuteMetricData GetData();
    public sealed virtual IMetric get_Copy();
    public sealed virtual void LogJson(StringBuilder sb);
    public sealed virtual void Tick();
}
public class Raven.Database.Util.OutputTicker : object {
    private Timer timer;
    private Action onStart;
    private Action onStop;
    public OutputTicker(TimeSpan interval, Action output, Action onStart, Action onStop);
    public void Start();
    public void Stop();
    public sealed virtual void Dispose();
}
public static class Raven.Database.Util.PerformanceCountersUtils : object {
    public static Nullable`1<long> SafelyGetPerformanceCounter(string categoryName, string counterName, string processName);
}
public static class Raven.Database.Util.PortUtil : object {
    private static ILog logger;
    public static int DefaultPort;
    private static PortUtil();
    public static int GetPort(string portStr, bool runInMemory);
    private static void TrySaveAutoPortForNextTime(int autoPort);
    private static bool TryReadPreviouslySelectAutoPort(Int32& port);
    private static int FindPort();
}
public enum Raven.Database.Util.QueryTimings : Enum {
    public int value__;
    [DescriptionAttribute("Query parsing")]
public static QueryTimings Parse;
    [DescriptionAttribute("Lucene search")]
public static QueryTimings Lucene;
    [DescriptionAttribute("Loading documents")]
public static QueryTimings LoadDocuments;
    [DescriptionAttribute("Transforming results")]
public static QueryTimings TransformResults;
}
public static class Raven.Database.Util.RavenGC : object {
    private static ILog log;
    private static long memoryBeforeLastForcedGC;
    private static long memoryAfterLastForcedGC;
    private static DateTime lastForcedGCTime;
    private static int delayBetweenGCInMinutes;
    private static int DefaultDelayBetweenGCInMinutes;
    private static int MaxDelayBetweenGCInMinutes;
    public static ReaderWriterLockSlim GcCollectLock;
    private static long lastTimeMemoryReleasedBeforeGC;
    private static long fiveSecondsInTicks;
    private static Lazy`1<Action> SetCompactLog;
    private static double memoryDifferenceLastGc;
    public static long MemoryBeforeLastForcedGC { get; }
    public static long MemoryAfterLastForcedGC { get; }
    public static DateTime LastForcedGCTime { get; }
    private static RavenGC();
    public static void ResetHistory();
    public static long get_MemoryBeforeLastForcedGC();
    public static long get_MemoryAfterLastForcedGC();
    public static DateTime get_LastForcedGCTime();
    private static void ReleaseMemoryBeforeGC();
    public static bool CollectGarbage(int generation, GCCollectionMode collectionMode, bool forceByUser);
    public static bool CollectGarbage(bool compactLoh, Action afterCollect, bool forceByUser);
    private static bool CollectGarbageInternal(bool compactLoh, Action afterCollect, bool forceByUser, int maxGeneration, GCCollectionMode gcCollectionMode, bool waitForPendingFinalizers);
    private static bool ShouldCollectNow();
    private static double DifferenceAsDecimalPercents(long v1, long v2);
    public static void ConsiderRunningGC();
}
public class Raven.Database.Util.ResourceTimerManager : object {
    private ILog log;
    private ConcurrentSet`1<Timer> timers;
    public Timer NewTimer(TimerCallback callback, TimeSpan dueTime, TimeSpan period);
    public sealed virtual void Dispose();
    public void ReleaseTimer(Timer timer);
}
public class Raven.Database.Util.SequentialUuidGenerator : object {
    private Byte[] ticksAsBytes;
    private long sequentialUuidCounterDocuments;
    [ObsoleteAttribute("Use RavenFS instead.")]
private long sequentialUuidCounterAttachments;
    private long sequentialUuidCounterDocumentsTransactions;
    private long sequentialUuidCounterMappedResults;
    private long sequentialUuidCounterReduceResults;
    private long sequentialUuidCounterQueue;
    private long sequentialUuidCounterTasks;
    private long sequentialUuidCounterScheduledReductions;
    private long sequentialUuidCounterIndexing;
    private long sequentialUuidCounterTransformers;
    private long sequentialUuidDocumentReferences;
    private long sequentialUuidSubscriptions;
    private long sequentialUuidLicensing;
    private long sequentialUuidSupportCoverage;
    unknown long EtagBase {public set; }
    public long LastDocumentTransactionEtag { get; }
    public void set_EtagBase(long value);
    public sealed virtual long get_LastDocumentTransactionEtag();
    public sealed virtual Etag CreateSequentialUuid(UuidType type);
}
public static class Raven.Database.Util.SizeHelper : object {
    public static string Humane(Nullable`1<long> size);
}
public class Raven.Database.Util.SortedKeyList`1 : object {
    private static int InitialSize;
    private IComparer`1<T> comparer;
    private int inUse;
    private int modificationCount;
    private T[] table;
    public int Count { get; }
    public int Capacity { get; }
    public SortedKeyList`1(IComparer`1<T> comparer);
    public int get_Count();
    public int get_Capacity();
    [IteratorStateMachineAttribute("Raven.Database.Util.SortedKeyList`1/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(T item);
    public bool Contains(T item);
    public void RemoveSmallerOrEqual(T item);
    private int FindSmallerOfEqual(T key);
    private void EnsureCapacity(int n, int free);
    private int Find(T key);
}
public static class Raven.Database.Util.SortFieldHelper : object {
    public static Field CustomField(string field);
}
internal class Raven.Database.Util.StopwatchScope : object {
    private Stopwatch sw;
    private StopwatchScope(Stopwatch sw);
    public sealed virtual void Dispose();
    public static StopwatchScope For(Stopwatch sw, bool resetBeforeStart);
}
public class Raven.Database.Util.Streams.PartialStream : Stream {
    private Stream inner;
    private long size;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PartialStream(Stream inner, long size);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
}
public class Raven.Database.Util.TimedEnumerable`1 : object {
    private IEnumerator`1<T> enumerator;
    private Action`1<double> _finished;
    private Stopwatch _watch;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    public TimedEnumerable`1(IEnumerable`1<T> enumerable, Action`1<double> finished);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(T value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public interface Raven.Server.IServerThingsForTests {
    public bool HasPendingRequests { get; }
    public int NumberOfRequests { get; }
    public RavenDBOptions Options { get; }
    public RequestManager RequestManager { get; }
    public abstract virtual bool get_HasPendingRequests();
    public abstract virtual int get_NumberOfRequests();
    public abstract virtual RavenDBOptions get_Options();
    public abstract virtual void ResetNumberOfRequests();
    public abstract virtual Task`1<DocumentDatabase> GetDatabaseInternal(string databaseName);
    public abstract virtual Task`1<RavenFileSystem> GetRavenFileSystemInternal(string fileSystemName);
    public abstract virtual RequestManager get_RequestManager();
}
public class Raven.Server.RavenDbServer : object {
    private DocumentStore documentStore;
    internal FilesStore filesStore;
    private MetricsTicker metricsTicker;
    private InMemoryRavenConfiguration configuration;
    private IServerThingsForTests serverThingsForTests;
    private RavenDBOptions options;
    private OwinHttpServer owinHttpServer;
    private string url;
    private bool filesStoreInitialized;
    [CompilerGeneratedAttribute]
private bool <UseEmbeddedHttpServer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    public InMemoryRavenConfiguration Configuration { get; public set; }
    public DocumentDatabase SystemDatabase { get; }
    public IServerThingsForTests Server { get; }
    public DocumentStore DocumentStore { get; }
    public FilesStore FilesStore { get; }
    public bool RunInMemory { get; public set; }
    public RavenDBOptions Options { get; }
    public string Url { get; public set; }
    public bool UseEmbeddedHttpServer { get; public set; }
    public bool Disposed { get; private set; }
    public RavenDbServer(InMemoryRavenConfiguration configuration);
    public InMemoryRavenConfiguration get_Configuration();
    public void set_Configuration(InMemoryRavenConfiguration value);
    public DocumentDatabase get_SystemDatabase();
    public IServerThingsForTests get_Server();
    public DocumentStore get_DocumentStore();
    public FilesStore get_FilesStore();
    public bool get_RunInMemory();
    public void set_RunInMemory(bool value);
    public RavenDbServer Initialize(Action`1<RavenDBOptions> configure);
    public void EnableHttpServer();
    public void DisableHttpServer();
    public RavenDBOptions get_Options();
    public string get_Url();
    public void set_Url(string value);
    [CompilerGeneratedAttribute]
public bool get_UseEmbeddedHttpServer();
    [CompilerGeneratedAttribute]
public void set_UseEmbeddedHttpServer(bool value);
    [CompilerGeneratedAttribute]
public bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private HttpMessageHandler <Initialize>b__25_1();
}
public abstract class Raven.Smuggler.SmugglerAbstractOperation`1 : object {
    protected T Parameters;
    protected SmugglerAbstractOperation`1(T parameters);
    public abstract virtual bool InitSmuggler();
    public void WaitForSmuggler();
    public abstract virtual void Dispose();
}
public class Raven.Smuggler.SmugglerBetweenOperations : object {
    [CompilerGeneratedAttribute]
private ISmugglerDatabaseOperations <From>k__BackingField;
    [CompilerGeneratedAttribute]
private ISmugglerDatabaseOperations <To>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IncrementalKey>k__BackingField;
    public ISmugglerDatabaseOperations From { get; public set; }
    public ISmugglerDatabaseOperations To { get; public set; }
    public string IncrementalKey { get; public set; }
    [CompilerGeneratedAttribute]
public ISmugglerDatabaseOperations get_From();
    [CompilerGeneratedAttribute]
public void set_From(ISmugglerDatabaseOperations value);
    [CompilerGeneratedAttribute]
public ISmugglerDatabaseOperations get_To();
    [CompilerGeneratedAttribute]
public void set_To(ISmugglerDatabaseOperations value);
    [CompilerGeneratedAttribute]
public string get_IncrementalKey();
    [CompilerGeneratedAttribute]
public void set_IncrementalKey(string value);
}
public class Raven.Smuggler.SmugglerBetweenRemoteFilesOperations : SmugglerRemoteFilesOperations {
    private Func`1<FilesStore> secondaryStore;
    protected FilesStore SecondaryStore { get; }
    public SmugglerBetweenRemoteFilesOperations(Func`1<FilesStore> primaryStore, Func`1<FilesStore> secondaryStore, Func`1<DocumentStore> documentStore);
    protected FilesStore get_SecondaryStore();
    public virtual Task PutFile(FileHeader file, Stream data, long size);
    public virtual string CreateIncrementalKey();
    public virtual Task`1<ExportFilesDestinations> GetIncrementalExportKey();
    public virtual Task PutIncrementalExportKey(ExportFilesDestinations destinations);
    public virtual Task PutConfig(string name, RavenJObject value);
}
public class Raven.Smuggler.SmugglerDatabaseApi : SmugglerDatabaseApiBase {
    protected BulkInsertOperation operation;
    protected DocumentStore store;
    public SmugglerDatabaseApi(SmugglerDatabaseOptions options);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseApi/<Between>d__3")]
public virtual Task Between(SmugglerBetweenOptions`1<RavenConnectionStringOptions> betweenOptions);
    [ObsoleteAttribute("Use RavenFS instead.")]
protected virtual Task`1<ExportOperationStatus> ExportAttachments(RavenConnectionStringOptions src, SmugglerJsonTextWriter jsonWriter, Etag lastEtag, Etag maxEtag, int maxNumberOfAttachmentsToExport);
    public virtual Task ExportDeletions(SmugglerJsonTextWriter jsonWriter, OperationState result, LastEtagsInfo maxEtagsToFetch);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseApi/<ImportData>d__6")]
public virtual Task ImportData(SmugglerImportOptions`1<RavenConnectionStringOptions> importOptions, Stream stream);
    private BulkInsertOperation CreateBulkInsertOperation(DocumentStore documentStore);
    protected static DocumentStore CreateStore(RavenConnectionStringOptions connectionStringOptions);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseApi/<ExportData>d__9")]
public virtual Task`1<OperationState> ExportData(SmugglerExportOptions`1<RavenConnectionStringOptions> exportOptions);
    [CompilerGeneratedAttribute]
private DocumentStore <.ctor>b__0_0();
    [CompilerGeneratedAttribute]
private BulkInsertOperation <.ctor>b__0_1();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__0_2();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__0_3();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__0_4();
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task <>n__0(SmugglerImportOptions`1<RavenConnectionStringOptions> importOptions, Stream stream);
    [CompilerGeneratedAttribute]
private void <CreateBulkInsertOperation>b__7_0(string text);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task`1<OperationState> <>n__1(SmugglerExportOptions`1<RavenConnectionStringOptions> exportOptions);
}
internal class Raven.Smuggler.SmugglerDatabaseBetweenOperation : object {
    [CompilerGeneratedAttribute]
private Action`1<string> <OnShowProgress>k__BackingField;
    public Action`1<string> OnShowProgress { get; public set; }
    [CompilerGeneratedAttribute]
public Action`1<string> get_OnShowProgress();
    [CompilerGeneratedAttribute]
public void set_OnShowProgress(Action`1<string> value);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseBetweenOperation/<Between>d__4")]
public Task Between(SmugglerBetweenOperations betweenOperations, SmugglerDatabaseOptions databaseOptions);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseBetweenOperation/<ExportIdentities>d__5")]
private Task ExportIdentities(ISmugglerDatabaseOperations exportOperations, ISmugglerDatabaseOperations importOperations, ItemType operateOnTypes);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseBetweenOperation/<ExportIndexes>d__6")]
private Task ExportIndexes(ISmugglerDatabaseOperations exportOperations, ISmugglerDatabaseOperations importOperations);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseBetweenOperation/<ExportDocuments>d__7")]
private Task`1<Etag> ExportDocuments(ISmugglerDatabaseOperations exportOperations, ISmugglerDatabaseOperations importOperations, SmugglerDatabaseOptions databaseOptions);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseBetweenOperation/<ExportAttachments>d__8")]
[ObsoleteAttribute("Use RavenFS instead.")]
private Task`1<Etag> ExportAttachments(ISmugglerDatabaseOperations exportOperations, ISmugglerDatabaseOperations importOperations, SmugglerDatabaseOptions databaseOptions);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseBetweenOperation/<ExportTransformers>d__9")]
private Task ExportTransformers(ISmugglerDatabaseOperations exportOperations, ISmugglerDatabaseOperations importOperations);
    private void ShowProgress(string format, Object[] args);
    public RavenJObject StripReplicationInformationFromMetadata(RavenJObject metadata);
    public RavenJToken DisableVersioning(RavenJObject metadata);
}
public class Raven.Smuggler.SmugglerDatabaseOperationDispatcher : SmugglerOperationDispatcher`1<SmugglerDatabaseOptions> {
    private SmugglerDatabaseApi api;
    protected string FileExtension { get; }
    public SmugglerDatabaseOperationDispatcher(SmugglerDatabaseApi api);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseOperationDispatcher/<PerformImportAsync>d__2")]
protected virtual Task PerformImportAsync(SmugglerDatabaseOptions parameters);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseOperationDispatcher/<PerformExportAsync>d__3")]
protected virtual Task PerformExportAsync(SmugglerDatabaseOptions parameters);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerDatabaseOperationDispatcher/<PerformBetweenAsync>d__4")]
protected virtual Task PerformBetweenAsync(SmugglerDatabaseOptions parameters);
    protected virtual string get_FileExtension();
}
public class Raven.Smuggler.SmugglerFilesApi : SmugglerFilesApiBase {
    private FilesStore primaryStore;
    private FilesStore secondaryStore;
    private DocumentStore documentStore;
    public SmugglerFilesApi(SmugglerFilesOptions options);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerFilesApi/<Between>d__4")]
public virtual Task Between(SmugglerBetweenOptions`1<FilesConnectionStringOptions> betweenOptions);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerFilesApi/<ExportData>d__5")]
public virtual Task`1<ExportFilesResult> ExportData(SmugglerExportOptions`1<FilesConnectionStringOptions> exportOptions);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerFilesApi/<ImportData>d__6")]
public virtual Task ImportData(SmugglerImportOptions`1<FilesConnectionStringOptions> importOptions);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerFilesApi/<CreateStore>d__7")]
internal static Task`1<FilesStore> CreateStore(FilesConnectionStringOptions options);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerFilesApi/<ValidateThatServerIsUpAndFilesystemExists>d__8")]
internal static Task ValidateThatServerIsUpAndFilesystemExists(FilesConnectionStringOptions server, FilesStore s);
    internal static DocumentStore CreateDocumentStore(FilesConnectionStringOptions options);
    [CompilerGeneratedAttribute]
private FilesStore <Between>b__4_0();
    [CompilerGeneratedAttribute]
private FilesStore <Between>b__4_1();
    [CompilerGeneratedAttribute]
private DocumentStore <Between>b__4_2();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(SmugglerBetweenOptions`1<FilesConnectionStringOptions> betweenOptions);
    [CompilerGeneratedAttribute]
private FilesStore <ExportData>b__5_0();
    [CompilerGeneratedAttribute]
private DocumentStore <ExportData>b__5_1();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ExportFilesResult> <>n__1(SmugglerExportOptions`1<FilesConnectionStringOptions> exportOptions);
    [CompilerGeneratedAttribute]
private FilesStore <ImportData>b__6_0();
    [CompilerGeneratedAttribute]
private DocumentStore <ImportData>b__6_1();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__2(SmugglerImportOptions`1<FilesConnectionStringOptions> importOptions);
}
public class Raven.Smuggler.SmugglerFilesOperationDispatcher : SmugglerOperationDispatcher`1<SmugglerFilesOptions> {
    private SmugglerFilesApiBase api;
    protected string FileExtension { get; }
    public SmugglerFilesOperationDispatcher(SmugglerFilesApiBase api);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerFilesOperationDispatcher/<PerformImportAsync>d__2")]
protected virtual Task PerformImportAsync(SmugglerFilesOptions parameters);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerFilesOperationDispatcher/<PerformExportAsync>d__3")]
protected virtual Task PerformExportAsync(SmugglerFilesOptions parameters);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerFilesOperationDispatcher/<PerformBetweenAsync>d__4")]
protected virtual Task PerformBetweenAsync(SmugglerFilesOptions parameters);
    protected virtual string get_FileExtension();
}
public abstract class Raven.Smuggler.SmugglerOperationDispatcher`1 : object {
    [CompilerGeneratedAttribute]
private T <Options>k__BackingField;
    public T Options { get; private set; }
    protected string FileExtension { get; }
    protected SmugglerOperationDispatcher`1(T options);
    [CompilerGeneratedAttribute]
public T get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(T value);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerOperationDispatcher`1/<Execute>d__5")]
public Task Execute(SmugglerAction action);
    protected abstract virtual Task PerformImportAsync(T parameters);
    protected abstract virtual Task PerformExportAsync(T parameters);
    protected abstract virtual Task PerformBetweenAsync(T parameters);
    protected abstract virtual string get_FileExtension();
}
public class Raven.Smuggler.SmugglerRemoteDatabaseOperations : object {
    private Func`1<DocumentStore> store;
    private Func`1<BulkInsertOperation> operation;
    private Func`1<bool> isDocsStreamingSupported;
    private Func`1<bool> isTransformersSupported;
    private Func`1<bool> isIdentitiesSmugglingSupported;
    private static int RetriesCount;
    private SmugglerJintHelper jintHelper;
    [CompilerGeneratedAttribute]
private SmugglerDatabaseOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LastRequestErrored>k__BackingField;
    private DocumentStore Store { get; }
    private BulkInsertOperation Operation { get; }
    public SmugglerDatabaseOptions Options { get; private set; }
    public bool LastRequestErrored { get; public set; }
    public SmugglerRemoteDatabaseOperations(Func`1<DocumentStore> store, Func`1<BulkInsertOperation> operation, Func`1<bool> isDocsStreamingSupported, Func`1<bool> isTransformersSupported, Func`1<bool> isIdentitiesSmugglingSupported);
    private DocumentStore get_Store();
    private BulkInsertOperation get_Operation();
    [CompilerGeneratedAttribute]
public sealed virtual SmugglerDatabaseOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(SmugglerDatabaseOptions value);
    [CompilerGeneratedAttribute]
public bool get_LastRequestErrored();
    [CompilerGeneratedAttribute]
public void set_LastRequestErrored(bool value);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Task DeleteAttachment(string key);
    public sealed virtual Task DeleteDocument(string key);
    [ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Task`1<Etag> ExportAttachmentsDeletion(SmugglerJsonTextWriter jsonWriter, Etag startAttachmentsDeletionEtag, Etag maxAttachmentEtag);
    public sealed virtual Task`1<Etag> ExportDocumentsDeletion(SmugglerJsonTextWriter jsonWriter, Etag startDocsEtag, Etag maxEtag);
    public sealed virtual LastEtagsInfo FetchCurrentMaxEtags();
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteDatabaseOperations/<GetAttachments>d__25")]
[ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Task`1<List`1<AttachmentInformation>> GetAttachments(int start, Etag etag, int maxRecords);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteDatabaseOperations/<GetAttachmentData>d__26")]
[ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Task`1<Byte[]> GetAttachmentData(AttachmentInformation attachmentInformation);
    public sealed virtual JsonDocument GetDocument(string key);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteDatabaseOperations/<GetDocuments>d__28")]
public sealed virtual Task`1<IAsyncEnumerator`1<RavenJObject>> GetDocuments(Etag lastEtag, int take);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteDatabaseOperations/<GetIndexes>d__29")]
public sealed virtual Task`1<RavenJArray> GetIndexes(int totalCount);
    public sealed virtual Task`1<DatabaseStatistics> GetStats();
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteDatabaseOperations/<GetTransformers>d__31")]
public sealed virtual Task`1<RavenJArray> GetTransformers(int start);
    public sealed virtual Task`1<BuildNumber> GetVersion(RavenConnectionStringOptions server);
    public sealed virtual void PurgeTombstones(OperationState result);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteDatabaseOperations/<PutAttachment>d__34")]
[ObsoleteAttribute("Use RavenFS instead.")]
public sealed virtual Task PutAttachment(AttachmentExportInfo attachmentExportInfo);
    public sealed virtual Task PutDocument(RavenJObject document, int size);
    public sealed virtual Task PutIndex(string indexName, RavenJToken index);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteDatabaseOperations/<PutTransformer>d__37")]
public sealed virtual Task PutTransformer(string transformerName, RavenJToken transformer);
    public virtual void ShowProgress(string format, Object[] args);
    public sealed virtual Task`1<RavenJObject> TransformDocument(RavenJObject document, string transformScript);
    public sealed virtual RavenJObject StripReplicationInformationFromMetadata(RavenJObject metadata);
    public sealed virtual void Initialize(SmugglerDatabaseOptions databaseOptions);
    public sealed virtual void Configure(SmugglerDatabaseOptions databaseOptions);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteDatabaseOperations/<GetIdentities>d__43")]
public sealed virtual Task`1<List`1<KeyValuePair`2<string, long>>> GetIdentities();
    public sealed virtual Task SeedIdentityFor(string identityName, long identityValue);
    public sealed virtual Task SeedIdentities(List`1<KeyValuePair`2<string, long>> itemsToInsert);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteDatabaseOperations/<WaitForLastBulkInsertTaskToFinish>d__46")]
public sealed virtual Task WaitForLastBulkInsertTaskToFinish();
    public sealed virtual Task`1<IAsyncEnumerator`1<RavenJObject>> ExportItems(ItemType types, OperationState state);
    public sealed virtual string GetIdentifier();
}
public class Raven.Smuggler.SmugglerRemoteFilesOperations : object {
    private Func`1<FilesStore> primaryStore;
    private Func`1<DocumentStore> documentStore;
    private static int RetriesCount;
    [CompilerGeneratedAttribute]
private SmugglerFilesOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LastRequestErrored>k__BackingField;
    protected FilesStore PrimaryStore { get; }
    protected DocumentStore DocumentStore { get; }
    public SmugglerFilesOptions Options { get; private set; }
    public bool LastRequestErrored { get; public set; }
    public bool IsEmbedded { get; }
    public SmugglerRemoteFilesOperations(Func`1<FilesStore> primaryStore, Func`1<DocumentStore> documentStore);
    protected FilesStore get_PrimaryStore();
    protected DocumentStore get_DocumentStore();
    [CompilerGeneratedAttribute]
public sealed virtual SmugglerFilesOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(SmugglerFilesOptions value);
    [CompilerGeneratedAttribute]
public bool get_LastRequestErrored();
    [CompilerGeneratedAttribute]
public void set_LastRequestErrored(bool value);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteFilesOperations/<GetStats>d__16")]
public virtual Task`1<FileSystemStats[]> GetStats();
    public virtual Task`1<BuildNumber> GetVersion(FilesConnectionStringOptions server);
    public virtual LastFilesEtagsInfo FetchCurrentMaxEtags();
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteFilesOperations/<GetFiles>d__19")]
public virtual Task`1<IAsyncEnumerator`1<FileHeader>> GetFiles(Etag lastEtag, int take);
    public virtual Task`1<Stream> DownloadFile(FileHeader file);
    public virtual Task PutFile(FileHeader file, Stream data, long size);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteFilesOperations/<GetConfigurations>d__22")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, RavenJObject>>> GetConfigurations(int start, int take);
    public virtual Task PutConfig(string name, RavenJObject value);
    public virtual void Initialize(SmugglerFilesOptions options);
    public virtual void Configure(SmugglerFilesOptions options);
    public virtual void ShowProgress(string format, Object[] args);
    public virtual string CreateIncrementalKey();
    public virtual Task`1<ExportFilesDestinations> GetIncrementalExportKey();
    public virtual Task PutIncrementalExportKey(ExportFilesDestinations destinations);
    public sealed virtual RavenJObject StripReplicationInformationFromMetadata(RavenJObject metadata);
    public sealed virtual RavenJObject DisableVersioning(RavenJObject metadata);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteFilesOperations/<ReceiveFilesInStream>d__32")]
public sealed virtual Task`1<Stream> ReceiveFilesInStream(List`1<string> filePaths);
    [AsyncStateMachineAttribute("Raven.Smuggler.SmugglerRemoteFilesOperations/<UploadFilesInStream>d__33")]
public sealed virtual Task UploadFilesInStream(FileUploadUnitOfWork[] files);
    public sealed virtual bool get_IsEmbedded();
}
public class Raven.Storage.Esent.Backup.EsentBackup : object {
    private JET_INSTANCE instance;
    private string destination;
    private BackupGrbit backupOptions;
    private CancellationToken token;
    [CompilerGeneratedAttribute]
private Action`3<string, Exception, BackupMessageSeverity> Notify;
    public EsentBackup(JET_INSTANCE instance, string destination, BackupGrbit backupOptions, CancellationToken token);
    [CompilerGeneratedAttribute]
public void add_Notify(Action`3<string, Exception, BackupMessageSeverity> value);
    [CompilerGeneratedAttribute]
public void remove_Notify(Action`3<string, Exception, BackupMessageSeverity> value);
    public void Execute();
    private JET_err StatusCallback(JET_SESID sesid, JET_SNP snp, JET_SNT snt, object data);
    [CompilerGeneratedAttribute]
private void <Execute>b__8_0();
}
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static class Raven.Storage.Esent.EsentExtension : object {
    [ExtensionAttribute]
public static void WithDatabase(JET_INSTANCE instance, string database, Func`4<Session, JET_DBID, Transaction, Transaction> action);
}
[CLSCompliantAttribute("False")]
public class Raven.Storage.Esent.SchemaCreator : object {
    public static string SchemaVersion;
    private Session session;
    public SchemaCreator(Session session);
    public void Create(string database);
    private void CreateIdentityTable(JET_DBID dbid);
    internal void CreateIndexingStatsTable(JET_DBID dbid);
    internal void CreateIndexingEtagsTable(JET_DBID dbid);
    internal void CreateIndexingStatsReduceTable(JET_DBID dbid);
    private void CreateDocumentsTable(JET_DBID dbid);
    private void CreateIndexes(JET_TABLEID tableid, JET_INDEXCREATE[] indexes);
    public static void CreateIndexes(Session session, JET_TABLEID tableid, JET_INDEXCREATE[] indexes);
    internal void CreateScheduledReductionsTable(JET_DBID dbid);
    internal void CreateMapResultsTable(JET_DBID dbid);
    internal void CreateReduceResultsTable(JET_DBID dbid);
    internal void CreateTasksTable(JET_DBID dbid);
    public static ColumndefGrbit ColumnNotNullIfOnHigherThanWindowsXp();
    private void CreateFilesTable(JET_DBID dbid);
    public void CreateListsTable(JET_DBID dbid);
    public void CreateQueueTable(JET_DBID dbid);
    private void CreateDetailsTable(JET_DBID dbid);
    internal void CreateReduceKeysCountsTable(JET_DBID dbid);
    internal void CreateReduceKeysStatusTable(JET_DBID dbid);
    internal void CreateIndexedDocumentsReferencesTable(JET_DBID dbid);
    public static void UpdateVersion(Session session, JET_DBID dbid, string newVersion);
}
[InheritedExportAttribute]
public interface Raven.Storage.Esent.SchemaUpdates.ISchemaUpdate {
    public string FromSchemaVersion { get; }
    public abstract virtual string get_FromSchemaVersion();
    public abstract virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public abstract virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From36To37 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
    public void CreateListsTable(Session session, JET_DBID dbid);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From37To38 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
    private void CreateScheduledReductionsTable(Session session, JET_DBID dbid);
    private void CreateMapResultsTable(Session session, JET_DBID dbid);
    private void CreateReduceResultsTable(Session session, JET_DBID dbid);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From38To39 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From39To40 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From40To41 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
    private void CreateReduceKeysCountsTable(Session session, JET_DBID dbid);
    private void CreateReduceKeysStatusTable(Session session, JET_DBID dbid);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From41To42 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From42To43 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From43To44 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
    private void CreateIndexedDocumentsReferencesTable(Session session, JET_DBID dbid);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From44To45 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From45To46 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public class Raven.Storage.Esent.SchemaUpdates.Updates.From46To47 : object {
    public string FromSchemaVersion { get; }
    public sealed virtual string get_FromSchemaVersion();
    public sealed virtual void Init(IUuidGenerator generator, InMemoryRavenConfiguration configuration);
    public sealed virtual void Update(Session session, JET_DBID dbid, Action`1<string> output);
}
public static class Raven.Storage.Esent.StorageActions.IndexReaderBuffers : object {
    private static BufferManager buffers;
    public static BufferManager Buffers { get; }
    private static IndexReaderBuffers();
    public static BufferManager get_Buffers();
}
public class Raven.Storage.Esent.StorageActions.OptimizedDeleter : object {
    private static int bookmarkMost;
    private ConcurrentSet`1<Key> itemsToDelete;
    private RemainingReductionPerLevel itemsToDeletePerViewAndLevel;
    [CompilerGeneratedAttribute]
private int <IndexId>k__BackingField;
    public RemainingReductionPerLevel ItemsToDeletePerViewAndLevel { get; }
    public int IndexId { get; public set; }
    private static OptimizedDeleter();
    public RemainingReductionPerLevel get_ItemsToDeletePerViewAndLevel();
    [CompilerGeneratedAttribute]
public int get_IndexId();
    [CompilerGeneratedAttribute]
public void set_IndexId(int value);
    public bool Add(JET_SESID session, JET_TABLEID table, int level);
    public IEnumerable`1<Tuple`2<Byte[], int>> GetSortedBookmarks();
}
public class Raven.Storage.Esent.StorageActions.OptimizedIndexReader : OptimizedIndexReader`1<object> {
    public bool Add(JET_SESID session, JET_TABLEID table);
    public OptimizedIndexReader Where(Func`1<bool> filter);
    public IEnumerable`1<TResult> Select(JET_SESID session, JET_TABLEID table, Func`1<TResult> func);
}
public class Raven.Storage.Esent.StorageActions.OptimizedIndexReader`1 : object {
    private List`1<Key<T>> primaryKeyIndexes;
    private static int bookmarkMost;
    private Func`2<T, bool> filter;
    public int Count { get; }
    public OptimizedIndexReader`1(int size);
    private static OptimizedIndexReader`1();
    public int get_Count();
    public bool Add(JET_SESID session, JET_TABLEID table, T item);
    [IteratorStateMachineAttribute("Raven.Storage.Esent.StorageActions.OptimizedIndexReader`1/<GetSortedBookmarks>d__8")]
public IEnumerable`1<Tuple`2<Byte[], int>> GetSortedBookmarks();
    public IEnumerable`1<TResult> Select(JET_SESID session, JET_TABLEID table, Func`2<T, TResult> func);
    private void SortPrimaryKeys();
    public OptimizedIndexReader`1<T> Where(Func`2<T, bool> predicate);
}
[CLSCompliantAttribute("False")]
public class Raven.Storage.Esent.StorageActionsAccessor : object {
    private DocumentStorageActions inner;
    [CompilerGeneratedAttribute]
private Action OnDispose;
    private DateTime createdAt;
    [CompilerGeneratedAttribute]
private IInFlightStateSnapshot <InFlightStateSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNested>k__BackingField;
    private List`1<DatabaseTask> tasks;
    private Action`1<JsonDocument[]> afterCommitAction;
    private List`1<JsonDocument> docsForCommit;
    public DocumentStorageActions Inner { get; }
    public IDocumentStorageActions Documents { get; }
    public IQueueStorageActions Queue { get; }
    public ITasksStorageActions Tasks { get; }
    public IStalenessStorageActions Staleness { get; }
    public IListsStorageActions Lists { get; }
    [ObsoleteAttribute("Use RavenFS instead.")]
public IAttachmentsStorageActions Attachments { get; }
    public IIndexingStorageActions Indexing { get; }
    public IGeneralStorageActions General { get; }
    public IMappedResultsStorageAction MapReduce { get; }
    public IInFlightStateSnapshot InFlightStateSnapshot { get; private set; }
    public bool IsNested { get; public set; }
    [CLSCompliantAttribute("False")]
public StorageActionsAccessor(DocumentStorageActions inner, IInFlightStateSnapshot snapshot);
    public DocumentStorageActions get_Inner();
    [CompilerGeneratedAttribute]
public void add_OnDispose(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnDispose(Action value);
    public sealed virtual IDocumentStorageActions get_Documents();
    public sealed virtual IQueueStorageActions get_Queue();
    public sealed virtual ITasksStorageActions get_Tasks();
    public sealed virtual IStalenessStorageActions get_Staleness();
    public sealed virtual IListsStorageActions get_Lists();
    public sealed virtual IAttachmentsStorageActions get_Attachments();
    public sealed virtual IIndexingStorageActions get_Indexing();
    public sealed virtual IGeneralStorageActions get_General();
    public sealed virtual IMappedResultsStorageAction get_MapReduce();
    [CompilerGeneratedAttribute]
public sealed virtual IInFlightStateSnapshot get_InFlightStateSnapshot();
    [CompilerGeneratedAttribute]
private void set_InFlightStateSnapshot(IInFlightStateSnapshot value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsNested();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsNested(bool value);
    public sealed virtual void add_OnStorageCommit(Action value);
    public sealed virtual void remove_OnStorageCommit(Action value);
    public sealed virtual void add_BeforeStorageCommit(Action value);
    public sealed virtual void remove_BeforeStorageCommit(Action value);
    public sealed virtual void add_AfterStorageCommit(Action value);
    public sealed virtual void remove_AfterStorageCommit(Action value);
    public sealed virtual T GetTask(Func`2<T, bool> predicate, T newTask);
    public sealed virtual void AfterStorageCommitBeforeWorkNotifications(JsonDocument doc, Action`1<JsonDocument[]> afterCommit);
    [DebuggerHiddenAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public void SaveAllTasks();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <AfterStorageCommitBeforeWorkNotifications>b__47_0();
}
public class Raven.Storage.Esent.TableColumnsCache : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <DocumentsColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <TasksColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <FilesColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <IndexesStatsColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <IndexesStatsReduceColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <IndexesEtagsColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <MappedResultsColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <ReduceResultsColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <ScheduledReductionColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <IdentityColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <DetailsColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <QueueColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <ListsColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <ReduceKeysCountsColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <ReduceKeysStatusColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JET_COLUMNID> <IndexedDocumentsReferencesColumns>k__BackingField;
    public IDictionary`2<string, JET_COLUMNID> DocumentsColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> TasksColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> FilesColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> IndexesStatsColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> IndexesStatsReduceColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> IndexesEtagsColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> MappedResultsColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> ReduceResultsColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> ScheduledReductionColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> IdentityColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> DetailsColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> QueueColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> ListsColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> ReduceKeysCountsColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> ReduceKeysStatusColumns { get; public set; }
    public IDictionary`2<string, JET_COLUMNID> IndexedDocumentsReferencesColumns { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_DocumentsColumns();
    [CompilerGeneratedAttribute]
public void set_DocumentsColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_TasksColumns();
    [CompilerGeneratedAttribute]
public void set_TasksColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_FilesColumns();
    [CompilerGeneratedAttribute]
public void set_FilesColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_IndexesStatsColumns();
    [CompilerGeneratedAttribute]
public void set_IndexesStatsColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_IndexesStatsReduceColumns();
    [CompilerGeneratedAttribute]
public void set_IndexesStatsReduceColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_IndexesEtagsColumns();
    [CompilerGeneratedAttribute]
public void set_IndexesEtagsColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_MappedResultsColumns();
    [CompilerGeneratedAttribute]
public void set_MappedResultsColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_ReduceResultsColumns();
    [CompilerGeneratedAttribute]
public void set_ReduceResultsColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_ScheduledReductionColumns();
    [CompilerGeneratedAttribute]
public void set_ScheduledReductionColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_IdentityColumns();
    [CompilerGeneratedAttribute]
public void set_IdentityColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_DetailsColumns();
    [CompilerGeneratedAttribute]
public void set_DetailsColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_QueueColumns();
    [CompilerGeneratedAttribute]
public void set_QueueColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_ListsColumns();
    [CompilerGeneratedAttribute]
public void set_ListsColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_ReduceKeysCountsColumns();
    [CompilerGeneratedAttribute]
public void set_ReduceKeysCountsColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_ReduceKeysStatusColumns();
    [CompilerGeneratedAttribute]
public void set_ReduceKeysStatusColumns(IDictionary`2<string, JET_COLUMNID> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JET_COLUMNID> get_IndexedDocumentsReferencesColumns();
    [CompilerGeneratedAttribute]
public void set_IndexedDocumentsReferencesColumns(IDictionary`2<string, JET_COLUMNID> value);
    public void InitColumDictionaries(JET_INSTANCE instance, string database);
}
public class Raven.Storage.Esent.TransactionalStorage : CriticalFinalizerObject {
    private static int instanceCounter;
    private ThreadLocal`1<StorageActionsAccessor> current;
    private ThreadLocal`1<object> disableBatchNesting;
    private ThreadLocal`1<EsentTransactionContext> dtcTransactionContext;
    private string database;
    private InMemoryRavenConfiguration configuration;
    private Action onCommit;
    private ReaderWriterLockSlim disposerLock;
    private string path;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed;
    private JET_INSTANCE instance;
    private TableColumnsCache tableColumnsCache;
    private IUuidGenerator generator;
    private IDocumentCacher documentCacher;
    private EsentInFlightTransactionalState inFlightTransactionalState;
    private static ILog log;
    private ConcurrentDictionary`2<int, RemainingReductionPerLevel> scheduledReductionsPerViewAndLevel;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<ISchemaUpdate> <Updaters>k__BackingField;
    private static object UpdateLocker;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    private long getDatabaseTransactionVersionSizeInBytesErrorValue;
    private bool reportedGetDatabaseTransactionCacheSizeInBytesError;
    private string uniquePrefix;
    private static object compactLocker;
    private Action onNestedTransactionEnter;
    private Action onNestedTransactionExit;
    [CompilerGeneratedAttribute]
private OrderedPartCollection`1<AbstractDocumentCodec> <DocumentCodecs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxVerPagesValueInBytes>k__BackingField;
    private static String[] indexingDropTables;
    [ImportManyAttribute]
public OrderedPartCollection`1<ISchemaUpdate> Updaters { get; public set; }
    public TableColumnsCache TableColumnsCache { get; }
    public JET_INSTANCE Instance { get; }
    public string Database { get; }
    public Guid Id { get; private set; }
    public IDocumentCacher DocumentCacher { get; }
    public string FriendlyName { get; }
    public bool SupportsDtc { get; }
    protected OrderedPartCollection`1<AbstractDocumentCodec> DocumentCodecs { get; protected set; }
    public long MaxVerPagesValueInBytes { get; public set; }
    public bool SkipConsistencyCheck { get; }
    public bool IsAlreadyInBatch { get; }
    public TransactionalStorage(InMemoryRavenConfiguration configuration, Action onCommit, Action onStorageInaccessible, Action onNestedTransactionEnter, Action onNestedTransactionExit);
    private static TransactionalStorage();
    [CompilerGeneratedAttribute]
public OrderedPartCollection`1<ISchemaUpdate> get_Updaters();
    [CompilerGeneratedAttribute]
public void set_Updaters(OrderedPartCollection`1<ISchemaUpdate> value);
    public sealed virtual ConcurrentDictionary`2<int, RemainingReductionPerLevel> GetScheduledReductionsPerViewAndLevel();
    public sealed virtual void ResetScheduledReductionsTracking();
    public sealed virtual void RegisterTransactionalStorageNotificationHandler(ITransactionalStorageNotificationHandler handler);
    public TableColumnsCache get_TableColumnsCache();
    public JET_INSTANCE get_Instance();
    public string get_Database();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    public sealed virtual IDocumentCacher get_DocumentCacher();
    public sealed virtual void Dispose();
    public sealed virtual Task StartBackupOperation(DocumentDatabase docDb, string backupDestinationDirectory, bool incrementalBackup, DatabaseDocument documentDatabase, ResourceBackupState state, CancellationToken cancellationToken);
    public sealed virtual void Restore(DatabaseRestoreRequest restoreRequest, Action`1<string> output, InMemoryRavenConfiguration globalConfiguration);
    public sealed virtual DatabaseSizeInformation GetDatabaseSize();
    public sealed virtual long GetDatabaseCacheSizeInBytes();
    public sealed virtual long GetDatabaseTransactionVersionSizeInBytes();
    public sealed virtual StorageStats GetStorageStats();
    public sealed virtual string get_FriendlyName();
    public sealed virtual bool HandleException(Exception exception);
    public sealed virtual bool get_SupportsDtc();
    private sealed virtual override void Raven.Database.Storage.ITransactionalStorage.Compact(InMemoryRavenConfiguration cfg, Action`1<string> output);
    private static void RecoverFromFailedCompact(string file);
    public static void Compact(InMemoryRavenConfiguration ravenConfiguration, JET_PFNSTATUS statusCallback);
    private static void CompactInternal(InMemoryRavenConfiguration ravenConfiguration, JET_PFNSTATUS statusCallback);
    public static void CreateInstance(JET_INSTANCE& compactInstance, string name);
    public sealed virtual Guid ChangeId();
    public sealed virtual void DumpAllStorageTables();
    public sealed virtual IList`1<string> ComputeDetailedStorageInformation(bool computeExactSizes, Action`1<string> progress, CancellationToken token);
    [CLSCompliantAttribute("False")]
public sealed virtual InFlightTransactionalState InitializeInFlightTransactionalState(DocumentDatabase self, Func`6<string, Etag, RavenJObject, RavenJObject, TransactionInformation, PutResult> put, Func`4<string, Etag, TransactionInformation, bool> delete);
    public sealed virtual void ClearCaches();
    public sealed virtual void Initialize(IUuidGenerator uuidGenerator, OrderedPartCollection`1<AbstractDocumentCodec> documentCodecs, Action`1<string> putResourceMarker, Action`2<object, Exception> onErrorAction);
    [CompilerGeneratedAttribute]
protected OrderedPartCollection`1<AbstractDocumentCodec> get_DocumentCodecs();
    [CompilerGeneratedAttribute]
protected void set_DocumentCodecs(OrderedPartCollection`1<AbstractDocumentCodec> value);
    [CompilerGeneratedAttribute]
public long get_MaxVerPagesValueInBytes();
    [CompilerGeneratedAttribute]
public void set_MaxVerPagesValueInBytes(long value);
    private void SetIdFromDb();
    public sealed virtual void DropAllIndexingInformation();
    private bool EnsureDatabaseIsCreatedAndAttachToDatabase();
    protected virtual override void Finalize();
    public sealed virtual IDisposable DisableBatchNesting();
    public IDisposable SetTransactionContext(EsentTransactionContext context);
    [CLSCompliantAttribute("False")]
public sealed virtual void Batch(Action`1<IStorageActionsAccessor> action);
    private Action ExecuteBatch(Action`1<IStorageActionsAccessor> action, EsentTransactionContext transactionContext);
    public sealed virtual IStorageActionsAccessor CreateAccessor();
    public sealed virtual bool get_SkipConsistencyCheck();
    public sealed virtual void ExecuteImmediatelyOrRegisterForSynchronization(Action action);
    public sealed virtual bool get_IsAlreadyInBatch();
    internal StorageActionsAccessor GetCurrentBatch();
    public static void DisableIndexChecking(JET_INSTANCE jetInstance);
    private void Output(string message);
    public sealed virtual List`1<TransactionContextData> GetPreparedTransactions();
    public sealed virtual object GetInFlightTransactionsInternalStateForDebugOnly();
    [CompilerGeneratedAttribute]
private void <Dispose>b__38_0();
    [CompilerGeneratedAttribute]
private bool <GetDatabaseTransactionVersionSizeInBytes>b__46_0(string x);
    [CompilerGeneratedAttribute]
private void <DumpAllStorageTables>b__62_0(IStorageActionsAccessor accessor);
    [CompilerGeneratedAttribute]
private Transaction <SetIdFromDb>b__75_0(Session session, JET_DBID dbid, Transaction tx);
    [CompilerGeneratedAttribute]
private void <DropAllIndexingInformation>b__76_0(IStorageActionsAccessor accessor);
    [CompilerGeneratedAttribute]
private JET_err <EnsureDatabaseIsCreatedAndAttachToDatabase>b__78_0(JET_SESID sesid, JET_SNP snp, JET_SNT snt, object data);
    [CompilerGeneratedAttribute]
private void <DisableBatchNesting>b__80_0();
    [CompilerGeneratedAttribute]
private void <SetTransactionContext>b__81_0();
}
public class Raven.Storage.Esent.TransactionalStorageConfigurator : StorageConfigurator {
    private TransactionalStorage transactionalStorage;
    protected string BaseName { get; }
    protected string EventSource { get; }
    public TransactionalStorageConfigurator(InMemoryRavenConfiguration configuration, TransactionalStorage transactionalStorage);
    protected virtual void ConfigureInstanceInternal(int maxVerPages);
    protected virtual string get_BaseName();
    protected virtual string get_EventSource();
}
public class Raven.Storage.Voron.TransactionalStorage : object {
    private static ILog Log;
    private ConcurrentSet`1<WeakReference`1<ITransactionalStorageNotificationHandler>> lowMemoryHandlers;
    private ThreadLocal`1<IStorageActionsAccessor> current;
    private ThreadLocal`1<object> disableBatchNesting;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) disposed;
    private DisposableAction exitLockDisposable;
    private ReaderWriterLockSlim disposerLock;
    private OrderedPartCollection`1<AbstractDocumentCodec> _documentCodecs;
    private IDocumentCacher documentCacher;
    private IUuidGenerator uuidGenerator;
    private InMemoryRavenConfiguration configuration;
    private Action onCommit;
    private Action onStorageInaccessible;
    private TableStorage tableStorage;
    private IBufferPool bufferPool;
    private Action onNestedTransactionExit;
    private Action onNestedTransactionEnter;
    private Lazy`1<ConcurrentDictionary`2<int, RemainingReductionPerLevel>> scheduledReductionsPerViewAndLevel;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Guid Id { get; private set; }
    public IDocumentCacher DocumentCacher { get; }
    public bool SkipConsistencyCheck { get; }
    public string FriendlyName { get; }
    public bool IsAlreadyInBatch { get; }
    public bool SupportsDtc { get; }
    public StorageEnvironment Environment { get; }
    public TransactionalStorage(InMemoryRavenConfiguration configuration, Action onCommit, Action onStorageInaccessible, Action onNestedTransactionEnter, Action onNestedTransactionExit);
    private static TransactionalStorage();
    public sealed virtual void Dispose();
    public sealed virtual void DropAllIndexingInformation();
    public sealed virtual ConcurrentDictionary`2<int, RemainingReductionPerLevel> GetScheduledReductionsPerViewAndLevel();
    public sealed virtual void ResetScheduledReductionsTracking();
    public sealed virtual void RegisterTransactionalStorageNotificationHandler(ITransactionalStorageNotificationHandler handler);
    private void RunTransactionalStorageNotificationHandlers();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    public sealed virtual IDocumentCacher get_DocumentCacher();
    public sealed virtual IDisposable DisableBatchNesting();
    public sealed virtual IStorageActionsAccessor CreateAccessor();
    public sealed virtual bool get_SkipConsistencyCheck();
    public sealed virtual void Batch(Action`1<IStorageActionsAccessor> action);
    private Action ExecuteBatch(Action`1<IStorageActionsAccessor> action);
    public sealed virtual void ExecuteImmediatelyOrRegisterForSynchronization(Action action);
    public sealed virtual void Initialize(IUuidGenerator generator, OrderedPartCollection`1<AbstractDocumentCodec> documentCodecs, Action`1<string> putResourceMarker, Action`2<object, Exception> onError);
    private void SetupDatabaseId();
    private static StorageEnvironmentOptions CreateMemoryStorageOptionsFromConfiguration(InMemoryRavenConfiguration configuration);
    private static StorageEnvironmentOptions CreateStorageOptionsFromConfiguration(InMemoryRavenConfiguration configuration);
    public sealed virtual Task StartBackupOperation(DocumentDatabase database, string backupDestinationDirectory, bool incrementalBackup, DatabaseDocument documentDatabase, ResourceBackupState state, CancellationToken cancellationToken);
    public sealed virtual void Restore(DatabaseRestoreRequest restoreRequest, Action`1<string> output, InMemoryRavenConfiguration globalConfiguration);
    public sealed virtual DatabaseSizeInformation GetDatabaseSize();
    public sealed virtual long GetDatabaseCacheSizeInBytes();
    public sealed virtual long GetDatabaseTransactionVersionSizeInBytes();
    public sealed virtual StorageStats GetStorageStats();
    public sealed virtual string get_FriendlyName();
    public sealed virtual bool HandleException(Exception exception);
    public sealed virtual bool get_IsAlreadyInBatch();
    public sealed virtual bool get_SupportsDtc();
    public sealed virtual void Compact(InMemoryRavenConfiguration ravenConfiguration, Action`1<string> output);
    private static void RecoverFromFailedCompact(string sourcePath);
    public sealed virtual Guid ChangeId();
    public sealed virtual void ClearCaches();
    public sealed virtual void DumpAllStorageTables();
    public StorageEnvironment get_Environment();
    [CLSCompliantAttribute("False")]
public sealed virtual InFlightTransactionalState InitializeInFlightTransactionalState(DocumentDatabase self, Func`6<string, Etag, RavenJObject, RavenJObject, TransactionInformation, PutResult> put, Func`4<string, Etag, TransactionInformation, bool> delete);
    public sealed virtual IList`1<string> ComputeDetailedStorageInformation(bool computeExactSizes, Action`1<string> progress, CancellationToken token);
    public sealed virtual List`1<TransactionContextData> GetPreparedTransactions();
    public sealed virtual object GetInFlightTransactionsInternalStateForDebugOnly();
    internal IStorageActionsAccessor GetCurrentBatch();
    private void Output(string message);
    private IDocumentCacher CreateDocumentCacher(InMemoryRavenConfiguration configuration);
    [CompilerGeneratedAttribute]
private void <.ctor>b__18_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__19_0();
    [CompilerGeneratedAttribute]
private void <Dispose>b__19_1();
    [CompilerGeneratedAttribute]
private void <Dispose>b__19_2();
    [CompilerGeneratedAttribute]
private void <Dispose>b__19_3();
    [CompilerGeneratedAttribute]
private void <DropAllIndexingInformation>b__20_0(IStorageActionsAccessor accessor);
    [CompilerGeneratedAttribute]
private void <RunTransactionalStorageNotificationHandlers>b__24_0(WeakReference`1<ITransactionalStorageNotificationHandler> x);
    [CompilerGeneratedAttribute]
private void <DisableBatchNesting>b__31_0();
}
[AttributeUsageAttribute("1")]
public class RavenVersionAttribute : Attribute {
    private string build;
    [CompilerGeneratedAttribute]
private string <CommitHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string CommitHash { get; public set; }
    public string Build { get; public set; }
    public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CommitHash();
    [CompilerGeneratedAttribute]
public void set_CommitHash(string value);
    public string get_Build();
    public void set_Build(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
}
public abstract class Rhino.Licensing.AbstractLicenseValidator : object {
    protected ILog Logger;
    private bool licenseInfoLogged;
    protected String[] TimeServers;
    public static String[] StandardTimeServer;
    private string licenseServerUrl;
    private Guid clientId;
    private string publicKey;
    private Timer nextLeaseTimer;
    private bool disableFutureChecks;
    private bool currentlyValidatingLicense;
    private DiscoveryHost discoveryHost;
    private DiscoveryClient discoveryClient;
    private Guid senderId;
    private SntpClient sntpClient;
    [CompilerGeneratedAttribute]
private Action`1<InvalidationType> LicenseInvalidated;
    [CompilerGeneratedAttribute]
private DateTime <ExpirationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private MultipleLicenseUsage <MultipleLicenseUsageBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubscriptionEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseType <LicenseType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableFloatingLicenses>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <LicenseAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClientDiscoveredEventArgs> MultipleLicensesWereDiscovered;
    [CompilerGeneratedAttribute]
private TimeSpan <LeaseTimeout>k__BackingField;
    public object LicenseAttributesLock;
    public DateTime ExpirationDate { get; private set; }
    public MultipleLicenseUsage MultipleLicenseUsageBehavior { get; public set; }
    public string SubscriptionEndpoint { get; public set; }
    public LicenseType LicenseType { get; private set; }
    public Guid UserId { get; private set; }
    public string Name { get; private set; }
    public bool DisableFloatingLicenses { get; public set; }
    public Dictionary`2<string, string> LicenseAttributes { get; private set; }
    protected string License { get; protected set; }
    public TimeSpan LeaseTimeout { get; public set; }
    protected AbstractLicenseValidator(string publicKey);
    protected AbstractLicenseValidator(string publicKey, string licenseServerUrl, Guid clientId);
    private static AbstractLicenseValidator();
    [CompilerGeneratedAttribute]
public void add_LicenseInvalidated(Action`1<InvalidationType> value);
    [CompilerGeneratedAttribute]
public void remove_LicenseInvalidated(Action`1<InvalidationType> value);
    [CompilerGeneratedAttribute]
public DateTime get_ExpirationDate();
    [CompilerGeneratedAttribute]
private void set_ExpirationDate(DateTime value);
    [CompilerGeneratedAttribute]
public MultipleLicenseUsage get_MultipleLicenseUsageBehavior();
    [CompilerGeneratedAttribute]
public void set_MultipleLicenseUsageBehavior(MultipleLicenseUsage value);
    [CompilerGeneratedAttribute]
public string get_SubscriptionEndpoint();
    [CompilerGeneratedAttribute]
public void set_SubscriptionEndpoint(string value);
    [CompilerGeneratedAttribute]
public LicenseType get_LicenseType();
    [CompilerGeneratedAttribute]
private void set_LicenseType(LicenseType value);
    [CompilerGeneratedAttribute]
public Guid get_UserId();
    [CompilerGeneratedAttribute]
private void set_UserId(Guid value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_DisableFloatingLicenses();
    [CompilerGeneratedAttribute]
public void set_DisableFloatingLicenses(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_LicenseAttributes();
    [CompilerGeneratedAttribute]
private void set_LicenseAttributes(Dictionary`2<string, string> value);
    protected abstract virtual string get_License();
    protected abstract virtual void set_License(string value);
    private void LeaseLicenseAgain(object state);
    private void RaiseLicenseInvalidated();
    private void DiscoveryHostOnClientDiscovered(object sender, ClientDiscoveredEventArgs clientDiscoveredEventArgs);
    [CompilerGeneratedAttribute]
public void add_MultipleLicensesWereDiscovered(EventHandler`1<ClientDiscoveredEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MultipleLicensesWereDiscovered(EventHandler`1<ClientDiscoveredEventArgs> value);
    public virtual void AssertValidLicense(bool turnOffDiscoveryClient);
    public virtual void AssertValidLicense(Action onValidLicense, bool turnOffDiscoveryClient, bool firstTime, bool forceUpdate);
    private bool IsLicenseValid(bool firstTime, bool forceUpdate);
    private bool ValidateLicense(bool firstTime, bool forceUpdate);
    public bool IsOemLicense();
    private bool ValidateWithoutUsingSubscriptionLeasing();
    private void TryGettingNewLeaseSubscription();
    protected bool TryOverwritingWithNewLicense(string newLicense);
    private void ValidateUsingNetworkTime();
    public virtual void RemoveExistingLicense();
    public bool TryLoadingLicenseValuesFromValidatedXml();
    [CompilerGeneratedAttribute]
public TimeSpan get_LeaseTimeout();
    [CompilerGeneratedAttribute]
public void set_LeaseTimeout(TimeSpan value);
    private bool ValidateFloatingLicense(string publicKeyOfFloatingLicense);
    internal bool ValidateXmlDocumentLicense(XmlDocument doc);
    private bool TryGetValidDocument(string licensePublicKey, XmlDocument doc);
    public void DisableFutureChecks();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <ValidateUsingNetworkTime>b__69_0(Task`1<DateTime> task);
}
public class Rhino.Licensing.CorruptLicenseFileException : RhinoLicensingException {
    public CorruptLicenseFileException(string message);
    public CorruptLicenseFileException(string message, Exception inner);
    protected CorruptLicenseFileException(SerializationInfo info, StreamingContext context);
}
public class Rhino.Licensing.Discovery.DiscoveryClient : object {
    private TimeSpan publishLimit;
    private Byte[] buffer;
    private UdpClient udpClient;
    private IPEndPoint allHostsGroup;
    private DateTime lastPublish;
    public DiscoveryClient(Guid senderId, Guid userId, string machineName, string userName);
    public DiscoveryClient(Guid senderId, Guid userId, string machineName, string userName, TimeSpan publishLimit);
    public void PublishMyPresence();
    private sealed virtual override void System.IDisposable.Dispose();
}
public class Rhino.Licensing.Discovery.DiscoveryHost : object {
    private Socket socket;
    private Byte[] buffer;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClientDiscoveredEventArgs> ClientDiscovered;
    [CompilerGeneratedAttribute]
private bool <IsStop>k__BackingField;
    protected bool IsStop { get; protected set; }
    public void Start();
    private void StartListening();
    private void Completed(object sender, SocketAsyncEventArgs socketAsyncEventArgs);
    [CompilerGeneratedAttribute]
public void add_ClientDiscovered(EventHandler`1<ClientDiscoveredEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClientDiscovered(EventHandler`1<ClientDiscoveredEventArgs> value);
    private void InvokeClientDiscovered(ClientDiscoveredEventArgs e);
    public sealed virtual void Dispose();
    public void Stop();
    [CompilerGeneratedAttribute]
protected bool get_IsStop();
    [CompilerGeneratedAttribute]
protected void set_IsStop(bool value);
}
public class Rhino.Licensing.FloatingLicenseNotAvailableException : RhinoLicensingException {
    public FloatingLicenseNotAvailableException(string message);
    public FloatingLicenseNotAvailableException(string message, Exception inner);
    protected FloatingLicenseNotAvailableException(SerializationInfo info, StreamingContext context);
}
[ServiceContractAttribute]
public interface Rhino.Licensing.ILicensingService {
    [OperationContractAttribute]
public abstract virtual string LeaseLicense(string machine, string user, Guid id);
}
public enum Rhino.Licensing.InvalidationType : Enum {
    public int value__;
    public static InvalidationType CannotGetNewLicense;
    public static InvalidationType TimeExpired;
}
[ServiceContractAttribute]
public interface Rhino.Licensing.ISubscriptionLicensingService {
    [OperationContractAttribute]
public abstract virtual string LeaseLicense(string previousLicense);
}
public class Rhino.Licensing.LicenseExpiredException : RhinoLicensingException {
    public LicenseExpiredException(string message);
    public LicenseExpiredException(string message, Exception inner);
    public LicenseExpiredException(SerializationInfo info, StreamingContext context);
}
public class Rhino.Licensing.LicenseFileNotFoundException : RhinoLicensingException {
    public LicenseFileNotFoundException(string message);
    public LicenseFileNotFoundException(string message, Exception inner);
    protected LicenseFileNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Rhino.Licensing.LicenseGenerator : object {
    private string privateKey;
    public LicenseGenerator(string privateKey);
    public string GenerateFloatingLicense(string name, string publicKey);
    public string Generate(string name, Guid id, DateTime expirationDate, LicenseType licenseType);
    public string Generate(string name, Guid id, DateTime expirationDate, IDictionary`2<string, string> attributes, LicenseType licenseType);
    private static XmlElement GetXmlDigitalSignature(XmlDocument x, AsymmetricAlgorithm key);
    private static XmlDocument CreateDocument(Guid id, string name, DateTime expirationDate, IDictionary`2<string, string> attributes, LicenseType licenseType);
}
public class Rhino.Licensing.LicenseNotFoundException : RhinoLicensingException {
    public LicenseNotFoundException(string message);
    public LicenseNotFoundException(string message, Exception inner);
    protected LicenseNotFoundException(SerializationInfo info, StreamingContext context);
}
public enum Rhino.Licensing.LicenseType : Enum {
    public int value__;
    public static LicenseType None;
    public static LicenseType Trial;
    public static LicenseType Standard;
    public static LicenseType Personal;
    public static LicenseType Floating;
    public static LicenseType Subscription;
}
public class Rhino.Licensing.LicenseValidator : AbstractLicenseValidator {
    private string licensePath;
    private DateTime lastModified;
    private string inMemoryLicense;
    protected string License { get; protected set; }
    public LicenseValidator(string publicKey, string licensePath);
    public LicenseValidator(string publicKey, string licensePath, string licenseServerUrl, Guid clientId);
    protected virtual string get_License();
    protected virtual void set_License(string value);
    public virtual void AssertValidLicense(bool turnOffDiscoveryClient);
    public virtual void RemoveExistingLicense();
    public bool SameFile(string fullPath);
}
[ServiceBehaviorAttribute]
public class Rhino.Licensing.LicensingService : object {
    private List`1<LicenseValidator> availableLicenses;
    private Dictionary`2<string, KeyValuePair`2<DateTime, LicenseValidator>> leasedLicenses;
    private string state;
    [CompilerGeneratedAttribute]
private static string <SoftwarePublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <LicenseServerPrivateKey>k__BackingField;
    public static string SoftwarePublicKey { get; public set; }
    public static string LicenseServerPrivateKey { get; public set; }
    [CompilerGeneratedAttribute]
public static string get_SoftwarePublicKey();
    [CompilerGeneratedAttribute]
public static void set_SoftwarePublicKey(string value);
    [CompilerGeneratedAttribute]
public static string get_LicenseServerPrivateKey();
    [CompilerGeneratedAttribute]
public static void set_LicenseServerPrivateKey(string value);
    private static void EnsureLicenseDirectoryExists(string licensesDirectory);
    private void ReadAvailableLicenses(string licensesDirectory);
    private void ReadInitialState();
    private void ReadState(Stream stream);
    private void WriteState(Stream stream);
    public sealed virtual string LeaseLicense(string machine, string user, Guid id);
    private string GenerateLicenseAndRenewLease(string identifier, Guid id, LicenseValidator licenseValidator, IDictionary`2<string, string> attributes);
    private static string GenerateLicense(Guid id, LicenseValidator validator, IDictionary`2<string, string> attributes);
}
public class Rhino.Licensing.RhinoLicensingException : Exception {
    protected RhinoLicensingException(string message);
    protected RhinoLicensingException(string message, Exception inner);
    protected RhinoLicensingException(SerializationInfo info, StreamingContext context);
}
public class Rhino.Licensing.SntpClient : object {
    private ILog log;
    public static byte SntpDataLength;
    private String[] hosts;
    private int index;
    public SntpClient(String[] hosts);
    private static SntpClient();
    private static bool GetIsServerMode(Byte[] sntpData);
    public static DateTime GetTransmitTimestamp(Byte[] sntpData);
    private static DateTime ComputeDate(ulong milliseconds);
    private static ulong GetMilliseconds(Byte[] sntpData, byte offset);
    [AsyncStateMachineAttribute("Rhino.Licensing.SntpClient/<GetDateAsync>d__9")]
public Task`1<DateTime> GetDateAsync();
    public static bool IsResponseValid(Byte[] sntpData);
}
public class Rhino.Licensing.StringLicenseValidator : AbstractLicenseValidator {
    [CompilerGeneratedAttribute]
private string <License>k__BackingField;
    protected string License { get; protected set; }
    public StringLicenseValidator(string publicKey, string license);
    public StringLicenseValidator(string publicKey, string license, string licenseServerUrl, Guid clientId);
    [CompilerGeneratedAttribute]
protected virtual string get_License();
    [CompilerGeneratedAttribute]
protected virtual void set_License(string value);
    public bool SameLicense(string lic);
}
public interface SpellChecker.Net.Search.Spell.IDictionary {
    public abstract virtual IEnumerator`1<string> GetWordsIterator();
}
public class SpellChecker.Net.Search.Spell.JaroWinklerDistance : object {
    private float threshold;
    public float Threshold { get; public set; }
    private static Int32[] Matches(string s1, string s2);
    public sealed virtual float GetDistance(string s1, string s2);
    public float get_Threshold();
    public void set_Threshold(float value);
}
public class SpellChecker.Net.Search.Spell.LevenshteinDistance : object {
    public sealed virtual float GetDistance(string target, string other);
}
public class SpellChecker.Net.Search.Spell.LuceneDictionary : object {
    internal IndexReader reader;
    internal string field;
    public LuceneDictionary(IndexReader reader, string field);
    public virtual IEnumerator`1<string> GetWordsIterator();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class SpellChecker.Net.Search.Spell.NGramDistance : object {
    private int n;
    public NGramDistance(int size);
    public sealed virtual float GetDistance(string source, string target);
}
public class SpellChecker.Net.Search.Spell.PlainTextDictionary : object {
    private StreamReader in_Renamed;
    private string line;
    private bool has_next_called;
    public PlainTextDictionary(FileInfo file);
    public PlainTextDictionary(Stream dictFile);
    public virtual IEnumerator`1<string> GetWordsIterator();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class SpellChecker.Net.Search.Spell.SpellChecker : object {
    public static string F_WORD;
    private Term F_WORD_TERM;
    internal Directory spellindex;
    private static float bStart;
    private static float bEnd;
    private IndexSearcher searcher;
    private static object searcherLock;
    private static object modifyCurrentIndexLock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) closed;
    internal float minScore;
    private StringDistance sd;
    public SpellChecker(Directory spellIndex, StringDistance sd);
    public SpellChecker(Directory spellIndex);
    private static SpellChecker();
    public virtual void SetSpellIndex(Directory spellIndexDir);
    public void setStringDistance(StringDistance sd);
    public StringDistance GetStringDistance();
    public virtual void SetAccuracy(float minScore);
    public virtual String[] SuggestSimilar(string word, int num_sug);
    public virtual String[] SuggestSimilar(string word, int numSug, IndexReader ir, string field, bool morePopular);
    private static void Add(BooleanQuery q, string k, string v, float boost);
    private static void Add(BooleanQuery q, string k, string v);
    private static String[] FormGrams(string text, int ng);
    public virtual void ClearIndex();
    public virtual bool Exist(string word);
    public virtual void IndexDictionary(IDictionary dict, int mergeFactor, int ramMB, CancellationToken token);
    public void IndexDictionary(IDictionary dict, CancellationToken token);
    private int GetMin(int l);
    private int GetMax(int l);
    private static Document CreateDocument(string text, int ng1, int ng2);
    private static void AddGram(string text, Document doc, int ng1, int ng2);
    private IndexSearcher ObtainSearcher();
    private void ReleaseSearcher(IndexSearcher aSearcher);
    private void EnsureOpen();
    public void Close();
    private void SwapSearcher(Directory dir);
    public virtual IndexSearcher CreateSearcher(Directory dir);
    private bool IsClosed();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected void Dispose(bool disposeOfManagedResources);
}
public interface SpellChecker.Net.Search.Spell.StringDistance {
    public abstract virtual float GetDistance(string s1, string s2);
}
internal class SpellChecker.Net.Search.Spell.SuggestWord : object {
    public float score;
    public int freq;
    public string termString;
    public int CompareTo(SuggestWord a);
}
internal class SpellChecker.Net.Search.Spell.SuggestWordQueue : PriorityQueue`1<SuggestWord> {
    internal SuggestWordQueue(int size);
    public virtual bool LessThan(SuggestWord a, SuggestWord b);
}
public class SpellChecker.Net.Search.Spell.TRStringDistance : object {
    internal Char[] sa;
    internal int n;
    internal Int32[][][] cache;
    public TRStringDistance(string target);
    public int GetDistance(string other);
    private static Int32[][] Form(int n, int m);
    private static int Min3(int a, int b, int c);
}
