public class RazorLight.Caching.CachedFileInfo : ValueType {
    public bool UpToDate;
    public string AssemblyFilePath;
    public string PdbFilePath;
    public CachedFileInfo(bool upToDate, string assemblyFilePath, string pdbFilePath);
    public void Deconstruct(Boolean& upToDate, String& assemblyFilePath, String& pdbFilePath);
}
public class RazorLight.Caching.FileHashCachingStrategy : object {
    public static IFileSystemCachingStrategy Instance;
    public string Name { get; }
    private static FileHashCachingStrategy();
    public sealed virtual string get_Name();
    private static string GetFileHash(string key, string filePath);
    public sealed virtual CachedFileInfo GetCachedFileInfo(string key, string templateFilePath, string cacheDir);
}
public class RazorLight.Caching.FileSystemCachingProvider : object {
    private MemoryCachingProvider m_cache;
    private string m_baseDir;
    private string m_cacheDir;
    private IFileSystemCachingStrategy m_fileSystemCachingStrategy;
    public FileSystemCachingProvider(string baseDir, string cacheDir, IFileSystemCachingStrategy fileSystemCachingStrategy);
    public string GetAssemblyFilePath(string key, string templateFilePath);
    private sealed virtual override void RazorLight.Compilation.IPrecompileCallback.Invoke(IGeneratedRazorTemplate generatedRazorTemplate, Byte[] rawAssembly, Byte[] rawSymbolStore);
    public sealed virtual void CacheTemplate(string key, Func`1<ITemplatePage> pageFactory, IChangeToken expirationToken);
    public sealed virtual bool Contains(string key);
    public sealed virtual void Remove(string key);
    public sealed virtual TemplateCacheLookupResult RetrieveTemplate(string key);
    public static Type GetTemplatePageType(string asmFilePath);
    public static ITemplatePage NewTemplatePage(Type templatePageType);
    public static Type GetTemplatePageType(Byte[] rawAssembly, Byte[] rawSymbolStore);
}
public interface RazorLight.Caching.ICachingProvider {
    public abstract virtual TemplateCacheLookupResult RetrieveTemplate(string key);
    public abstract virtual void CacheTemplate(string key, Func`1<ITemplatePage> pageFactory, IChangeToken expirationToken);
    public abstract virtual bool Contains(string key);
    public abstract virtual void Remove(string key);
}
public interface RazorLight.Caching.IFileSystemCachingStrategy {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual CachedFileInfo GetCachedFileInfo(string key, string templateFilePath, string cacheDir);
}
public class RazorLight.Caching.MemoryCachingProvider : object {
    [CompilerGeneratedAttribute]
private IMemoryCache <LookupCache>k__BackingField;
    protected IMemoryCache LookupCache { get; protected set; }
    [CompilerGeneratedAttribute]
protected IMemoryCache get_LookupCache();
    [CompilerGeneratedAttribute]
protected void set_LookupCache(IMemoryCache value);
    public sealed virtual TemplateCacheLookupResult RetrieveTemplate(string key);
    public sealed virtual bool Contains(string key);
    public sealed virtual void CacheTemplate(string key, Func`1<ITemplatePage> pageFactory, IChangeToken expirationToken);
    public sealed virtual void Remove(string key);
}
public class RazorLight.Caching.SimpleFileCachingStrategy : object {
    public static IFileSystemCachingStrategy Instance;
    public string Name { get; }
    private static SimpleFileCachingStrategy();
    public sealed virtual string get_Name();
    public sealed virtual CachedFileInfo GetCachedFileInfo(string key, string templateFilePath, string cacheDir);
}
public class RazorLight.Caching.TemplateCacheItem : ValueType {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<ITemplatePage> <TemplatePageFactory>k__BackingField;
    public string Key { get; public set; }
    public Func`1<ITemplatePage> TemplatePageFactory { get; public set; }
    public TemplateCacheItem(string key, Func`1<ITemplatePage> pageFactory);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Func`1<ITemplatePage> get_TemplatePageFactory();
    [CompilerGeneratedAttribute]
public void set_TemplatePageFactory(Func`1<ITemplatePage> value);
}
public class RazorLight.Caching.TemplateCacheLookupResult : object {
    [CompilerGeneratedAttribute]
private TemplateCacheItem <Template>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    public TemplateCacheItem Template { get; public set; }
    public bool Success { get; }
    public TemplateCacheLookupResult(TemplateCacheItem cacheItem);
    [CompilerGeneratedAttribute]
public TemplateCacheItem get_Template();
    [CompilerGeneratedAttribute]
public void set_Template(TemplateCacheItem value);
    [CompilerGeneratedAttribute]
public bool get_Success();
}
public class RazorLight.Compilation.CompiledTemplateDescriptor : object {
    [CompilerGeneratedAttribute]
private string <TemplateKey>k__BackingField;
    [CompilerGeneratedAttribute]
private RazorLightTemplateAttribute <TemplateAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private IChangeToken <ExpirationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrecompiled>k__BackingField;
    [CompilerGeneratedAttribute]
private RazorCompiledItem <Item>k__BackingField;
    public string TemplateKey { get; public set; }
    public RazorLightTemplateAttribute TemplateAttribute { get; public set; }
    public IChangeToken ExpirationToken { get; public set; }
    public bool IsPrecompiled { get; public set; }
    public RazorCompiledItem Item { get; public set; }
    public Type Type { get; }
    [CompilerGeneratedAttribute]
public string get_TemplateKey();
    [CompilerGeneratedAttribute]
public void set_TemplateKey(string value);
    [CompilerGeneratedAttribute]
public RazorLightTemplateAttribute get_TemplateAttribute();
    [CompilerGeneratedAttribute]
public void set_TemplateAttribute(RazorLightTemplateAttribute value);
    [CompilerGeneratedAttribute]
public IChangeToken get_ExpirationToken();
    [CompilerGeneratedAttribute]
public void set_ExpirationToken(IChangeToken value);
    [CompilerGeneratedAttribute]
public bool get_IsPrecompiled();
    [CompilerGeneratedAttribute]
public void set_IsPrecompiled(bool value);
    [CompilerGeneratedAttribute]
public RazorCompiledItem get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(RazorCompiledItem value);
    public Type get_Type();
}
public class RazorLight.Compilation.DefaultAssemblyPathFormatter : object {
    public sealed virtual string GetAssemblyPath(Assembly assembly);
}
public class RazorLight.Compilation.DefaultMetadataReferenceManager : object {
    private IAssemblyPathFormatter _pathFormatter;
    [CompilerGeneratedAttribute]
private HashSet`1<MetadataReference> <AdditionalMetadataReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ExcludedAssemblies>k__BackingField;
    public HashSet`1<MetadataReference> AdditionalMetadataReferences { get; }
    public HashSet`1<string> ExcludedAssemblies { get; }
    public DefaultMetadataReferenceManager(IOptions`1<RazorLightOptions> options, IAssemblyPathFormatter pathFormatter);
    public DefaultMetadataReferenceManager(HashSet`1<MetadataReference> metadataReferences);
    public DefaultMetadataReferenceManager(HashSet`1<MetadataReference> metadataReferences, HashSet`1<string> excludedAssemblies);
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<MetadataReference> get_AdditionalMetadataReferences();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ExcludedAssemblies();
    public sealed virtual IReadOnlyList`1<MetadataReference> Resolve(Assembly assembly);
    internal IReadOnlyList`1<MetadataReference> Resolve(Assembly assembly, DependencyContext dependencyContext);
    [IteratorStateMachineAttribute("RazorLight.Compilation.DefaultMetadataReferenceManager/<GetReferencedAssemblies>d__13")]
private static IEnumerable`1<Assembly> GetReferencedAssemblies(Assembly a, ISet`1<string> excludedAssemblies, HashSet`1<string> visitedAssemblies);
    [CompilerGeneratedAttribute]
private string <Resolve>b__12_2(Assembly p);
    [CompilerGeneratedAttribute]
private bool <Resolve>b__12_0(CompilationLibrary x);
}
public interface RazorLight.Compilation.IAssemblyPathFormatter {
    public abstract virtual string GetAssemblyPath(Assembly assembly);
}
public interface RazorLight.Compilation.ICompilationService {
    public CSharpCompilationOptions CSharpCompilationOptions { get; }
    public EmitOptions EmitOptions { get; }
    public CSharpParseOptions ParseOptions { get; }
    public Assembly OperatingAssembly { get; }
    public abstract virtual CSharpCompilationOptions get_CSharpCompilationOptions();
    public abstract virtual EmitOptions get_EmitOptions();
    public abstract virtual CSharpParseOptions get_ParseOptions();
    public abstract virtual Assembly get_OperatingAssembly();
    public abstract virtual Assembly CompileAndEmit(IGeneratedRazorTemplate razorTemplate);
}
public interface RazorLight.Compilation.IMetadataReferenceManager {
    public HashSet`1<MetadataReference> AdditionalMetadataReferences { get; }
    public abstract virtual IReadOnlyList`1<MetadataReference> Resolve(Assembly assembly);
    public abstract virtual HashSet`1<MetadataReference> get_AdditionalMetadataReferences();
}
public interface RazorLight.Compilation.IPrecompileCallback {
    public abstract virtual void Invoke(IGeneratedRazorTemplate generatedRazorTemplate, Byte[] rawAssembly, Byte[] rawSymbolStore);
}
public interface RazorLight.Compilation.IRazorTemplateCompiler {
    public ICompilationService CompilationService { get; }
    public abstract virtual ICompilationService get_CompilationService();
    public abstract virtual Task`1<CompiledTemplateDescriptor> CompileAsync(string templateKey);
}
public interface RazorLight.Compilation.ITemplateFactoryProvider {
    public abstract virtual Func`1<ITemplatePage> CreateFactory(CompiledTemplateDescriptor templateDescriptor);
}
public class RazorLight.Compilation.LegacyFixAssemblyPathFormatter : object {
    public sealed virtual string GetAssemblyPath(Assembly assembly);
}
public class RazorLight.Compilation.RazorTemplateCompiler : object {
    private SemaphoreSlim _cacheLock;
    private RazorSourceGenerator _razorSourceGenerator;
    private ICompilationService _compiler;
    private RazorLightOptions _razorLightOptions;
    private RazorLightProject _razorProject;
    private IMemoryCache _cache;
    private ConcurrentDictionary`2<string, string> _normalizedKeysCache;
    private Dictionary`2<string, CompiledTemplateDescriptor> _precompiledViews;
    public ICompilationService CompilationService { get; }
    internal IMemoryCache Cache { get; }
    internal Type ProjectType { get; }
    public RazorTemplateCompiler(RazorSourceGenerator sourceGenerator, ICompilationService compilationService, RazorLightProject razorLightProject, RazorLightOptions razorLightOptions);
    public RazorTemplateCompiler(RazorSourceGenerator sourceGenerator, ICompilationService compilationService, RazorLightProject razorLightProject, IOptions`1<RazorLightOptions> options);
    public sealed virtual ICompilationService get_CompilationService();
    internal IMemoryCache get_Cache();
    public sealed virtual Task`1<CompiledTemplateDescriptor> CompileAsync(string templateKey);
    internal Type get_ProjectType();
    [AsyncStateMachineAttribute("RazorLight.Compilation.RazorTemplateCompiler/<OnCacheMissAsync>d__17")]
private Task`1<CompiledTemplateDescriptor> OnCacheMissAsync(string templateKey);
    [AsyncStateMachineAttribute("RazorLight.Compilation.RazorTemplateCompiler/<CreateRuntimeCompilationWorkItem>d__18")]
private Task`1<ViewCompilerWorkItem> CreateRuntimeCompilationWorkItem(string templateKey);
    [AsyncStateMachineAttribute("RazorLight.Compilation.RazorTemplateCompiler/<CompileAndEmitAsync>d__19")]
protected virtual Task`1<CompiledTemplateDescriptor> CompileAndEmitAsync(RazorLightProjectItem projectItem);
    internal string GetNormalizedKey(string templateKey);
    [AsyncStateMachineAttribute("RazorLight.Compilation.RazorTemplateCompiler/<CreateTemplateNotFoundException>d__21")]
internal Task`1<TemplateNotFoundException> CreateTemplateNotFoundException(RazorLightProjectItem projectItem);
}
public class RazorLight.Compilation.RoslynCompilationService : object {
    private IMetadataReferenceManager metadataReferenceManager;
    private bool isDevelopment;
    private List`1<MetadataReference> metadataReferences;
    private IPrecompileCallback precompileCallback;
    [CompilerGeneratedAttribute]
private Assembly <OperatingAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private EmitOptions <EmitOptions>k__BackingField;
    private CSharpParseOptions _parseOptions;
    private CSharpCompilationOptions _compilationOptions;
    private static object locker;
    private bool _optionsInitialized;
    public Assembly OperatingAssembly { get; }
    public EmitOptions EmitOptions { get; }
    public CSharpCompilationOptions CSharpCompilationOptions { get; }
    public CSharpParseOptions ParseOptions { get; }
    public RoslynCompilationService(IMetadataReferenceManager referenceManager, Assembly operatingAssembly, IPrecompileCallback precompileCallback);
    public RoslynCompilationService(IMetadataReferenceManager referenceManager, IOptions`1<RazorLightOptions> options, IPrecompileCallback precompileCallback);
    private static RoslynCompilationService();
    [CompilerGeneratedAttribute]
public virtual Assembly get_OperatingAssembly();
    [CompilerGeneratedAttribute]
public virtual EmitOptions get_EmitOptions();
    public virtual CSharpCompilationOptions get_CSharpCompilationOptions();
    public virtual CSharpParseOptions get_ParseOptions();
    private void EnsureOptions();
    public sealed virtual Assembly CompileAndEmit(IGeneratedRazorTemplate razorTemplate);
    protected internal virtual CompilationOptions GetDependencyContextCompilationOptions();
    private CSharpCompilation CreateCompilation(string compilationContent, string assemblyName);
    public CSharpCompilation CreateCompilation(string assemblyName);
    public SyntaxTree CreateSyntaxTree(SourceText sourceText);
    private CSharpCompilationOptions GetCompilationOptions(CompilationOptions dependencyContextOptions);
    private CSharpParseOptions GetParseOptions(CompilationOptions dependencyContextOptions);
}
public class RazorLight.Compilation.TemplateCompilationDiagnostic : object {
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormattedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FileLinePositionSpan> <LineSpan>k__BackingField;
    public string ErrorMessage { get; }
    public string FormattedMessage { get; }
    public Nullable`1<FileLinePositionSpan> LineSpan { get; }
    public TemplateCompilationDiagnostic(string errorMessage, string formattedMessage, Nullable`1<FileLinePositionSpan> lineSpan);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public string get_FormattedMessage();
    [CompilerGeneratedAttribute]
public Nullable`1<FileLinePositionSpan> get_LineSpan();
}
public class RazorLight.Compilation.TemplateCompilationException : RazorLightException {
    private List`1<TemplateCompilationDiagnostic> compilationDiagnostics;
    public IReadOnlyList`1<string> CompilationErrors { get; }
    public IReadOnlyList`1<TemplateCompilationDiagnostic> CompilationDiagnostics { get; }
    [ObsoleteAttribute("Use constructor that takes enumerable of TemplateCompilationDiagnostic as input parameters")]
public TemplateCompilationException(string message, IEnumerable`1<string> errors);
    public TemplateCompilationException(string message, IEnumerable`1<TemplateCompilationDiagnostic> diagnostics);
    public IReadOnlyList`1<string> get_CompilationErrors();
    public IReadOnlyList`1<TemplateCompilationDiagnostic> get_CompilationDiagnostics();
}
public class RazorLight.Compilation.TemplateFactoryProvider : object {
    public sealed virtual Func`1<ITemplatePage> CreateFactory(CompiledTemplateDescriptor templateDescriptor);
}
public class RazorLight.Compilation.TemplateFactoryResult : ValueType {
    [CompilerGeneratedAttribute]
private CompiledTemplateDescriptor <TemplateDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<ITemplatePage> <TemplatePageFactory>k__BackingField;
    public CompiledTemplateDescriptor TemplateDescriptor { get; }
    public Func`1<ITemplatePage> TemplatePageFactory { get; }
    public TemplateFactoryResult(CompiledTemplateDescriptor viewDescriptor, Func`1<ITemplatePage> templatePageFactory);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CompiledTemplateDescriptor get_TemplateDescriptor();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Func`1<ITemplatePage> get_TemplatePageFactory();
}
internal class RazorLight.DefaultRazorEngine : object {
    public static RazorEngine Instance { get; }
    public static RazorEngine get_Instance();
}
public class RazorLight.DependencyInjection.PropertyInjector : object {
    private IServiceProvider services;
    private ConcurrentDictionary`2<PropertyInfo, FastPropertySetter> _propertyCache;
    public PropertyInjector(IServiceProvider services);
    public void Inject(ITemplatePage page);
}
[ObsoleteAttribute("Use RazorLightEngineBuilder instead", "True")]
public class RazorLight.EngineFactory : object {
    public virtual RazorLightEngine ForFileSystem(string root);
    public virtual RazorLightEngine ForFileSystem(string root, RazorLightOptions options);
    public virtual RazorLightEngine ForEmbeddedResources(Type rootType);
    public virtual RazorLightEngine ForEmbeddedResources(Type rootType, RazorLightOptions options);
    public sealed virtual RazorLightEngine Create(RazorLightOptions options);
    public virtual RazorLightEngine Create(RazorLightProject project, RazorLightOptions options);
}
public class RazorLight.EngineHandler : object {
    [CompilerGeneratedAttribute]
private RazorLightOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ICachingProvider <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private IRazorTemplateCompiler <Compiler>k__BackingField;
    [CompilerGeneratedAttribute]
private ITemplateFactoryProvider <FactoryProvider>k__BackingField;
    public RazorLightOptions Options { get; }
    public ICachingProvider Cache { get; }
    public IRazorTemplateCompiler Compiler { get; }
    public ITemplateFactoryProvider FactoryProvider { get; }
    public bool IsCachingEnabled { get; }
    public EngineHandler(RazorLightOptions options, IRazorTemplateCompiler compiler, ITemplateFactoryProvider factoryProvider, ICachingProvider cache);
    public EngineHandler(IOptions`1<RazorLightOptions> options, IRazorTemplateCompiler compiler, ITemplateFactoryProvider factoryProvider, ICachingProvider cache);
    [CompilerGeneratedAttribute]
public sealed virtual RazorLightOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual ICachingProvider get_Cache();
    [CompilerGeneratedAttribute]
public sealed virtual IRazorTemplateCompiler get_Compiler();
    [CompilerGeneratedAttribute]
public sealed virtual ITemplateFactoryProvider get_FactoryProvider();
    public sealed virtual bool get_IsCachingEnabled();
    [AsyncStateMachineAttribute("RazorLight.EngineHandler/<CompileTemplateAsync>d__16")]
public sealed virtual Task`1<ITemplatePage> CompileTemplateAsync(string key);
    [AsyncStateMachineAttribute("RazorLight.EngineHandler/<RenderTemplateAsync>d__17`1")]
public sealed virtual Task`1<string> RenderTemplateAsync(ITemplatePage templatePage, T model, ExpandoObject viewBag);
    [AsyncStateMachineAttribute("RazorLight.EngineHandler/<RenderTemplateAsync>d__18`1")]
public sealed virtual Task RenderTemplateAsync(ITemplatePage templatePage, T model, TextWriter textWriter, ExpandoObject viewBag);
    [AsyncStateMachineAttribute("RazorLight.EngineHandler/<RenderIncludedTemplateAsync>d__19`1")]
public sealed virtual Task RenderIncludedTemplateAsync(ITemplatePage templatePage, T model, TextWriter textWriter, ExpandoObject viewBag, TemplateRenderer templateRenderer);
    [AsyncStateMachineAttribute("RazorLight.EngineHandler/<CompileRenderAsync>d__20`1")]
public sealed virtual Task`1<string> CompileRenderAsync(string key, T model, ExpandoObject viewBag);
    public sealed virtual Task`1<string> CompileRenderStringAsync(string key, string content, T model, ExpandoObject viewBag);
    private void SetModelContext(ITemplatePage templatePage, TextWriter textWriter, T model, ExpandoObject viewBag);
}
[ExtensionAttribute]
public static class RazorLight.Extensions.ServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddRazorLight(IServiceCollection services, Func`1<IRazorLightEngine> engineFactoryProvider);
    [ExtensionAttribute]
public static RazorLightDependencyBuilder AddRazorLight(IServiceCollection services);
    private static void AddEngineRenderCallbacks(IRazorLightEngine engine, IServiceProvider services);
}
[ExtensionAttribute]
public static class RazorLight.Extensions.TypeExtensions : object {
    [ExtensionAttribute]
public static ExpandoObject ToExpando(object anonymousObject);
    [ExtensionAttribute]
public static bool IsAnonymousType(Type type);
}
public class RazorLight.Generation.GeneratedRazorTemplate : object {
    [CompilerGeneratedAttribute]
private RazorLightProjectItem <ProjectItem>k__BackingField;
    [CompilerGeneratedAttribute]
private RazorCSharpDocument <CSharpDocument>k__BackingField;
    public RazorLightProjectItem ProjectItem { get; public set; }
    public string TemplateKey { get; }
    public RazorCSharpDocument CSharpDocument { get; public set; }
    public string GeneratedCode { get; }
    public GeneratedRazorTemplate(RazorLightProjectItem projectItem, RazorCSharpDocument cSharpDocument);
    [CompilerGeneratedAttribute]
public sealed virtual RazorLightProjectItem get_ProjectItem();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectItem(RazorLightProjectItem value);
    public sealed virtual string get_TemplateKey();
    [CompilerGeneratedAttribute]
public RazorCSharpDocument get_CSharpDocument();
    [CompilerGeneratedAttribute]
public void set_CSharpDocument(RazorCSharpDocument value);
    public sealed virtual string get_GeneratedCode();
}
public interface RazorLight.Generation.IGeneratedRazorTemplate {
    public string TemplateKey { get; }
    public string GeneratedCode { get; }
    public RazorLightProjectItem ProjectItem { get; public set; }
    public abstract virtual string get_TemplateKey();
    public abstract virtual string get_GeneratedCode();
    public abstract virtual RazorLightProjectItem get_ProjectItem();
    public abstract virtual void set_ProjectItem(RazorLightProjectItem value);
}
public class RazorLight.Generation.RazorSourceGenerator : object {
    [CompilerGeneratedAttribute]
private RazorEngine <ProjectEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private RazorLightProject <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private RazorSourceDocument <DefaultImports>k__BackingField;
    public RazorEngine ProjectEngine { get; public set; }
    public RazorLightProject Project { get; public set; }
    public ISet`1<string> Namespaces { get; public set; }
    public RazorSourceDocument DefaultImports { get; public set; }
    public RazorSourceGenerator(RazorEngine projectEngine, RazorLightProject project, ISet`1<string> namespaces);
    [CompilerGeneratedAttribute]
public RazorEngine get_ProjectEngine();
    [CompilerGeneratedAttribute]
public void set_ProjectEngine(RazorEngine value);
    [CompilerGeneratedAttribute]
public RazorLightProject get_Project();
    [CompilerGeneratedAttribute]
public void set_Project(RazorLightProject value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Namespaces();
    [CompilerGeneratedAttribute]
public void set_Namespaces(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public RazorSourceDocument get_DefaultImports();
    [CompilerGeneratedAttribute]
public void set_DefaultImports(RazorSourceDocument value);
    [AsyncStateMachineAttribute("RazorLight.Generation.RazorSourceGenerator/<GenerateCodeAsync>d__17")]
public Task`1<IGeneratedRazorTemplate> GenerateCodeAsync(string key);
    [AsyncStateMachineAttribute("RazorLight.Generation.RazorSourceGenerator/<GenerateCodeAsync>d__18")]
public Task`1<IGeneratedRazorTemplate> GenerateCodeAsync(RazorLightProjectItem projectItem);
    [AsyncStateMachineAttribute("RazorLight.Generation.RazorSourceGenerator/<CreateCodeDocumentAsync>d__19")]
public virtual Task`1<RazorCodeDocument> CreateCodeDocumentAsync(RazorLightProjectItem projectItem);
    [AsyncStateMachineAttribute("RazorLight.Generation.RazorSourceGenerator/<GetImportsAsync>d__20")]
public virtual Task`1<IEnumerable`1<RazorSourceDocument>> GetImportsAsync(RazorLightProjectItem projectItem);
    protected internal RazorSourceDocument GetDefaultImports();
    protected internal RazorSourceDocument GetNamespacesImports();
    [IteratorStateMachineAttribute("RazorLight.Generation.RazorSourceGenerator/<GetDefaultImportLines>d__23")]
public virtual IEnumerable`1<string> GetDefaultImportLines();
}
public class RazorLight.Generation.TemplateGenerationException : RazorLightException {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RazorDiagnostic> <Diagnostics>k__BackingField;
    public IReadOnlyList`1<RazorDiagnostic> Diagnostics { get; public set; }
    public TemplateGenerationException(string message, IReadOnlyList`1<RazorDiagnostic> diagnostic);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RazorDiagnostic> get_Diagnostics();
    [CompilerGeneratedAttribute]
public void set_Diagnostics(IReadOnlyList`1<RazorDiagnostic> value);
}
[ObsoleteAttribute("Use RazorLightEngineBuilder instead", "True")]
public interface RazorLight.IEngineFactory {
    public abstract virtual RazorLightEngine ForFileSystem(string root);
    public abstract virtual RazorLightEngine ForFileSystem(string root, RazorLightOptions options);
    public abstract virtual RazorLightEngine ForEmbeddedResources(Type rootType);
    public abstract virtual RazorLightEngine ForEmbeddedResources(Type rootType, RazorLightOptions options);
    public abstract virtual RazorLightEngine Create(RazorLightOptions options);
    public abstract virtual RazorLightEngine Create(RazorLightProject project, RazorLightOptions options);
}
public interface RazorLight.IEngineHandler {
    public ICachingProvider Cache { get; }
    public IRazorTemplateCompiler Compiler { get; }
    public ITemplateFactoryProvider FactoryProvider { get; }
    public RazorLightOptions Options { get; }
    public bool IsCachingEnabled { get; }
    public abstract virtual ICachingProvider get_Cache();
    public abstract virtual IRazorTemplateCompiler get_Compiler();
    public abstract virtual ITemplateFactoryProvider get_FactoryProvider();
    public abstract virtual RazorLightOptions get_Options();
    public abstract virtual bool get_IsCachingEnabled();
    public abstract virtual Task`1<ITemplatePage> CompileTemplateAsync(string key);
    public abstract virtual Task`1<string> CompileRenderAsync(string key, T model, ExpandoObject viewBag);
    public abstract virtual Task`1<string> CompileRenderStringAsync(string key, string content, T model, ExpandoObject viewBag);
    public abstract virtual Task`1<string> RenderTemplateAsync(ITemplatePage templatePage, T model, ExpandoObject viewBag);
    public abstract virtual Task RenderTemplateAsync(ITemplatePage templatePage, T model, TextWriter textWriter, ExpandoObject viewBag);
    public abstract virtual Task RenderIncludedTemplateAsync(ITemplatePage templatePage, T model, TextWriter textWriter, ExpandoObject viewBag, TemplateRenderer templateRenderer);
}
public class RazorLight.Instrumentation.InjectDirective : object {
    public static DirectiveDescriptor Directive;
    private static InjectDirective();
    public static RazorProjectEngineBuilder Register(RazorProjectEngineBuilder builder);
}
public static class RazorLight.Instrumentation.ModelDirective : object {
    public static DirectiveDescriptor Directive;
    private static ModelDirective();
    public static RazorProjectEngineBuilder Register(RazorProjectEngineBuilder builder);
    public static string GetModelType(DocumentIntermediateNode document);
    private static string GetModelType(DocumentIntermediateNode document, Visitor visitor);
}
internal class RazorLight.Instrumentation.OverrideRuntimeNodeWriterTemplateTypeNamePhase : RazorEnginePhaseBase {
    private string _templateTypeName;
    public OverrideRuntimeNodeWriterTemplateTypeNamePhase(string templateTypeName);
    public static void Register(RazorProjectEngineBuilder builder);
    protected virtual void ExecuteCore(RazorCodeDocument codeDocument);
}
public class RazorLight.Instrumentation.RazorLightAssemblyAttributeInjectionPass : IntermediateNodePassBase {
    private static string RazorLightTemplateAttribute;
    protected virtual void ExecuteCore(RazorCodeDocument codeDocument, DocumentIntermediateNode documentNode);
    private static string EscapeAsVerbatimLiteral(string value);
}
public class RazorLight.Instrumentation.RazorLightTemplateDocumentClassifierPass : DocumentClassifierPassBase {
    public static string RazorLightTemplateDocumentKind;
    protected string DocumentKind { get; }
    private static RazorLightTemplateDocumentClassifierPass();
    protected virtual string get_DocumentKind();
    protected virtual bool IsMatch(RazorCodeDocument codeDocument, DocumentIntermediateNode documentNode);
    protected virtual void OnDocumentStructureCreated(RazorCodeDocument codeDocument, NamespaceDeclarationIntermediateNode namespace, ClassDeclarationIntermediateNode class, MethodDeclarationIntermediateNode method);
}
internal class RazorLight.Internal.AssemblyDebugModeUtility : object {
    internal static bool IsAssemblyDebugBuild(Assembly assembly);
}
public class RazorLight.Internal.Buffering.ArrayPoolBufferSource : object {
    private ArrayPool`1<char> _pool;
    public ArrayPoolBufferSource(ArrayPool`1<char> pool);
    public sealed virtual Char[] Rent(int bufferSize);
    public sealed virtual void Return(Char[] buffer);
}
public interface RazorLight.Internal.Buffering.ICharBufferSource {
    public abstract virtual Char[] Rent(int bufferSize);
    public abstract virtual void Return(Char[] buffer);
}
public interface RazorLight.Internal.Buffering.IViewBufferScope {
    public abstract virtual ViewBufferValue[] GetPage(int pageSize);
    public abstract virtual void ReturnSegment(ViewBufferValue[] segment);
    public abstract virtual PagedBufferedTextWriter CreateWriter(TextWriter writer);
}
public class RazorLight.Internal.Buffering.MemoryPoolViewBufferScope : object {
    public static int MinimumSize;
    private ArrayPool`1<ViewBufferValue> _viewBufferPool;
    private ArrayPool`1<char> _charPool;
    private List`1<ViewBufferValue[]> _available;
    private List`1<ViewBufferValue[]> _leased;
    private bool _disposed;
    public MemoryPoolViewBufferScope(ArrayPool`1<ViewBufferValue> viewBufferPool, ArrayPool`1<char> charPool);
    private static MemoryPoolViewBufferScope();
    public sealed virtual ViewBufferValue[] GetPage(int pageSize);
    public sealed virtual void ReturnSegment(ViewBufferValue[] segment);
    public sealed virtual PagedBufferedTextWriter CreateWriter(TextWriter writer);
    public sealed virtual void Dispose();
}
public class RazorLight.Internal.Buffering.PagedBufferedTextWriter : TextWriter {
    private TextWriter _inner;
    private PagedCharBuffer _charBuffer;
    public Encoding Encoding { get; }
    public PagedBufferedTextWriter(ArrayPool`1<char> pool, TextWriter inner);
    public virtual Encoding get_Encoding();
    public virtual void Flush();
    [AsyncStateMachineAttribute("RazorLight.Internal.Buffering.PagedBufferedTextWriter/<FlushAsync>d__6")]
public virtual Task FlushAsync();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    [AsyncStateMachineAttribute("RazorLight.Internal.Buffering.PagedBufferedTextWriter/<WriteAsync>d__11")]
public virtual Task WriteAsync(char value);
    [AsyncStateMachineAttribute("RazorLight.Internal.Buffering.PagedBufferedTextWriter/<WriteAsync>d__12")]
public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [AsyncStateMachineAttribute("RazorLight.Internal.Buffering.PagedBufferedTextWriter/<WriteAsync>d__13")]
public virtual Task WriteAsync(string value);
    protected virtual void Dispose(bool disposing);
}
public class RazorLight.Internal.Buffering.PagedCharBuffer : object {
    public static int PageSize;
    private int _charIndex;
    [CompilerGeneratedAttribute]
private ICharBufferSource <BufferSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Char[]> <Pages>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <CurrentPage>k__BackingField;
    public ICharBufferSource BufferSource { get; }
    public IList`1<Char[]> Pages { get; }
    public int Length { get; }
    private Char[] CurrentPage { get; private set; }
    public PagedCharBuffer(ICharBufferSource bufferSource);
    [CompilerGeneratedAttribute]
public ICharBufferSource get_BufferSource();
    [CompilerGeneratedAttribute]
public IList`1<Char[]> get_Pages();
    public int get_Length();
    [CompilerGeneratedAttribute]
private Char[] get_CurrentPage();
    [CompilerGeneratedAttribute]
private void set_CurrentPage(Char[] value);
    public void Append(char value);
    public void Append(string value);
    public void Append(Char[] buffer, int index, int count);
    public void Clear();
    private Char[] GetCurrentPage();
    private Char[] NewPage();
    public sealed virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class RazorLight.Internal.Buffering.ViewBuffer : object {
    public static int PartialViewPageSize;
    public static int TagHelperPageSize;
    public static int ViewComponentPageSize;
    public static int ViewPageSize;
    private IViewBufferScope _bufferScope;
    private string _name;
    private int _pageSize;
    private ViewBufferPage _currentPage;
    private List`1<ViewBufferPage> _multiplePages;
    public int Count { get; }
    public ViewBufferPage Item { get; }
    public ViewBuffer(IViewBufferScope bufferScope, string name, int pageSize);
    private static ViewBuffer();
    public int get_Count();
    public ViewBufferPage get_Item(int index);
    public sealed virtual IHtmlContentBuilder Append(string unencoded);
    public sealed virtual IHtmlContentBuilder AppendHtml(IHtmlContent content);
    public sealed virtual IHtmlContentBuilder AppendHtml(string encoded);
    private void AppendValue(ViewBufferValue value);
    private ViewBufferPage GetCurrentPage();
    private void AddPage(ViewBufferPage page);
    public sealed virtual IHtmlContentBuilder Clear();
    public sealed virtual void WriteTo(TextWriter writer, HtmlEncoder encoder);
    [AsyncStateMachineAttribute("RazorLight.Internal.Buffering.ViewBuffer/<WriteToAsync>d__22")]
public Task WriteToAsync(TextWriter writer, HtmlEncoder encoder);
    private string DebuggerToString();
    public sealed virtual void CopyTo(IHtmlContentBuilder destination);
    public sealed virtual void MoveTo(IHtmlContentBuilder destination);
    private void MoveTo(ViewBuffer destination);
}
public class RazorLight.Internal.Buffering.ViewBufferPage : object {
    [CompilerGeneratedAttribute]
private ViewBufferValue[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public ViewBufferValue[] Buffer { get; }
    public int Capacity { get; }
    public int Count { get; public set; }
    public bool IsFull { get; }
    public ViewBufferPage(ViewBufferValue[] buffer);
    [CompilerGeneratedAttribute]
public ViewBufferValue[] get_Buffer();
    public int get_Capacity();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    public bool get_IsFull();
    public void Append(ViewBufferValue value);
}
public class RazorLight.Internal.Buffering.ViewBufferTextWriter : TextWriter {
    private TextWriter _inner;
    private HtmlEncoder _htmlEncoder;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBuffering>k__BackingField;
    [CompilerGeneratedAttribute]
private ViewBuffer <Buffer>k__BackingField;
    public Encoding Encoding { get; }
    public bool IsBuffering { get; private set; }
    public ViewBuffer Buffer { get; }
    public ViewBufferTextWriter(ViewBuffer buffer, Encoding encoding);
    public ViewBufferTextWriter(ViewBuffer buffer, Encoding encoding, HtmlEncoder htmlEncoder, TextWriter inner);
    [CompilerGeneratedAttribute]
public virtual Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public bool get_IsBuffering();
    [CompilerGeneratedAttribute]
private void set_IsBuffering(bool value);
    [CompilerGeneratedAttribute]
public ViewBuffer get_Buffer();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    public virtual void Write(object value);
    public void Write(IHtmlContent value);
    public void Write(IHtmlContentContainer value);
    public virtual void WriteLine(object value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(string value);
    public virtual void WriteLine();
    public virtual void WriteLine(string value);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] value, int start, int offset);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync();
    public virtual void Flush();
    [AsyncStateMachineAttribute("RazorLight.Internal.Buffering.ViewBufferTextWriter/<FlushAsync>d__31")]
public virtual Task FlushAsync();
}
[DebuggerDisplayAttribute("{DebuggerToString()}")]
public class RazorLight.Internal.Buffering.ViewBufferValue : ValueType {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public ViewBufferValue(string value);
    public ViewBufferValue(IHtmlContent content);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public object get_Value();
    private string DebuggerToString();
}
[ExtensionAttribute]
internal static class RazorLight.Internal.CodeWriterExtensions : object {
    [ExtensionAttribute]
public static IDisposable BuildLinePragma(CodeWriter writer, Nullable`1<SourceSpan> span);
    [ExtensionAttribute]
public static bool IsAtBeginningOfLine(CodeWriter writer);
    [ExtensionAttribute]
public static CodeWriter WriteLineNumberDirective(CodeWriter writer, SourceSpan span);
}
public class RazorLight.Internal.ExpressionRewriter : CSharpSyntaxRewriter {
    private static string FieldNameTemplate;
    [CompilerGeneratedAttribute]
private bool <IsInsideClass>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<SimpleLambdaExpressionSyntax, IdentifierNameSyntax>> <Expressions>k__BackingField;
    private bool IsInsideClass { get; private set; }
    private SemanticModel SemanticModel { get; }
    private List`1<KeyValuePair`2<SimpleLambdaExpressionSyntax, IdentifierNameSyntax>> Expressions { get; }
    public ExpressionRewriter(SemanticModel semanticModel);
    private static ExpressionRewriter();
    [CompilerGeneratedAttribute]
private bool get_IsInsideClass();
    [CompilerGeneratedAttribute]
private void set_IsInsideClass(bool value);
    [CompilerGeneratedAttribute]
private SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<SimpleLambdaExpressionSyntax, IdentifierNameSyntax>> get_Expressions();
    public static CSharpCompilation Rewrite(CSharpCompilation compilation);
    public virtual SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    private static IdentifierNameSyntax PadMemberAccess(SimpleLambdaExpressionSyntax node, IdentifierNameSyntax memberAccess);
    private static bool IsValidForHoisting(ParameterSyntax parameter, CSharpSyntaxNode node);
}
internal class RazorLight.Internal.FastPropertySetter : object {
    private static MethodInfo CallPropertyGetterOpenGenericMethod;
    private static MethodInfo CallPropertyGetterByReferenceOpenGenericMethod;
    private static MethodInfo CallNullSafePropertyGetterOpenGenericMethod;
    private static MethodInfo CallNullSafePropertyGetterByReferenceOpenGenericMethod;
    private static MethodInfo CallPropertySetterOpenGenericMethod;
    private static ConcurrentDictionary`2<Type, FastPropertySetter[]> PropertiesCache;
    private static ConcurrentDictionary`2<Type, FastPropertySetter[]> VisiblePropertiesCache;
    private Action`2<object, object> _valueSetter;
    private Func`2<object, object> _valueGetter;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public PropertyInfo Property { get; }
    public string Name { get; protected set; }
    public Func`2<object, object> ValueGetter { get; }
    public Action`2<object, object> ValueSetter { get; }
    public FastPropertySetter(PropertyInfo property);
    private static FastPropertySetter();
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    public Func`2<object, object> get_ValueGetter();
    public Action`2<object, object> get_ValueSetter();
    public object GetValue(object instance);
    public void SetValue(object instance, object value);
    public static FastPropertySetter[] GetProperties(TypeInfo typeInfo);
    public static FastPropertySetter[] GetProperties(Type type);
    public static FastPropertySetter[] GetVisibleProperties(TypeInfo typeInfo);
    public static FastPropertySetter[] GetVisibleProperties(Type type);
    public static Func`2<object, object> MakeFastPropertyGetter(PropertyInfo propertyInfo);
    public static Func`2<object, object> MakeNullSafeFastPropertyGetter(PropertyInfo propertyInfo);
    private static Func`2<object, object> MakeFastPropertyGetter(PropertyInfo propertyInfo, MethodInfo propertyGetterWrapperMethod, MethodInfo propertyGetterByRefWrapperMethod);
    private static Func`2<object, object> MakeFastPropertyGetter(Type openGenericDelegateType, MethodInfo propertyGetMethod, MethodInfo openGenericWrapperMethod);
    public static Action`2<object, object> MakeFastPropertySetter(PropertyInfo propertyInfo);
    public static IDictionary`2<string, object> ObjectToDictionary(object value);
    private static FastPropertySetter CreateInstance(PropertyInfo property);
    private static object CallPropertyGetter(Func`2<TDeclaringType, TValue> getter, object target);
    private static object CallPropertyGetterByReference(ByRefFunc`2<TDeclaringType, TValue> getter, object target);
    private static object CallNullSafePropertyGetter(Func`2<TDeclaringType, TValue> getter, object target);
    private static object CallNullSafePropertyGetterByReference(ByRefFunc`2<TDeclaringType, TValue> getter, object target);
    private static void CallPropertySetter(Action`2<TDeclaringType, TValue> setter, object target, object value);
    protected static FastPropertySetter[] GetVisibleProperties(Type type, Func`2<PropertyInfo, FastPropertySetter> createPropertyHelper, ConcurrentDictionary`2<Type, FastPropertySetter[]> allPropertiesCache, ConcurrentDictionary`2<Type, FastPropertySetter[]> visiblePropertiesCache);
    protected static FastPropertySetter[] GetProperties(Type type, Func`2<PropertyInfo, FastPropertySetter> createPropertyHelper, ConcurrentDictionary`2<Type, FastPropertySetter[]> cache);
    private static bool IsInterestingProperty(PropertyInfo property);
}
internal class RazorLight.Internal.PropertyActivator`1 : object {
    private Func`2<TContext, object> _valueAccessor;
    private Action`2<object, object> _fastPropertySetter;
    [CompilerGeneratedAttribute]
private PropertyInfo <PropertyInfo>k__BackingField;
    public PropertyInfo PropertyInfo { get; private set; }
    public PropertyActivator`1(PropertyInfo propertyInfo, Func`2<TContext, object> valueAccessor);
    [CompilerGeneratedAttribute]
public PropertyInfo get_PropertyInfo();
    [CompilerGeneratedAttribute]
private void set_PropertyInfo(PropertyInfo value);
    public object Activate(object instance, TContext context);
    public static PropertyActivator`1[] GetPropertiesToActivate(Type type, Type activateAttributeType, Func`2<PropertyInfo, PropertyActivator`1<TContext>> createActivateInfo);
    public static PropertyActivator`1[] GetPropertiesToActivate(Type type, Type activateAttributeType, Func`2<PropertyInfo, PropertyActivator`1<TContext>> createActivateInfo, bool includeNonPublic);
}
[AttributeUsageAttribute("128")]
public class RazorLight.Internal.RazorInjectAttribute : Attribute {
}
public class RazorLight.Internal.RenderAsyncDelegate : MulticastDelegate {
    public RenderAsyncDelegate(object object, IntPtr method);
    public virtual Task Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal static class RazorLight.Internal.SymbolsUtility : object {
    private static string SymWriterGuid;
    public static bool SupportsFullPdbGeneration();
}
public interface RazorLight.IPageContext {
    public TextWriter Writer { get; public set; }
    [DynamicAttribute]
public object ViewBag { get; }
    public abstract virtual TextWriter get_Writer();
    public abstract virtual void set_Writer(TextWriter value);
    public abstract virtual object get_ViewBag();
}
public interface RazorLight.IRazorLightEngine {
    public RazorLightOptions Options { get; }
    public IEngineHandler Handler { get; }
    public abstract virtual RazorLightOptions get_Options();
    public abstract virtual IEngineHandler get_Handler();
    public abstract virtual Task`1<string> CompileRenderAsync(string key, T model, ExpandoObject viewBag);
    [ObsoleteAttribute("Please, use generic version of CompileRenderAsync", "True")]
public abstract virtual Task`1<string> CompileRenderAsync(string key, object model, Type modelType, ExpandoObject viewBag);
    public abstract virtual Task`1<string> CompileRenderStringAsync(string key, string content, T model, ExpandoObject viewBag);
    public abstract virtual Task`1<ITemplatePage> CompileTemplateAsync(string key);
    [ObsoleteAttribute("Please, use generic version of RenderTemplateAsync", "True")]
public abstract virtual Task`1<string> RenderTemplateAsync(ITemplatePage templatePage, object model, Type modelType, ExpandoObject viewBag);
    public abstract virtual Task`1<string> RenderTemplateAsync(ITemplatePage templatePage, T model, ExpandoObject viewBag);
    [ObsoleteAttribute("Please, use generic version of RenderTemplateAsync", "True")]
public abstract virtual Task RenderTemplateAsync(ITemplatePage templatePage, object model, Type modelType, TextWriter textWriter, ExpandoObject viewBag);
    public abstract virtual Task RenderTemplateAsync(ITemplatePage templatePage, T model, TextWriter textWriter, ExpandoObject viewBag);
}
public interface RazorLight.IRazorLightEngineFactory {
    public abstract virtual IRazorLightEngine Create(Assembly operatingAssembly, string fileSystemProjectRoot);
}
public interface RazorLight.ITemplatePage {
    public PageContext PageContext { get; public set; }
    public IHtmlContent BodyContent { get; public set; }
    public bool DisableEncoding { get; public set; }
    public string Key { get; public set; }
    public bool IsLayoutBeingRendered { get; public set; }
    public string Layout { get; public set; }
    public IDictionary`2<string, RenderAsyncDelegate> PreviousSectionWriters { get; public set; }
    public IDictionary`2<string, RenderAsyncDelegate> SectionWriters { get; }
    public Func`3<string, object, Task> IncludeFunc { get; public set; }
    public abstract virtual void SetModel(object model);
    public abstract virtual PageContext get_PageContext();
    public abstract virtual void set_PageContext(PageContext value);
    public abstract virtual IHtmlContent get_BodyContent();
    public abstract virtual void set_BodyContent(IHtmlContent value);
    public abstract virtual bool get_DisableEncoding();
    public abstract virtual void set_DisableEncoding(bool value);
    public abstract virtual string get_Key();
    public abstract virtual void set_Key(string value);
    public abstract virtual bool get_IsLayoutBeingRendered();
    public abstract virtual void set_IsLayoutBeingRendered(bool value);
    public abstract virtual string get_Layout();
    public abstract virtual void set_Layout(string value);
    public abstract virtual IDictionary`2<string, RenderAsyncDelegate> get_PreviousSectionWriters();
    public abstract virtual void set_PreviousSectionWriters(IDictionary`2<string, RenderAsyncDelegate> value);
    public abstract virtual IDictionary`2<string, RenderAsyncDelegate> get_SectionWriters();
    public abstract virtual Task ExecuteAsync();
    public abstract virtual Func`3<string, object, Task> get_IncludeFunc();
    public abstract virtual void set_IncludeFunc(Func`3<string, object, Task> value);
    public abstract virtual void EnsureRenderedBodyOrSections();
}
public class RazorLight.ModelTypeInfo : object {
    [CompilerGeneratedAttribute]
private bool <IsStrongType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TemplateType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TemplateTypeName>k__BackingField;
    public bool IsStrongType { get; private set; }
    public Type Type { get; private set; }
    public Type TemplateType { get; private set; }
    public string TemplateTypeName { get; private set; }
    public ModelTypeInfo(Type type);
    [CompilerGeneratedAttribute]
public bool get_IsStrongType();
    [CompilerGeneratedAttribute]
private void set_IsStrongType(bool value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public Type get_TemplateType();
    [CompilerGeneratedAttribute]
private void set_TemplateType(Type value);
    [CompilerGeneratedAttribute]
public string get_TemplateTypeName();
    [CompilerGeneratedAttribute]
private void set_TemplateTypeName(string value);
    public object CreateTemplateModel(object model);
    public static string GetFriendlyName(Type type);
    private static bool IsGenericType(Type type);
}
public class RazorLight.PageContext : object {
    [DynamicAttribute]
private object _viewBag;
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExecutingPageKey>k__BackingField;
    [CompilerGeneratedAttribute]
private ModelTypeInfo <ModelTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Model>k__BackingField;
    public TextWriter Writer { get; public set; }
    [DynamicAttribute]
public object ViewBag { get; }
    public string ExecutingPageKey { get; public set; }
    public ModelTypeInfo ModelTypeInfo { get; public set; }
    public object Model { get; public set; }
    public PageContext(ExpandoObject viewBag);
    [CompilerGeneratedAttribute]
public sealed virtual TextWriter get_Writer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Writer(TextWriter value);
    public sealed virtual object get_ViewBag();
    [CompilerGeneratedAttribute]
public string get_ExecutingPageKey();
    [CompilerGeneratedAttribute]
public void set_ExecutingPageKey(string value);
    [CompilerGeneratedAttribute]
public ModelTypeInfo get_ModelTypeInfo();
    [CompilerGeneratedAttribute]
public void set_ModelTypeInfo(ModelTypeInfo value);
    [CompilerGeneratedAttribute]
public object get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(object value);
}
public class RazorLight.Razor.EmbeddedRazorProject : RazorLightProject {
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    public Assembly Assembly { get; public set; }
    public string RootNamespace { get; public set; }
    public string Extension { get; public set; }
    public EmbeddedRazorProject(Type rootType);
    public EmbeddedRazorProject(Assembly assembly, string rootNamespace);
    [CompilerGeneratedAttribute]
public Assembly get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(Assembly value);
    [CompilerGeneratedAttribute]
public string get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_Extension();
    [CompilerGeneratedAttribute]
public void set_Extension(string value);
    public virtual Task`1<RazorLightProjectItem> GetItemAsync(string templateKey);
    public virtual Task`1<IEnumerable`1<RazorLightProjectItem>> GetImportsAsync(string templateKey);
    public virtual Task`1<IEnumerable`1<string>> GetKnownKeysAsync();
}
public class RazorLight.Razor.EmbeddedRazorProjectItem : RazorLightProjectItem {
    private string fullTemplateKey;
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public Assembly Assembly { get; public set; }
    public string Key { get; }
    public bool Exists { get; }
    public EmbeddedRazorProjectItem(Assembly assembly, string rootNamespace, string key);
    public EmbeddedRazorProjectItem(Type rootType, string key);
    [CompilerGeneratedAttribute]
public Assembly get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(Assembly value);
    [CompilerGeneratedAttribute]
public virtual string get_Key();
    public virtual bool get_Exists();
    public virtual Stream Read();
    [CompilerGeneratedAttribute]
private bool <get_Exists>b__11_0(string f);
}
public class RazorLight.Razor.FileSystemRazorProject : RazorLightProject {
    public static string DefaultExtension;
    private IFileProvider _fileProvider;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    public string Extension { get; public set; }
    public string Root { get; }
    public FileSystemRazorProject(string root);
    public FileSystemRazorProject(string root, string extension);
    [CompilerGeneratedAttribute]
public string get_Extension();
    [CompilerGeneratedAttribute]
public void set_Extension(string value);
    public virtual Task`1<RazorLightProjectItem> GetItemAsync(string templateKey);
    [CompilerGeneratedAttribute]
public string get_Root();
    protected string GetAbsoluteFilePathFromKey(string templateKey);
    public virtual Task`1<IEnumerable`1<RazorLightProjectItem>> GetImportsAsync(string templateKey);
    public virtual Task`1<IEnumerable`1<string>> GetKnownKeysAsync();
    public virtual string NormalizeKey(string templateKey);
    [CompilerGeneratedAttribute]
private bool <GetKnownKeysAsync>b__14_0(string x);
    [CompilerGeneratedAttribute]
private string <GetKnownKeysAsync>b__14_1(string x);
}
public static class RazorLight.Razor.FileSystemRazorProjectHelper : object {
    public static string NormalizeKey(string templateKey);
}
public class RazorLight.Razor.FileSystemRazorProjectItem : RazorLightProjectItem {
    [CompilerGeneratedAttribute]
private FileInfo <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public FileInfo File { get; }
    public string Key { get; }
    public bool Exists { get; }
    public FileSystemRazorProjectItem(string templateKey, FileInfo fileInfo);
    [CompilerGeneratedAttribute]
public FileInfo get_File();
    [CompilerGeneratedAttribute]
public virtual string get_Key();
    public virtual bool get_Exists();
    public virtual Stream Read();
}
public class RazorLight.Razor.NoRazorProject : RazorLightProject {
    public virtual Task`1<RazorLightProjectItem> GetItemAsync(string templateKey);
    public virtual Task`1<IEnumerable`1<RazorLightProjectItem>> GetImportsAsync(string templateKey);
    public virtual Task`1<IEnumerable`1<string>> GetKnownKeysAsync();
}
public class RazorLight.Razor.NoRazorProjectItem : RazorLightProjectItem {
    private static Lazy`1<NoRazorProjectItem> EmptyImpl;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exists>k__BackingField;
    public static NoRazorProjectItem Empty { get; }
    public string Key { get; }
    public bool Exists { get; }
    private static NoRazorProjectItem();
    public static NoRazorProjectItem get_Empty();
    [CompilerGeneratedAttribute]
public virtual string get_Key();
    [CompilerGeneratedAttribute]
public virtual bool get_Exists();
    public virtual Stream Read();
    public virtual bool Equals(object obj);
    private bool Equals(NoRazorProjectItem other);
    public virtual int GetHashCode();
}
public class RazorLight.Razor.RazorLightHelperResult : object {
    private Func`2<TextWriter, Task> _writeAction;
    public RazorLightHelperResult(Func`2<TextWriter, Task> asyncAction);
    public virtual void WriteTo(TextWriter writer, HtmlEncoder encoder);
}
public abstract class RazorLight.Razor.RazorLightProject : object {
    public abstract virtual Task`1<RazorLightProjectItem> GetItemAsync(string templateKey);
    public abstract virtual Task`1<IEnumerable`1<RazorLightProjectItem>> GetImportsAsync(string templateKey);
    public virtual Task`1<IEnumerable`1<string>> GetKnownKeysAsync();
    public virtual string NormalizeKey(string templateKey);
}
public abstract class RazorLight.Razor.RazorLightProjectItem : object {
    [CompilerGeneratedAttribute]
private IChangeToken <ExpirationToken>k__BackingField;
    public IChangeToken ExpirationToken { get; public set; }
    public string Key { get; }
    public bool Exists { get; }
    [CompilerGeneratedAttribute]
public IChangeToken get_ExpirationToken();
    [CompilerGeneratedAttribute]
public void set_ExpirationToken(IChangeToken value);
    public abstract virtual string get_Key();
    public abstract virtual bool get_Exists();
    public abstract virtual Stream Read();
}
[AttributeUsageAttribute("1")]
public class RazorLight.Razor.RazorLightTemplateAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TemplateType>k__BackingField;
    public string Key { get; }
    public Type TemplateType { get; }
    public RazorLightTemplateAttribute(string key, Type templateType);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public Type get_TemplateType();
}
public class RazorLight.Razor.TextSourceRazorProjectItem : RazorLightProjectItem {
    private string _content;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; }
    public bool Exists { get; }
    public string Content { get; }
    public TextSourceRazorProjectItem(string key, string content);
    [CompilerGeneratedAttribute]
public virtual string get_Key();
    public virtual bool get_Exists();
    public string get_Content();
    public virtual Stream Read();
}
public class RazorLight.RazorLightDependencyBuilder : object {
    private IServiceCollection _services;
    public RazorLightDependencyBuilder(IServiceCollection services);
    public RazorLightDependencyBuilder UseFileSystemProject(string root, string extension);
    public RazorLightDependencyBuilder UseMemoryCachingProvider();
    public RazorLightDependencyBuilder UseEmbeddedResourcesProject(Type rootType);
    public RazorLightDependencyBuilder UseNetFrameworkLegacyFix();
    public RazorLightDependencyBuilder SetOperatingAssembly(Assembly assembly);
    public RazorLightDependencyBuilder ExcludeAssemblies(String[] assemblyNames);
    public RazorLightDependencyBuilder AddMetadataReferences(MetadataReference[] metadata);
}
public class RazorLight.RazorLightEngine : object {
    private IEngineHandler _handler;
    public RazorLightOptions Options { get; }
    public IEngineHandler Handler { get; }
    public RazorLightEngine(IEngineHandler handler);
    public sealed virtual RazorLightOptions get_Options();
    public sealed virtual IEngineHandler get_Handler();
    [ObsoleteAttribute("Please, use generic version of CompileRenderAsync", "True")]
public sealed virtual Task`1<string> CompileRenderAsync(string key, object model, Type modelType, ExpandoObject viewBag);
    [ObsoleteAttribute("Please, use CompileRenderStringAsync", "True")]
public Task`1<string> CompileRenderAsync(string key, string content, object model, Type modelType, ExpandoObject viewBag);
    [ObsoleteAttribute("Please, use generic version of RenderTemplateAsync", "True")]
public sealed virtual Task`1<string> RenderTemplateAsync(ITemplatePage templatePage, object model, Type modelType, ExpandoObject viewBag);
    [ObsoleteAttribute("Please, use generic version of RenderTemplateAsync", "True")]
public sealed virtual Task RenderTemplateAsync(ITemplatePage templatePage, object model, Type modelType, TextWriter textWriter, ExpandoObject viewBag);
    public sealed virtual Task`1<string> CompileRenderAsync(string key, T model, ExpandoObject viewBag);
    public sealed virtual Task`1<string> CompileRenderStringAsync(string key, string content, T model, ExpandoObject viewBag);
    public sealed virtual Task`1<ITemplatePage> CompileTemplateAsync(string key);
    public sealed virtual Task`1<string> RenderTemplateAsync(ITemplatePage templatePage, T model, ExpandoObject viewBag);
    public sealed virtual Task RenderTemplateAsync(ITemplatePage templatePage, T model, TextWriter textWriter, ExpandoObject viewBag);
}
public class RazorLight.RazorLightEngineBuilder : object {
    protected Assembly operatingAssembly;
    protected HashSet`1<string> namespaces;
    protected ConcurrentDictionary`2<string, string> dynamicTemplates;
    protected HashSet`1<MetadataReference> metadataReferences;
    protected HashSet`1<string> excludedAssemblies;
    protected List`1<Action`1<ITemplatePage>> prerenderCallbacks;
    protected RazorLightProject project;
    protected ICachingProvider cachingProvider;
    private Nullable`1<bool> disableEncoding;
    private Nullable`1<bool> enableDebugMode;
    private RazorLightOptions options;
    public virtual RazorLightEngineBuilder UseProject(RazorLightProject razorLightProject);
    public RazorLightEngineBuilder UseNoProject();
    public RazorLightEngineBuilder UseFileSystemProject(string root);
    public RazorLightEngineBuilder UseFileSystemProject(string root, string extension);
    public RazorLightEngineBuilder UseEmbeddedResourcesProject(Type rootType);
    public RazorLightEngineBuilder UseEmbeddedResourcesProject(Assembly assembly, string rootNamespace);
    public RazorLightEngineBuilder UseOptions(RazorLightOptions razorLightOptions);
    public RazorLightEngineBuilder DisableEncoding();
    public RazorLightEngineBuilder EnableEncoding();
    public virtual RazorLightEngineBuilder UseMemoryCachingProvider();
    public virtual RazorLightEngineBuilder UseCachingProvider(ICachingProvider provider);
    public virtual RazorLightEngineBuilder AddDefaultNamespaces(String[] namespaces);
    public virtual RazorLightEngineBuilder AddMetadataReferences(MetadataReference[] metadata);
    public virtual RazorLightEngineBuilder ExcludeAssemblies(String[] assemblyNames);
    public virtual RazorLightEngineBuilder AddPrerenderCallbacks(Action`1[] callbacks);
    public virtual RazorLightEngineBuilder AddDynamicTemplates(IDictionary`2<string, string> dynamicTemplates);
    public virtual RazorLightEngineBuilder SetOperatingAssembly(Assembly assembly);
    public virtual RazorLightEngineBuilder EnableDebugMode(bool enableDebugMode);
    public virtual RazorLightEngine Build();
    private void ThrowIfHasBeenSetExplicitly(string option);
}
public class RazorLight.RazorLightEngineWithFileSystemProjectFactory : object {
    public sealed virtual IRazorLightEngine Create(Assembly operatingAssembly, string fileSystemProjectRoot);
}
public class RazorLight.RazorLightException : Exception {
    public RazorLightException(string message);
    public RazorLightException(string message, Exception exception);
}
public class RazorLight.RazorLightOptions : object {
    [CompilerGeneratedAttribute]
private ISet`1<string> <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <DynamicTemplates>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<MetadataReference> <AdditionalMetadataReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ExcludedAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Action`1<ITemplatePage>> <PreRenderCallbacks>k__BackingField;
    [CompilerGeneratedAttribute]
private ICachingProvider <CachingProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <OperatingAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DisableEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableDebugMode>k__BackingField;
    public ISet`1<string> Namespaces { get; public set; }
    public IDictionary`2<string, string> DynamicTemplates { get; public set; }
    public HashSet`1<MetadataReference> AdditionalMetadataReferences { get; public set; }
    public HashSet`1<string> ExcludedAssemblies { get; public set; }
    public IList`1<Action`1<ITemplatePage>> PreRenderCallbacks { get; public set; }
    public ICachingProvider CachingProvider { get; public set; }
    public Assembly OperatingAssembly { get; public set; }
    public Nullable`1<bool> DisableEncoding { get; public set; }
    public Nullable`1<bool> EnableDebugMode { get; public set; }
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Namespaces();
    [CompilerGeneratedAttribute]
public void set_Namespaces(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_DynamicTemplates();
    [CompilerGeneratedAttribute]
public void set_DynamicTemplates(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<MetadataReference> get_AdditionalMetadataReferences();
    [CompilerGeneratedAttribute]
public void set_AdditionalMetadataReferences(HashSet`1<MetadataReference> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_ExcludedAssemblies();
    [CompilerGeneratedAttribute]
public void set_ExcludedAssemblies(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public virtual IList`1<Action`1<ITemplatePage>> get_PreRenderCallbacks();
    [CompilerGeneratedAttribute]
public virtual void set_PreRenderCallbacks(IList`1<Action`1<ITemplatePage>> value);
    [CompilerGeneratedAttribute]
public ICachingProvider get_CachingProvider();
    [CompilerGeneratedAttribute]
public void set_CachingProvider(ICachingProvider value);
    [CompilerGeneratedAttribute]
public Assembly get_OperatingAssembly();
    [CompilerGeneratedAttribute]
public void set_OperatingAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DisableEncoding();
    [CompilerGeneratedAttribute]
public void set_DisableEncoding(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableDebugMode();
    [CompilerGeneratedAttribute]
public void set_EnableDebugMode(Nullable`1<bool> value);
}
public class RazorLight.TagHelpers.DefaultTagHelperActivator : object {
    private ITypeActivatorCache _typeActivatorCache;
    public DefaultTagHelperActivator(ITypeActivatorCache typeActivatorCache);
    public sealed virtual TTagHelper Create(PageContext context);
}
public class RazorLight.TagHelpers.DefaultTagHelperFactory : object {
    private ITagHelperActivator _activator;
    private ConcurrentDictionary`2<Type, PropertyActivator`1[]> _injectActions;
    private static Func`2<PropertyInfo, PropertyActivator`1<PageContext>> _createActivateInfo;
    public DefaultTagHelperFactory(ITagHelperActivator activator);
    private static DefaultTagHelperFactory();
    public sealed virtual TTagHelper CreateTagHelper(PageContext context);
    private static void InitializeTagHelper(TTagHelper tagHelper, PageContext context);
    private static PropertyActivator`1<PageContext> CreateActivateInfo(PropertyInfo property);
}
public interface RazorLight.TagHelpers.ITagHelperActivator {
    public abstract virtual TTagHelper Create(PageContext context);
}
public interface RazorLight.TagHelpers.ITagHelperFactory {
    public abstract virtual TTagHelper CreateTagHelper(PageContext context);
}
public interface RazorLight.TagHelpers.ITagHelperInitializer`1 {
    public abstract virtual void Initialize(TTagHelper helper, PageContext context);
}
public interface RazorLight.TagHelpers.ITypeActivatorCache {
    public abstract virtual TInstance CreateInstance(IServiceProvider serviceProvider, Type optionType);
}
public class RazorLight.TagHelpers.TypeActivatorCache : object {
    private Func`2<Type, ObjectFactory> _createFactory;
    private ConcurrentDictionary`2<Type, ObjectFactory> _typeActivatorCache;
    public sealed virtual TInstance CreateInstance(IServiceProvider serviceProvider, Type implementationType);
}
public class RazorLight.TemplateNotFoundException : RazorLightException {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <KnownDynamicTemplateKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <KnownProjectTemplateKeys>k__BackingField;
    public IEnumerable`1<string> KnownDynamicTemplateKeys { get; }
    public IEnumerable`1<string> KnownProjectTemplateKeys { get; }
    public TemplateNotFoundException(string message);
    public TemplateNotFoundException(string message, Exception exception);
    public TemplateNotFoundException(string message, IEnumerable`1<string> knownDynamicTemplateKeys, IEnumerable`1<string> knownProjectTemplateKeys);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_KnownDynamicTemplateKeys();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_KnownProjectTemplateKeys();
}
public abstract class RazorLight.TemplatePage : TemplatePageBase {
    private HashSet`1<string> _renderedSections;
    private bool _renderedBody;
    private bool _ignoreBody;
    private HashSet`1<string> _ignoredSections;
    [AsyncStateMachineAttribute("RazorLight.TemplatePage/<IncludeAsync>d__4")]
public Task IncludeAsync(string key, object model);
    protected virtual IHtmlContent RenderBody();
    public void IgnoreBody();
    public virtual void DefineSection(string name, RenderAsyncDelegate section);
    public bool IsSectionDefined(string name);
    public HtmlString RenderSection(string name);
    public HtmlString RenderSection(string name, bool required);
    public Task`1<HtmlString> RenderSectionAsync(string name);
    public Task`1<HtmlString> RenderSectionAsync(string name, bool required);
    [AsyncStateMachineAttribute("RazorLight.TemplatePage/<RenderSectionAsyncCore>d__13")]
private Task`1<HtmlString> RenderSectionAsyncCore(string sectionName, bool required);
    public void IgnoreSection(string sectionName);
    public virtual void EnsureRenderedBodyOrSections();
    public virtual void BeginContext(int position, int length, bool isLiteral);
    public virtual void EndContext();
    private void EnsureMethodCanBeInvoked(string methodName);
}
public abstract class RazorLight.TemplatePage`1 : TemplatePage {
    [CompilerGeneratedAttribute]
private TModel <Model>k__BackingField;
    public TModel Model { get; public set; }
    [CompilerGeneratedAttribute]
public TModel get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(TModel value);
    public virtual void SetModel(object model);
}
public abstract class RazorLight.TemplatePageBase : object {
    private Stack`1<TextWriter> _textWriterStack;
    private StringWriter _valueBuffer;
    private ITagHelperFactory _tagHelperFactory;
    private IViewBufferScope _bufferScope;
    private TextWriter _pageWriter;
    private AttributeInfo _attributeInfo;
    private TagHelperAttributeInfo _tagHelperAttributeInfo;
    [CompilerGeneratedAttribute]
private PageContext <PageContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IHtmlContent <BodyContent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLayoutBeingRendered>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, object, Task> <IncludeFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<TagHelperScopeInfo> <TagHelperScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, RenderAsyncDelegate> <PreviousSectionWriters>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, RenderAsyncDelegate> <SectionWriters>k__BackingField;
    [CompilerGeneratedAttribute]
private HtmlEncoder <HtmlEncoder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableEncoding>k__BackingField;
    public PageContext PageContext { get; public set; }
    public IHtmlContent BodyContent { get; public set; }
    public bool IsLayoutBeingRendered { get; public set; }
    public string Layout { get; public set; }
    [DynamicAttribute]
public object ViewBag { get; }
    public Func`3<string, object, Task> IncludeFunc { get; public set; }
    private Stack`1<TagHelperScopeInfo> TagHelperScopes { get; }
    public IDictionary`2<string, RenderAsyncDelegate> PreviousSectionWriters { get; public set; }
    public IDictionary`2<string, RenderAsyncDelegate> SectionWriters { get; }
    public HtmlEncoder HtmlEncoder { get; public set; }
    public string Key { get; public set; }
    public bool DisableEncoding { get; public set; }
    public TextWriter Output { get; }
    private ITagHelperFactory TagHelperFactory { get; }
    private IViewBufferScope BufferScope { get; }
    public abstract virtual void SetModel(object model);
    [CompilerGeneratedAttribute]
public virtual PageContext get_PageContext();
    [CompilerGeneratedAttribute]
public virtual void set_PageContext(PageContext value);
    [CompilerGeneratedAttribute]
public sealed virtual IHtmlContent get_BodyContent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BodyContent(IHtmlContent value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLayoutBeingRendered();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsLayoutBeingRendered(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Layout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Layout(string value);
    public virtual object get_ViewBag();
    [CompilerGeneratedAttribute]
public sealed virtual Func`3<string, object, Task> get_IncludeFunc();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeFunc(Func`3<string, object, Task> value);
    [CompilerGeneratedAttribute]
private Stack`1<TagHelperScopeInfo> get_TagHelperScopes();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, RenderAsyncDelegate> get_PreviousSectionWriters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PreviousSectionWriters(IDictionary`2<string, RenderAsyncDelegate> value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, RenderAsyncDelegate> get_SectionWriters();
    [CompilerGeneratedAttribute]
public HtmlEncoder get_HtmlEncoder();
    [CompilerGeneratedAttribute]
public void set_HtmlEncoder(HtmlEncoder value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Key(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DisableEncoding();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DisableEncoding(bool value);
    public virtual TextWriter get_Output();
    private ITagHelperFactory get_TagHelperFactory();
    private IViewBufferScope get_BufferScope();
    public abstract virtual Task ExecuteAsync();
    [AsyncStateMachineAttribute("RazorLight.TemplatePageBase/<FlushAsync>d__59")]
public virtual Task`1<HtmlString> FlushAsync();
    public abstract virtual void BeginContext(int position, int length, bool isLiteral);
    public abstract virtual void EndContext();
    public abstract virtual void EnsureRenderedBodyOrSections();
    public IRawString Raw(string rawString);
    public static IHtmlContent HelperFunction(Func`2<object, IHtmlContent> body);
    public TTagHelper CreateTagHelper();
    public void StartTagHelperWritingScope(HtmlEncoder encoder);
    public TagHelperContent EndTagHelperWritingScope();
    public void BeginWriteTagHelperAttribute();
    public string EndWriteTagHelperAttribute();
    [EditorBrowsableAttribute("1")]
protected void DefineSection(string name, Func`2<object, Task> section);
    public virtual void DefineSection(string name, RenderAsyncDelegate section);
    public virtual void Write(object value);
    public virtual void Write(string value);
    public virtual void WriteLiteral(object value);
    public virtual void WriteLiteral(string value);
    protected internal virtual void PushWriter(TextWriter writer);
    protected internal virtual TextWriter PopWriter();
    public virtual void BeginWriteAttribute(string name, string prefix, int prefixOffset, string suffix, int suffixOffset, int attributeValuesCount);
    public void WriteAttributeValue(string prefix, int prefixOffset, object value, int valueOffset, int valueLength, bool isLiteral);
    public virtual void EndWriteAttribute();
    public void BeginAddHtmlAttributeValues(TagHelperExecutionContext executionContext, string attributeName, int attributeValuesCount, HtmlAttributeValueStyle attributeValueStyle);
    public void AddHtmlAttributeValue(string prefix, int prefixOffset, object value, int valueOffset, int valueLength, bool isLiteral);
    public void EndAddHtmlAttributeValues(TagHelperExecutionContext executionContext);
    private void WriteUnprefixedAttributeValue(object value, bool isLiteral);
    private void WritePositionTaggedLiteral(string value, int position);
    private bool IsBoolFalseOrNullValue(string prefix, object value);
    private bool IsBoolTrueWithEmptyPrefixValue(string prefix, object value);
}
public class RazorLight.TemplateRenderer : object {
    private HtmlEncoder _htmlEncoder;
    private IEngineHandler _engineHandler;
    private IViewBufferScope _bufferScope;
    public TemplateRenderer(IEngineHandler engineHandler, HtmlEncoder htmlEncoder, IViewBufferScope bufferScope);
    [AsyncStateMachineAttribute("RazorLight.TemplateRenderer/<RenderAsync>d__4")]
public virtual Task RenderAsync(ITemplatePage page);
    [AsyncStateMachineAttribute("RazorLight.TemplateRenderer/<RenderPageAsync>d__5")]
private Task`1<ViewBufferTextWriter> RenderPageAsync(ITemplatePage page, PageContext context, bool invokeViewStarts);
    [AsyncStateMachineAttribute("RazorLight.TemplateRenderer/<RenderPageCoreAsync>d__6")]
private Task RenderPageCoreAsync(ITemplatePage page, PageContext context);
    private Task RenderViewStartsAsync(PageContext context);
    [AsyncStateMachineAttribute("RazorLight.TemplateRenderer/<RenderLayoutAsync>d__8")]
private Task RenderLayoutAsync(ITemplatePage page, PageContext context, ViewBufferTextWriter bodyWriter);
    private void ExecutePageCallbacks(ITemplatePage page, IList`1<Action`1<ITemplatePage>> callbacks);
}
public interface RazorLight.Text.IRawString {
    public abstract virtual void WriteTo(TextWriter writer);
}
public class RazorLight.Text.RawString : object {
    private string _value;
    public string Value { get; }
    public RawString(string value);
    public string get_Value();
    public sealed virtual void WriteTo(TextWriter writer);
}
