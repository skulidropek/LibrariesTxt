[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Rebus.Activation.BuiltinHandlerActivator : object {
    private List`1<object> _handlerInstances;
    private List`1<Delegate> _handlerFactoriesNoArguments;
    private List`1<Delegate> _handlerFactoriesMessageContextArgument;
    private List`1<Delegate> _handlerFactoriesBusAndMessageContextArguments;
    private ConcurrentDictionary`2<Type, Func`2[]> _cachedHandlerFactories;
    private ConcurrentDictionary`2<Type, IHandleMessages[]> _cachedHandlers;
    [CompilerGeneratedAttribute]
private IBus <Bus>k__BackingField;
    public IBus Bus { get; private set; }
    [AsyncStateMachineAttribute("Rebus.Activation.BuiltinHandlerActivator/<GetHandlers>d__6`1")]
public sealed virtual Task`1<IEnumerable`1<IHandleMessages`1<TMessage>>> GetHandlers(TMessage message, ITransactionContext transactionContext);
    [CompilerGeneratedAttribute]
public IBus get_Bus();
    [CompilerGeneratedAttribute]
private void set_Bus(IBus value);
    public sealed virtual void SetBus(IBus bus);
    public BuiltinHandlerActivator Handle(Func`4<IBus, IMessageContext, TMessage, Task> handlerFunction);
    public BuiltinHandlerActivator Handle(Func`3<IBus, TMessage, Task> handlerFunction);
    public BuiltinHandlerActivator Handle(Func`2<TMessage, Task> handlerFunction);
    public BuiltinHandlerActivator Register(Func`1<THandler> handlerFactory);
    public BuiltinHandlerActivator Register(Func`2<IMessageContext, THandler> handlerFactory);
    public BuiltinHandlerActivator Register(Func`3<IBus, IMessageContext, THandler> handlerFactory);
    private void AssertHasNotBeenStarted(string handlerDescription);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private IBus <Handle>b__13_0();
}
internal class Rebus.Activation.EmptyActivator : object {
    public sealed virtual Task`1<IEnumerable`1<IHandleMessages`1<TMessage>>> GetHandlers(TMessage message, ITransactionContext transactionContext);
}
public interface Rebus.Activation.IContainerAdapter {
    public abstract virtual void SetBus(IBus bus);
}
public interface Rebus.Activation.IHandlerActivator {
    public abstract virtual Task`1<IEnumerable`1<IHandleMessages`1<TMessage>>> GetHandlers(TMessage message, ITransactionContext transactionContext);
}
[ExtensionAttribute]
internal static class Rebus.Activation.OneWayClientTransportValidationExtensions : object {
    [ExtensionAttribute]
public static void ValidateOneWayClient(OptionsConfigurer options);
}
public static class Rebus.Auditing.Messages.AuditHeaders : object {
    public static string AuditTime;
    public static string HandleTime;
    public static string HandleQueue;
    public static string MachineName;
}
internal class Rebus.Auditing.Messages.AuditingHelper : object {
    private ITransport _transport;
    private IRebusTime _rebusTime;
    private bool _didInitializeAuditQueue;
    [CompilerGeneratedAttribute]
private string <AuditQueueName>k__BackingField;
    public string AuditQueueName { get; }
    public AuditingHelper(ITransport transport, string auditQueueName, IRebusTime rebusTime);
    [CompilerGeneratedAttribute]
public string get_AuditQueueName();
    public void EnsureAuditQueueHasBeenCreated();
    public void SetCommonHeaders(TransportMessage transportMessage);
    private static string GetMachineName();
}
[StepDocumentationAttribute("Wraps the execution of the entire receive pipeline and forwards a copy of the current transport message to the configured audit queue if processing was successful, including some useful headers.")]
internal class Rebus.Auditing.Messages.IncomingAuditingStep : object {
    private AuditingHelper _auditingHelper;
    private ITransport _transport;
    private IRebusTime _rebusTime;
    public IncomingAuditingStep(AuditingHelper auditingHelper, ITransport transport, IRebusTime rebusTime);
    public sealed virtual void Initialize();
    [AsyncStateMachineAttribute("Rebus.Auditing.Messages.IncomingAuditingStep/<Process>d__5")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
}
[ExtensionAttribute]
public static class Rebus.Auditing.Messages.MessageAuditingConfigurationExtensions : object {
    [ExtensionAttribute]
public static void EnableMessageAuditing(OptionsConfigurer configurer, string auditQueue);
}
[StepDocumentationAttribute("Forwards a copy of published messages to the configured audit queue, including some useful headers.")]
internal class Rebus.Auditing.Messages.OutgoingAuditingStep : object {
    private AuditingHelper _auditingHelper;
    private ITransport _transport;
    public OutgoingAuditingStep(AuditingHelper auditingHelper, ITransport transport);
    public sealed virtual void Initialize();
    [AsyncStateMachineAttribute("Rebus.Auditing.Messages.OutgoingAuditingStep/<Process>d__4")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
    private static bool IsPublishedMessage(TransportMessage transportMessage);
}
public interface Rebus.Auditing.Sagas.ISagaSnapshotStorage {
    public abstract virtual Task Save(ISagaData sagaData, Dictionary`2<string, string> sagaAuditMetadata);
}
internal class Rebus.Auditing.Sagas.LoggerSagaSnapperShotter : object {
    private ILog _log;
    public LoggerSagaSnapperShotter(IRebusLoggerFactory rebusLoggerFactory);
    [AsyncStateMachineAttribute("Rebus.Auditing.Sagas.LoggerSagaSnapperShotter/<Save>d__2")]
public sealed virtual Task Save(ISagaData sagaData, Dictionary`2<string, string> sagaAuditMetadata);
}
[ExtensionAttribute]
public static class Rebus.Auditing.Sagas.SagaAuditingConfigurationExtensions : object {
    [ExtensionAttribute]
public static StandardConfigurer`1<ISagaSnapshotStorage> EnableSagaAuditing(OptionsConfigurer configurer);
    [ExtensionAttribute]
public static void OutputToLog(StandardConfigurer`1<ISagaSnapshotStorage> configurer);
    private static ITransport GetTransport(IResolutionContext context);
    private static ISagaSnapshotStorage GetSagaSnapshotStorage(IResolutionContext context);
}
public static class Rebus.Auditing.Sagas.SagaAuditingMetadataKeys : object {
    public static string HandleQueue;
    public static string SagaDataType;
    public static string SagaHandlerType;
    public static string MessageType;
    public static string MessageId;
    public static string MachineName;
}
[StepDocumentationAttribute("Saves a snapshot of each piece of saga data to the selected snapshot storage.")]
internal class Rebus.Auditing.Sagas.SaveSagaDataSnapshotStep : object {
    private ISagaSnapshotStorage _sagaSnapshotStorage;
    private ITransport _transport;
    private string _machineName;
    public SaveSagaDataSnapshotStep(ISagaSnapshotStorage sagaSnapshotStorage, ITransport transport);
    [AsyncStateMachineAttribute("Rebus.Auditing.Sagas.SaveSagaDataSnapshotStep/<Process>d__4")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    private Dictionary`2<string, string> GetMetadata(ISagaData sagaData, object handler, Message message);
    private static string GetMachineName();
}
[ExtensionAttribute]
public static class Rebus.Backoff.BackoffConfigurationExtensions : object {
    [ExtensionAttribute]
public static void SetBackoffTimes(OptionsConfigurer configurer, TimeSpan[] backoffTimes);
    [ExtensionAttribute]
public static void SetBackoffTimes(OptionsConfigurer configurer, IEnumerable`1<TimeSpan> backoffTimes);
}
internal static class Rebus.Bus.Advanced.AsyncHelpers : object {
    public static void RunSync(Func`1<Task> task);
}
public interface Rebus.Bus.Advanced.IAdvancedApi {
    public IWorkersApi Workers { get; }
    public ITopicsApi Topics { get; }
    public IRoutingApi Routing { get; }
    public ITransportMessageApi TransportMessage { get; }
    public IDataBus DataBus { get; }
    public ISyncBus SyncBus { get; }
    public abstract virtual IWorkersApi get_Workers();
    public abstract virtual ITopicsApi get_Topics();
    public abstract virtual IRoutingApi get_Routing();
    public abstract virtual ITransportMessageApi get_TransportMessage();
    public abstract virtual IDataBus get_DataBus();
    public abstract virtual ISyncBus get_SyncBus();
}
public interface Rebus.Bus.Advanced.IRoutingApi {
    public abstract virtual Task Send(string destinationAddress, object explicitlyRoutedMessage, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual Task SendRoutingSlip(Itinerary itinerary, object message, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual Task Defer(string destinationAddress, TimeSpan delay, object explicitlyRoutedMessage, IDictionary`2<string, string> optionalHeaders);
}
public interface Rebus.Bus.Advanced.ISyncBus {
    public abstract virtual void SendLocal(object commandMessage, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual void Send(object commandMessage, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual void Reply(object replyMessage, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual void Defer(TimeSpan delay, object message, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual void DeferLocal(TimeSpan delay, object message, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual void Subscribe();
    public abstract virtual void Subscribe(Type eventType);
    public abstract virtual void Unsubscribe();
    public abstract virtual void Unsubscribe(Type eventType);
    public abstract virtual void Publish(object eventMessage, IDictionary`2<string, string> optionalHeaders);
}
public interface Rebus.Bus.Advanced.ITopicsApi {
    public abstract virtual Task Publish(string topic, object eventMessage, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual Task Subscribe(string topic);
    public abstract virtual Task Unsubscribe(string topic);
}
public interface Rebus.Bus.Advanced.ITransportMessageApi {
    public abstract virtual Task Forward(string destinationAddress, Dictionary`2<string, string> optionalAdditionalHeaders);
    public abstract virtual Task Defer(TimeSpan delay, Dictionary`2<string, string> optionalAdditionalHeaders);
}
public interface Rebus.Bus.Advanced.IWorkersApi {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual void SetNumberOfWorkers(int numberOfWorkers);
}
public class Rebus.Bus.BusLifetimeEvents : object {
    [CompilerGeneratedAttribute]
private Action BusStarting;
    [CompilerGeneratedAttribute]
private Action BusStarted;
    [CompilerGeneratedAttribute]
private Action BusDisposing;
    [CompilerGeneratedAttribute]
private Action WorkersStopped;
    [CompilerGeneratedAttribute]
private Action BusDisposed;
    [CompilerGeneratedAttribute]
public void add_BusStarting(Action value);
    [CompilerGeneratedAttribute]
public void remove_BusStarting(Action value);
    [CompilerGeneratedAttribute]
public void add_BusStarted(Action value);
    [CompilerGeneratedAttribute]
public void remove_BusStarted(Action value);
    [CompilerGeneratedAttribute]
public void add_BusDisposing(Action value);
    [CompilerGeneratedAttribute]
public void remove_BusDisposing(Action value);
    [CompilerGeneratedAttribute]
public void add_WorkersStopped(Action value);
    [CompilerGeneratedAttribute]
public void remove_WorkersStopped(Action value);
    [CompilerGeneratedAttribute]
public void add_BusDisposed(Action value);
    [CompilerGeneratedAttribute]
public void remove_BusDisposed(Action value);
    internal void RaiseBusStarting();
    internal void RaiseBusStarted();
    internal void RaiseBusDisposing();
    internal void RaiseBusDisposed();
    internal void RaiseWorkersStopped();
}
public interface Rebus.Bus.IBus {
    public IAdvancedApi Advanced { get; }
    public abstract virtual Task SendLocal(object commandMessage, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual Task Send(object commandMessage, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual Task DeferLocal(TimeSpan delay, object message, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual Task Defer(TimeSpan delay, object message, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual Task Reply(object replyMessage, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual Task Subscribe();
    public abstract virtual Task Subscribe(Type eventType);
    public abstract virtual Task Unsubscribe();
    public abstract virtual Task Unsubscribe(Type eventType);
    public abstract virtual Task Publish(object eventMessage, IDictionary`2<string, string> optionalHeaders);
    public abstract virtual IAdvancedApi get_Advanced();
}
public interface Rebus.Bus.IInitializable {
    public abstract virtual void Initialize();
}
[ExtensionAttribute]
public static class Rebus.Bus.MessageExtensions : object {
    [ExtensionAttribute]
public static void SetDeferHeaders(Message message, DateTimeOffset approximateDeliveryTime, string destinationAddress);
    [ExtensionAttribute]
public static void SetDeferHeaders(TransportMessage message, DateTimeOffset approximateDeliveryTime, string destinationAddress);
    private static void InnerSetDeferHeaders(DateTimeOffset approximateDeliveryTime, Dictionary`2<string, string> headers, string destinationAddress);
    [ExtensionAttribute]
public static string GetMessageType(Message message);
    [ExtensionAttribute]
public static string GetMessageType(TransportMessage message);
    [ExtensionAttribute]
public static string GetMessageId(Message message);
    [ExtensionAttribute]
public static string GetMessageId(TransportMessage message);
    [ExtensionAttribute]
public static string GetMessageLabel(Message message);
    [ExtensionAttribute]
public static string GetMessageLabel(TransportMessage message);
    [ExtensionAttribute]
public static TransportMessage Clone(TransportMessage message);
    private static string GetMessageLabel(Dictionary`2<string, string> headers);
    private static string GetTypeNameFromBodyObjectOrNull(object body);
}
public class Rebus.Bus.RebusBus : object {
    private static int _busIdCounter;
    private List`1<IWorker> _workers;
    private BusLifetimeEvents _busLifetimeEvents;
    private ISubscriptionStorage _subscriptionStorage;
    private ITopicNameConvention _topicNameConvention;
    private IPipelineInvoker _pipelineInvoker;
    private IWorkerFactory _workerFactory;
    private ITransport _transport;
    private IRebusTime _rebusTime;
    private IDataBus _dataBus;
    private Options _options;
    private IRouter _router;
    private string _busName;
    private ILog _log;
    private bool _disposing;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private Action Disposed;
    public IAdvancedApi Advanced { get; }
    public RebusBus(IWorkerFactory workerFactory, IRouter router, ITransport transport, IPipelineInvoker pipelineInvoker, ISubscriptionStorage subscriptionStorage, Options options, IRebusLoggerFactory rebusLoggerFactory, BusLifetimeEvents busLifetimeEvents, IDataBus dataBus, ITopicNameConvention topicNameConvention, IRebusTime rebusTime);
    public void Start(int numberOfWorkers);
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<SendLocal>d__22")]
public sealed virtual Task SendLocal(object commandMessage, IDictionary`2<string, string> optionalHeaders);
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<Send>d__23")]
public sealed virtual Task Send(object commandMessage, IDictionary`2<string, string> optionalHeaders);
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<DeferLocal>d__24")]
public sealed virtual Task DeferLocal(TimeSpan delay, object message, IDictionary`2<string, string> optionalHeaders);
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<Defer>d__25")]
public sealed virtual Task Defer(TimeSpan delay, object message, IDictionary`2<string, string> optionalHeaders);
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<Reply>d__26")]
public sealed virtual Task Reply(object replyMessage, IDictionary`2<string, string> optionalHeaders);
    public sealed virtual Task Subscribe();
    public sealed virtual Task Subscribe(Type eventType);
    public sealed virtual Task Unsubscribe();
    public sealed virtual Task Unsubscribe(Type eventType);
    public sealed virtual Task Publish(object eventMessage, IDictionary`2<string, string> optionalHeaders);
    public sealed virtual IAdvancedApi get_Advanced();
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<InnerPublish>d__34")]
private Task InnerPublish(string topic, object eventMessage, IDictionary`2<string, string> optionalHeaders);
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<InnerSubscribe>d__35")]
private Task InnerSubscribe(string topic);
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<InnerUnsubscribe>d__36")]
private Task InnerUnsubscribe(string topic);
    private string GetTimeoutManagerAddress();
    private static Message CreateMessage(object commandMessage, Operation operation, IDictionary`2<string, string> optionalHeaders);
    private static Dictionary`2<string, string> CreateHeaders(IDictionary`2<string, string> optionalHeaders);
    private static string GetReturnAddress(TransportMessage transportMessage);
    private static StepContext GetCurrentReceiveContext(ITransactionContext currentTransactionContext);
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<InnerSend>d__43")]
private Task InnerSend(IEnumerable`1<string> destinationAddresses, Message logicalMessage);
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<SendUsingTransactionContext>d__44")]
private Task SendUsingTransactionContext(IEnumerable`1<string> destinationAddresses, Message logicalMessage, ITransactionContext transactionContext);
    [AsyncStateMachineAttribute("Rebus.Bus.RebusBus/<SendTransportMessage>d__45")]
private Task SendTransportMessage(string destinationAddress, TransportMessage transportMessage);
    public sealed virtual void Dispose();
    private void StopWorker(IWorker worker);
    [CompilerGeneratedAttribute]
public void add_Disposed(Action value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(Action value);
    public void SetNumberOfWorkers(int desiredNumberOfWorkers);
    private int GetNumberOfWorkers();
    private void AddWorker();
    private void RemoveWorkers(int desiredNumberOfWorkers);
    private ITransactionContext GetCurrentTransactionContext(bool mustBelongToThisBus);
    public virtual string ToString();
}
public enum Rebus.Compression.DataCompressionMode : Enum {
    public int value__;
    public static DataCompressionMode Always;
    public static DataCompressionMode Explicit;
}
internal class Rebus.Compression.UnzippingSerializerDecorator : ZipDecoratorBase {
    private ISerializer _serializer;
    private Zipper _zipper;
    public UnzippingSerializerDecorator(ISerializer serializer, Zipper zipper);
    public sealed virtual Task`1<TransportMessage> Serialize(Message message);
    [AsyncStateMachineAttribute("Rebus.Compression.UnzippingSerializerDecorator/<Deserialize>d__4")]
public sealed virtual Task`1<Message> Deserialize(TransportMessage transportMessage);
}
[ExtensionAttribute]
public static class Rebus.Compression.ZipConfigurationExtensions : object {
    public static int DefaultBodyThresholdBytes;
    [ExtensionAttribute]
public static void EnableCompression(OptionsConfigurer configurer, int bodySizeThresholdBytes);
    [ExtensionAttribute]
public static StandardConfigurer`1<IDataBusStorage> UseCompression(StandardConfigurer`1<IDataBusStorage> configurer, DataCompressionMode dataCompressionMode);
}
internal abstract class Rebus.Compression.ZipDecoratorBase : object {
    public static string GzipEncodingHeader;
}
public class Rebus.Compression.Zipper : object {
    public Byte[] Zip(Byte[] uncompressedBytes);
    public Byte[] Unzip(Byte[] compressedBytes);
}
public class Rebus.Compression.ZippingDataBusStorageDecorator : object {
    private IDataBusStorage _innerDataBusStorage;
    private DataCompressionMode _dataCompressionMode;
    public ZippingDataBusStorageDecorator(IDataBusStorage innerDataBusStorage, DataCompressionMode dataCompressionMode);
    [AsyncStateMachineAttribute("Rebus.Compression.ZippingDataBusStorageDecorator/<Read>d__3")]
public sealed virtual Task`1<Stream> Read(string id);
    [AsyncStateMachineAttribute("Rebus.Compression.ZippingDataBusStorageDecorator/<ReadMetadata>d__4")]
public sealed virtual Task`1<Dictionary`2<string, string>> ReadMetadata(string id);
    [AsyncStateMachineAttribute("Rebus.Compression.ZippingDataBusStorageDecorator/<Save>d__5")]
public sealed virtual Task Save(string id, Stream source, Dictionary`2<string, string> metadata);
}
internal class Rebus.Compression.ZippingSerializerDecorator : ZipDecoratorBase {
    private ISerializer _serializer;
    private Zipper _zipper;
    private int _bodySizeThresholdBytes;
    public ZippingSerializerDecorator(ISerializer serializer, Zipper zipper, int bodySizeThresholdBytes);
    [AsyncStateMachineAttribute("Rebus.Compression.ZippingSerializerDecorator/<Serialize>d__4")]
public sealed virtual Task`1<TransportMessage> Serialize(Message message);
    [AsyncStateMachineAttribute("Rebus.Compression.ZippingSerializerDecorator/<Deserialize>d__5")]
public sealed virtual Task`1<Message> Deserialize(TransportMessage transportMessage);
}
public static class Rebus.Config.Configure : object {
    public static RebusConfigurer With(IHandlerActivator handlerActivator);
    public static RebusConfigurer OneWayClient();
}
internal class Rebus.Config.DefaultCorrelationErrorHandler : object {
    private ILog _log;
    public DefaultCorrelationErrorHandler(IRebusLoggerFactory rebusLoggerFactory);
    public sealed virtual Task HandleCorrelationError(SagaDataCorrelationProperties properties, HandlerInvoker handlerInvoker, Message message);
}
[ExtensionAttribute]
public static class Rebus.Config.DelayedStartupConfigurationExtensions : object {
    [ExtensionAttribute]
public static IBusStarter Create(RebusConfigurer configurer);
}
public interface Rebus.Config.IBusStarter {
    public IBus Bus { get; }
    public abstract virtual IBus Start();
    public abstract virtual IBus get_Bus();
}
public static class Rebus.Config.OneWayClientBackdoor : object {
    private static string OneWayDecoratorDescription;
    public static void ConfigureOneWayClient(StandardConfigurer`1<ITransport> configurer);
}
internal class Rebus.Config.OneWayClientBusDecorator : object {
    private AdvancedApiDecorator _advancedApiDecorator;
    private IBus _innerBus;
    public IAdvancedApi Advanced { get; }
    public OneWayClientBusDecorator(IBus innerBus, IRebusLoggerFactory rebusLoggerFactory);
    public sealed virtual Task SendLocal(object commandMessage, IDictionary`2<string, string> optionalHeaders);
    public sealed virtual Task Send(object commandMessage, IDictionary`2<string, string> optionalHeaders);
    public sealed virtual Task Reply(object replyMessage, IDictionary`2<string, string> optionalHeaders);
    public sealed virtual Task Defer(TimeSpan delay, object message, IDictionary`2<string, string> optionalHeaders);
    public sealed virtual Task DeferLocal(TimeSpan delay, object message, IDictionary`2<string, string> optionalHeaders);
    public sealed virtual IAdvancedApi get_Advanced();
    public sealed virtual Task Subscribe();
    public sealed virtual Task Subscribe(Type eventType);
    public sealed virtual Task Unsubscribe();
    public sealed virtual Task Unsubscribe(Type eventType);
    public sealed virtual Task Publish(object eventMessage, IDictionary`2<string, string> optionalHeaders);
    public sealed virtual void Dispose();
}
public class Rebus.Config.Options : object {
    public static int DefaultNumberOfWorkers;
    public static int DefaultMaxParallelism;
    public static int DefaultConflictResolutionAttempts;
    public static TimeSpan DefaultWorkerShutdownTimeout;
    public static TimeSpan DefaultDueTimeoutsPollInterval;
    public static TimeSpan DefaultTransportReceiveErrorCooldownTime;
    [CompilerGeneratedAttribute]
private int <NumberOfWorkers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConflictResolutionAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DueTimeoutsPollInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <WorkerShutdownTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TransportReceiveErrorCooldownTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExternalTimeoutManagerAddressOrNull>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultReturnAddressOrNull>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OptionalBusName>k__BackingField;
    public int NumberOfWorkers { get; public set; }
    public int MaxParallelism { get; public set; }
    public int MaxConflictResolutionAttempts { get; public set; }
    public TimeSpan DueTimeoutsPollInterval { get; public set; }
    public TimeSpan WorkerShutdownTimeout { get; public set; }
    public TimeSpan TransportReceiveErrorCooldownTime { get; public set; }
    public string ExternalTimeoutManagerAddressOrNull { get; public set; }
    public string DefaultReturnAddressOrNull { get; public set; }
    public string OptionalBusName { get; public set; }
    private static Options();
    [CompilerGeneratedAttribute]
public int get_NumberOfWorkers();
    [CompilerGeneratedAttribute]
public void set_NumberOfWorkers(int value);
    [CompilerGeneratedAttribute]
public int get_MaxParallelism();
    [CompilerGeneratedAttribute]
public void set_MaxParallelism(int value);
    [CompilerGeneratedAttribute]
public int get_MaxConflictResolutionAttempts();
    [CompilerGeneratedAttribute]
public void set_MaxConflictResolutionAttempts(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DueTimeoutsPollInterval();
    [CompilerGeneratedAttribute]
public void set_DueTimeoutsPollInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_WorkerShutdownTimeout();
    [CompilerGeneratedAttribute]
public void set_WorkerShutdownTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TransportReceiveErrorCooldownTime();
    [CompilerGeneratedAttribute]
public void set_TransportReceiveErrorCooldownTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_ExternalTimeoutManagerAddressOrNull();
    [CompilerGeneratedAttribute]
public void set_ExternalTimeoutManagerAddressOrNull(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultReturnAddressOrNull();
    [CompilerGeneratedAttribute]
public void set_DefaultReturnAddressOrNull(string value);
    [CompilerGeneratedAttribute]
public string get_OptionalBusName();
    [CompilerGeneratedAttribute]
public void set_OptionalBusName(string value);
}
public class Rebus.Config.OptionsConfigurer : object {
    private Options _options;
    private Injectionist _injectionist;
    internal OptionsConfigurer(Options options, Injectionist injectionist);
    internal StandardConfigurer`1<TService> GetConfigurer();
    public void SetNumberOfWorkers(int numberOfWorkers);
    public void SetBusName(string busName);
    public void Events(Action`1<BusLifetimeEvents> callback);
    public void SetMaxParallelism(int maxParallelism);
    public void SetWorkerShutdownTimeout(TimeSpan timeout);
    public void SetDueTimeoutsPollInteval(TimeSpan dueTimeoutsPollInterval);
    public void SetDefaultReturnAddress(string returnAddress);
    public void Register(Func`2<IResolutionContext, TService> resolverMethod, string description);
    public bool Has();
    public void Decorate(Func`2<IResolutionContext, TService> resolverMethod, string description);
    public void LogPipeline(bool verbose);
    private static string Format(IEnumerable`1<IStep> pipeline, bool verbose);
    private static string GetDocsOrNull(IStep step);
}
public class Rebus.Config.RebusConfigurer : object {
    private Injectionist _injectionist;
    private Options _options;
    private bool _hasBeenStarted;
    internal RebusConfigurer(IHandlerActivator handlerActivator);
    public RebusConfigurer Logging(Action`1<RebusLoggingConfigurer> configurer);
    public RebusConfigurer Transport(Action`1<StandardConfigurer`1<ITransport>> configurer);
    public RebusConfigurer Errors(Action`1<StandardConfigurer`1<IErrorTracker>> configurer);
    public RebusConfigurer DataBus(Action`1<StandardConfigurer`1<IDataBusStorage>> configurer);
    public RebusConfigurer Routing(Action`1<StandardConfigurer`1<IRouter>> configurer);
    public RebusConfigurer Sagas(Action`1<StandardConfigurer`1<ISagaStorage>> configurer);
    public RebusConfigurer Subscriptions(Action`1<StandardConfigurer`1<ISubscriptionStorage>> configurer);
    public RebusConfigurer Serialization(Action`1<StandardConfigurer`1<ISerializer>> configurer);
    public RebusConfigurer Timeouts(Action`1<StandardConfigurer`1<ITimeoutManager>> configurer);
    public RebusConfigurer Options(Action`1<OptionsConfigurer> configurer);
    public IBus Start();
    private void VerifyRequirements();
    private void PossiblyRegisterDefault(Func`2<IResolutionContext, TService> factoryMethod);
}
public class Rebus.Config.RebusLoggingConfigurer : object {
    private Injectionist _injectionist;
    internal RebusLoggingConfigurer(Injectionist injectionist);
    public void Console(LogLevel minLevel);
    public void ColoredConsole(LogLevel minLevel);
    public void Trace();
    public void None();
    public void Use(IRebusLoggerFactory rebusLoggerFactory);
    public void Register(Func`2<IResolutionContext, TService> factoryMethod, string description);
    public void Decorate(Func`2<IResolutionContext, TService> factoryMethod, string description);
}
public class Rebus.Config.StandardConfigurer`1 : object {
    private Injectionist _injectionist;
    private Options _options;
    internal Options Options { get; }
    internal StandardConfigurer`1(Injectionist injectionist, Options options);
    public static StandardConfigurer`1<TService> GetConfigurerFrom(OptionsConfigurer configurer);
    internal Options get_Options();
    public void Register(Func`2<IResolutionContext, TService> factoryMethod, string description);
    public void Decorate(Func`2<IResolutionContext, TService> factoryMethod, string description);
    public StandardConfigurer`1<TOther> OtherService();
}
[ExtensionAttribute]
public static class Rebus.DataBus.ClaimCheck.AutomaticClaimCheckConfigurationExtensions : object {
    [ExtensionAttribute]
public static void SendBigMessagesAsAttachments(StandardConfigurer`1<IDataBusStorage> configurer, int bodySizeThresholdBytes);
}
[StepDocumentationAttribute("Outgoing step that 'dehydrates' big messages by storing the payload as a data bus attachment.")]
public class Rebus.DataBus.ClaimCheck.DehydrateOutgoingMessageStep : object {
    private static Byte[] EmptyMessageBody;
    private int _messageSizeLimitBytes;
    private IDataBus _dataBus;
    public DehydrateOutgoingMessageStep(IDataBus dataBus, int messageSizeLimitBytes);
    private static DehydrateOutgoingMessageStep();
    [AsyncStateMachineAttribute("Rebus.DataBus.ClaimCheck.DehydrateOutgoingMessageStep/<Process>d__4")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.DataBus.ClaimCheck.DehydrateOutgoingMessageStep/<DehydrateTransportMessage>d__5")]
private Task DehydrateTransportMessage(OutgoingStepContext context, TransportMessage transportMessage);
}
[StepDocumentationAttribute("Incoming step that 'hydrates' big messages, if the payload was stored as a data bus attachment.")]
public class Rebus.DataBus.ClaimCheck.HydrateIncomingMessageStep : object {
    private IDataBus _dataBus;
    public HydrateIncomingMessageStep(IDataBus dataBus);
    [AsyncStateMachineAttribute("Rebus.DataBus.ClaimCheck.HydrateIncomingMessageStep/<Process>d__2")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
}
public class Rebus.DataBus.DataBusAttachment : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; protected set; }
    public DataBusAttachment(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
protected void set_Id(string value);
    [AsyncStateMachineAttribute("Rebus.DataBus.DataBusAttachment/<OpenRead>d__6")]
public Task`1<Stream> OpenRead();
    [AsyncStateMachineAttribute("Rebus.DataBus.DataBusAttachment/<GetMetadata>d__7")]
public Task`1<Dictionary`2<string, string>> GetMetadata();
    [AsyncStateMachineAttribute("Rebus.DataBus.DataBusAttachment/<OpenRead>d__8")]
public static Task`1<Stream> OpenRead(string id);
    [AsyncStateMachineAttribute("Rebus.DataBus.DataBusAttachment/<GetMetadata>d__9")]
public static Task`1<Dictionary`2<string, string>> GetMetadata(string id);
    private static IDataBusStorage GetDataBusStorage();
    private static IDataBusStorage GetDataBusStorageForTesting();
    private static IDataBusStorage GetDataBusStorageFromMessageContext();
}
internal class Rebus.DataBus.DataBusIncomingStep : object {
    public static string DataBusStorageKey;
    private IDataBusStorage _dataBusStorage;
    public DataBusIncomingStep(IDataBusStorage dataBusStorage);
    [AsyncStateMachineAttribute("Rebus.DataBus.DataBusIncomingStep/<Process>d__3")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
}
internal static class Rebus.DataBus.DataBusStorageQuery : object {
    public static bool IsSatisfied(Dictionary`2<string, string> metadata, TimeRange readTime, TimeRange saveTime);
}
internal class Rebus.DataBus.DefaultDataBus : object {
    private IDataBusStorage _dataBusStorage;
    private IDataBusStorageManagement _dataBusStorageManagement;
    public DefaultDataBus(IDataBusStorage dataBusStorage, IDataBusStorageManagement dataBusStorageManagement);
    [AsyncStateMachineAttribute("Rebus.DataBus.DefaultDataBus/<CreateAttachment>d__3")]
public sealed virtual Task`1<DataBusAttachment> CreateAttachment(Stream source, Dictionary`2<string, string> optionalMetadata);
    public sealed virtual Task`1<Stream> OpenRead(string dataBusAttachmentId);
    public sealed virtual Task`1<Dictionary`2<string, string>> GetMetadata(string dataBusAttachmentId);
    public sealed virtual Task Delete(string dataBusAttachmentId);
    public sealed virtual IEnumerable`1<string> Query(TimeRange readTime, TimeRange saveTime);
}
[ExtensionAttribute]
public static class Rebus.DataBus.FileSystem.FileSystemDataBusExtensions : object {
    [ExtensionAttribute]
public static void StoreInFileSystem(StandardConfigurer`1<IDataBusStorage> configurer, string directoryPath);
}
public class Rebus.DataBus.FileSystem.FileSystemDataBusStorage : object {
    private static string DataFileExtension;
    private static string MetadataFileExtension;
    private static string FilePrefix;
    private DictionarySerializer _dictionarySerializer;
    private string _directoryPath;
    private IRebusTime _rebusTime;
    private Retrier _retrier;
    private ILog _log;
    public FileSystemDataBusStorage(string directoryPath, IRebusLoggerFactory rebusLoggerFactory, IRebusTime rebusTime);
    public sealed virtual void Initialize();
    [AsyncStateMachineAttribute("Rebus.DataBus.FileSystem.FileSystemDataBusStorage/<Save>d__10")]
public sealed virtual Task Save(string id, Stream source, Dictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Rebus.DataBus.FileSystem.FileSystemDataBusStorage/<Read>d__11")]
public sealed virtual Task`1<Stream> Read(string id);
    [AsyncStateMachineAttribute("Rebus.DataBus.FileSystem.FileSystemDataBusStorage/<ReadMetadata>d__12")]
public sealed virtual Task`1<Dictionary`2<string, string>> ReadMetadata(string id);
    [AsyncStateMachineAttribute("Rebus.DataBus.FileSystem.FileSystemDataBusStorage/<Delete>d__13")]
public sealed virtual Task Delete(string id);
    private static void InnerDelete(string id, string filePath, string metadataFilePath);
    [IteratorStateMachineAttribute("Rebus.DataBus.FileSystem.FileSystemDataBusStorage/<Query>d__15")]
public sealed virtual IEnumerable`1<string> Query(TimeRange readTime, TimeRange saveTime);
    [AsyncStateMachineAttribute("Rebus.DataBus.FileSystem.FileSystemDataBusStorage/<UpdateLastReadTime>d__16")]
private Task UpdateLastReadTime(string id);
    private string GetFilePath(string id, string extension);
    private Dictionary`2<string, string> InnerReadMetadata(string id, string metadataFilePath, string filePath);
}
internal class Rebus.DataBus.FileSystem.Retrier : object {
    private ILog _log;
    public Retrier(IRebusLoggerFactory rebusLoggerFactory);
    public void Execute(Action action, Func`2<Exception, bool> handle, int attempts, int delaySeconds);
}
public interface Rebus.DataBus.IDataBus {
    public abstract virtual Task`1<DataBusAttachment> CreateAttachment(Stream source, Dictionary`2<string, string> optionalMetadata);
    public abstract virtual Task`1<Stream> OpenRead(string dataBusAttachmentId);
    public abstract virtual Task`1<Dictionary`2<string, string>> GetMetadata(string dataBusAttachmentId);
    public abstract virtual Task Delete(string dataBusAttachmentId);
    public abstract virtual IEnumerable`1<string> Query(TimeRange readTime, TimeRange saveTime);
}
public interface Rebus.DataBus.IDataBusStorage {
    public abstract virtual Task Save(string id, Stream source, Dictionary`2<string, string> metadata);
    public abstract virtual Task`1<Stream> Read(string id);
    public abstract virtual Task`1<Dictionary`2<string, string>> ReadMetadata(string id);
}
public interface Rebus.DataBus.IDataBusStorageManagement {
    public abstract virtual Task Delete(string id);
    public abstract virtual IEnumerable`1<string> Query(TimeRange readTime, TimeRange saveTime);
}
[ExtensionAttribute]
public static class Rebus.DataBus.InMem.InMemDataBusExtensions : object {
    [ExtensionAttribute]
public static void StoreInMemory(StandardConfigurer`1<IDataBusStorage> configurer, InMemDataStore inMemDataStore);
}
internal class Rebus.DataBus.InMem.InMemDataBusStorage : object {
    private InMemDataStore _dataStore;
    private IRebusTime _rebusTime;
    public InMemDataBusStorage(InMemDataStore dataStore, IRebusTime rebusTime);
    [AsyncStateMachineAttribute("Rebus.DataBus.InMem.InMemDataBusStorage/<Save>d__3")]
public sealed virtual Task Save(string id, Stream source, Dictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Rebus.DataBus.InMem.InMemDataBusStorage/<Read>d__4")]
public sealed virtual Task`1<Stream> Read(string id);
    [AsyncStateMachineAttribute("Rebus.DataBus.InMem.InMemDataBusStorage/<ReadMetadata>d__5")]
public sealed virtual Task`1<Dictionary`2<string, string>> ReadMetadata(string id);
    [AsyncStateMachineAttribute("Rebus.DataBus.InMem.InMemDataBusStorage/<Delete>d__6")]
public sealed virtual Task Delete(string id);
    public sealed virtual IEnumerable`1<string> Query(TimeRange readTime, TimeRange saveTime);
}
public class Rebus.DataBus.InMem.InMemDataStore : object {
    private ConcurrentDictionary`2<string, InMemBlob> _data;
    public long SizeBytes { get; }
    public IEnumerable`1<string> AttachmentIds { get; }
    public long get_SizeBytes();
    public IEnumerable`1<string> get_AttachmentIds();
    public void Save(string id, Byte[] bytes, Dictionary`2<string, string> metadata);
    public bool Contains(string id);
    public Byte[] Load(string id);
    public void AddMetadata(string id, Dictionary`2<string, string> metadata);
    public Dictionary`2<string, string> LoadMetadata(string id);
    public bool Delete(string id);
    public void Reset();
}
public static class Rebus.DataBus.MetadataKeys : object {
    public static string Length;
    public static string SaveTime;
    public static string ReadTime;
    public static string ContentEncoding;
    public static string ContentEncryption;
    public static string ContentInitializationVector;
    public static string ContentEncryptionKeyId;
}
public class Rebus.DataBus.TimeRange : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <From>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <To>k__BackingField;
    public Nullable`1<DateTimeOffset> From { get; }
    public Nullable`1<DateTimeOffset> To { get; }
    public TimeRange(Nullable`1<DateTimeOffset> from, Nullable`1<DateTimeOffset> to);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_From();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_To();
    public virtual string ToString();
}
internal class Rebus.Encryption.AesEncryptor : object {
    private IEncryptionKeyProvider _keyProvider;
    public string ContentEncryptionValue { get; }
    public AesEncryptor(string key);
    public AesEncryptor(IEncryptionKeyProvider keyProvider);
    public sealed virtual string get_ContentEncryptionValue();
    [AsyncStateMachineAttribute("Rebus.Encryption.AesEncryptor/<Encrypt>d__5")]
public sealed virtual Task`1<EncryptedData> Encrypt(Byte[] bytes);
    [AsyncStateMachineAttribute("Rebus.Encryption.AesEncryptor/<Decrypt>d__6")]
public sealed virtual Task`1<Byte[]> Decrypt(EncryptedData encryptedData);
}
[StepDocumentationAttribute("Decrypts the body of the incoming message if it has the 'rbs2-content-encryption' header")]
public class Rebus.Encryption.DecryptMessagesIncomingStep : object {
    private IAsyncEncryptor _encryptor;
    public DecryptMessagesIncomingStep(IAsyncEncryptor encryptor);
    [AsyncStateMachineAttribute("Rebus.Encryption.DecryptMessagesIncomingStep/<Process>d__2")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    private static Byte[] GetIv(IDictionary`2<string, string> headers);
}
internal class Rebus.Encryption.DefaultAsyncEncryptor : object {
    private IEncryptor _encryptor;
    public string ContentEncryptionValue { get; }
    public DefaultAsyncEncryptor(IEncryptor encryptor);
    public sealed virtual string get_ContentEncryptionValue();
    public sealed virtual Task`1<Byte[]> Decrypt(EncryptedData encryptedData);
    public sealed virtual Task`1<EncryptedData> Encrypt(Byte[] bytes);
}
public class Rebus.Encryption.EncryptedData : object {
    [CompilerGeneratedAttribute]
private Byte[] <Iv>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    public Byte[] Iv { get; }
    public Byte[] Bytes { get; }
    public string KeyId { get; }
    public EncryptedData(Byte[] bytes, Byte[] iv);
    public EncryptedData(Byte[] bytes, Byte[] iv, string keyId);
    [CompilerGeneratedAttribute]
public Byte[] get_Iv();
    [CompilerGeneratedAttribute]
public Byte[] get_Bytes();
    [CompilerGeneratedAttribute]
public string get_KeyId();
}
public class Rebus.Encryption.EncryptingDataBusStorageDecorator : object {
    private IDataBusStorage _dataBusStorage;
    private IAsyncEncryptor _asyncEncryptor;
    public EncryptingDataBusStorageDecorator(IDataBusStorage dataBusStorage, IAsyncEncryptor asyncEncryptor);
    [AsyncStateMachineAttribute("Rebus.Encryption.EncryptingDataBusStorageDecorator/<Save>d__3")]
public sealed virtual Task Save(string id, Stream source, Dictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Rebus.Encryption.EncryptingDataBusStorageDecorator/<Read>d__4")]
public sealed virtual Task`1<Stream> Read(string id);
    public sealed virtual Task`1<Dictionary`2<string, string>> ReadMetadata(string id);
}
[ExtensionAttribute]
public static class Rebus.Encryption.EncryptionConfigurationExtensions : object {
    [ExtensionAttribute]
public static void EnableEncryption(OptionsConfigurer configurer, string key);
    [ExtensionAttribute]
public static StandardConfigurer`1<IEncryptor> EnableCustomEncryption(OptionsConfigurer configurer);
    [ExtensionAttribute]
public static StandardConfigurer`1<IAsyncEncryptor> EnableCustomAsyncEncryption(OptionsConfigurer configurer);
    [ExtensionAttribute]
public static void EnableEncryption(StandardConfigurer`1<IDataBusStorage> configurer);
    [CompilerGeneratedAttribute]
internal static IAsyncEncryptor <EnableEncryption>g__GetAsyncEncryptor|3_1(<>c__DisplayClass3_0& );
}
public static class Rebus.Encryption.EncryptionHeaders : object {
    public static string ContentEncryption;
    public static string KeyId;
    public static string ContentInitializationVector;
    public static string DisableEncryptionHeader;
}
public class Rebus.Encryption.EncryptionKey : object {
    [CompilerGeneratedAttribute]
private Byte[] <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public Byte[] Key { get; }
    public string Identifier { get; }
    public EncryptionKey(Byte[] key, string identifier);
    [CompilerGeneratedAttribute]
public Byte[] get_Key();
    [CompilerGeneratedAttribute]
public string get_Identifier();
}
[StepDocumentationAttribute("Encrypts the body of the outgoing message, unless the special 'rbs2-disable-encryption' header has been added to the message")]
public class Rebus.Encryption.EncryptMessagesOutgoingStep : object {
    private IAsyncEncryptor _encryptor;
    public EncryptMessagesOutgoingStep(IAsyncEncryptor encryptor);
    [AsyncStateMachineAttribute("Rebus.Encryption.EncryptMessagesOutgoingStep/<Process>d__2")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
}
public class Rebus.Encryption.FixedAesEncryptionKeyProvider : object {
    private static string KeyIdentifier;
    private Task`1<EncryptionKey> _encryptionKey;
    public FixedAesEncryptionKeyProvider(string encryptionKey);
    public static string GenerateNewKey(int keySize);
    public sealed virtual Task`1<EncryptionKey> GetCurrentKey();
    public sealed virtual Task`1<EncryptionKey> GetSpecificKey(string identifier);
}
public class Rebus.Encryption.FixedRijndaelEncryptionKeyProvider : object {
    private static string KeyIdentifier;
    private Task`1<EncryptionKey> _encryptionKey;
    public FixedRijndaelEncryptionKeyProvider(string encryptionKey);
    public static string GenerateNewKey();
    public sealed virtual Task`1<EncryptionKey> GetCurrentKey();
    public sealed virtual Task`1<EncryptionKey> GetSpecificKey(string identifier);
}
public interface Rebus.Encryption.IAsyncEncryptor {
    public string ContentEncryptionValue { get; }
    public abstract virtual string get_ContentEncryptionValue();
    public abstract virtual Task`1<Byte[]> Decrypt(EncryptedData encryptedData);
    public abstract virtual Task`1<EncryptedData> Encrypt(Byte[] bytes);
}
public interface Rebus.Encryption.IEncryptionKeyProvider {
    public abstract virtual Task`1<EncryptionKey> GetCurrentKey();
    public abstract virtual Task`1<EncryptionKey> GetSpecificKey(string identifier);
}
public interface Rebus.Encryption.IEncryptor {
    public string ContentEncryptionValue { get; }
    public abstract virtual string get_ContentEncryptionValue();
    public abstract virtual Byte[] Decrypt(EncryptedData encryptedData);
    public abstract virtual EncryptedData Encrypt(Byte[] bytes);
}
internal class Rebus.Encryption.RijndaelEncryptor : object {
    private IEncryptionKeyProvider _keyProvider;
    public string ContentEncryptionValue { get; }
    public RijndaelEncryptor(string key);
    public RijndaelEncryptor(IEncryptionKeyProvider keyProvider);
    public sealed virtual string get_ContentEncryptionValue();
    [AsyncStateMachineAttribute("Rebus.Encryption.RijndaelEncryptor/<Encrypt>d__5")]
public sealed virtual Task`1<EncryptedData> Encrypt(Byte[] bytes);
    [AsyncStateMachineAttribute("Rebus.Encryption.RijndaelEncryptor/<Decrypt>d__6")]
public sealed virtual Task`1<Byte[]> Decrypt(EncryptedData encryptedData);
}
public class Rebus.Exceptions.ConcurrencyException : Exception {
    public ConcurrencyException(string message);
    public ConcurrencyException(Exception innerException, string message);
    public ConcurrencyException(SerializationInfo info, StreamingContext context);
}
public class Rebus.Exceptions.FailFastException : Exception {
    public FailFastException(string message);
    public FailFastException(Exception innerException, string message);
    public FailFastException(SerializationInfo info, StreamingContext context);
}
public interface Rebus.Exceptions.IFailFastException {
}
public class Rebus.Exceptions.MessageCouldNotBeDispatchedToAnyHandlersException : RebusApplicationException {
    public MessageCouldNotBeDispatchedToAnyHandlersException(string message);
    public MessageCouldNotBeDispatchedToAnyHandlersException(SerializationInfo info, StreamingContext context);
}
public class Rebus.Exceptions.RebusApplicationException : Exception {
    public RebusApplicationException(string message);
    public RebusApplicationException(Exception innerException, string message);
    public RebusApplicationException(SerializationInfo info, StreamingContext context);
}
public class Rebus.Exceptions.RebusConfigurationException : Exception {
    public RebusConfigurationException(string message);
    public RebusConfigurationException(Exception innerException, string message);
    public RebusConfigurationException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class Rebus.Exceptions.TransportMessageApiExtensions : object {
    [AsyncStateMachineAttribute("Rebus.Exceptions.TransportMessageApiExtensions/<Deadletter>d__0")]
[ExtensionAttribute]
public static Task Deadletter(ITransportMessageApi transportMessageApi, string errorDetails, bool throwIfAlreadyDeadlettered);
    [AsyncStateMachineAttribute("Rebus.Exceptions.TransportMessageApiExtensions/<Deadletter>d__1")]
[ExtensionAttribute]
public static Task Deadletter(ITransportMessageApi transportMessageApi, Exception exception, bool throwIfAlreadyDeadlettered);
    private static void InnerDeadletter(Exception exception, bool throwIfAlreadyDeadlettered);
}
internal class Rebus.ExclusiveLocks.ConcurrentDictionaryExclusiveAccessLock : object {
    private static Task`1<bool> TrueResult;
    private static Task`1<bool> FalseResult;
    private ConcurrentDictionary`2<string, byte> _locks;
    private static ConcurrentDictionaryExclusiveAccessLock();
    public sealed virtual Task`1<bool> AcquireLockAsync(string key, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> IsLockAcquiredAsync(string key, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> ReleaseLockAsync(string key);
}
public interface Rebus.ExclusiveLocks.IExclusiveAccessLock {
    public abstract virtual Task`1<bool> AcquireLockAsync(string key, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsLockAcquiredAsync(string key, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> ReleaseLockAsync(string key);
}
[ExtensionAttribute]
internal static class Rebus.Extensions.ConcurrentQueueExtensions : object {
    [ExtensionAttribute]
public static void Clear(ConcurrentQueue`1<T> queue);
}
[ExtensionAttribute]
public static class Rebus.Extensions.DateTimeExtensions : object {
    [ExtensionAttribute]
public static TimeSpan ElapsedUntilNow(DateTimeOffset dateTime, IRebusTime rebusTime);
    [ExtensionAttribute]
public static string ToIso8601DateTimeOffset(DateTimeOffset dateTimeOffset);
    [ExtensionAttribute]
public static DateTimeOffset ToDateTimeOffset(string iso8601String);
}
[ExtensionAttribute]
public static class Rebus.Extensions.DictionaryExtensions : object {
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> MergedWith(IDictionary`2<TKey, TValue> dictionary, IDictionary`2<TKey, TValue> otherDictionary);
    [ExtensionAttribute]
public static Dictionary`2<string, string> Clone(Dictionary`2<string, string> dictionary);
    [ExtensionAttribute]
public static string GetValue(Dictionary`2<string, string> dictionary, string key);
    [ExtensionAttribute]
public static string GetValueOrNull(Dictionary`2<string, string> dictionary, string key);
    [ExtensionAttribute]
public static TItem GetOrAdd(Dictionary`2<string, TBase> dictionary, string key, Func`1<TItem> newItemFactory);
    [AsyncStateMachineAttribute("Rebus.Extensions.DictionaryExtensions/<GetOrAddAsync>d__5`2")]
[ExtensionAttribute]
public static Task`1<TItem> GetOrAddAsync(Dictionary`2<string, TBase> dictionary, string key, Func`1<Task`1<TItem>> newItemFactory);
    [ExtensionAttribute]
public static ConcurrentDictionary`2<TKey, TValue> ToConcurrentDictionary(IEnumerable`1<TValue> items, Func`2<TValue, TKey> keyFunction);
    [ExtensionAttribute]
public static T GetOrThrow(IDictionary`2<string, object> dictionary, string key);
    [ExtensionAttribute]
public static T GetOrNull(Dictionary`2<string, object> dictionary, string key);
}
[ExtensionAttribute]
public static class Rebus.Extensions.MessageContextExtensions : object {
    [ExtensionAttribute]
public static CancellationToken GetCancellationToken(IMessageContext context);
}
[ExtensionAttribute]
internal static class Rebus.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static string Truncate(string text, int maxLength, string placeholder);
    [ExtensionAttribute]
public static string WrappedAt(string str, int width);
    private static string WrapSection(string section, int width);
    [ExtensionAttribute]
public static string Indented(string str, int indent);
}
[ExtensionAttribute]
public static class Rebus.Extensions.TypeExtensions : object {
    private static ConcurrentDictionary`2<Type, string> SimpleAssemblyQualifiedTypeNameCache;
    private static TypeExtensions();
    [IteratorStateMachineAttribute("Rebus.Extensions.TypeExtensions/<GetBaseTypes>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetBaseTypes(Type type);
    [ExtensionAttribute]
public static string GetSimpleAssemblyQualifiedName(Type type);
}
public interface Rebus.Handlers.IHandleMessages {
}
public interface Rebus.Handlers.IHandleMessages`1 {
    public abstract virtual Task Handle(TMessage message);
}
internal class Rebus.Handlers.InternalHandlersContributor : object {
    private IHandlerActivator _innerHandlerActivator;
    private Dictionary`2<Type, IHandleMessages[]> _internalHandlers;
    public InternalHandlersContributor(IHandlerActivator innerHandlerActivator, ISubscriptionStorage subscriptionStorage);
    [AsyncStateMachineAttribute("Rebus.Handlers.InternalHandlersContributor/<GetHandlers>d__3`1")]
public sealed virtual Task`1<IEnumerable`1<IHandleMessages`1<TMessage>>> GetHandlers(TMessage message, ITransactionContext transactionContext);
    private IEnumerable`1<IHandleMessages`1<TMessage>> GetOwnHandlersFor();
}
public class Rebus.Handlers.Reordering.AdditionalReorderingConfiguration : object {
    private ReorderingConfiguration _reorderingConfiguration;
    internal AdditionalReorderingConfiguration(ReorderingConfiguration reorderingConfiguration);
    public AdditionalReorderingConfiguration Then();
}
[ExtensionAttribute]
public static class Rebus.Handlers.Reordering.HandlerReorderingConfigurationExtensions : object {
    [ExtensionAttribute]
public static ReorderingConfiguration SpecifyOrderOfHandlers(OptionsConfigurer configurer);
}
public class Rebus.Handlers.Reordering.HandlerReorderingStep : object {
    private ReorderingConfiguration _configuration;
    public HandlerReorderingStep(ReorderingConfiguration configuration);
    [AsyncStateMachineAttribute("Rebus.Handlers.Reordering.HandlerReorderingStep/<Process>d__2")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    [CompilerGeneratedAttribute]
private int <Process>b__2_0(HandlerInvoker i);
}
public class Rebus.Handlers.Reordering.ReorderingConfiguration : object {
    private Dictionary`2<Type, int> _orderedHandlerTypes;
    private int _index;
    public AdditionalReorderingConfiguration First();
    internal void Add();
    public int GetIndex(object handler);
}
public class Rebus.Injection.Injectionist : object {
    private Dictionary`2<Type, Handler> _resolvers;
    [CompilerGeneratedAttribute]
private Action`1<Type> ResolveRequested;
    public ResolutionResult`1<TService> Get();
    [CompilerGeneratedAttribute]
public void add_ResolveRequested(Action`1<Type> value);
    [CompilerGeneratedAttribute]
public void remove_ResolveRequested(Action`1<Type> value);
    public void Register(Func`2<IResolutionContext, TService> resolverMethod, string description);
    public void Decorate(Func`2<IResolutionContext, TService> resolverMethod, string description);
    public bool Has(bool primary);
    private static bool ResolverHaveRegistrationFor(bool primary, Dictionary`2<Type, Handler> resolvers);
    private void Register(Func`2<IResolutionContext, TService> resolverMethod, bool isDecorator, string description);
    private Handler GetOrCreateHandler();
}
public interface Rebus.Injection.IResolutionContext {
    public IEnumerable TrackedInstances { get; }
    public abstract virtual TService Get();
    public abstract virtual IEnumerable get_TrackedInstances();
    public abstract virtual bool Has(bool primary);
}
public class Rebus.Injection.ResolutionException : Exception {
    public ResolutionException(string message);
    public ResolutionException(Exception innerException, string message);
    public ResolutionException(SerializationInfo info, StreamingContext context);
}
public class Rebus.Injection.ResolutionResult`1 : object {
    [CompilerGeneratedAttribute]
private TService <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable <TrackedInstances>k__BackingField;
    public TService Instance { get; }
    public IEnumerable TrackedInstances { get; }
    internal ResolutionResult`1(TService instance, IEnumerable trackedInstances);
    [CompilerGeneratedAttribute]
public TService get_Instance();
    [CompilerGeneratedAttribute]
public IEnumerable get_TrackedInstances();
}
internal static class Rebus.Internals.Shims : object {
    public static string GetSimpleAssemblyQualifiedName(Type type);
    private static StringBuilder BuildSimpleAssemblyQualifiedName(Type type, StringBuilder sb);
}
public abstract class Rebus.Logging.AbstractRebusLoggerFactory : object {
    private static Regex PlaceholderRegex;
    private static AbstractRebusLoggerFactory();
    protected abstract virtual ILog GetLogger(Type type);
    public sealed virtual ILog GetLogger();
    protected string RenderString(string message, Object[] objs);
    protected virtual string FormatObject(object obj, string format);
}
public class Rebus.Logging.ColorSetting : object {
    [CompilerGeneratedAttribute]
private ConsoleColor <ForegroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsoleColor> <BackgroundColor>k__BackingField;
    public ConsoleColor ForegroundColor { get; }
    public Nullable`1<ConsoleColor> BackgroundColor { get; }
    private ColorSetting(ConsoleColor foregroundColor, Nullable`1<ConsoleColor> backgroundColor);
    [CompilerGeneratedAttribute]
public ConsoleColor get_ForegroundColor();
    [CompilerGeneratedAttribute]
public Nullable`1<ConsoleColor> get_BackgroundColor();
    public static ColorSetting Foreground(ConsoleColor foregroundColor);
    public ColorSetting Background(ConsoleColor backgroundColor);
    public void Apply();
    public void Revert();
}
public class Rebus.Logging.ConsoleLoggerFactory : AbstractRebusLoggerFactory {
    private static ConcurrentDictionary`2<Type, ILog> Loggers;
    private bool _colored;
    private List`1<Func`2<LogStatement, bool>> _filters;
    private LoggingColors _colors;
    private LogLevel _minLevel;
    private bool _showTimestamps;
    public LoggingColors Colors { get; public set; }
    public LogLevel MinLevel { get; public set; }
    public IList`1<Func`2<LogStatement, bool>> Filters { get; }
    public bool ShowTimestamps { get; public set; }
    public ConsoleLoggerFactory(bool colored);
    private static ConsoleLoggerFactory();
    public LoggingColors get_Colors();
    public void set_Colors(LoggingColors value);
    public LogLevel get_MinLevel();
    public void set_MinLevel(LogLevel value);
    public IList`1<Func`2<LogStatement, bool>> get_Filters();
    public bool get_ShowTimestamps();
    public void set_ShowTimestamps(bool value);
    protected virtual ILog GetLogger(Type type);
    private bool AbortedByFilter(LogLevel level, string text, Object[] args, Type type);
}
public interface Rebus.Logging.ILog {
    public abstract virtual void Debug(string message, Object[] objs);
    public abstract virtual void Info(string message, Object[] objs);
    public abstract virtual void Warn(string message, Object[] objs);
    public abstract virtual void Warn(Exception exception, string message, Object[] objs);
    public abstract virtual void Error(string message, Object[] objs);
    public abstract virtual void Error(Exception exception, string message, Object[] objs);
}
public interface Rebus.Logging.IRebusLoggerFactory {
    public abstract virtual ILog GetLogger();
}
public class Rebus.Logging.LoggingColors : object {
    [CompilerGeneratedAttribute]
private ColorSetting <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorSetting <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorSetting <Warn>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorSetting <Error>k__BackingField;
    public ColorSetting Debug { get; public set; }
    public ColorSetting Info { get; public set; }
    public ColorSetting Warn { get; public set; }
    public ColorSetting Error { get; public set; }
    [CompilerGeneratedAttribute]
public ColorSetting get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(ColorSetting value);
    [CompilerGeneratedAttribute]
public ColorSetting get_Info();
    [CompilerGeneratedAttribute]
public void set_Info(ColorSetting value);
    [CompilerGeneratedAttribute]
public ColorSetting get_Warn();
    [CompilerGeneratedAttribute]
public void set_Warn(ColorSetting value);
    [CompilerGeneratedAttribute]
public ColorSetting get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(ColorSetting value);
}
public enum Rebus.Logging.LogLevel : Enum {
    public int value__;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warn;
    public static LogLevel Error;
}
public class Rebus.Logging.NullLoggerFactory : AbstractRebusLoggerFactory {
    private static NullLogger Logger;
    private static NullLoggerFactory();
    protected virtual ILog GetLogger(Type type);
}
public class Rebus.Logging.TraceLoggerFactory : AbstractRebusLoggerFactory {
    protected virtual ILog GetLogger(Type type);
}
public class Rebus.Messages.Control.SubscribeRequest : object {
    [CompilerGeneratedAttribute]
private string <SubscriberAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    public string SubscriberAddress { get; public set; }
    public string Topic { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SubscriberAddress();
    [CompilerGeneratedAttribute]
public void set_SubscriberAddress(string value);
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
}
public class Rebus.Messages.Control.UnsubscribeRequest : object {
    [CompilerGeneratedAttribute]
private string <SubscriberAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Topic>k__BackingField;
    public string SubscriberAddress { get; public set; }
    public string Topic { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SubscriberAddress();
    [CompilerGeneratedAttribute]
public void set_SubscriberAddress(string value);
    [CompilerGeneratedAttribute]
public string get_Topic();
    [CompilerGeneratedAttribute]
public void set_Topic(string value);
}
[AttributeUsageAttribute("4")]
public class Rebus.Messages.HeaderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    public string Value { get; }
    public HeaderAttribute(string key, string value);
    public HeaderAttribute(string key);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
}
public static class Rebus.Messages.Headers : object {
    public static string MessageId;
    public static string Type;
    public static string CorrelationId;
    public static string InReplyTo;
    public static string CorrelationSequence;
    public static string ReturnAddress;
    public static string SenderAddress;
    public static string RoutingSlipItinerary;
    public static string RoutingSlipTravelogue;
    public static string ContentType;
    public static string ContentEncoding;
    public static string ErrorDetails;
    public static string SourceQueue;
    public static string DeferredUntil;
    public static string DeferredRecipient;
    public static string DeferCount;
    public static string TimeToBeReceived;
    public static string Express;
    public static string SentTime;
    public static string Intent;
    public static string MessagePayloadAttachmentId;
    public static string DeliveryCount;
}
public class Rebus.Messages.Message : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Body>k__BackingField;
    public Dictionary`2<string, string> Headers { get; private set; }
    public object Body { get; private set; }
    public Message(Dictionary`2<string, string> headers, object body);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public object get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(object value);
}
public class Rebus.Messages.OriginalTransportMessage : object {
    [CompilerGeneratedAttribute]
private TransportMessage <TransportMessage>k__BackingField;
    public TransportMessage TransportMessage { get; }
    public OriginalTransportMessage(TransportMessage transportMessage);
    [CompilerGeneratedAttribute]
public TransportMessage get_TransportMessage();
}
public class Rebus.Messages.TransportMessage : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Body>k__BackingField;
    public Dictionary`2<string, string> Headers { get; }
    public Byte[] Body { get; }
    public TransportMessage(Dictionary`2<string, string> headers, Byte[] body);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public Byte[] get_Body();
}
internal class Rebus.Persistence.FileSystem.FileSystemExclusiveLock : object {
    private FileStream _fileStream;
    private bool _disposed;
    public FileSystemExclusiveLock(string pathToLock, ILog log);
    private static void EnsureTargetFile(string pathToLock, ILog log);
    public sealed virtual void Dispose();
}
internal static class Rebus.Persistence.FileSystem.FileSystemHelpers : object {
    public static void EnsureDirectoryIsWritable(string directoryPath);
}
internal class Rebus.Persistence.FileSystem.FileSystemSagaIndex : object {
    private string _basePath;
    private JsonSerializerSettings _serializerSettings;
    private string IndexPath { get; }
    public FileSystemSagaIndex(string basePath);
    private string get_IndexPath();
    public ISagaData FindById(Guid id);
    public ISagaData Find(Type sagaDataType, string propertyName, object propertyValue);
    public void Insert(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    public bool Contains(Guid id);
    public void Remove(Guid sagaDataId);
    private List`1<SagaIndexItem> ReadIndexItems();
    private void WriteSagaIndexItems(List`1<SagaIndexItem> indexItems);
    private string SagaFilePath(Guid id);
    private static IEnumerable`1<SagaIndexItem> GetPropertiesToIndex(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    private static object Value(object obj, string path);
}
public class Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage : object {
    private string _snapshotDirectory;
    private ILog _log;
    public FileSystemSagaSnapshotStorage(string snapshotDirectory, IRebusLoggerFactory rebusLoggerFactory);
    public sealed virtual void Initialize();
    [AsyncStateMachineAttribute("Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorage/<Save>d__4")]
public sealed virtual Task Save(ISagaData sagaData, Dictionary`2<string, string> sagaAuditMetadata);
}
[ExtensionAttribute]
public static class Rebus.Persistence.FileSystem.FileSystemSagaSnapshotStorageConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseJsonFile(StandardConfigurer`1<ISagaSnapshotStorage> configurer, string directory);
}
public class Rebus.Persistence.FileSystem.FileSystemSagaStorage : object {
    private static string IdPropertyName;
    private string _basePath;
    private string _lockFile;
    private ILog _log;
    public FileSystemSagaStorage(string basePath, IRebusLoggerFactory rebusLoggerFactory);
    [AsyncStateMachineAttribute("Rebus.Persistence.FileSystem.FileSystemSagaStorage/<Find>d__5")]
public sealed virtual Task`1<ISagaData> Find(Type sagaDataType, string propertyName, object propertyValue);
    [AsyncStateMachineAttribute("Rebus.Persistence.FileSystem.FileSystemSagaStorage/<Insert>d__6")]
public sealed virtual Task Insert(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    [AsyncStateMachineAttribute("Rebus.Persistence.FileSystem.FileSystemSagaStorage/<Update>d__7")]
public sealed virtual Task Update(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    [AsyncStateMachineAttribute("Rebus.Persistence.FileSystem.FileSystemSagaStorage/<Delete>d__8")]
public sealed virtual Task Delete(ISagaData sagaData);
    private static Guid GetId(ISagaData sagaData);
    [CompilerGeneratedAttribute]
internal static Guid <Find>g__GetGuidValue|5_0(object value);
}
[ExtensionAttribute]
public static class Rebus.Persistence.FileSystem.FileSystemSagaStorageConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseFilesystem(StandardConfigurer`1<ISagaStorage> configurer, string basePath);
}
public class Rebus.Persistence.FileSystem.FileSystemTimeoutManager : object {
    private static string TickFormat;
    private string _basePath;
    private IRebusTime _rebusTime;
    private string _lockFile;
    private ILog _log;
    private static FileSystemTimeoutManager();
    public FileSystemTimeoutManager(string basePath, IRebusLoggerFactory rebusLoggerFactory, IRebusTime rebusTime);
    [AsyncStateMachineAttribute("Rebus.Persistence.FileSystem.FileSystemTimeoutManager/<Defer>d__7")]
public sealed virtual Task Defer(DateTimeOffset approximateDueTime, Dictionary`2<string, string> headers, Byte[] body);
    [AsyncStateMachineAttribute("Rebus.Persistence.FileSystem.FileSystemTimeoutManager/<GetDueMessages>d__8")]
public sealed virtual Task`1<DueMessagesResult> GetDueMessages();
}
[ExtensionAttribute]
public static class Rebus.Persistence.FileSystem.FileSystemTimeoutStorageConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseFileSystem(StandardConfigurer`1<ITimeoutManager> configurer, string basePath);
}
public class Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage : object {
    private static Encoding FileEncoding;
    private ReaderWriterLockSlim _readerWriterLockSlim;
    private string _jsonFilePath;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private bool <IsCentralized>k__BackingField;
    public bool IsCentralized { get; }
    public JsonFileSubscriptionStorage(string jsonFilePath, bool isCentralized);
    private static JsonFileSubscriptionStorage();
    [AsyncStateMachineAttribute("Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage/<GetSubscriberAddresses>d__5")]
public sealed virtual Task`1<IReadOnlyList`1<string>> GetSubscriberAddresses(string topic);
    [AsyncStateMachineAttribute("Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage/<RegisterSubscriber>d__6")]
public sealed virtual Task RegisterSubscriber(string topic, string subscriberAddress);
    [AsyncStateMachineAttribute("Rebus.Persistence.FileSystem.JsonFileSubscriptionStorage/<UnregisterSubscriber>d__7")]
public sealed virtual Task UnregisterSubscriber(string topic, string subscriberAddress);
    private void SaveSubscriptions(Dictionary`2<string, HashSet`1<string>> subscriptions);
    private Dictionary`2<string, HashSet`1<string>> GetSubscriptions();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCentralized();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Rebus.Persistence.FileSystem.JsonFileSubscriptionStorageConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseJsonFile(StandardConfigurer`1<ISubscriptionStorage> configurer, string jsonFilePath);
}
[ExtensionAttribute]
internal static class Rebus.Persistence.FileSystem.ReaderWriterLockSlimExtensions : object {
    [ExtensionAttribute]
public static IDisposable ReadLock(ReaderWriterLockSlim readerWriterLockSlim);
    [ExtensionAttribute]
public static IDisposable WriteLock(ReaderWriterLockSlim readerWriterLockSlim);
}
public class Rebus.Persistence.InMem.InMemorySagaStorage : object {
    private ConcurrentDictionary`2<Guid, ISagaData> _data;
    private object _lock;
    private JsonSerializerSettings _serializerSettings;
    [CompilerGeneratedAttribute]
private Action`1<ISagaData> Created;
    [CompilerGeneratedAttribute]
private Action`1<ISagaData> Updated;
    [CompilerGeneratedAttribute]
private Action`1<ISagaData> Deleted;
    [CompilerGeneratedAttribute]
private Action`1<ISagaData> Correlated;
    [CompilerGeneratedAttribute]
private Action CouldNotCorrelate;
    public IEnumerable`1<ISagaData> Instances { get; }
    public IEnumerable`1<ISagaData> get_Instances();
    internal void AddInstance(ISagaData sagaData);
    [CompilerGeneratedAttribute]
internal void add_Created(Action`1<ISagaData> value);
    [CompilerGeneratedAttribute]
internal void remove_Created(Action`1<ISagaData> value);
    [CompilerGeneratedAttribute]
internal void add_Updated(Action`1<ISagaData> value);
    [CompilerGeneratedAttribute]
internal void remove_Updated(Action`1<ISagaData> value);
    [CompilerGeneratedAttribute]
internal void add_Deleted(Action`1<ISagaData> value);
    [CompilerGeneratedAttribute]
internal void remove_Deleted(Action`1<ISagaData> value);
    [CompilerGeneratedAttribute]
internal void add_Correlated(Action`1<ISagaData> value);
    [CompilerGeneratedAttribute]
internal void remove_Correlated(Action`1<ISagaData> value);
    [CompilerGeneratedAttribute]
internal void add_CouldNotCorrelate(Action value);
    [CompilerGeneratedAttribute]
internal void remove_CouldNotCorrelate(Action value);
    [AsyncStateMachineAttribute("Rebus.Persistence.InMem.InMemorySagaStorage/<Find>d__21")]
public sealed virtual Task`1<ISagaData> Find(Type sagaDataType, string propertyName, object propertyValue);
    [AsyncStateMachineAttribute("Rebus.Persistence.InMem.InMemorySagaStorage/<Insert>d__22")]
public sealed virtual Task Insert(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    [AsyncStateMachineAttribute("Rebus.Persistence.InMem.InMemorySagaStorage/<Update>d__23")]
public sealed virtual Task Update(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    private void VerifyCorrelationPropertyUniqueness(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    [AsyncStateMachineAttribute("Rebus.Persistence.InMem.InMemorySagaStorage/<Delete>d__25")]
public sealed virtual Task Delete(ISagaData sagaData);
    public void Reset();
    private static Guid GetId(ISagaData sagaData);
    private ISagaData Clone(ISagaData sagaData);
}
[ExtensionAttribute]
public static class Rebus.Persistence.InMem.InMemorySagaStorageExtensions : object {
    [ExtensionAttribute]
public static void StoreInMemory(StandardConfigurer`1<ISagaStorage> configurer);
}
public class Rebus.Persistence.InMem.InMemorySubscriberStore : object {
    private static StringComparer StringComparer;
    private static String[] NoSubscribers;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, object>> _subscribers;
    public IEnumerable`1<string> Topics { get; }
    private static InMemorySubscriberStore();
    public IEnumerable`1<string> get_Topics();
    public String[] GetSubscribers(string topic);
    public void AddSubscriber(string topic, string subscriberAddress);
    public void RemoveSubscriber(string topic, string subscriberAddress);
    public void Reset();
}
public class Rebus.Persistence.InMem.InMemorySubscriptionStorage : object {
    private InMemorySubscriberStore _subscriberStore;
    [CompilerGeneratedAttribute]
private bool <IsCentralized>k__BackingField;
    public bool IsCentralized { get; }
    private InMemorySubscriptionStorage(InMemorySubscriberStore subscriberStore, bool isCentralized);
    public InMemorySubscriptionStorage(InMemorySubscriberStore subscriberStore);
    [AsyncStateMachineAttribute("Rebus.Persistence.InMem.InMemorySubscriptionStorage/<GetSubscriberAddresses>d__4")]
public sealed virtual Task`1<IReadOnlyList`1<string>> GetSubscriberAddresses(string topic);
    [AsyncStateMachineAttribute("Rebus.Persistence.InMem.InMemorySubscriptionStorage/<RegisterSubscriber>d__5")]
public sealed virtual Task RegisterSubscriber(string topic, string subscriberAddress);
    [AsyncStateMachineAttribute("Rebus.Persistence.InMem.InMemorySubscriptionStorage/<UnregisterSubscriber>d__6")]
public sealed virtual Task UnregisterSubscriber(string topic, string subscriberAddress);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCentralized();
}
[ExtensionAttribute]
public static class Rebus.Persistence.InMem.InMemorySubscriptionStorageExtensions : object {
    [ExtensionAttribute]
public static void StoreInMemory(StandardConfigurer`1<ISubscriptionStorage> configurer, InMemorySubscriberStore subscriberStore);
    [ExtensionAttribute]
public static void StoreInMemory(StandardConfigurer`1<ISubscriptionStorage> configurer);
}
public class Rebus.Persistence.InMem.InMemoryTimeoutManager : object {
    private ConcurrentDictionary`2<string, DeferredMessage> _deferredMessages;
    private IRebusTime _rebusTime;
    public InMemoryTimeoutManager(IRebusTime rebusTime);
    [AsyncStateMachineAttribute("Rebus.Persistence.InMem.InMemoryTimeoutManager/<Defer>d__3")]
public sealed virtual Task Defer(DateTimeOffset approximateDueTime, Dictionary`2<string, string> headers, Byte[] body);
    [AsyncStateMachineAttribute("Rebus.Persistence.InMem.InMemoryTimeoutManager/<GetDueMessages>d__4")]
public sealed virtual Task`1<DueMessagesResult> GetDueMessages();
    public sealed virtual IEnumerator`1<DeferredMessage> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private bool <GetDueMessages>b__4_0(KeyValuePair`2<string, DeferredMessage> v);
}
[ExtensionAttribute]
public static class Rebus.Persistence.InMem.InMemoryTimeoutManagerExtensions : object {
    [ExtensionAttribute]
public static void StoreInMemory(StandardConfigurer`1<ITimeoutManager> configurer);
}
internal class Rebus.Persistence.Throwing.DisabledDataBus : object {
    public sealed virtual Task`1<DataBusAttachment> CreateAttachment(Stream source, Dictionary`2<string, string> optionalMetadata);
    public sealed virtual Task`1<Stream> OpenRead(string dataBusAttachmentId);
    public sealed virtual Task`1<Dictionary`2<string, string>> GetMetadata(string dataBusAttachmentId);
    public sealed virtual Task Delete(string dataBusAttachmentId);
    public sealed virtual IEnumerable`1<string> Query(TimeRange readTime, TimeRange saveTime);
    private static InvalidOperationException GetException();
}
internal class Rebus.Persistence.Throwing.DisabledDataBusStorageManagement : object {
    public sealed virtual Task Delete(string id);
    public sealed virtual IEnumerable`1<string> Query(TimeRange readTime, TimeRange saveTime);
    private static NotSupportedException GetException();
}
internal class Rebus.Persistence.Throwing.DisabledSagaStorage : object {
    public sealed virtual Task`1<ISagaData> Find(Type sagaDataType, string propertyName, object propertyValue);
    public sealed virtual Task Insert(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    public sealed virtual Task Update(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    public sealed virtual Task Delete(ISagaData sagaData);
    private static InvalidOperationException GetException();
}
internal class Rebus.Persistence.Throwing.DisabledSubscriptionStorage : object {
    public bool IsCentralized { get; }
    public sealed virtual Task`1<IReadOnlyList`1<string>> GetSubscriberAddresses(string topic);
    public sealed virtual Task RegisterSubscriber(string topic, string subscriberAddress);
    public sealed virtual Task UnregisterSubscriber(string topic, string subscriberAddress);
    public sealed virtual bool get_IsCentralized();
    private static InvalidOperationException GetException();
}
internal class Rebus.Persistence.Throwing.DisabledTimeoutManager : object {
    public sealed virtual Task Defer(DateTimeOffset approximateDueTime, Dictionary`2<string, string> headers, Byte[] body);
    public sealed virtual Task`1<DueMessagesResult> GetDueMessages();
    private static InvalidOperationException GetException();
}
public class Rebus.Pipeline.DefaultPipeline : object {
    private List`1<IOutgoingStep> _sendSteps;
    private List`1<IIncomingStep> _receiveSteps;
    public DefaultPipeline(IEnumerable`1<IOutgoingStep> initialOutgoingSteps, IEnumerable`1<IIncomingStep> initialIncomingSteps);
    public sealed virtual IOutgoingStep[] SendPipeline();
    public sealed virtual IIncomingStep[] ReceivePipeline();
    public DefaultPipeline OnReceive(IIncomingStep step);
    public DefaultPipeline OnSend(IOutgoingStep step);
}
public interface Rebus.Pipeline.IIncomingStep {
    public abstract virtual Task Process(IncomingStepContext context, Func`1<Task> next);
}
public interface Rebus.Pipeline.IMessageContext {
    public ITransactionContext TransactionContext { get; }
    public IncomingStepContext IncomingStepContext { get; }
    public TransportMessage TransportMessage { get; }
    public Message Message { get; }
    public Dictionary`2<string, string> Headers { get; }
    public abstract virtual ITransactionContext get_TransactionContext();
    public abstract virtual IncomingStepContext get_IncomingStepContext();
    public abstract virtual TransportMessage get_TransportMessage();
    public abstract virtual Message get_Message();
    public abstract virtual Dictionary`2<string, string> get_Headers();
}
public class Rebus.Pipeline.IncomingStepContext : StepContext {
    public IncomingStepContext(TransportMessage message, ITransactionContext transactionContext);
}
internal class Rebus.Pipeline.Invokers.ActionPipelineInvoker : object {
    private Func`2<IncomingStepContext, Task> _invokeReceivePipeline;
    private Func`2<OutgoingStepContext, Task> _invokeSendPipeline;
    public ActionPipelineInvoker(IPipeline pipeline);
    public sealed virtual Task Invoke(IncomingStepContext context);
    public sealed virtual Task Invoke(OutgoingStepContext context);
    private static Func`2<IncomingStepContext, Task> GenerateReceiveFunction(Span`1<IIncomingStep> steps);
    private static Func`2<OutgoingStepContext, Task> GenerateSendFunction(Span`1<IOutgoingStep> steps);
    [CompilerGeneratedAttribute]
internal static Task <GenerateReceiveFunction>g__CompletedFunction|5_0(IncomingStepContext context);
    [CompilerGeneratedAttribute]
internal static Task <GenerateSendFunction>g__CompletedFunction|6_0(OutgoingStepContext context);
}
internal class Rebus.Pipeline.Invokers.DefaultPipelineInvoker : object {
    private static Task`1<int> Noop;
    private static Func`1<Task> TerminationStep;
    private Func`2<IncomingStepContext, Task> _processIncoming;
    private Func`2<OutgoingStepContext, Task> _processOutgoing;
    public DefaultPipelineInvoker(IPipeline pipeline);
    private static DefaultPipelineInvoker();
    public sealed virtual Task Invoke(IncomingStepContext context);
    public sealed virtual Task Invoke(OutgoingStepContext context);
}
internal class Rebus.Pipeline.Invokers.DefaultPipelineInvokerNew : object {
    private static Task Noop;
    private Func`2<IncomingStepContext, Task> _processIncoming;
    private Func`2<OutgoingStepContext, Task> _processOutgoing;
    public DefaultPipelineInvokerNew(IPipeline pipeline);
    private static DefaultPipelineInvokerNew();
    public sealed virtual Task Invoke(IncomingStepContext context);
    public sealed virtual Task Invoke(OutgoingStepContext context);
}
public interface Rebus.Pipeline.IOutgoingStep {
    public abstract virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
}
public interface Rebus.Pipeline.IPipeline {
    public abstract virtual IOutgoingStep[] SendPipeline();
    public abstract virtual IIncomingStep[] ReceivePipeline();
}
public interface Rebus.Pipeline.IPipelineInvoker {
    public abstract virtual Task Invoke(IncomingStepContext context);
    public abstract virtual Task Invoke(OutgoingStepContext context);
}
public interface Rebus.Pipeline.IStep {
}
public class Rebus.Pipeline.MessageContext : object {
    [CompilerGeneratedAttribute]
private ITransactionContext <TransactionContext>k__BackingField;
    public ITransactionContext TransactionContext { get; }
    public IncomingStepContext IncomingStepContext { get; }
    public TransportMessage TransportMessage { get; }
    public Message Message { get; }
    public Dictionary`2<string, string> Headers { get; }
    public static IMessageContext Current { get; }
    internal MessageContext(ITransactionContext transactionContext);
    [CompilerGeneratedAttribute]
public sealed virtual ITransactionContext get_TransactionContext();
    public sealed virtual IncomingStepContext get_IncomingStepContext();
    public sealed virtual TransportMessage get_TransportMessage();
    public sealed virtual Message get_Message();
    public sealed virtual Dictionary`2<string, string> get_Headers();
    public static IMessageContext get_Current();
}
public class Rebus.Pipeline.OutgoingStepContext : StepContext {
    public OutgoingStepContext(Message logicalMessage, ITransactionContext transactionContext, DestinationAddresses destinationAddresses);
}
public enum Rebus.Pipeline.PipelineAbsolutePosition : Enum {
    public int value__;
    public static PipelineAbsolutePosition Front;
    public static PipelineAbsolutePosition Back;
}
[ExtensionAttribute]
public static class Rebus.Pipeline.PipelineMessageContextExtensions : object {
    [ExtensionAttribute]
public static void AbortDispatch(IMessageContext messageContext);
}
public enum Rebus.Pipeline.PipelineRelativePosition : Enum {
    public int value__;
    public static PipelineRelativePosition Before;
    public static PipelineRelativePosition After;
}
public class Rebus.Pipeline.PipelineStepConcatenator : object {
    private List`1<IIncomingStep> _incomingFrontSteps;
    private List`1<IIncomingStep> _incomingBackSteps;
    private List`1<IOutgoingStep> _outgoingFrontSteps;
    private List`1<IOutgoingStep> _outgoingBackSteps;
    private IPipeline _pipeline;
    public PipelineStepConcatenator(IPipeline pipeline);
    public PipelineStepConcatenator OnSend(IOutgoingStep step, PipelineAbsolutePosition position);
    public PipelineStepConcatenator OnReceive(IIncomingStep step, PipelineAbsolutePosition position);
    public sealed virtual IOutgoingStep[] SendPipeline();
    public sealed virtual IIncomingStep[] ReceivePipeline();
}
public class Rebus.Pipeline.PipelineStepInjector : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<Type, List`1<ValueTuple`2<PipelineRelativePosition, IOutgoingStep>>> _outgoingInjectedSteps;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<Type, List`1<ValueTuple`2<PipelineRelativePosition, IIncomingStep>>> _incomingInjectedSteps;
    private IPipeline _pipeline;
    public PipelineStepInjector(IPipeline pipeline);
    public sealed virtual IOutgoingStep[] SendPipeline();
    public sealed virtual IIncomingStep[] ReceivePipeline();
    [IteratorStateMachineAttribute("Rebus.Pipeline.PipelineStepInjector/<ComposeReceivePipeline>d__6")]
private IEnumerable`1<IIncomingStep> ComposeReceivePipeline();
    [IteratorStateMachineAttribute("Rebus.Pipeline.PipelineStepInjector/<ComposeSendPipeline>d__7")]
private IEnumerable`1<IOutgoingStep> ComposeSendPipeline();
    public PipelineStepInjector OnSend(IOutgoingStep step, PipelineRelativePosition position, Type anchorStep);
    public PipelineStepInjector OnReceive(IIncomingStep step, PipelineRelativePosition position, Type anchorStep);
    [CompilerGeneratedAttribute]
private ValueTuple`2<Type, List`1<ValueTuple`2<PipelineRelativePosition, IIncomingStep>>> <ComposeReceivePipeline>b__6_0(Type type);
    [CompilerGeneratedAttribute]
private ValueTuple`2<Type, List`1<ValueTuple`2<PipelineRelativePosition, IOutgoingStep>>> <ComposeSendPipeline>b__7_0(Type type);
}
public class Rebus.Pipeline.PipelineStepRemover : object {
    private List`1<Func`2<IIncomingStep, bool>> _incomingStepPredicates;
    private List`1<Func`2<IOutgoingStep, bool>> _outgoingStepPredicates;
    private IPipeline _pipeline;
    private HashSet`1<IDisposable> _alreadyDisposedSteps;
    public PipelineStepRemover(IPipeline pipeline);
    public sealed virtual IOutgoingStep[] SendPipeline();
    public sealed virtual IIncomingStep[] ReceivePipeline();
    [IteratorStateMachineAttribute("Rebus.Pipeline.PipelineStepRemover/<ComposeReceivePipeline>d__6")]
private IEnumerable`1<IIncomingStep> ComposeReceivePipeline();
    [IteratorStateMachineAttribute("Rebus.Pipeline.PipelineStepRemover/<ComposeSendPipeline>d__7")]
private IEnumerable`1<IOutgoingStep> ComposeSendPipeline();
    public PipelineStepRemover RemoveIncomingStep(Func`2<IIncomingStep, bool> stepPredicate);
    public PipelineStepRemover RemoveOutgoingStep(Func`2<IOutgoingStep, bool> stepPredicate);
    private bool HasMatch(IOutgoingStep step);
    private bool HasMatch(IIncomingStep step);
    private void PossiblyDispose(IStep step);
}
[StepDocumentationAttribute("Looks at the incoming message and decides how to handle it. A HandlerInvokers object is saved to the context to be invoked later.")]
public class Rebus.Pipeline.Receive.ActivateHandlersStep : object {
    private ConcurrentDictionary`2<Type, MethodInfo> _dispatchMethods;
    private IHandlerActivator _handlerActivator;
    public ActivateHandlersStep(IHandlerActivator handlerActivator);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.ActivateHandlersStep/<Process>d__3")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.ActivateHandlersStep/<GetHandlerInvokers>d__4`1")]
protected virtual Task`1<HandlerInvokers> GetHandlerInvokers(TMessage message, ITransactionContext transactionContext, Message logicalMessage);
    protected virtual HandlerInvoker CreateHandlerInvoker(IHandleMessages`1<TMessage> handler, TMessage message, ITransactionContext transactionContext, Message logicalMessage);
    private MethodInfo GetDispatchMethod(Type messageType);
}
[StepDocumentationAttribute("Deserializes the current transport message using the configured serializer, saving the deserialized message back to the context.")]
public class Rebus.Pipeline.Receive.DeserializeIncomingMessageStep : object {
    private ISerializer _serializer;
    public DeserializeIncomingMessageStep(ISerializer serializer);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.DeserializeIncomingMessageStep/<Process>d__2")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
}
[StepDocumentationAttribute("Gets all the handler invokers from the current context and invokes them in order.

Please note that each invoker might choose to ignore the invocation internally.

If no invokers were found, a RebusApplicationException is thrown.")]
public class Rebus.Pipeline.Receive.DispatchIncomingMessageStep : object {
    private ILog _log;
    public static string AbortDispatchContextKey;
    public DispatchIncomingMessageStep(IRebusLoggerFactory rebusLoggerFactory);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.DispatchIncomingMessageStep/<Process>d__3")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
}
[StepDocumentationAttribute("If the incoming message should not be handled now, this step saves the message until it is time to deliver the message.

This is done by checking if the incoming message has a 'rbs2-deferred-until' header with a desired time to be delivered.")]
public class Rebus.Pipeline.Receive.HandleDeferredMessagesStep : object {
    private static string DueMessagesSenderTaskName;
    private ITimeoutManager _timeoutManager;
    private ITransport _transport;
    private Options _options;
    private IAsyncTask _dueMessagesSenderBackgroundTask;
    private ILog _log;
    private bool _disposed;
    private bool UsingExternalTimeoutManager { get; }
    public HandleDeferredMessagesStep(ITimeoutManager timeoutManager, ITransport transport, Options options, IRebusLoggerFactory rebusLoggerFactory, IAsyncTaskFactory asyncTaskFactory);
    public sealed virtual void Initialize();
    private bool get_UsingExternalTimeoutManager();
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.HandleDeferredMessagesStep/<TimerElapsed>d__11")]
private Task TimerElapsed();
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.HandleDeferredMessagesStep/<Process>d__12")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.HandleDeferredMessagesStep/<ForwardMessageToExternalTimeoutManager>d__13")]
private Task ForwardMessageToExternalTimeoutManager(TransportMessage transportMessage, ITransactionContext transactionContext);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.HandleDeferredMessagesStep/<StoreMessageUntilDue>d__14")]
private Task StoreMessageUntilDue(string deferredUntil, Dictionary`2<string, string> headers, TransportMessage transportMessage);
    private static DateTimeOffset GetTimeToBeDelivered(string deferredUntil);
    public sealed virtual void Dispose();
}
public abstract class Rebus.Pipeline.Receive.HandlerInvoker : object {
    private static ConcurrentDictionary`2<string, bool> CanBeInitiatedByCache;
    protected static ConcurrentDictionary`2<Type, Action`2<object, ISagaData>> SagaDataSetters;
    public static string CurrentHandlerInvokerItemsKey;
    public bool HasSaga { get; }
    public Saga Saga { get; }
    public object Handler { get; }
    public bool WillBeInvoked { get; }
    private static HandlerInvoker();
    public bool CanBeInitiatedBy(Type messageType);
    public abstract virtual Task Invoke();
    public abstract virtual bool get_HasSaga();
    public abstract virtual Saga get_Saga();
    public abstract virtual void SetSagaData(ISagaData sagaData);
    public abstract virtual ISagaData GetSagaData();
    public abstract virtual void SkipInvocation();
    public abstract virtual object get_Handler();
    public abstract virtual bool get_WillBeInvoked();
}
public class Rebus.Pipeline.Receive.HandlerInvoker`1 : HandlerInvoker {
    private Func`1<Task> _action;
    private object _handler;
    private ITransactionContext _transactionContext;
    private ISagaData _sagaData;
    private bool _invokeHandler;
    private static string SagaDataPropertyName;
    public object Handler { get; }
    public bool WillBeInvoked { get; }
    public bool HasSaga { get; }
    public Saga Saga { get; }
    public HandlerInvoker`1(Func`1<Task> action, object handler, ITransactionContext transactionContext);
    public virtual object get_Handler();
    public virtual bool get_WillBeInvoked();
    public virtual bool get_HasSaga();
    public virtual Saga get_Saga();
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.HandlerInvoker`1/<Invoke>d__14")]
public virtual Task Invoke();
    public virtual void SetSagaData(ISagaData sagaData);
    public virtual ISagaData GetSagaData();
    public virtual void SkipInvocation();
    [CompilerGeneratedAttribute]
private Action`2<object, ISagaData> <SetSagaData>b__17_0(Type type);
}
[DefaultMemberAttribute("Item")]
public class Rebus.Pipeline.Receive.HandlerInvokers : object {
    private List`1<HandlerInvoker> _handlerInvokers;
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    public Message Message { get; }
    public int Count { get; }
    public HandlerInvoker Item { get; }
    public HandlerInvokers(Message message, IEnumerable`1<HandlerInvoker> handlerInvokers);
    [CompilerGeneratedAttribute]
public Message get_Message();
    public int get_Count();
    public HandlerInvoker get_Item(int index);
    public sealed virtual IEnumerator`1<HandlerInvoker> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[StepDocumentationAttribute("If the message being handled is a routing slip with an itinerary, this step ensures that the routing slip is forwarded to the next destination.")]
public class Rebus.Pipeline.Receive.HandleRoutingSlipsStep : object {
    private static Char[] Separators;
    private ITransport _transport;
    private ISerializer _serialier;
    public HandleRoutingSlipsStep(ITransport transport, ISerializer serialier);
    private static HandleRoutingSlipsStep();
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.HandleRoutingSlipsStep/<Process>d__4")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Receive.HandleRoutingSlipsStep/<HandleRoutingSlip>d__5")]
private Task HandleRoutingSlip(IncomingStepContext context, Message message);
    private static string GetNextSequenceNumber(IReadOnlyDictionary`2<string, string> headers);
    private static String[] GetDestinations(Dictionary`2<string, string> headers, string headerKey);
}
[StepDocumentationAttribute("Assigns these default headers to the outgoing message: 

1) a new GUID as the 'rbs2-msg-id' header (*).

2) a 'rbs2-return-address' (unless the bus is a one-way client) (*).

3) a 'rbs2-senttime' with the current time (*).

-4) 'rbs2-msg-type' with the message's simple assembly-qualified type name (*).
-
-(*) Unless explicitly set to something else")]
public class Rebus.Pipeline.Send.AssignDefaultHeadersStep : object {
    private IMessageTypeNameConvention _messageTypeNameConvention;
    private IRebusTime _rebusTime;
    private string _senderAddress;
    private string _returnAddress;
    private bool _hasSenderAddress;
    private bool _hasReturnAddress;
    public AssignDefaultHeadersStep(ITransport transport, IRebusTime rebusTime, IMessageTypeNameConvention messageTypeNameConvention, string defaultReturnAddressOrNull);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Send.AssignDefaultHeadersStep/<Process>d__7")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
}
[StepDocumentationAttribute("If the outgoing message type has [HeaderAttribute(..., ...)] on it, the found headers will automatically be picked up and added to the outgoing message.

Headers already on the message will not be overwritten.")]
public class Rebus.Pipeline.Send.AutoHeadersOutgoingStep : object {
    private ConcurrentDictionary`2<Type, HeaderAttribute[]> _headersToAssign;
    [AsyncStateMachineAttribute("Rebus.Pipeline.Send.AutoHeadersOutgoingStep/<Process>d__1")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
}
public class Rebus.Pipeline.Send.DestinationAddresses : object {
    private List`1<string> _addresses;
    public DestinationAddresses(IEnumerable`1<string> addresses);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[StepDocumentationAttribute("Sets the 'rbs2-corr-id' header of the outgoing message to one of the following three things:

1) The correlation ID of the message currently being handled.
2) The message ID of the message currently being handled.
3) The message's own message ID.")]
public class Rebus.Pipeline.Send.FlowCorrelationIdStep : object {
    [AsyncStateMachineAttribute("Rebus.Pipeline.Send.FlowCorrelationIdStep/<Process>d__0")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
    private static CorrelationInfo GetCorrelationIdToAssign(IncomingStepContext incomingStepContext, Message outgoingMessage);
    private static int ParseOrZero(string correlationSequenceHeader);
}
[StepDocumentationAttribute("Final step that uses the current transport to send the transport message found in the context to all addresses found by looking up the DestinationAddress object from the context.")]
public class Rebus.Pipeline.Send.SendOutgoingMessageStep : object {
    private ITransport _transport;
    private ILog _log;
    public SendOutgoingMessageStep(ITransport transport, IRebusLoggerFactory rebusLoggerFactory);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Send.SendOutgoingMessageStep/<Process>d__3")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Send.SendOutgoingMessageStep/<Send>d__4")]
private Task Send(List`1<string> destinationAddressesList, TransportMessage transportMessage, ITransactionContext currentTransactionContext);
}
[StepDocumentationAttribute("Serializes the outgoing message using the configured serializer, storing the resulting transport message back to the context.")]
public class Rebus.Pipeline.Send.SerializeOutgoingMessageStep : object {
    private ISerializer _serializer;
    public SerializeOutgoingMessageStep(ISerializer serializer);
    [AsyncStateMachineAttribute("Rebus.Pipeline.Send.SerializeOutgoingMessageStep/<Process>d__2")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
}
[StepDocumentationAttribute("Checks the consistency of the outgoing message")]
public class Rebus.Pipeline.Send.ValidateOutgoingMessageStep : object {
    [AsyncStateMachineAttribute("Rebus.Pipeline.Send.ValidateOutgoingMessageStep/<Process>d__0")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
    private static void CheckDeferHeaders(IReadOnlyDictionary`2<string, string> headers);
}
public abstract class Rebus.Pipeline.StepContext : object {
    public static string StepContextKey;
    private ConcurrentDictionary`2<string, object> _items;
    private Object[] _fastItems;
    private static int _index;
    public T Save(T instance);
    public T Load();
    public T Save(string key, T instance);
    public T Load(string key);
}
[AttributeUsageAttribute("4")]
public class Rebus.Pipeline.StepDocumentationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; private set; }
    public StepDocumentationAttribute(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
}
public class Rebus.Profiling.PipelineStepProfiler : object {
    private IPipeline _pipeline;
    private PipelineStepProfilerStats _profilerStats;
    public PipelineStepProfiler(IPipeline pipeline, PipelineStepProfilerStats profilerStats);
    public sealed virtual IOutgoingStep[] SendPipeline();
    public sealed virtual IIncomingStep[] ReceivePipeline();
    [IteratorStateMachineAttribute("Rebus.Profiling.PipelineStepProfiler/<ComposeReceivePipeline>d__5")]
private IEnumerable`1<IIncomingStep> ComposeReceivePipeline();
}
public class Rebus.Profiling.PipelineStepProfilerStats : object {
    private ConcurrentDictionary`2<Type, TimeSpan> _stats;
    internal void Register(StatsContext statsContext);
    public List`1<StepStat> GetAndResetStats();
    public List`1<StepStat> GetStats();
}
internal class Rebus.Profiling.StatsContext : object {
    private ConcurrentStack`1<Measurement> _measurements;
    internal void AddMeasurement(IIncomingStep step, TimeSpan elapsed);
    private TimeSpan Correct(TimeSpan elapsed);
    internal IDisposable Measure(IIncomingStep nextStep);
    public IEnumerable`1<Measurement> GetMeasurements();
}
internal class Rebus.Reflection.Reflect : object {
    public static string Path(Expression`1<Func`2<T, object>> expression);
    public static object Value(object obj, string path);
    private static string GetPropertyName(Expression expression);
}
public class Rebus.Retry.ErrorTracking.InMemErrorTracker : object {
    private static string BackgroundTaskName;
    private static Task`1<bool> FalseTaskResult;
    private ConcurrentDictionary`2<string, ErrorTracking> _trackedErrors;
    private RetryStrategySettings _retryStrategySettings;
    private IAsyncTask _cleanupOldTrackedErrorsTask;
    private IExceptionLogger _exceptionLogger;
    private IExceptionInfoFactory _exceptionInfoFactory;
    private IRebusTime _rebusTime;
    private bool _disposed;
    public InMemErrorTracker(RetryStrategySettings retryStrategySettings, IAsyncTaskFactory asyncTaskFactory, IRebusTime rebusTime, IExceptionLogger exceptionLogger, IExceptionInfoFactory exceptionInfoFactory);
    private static InMemErrorTracker();
    public sealed virtual void Initialize();
    public sealed virtual Task MarkAsFinal(string messageId);
    public sealed virtual Task RegisterError(string messageId, Exception exception);
    public sealed virtual Task`1<bool> HasFailedTooManyTimes(string messageId);
    [AsyncStateMachineAttribute("Rebus.Retry.ErrorTracking.InMemErrorTracker/<GetFullErrorDescription>d__14")]
public sealed virtual Task`1<string> GetFullErrorDescription(string messageId);
    [AsyncStateMachineAttribute("Rebus.Retry.ErrorTracking.InMemErrorTracker/<GetExceptions>d__15")]
public sealed virtual Task`1<IReadOnlyList`1<ExceptionInfo>> GetExceptions(string messageId);
    public sealed virtual Task CleanUp(string messageId);
    [AsyncStateMachineAttribute("Rebus.Retry.ErrorTracking.InMemErrorTracker/<CleanupOldTrackedErrors>d__17")]
private Task CleanupOldTrackedErrors();
    private void RemoveTracking(string messageId);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private ErrorTracking <MarkAsFinal>b__11_0(string _);
}
[ExtensionAttribute]
public static class Rebus.Retry.ErrorTracking.InMemErrorTrackerConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseInMemErrorTracker(StandardConfigurer`1<IErrorTracker> configurer);
    [ExtensionAttribute]
public static void UseInMemExceptionInfos(StandardConfigurer`1<IErrorTracker> configurer);
}
public class Rebus.Retry.ExceptionInfo : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Type { get; public set; }
    public string Message { get; public set; }
    public string Details { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public ExceptionInfo(string Type, string Message, string Details, DateTimeOffset Time);
    [CompilerGeneratedAttribute]
protected ExceptionInfo(ExceptionInfo original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_Details();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Details(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Time(DateTimeOffset value);
    public static ExceptionInfo FromException(Exception exception);
    public string GetFullErrorDescription();
    public TExceptionInfo ConvertTo();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ExceptionInfo left, ExceptionInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ExceptionInfo left, ExceptionInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ExceptionInfo other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual ExceptionInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Type, String& Message, String& Details, DateTimeOffset& Time);
}
public class Rebus.Retry.FailFast.FailFastChecker : object {
    public virtual bool ShouldFailFast(string messageId, Exception exception);
}
[ExtensionAttribute]
public static class Rebus.Retry.FailFast.FailFastConfigurationExtension : object {
    [ExtensionAttribute]
public static void FailFastOn(OptionsConfigurer configurer, Func`2<TException, bool> when);
}
public interface Rebus.Retry.FailFast.IFailFastChecker {
    public abstract virtual bool ShouldFailFast(string messageId, Exception exception);
}
public class Rebus.Retry.FailFast.ManualDeadletterCommand : object {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    internal ManualDeadletterCommand(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public interface Rebus.Retry.IErrorHandler {
    public abstract virtual Task HandlePoisonMessage(TransportMessage transportMessage, ITransactionContext transactionContext, ExceptionInfo exception);
}
public interface Rebus.Retry.IErrorTracker {
    public abstract virtual Task RegisterError(string messageId, Exception exception);
    public abstract virtual Task CleanUp(string messageId);
    public abstract virtual Task`1<bool> HasFailedTooManyTimes(string messageId);
    public abstract virtual Task`1<string> GetFullErrorDescription(string messageId);
    public abstract virtual Task`1<IReadOnlyList`1<ExceptionInfo>> GetExceptions(string messageId);
    public abstract virtual Task MarkAsFinal(string messageId);
}
public interface Rebus.Retry.IExceptionInfoFactory {
    public abstract virtual ExceptionInfo CreateInfo(Exception exception);
}
public interface Rebus.Retry.IExceptionLogger {
    public abstract virtual void LogException(string messageId, Exception exception, int errorCount, bool isFinal);
}
public class Rebus.Retry.Info.InMemExceptionInfo : ExceptionInfo {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Exception Exception { get; }
    public InMemExceptionInfo(Exception exception);
    [CompilerGeneratedAttribute]
protected InMemExceptionInfo(InMemExceptionInfo original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(InMemExceptionInfo left, InMemExceptionInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(InMemExceptionInfo left, InMemExceptionInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ExceptionInfo other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(InMemExceptionInfo other);
    [NullableContextAttribute("1")]
[PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override InMemExceptionInfo <Clone>$();
}
public class Rebus.Retry.Info.InMemExceptionInfoFactory : object {
    public sealed virtual ExceptionInfo CreateInfo(Exception exception);
}
public class Rebus.Retry.Info.ToStringExceptionInfoFactory : object {
    public sealed virtual ExceptionInfo CreateInfo(Exception exception);
}
public interface Rebus.Retry.IRetryStrategy {
    public abstract virtual IRetryStep GetRetryStep();
}
public class Rebus.Retry.PoisonQueues.DeadletterQueueErrorHandler : object {
    private RetryStrategySettings _retryStrategySettings;
    private ITransport _transport;
    private ILog _log;
    public DeadletterQueueErrorHandler(RetryStrategySettings retryStrategySettings, ITransport transport, IRebusLoggerFactory rebusLoggerFactory);
    public sealed virtual void Initialize();
    [AsyncStateMachineAttribute("Rebus.Retry.PoisonQueues.DeadletterQueueErrorHandler/<HandlePoisonMessage>d__5")]
public sealed virtual Task HandlePoisonMessage(TransportMessage transportMessage, ITransactionContext transactionContext, ExceptionInfo exception);
    private string GetErrorDetails(ExceptionInfo exception);
}
internal class Rebus.Retry.Simple.DefaultExceptionLogger : object {
    private ILog _log;
    public DefaultExceptionLogger(IRebusLoggerFactory rebusLoggerFactory);
    public sealed virtual void LogException(string messageId, Exception exception, int errorCount, bool isFinal);
}
[StepDocumentationAttribute("Wraps the invocation of the entire receive pipeline in an exception handler, tracking the number of times the received message has been attempted to be delivered.

If the maximum number of delivery attempts is reached, the message is passed to the error handler, which by default will move the message to the error queue.")]
public class Rebus.Retry.Simple.DefaultRetryStep : object {
    public static string DispatchAsFailedMessageKey;
    private RetryStrategySettings _retryStrategySettings;
    private IExceptionInfoFactory _exceptionInfoFactory;
    private CancellationToken _cancellationToken;
    private IFailFastChecker _failFastChecker;
    private IErrorHandler _errorHandler;
    private IErrorTracker _errorTracker;
    private ILog _log;
    public DefaultRetryStep(IRebusLoggerFactory rebusLoggerFactory, IErrorHandler errorHandler, IErrorTracker errorTracker, IFailFastChecker failFastChecker, IExceptionInfoFactory exceptionInfoFactory, RetryStrategySettings retryStrategySettings, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Rebus.Retry.Simple.DefaultRetryStep/<Process>d__9")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.Retry.Simple.DefaultRetryStep/<HandleException>d__10")]
private Task HandleException(Exception exception, ITransactionContext transactionContext, string messageId, IncomingStepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.Retry.Simple.DefaultRetryStep/<DispatchSecondLevelRetry>d__11")]
private Task DispatchSecondLevelRetry(ITransactionContext transactionContext, string messageId, IncomingStepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.Retry.Simple.DefaultRetryStep/<HandleManualDeadlettering>d__12")]
private Task HandleManualDeadlettering(IncomingStepContext context);
    [AsyncStateMachineAttribute("Rebus.Retry.Simple.DefaultRetryStep/<DispatchSecondLevelRetry>d__13")]
private static Task DispatchSecondLevelRetry(ITransactionContext transactionContext, StepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.Retry.Simple.DefaultRetryStep/<PassToErrorHandler>d__14")]
private Task PassToErrorHandler(StepContext context, ExceptionInfo exception);
    private static ExceptionInfo GetAggregateException(IEnumerable`1<ExceptionInfo> exceptions);
}
public class Rebus.Retry.Simple.DefaultRetryStrategy : object {
    private RetryStrategySettings _retryStrategySettings;
    private IRebusLoggerFactory _rebusLoggerFactory;
    private IErrorTracker _errorTracker;
    private IErrorHandler _errorHandler;
    private IFailFastChecker _failFastChecker;
    private IExceptionInfoFactory _exceptionInfoFactory;
    private CancellationToken _cancellationToken;
    public DefaultRetryStrategy(RetryStrategySettings retryStrategySettings, IRebusLoggerFactory rebusLoggerFactory, IErrorTracker errorTracker, IErrorHandler errorHandler, IFailFastChecker failFastChecker, IExceptionInfoFactory exceptionInfoFactory, CancellationToken cancellationToken);
    public sealed virtual IRetryStep GetRetryStep();
}
internal class Rebus.Retry.Simple.FailedMessageWrapper`1 : object {
    [CompilerGeneratedAttribute]
private TMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ExceptionInfo> <Exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    public TMessage Message { get; }
    public string ErrorDescription { get; }
    public IEnumerable`1<ExceptionInfo> Exceptions { get; }
    public Dictionary`2<string, string> Headers { get; }
    public FailedMessageWrapper`1(Dictionary`2<string, string> headers, TMessage message, string errorDescription, IEnumerable`1<ExceptionInfo> exceptions);
    [CompilerGeneratedAttribute]
public sealed virtual TMessage get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ErrorDescription();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ExceptionInfo> get_Exceptions();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Headers();
    public virtual string ToString();
}
[StepDocumentationAttribute("When 2nd level retries are enabled, a message that has failed too many times must be dispatched as a IFailed<TMessage>.

This is carried out by having the retry step add the 'dispatch-as-failed-message' key to the context,
which is then detected by this wrapper step.")]
internal class Rebus.Retry.Simple.FailedMessageWrapperStep : object {
    private IErrorTracker _errorTracker;
    private static ConcurrentDictionary`2<Type, MethodInfo> WrapperMethods;
    private static MethodInfo GenericWrapMethod;
    public FailedMessageWrapperStep(IErrorTracker errorTracker);
    private static FailedMessageWrapperStep();
    [AsyncStateMachineAttribute("Rebus.Retry.Simple.FailedMessageWrapperStep/<Process>d__2")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    private static object WrapInFailed(Dictionary`2<string, string> headers, object body, string errorDescription, IEnumerable`1<ExceptionInfo> exceptions);
    private static IFailed`1<TMessage> Wrap(Dictionary`2<string, string> headers, TMessage body, string errorDescription, IEnumerable`1<ExceptionInfo> exceptions);
}
public interface Rebus.Retry.Simple.IFailed`1 {
    public TMessage Message { get; }
    public string ErrorDescription { get; }
    public Dictionary`2<string, string> Headers { get; }
    public IEnumerable`1<ExceptionInfo> Exceptions { get; }
    public abstract virtual TMessage get_Message();
    public abstract virtual string get_ErrorDescription();
    public abstract virtual Dictionary`2<string, string> get_Headers();
    public abstract virtual IEnumerable`1<ExceptionInfo> get_Exceptions();
}
public interface Rebus.Retry.Simple.IRetryStep {
}
[ExtensionAttribute]
public static class Rebus.Retry.Simple.RetryStrategyConfigurationExtensions : object {
    [ExtensionAttribute]
public static void RetryStrategy(OptionsConfigurer optionsConfigurer, string errorQueueName, int maxDeliveryAttempts, bool secondLevelRetriesEnabled, int errorDetailsHeaderMaxLength, int errorTrackingMaxAgeMinutes, int errorQueueErrorCooldownTimeSeconds);
}
public class Rebus.Retry.Simple.RetryStrategySettings : object {
    public static string DefaultErrorQueueName;
    public static int DefaultNumberOfDeliveryAttempts;
    public static int DefaultErrorTrackingMaxAgeMinutes;
    public static int DefaultErrorQueueErrorCooldownTimeSeconds;
    [CompilerGeneratedAttribute]
private string <ErrorQueueName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDeliveryAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SecondLevelRetriesEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorDetailsHeaderMaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorTrackingMaxAgeMinutes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorQueueErrorCooldownTimeSeconds>k__BackingField;
    public string ErrorQueueName { get; internal set; }
    public int MaxDeliveryAttempts { get; internal set; }
    public bool SecondLevelRetriesEnabled { get; internal set; }
    public int ErrorDetailsHeaderMaxLength { get; internal set; }
    public int ErrorTrackingMaxAgeMinutes { get; internal set; }
    public int ErrorQueueErrorCooldownTimeSeconds { get; internal set; }
    public RetryStrategySettings(string errorQueueAddress, int maxDeliveryAttempts, bool secondLevelRetriesEnabled, int errorDetailsHeaderMaxLength, int errorTrackingMaxAgeMinutes, int errorQueueErrorCooldownTimeSeconds);
    [CompilerGeneratedAttribute]
public string get_ErrorQueueName();
    [CompilerGeneratedAttribute]
internal void set_ErrorQueueName(string value);
    [CompilerGeneratedAttribute]
public int get_MaxDeliveryAttempts();
    [CompilerGeneratedAttribute]
internal void set_MaxDeliveryAttempts(int value);
    [CompilerGeneratedAttribute]
public bool get_SecondLevelRetriesEnabled();
    [CompilerGeneratedAttribute]
internal void set_SecondLevelRetriesEnabled(bool value);
    [CompilerGeneratedAttribute]
public int get_ErrorDetailsHeaderMaxLength();
    [CompilerGeneratedAttribute]
internal void set_ErrorDetailsHeaderMaxLength(int value);
    [CompilerGeneratedAttribute]
public int get_ErrorTrackingMaxAgeMinutes();
    [CompilerGeneratedAttribute]
internal void set_ErrorTrackingMaxAgeMinutes(int value);
    [CompilerGeneratedAttribute]
public int get_ErrorQueueErrorCooldownTimeSeconds();
    [CompilerGeneratedAttribute]
internal void set_ErrorQueueErrorCooldownTimeSeconds(int value);
}
[StepDocumentationAttribute("When 2nd level retries are enabled, it is easy to accidentally Send/Defer the incoming IFailed<TMessage> instead of the TMessage. This step prohibits that.")]
internal class Rebus.Retry.Simple.VerifyCannotSendFailedMessageWrapperStep : object {
    [AsyncStateMachineAttribute("Rebus.Retry.Simple.VerifyCannotSendFailedMessageWrapperStep/<Process>d__0")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
}
[ExtensionAttribute]
public static class Rebus.Routing.Exceptions.AutoForwardOnExceptionConfigurationExtensions : object {
    [ExtensionAttribute]
public static StandardConfigurer`1<IRouter> ForwardOnException(StandardConfigurer`1<IRouter> configurer, string destinationQueue, LogLevel logLevel, Func`2<TException, bool> shouldForward);
}
public interface Rebus.Routing.IRouter {
    public abstract virtual Task`1<string> GetDestinationAddress(Message message);
    public abstract virtual Task`1<string> GetOwnerAddress(string topic);
}
public class Rebus.Routing.Itinerary : object {
    private List`1<string> _destinations;
    private string _returnAddressOrNull;
    private bool _returnToSender;
    internal bool MustReturnToSender { get; }
    internal string GetReturnAddress { get; }
    internal bool HasExplicitlySpecifiedReturnAddress { get; }
    public Itinerary(String[] destinationAddresses);
    public Itinerary Add(string destinationAddress);
    public Itinerary ReturnTo(string destinationAddress);
    public Itinerary ReturnToSender();
    internal bool get_MustReturnToSender();
    internal string get_GetReturnAddress();
    internal bool get_HasExplicitlySpecifiedReturnAddress();
    internal List`1<string> GetDestinationAddresses();
}
internal enum Rebus.Routing.TransportMessages.ActionType : Enum {
    public int value__;
    public static ActionType None;
    public static ActionType Forward;
    public static ActionType Ignore;
}
public enum Rebus.Routing.TransportMessages.ErrorBehavior : Enum {
    public int value__;
    public static ErrorBehavior RetryForever;
    public static ErrorBehavior Normal;
}
public class Rebus.Routing.TransportMessages.ForwardAction : object {
    public static ForwardAction None;
    [CompilerGeneratedAttribute]
private List`1<string> <DestinationQueueNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ActionType <ActionType>k__BackingField;
    internal List`1<string> DestinationQueueNames { get; }
    internal ActionType ActionType { get; }
    private ForwardAction(ActionType actionType, String[] destinationAddresses);
    private static ForwardAction();
    public static ForwardAction ForwardTo(string destinationQueueName);
    public static ForwardAction ForwardTo(IEnumerable`1<string> destinationQueueNames);
    public static ForwardAction Ignore();
    [CompilerGeneratedAttribute]
internal List`1<string> get_DestinationQueueNames();
    [CompilerGeneratedAttribute]
internal ActionType get_ActionType();
}
[StepDocumentationAttribute("This step allows for very quickly forwarding of the incoming transport message without performing any further actions")]
public class Rebus.Routing.TransportMessages.ForwardTransportMessageStep : object {
    private Func`2<TransportMessage, Task`1<ForwardAction>> _routingFunction;
    private IExceptionInfoFactory _exceptionInfoFactory;
    private ErrorBehavior _errorBehavior;
    private IErrorHandler _errorHandler;
    private ITransport _transport;
    private ILog _log;
    public ForwardTransportMessageStep(Func`2<TransportMessage, Task`1<ForwardAction>> routingFunction, ITransport transport, IRebusLoggerFactory rebusLoggerFactory, ErrorBehavior errorBehavior, IErrorHandler errorHandler, IExceptionInfoFactory exceptionInfoFactory);
    [AsyncStateMachineAttribute("Rebus.Routing.TransportMessages.ForwardTransportMessageStep/<Process>d__7")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.Routing.TransportMessages.ForwardTransportMessageStep/<CommitIfPossible>d__8")]
private static Task CommitIfPossible(ITransactionContext transactionContext);
}
[ExtensionAttribute]
public static class Rebus.Routing.TransportMessages.TransportMessageRoutingConfigurationExtensions : object {
    [ExtensionAttribute]
public static void AddTransportMessageForwarder(StandardConfigurer`1<IRouter> configurer, Func`2<TransportMessage, Task`1<ForwardAction>> routingFunction);
    [ExtensionAttribute]
public static void AddTransportMessageForwarder(StandardConfigurer`1<IRouter> configurer, Func`2<TransportMessage, Task`1<ForwardAction>> routingFunction, ErrorBehavior errorBehavior);
}
public class Rebus.Routing.TypeBased.TypeBasedRouter : object {
    private Dictionary`2<Type, string> _messageTypeAddresses;
    private ILog _log;
    private string _fallbackAddress;
    public TypeBasedRouter(IRebusLoggerFactory rebusLoggerFactory);
    public TypeBasedRouter MapAssemblyOf(string destinationAddress);
    public TypeBasedRouter MapAssemblyOf(Type messageType, string destinationAddress);
    public TypeBasedRouter MapAssemblyDerivedFrom(string destinationAddress);
    public TypeBasedRouter MapAssemblyDerivedFrom(Type derivedFrom, string destinationAddress);
    public TypeBasedRouter MapAssemblyNamespaceOf(string destinationAddress);
    public TypeBasedRouter MapAssemblyNamespaceOf(Type messageType, string destinationAddress);
    public TypeBasedRouter MapAssemblyNamespaceOfDerivedFrom(string destinationAddress);
    public TypeBasedRouter MapAssemblyNamespaceOfDerivedFrom(Type messageType, Type derivedFrom, string destinationAddress);
    public TypeBasedRouter Map(string destinationAddress);
    public TypeBasedRouter MapFallback(string destinationAddress);
    public TypeBasedRouter Map(Type messageType, string destinationAddress);
    private void SaveMapping(Type messageType, string destinationAddress);
    [AsyncStateMachineAttribute("Rebus.Routing.TypeBased.TypeBasedRouter/<GetDestinationAddress>d__16")]
public sealed virtual Task`1<string> GetDestinationAddress(Message message);
    [AsyncStateMachineAttribute("Rebus.Routing.TypeBased.TypeBasedRouter/<GetOwnerAddress>d__17")]
public sealed virtual Task`1<string> GetOwnerAddress(string topic);
    private static Type GetMessageTypeFromTopic(string topic);
    private string GetDestinationAddressForMessageType(Type messageType);
}
[ExtensionAttribute]
public static class Rebus.Routing.TypeBased.TypeBasedRouterConfigurationExtensions : object {
    [ExtensionAttribute]
public static TypeBasedRouterConfigurationBuilder TypeBased(StandardConfigurer`1<IRouter> configurer);
}
[ExtensionAttribute]
public static class Rebus.Sagas.Conflicts.SagaConflictResolutionConfigurationExtensions : object {
    [ExtensionAttribute]
public static void SetMaxConflictResolutionAttempts(StandardConfigurer`1<ISagaStorage> configurer, int value);
}
public class Rebus.Sagas.CorrelationProperty : object {
    private static Type[] AllowedCorrelationPropertyTypes;
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<IMessageContext, Message, object> <GetValueFromMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SagaDataType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SagaType>k__BackingField;
    public Type MessageType { get; }
    public Func`3<IMessageContext, Message, object> GetValueFromMessage { get; }
    public Type SagaDataType { get; }
    public string PropertyName { get; }
    public Type SagaType { get; }
    public CorrelationProperty(Type messageType, Func`3<IMessageContext, Message, object> getValueFromMessage, Type sagaDataType, string propertyName, Type sagaType);
    private static CorrelationProperty();
    private void Validate();
    private PropertyInfo GetPropertyInfo();
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
public Func`3<IMessageContext, Message, object> get_GetValueFromMessage();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_SagaDataType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PropertyName();
    [CompilerGeneratedAttribute]
public Type get_SagaType();
}
[StepDocumentationAttribute("Enforces exclusive access to saga data in the rest of the pipeline by acquiring locks for the relevant correlation properties.")]
internal class Rebus.Sagas.Exclusive.EnforceExclusiveSagaAccessIncomingStep : EnforceExclusiveSagaAccessIncomingStepBase {
    private IExclusiveAccessLock _lockHandler;
    private string _lockPrefix;
    private TimeSpan _lockSleepMinDelay;
    private TimeSpan _lockSleepMaxDelay;
    private Random _random;
    public EnforceExclusiveSagaAccessIncomingStep(IExclusiveAccessLock lockHandler, int maxLockBuckets, string lockPrefix, CancellationToken cancellationToken, Nullable`1<TimeSpan> lockSleepMinDelay, Nullable`1<TimeSpan> lockSleepMaxDelay);
    [AsyncStateMachineAttribute("Rebus.Sagas.Exclusive.EnforceExclusiveSagaAccessIncomingStep/<AcquireLockAsync>d__6")]
protected virtual Task`1<bool> AcquireLockAsync(int lockId);
    protected virtual Task`1<bool> ReleaseLockAsync(int lockId);
    private string LockKey(int lockId);
    public virtual string ToString();
}
internal abstract class Rebus.Sagas.Exclusive.EnforceExclusiveSagaAccessIncomingStepBase : object {
    private SagaHelper _sagaHelper;
    protected int _maxLockBuckets;
    protected CancellationToken _cancellationToken;
    protected EnforceExclusiveSagaAccessIncomingStepBase(int maxLockBuckets, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Rebus.Sagas.Exclusive.EnforceExclusiveSagaAccessIncomingStepBase/<Process>d__4")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    private static int GetHashCodeStable(string lockId);
    protected abstract virtual Task`1<bool> AcquireLockAsync(int lockId);
    protected abstract virtual Task`1<bool> ReleaseLockAsync(int lockId);
    [AsyncStateMachineAttribute("Rebus.Sagas.Exclusive.EnforceExclusiveSagaAccessIncomingStepBase/<WaitForLocks>d__8")]
private Task WaitForLocks(Int32[] lockIds);
    [AsyncStateMachineAttribute("Rebus.Sagas.Exclusive.EnforceExclusiveSagaAccessIncomingStepBase/<ReleaseLocks>d__9")]
private Task ReleaseLocks(Int32[] lockIds);
}
[ExtensionAttribute]
public static class Rebus.Sagas.Exclusive.ExclusiveAccessConfigurationExtensions : object {
    [ExtensionAttribute]
public static void EnforceExclusiveAccess(StandardConfigurer`1<ISagaStorage> configurer, int maxLockBuckets);
    [ExtensionAttribute]
public static void EnforceExclusiveAccess(StandardConfigurer`1<ISagaStorage> configurer, IExclusiveAccessLock locker, string lockPrefix, int maxLockBuckets);
    [ExtensionAttribute]
public static void EnforceExclusiveAccess(StandardConfigurer`1<ISagaStorage> configurer, Func`2<IResolutionContext, IExclusiveAccessLock> getLocker, string lockPrefix, int maxLockBuckets);
}
internal class Rebus.Sagas.Exclusive.SemaphoreSlimExclusiveSagaAccessIncomingStep : EnforceExclusiveSagaAccessIncomingStepBase {
    private SemaphoreSlim[] _locks;
    private bool _disposed;
    public SemaphoreSlimExclusiveSagaAccessIncomingStep(int lockBuckets, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Rebus.Sagas.Exclusive.SemaphoreSlimExclusiveSagaAccessIncomingStep/<AcquireLockAsync>d__2")]
protected virtual Task`1<bool> AcquireLockAsync(int lockId);
    [AsyncStateMachineAttribute("Rebus.Sagas.Exclusive.SemaphoreSlimExclusiveSagaAccessIncomingStep/<ReleaseLockAsync>d__3")]
protected virtual Task`1<bool> ReleaseLockAsync(int lockId);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public interface Rebus.Sagas.IAmInitiatedBy`1 {
}
public interface Rebus.Sagas.ICorrelationConfig`1 {
    public abstract virtual void Correlate(Func`2<TMessage, object> messageValueExtractorFunction, Expression`1<Func`2<TSagaData, object>> sagaDataValueExpression);
    public abstract virtual void Correlate(Func`2<TMessage, object> messageValueExtractorFunction, string sagaDataPropertyName);
    public abstract virtual void CorrelateHeader(string headerKey, Expression`1<Func`2<TSagaData, object>> sagaDataValueExpression);
    public abstract virtual void CorrelateHeader(string headerKey, string sagaDataPropertyName);
    public abstract virtual void CorrelateContext(Func`2<IMessageContext, object> contextValueExtractorFunction, Expression`1<Func`2<TSagaData, object>> sagaDataValueExpression);
    public abstract virtual void CorrelateContext(Func`2<IMessageContext, object> contextValueExtractorFunction, string sagaDataPropertyName);
}
public interface Rebus.Sagas.ICorrelationErrorHandler {
    public abstract virtual Task HandleCorrelationError(SagaDataCorrelationProperties correlationProperties, HandlerInvoker handlerInvoker, Message message);
}
public class Rebus.Sagas.Idempotent.IdempotencyData : object {
    [CompilerGeneratedAttribute]
private List`1<OutgoingMessages> <OutgoingMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <HandledMessageIds>k__BackingField;
    public List`1<OutgoingMessages> OutgoingMessages { get; }
    public HashSet`1<string> HandledMessageIds { get; }
    public IdempotencyData(IEnumerable`1<OutgoingMessages> outgoingMessages, IEnumerable`1<string> handledMessageIds);
    [CompilerGeneratedAttribute]
public List`1<OutgoingMessages> get_OutgoingMessages();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_HandledMessageIds();
    public bool HasAlreadyHandled(string messageId);
    public IEnumerable`1<OutgoingMessage> GetOutgoingMessages(string messageId);
    public void MarkMessageAsHandled(string messageId);
    public void AddOutgoingMessage(string messageId, IEnumerable`1<string> destinationAddresses, TransportMessage transportMessage);
    private OutgoingMessages GetOrCreate(string messageId);
}
public abstract class Rebus.Sagas.Idempotent.IdempotentSaga`1 : Saga`1<TSagaData> {
}
[ExtensionAttribute]
public static class Rebus.Sagas.Idempotent.IdempotentSagaConfigurationExtensions : object {
    [ExtensionAttribute]
public static void EnableIdempotentSagas(OptionsConfigurer configurer);
}
public abstract class Rebus.Sagas.Idempotent.IdempotentSagaData : SagaData {
    [CompilerGeneratedAttribute]
private IdempotencyData <IdempotencyData>k__BackingField;
    public IdempotencyData IdempotencyData { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IdempotencyData get_IdempotencyData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IdempotencyData(IdempotencyData value);
}
[StepDocumentationAttribute("Checks the loaded saga data to see if the message currently being handled is a duplicate of a message that has previously been handled.

If that is the case, message dispatch is skipped, but any messages stored as outgoing messages from previously handling the incoming message will be sent.")]
public class Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep : object {
    private ITransport _transport;
    private ILog _log;
    public IdempotentSagaIncomingStep(ITransport transport, IRebusLoggerFactory rebusLoggerFactory);
    [AsyncStateMachineAttribute("Rebus.Sagas.Idempotent.IdempotentSagaIncomingStep/<Process>d__3")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
}
[StepDocumentationAttribute("If the sent message originates from an idempotent saga, the message is stored in the saga's IdempotencyData in order to allow for re-sending it later on if necessary.")]
public class Rebus.Sagas.Idempotent.IdempotentSagaOutgoingStep : object {
    [AsyncStateMachineAttribute("Rebus.Sagas.Idempotent.IdempotentSagaOutgoingStep/<Process>d__0")]
public sealed virtual Task Process(OutgoingStepContext context, Func`1<Task> next);
}
public interface Rebus.Sagas.Idempotent.IIdempotentSagaData {
    public IdempotencyData IdempotencyData { get; public set; }
    public abstract virtual IdempotencyData get_IdempotencyData();
    public abstract virtual void set_IdempotencyData(IdempotencyData value);
}
public class Rebus.Sagas.Idempotent.OutgoingMessage : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <DestinationAddresses>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportMessage <TransportMessage>k__BackingField;
    public IEnumerable`1<string> DestinationAddresses { get; }
    public TransportMessage TransportMessage { get; }
    public OutgoingMessage(IEnumerable`1<string> destinationAddresses, TransportMessage transportMessage);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_DestinationAddresses();
    [CompilerGeneratedAttribute]
public TransportMessage get_TransportMessage();
}
public class Rebus.Sagas.Idempotent.OutgoingMessages : object {
    private List`1<OutgoingMessage> _messagesToSend;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    public string MessageId { get; }
    public IEnumerable`1<OutgoingMessage> MessagesToSend { get; }
    public OutgoingMessages(string messageId, IEnumerable`1<OutgoingMessage> messagesToSend);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    public IEnumerable`1<OutgoingMessage> get_MessagesToSend();
    public void Add(OutgoingMessage outgoingMessage);
}
public interface Rebus.Sagas.ISagaCorrelationProperty {
    public string PropertyName { get; }
    public Type SagaDataType { get; }
    public abstract virtual string get_PropertyName();
    public abstract virtual Type get_SagaDataType();
}
public interface Rebus.Sagas.ISagaData {
    public Guid Id { get; public set; }
    public int Revision { get; public set; }
    public abstract virtual Guid get_Id();
    public abstract virtual void set_Id(Guid value);
    public abstract virtual int get_Revision();
    public abstract virtual void set_Revision(int value);
}
public interface Rebus.Sagas.ISagaStorage {
    public abstract virtual Task`1<ISagaData> Find(Type sagaDataType, string propertyName, object propertyValue);
    public abstract virtual Task Insert(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    public abstract virtual Task Update(ISagaData sagaData, IEnumerable`1<ISagaCorrelationProperty> correlationProperties);
    public abstract virtual Task Delete(ISagaData sagaData);
}
[StepDocumentationAttribute("Looks at the handler invokers in the context and sees if there's one or more saga handlers in there. 

If that's the case, relevant saga data is loaded/created, and the rest of the pipeline gets invoked.

Afterwards, all the created/loaded saga data is updated appropriately.")]
public class Rebus.Sagas.LoadSagaDataStep : object {
    private static string RevisionPropertyName;
    private static String[] IgnoredProperties;
    private ICorrelationErrorHandler _correlationErrorHandler;
    private SagaHelper _sagaHelper;
    private ISagaStorage _sagaStorage;
    private Options _options;
    private ILog _log;
    public LoadSagaDataStep(ISagaStorage sagaStorage, ICorrelationErrorHandler correlationErrorHandler, IRebusLoggerFactory rebusLoggerFactory, Options options);
    private static LoadSagaDataStep();
    [AsyncStateMachineAttribute("Rebus.Sagas.LoadSagaDataStep/<Process>d__8")]
public sealed virtual Task Process(IncomingStepContext context, Func`1<Task> next);
    [AsyncStateMachineAttribute("Rebus.Sagas.LoadSagaDataStep/<TryMountSagaDataOnInvoker>d__9")]
private Task TryMountSagaDataOnInvoker(HandlerInvoker sagaInvoker, Message message, string label, List`1<RelevantSagaInfo> loadedSagaData, List`1<RelevantSagaInfo> newlyCreatedSagaData, ITransactionContext transactionContext);
    private static void TrySetCorrelationPropertyValue(ISagaData newSagaData, CorrelationProperty correlationProperty, Message message, ITransactionContext transactionContext);
    [AsyncStateMachineAttribute("Rebus.Sagas.LoadSagaDataStep/<SaveSagaData>d__11")]
private Task SaveSagaData(RelevantSagaInfo sagaDataToUpdate, bool insert);
}
public abstract class Rebus.Sagas.Saga : object {
    private static ConcurrentDictionary`2<Type, bool> CachedUserHasOverriddenConflictResolutionMethod;
    [CompilerGeneratedAttribute]
private bool <WasMarkedAsComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasMarkedAsUnchanged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HoldsNewSagaDataInstance>k__BackingField;
    internal bool WasMarkedAsComplete { get; internal set; }
    internal bool WasMarkedAsUnchanged { get; internal set; }
    internal bool HoldsNewSagaDataInstance { get; internal set; }
    protected bool IsNew { get; }
    private static Saga();
    internal bool UserHasOverriddenConflictResolutionMethod();
    internal static IEnumerable`1<CorrelationProperty> GetCorrelationProperties();
    internal abstract virtual IEnumerable`1<CorrelationProperty> GenerateCorrelationProperties();
    internal abstract virtual Type GetSagaDataType();
    internal abstract virtual ISagaData CreateNewSagaData();
    [CompilerGeneratedAttribute]
internal bool get_WasMarkedAsComplete();
    [CompilerGeneratedAttribute]
internal void set_WasMarkedAsComplete(bool value);
    [CompilerGeneratedAttribute]
internal bool get_WasMarkedAsUnchanged();
    [CompilerGeneratedAttribute]
internal void set_WasMarkedAsUnchanged(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HoldsNewSagaDataInstance();
    [CompilerGeneratedAttribute]
internal void set_HoldsNewSagaDataInstance(bool value);
    protected virtual void MarkAsComplete();
    protected virtual void MarkAsUnchanged();
    protected bool get_IsNew();
    internal abstract virtual Task InvokeConflictResolution(ISagaData otherSagaData);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool <UserHasOverriddenConflictResolutionMethod>b__1_0(Type type);
}
public abstract class Rebus.Sagas.Saga`1 : Saga {
    [CompilerGeneratedAttribute]
private TSagaData <Data>k__BackingField;
    public TSagaData Data { get; public set; }
    [CompilerGeneratedAttribute]
public TSagaData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(TSagaData value);
    protected abstract virtual void CorrelateMessages(ICorrelationConfig`1<TSagaData> config);
    internal sealed virtual IEnumerable`1<CorrelationProperty> GenerateCorrelationProperties();
    [AsyncStateMachineAttribute("Rebus.Sagas.Saga`1/<InvokeConflictResolution>d__6")]
internal sealed virtual Task InvokeConflictResolution(ISagaData otherSagaData);
    [AsyncStateMachineAttribute("Rebus.Sagas.Saga`1/<ResolveConflict>d__7")]
protected virtual Task ResolveConflict(TSagaData otherSagaData);
    internal virtual Type GetSagaDataType();
    internal virtual ISagaData CreateNewSagaData();
}
[ExtensionAttribute]
public static class Rebus.Sagas.SagaCorrelationConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseCorrelationErrorHandler(StandardConfigurer`1<ISagaStorage> configurer, ICorrelationErrorHandler correlationErrorHandler);
}
public abstract class Rebus.Sagas.SagaData : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    public Guid Id { get; public set; }
    public int Revision { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Revision();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Revision(int value);
}
public class Rebus.Sagas.SagaDataCorrelationProperties : object {
    private ConcurrentDictionary`2<Type, IReadOnlyList`1<CorrelationProperty>> _cachedCorrelationProperties;
    private Dictionary`2<Type, IReadOnlyList`1<CorrelationProperty>> _correlationProperties;
    private Type _sagaDataType;
    public SagaDataCorrelationProperties(Dictionary`2<Type, IReadOnlyList`1<CorrelationProperty>> correlationProperties, Type sagaDataType);
    public IEnumerable`1<CorrelationProperty> ForMessage(object body);
    public sealed virtual IEnumerator`1<CorrelationProperty> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CorrelationProperty> <ForMessage>b__4_0(Type nonCapturedMessageType);
    [CompilerGeneratedAttribute]
private IEnumerable`1<CorrelationProperty> <ForMessage>b__4_1(Type type);
}
public class Rebus.Sagas.SagaHelper : object {
    private ConcurrentDictionary`2<string, Dictionary`2<Type, IReadOnlyList`1<CorrelationProperty>>> _cachedCorrelationProperties;
    public SagaDataCorrelationProperties GetCorrelationProperties(Saga saga);
    public ISagaData CreateNewSagaData(Saga saga);
    private static Dictionary`2<Type, IReadOnlyList`1<CorrelationProperty>> GetCorrelationPropertiesForSagaHandler(Saga saga);
}
internal class Rebus.Serialization.Custom.CustomTypeNameConvention : object {
    private SimpleAssemblyQualifiedMessageTypeNameConvention _defaultConvention;
    private ConcurrentDictionary`2<Type, string> _typeToName;
    private ConcurrentDictionary`2<string, Type> _nameToType;
    private bool _allowFallback;
    public CustomTypeNameConvention(ConcurrentDictionary`2<Type, string> typeToName, ConcurrentDictionary`2<string, Type> nameToType, bool allowFallback);
    private static string CodeExample(Type type, string name);
    public sealed virtual string GetTypeName(Type type);
    public sealed virtual Type GetType(string name);
    private string GetListOfMappedTypes();
    [CompilerGeneratedAttribute]
internal static string <CodeExample>g__TypeText|0_0(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static string <CodeExample>g__NameText|0_1(<>c__DisplayClass0_0& );
}
public class Rebus.Serialization.Custom.CustomTypeNameConventionBuilder : object {
    private ConcurrentDictionary`2<Type, string> _typeToName;
    private ConcurrentDictionary`2<string, Type> _nameToType;
    private bool _allowFallback;
    public CustomTypeNameConventionBuilder AddWithShortNames(IEnumerable`1<Type> types);
    public CustomTypeNameConventionBuilder AddWithShortName();
    public CustomTypeNameConventionBuilder AddWithShortName(Type type);
    public CustomTypeNameConventionBuilder AddWithCustomName(string name);
    public CustomTypeNameConventionBuilder AddWithCustomName(Type type, string name);
    public CustomTypeNameConventionBuilder AllowFallbackToDefaultConvention();
    internal CustomTypeNameConvention GetConvention();
    private void AddMapping(Type type, string name);
}
[ExtensionAttribute]
public static class Rebus.Serialization.Custom.CustomTypeNameConventionExtensions : object {
    [ExtensionAttribute]
public static CustomTypeNameConventionBuilder UseCustomMessageTypeNames(StandardConfigurer`1<ISerializer> configurer);
}
public class Rebus.Serialization.DictionarySerializer : object {
    private JsonSerializerSettings _settings;
    public string SerializeToString(Dictionary`2<string, string> dictionary);
    public Dictionary`2<string, string> DeserializeFromString(string jsonText);
}
public class Rebus.Serialization.GenericJsonSerializer : object {
    private static JsonSerializerSettings Settings;
    private static GenericJsonSerializer();
    public string Serialize(T obj);
    public T Deserialize(string json);
}
public class Rebus.Serialization.HeaderSerializer : object {
    private static Encoding DefaultEncoding;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Encoding Encoding { get; public set; }
    private static HeaderSerializer();
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    public string SerializeToString(Dictionary`2<string, string> headers);
    public Byte[] Serialize(Dictionary`2<string, string> headers);
    public Dictionary`2<string, string> Deserialize(Byte[] bytes);
    public Dictionary`2<string, string> DeserializeFromString(string str);
}
public interface Rebus.Serialization.IMessageTypeNameConvention {
    public abstract virtual string GetTypeName(Type type);
    public abstract virtual Type GetType(string name);
}
public interface Rebus.Serialization.ISerializer {
    public abstract virtual Task`1<TransportMessage> Serialize(Message message);
    public abstract virtual Task`1<Message> Deserialize(TransportMessage transportMessage);
}
public enum Rebus.Serialization.Json.JsonInteroperabilityMode : Enum {
    public int value__;
    public static JsonInteroperabilityMode FullTypeInformation;
    public static JsonInteroperabilityMode PureJson;
}
internal class Rebus.Serialization.Json.JsonSerializer : object {
    public static string JsonUtf8ContentType;
    public static string JsonContentType;
    private static JsonSerializerSettings DefaultSettings;
    private static Encoding DefaultEncoding;
    private JsonSerializerSettings _settings;
    private Encoding _encoding;
    private IMessageTypeNameConvention _messageTypeNameConvention;
    private string _encodingHeaderValue;
    public JsonSerializer(IMessageTypeNameConvention messageTypeNameConvention, JsonSerializerSettings jsonSerializerSettings, Encoding encoding);
    private static JsonSerializer();
    [AsyncStateMachineAttribute("Rebus.Serialization.Json.JsonSerializer/<Serialize>d__9")]
public sealed virtual Task`1<TransportMessage> Serialize(Message message);
    [AsyncStateMachineAttribute("Rebus.Serialization.Json.JsonSerializer/<Deserialize>d__10")]
public sealed virtual Task`1<Message> Deserialize(TransportMessage transportMessage);
    private Encoding GetEncoding(string contentType);
    private Message GetMessage(TransportMessage transportMessage, Encoding bodyEncoding);
    private Type GetTypeOrNull(TransportMessage transportMessage);
    private object Deserialize(string bodyString, Type type);
    private static string Limit(string bodyString, int maxLength);
}
[ExtensionAttribute]
public static class Rebus.Serialization.Json.NewtonsoftJsonConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseNewtonsoftJson(StandardConfigurer`1<ISerializer> configurer);
    [ExtensionAttribute]
public static void UseNewtonsoftJson(StandardConfigurer`1<ISerializer> configurer, JsonInteroperabilityMode mode);
    [ExtensionAttribute]
public static void UseNewtonsoftJson(StandardConfigurer`1<ISerializer> configurer, JsonSerializerSettings settings, Encoding encoding);
    private static TypeNameHandling GetTypeNameHandling(JsonInteroperabilityMode mode);
    private static void RegisterSerializer(StandardConfigurer`1<ISerializer> configurer, JsonSerializerSettings settings, Encoding encoding);
}
[ExtensionAttribute]
public static class Rebus.Serialization.Json.SystemJsonConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseSystemTextJson(StandardConfigurer`1<ISerializer> configurer);
    [ExtensionAttribute]
public static void UseSystemTextJson(StandardConfigurer`1<ISerializer> configurer, JsonSerializerOptions settings, Encoding encoding);
    private static void RegisterSerializer(StandardConfigurer`1<ISerializer> configurer, JsonSerializerOptions settings, Encoding encoding);
}
internal class Rebus.Serialization.Json.SystemTextJsonSerializer : object {
    private static JsonSerializerOptions DefaultJsonSerializerOptions;
    private static Encoding DefaultEncoding;
    public static string JsonUtf8ContentType;
    public static string JsonContentType;
    private IMessageTypeNameConvention _messageTypeNameConvention;
    private JsonSerializerOptions _options;
    private string _encodingHeaderValue;
    private Encoding _encoding;
    public SystemTextJsonSerializer(IMessageTypeNameConvention messageTypeNameConvention, JsonSerializerOptions jsonSerializerOptions, Encoding encoding);
    private static SystemTextJsonSerializer();
    public sealed virtual Task`1<TransportMessage> Serialize(Message message);
    public sealed virtual Task`1<Message> Deserialize(TransportMessage transportMessage);
    private Encoding GetEncoding(string contentType);
    private Message GetMessage(TransportMessage transportMessage, Encoding bodyEncoding);
    private Type GetTypeOrNull(TransportMessage transportMessage);
    private object DeserializeUtf8(Byte[] body, Type type);
    private object Deserialize(string bodyString, Type type);
    private static string Limit(string bodyString, int maxLength);
}
public class Rebus.Serialization.ObjectSerializer : object {
    private static JsonSerializerSettings Settings;
    private static Encoding TextEncoding;
    private static ObjectSerializer();
    public Byte[] Serialize(object obj);
    public string SerializeToString(object obj);
    public object Deserialize(Byte[] bytes);
    public object DeserializeFromString(string str);
}
internal class Rebus.Serialization.SimpleAssemblyQualifiedMessageTypeNameConvention : object {
    private ConcurrentDictionary`2<Type, string> _typeToName;
    private ConcurrentDictionary`2<string, Type> _nameToType;
    public sealed virtual string GetTypeName(Type type);
    public sealed virtual Type GetType(string name);
}
public interface Rebus.Subscriptions.ISubscriptionStorage {
    public bool IsCentralized { get; }
    public abstract virtual Task`1<IReadOnlyList`1<string>> GetSubscriberAddresses(string topic);
    public abstract virtual Task RegisterSubscriber(string topic, string subscriberAddress);
    public abstract virtual Task UnregisterSubscriber(string topic, string subscriberAddress);
    public abstract virtual bool get_IsCentralized();
}
internal static class Rebus.Testing.TestBackdoor : object {
    [CompilerGeneratedAttribute]
private static IDataBusStorage <TestDataBusStorage>k__BackingField;
    public static IDataBusStorage TestDataBusStorage { get; private set; }
    public static void EnableTestMode(IDataBusStorage dataBusStorage);
    public static void Reset();
    [CompilerGeneratedAttribute]
public static IDataBusStorage get_TestDataBusStorage();
    [CompilerGeneratedAttribute]
private static void set_TestDataBusStorage(IDataBusStorage value);
}
public class Rebus.Threading.AsyncBottleneck : object {
    private SemaphoreSlim _semaphore;
    public AsyncBottleneck(int maxParallelOperationsToAllow);
    [AsyncStateMachineAttribute("Rebus.Threading.AsyncBottleneck/<Enter>d__2")]
public Task`1<IDisposable> Enter(CancellationToken cancellationToken);
}
public interface Rebus.Threading.IAsyncTask {
    public abstract virtual void Start();
}
public interface Rebus.Threading.IAsyncTaskFactory {
    public abstract virtual IAsyncTask Create(string description, Func`1<Task> action, bool prettyInsignificant, int intervalSeconds);
}
public class Rebus.Threading.ParallelOperationsManager : object {
    private int _maxParallelism;
    private SemaphoreSlim _semaphore;
    public bool HasPendingTasks { get; }
    public ParallelOperationsManager(int maxParallelism);
    public virtual bool get_HasPendingTasks();
    public ParallelOperation TryBegin();
    private void OperationFinished();
}
public class Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask : object {
    public static TimeSpan DefaultInterval;
    private string _description;
    private Func`1<Task> _action;
    private bool _prettyInsignificant;
    private ILog _log;
    private Timer _timer;
    private bool _disposed;
    private TimeSpan _interval;
    private object _tickExecutionLock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _executingTick;
    public TimeSpan Interval { get; public set; }
    public SystemThreadingTimerAsyncTask(string description, Func`1<Task> action, IRebusLoggerFactory rebusLoggerFactory, bool prettyInsignificant);
    private static SystemThreadingTimerAsyncTask();
    public TimeSpan get_Interval();
    public void set_Interval(TimeSpan value);
    public sealed virtual void Start();
    [AsyncStateMachineAttribute("Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTask/<Tick>d__15")]
private void Tick();
    public sealed virtual void Dispose();
    private void LogStartStop(string message, Object[] objs);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <Start>b__14_0(object obj);
}
public class Rebus.Threading.SystemThreadingTimer.SystemThreadingTimerAsyncTaskFactory : object {
    private IRebusLoggerFactory _rebusLoggerFactory;
    public SystemThreadingTimerAsyncTaskFactory(IRebusLoggerFactory rebusLoggerFactory);
    public sealed virtual IAsyncTask Create(string description, Func`1<Task> action, bool prettyInsignificant, int intervalSeconds);
}
public class Rebus.Threading.TaskParallelLibrary.TplAsyncTask : object {
    public static TimeSpan DefaultInterval;
    private CancellationTokenSource _tokenSource;
    private bool _prettyInsignificant;
    private string _description;
    private Func`1<Task> _action;
    private ILog _log;
    private TimeSpan _interval;
    private Task _task;
    public TimeSpan Interval { get; public set; }
    public TplAsyncTask(string description, Func`1<Task> action, IRebusLoggerFactory rebusLoggerFactory, bool prettyInsignificant);
    private static TplAsyncTask();
    public TimeSpan get_Interval();
    public void set_Interval(TimeSpan value);
    public sealed virtual void Start();
    public sealed virtual void Dispose();
    private void LogStartStop(string message, Object[] objs);
}
public class Rebus.Threading.TaskParallelLibrary.TplAsyncTaskFactory : object {
    private IRebusLoggerFactory _rebusLoggerFactory;
    public TplAsyncTaskFactory(IRebusLoggerFactory rebusLoggerFactory);
    public sealed virtual IAsyncTask Create(string description, Func`1<Task> action, bool prettyInsignificant, int intervalSeconds);
}
public class Rebus.Time.DefaultRebusTime : object {
    public DateTimeOffset Now { get; }
    public sealed virtual DateTimeOffset get_Now();
}
public interface Rebus.Time.IRebusTime {
    public DateTimeOffset Now { get; }
    public abstract virtual DateTimeOffset get_Now();
}
public class Rebus.Timeouts.DueMessage : object {
    private Func`1<Task> _completeAction;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Body>k__BackingField;
    public Dictionary`2<string, string> Headers { get; }
    public Byte[] Body { get; }
    public DueMessage(Dictionary`2<string, string> headers, Byte[] body, Func`1<Task> completeAction);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public Byte[] get_Body();
    [AsyncStateMachineAttribute("Rebus.Timeouts.DueMessage/<MarkAsCompleted>d__8")]
public Task MarkAsCompleted();
    public TransportMessage ToTransportMessage();
}
public class Rebus.Timeouts.DueMessagesResult : object {
    private List`1<DueMessage> _dueMessages;
    private Func`1<Task> _cleanupAction;
    public static DueMessagesResult Empty;
    public DueMessagesResult(IEnumerable`1<DueMessage> dueMessages, Func`1<Task> cleanupAction);
    private static DueMessagesResult();
    [AsyncStateMachineAttribute("Rebus.Timeouts.DueMessagesResult/<Complete>d__4")]
public Task Complete();
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<DueMessage> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [AsyncStateMachineAttribute("Rebus.Timeouts.DueMessagesResult/<CleanUp>d__8")]
private Task CleanUp();
}
public interface Rebus.Timeouts.ITimeoutManager {
    public abstract virtual Task Defer(DateTimeOffset approximateDueTime, Dictionary`2<string, string> headers, Byte[] body);
    public abstract virtual Task`1<DueMessagesResult> GetDueMessages();
}
internal class Rebus.Timeouts.ThrowingTimeoutManager : object {
    [AsyncStateMachineAttribute("Rebus.Timeouts.ThrowingTimeoutManager/<Defer>d__0")]
public sealed virtual Task Defer(DateTimeOffset approximateDueTime, Dictionary`2<string, string> headers, Byte[] body);
    [AsyncStateMachineAttribute("Rebus.Timeouts.ThrowingTimeoutManager/<GetDueMessages>d__1")]
public sealed virtual Task`1<DueMessagesResult> GetDueMessages();
}
[ExtensionAttribute]
public static class Rebus.Timeouts.TimeoutsConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseExternalTimeoutManager(StandardConfigurer`1<ITimeoutManager> configurer, string timeoutManagerAddress);
}
public class Rebus.Topic.DefaultTopicNameConvention : object {
    public sealed virtual string GetTopic(Type eventType);
}
public interface Rebus.Topic.ITopicNameConvention {
    public abstract virtual string GetTopic(Type eventType);
}
public abstract class Rebus.Transport.AbstractRebusTransport : object {
    internal static string OutgoingMessagesKey;
    private static Task`1<int> TaskCompletedResult;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    public string Address { get; }
    protected AbstractRebusTransport(string inputQueueName);
    private static AbstractRebusTransport();
    public sealed virtual Task Send(string destinationAddress, TransportMessage message, ITransactionContext context);
    public abstract virtual void CreateQueue(string address);
    public abstract virtual Task`1<TransportMessage> Receive(ITransactionContext context, CancellationToken cancellationToken);
    protected abstract virtual Task SendOutgoingMessages(IEnumerable`1<OutgoingTransportMessage> outgoingMessages, ITransactionContext context);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Address();
}
public static class Rebus.Transport.AmbientTransactionContext : object {
    private static AsyncLocal`1<ITransactionContext> AsyncLocalTransactionContext;
    public static Action`1<ITransactionContext> DefaultSetter;
    public static Func`1<ITransactionContext> DefaultGetter;
    private static Action`1<ITransactionContext> _setCurrent;
    private static Func`1<ITransactionContext> _getCurrent;
    public static ITransactionContext Current { get; }
    private static AmbientTransactionContext();
    public static ITransactionContext get_Current();
    public static void SetCurrent(ITransactionContext transactionContext);
    public static void SetAccessors(Action`1<ITransactionContext> setter, Func`1<ITransactionContext> getter);
}
public class Rebus.Transport.FileSystem.FileSystemTransport : AbstractRebusTransport {
    private static GenericJsonSerializer Serializer;
    private ConcurrentQueue`1<IncomingMessage> _incomingMessages;
    private FileSystemTransportOptions _options;
    private IRebusTime _rebusTime;
    private string _baseDirectory;
    public FileSystemTransport(string baseDirectory, string inputQueueName, FileSystemTransportOptions options, IRebusTime rebusTime);
    private static FileSystemTransport();
    public virtual void CreateQueue(string address);
    [AsyncStateMachineAttribute("Rebus.Transport.FileSystem.FileSystemTransport/<Receive>d__7")]
public virtual Task`1<TransportMessage> Receive(ITransactionContext context, CancellationToken cancellationToken);
    private void ReceiveNextBatch();
    public sealed virtual void Initialize();
    [AsyncStateMachineAttribute("Rebus.Transport.FileSystem.FileSystemTransport/<GetProperties>d__10")]
public sealed virtual Task`1<Dictionary`2<string, object>> GetProperties(CancellationToken cancellationToken);
    private string GetDirectory(string queueName);
    private static void EnsureDirectoryExists(string directoryPath);
    [AsyncStateMachineAttribute("Rebus.Transport.FileSystem.FileSystemTransport/<SendOutgoingMessages>d__15")]
protected virtual Task SendOutgoingMessages(IEnumerable`1<OutgoingTransportMessage> outgoingMessages, ITransactionContext context);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Rebus.Transport.FileSystem.FileSystemTransportConfigurationExtensions : object {
    [ExtensionAttribute]
public static FileSystemTransportOptions UseFileSystem(StandardConfigurer`1<ITransport> configurer, string baseDirectory, string inputQueueName);
    [ExtensionAttribute]
public static void UseFileSystemAsOneWayClient(StandardConfigurer`1<ITransport> configurer, string baseDirectory);
}
public class Rebus.Transport.FileSystem.FileSystemTransportOptions : object {
    [CompilerGeneratedAttribute]
private int <PrefetchCount>k__BackingField;
    internal int PrefetchCount { get; internal set; }
    public FileSystemTransportOptions Prefetch(int prefecthCount);
    [CompilerGeneratedAttribute]
internal int get_PrefetchCount();
    [CompilerGeneratedAttribute]
internal void set_PrefetchCount(int value);
}
public interface Rebus.Transport.ICanEagerCommit {
    public abstract virtual Task CommitAsync();
}
public class Rebus.Transport.InMem.InMemNetwork : object {
    private static int _networkIdCounter;
    private string _networkId;
    private ConcurrentDictionary`2<string, ConcurrentQueue`1<InMemTransportMessage>> _queues;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, object>> _subscribers;
    private ILog _log;
    public IEnumerable`1<string> Queues { get; }
    public InMemNetwork(bool outputEventsToConsole);
    public InMemNetwork(IRebusLoggerFactory loggerFactory);
    public IEnumerable`1<string> get_Queues();
    public void Reset();
    public int Count();
    public int Count(string inputQueueName);
    public void Deliver(string destinationAddress, InMemTransportMessage msg, bool alwaysQuiet);
    public InMemTransportMessage GetNextOrNull(string inputQueueName);
    public bool HasQueue(string address);
    public void CreateQueue(string address);
    public int GetCount(string address);
    public IReadOnlyList`1<InMemTransportMessage> GetMessages(string address);
    public IReadOnlyList`1<string> GetSubscribers(string topic);
    public void AddSubscriber(string topic, string subscriberAddress);
    public void RemoveSubscriber(string topic, string subscriberAddress);
    private static bool MessageIsExpired(InMemTransportMessage message);
}
public class Rebus.Transport.InMem.InMemTransport : AbstractRebusTransport {
    private InMemNetwork _network;
    private string _inputQueueAddress;
    public bool IsCentralized { get; }
    public InMemTransport(InMemNetwork network, string inputQueueAddress);
    public virtual void CreateQueue(string address);
    [AsyncStateMachineAttribute("Rebus.Transport.InMem.InMemTransport/<Receive>d__4")]
public virtual Task`1<TransportMessage> Receive(ITransactionContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Rebus.Transport.InMem.InMemTransport/<SendOutgoingMessages>d__5")]
protected virtual Task SendOutgoingMessages(IEnumerable`1<OutgoingTransportMessage> outgoingMessages, ITransactionContext context);
    public sealed virtual void Initialize();
    [AsyncStateMachineAttribute("Rebus.Transport.InMem.InMemTransport/<GetProperties>d__7")]
public sealed virtual Task`1<Dictionary`2<string, object>> GetProperties(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Rebus.Transport.InMem.InMemTransport/<GetSubscriberAddresses>d__8")]
public sealed virtual Task`1<IReadOnlyList`1<string>> GetSubscriberAddresses(string topic);
    [AsyncStateMachineAttribute("Rebus.Transport.InMem.InMemTransport/<RegisterSubscriber>d__9")]
public sealed virtual Task RegisterSubscriber(string topic, string subscriberAddress);
    [AsyncStateMachineAttribute("Rebus.Transport.InMem.InMemTransport/<UnregisterSubscriber>d__10")]
public sealed virtual Task UnregisterSubscriber(string topic, string subscriberAddress);
    public sealed virtual bool get_IsCentralized();
}
[ExtensionAttribute]
public static class Rebus.Transport.InMem.InMemTransportConfigurationExtensions : object {
    [ExtensionAttribute]
public static void UseInMemoryTransport(StandardConfigurer`1<ITransport> configurer, InMemNetwork network, string inputQueueName, bool registerSubscriptionStorage);
    [ExtensionAttribute]
public static void UseInMemoryTransportAsOneWayClient(StandardConfigurer`1<ITransport> configurer, InMemNetwork network, bool registerSubscriptionStorage);
}
public class Rebus.Transport.InMem.InMemTransportMessage : object {
    private DateTimeOffset _creationTime;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Body>k__BackingField;
    public TimeSpan Age { get; }
    public Dictionary`2<string, string> Headers { get; }
    public Byte[] Body { get; }
    public InMemTransportMessage(TransportMessage transportMessage);
    public TimeSpan get_Age();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public Byte[] get_Body();
    public TransportMessage ToTransportMessage();
}
[ExtensionAttribute]
public static class Rebus.Transport.InMem.InMemTransportMessageExtensions : object {
    [ExtensionAttribute]
public static InMemTransportMessage ToInMemTransportMessage(TransportMessage transportMessage);
}
public interface Rebus.Transport.ITransactionContext {
    public ConcurrentDictionary`2<string, object> Items { get; }
    public abstract virtual ConcurrentDictionary`2<string, object> get_Items();
    public abstract virtual void OnCommit(Func`2<ITransactionContext, Task> commitAction);
    public abstract virtual void OnRollback(Func`2<ITransactionContext, Task> abortedAction);
    public abstract virtual void OnAck(Func`2<ITransactionContext, Task> completedAction);
    public abstract virtual void OnNack(Func`2<ITransactionContext, Task> commitAction);
    public abstract virtual void OnDisposed(Action`1<ITransactionContext> disposedAction);
    public abstract virtual void SetResult(bool commit, bool ack);
}
public interface Rebus.Transport.ITransactionContextWithOwningBus {
    public IBus OwningBus { get; }
    public abstract virtual IBus get_OwningBus();
}
public interface Rebus.Transport.ITransport {
    public string Address { get; }
    public abstract virtual void CreateQueue(string address);
    public abstract virtual Task Send(string destinationAddress, TransportMessage message, ITransactionContext context);
    public abstract virtual Task`1<TransportMessage> Receive(ITransactionContext context, CancellationToken cancellationToken);
    public abstract virtual string get_Address();
}
public interface Rebus.Transport.ITransportInspector {
    public abstract virtual Task`1<Dictionary`2<string, object>> GetProperties(CancellationToken cancellationToken);
}
public class Rebus.Transport.OutgoingTransportMessage : object {
    [CompilerGeneratedAttribute]
private TransportMessage <TransportMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationAddress>k__BackingField;
    public TransportMessage TransportMessage { get; }
    public string DestinationAddress { get; }
    public OutgoingTransportMessage(TransportMessage transportMessage, string destinationAddress);
    [CompilerGeneratedAttribute]
public TransportMessage get_TransportMessage();
    [CompilerGeneratedAttribute]
public string get_DestinationAddress();
}
public class Rebus.Transport.RebusTransactionScope : object {
    private ITransactionContext _previousTransactionContext;
    private TransactionContext _transactionContext;
    public ITransactionContext TransactionContext { get; }
    public ITransactionContext get_TransactionContext();
    public Task CompleteAsync();
    public void Complete();
    public sealed virtual void Dispose();
}
public class Rebus.Transport.RebusTransactionScopeSuppressor : object {
    private ITransactionContext _previousTransactionContext;
    public sealed virtual void Dispose();
}
internal class Rebus.Transport.TransactionContext : object {
    [CompilerGeneratedAttribute]
private Func`2<ITransactionContext, Task> _onCommitted;
    [CompilerGeneratedAttribute]
private Func`2<ITransactionContext, Task> _onRollback;
    [CompilerGeneratedAttribute]
private Func`2<ITransactionContext, Task> _onAck;
    [CompilerGeneratedAttribute]
private Func`2<ITransactionContext, Task> _onNack;
    [CompilerGeneratedAttribute]
private Action`1<ITransactionContext> _onDisposed;
    private Nullable`1<bool> _mustCommit;
    private Nullable`1<bool> _mustAck;
    private bool _completed;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, object> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Exception> OnError;
    public ConcurrentDictionary`2<string, object> Items { get; }
    [CompilerGeneratedAttribute]
private void add__onCommitted(Func`2<ITransactionContext, Task> value);
    [CompilerGeneratedAttribute]
private void remove__onCommitted(Func`2<ITransactionContext, Task> value);
    [CompilerGeneratedAttribute]
private void add__onRollback(Func`2<ITransactionContext, Task> value);
    [CompilerGeneratedAttribute]
private void remove__onRollback(Func`2<ITransactionContext, Task> value);
    [CompilerGeneratedAttribute]
private void add__onAck(Func`2<ITransactionContext, Task> value);
    [CompilerGeneratedAttribute]
private void remove__onAck(Func`2<ITransactionContext, Task> value);
    [CompilerGeneratedAttribute]
private void add__onNack(Func`2<ITransactionContext, Task> value);
    [CompilerGeneratedAttribute]
private void remove__onNack(Func`2<ITransactionContext, Task> value);
    [CompilerGeneratedAttribute]
private void add__onDisposed(Action`1<ITransactionContext> value);
    [CompilerGeneratedAttribute]
private void remove__onDisposed(Action`1<ITransactionContext> value);
    [CompilerGeneratedAttribute]
public sealed virtual ConcurrentDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
public void add_OnError(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_OnError(Action`1<Exception> value);
    public sealed virtual void OnCommit(Func`2<ITransactionContext, Task> commitAction);
    public sealed virtual void OnAck(Func`2<ITransactionContext, Task> ackAction);
    public sealed virtual void OnNack(Func`2<ITransactionContext, Task> nackAction);
    public sealed virtual void OnRollback(Func`2<ITransactionContext, Task> rollbackAction);
    public sealed virtual void OnDisposed(Action`1<ITransactionContext> disposeAction);
    public sealed virtual void SetResult(bool commit, bool ack);
    [AsyncStateMachineAttribute("Rebus.Transport.TransactionContext/<CommitAsync>d__31")]
public sealed virtual Task CommitAsync();
    [AsyncStateMachineAttribute("Rebus.Transport.TransactionContext/<Complete>d__32")]
public Task Complete();
    public sealed virtual void Dispose();
    private static void ThrowCompletedException(string actionName);
    [AsyncStateMachineAttribute("Rebus.Transport.TransactionContext/<InvokeAsync>d__35")]
private Task InvokeAsync(Func`2<ITransactionContext, Task> actions);
}
[ExtensionAttribute]
public static class Rebus.Transport.TransactionContextExtensions : object {
    [ExtensionAttribute]
public static T GetOrNull(ITransactionContext context, string key);
    [ExtensionAttribute]
public static T GetOrThrow(ITransactionContext context, string key);
    [ExtensionAttribute]
public static TItem GetOrAdd(ITransactionContext context, string key, Func`1<TItem> newItemFactory);
}
internal class Rebus.Transport.TransactionContextWithOwningBus : TransactionContext {
    [CompilerGeneratedAttribute]
private IBus <OwningBus>k__BackingField;
    public IBus OwningBus { get; }
    public TransactionContextWithOwningBus(RebusBus owningBus);
    [CompilerGeneratedAttribute]
public sealed virtual IBus get_OwningBus();
}
public static class Rebus.Transport.TransportInspectorPropertyKeys : object {
    public static string QueueLength;
}
public interface Rebus.Workers.IWorker {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void Stop();
}
public interface Rebus.Workers.IWorkerFactory {
    public abstract virtual IWorker CreateWorker(string workerName);
}
internal class Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy : object {
    private TimeSpan[] _backoffTimes;
    private Options _options;
    private long _waitTimeTicks;
    public DefaultBackoffStrategy(IEnumerable`1<TimeSpan> backoffTimes, Options options);
    public sealed virtual void Wait(CancellationToken token);
    public sealed virtual Task WaitAsync(CancellationToken token);
    public sealed virtual void WaitNoMessage(CancellationToken token);
    public sealed virtual Task WaitNoMessageAsync(CancellationToken token);
    public sealed virtual void WaitError(CancellationToken token);
    [AsyncStateMachineAttribute("Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy/<WaitErrorAsync>d__9")]
public sealed virtual Task WaitErrorAsync(CancellationToken token);
    public sealed virtual void Reset();
    [AsyncStateMachineAttribute("Rebus.Workers.ThreadPoolBased.DefaultBackoffStrategy/<InnerWaitAsync>d__11")]
private Task InnerWaitAsync(CancellationToken token);
    private void InnerWait(CancellationToken token);
    private TimeSpan GetNextBackoffTime();
}
public interface Rebus.Workers.ThreadPoolBased.IBackoffStrategy {
    public abstract virtual void Wait(CancellationToken token);
    public abstract virtual Task WaitAsync(CancellationToken token);
    public abstract virtual void WaitNoMessage(CancellationToken token);
    public abstract virtual Task WaitNoMessageAsync(CancellationToken token);
    public abstract virtual void WaitError(CancellationToken token);
    public abstract virtual Task WaitErrorAsync(CancellationToken token);
    public abstract virtual void Reset();
}
internal class Rebus.Workers.ThreadPoolBased.ThreadPoolWorker : object {
    private CancellationTokenSource _cancellationTokenSource;
    private ParallelOperationsManager _parallelOperationsManager;
    private CancellationToken _busDisposalCancellationToken;
    private ManualResetEvent _workerShutDown;
    private IPipelineInvoker _pipelineInvoker;
    private IBackoffStrategy _backoffStrategy;
    private ITransport _transport;
    private Thread _workerThread;
    private RebusBus _owningBus;
    private Options _options;
    private ILog _log;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    internal ThreadPoolWorker(string name, ITransport transport, IRebusLoggerFactory rebusLoggerFactory, IPipelineInvoker pipelineInvoker, ParallelOperationsManager parallelOperationsManager, RebusBus owningBus, Options options, IBackoffStrategy backoffStrategy, CancellationToken busDisposalCancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    private void Run();
    private void TryReceiveNextMessage(CancellationToken token);
    private void LogException(Task task);
    [AsyncStateMachineAttribute("Rebus.Workers.ThreadPoolBased.ThreadPoolWorker/<TryAsyncReceive>d__18")]
private Task TryAsyncReceive(CancellationToken token, IDisposable parallelOperation);
    [AsyncStateMachineAttribute("Rebus.Workers.ThreadPoolBased.ThreadPoolWorker/<ReceiveTransportMessage>d__19")]
private Task`1<TransportMessage> ReceiveTransportMessage(CancellationToken token, ITransactionContext context);
    [AsyncStateMachineAttribute("Rebus.Workers.ThreadPoolBased.ThreadPoolWorker/<ProcessMessage>d__20")]
private Task ProcessMessage(TransactionContext context, TransportMessage transportMessage);
    public sealed virtual void Stop();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <TryAsyncReceive>b__18_0(Exception exception);
}
public class Rebus.Workers.ThreadPoolBased.ThreadPoolWorkerFactory : object {
    private ITransport _transport;
    private IRebusLoggerFactory _rebusLoggerFactory;
    private IPipelineInvoker _pipelineInvoker;
    private Options _options;
    private Func`1<RebusBus> _busGetter;
    private IBackoffStrategy _backoffStrategy;
    private CancellationToken _busDisposalCancellationToken;
    private ParallelOperationsManager _parallelOperationsManager;
    private ILog _log;
    public ThreadPoolWorkerFactory(ITransport transport, IRebusLoggerFactory rebusLoggerFactory, IPipelineInvoker pipelineInvoker, Options options, Func`1<RebusBus> busGetter, BusLifetimeEvents busLifetimeEvents, IBackoffStrategy backoffStrategy, CancellationToken busDisposalCancellationToken);
    public sealed virtual IWorker CreateWorker(string workerName);
    private void WaitForContinuationsToFinish();
}
[ExtensionAttribute]
public static class Rebus.Workers.TplBased.TplOptionsExtensions : object {
    [ExtensionAttribute]
public static void UseTplToReceiveMessages(OptionsConfigurer configurer);
}
internal class Rebus.Workers.TplBased.TplWorker : object {
    private CancellationTokenSource _cancellationTokenSource;
    private ManualResetEvent _workerStopped;
    private ParallelOperationsManager _parallelOperationsManager;
    private CancellationToken _busDisposalCancellationToken;
    private CancellationToken _cancellationToken;
    private IPipelineInvoker _pipelineInvoker;
    private IBackoffStrategy _backoffStrategy;
    private ITransport _transport;
    private RebusBus _owningBus;
    private Options _options;
    private ILog _log;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public TplWorker(string workerName, RebusBus owningBus, ITransport transport, IRebusLoggerFactory rebusLoggerFactory, IPipelineInvoker pipelineInvoker, ParallelOperationsManager parallelOperationsManager, Options options, IBackoffStrategy backoffStrategy, CancellationToken busDisposalCancellationToken);
    [AsyncStateMachineAttribute("Rebus.Workers.TplBased.TplWorker/<Run>d__12")]
private Task Run();
    [AsyncStateMachineAttribute("Rebus.Workers.TplBased.TplWorker/<TryProcessNextMessage>d__13")]
private Task TryProcessNextMessage();
    [AsyncStateMachineAttribute("Rebus.Workers.TplBased.TplWorker/<ProcessMessage>d__14")]
private Task ProcessMessage(TransactionContext context, TransportMessage transportMessage);
    [AsyncStateMachineAttribute("Rebus.Workers.TplBased.TplWorker/<ReceiveTransportMessage>d__15")]
private Task`1<TransportMessage> ReceiveTransportMessage(CancellationToken token, ITransactionContext context);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual void Stop();
    public sealed virtual void Dispose();
}
public class Rebus.Workers.TplBased.TplWorkerFactory : object {
    private ParallelOperationsManager _parallelOperationsManager;
    private CancellationToken _busDisposalCancellationToken;
    private IRebusLoggerFactory _rebusLoggerFactory;
    private IBackoffStrategy _backoffStrategy;
    private IPipelineInvoker _pipelineInvoker;
    private Func`1<RebusBus> _busGetter;
    private ITransport _transport;
    private Options _options;
    private ILog _log;
    public TplWorkerFactory(ITransport transport, IRebusLoggerFactory rebusLoggerFactory, IPipelineInvoker pipelineInvoker, Options options, Func`1<RebusBus> busGetter, BusLifetimeEvents busLifetimeEvents, IBackoffStrategy backoffStrategy, CancellationToken busDisposalCancellationToken);
    private void WaitForContinuationsToFinish();
    public sealed virtual IWorker CreateWorker(string workerName);
}
internal class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
