[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AssertionConditionAttribute : Attribute {
    private AssertionConditionType myConditionType;
    public AssertionConditionType ConditionType { get; }
    public AssertionConditionAttribute(AssertionConditionType conditionType);
    public AssertionConditionType get_ConditionType();
}
internal enum JetBrains.Annotations.AssertionConditionType : Enum {
    public int value__;
    public static AssertionConditionType IS_TRUE;
    public static AssertionConditionType IS_FALSE;
    public static AssertionConditionType IS_NULL;
    public static AssertionConditionType IS_NOT_NULL;
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.AssertionMethodAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
internal class JetBrains.Annotations.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type[] <BaseTypes>k__BackingField;
    public Type[] BaseTypes { get; private set; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type[] get_BaseTypes();
    [CompilerGeneratedAttribute]
private void set_BaseTypes(Type[] value);
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
internal class JetBrains.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FDT>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    public string FDT { get; private set; }
    public bool ForceFullStates { get; private set; }
    public ContractAnnotationAttribute(string fdt);
    public ContractAnnotationAttribute(string fdt, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_FDT();
    [CompilerGeneratedAttribute]
private void set_FDT(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    [CompilerGeneratedAttribute]
private void set_ForceFullStates(bool value);
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithMembers;
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InstantHandleAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.LinqTunnelAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; private set; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; private set; }
    public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.NoEnumerationAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; private set; }
    public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.PathReferenceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    public string BasePath { get; private set; }
    public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
private void set_BasePath(string value);
}
[MeansImplicitUseAttribute]
internal class JetBrains.Annotations.PublicAPIAttribute : Attribute {
    public PublicAPIAttribute(string comment);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.PureAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
internal class JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    public string FormatParameterName { get; private set; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
    [CompilerGeneratedAttribute]
private void set_FormatParameterName(string value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.TerminatesProgramAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; private set; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; private set; }
    [UsedImplicitlyAttribute]
public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [UsedImplicitlyAttribute]
public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    [UsedImplicitlyAttribute]
public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
public class Remotion.Linq.Clauses.AdditionalFromClause : FromClauseBase {
    public AdditionalFromClause(string itemName, Type itemType, Expression fromExpression);
    public sealed virtual void Accept(IQueryModelVisitor visitor, QueryModel queryModel, int index);
    public AdditionalFromClause Clone(CloneContext cloneContext);
    private sealed virtual override IBodyClause Remotion.Linq.Clauses.IBodyClause.Clone(CloneContext cloneContext);
}
public class Remotion.Linq.Clauses.CloneContext : object {
    [CompilerGeneratedAttribute]
private QuerySourceMapping <QuerySourceMapping>k__BackingField;
    public QuerySourceMapping QuerySourceMapping { get; private set; }
    public CloneContext(QuerySourceMapping querySourceMapping);
    [CompilerGeneratedAttribute]
public QuerySourceMapping get_QuerySourceMapping();
    [CompilerGeneratedAttribute]
private void set_QuerySourceMapping(QuerySourceMapping value);
}
public interface Remotion.Linq.Clauses.Expressions.IPartialEvaluationExceptionExpressionVisitor {
    public abstract virtual Expression VisitPartialEvaluationException(PartialEvaluationExceptionExpression partialEvaluationExceptionExpression);
}
public interface Remotion.Linq.Clauses.Expressions.IVBSpecificExpressionVisitor {
    public abstract virtual Expression VisitVBStringComparison(VBStringComparisonExpression vbStringComparisonExpression);
}
public class Remotion.Linq.Clauses.Expressions.PartialEvaluationExceptionExpression : Expression {
    private Exception _exception;
    private Expression _evaluatedExpression;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Exception Exception { get; }
    public Expression EvaluatedExpression { get; }
    public bool CanReduce { get; }
    public PartialEvaluationExceptionExpression(Exception exception, Expression evaluatedExpression);
    public virtual Type get_Type();
    public virtual ExpressionType get_NodeType();
    public Exception get_Exception();
    public Expression get_EvaluatedExpression();
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected virtual Expression Accept(ExpressionVisitor visitor);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.Expressions.QuerySourceReferenceExpression : Expression {
    private Type _type;
    [CompilerGeneratedAttribute]
private IQuerySource <ReferencedQuerySource>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public IQuerySource ReferencedQuerySource { get; private set; }
    public QuerySourceReferenceExpression(IQuerySource querySource);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public IQuerySource get_ReferencedQuerySource();
    [CompilerGeneratedAttribute]
private void set_ReferencedQuerySource(IQuerySource value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual Expression Accept(ExpressionVisitor visitor);
}
public class Remotion.Linq.Clauses.Expressions.SubQueryExpression : Expression {
    private Type _type;
    [CompilerGeneratedAttribute]
private QueryModel <QueryModel>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public QueryModel QueryModel { get; private set; }
    public SubQueryExpression(QueryModel queryModel);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public QueryModel get_QueryModel();
    [CompilerGeneratedAttribute]
private void set_QueryModel(QueryModel value);
    public virtual string ToString();
    protected virtual Expression Accept(ExpressionVisitor visitor);
}
public class Remotion.Linq.Clauses.Expressions.VBStringComparisonExpression : Expression {
    private Expression _comparison;
    private bool _textCompare;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Comparison { get; }
    public bool TextCompare { get; }
    public bool CanReduce { get; }
    public VBStringComparisonExpression(Expression comparison, bool textCompare);
    public virtual Type get_Type();
    public virtual ExpressionType get_NodeType();
    public Expression get_Comparison();
    public bool get_TextCompare();
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected virtual Expression Accept(ExpressionVisitor visitor);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ExpressionVisitors.AccessorFindingExpressionVisitor : RelinqExpressionVisitor {
    private Expression _searchedExpression;
    private ParameterExpression _inputParameter;
    private Stack`1<Expression> _accessorPathStack;
    [CompilerGeneratedAttribute]
private LambdaExpression <AccessorPath>k__BackingField;
    private LambdaExpression AccessorPath { get; private set; }
    private AccessorFindingExpressionVisitor(Expression searchedExpression, ParameterExpression inputParameter);
    public static LambdaExpression FindAccessorLambda(Expression searchedExpression, Expression fullExpression, ParameterExpression inputParameter);
    [CompilerGeneratedAttribute]
private LambdaExpression get_AccessorPath();
    [CompilerGeneratedAttribute]
private void set_AccessorPath(LambdaExpression value);
    public virtual Expression Visit(Expression expression);
    protected virtual Expression VisitNew(NewExpression expression);
    protected virtual Expression VisitUnary(UnaryExpression expression);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding memberBinding);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment memberAssigment);
    private void CheckAndVisitMemberAssignment(MemberInfo member, Expression expression);
    private Expression GetMemberAccessExpression(Expression input, MemberInfo member);
    private Expression EnsureMemberIsAccessibleFromInput(Expression input, MemberInfo member);
}
public class Remotion.Linq.Clauses.ExpressionVisitors.CloningExpressionVisitor : RelinqExpressionVisitor {
    private QuerySourceMapping _querySourceMapping;
    private CloningExpressionVisitor(QuerySourceMapping querySourceMapping);
    public static Expression AdjustExpressionAfterCloning(Expression expression, QuerySourceMapping querySourceMapping);
    protected internal virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    protected internal virtual Expression VisitSubQuery(SubQueryExpression expression);
}
public class Remotion.Linq.Clauses.ExpressionVisitors.ReferenceReplacingExpressionVisitor : RelinqExpressionVisitor {
    private QuerySourceMapping _querySourceMapping;
    private bool _throwOnUnmappedReferences;
    private ReferenceReplacingExpressionVisitor(QuerySourceMapping querySourceMapping, bool throwOnUnmappedReferences);
    public static Expression ReplaceClauseReferences(Expression expression, QuerySourceMapping querySourceMapping, bool throwOnUnmappedReferences);
    protected internal virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    protected internal virtual Expression VisitSubQuery(SubQueryExpression expression);
    [CompilerGeneratedAttribute]
private Expression <VisitSubQuery>b__5_0(Expression ex);
}
public class Remotion.Linq.Clauses.ExpressionVisitors.ReverseResolvingExpressionVisitor : RelinqExpressionVisitor {
    private Expression _itemExpression;
    private ParameterExpression _lambdaParameter;
    private ReverseResolvingExpressionVisitor(Expression itemExpression, ParameterExpression lambdaParameter);
    public static LambdaExpression ReverseResolve(Expression itemExpression, Expression resolvedExpression);
    public static LambdaExpression ReverseResolveLambda(Expression itemExpression, LambdaExpression resolvedExpression, int parameterInsertionPosition);
    protected internal virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
}
public abstract class Remotion.Linq.Clauses.FromClauseBase : object {
    private string _itemName;
    private Type _itemType;
    private Expression _fromExpression;
    public string ItemName { get; public set; }
    public Type ItemType { get; public set; }
    public Expression FromExpression { get; public set; }
    internal FromClauseBase(string itemName, Type itemType, Expression fromExpression);
    public sealed virtual string get_ItemName();
    public void set_ItemName(string value);
    public sealed virtual Type get_ItemType();
    public void set_ItemType(Type value);
    public sealed virtual Expression get_FromExpression();
    public void set_FromExpression(Expression value);
    public virtual void CopyFromSource(IFromClause source);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.GroupJoinClause : object {
    private string _itemName;
    private Type _itemType;
    private JoinClause _joinClause;
    public string ItemName { get; public set; }
    public Type ItemType { get; public set; }
    public JoinClause JoinClause { get; public set; }
    public GroupJoinClause(string itemName, Type itemType, JoinClause joinClause);
    public sealed virtual string get_ItemName();
    public void set_ItemName(string value);
    public sealed virtual Type get_ItemType();
    public void set_ItemType(Type value);
    public JoinClause get_JoinClause();
    public void set_JoinClause(JoinClause value);
    public sealed virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public sealed virtual void Accept(IQueryModelVisitor visitor, QueryModel queryModel, int index);
    public GroupJoinClause Clone(CloneContext cloneContext);
    private sealed virtual override IBodyClause Remotion.Linq.Clauses.IBodyClause.Clone(CloneContext cloneContext);
    public virtual string ToString();
}
public interface Remotion.Linq.Clauses.IBodyClause {
    public abstract virtual void Accept(IQueryModelVisitor visitor, QueryModel queryModel, int index);
    public abstract virtual IBodyClause Clone(CloneContext cloneContext);
}
public interface Remotion.Linq.Clauses.IClause {
    public abstract virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
}
public interface Remotion.Linq.Clauses.IFromClause {
    public Expression FromExpression { get; }
    public abstract virtual Expression get_FromExpression();
    public abstract virtual void CopyFromSource(IFromClause source);
}
public interface Remotion.Linq.Clauses.IQuerySource {
    public string ItemName { get; }
    public Type ItemType { get; }
    public abstract virtual string get_ItemName();
    public abstract virtual Type get_ItemType();
}
public class Remotion.Linq.Clauses.JoinClause : object {
    private Type _itemType;
    private string _itemName;
    private Expression _innerSequence;
    private Expression _outerKeySelector;
    private Expression _innerKeySelector;
    public Type ItemType { get; public set; }
    public string ItemName { get; public set; }
    public Expression InnerSequence { get; public set; }
    public Expression OuterKeySelector { get; public set; }
    public Expression InnerKeySelector { get; public set; }
    public JoinClause(string itemName, Type itemType, Expression innerSequence, Expression outerKeySelector, Expression innerKeySelector);
    public sealed virtual Type get_ItemType();
    public void set_ItemType(Type value);
    public sealed virtual string get_ItemName();
    public void set_ItemName(string value);
    public Expression get_InnerSequence();
    public void set_InnerSequence(Expression value);
    public Expression get_OuterKeySelector();
    public void set_OuterKeySelector(Expression value);
    public Expression get_InnerKeySelector();
    public void set_InnerKeySelector(Expression value);
    public sealed virtual void Accept(IQueryModelVisitor visitor, QueryModel queryModel, int index);
    public void Accept(IQueryModelVisitor visitor, QueryModel queryModel, GroupJoinClause groupJoinClause);
    public JoinClause Clone(CloneContext cloneContext);
    private sealed virtual override IBodyClause Remotion.Linq.Clauses.IBodyClause.Clone(CloneContext cloneContext);
    public sealed virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.MainFromClause : FromClauseBase {
    public MainFromClause(string itemName, Type itemType, Expression fromExpression);
    public void Accept(IQueryModelVisitor visitor, QueryModel queryModel);
    public MainFromClause Clone(CloneContext cloneContext);
}
public class Remotion.Linq.Clauses.OrderByClause : object {
    [CompilerGeneratedAttribute]
private ObservableCollection`1<Ordering> <Orderings>k__BackingField;
    public ObservableCollection`1<Ordering> Orderings { get; private set; }
    [CompilerGeneratedAttribute]
public ObservableCollection`1<Ordering> get_Orderings();
    [CompilerGeneratedAttribute]
private void set_Orderings(ObservableCollection`1<Ordering> value);
    public sealed virtual void Accept(IQueryModelVisitor visitor, QueryModel queryModel, int index);
    public sealed virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public OrderByClause Clone(CloneContext cloneContext);
    private sealed virtual override IBodyClause Remotion.Linq.Clauses.IBodyClause.Clone(CloneContext cloneContext);
    public virtual string ToString();
    private void Orderings_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
}
public class Remotion.Linq.Clauses.Ordering : object {
    private Expression _expression;
    [CompilerGeneratedAttribute]
private OrderingDirection <OrderingDirection>k__BackingField;
    public Expression Expression { get; public set; }
    public OrderingDirection OrderingDirection { get; public set; }
    public Ordering(Expression expression, OrderingDirection direction);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public OrderingDirection get_OrderingDirection();
    [CompilerGeneratedAttribute]
public void set_OrderingDirection(OrderingDirection value);
    public void Accept(IQueryModelVisitor visitor, QueryModel queryModel, OrderByClause orderByClause, int index);
    public Ordering Clone(CloneContext cloneContext);
    public void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public enum Remotion.Linq.Clauses.OrderingDirection : Enum {
    public int value__;
    public static OrderingDirection Asc;
    public static OrderingDirection Desc;
}
public class Remotion.Linq.Clauses.QuerySourceMapping : object {
    private Dictionary`2<IQuerySource, Expression> _lookup;
    public bool ContainsMapping(IQuerySource querySource);
    public void AddMapping(IQuerySource querySource, Expression expression);
    public void RemoveMapping(IQuerySource querySource);
    public void ReplaceMapping(IQuerySource querySource, Expression expression);
    public Expression GetExpression(IQuerySource querySource);
}
public abstract class Remotion.Linq.Clauses.ResultOperatorBase : object {
    public abstract virtual IStreamedData ExecuteInMemory(IStreamedData input);
    public abstract virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    public abstract virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public void Accept(IQueryModelVisitor visitor, QueryModel queryModel, int index);
    public abstract virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    protected object InvokeExecuteMethod(MethodInfo method, object input);
    protected T GetConstantValueFromExpression(string expressionName, Expression expression);
    protected void CheckSequenceItemType(StreamedSequenceInfo inputInfo, Type expectedItemType);
}
public class Remotion.Linq.Clauses.ResultOperators.AggregateFromSeedResultOperator : ValueFromSequenceResultOperatorBase {
    private static MethodInfo s_executeMethod;
    private Expression _seed;
    private LambdaExpression _func;
    private LambdaExpression _resultSelector;
    public LambdaExpression Func { get; public set; }
    public Expression Seed { get; public set; }
    public LambdaExpression OptionalResultSelector { get; public set; }
    public AggregateFromSeedResultOperator(Expression seed, LambdaExpression func, LambdaExpression optionalResultSelector);
    private static AggregateFromSeedResultOperator();
    public LambdaExpression get_Func();
    public void set_Func(LambdaExpression value);
    public Expression get_Seed();
    public void set_Seed(Expression value);
    public LambdaExpression get_OptionalResultSelector();
    public void set_OptionalResultSelector(LambdaExpression value);
    public T GetConstantSeed();
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public StreamedValue ExecuteAggregateInMemory(StreamedSequence input);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    private StreamedValueInfo GetOutputDataInfo(StreamedSequenceInfo sequenceInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
    private Type GetResultType();
    private bool DescribesValidFuncType(LambdaExpression value);
    private bool DescribesValidResultSelectorType(LambdaExpression value);
}
public class Remotion.Linq.Clauses.ResultOperators.AggregateResultOperator : ValueFromSequenceResultOperatorBase {
    private LambdaExpression _func;
    public LambdaExpression Func { get; public set; }
    public AggregateResultOperator(LambdaExpression func);
    public LambdaExpression get_Func();
    public void set_Func(LambdaExpression value);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    private StreamedValueInfo GetOutputDataInfo(StreamedSequenceInfo sequenceInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
    private bool DescribesValidFuncType(LambdaExpression value);
    private Type GetExpectedItemType();
}
public class Remotion.Linq.Clauses.ResultOperators.AllResultOperator : ValueFromSequenceResultOperatorBase {
    private Expression _predicate;
    public Expression Predicate { get; public set; }
    public AllResultOperator(Expression predicate);
    public Expression get_Predicate();
    public void set_Predicate(Expression value);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    private StreamedValueInfo GetOutputDataInfo(StreamedSequenceInfo sequenceInfo);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.AnyResultOperator : ValueFromSequenceResultOperatorBase {
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    private StreamedValueInfo GetOutputDataInfo(StreamedSequenceInfo sequenceInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.AsQueryableResultOperator : SequenceTypePreservingResultOperatorBase {
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.AverageResultOperator : ValueFromSequenceResultOperatorBase {
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    private StreamedValueInfo GetOutputDataInfo(StreamedSequenceInfo sequenceInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
    private Type GetResultType(Type inputItemType);
}
public class Remotion.Linq.Clauses.ResultOperators.CastResultOperator : SequenceFromSequenceResultOperatorBase {
    private static MethodInfo s_enumerableCastMethod;
    private Type _castItemType;
    public Type CastItemType { get; public set; }
    public CastResultOperator(Type castItemType);
    private static CastResultOperator();
    public Type get_CastItemType();
    public void set_CastItemType(Type value);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
    private UnaryExpression GetNewItemExpression(Expression inputItemExpression);
}
public abstract class Remotion.Linq.Clauses.ResultOperators.ChoiceResultOperatorBase : ValueFromSequenceResultOperatorBase {
    [CompilerGeneratedAttribute]
private bool <ReturnDefaultWhenEmpty>k__BackingField;
    public bool ReturnDefaultWhenEmpty { get; public set; }
    protected ChoiceResultOperatorBase(bool returnDefaultWhenEmpty);
    [CompilerGeneratedAttribute]
public bool get_ReturnDefaultWhenEmpty();
    [CompilerGeneratedAttribute]
public void set_ReturnDefaultWhenEmpty(bool value);
    public sealed virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    protected StreamedValueInfo GetOutputDataInfo(StreamedSequenceInfo inputSequenceInfo);
}
public class Remotion.Linq.Clauses.ResultOperators.ConcatResultOperator : SequenceFromSequenceResultOperatorBase {
    private string _itemName;
    private Type _itemType;
    private Expression _source2;
    public string ItemName { get; public set; }
    public Type ItemType { get; public set; }
    public Expression Source2 { get; public set; }
    public ConcatResultOperator(string itemName, Type itemType, Expression source2);
    public sealed virtual string get_ItemName();
    public void set_ItemName(string value);
    public sealed virtual Type get_ItemType();
    public void set_ItemType(Type value);
    public Expression get_Source2();
    public void set_Source2(Expression value);
    public IEnumerable GetConstantSource2();
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.ContainsResultOperator : ValueFromSequenceResultOperatorBase {
    private Expression _item;
    public Expression Item { get; public set; }
    public ContainsResultOperator(Expression item);
    public Expression get_Item();
    public void set_Item(Expression value);
    public T GetConstantItem();
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    private StreamedValueInfo GetOutputDataInfo(StreamedSequenceInfo inputInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.CountResultOperator : ValueFromSequenceResultOperatorBase {
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    private StreamedValueInfo GetOutputDataInfo(StreamedSequenceInfo sequenceInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.DefaultIfEmptyResultOperator : SequenceTypePreservingResultOperatorBase {
    [CompilerGeneratedAttribute]
private Expression <OptionalDefaultValue>k__BackingField;
    public Expression OptionalDefaultValue { get; public set; }
    public DefaultIfEmptyResultOperator(Expression optionalDefaultValue);
    [CompilerGeneratedAttribute]
public Expression get_OptionalDefaultValue();
    [CompilerGeneratedAttribute]
public void set_OptionalDefaultValue(Expression value);
    public object GetConstantOptionalDefaultValue();
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.DistinctResultOperator : SequenceTypePreservingResultOperatorBase {
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.ExceptResultOperator : SequenceTypePreservingResultOperatorBase {
    private Expression _source2;
    public Expression Source2 { get; public set; }
    public ExceptResultOperator(Expression source2);
    public Expression get_Source2();
    public void set_Source2(Expression value);
    public IEnumerable`1<T> GetConstantSource2();
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.FirstResultOperator : ChoiceResultOperatorBase {
    public FirstResultOperator(bool returnDefaultWhenEmpty);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.GroupResultOperator : SequenceFromSequenceResultOperatorBase {
    private static MethodInfo s_executeMethod;
    private string _itemName;
    private Expression _keySelector;
    private Expression _elementSelector;
    public string ItemName { get; public set; }
    public Type ItemType { get; }
    public Expression KeySelector { get; public set; }
    public Expression ElementSelector { get; public set; }
    public GroupResultOperator(string itemName, Expression keySelector, Expression elementSelector);
    private static GroupResultOperator();
    public sealed virtual string get_ItemName();
    public void set_ItemName(string value);
    public sealed virtual Type get_ItemType();
    public Expression get_KeySelector();
    public void set_KeySelector(Expression value);
    public Expression get_ElementSelector();
    public void set_ElementSelector(Expression value);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public StreamedSequence ExecuteGroupingInMemory(StreamedSequence input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.IntersectResultOperator : SequenceTypePreservingResultOperatorBase {
    private Expression _source2;
    public Expression Source2 { get; public set; }
    public IntersectResultOperator(Expression source2);
    public Expression get_Source2();
    public void set_Source2(Expression value);
    public IEnumerable`1<T> GetConstantSource2();
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.LastResultOperator : ChoiceResultOperatorBase {
    public LastResultOperator(bool returnDefaultWhenEmpty);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.LongCountResultOperator : ValueFromSequenceResultOperatorBase {
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    private StreamedValueInfo GetOutputDataInfo(StreamedSequenceInfo sequenceInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.MaxResultOperator : ChoiceResultOperatorBase {
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.MinResultOperator : ChoiceResultOperatorBase {
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.OfTypeResultOperator : SequenceFromSequenceResultOperatorBase {
    private static MethodInfo s_enumerableOfTypeMethod;
    private Type _searchedItemType;
    public Type SearchedItemType { get; public set; }
    public OfTypeResultOperator(Type searchedItemType);
    private static OfTypeResultOperator();
    public Type get_SearchedItemType();
    public void set_SearchedItemType(Type value);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
    private UnaryExpression GetNewItemExpression(Expression inputItemExpression);
}
public class Remotion.Linq.Clauses.ResultOperators.ReverseResultOperator : SequenceTypePreservingResultOperatorBase {
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public abstract class Remotion.Linq.Clauses.ResultOperators.SequenceFromSequenceResultOperatorBase : ResultOperatorBase {
    private static MethodInfo s_executeMethod;
    private static SequenceFromSequenceResultOperatorBase();
    public abstract virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public sealed virtual IStreamedData ExecuteInMemory(IStreamedData input);
}
public abstract class Remotion.Linq.Clauses.ResultOperators.SequenceTypePreservingResultOperatorBase : SequenceFromSequenceResultOperatorBase {
    public sealed virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    protected StreamedSequenceInfo GetOutputDataInfo(StreamedSequenceInfo inputSequenceInfo);
}
public class Remotion.Linq.Clauses.ResultOperators.SingleResultOperator : ChoiceResultOperatorBase {
    public SingleResultOperator(bool returnDefaultWhenEmpty);
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.SkipResultOperator : SequenceTypePreservingResultOperatorBase {
    private Expression _count;
    public Expression Count { get; public set; }
    public SkipResultOperator(Expression count);
    public Expression get_Count();
    public void set_Count(Expression value);
    public int GetConstantCount();
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.SumResultOperator : ValueFromSequenceResultOperatorBase {
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedValue ExecuteInMemory(StreamedSequence input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    private IStreamedDataInfo GetOutputDataInfo(StreamedSequenceInfo sequenceInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.TakeResultOperator : SequenceTypePreservingResultOperatorBase {
    private Expression _count;
    public Expression Count { get; public set; }
    public TakeResultOperator(Expression count);
    public Expression get_Count();
    public void set_Count(Expression value);
    public int GetConstantCount();
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public class Remotion.Linq.Clauses.ResultOperators.UnionResultOperator : SequenceFromSequenceResultOperatorBase {
    private string _itemName;
    private Type _itemType;
    private Expression _source2;
    public string ItemName { get; public set; }
    public Type ItemType { get; public set; }
    public Expression Source2 { get; public set; }
    public UnionResultOperator(string itemName, Type itemType, Expression source2);
    public sealed virtual string get_ItemName();
    public void set_ItemName(string value);
    public sealed virtual Type get_ItemType();
    public void set_ItemType(Type value);
    public Expression get_Source2();
    public void set_Source2(Expression value);
    public IEnumerable GetConstantSource2();
    public virtual ResultOperatorBase Clone(CloneContext cloneContext);
    public virtual StreamedSequence ExecuteInMemory(StreamedSequence input);
    public virtual IStreamedDataInfo GetOutputDataInfo(IStreamedDataInfo inputInfo);
    public virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
}
public abstract class Remotion.Linq.Clauses.ResultOperators.ValueFromSequenceResultOperatorBase : ResultOperatorBase {
    private static MethodInfo s_executeMethod;
    private static ValueFromSequenceResultOperatorBase();
    public abstract virtual StreamedValue ExecuteInMemory(StreamedSequence sequence);
    public sealed virtual IStreamedData ExecuteInMemory(IStreamedData input);
}
public class Remotion.Linq.Clauses.SelectClause : object {
    private Expression _selector;
    public Expression Selector { get; public set; }
    public SelectClause(Expression selector);
    public Expression get_Selector();
    public void set_Selector(Expression value);
    public void Accept(IQueryModelVisitor visitor, QueryModel queryModel);
    public SelectClause Clone(CloneContext cloneContext);
    public sealed virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public virtual string ToString();
    public StreamedSequenceInfo GetOutputDataInfo();
}
public interface Remotion.Linq.Clauses.StreamedData.IStreamedData {
    public IStreamedDataInfo DataInfo { get; }
    public object Value { get; }
    public abstract virtual IStreamedDataInfo get_DataInfo();
    public abstract virtual object get_Value();
}
public interface Remotion.Linq.Clauses.StreamedData.IStreamedDataInfo {
    public Type DataType { get; }
    public abstract virtual Type get_DataType();
    public abstract virtual IStreamedData ExecuteQueryModel(QueryModel queryModel, IQueryExecutor executor);
    public abstract virtual IStreamedDataInfo AdjustDataType(Type dataType);
}
public class Remotion.Linq.Clauses.StreamedData.StreamedScalarValueInfo : StreamedValueInfo {
    private static MethodInfo s_executeMethod;
    public StreamedScalarValueInfo(Type dataType);
    private static StreamedScalarValueInfo();
    public virtual IStreamedData ExecuteQueryModel(QueryModel queryModel, IQueryExecutor executor);
    protected virtual StreamedValueInfo CloneWithNewDataType(Type dataType);
    public object ExecuteScalarQueryModel(QueryModel queryModel, IQueryExecutor executor);
}
public class Remotion.Linq.Clauses.StreamedData.StreamedSequence : object {
    [CompilerGeneratedAttribute]
private StreamedSequenceInfo <DataInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable <Sequence>k__BackingField;
    [NotNullAttribute]
public StreamedSequenceInfo DataInfo { get; private set; }
    private object Remotion.Linq.Clauses.StreamedData.IStreamedData.Value { get; }
    private IStreamedDataInfo Remotion.Linq.Clauses.StreamedData.IStreamedData.DataInfo { get; }
    [NotNullAttribute]
public IEnumerable Sequence { get; private set; }
    public StreamedSequence(IEnumerable sequence, StreamedSequenceInfo streamedSequenceInfo);
    [CompilerGeneratedAttribute]
public StreamedSequenceInfo get_DataInfo();
    [CompilerGeneratedAttribute]
private void set_DataInfo(StreamedSequenceInfo value);
    private sealed virtual override object Remotion.Linq.Clauses.StreamedData.IStreamedData.get_Value();
    private sealed virtual override IStreamedDataInfo Remotion.Linq.Clauses.StreamedData.IStreamedData.get_DataInfo();
    [CompilerGeneratedAttribute]
public IEnumerable get_Sequence();
    [CompilerGeneratedAttribute]
private void set_Sequence(IEnumerable value);
    [NotNullAttribute]
public IEnumerable`1<T> GetTypedSequence();
}
public class Remotion.Linq.Clauses.StreamedData.StreamedSequenceInfo : object {
    private static MethodInfo s_executeMethod;
    [CompilerGeneratedAttribute]
private Type <ResultItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <ItemExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DataType>k__BackingField;
    public Type ResultItemType { get; private set; }
    public Expression ItemExpression { get; private set; }
    public Type DataType { get; private set; }
    public StreamedSequenceInfo(Type dataType, Expression itemExpression);
    private static StreamedSequenceInfo();
    [CompilerGeneratedAttribute]
public Type get_ResultItemType();
    [CompilerGeneratedAttribute]
private void set_ResultItemType(Type value);
    [CompilerGeneratedAttribute]
public Expression get_ItemExpression();
    [CompilerGeneratedAttribute]
private void set_ItemExpression(Expression value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DataType();
    [CompilerGeneratedAttribute]
private void set_DataType(Type value);
    public sealed virtual IStreamedDataInfo AdjustDataType(Type dataType);
    public sealed virtual IStreamedData ExecuteQueryModel(QueryModel queryModel, IQueryExecutor executor);
    public IEnumerable ExecuteCollectionQueryModel(QueryModel queryModel, IQueryExecutor executor);
    public sealed virtual bool Equals(object obj);
    public sealed virtual bool Equals(IStreamedDataInfo obj);
    public virtual int GetHashCode();
}
public class Remotion.Linq.Clauses.StreamedData.StreamedSingleValueInfo : StreamedValueInfo {
    private static MethodInfo s_executeMethod;
    private bool _returnDefaultWhenEmpty;
    public bool ReturnDefaultWhenEmpty { get; }
    public StreamedSingleValueInfo(Type dataType, bool returnDefaultWhenEmpty);
    private static StreamedSingleValueInfo();
    public bool get_ReturnDefaultWhenEmpty();
    public virtual IStreamedData ExecuteQueryModel(QueryModel queryModel, IQueryExecutor executor);
    protected virtual StreamedValueInfo CloneWithNewDataType(Type dataType);
    public object ExecuteSingleQueryModel(QueryModel queryModel, IQueryExecutor executor);
    public virtual bool Equals(IStreamedDataInfo obj);
    public virtual int GetHashCode();
}
public class Remotion.Linq.Clauses.StreamedData.StreamedValue : object {
    [CompilerGeneratedAttribute]
private StreamedValueInfo <DataInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public StreamedValueInfo DataInfo { get; private set; }
    public object Value { get; private set; }
    private IStreamedDataInfo Remotion.Linq.Clauses.StreamedData.IStreamedData.DataInfo { get; }
    public StreamedValue(object value, StreamedValueInfo streamedValueInfo);
    [CompilerGeneratedAttribute]
public StreamedValueInfo get_DataInfo();
    [CompilerGeneratedAttribute]
private void set_DataInfo(StreamedValueInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    private sealed virtual override IStreamedDataInfo Remotion.Linq.Clauses.StreamedData.IStreamedData.get_DataInfo();
    public T GetTypedValue();
}
public abstract class Remotion.Linq.Clauses.StreamedData.StreamedValueInfo : object {
    [CompilerGeneratedAttribute]
private Type <DataType>k__BackingField;
    public Type DataType { get; private set; }
    internal StreamedValueInfo(Type dataType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DataType();
    [CompilerGeneratedAttribute]
private void set_DataType(Type value);
    public abstract virtual IStreamedData ExecuteQueryModel(QueryModel queryModel, IQueryExecutor executor);
    protected abstract virtual StreamedValueInfo CloneWithNewDataType(Type dataType);
    public virtual IStreamedDataInfo AdjustDataType(Type dataType);
    public sealed virtual bool Equals(object obj);
    public virtual bool Equals(IStreamedDataInfo obj);
    public virtual int GetHashCode();
}
public class Remotion.Linq.Clauses.WhereClause : object {
    private Expression _predicate;
    public Expression Predicate { get; public set; }
    public WhereClause(Expression predicate);
    public Expression get_Predicate();
    public void set_Predicate(Expression value);
    public sealed virtual void Accept(IQueryModelVisitor visitor, QueryModel queryModel, int index);
    public sealed virtual void TransformExpressions(Func`2<Expression, Expression> transformation);
    public WhereClause Clone(CloneContext cloneContext);
    private sealed virtual override IBodyClause Remotion.Linq.Clauses.IBodyClause.Clone(CloneContext cloneContext);
    public virtual string ToString();
}
internal class Remotion.Linq.Collections.ChangeResistantObservableCollectionEnumerator`1 : object {
    private ObservableCollection`1<T> _collection;
    private int _index;
    private bool _disposed;
    public int Index { get; }
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ChangeResistantObservableCollectionEnumerator`1(ObservableCollection`1<T> collection);
    public int get_Index();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private void Collection_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
}
internal class Remotion.Linq.Collections.IndexValuePair`1 : ValueType {
    private ChangeResistantObservableCollectionEnumerator`1<T> _enumerator;
    public int Index { get; }
    public T Value { get; }
    public IndexValuePair`1(ChangeResistantObservableCollectionEnumerator`1<T> enumerator);
    public int get_Index();
    public T get_Value();
}
[ExtensionAttribute]
internal static class Remotion.Linq.Collections.MultiDictionaryExtensions : object {
    [ExtensionAttribute]
public static void Add(IDictionary`2<TKey, ICollection`1<TValue>> dictionary, TKey key, TValue item);
    [ExtensionAttribute]
public static int CountValues(IDictionary`2<TKey, ICollection`1<TValue>> dictionary);
}
[ExtensionAttribute]
internal static class Remotion.Linq.Collections.ObservableCollectionExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> AsChangeResistantEnumerable(ObservableCollection`1<T> collection);
    [IteratorStateMachineAttribute("Remotion.Linq.Collections.ObservableCollectionExtensions/<AsChangeResistantEnumerableWithIndex>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<IndexValuePair`1<T>> AsChangeResistantEnumerableWithIndex(ObservableCollection`1<T> collection);
}
public class Remotion.Linq.DefaultQueryProvider : QueryProviderBase {
    private Type _queryableType;
    public Type QueryableType { get; }
    public DefaultQueryProvider(Type queryableType, IQueryParser queryParser, IQueryExecutor executor);
    private void CheckQueryableType(Type queryableType);
    public Type get_QueryableType();
    public virtual IQueryable`1<T> CreateQuery(Expression expression);
}
public interface Remotion.Linq.IQueryExecutor {
    public abstract virtual T ExecuteScalar(QueryModel queryModel);
    public abstract virtual T ExecuteSingle(QueryModel queryModel, bool returnDefaultWhenEmpty);
    public abstract virtual IEnumerable`1<T> ExecuteCollection(QueryModel queryModel);
}
public interface Remotion.Linq.IQueryModelVisitor {
    public abstract virtual void VisitQueryModel(QueryModel queryModel);
    public abstract virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
    public abstract virtual void VisitAdditionalFromClause(AdditionalFromClause fromClause, QueryModel queryModel, int index);
    public abstract virtual void VisitJoinClause(JoinClause joinClause, QueryModel queryModel, int index);
    public abstract virtual void VisitJoinClause(JoinClause joinClause, QueryModel queryModel, GroupJoinClause groupJoinClause);
    public abstract virtual void VisitGroupJoinClause(GroupJoinClause joinClause, QueryModel queryModel, int index);
    public abstract virtual void VisitWhereClause(WhereClause whereClause, QueryModel queryModel, int index);
    public abstract virtual void VisitOrderByClause(OrderByClause orderByClause, QueryModel queryModel, int index);
    public abstract virtual void VisitOrdering(Ordering ordering, QueryModel queryModel, OrderByClause orderByClause, int index);
    public abstract virtual void VisitSelectClause(SelectClause selectClause, QueryModel queryModel);
    public abstract virtual void VisitResultOperator(ResultOperatorBase resultOperator, QueryModel queryModel, int index);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.MemberBindings.FieldInfoBinding : MemberBinding {
    public FieldInfoBinding(FieldInfo boundMember, Expression associatedExpression);
    public virtual bool MatchesReadAccess(MemberInfo member);
}
public abstract class Remotion.Linq.Parsing.ExpressionVisitors.MemberBindings.MemberBinding : object {
    private MemberInfo _boundMember;
    private Expression _associatedExpression;
    public MemberInfo BoundMember { get; }
    public Expression AssociatedExpression { get; }
    public MemberBinding(MemberInfo boundMember, Expression associatedExpression);
    public static MemberBinding Bind(MemberInfo boundMember, Expression associatedExpression);
    public MemberInfo get_BoundMember();
    public Expression get_AssociatedExpression();
    public abstract virtual bool MatchesReadAccess(MemberInfo member);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.MemberBindings.MethodInfoBinding : MemberBinding {
    public MethodInfoBinding(MethodInfo boundMember, Expression associatedExpression);
    public virtual bool MatchesReadAccess(MemberInfo readMember);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.MemberBindings.PropertyInfoBinding : MemberBinding {
    public PropertyInfoBinding(PropertyInfo boundMember, Expression associatedExpression);
    public virtual bool MatchesReadAccess(MemberInfo member);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.MultiReplacingExpressionVisitor : RelinqExpressionVisitor {
    private IDictionary`2<Expression, Expression> _expressionMapping;
    private MultiReplacingExpressionVisitor(IDictionary`2<Expression, Expression> expressionMapping);
    public static Expression Replace(IDictionary`2<Expression, Expression> expressionMapping, Expression sourceTree);
    public virtual Expression Visit(Expression expression);
    protected internal virtual Expression VisitSubQuery(SubQueryExpression expression);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.PartialEvaluatingExpressionVisitor : RelinqExpressionVisitor {
    private PartialEvaluationInfo _partialEvaluationInfo;
    private IEvaluatableExpressionFilter _evaluatableExpressionFilter;
    private PartialEvaluatingExpressionVisitor(PartialEvaluationInfo partialEvaluationInfo, IEvaluatableExpressionFilter evaluatableExpressionFilter);
    public static Expression EvaluateIndependentSubtrees(Expression expressionTree, IEvaluatableExpressionFilter evaluatableExpressionFilter);
    public virtual Expression Visit(Expression expression);
    private Expression EvaluateSubtree(Expression subtree);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.ReplacingExpressionVisitor : RelinqExpressionVisitor {
    private Expression _replacedExpression;
    private Expression _replacementExpression;
    private ReplacingExpressionVisitor(Expression replacedExpression, Expression replacementExpression);
    public static Expression Replace(Expression replacedExpression, Expression replacementExpression, Expression sourceTree);
    public virtual Expression Visit(Expression expression);
    protected internal virtual Expression VisitSubQuery(SubQueryExpression expression);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.SubQueryFindingExpressionVisitor : RelinqExpressionVisitor {
    private INodeTypeProvider _nodeTypeProvider;
    private ExpressionTreeParser _expressionTreeParser;
    private QueryParser _queryParser;
    private SubQueryFindingExpressionVisitor(INodeTypeProvider nodeTypeProvider);
    public static Expression Process(Expression expressionTree, INodeTypeProvider nodeTypeProvider);
    public virtual Expression Visit(Expression expression);
    private SubQueryExpression CreateSubQueryNode(MethodCallExpression methodCallExpression);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.ExpressionTransformation : MulticastDelegate {
    public ExpressionTransformation(object object, IntPtr method);
    public virtual Expression Invoke(Expression expression);
    public virtual IAsyncResult BeginInvoke(Expression expression, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.ExpressionTransformerRegistry : object {
    private IDictionary`2<ExpressionType, ICollection`1<ExpressionTransformation>> _transformations;
    private List`1<ExpressionTransformation> _genericTransformations;
    public int RegisteredTransformerCount { get; }
    public static ExpressionTransformerRegistry CreateDefault();
    public int get_RegisteredTransformerCount();
    public ExpressionTransformation[] GetAllTransformations(ExpressionType expressionType);
    public sealed virtual IEnumerable`1<ExpressionTransformation> GetTransformations(Expression expression);
    public void Register(IExpressionTransformer`1<T> transformer);
    private static Expression TransformExpression(Expression expression, IExpressionTransformer`1<T> transformer);
}
public interface Remotion.Linq.Parsing.ExpressionVisitors.Transformation.IExpressionTranformationProvider {
    public abstract virtual IEnumerable`1<ExpressionTransformation> GetTransformations(Expression expression);
}
public interface Remotion.Linq.Parsing.ExpressionVisitors.Transformation.IExpressionTransformer`1 {
    public ExpressionType[] SupportedExpressionTypes { get; }
    public abstract virtual ExpressionType[] get_SupportedExpressionTypes();
    public abstract virtual Expression Transform(T expression);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.PredefinedTransformations.AttributeEvaluatingExpressionTransformer : object {
    public ExpressionType[] SupportedExpressionTypes { get; }
    public sealed virtual ExpressionType[] get_SupportedExpressionTypes();
    public sealed virtual Expression Transform(Expression expression);
    private static IMethodCallExpressionTransformerAttribute GetTransformerProvider(MethodInfo methodInfo);
    private static Expression ApplyTransformer(IMethodCallExpressionTransformerAttribute provider, MethodCallExpression methodCallExpression);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.PredefinedTransformations.DictionaryEntryNewExpressionTransformer : MemberAddingNewExpressionTransformerBase {
    protected virtual MemberInfo[] GetMembers(ConstructorInfo constructorInfo, ReadOnlyCollection`1<Expression> arguments);
    protected virtual bool CanAddMembers(Type instantiatedType, ReadOnlyCollection`1<Expression> arguments);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.PredefinedTransformations.InvocationOfLambdaExpressionTransformer : object {
    public ExpressionType[] SupportedExpressionTypes { get; }
    public sealed virtual ExpressionType[] get_SupportedExpressionTypes();
    public sealed virtual Expression Transform(InvocationExpression expression);
    private Expression StripTrivialConversions(Expression invokedExpression);
    private Expression InlineLambdaExpression(LambdaExpression lambdaExpression, ReadOnlyCollection`1<Expression> arguments);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.PredefinedTransformations.KeyValuePairNewExpressionTransformer : MemberAddingNewExpressionTransformerBase {
    protected virtual MemberInfo[] GetMembers(ConstructorInfo constructorInfo, ReadOnlyCollection`1<Expression> arguments);
    protected virtual bool CanAddMembers(Type instantiatedType, ReadOnlyCollection`1<Expression> arguments);
}
public abstract class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.PredefinedTransformations.MemberAddingNewExpressionTransformerBase : object {
    public ExpressionType[] SupportedExpressionTypes { get; }
    protected abstract virtual bool CanAddMembers(Type instantiatedType, ReadOnlyCollection`1<Expression> arguments);
    protected abstract virtual MemberInfo[] GetMembers(ConstructorInfo constructorInfo, ReadOnlyCollection`1<Expression> arguments);
    public sealed virtual ExpressionType[] get_SupportedExpressionTypes();
    public sealed virtual Expression Transform(NewExpression expression);
    protected MemberInfo GetMemberForNewExpression(Type instantiatedType, string propertyName);
}
[AttributeUsageAttribute("64")]
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.PredefinedTransformations.MethodCallExpressionTransformerAttribute : Attribute {
    private Type _transformerType;
    public Type TransformerType { get; }
    public MethodCallExpressionTransformerAttribute(Type transformerType);
    public Type get_TransformerType();
    public sealed virtual IExpressionTransformer`1<MethodCallExpression> GetExpressionTransformer(MethodCallExpression expression);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.PredefinedTransformations.NullableValueTransformer : object {
    public ExpressionType[] SupportedExpressionTypes { get; }
    public sealed virtual ExpressionType[] get_SupportedExpressionTypes();
    public sealed virtual Expression Transform(MemberExpression expression);
    private bool IsDeclaredByNullableType(MemberInfo memberInfo);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.PredefinedTransformations.TupleNewExpressionTransformer : MemberAddingNewExpressionTransformerBase {
    protected virtual bool CanAddMembers(Type instantiatedType, ReadOnlyCollection`1<Expression> arguments);
    protected virtual MemberInfo[] GetMembers(ConstructorInfo constructorInfo, ReadOnlyCollection`1<Expression> arguments);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.PredefinedTransformations.VBCompareStringExpressionTransformer : object {
    private static string c_vbOperatorsClassName;
    private static string c_vbEmbeddedOperatorsClassName;
    private static string c_vbCompareStringOperatorMethodName;
    private static MethodInfo s_stringCompareToMethod;
    public ExpressionType[] SupportedExpressionTypes { get; }
    private static VBCompareStringExpressionTransformer();
    public sealed virtual ExpressionType[] get_SupportedExpressionTypes();
    public sealed virtual Expression Transform(BinaryExpression expression);
    private Expression GetExpressionForNodeType(BinaryExpression expression, MethodCallExpression leftSideAsMethodCallExpression, ConstantExpression leftSideArgument2AsConstantExpression);
    private bool IsVBOperator(MethodInfo operatorMethod, string operatorName);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.Transformation.PredefinedTransformations.VBInformationIsNothingExpressionTransformer : object {
    private static string c_vbInformationClassName;
    private static string c_vbIsNothingMethodName;
    public ExpressionType[] SupportedExpressionTypes { get; }
    public sealed virtual ExpressionType[] get_SupportedExpressionTypes();
    public sealed virtual Expression Transform(MethodCallExpression expression);
    private bool IsVBIsNothing(MethodInfo operatorMethod);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.TransformingExpressionVisitor : RelinqExpressionVisitor {
    private IExpressionTranformationProvider _tranformationProvider;
    private TransformingExpressionVisitor(IExpressionTranformationProvider tranformationProvider);
    public static Expression Transform(Expression expression, IExpressionTranformationProvider tranformationProvider);
    public virtual Expression Visit(Expression expression);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.TransparentIdentifierRemovingExpressionVisitor : RelinqExpressionVisitor {
    public static Expression ReplaceTransparentIdentifiers(Expression expression);
    protected virtual Expression VisitMember(MemberExpression memberExpression);
    protected internal virtual Expression VisitSubQuery(SubQueryExpression expression);
    private IEnumerable`1<MemberBinding> GetMemberBindingsCreatedByExpression(Expression expression);
    [IteratorStateMachineAttribute("Remotion.Linq.Parsing.ExpressionVisitors.TransparentIdentifierRemovingExpressionVisitor/<GetMemberBindingsForNewExpression>d__5")]
private IEnumerable`1<MemberBinding> GetMemberBindingsForNewExpression(NewExpression newExpression);
}
public abstract class Remotion.Linq.Parsing.ExpressionVisitors.TreeEvaluation.EvaluatableExpressionFilterBase : object {
    public virtual bool IsEvaluatableBinary(BinaryExpression node);
    public virtual bool IsEvaluatableConditional(ConditionalExpression node);
    public virtual bool IsEvaluatableConstant(ConstantExpression node);
    public virtual bool IsEvaluatableElementInit(ElementInit node);
    public virtual bool IsEvaluatableInvocation(InvocationExpression node);
    public virtual bool IsEvaluatableLambda(LambdaExpression node);
    public virtual bool IsEvaluatableListInit(ListInitExpression node);
    public virtual bool IsEvaluatableMember(MemberExpression node);
    public virtual bool IsEvaluatableMemberAssignment(MemberAssignment node);
    public virtual bool IsEvaluatableMemberInit(MemberInitExpression node);
    public virtual bool IsEvaluatableMemberListBinding(MemberListBinding node);
    public virtual bool IsEvaluatableMemberMemberBinding(MemberMemberBinding node);
    public virtual bool IsEvaluatableMethodCall(MethodCallExpression node);
    public virtual bool IsEvaluatableNew(NewExpression node);
    public virtual bool IsEvaluatableNewArray(NewArrayExpression node);
    public virtual bool IsEvaluatableTypeBinary(TypeBinaryExpression node);
    public virtual bool IsEvaluatableUnary(UnaryExpression node);
    public virtual bool IsEvaluatableBlock(BlockExpression node);
    public virtual bool IsEvaluatableCatchBlock(CatchBlock node);
    public virtual bool IsEvaluatableDebugInfo(DebugInfoExpression node);
    public virtual bool IsEvaluatableDefault(DefaultExpression node);
    public virtual bool IsEvaluatableGoto(GotoExpression node);
    public virtual bool IsEvaluatableIndex(IndexExpression node);
    public virtual bool IsEvaluatableLabel(LabelExpression node);
    public virtual bool IsEvaluatableLabelTarget(LabelTarget node);
    public virtual bool IsEvaluatableLoop(LoopExpression node);
    public virtual bool IsEvaluatableSwitch(SwitchExpression node);
    public virtual bool IsEvaluatableSwitchCase(SwitchCase node);
    public virtual bool IsEvaluatableTry(TryExpression node);
}
public class Remotion.Linq.Parsing.ExpressionVisitors.TreeEvaluation.EvaluatableTreeFindingExpressionVisitor : RelinqExpressionVisitor {
    private static ExpressionType c_minExpressionType;
    private static ExpressionType s_maxExpressionType;
    private IEvaluatableExpressionFilter _evaluatableExpressionFilter;
    private PartialEvaluationInfo _partialEvaluationInfo;
    private bool _isCurrentSubtreeEvaluatable;
    private EvaluatableTreeFindingExpressionVisitor(IEvaluatableExpressionFilter evaluatableExpressionFilter);
    private static EvaluatableTreeFindingExpressionVisitor();
    public static PartialEvaluationInfo Analyze(Expression expressionTree, IEvaluatableExpressionFilter evaluatableExpressionFilter);
    public virtual Expression Visit(Expression expression);
    protected virtual Expression VisitBinary(BinaryExpression expression);
    protected virtual Expression VisitConditional(ConditionalExpression expression);
    protected virtual Expression VisitConstant(ConstantExpression expression);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected virtual Expression VisitInvocation(InvocationExpression expression);
    protected virtual Expression VisitLambda(Expression`1<T> expression);
    protected virtual Expression VisitMember(MemberExpression expression);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual Expression VisitMemberInit(MemberInitExpression expression);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
    protected virtual Expression VisitMethodCall(MethodCallExpression expression);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected virtual Expression VisitListInit(ListInitExpression expression);
    protected virtual Expression VisitNew(NewExpression expression);
    protected virtual Expression VisitParameter(ParameterExpression expression);
    protected virtual Expression VisitNewArray(NewArrayExpression expression);
    protected virtual Expression VisitTypeBinary(TypeBinaryExpression expression);
    protected virtual Expression VisitUnary(UnaryExpression expression);
    protected virtual Expression VisitBlock(BlockExpression expression);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected virtual Expression VisitDebugInfo(DebugInfoExpression expression);
    protected virtual Expression VisitDefault(DefaultExpression expression);
    protected virtual Expression VisitGoto(GotoExpression expression);
    protected virtual Expression VisitIndex(IndexExpression expression);
    protected virtual Expression VisitLabel(LabelExpression expression);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    protected virtual Expression VisitLoop(LoopExpression expression);
    protected virtual Expression VisitSwitch(SwitchExpression expression);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected virtual Expression VisitTry(TryExpression expression);
    private bool IsCurrentExpressionEvaluatable(Expression expression);
    private bool IsQueryableExpression(Expression expression);
    public sealed virtual Expression VisitPartialEvaluationException(PartialEvaluationExceptionExpression partialEvaluationExceptionExpression);
}
public interface Remotion.Linq.Parsing.ExpressionVisitors.TreeEvaluation.IEvaluatableExpressionFilter {
    public abstract virtual bool IsEvaluatableBinary(BinaryExpression node);
    public abstract virtual bool IsEvaluatableConditional(ConditionalExpression node);
    public abstract virtual bool IsEvaluatableConstant(ConstantExpression node);
    public abstract virtual bool IsEvaluatableElementInit(ElementInit node);
    public abstract virtual bool IsEvaluatableInvocation(InvocationExpression node);
    public abstract virtual bool IsEvaluatableLambda(LambdaExpression node);
    public abstract virtual bool IsEvaluatableListInit(ListInitExpression node);
    public abstract virtual bool IsEvaluatableMember(MemberExpression node);
    public abstract virtual bool IsEvaluatableMemberAssignment(MemberAssignment node);
    public abstract virtual bool IsEvaluatableMemberInit(MemberInitExpression node);
    public abstract virtual bool IsEvaluatableMemberListBinding(MemberListBinding node);
    public abstract virtual bool IsEvaluatableMemberMemberBinding(MemberMemberBinding node);
    public abstract virtual bool IsEvaluatableMethodCall(MethodCallExpression node);
    public abstract virtual bool IsEvaluatableNew(NewExpression node);
    public abstract virtual bool IsEvaluatableNewArray(NewArrayExpression node);
    public abstract virtual bool IsEvaluatableTypeBinary(TypeBinaryExpression node);
    public abstract virtual bool IsEvaluatableUnary(UnaryExpression node);
    public abstract virtual bool IsEvaluatableBlock(BlockExpression node);
    public abstract virtual bool IsEvaluatableCatchBlock(CatchBlock node);
    public abstract virtual bool IsEvaluatableDebugInfo(DebugInfoExpression node);
    public abstract virtual bool IsEvaluatableDefault(DefaultExpression node);
    public abstract virtual bool IsEvaluatableGoto(GotoExpression node);
    public abstract virtual bool IsEvaluatableIndex(IndexExpression node);
    public abstract virtual bool IsEvaluatableLabel(LabelExpression node);
    public abstract virtual bool IsEvaluatableLabelTarget(LabelTarget node);
    public abstract virtual bool IsEvaluatableLoop(LoopExpression node);
    public abstract virtual bool IsEvaluatableSwitch(SwitchExpression node);
    public abstract virtual bool IsEvaluatableSwitchCase(SwitchCase node);
    public abstract virtual bool IsEvaluatableTry(TryExpression node);
}
internal class Remotion.Linq.Parsing.ExpressionVisitors.TreeEvaluation.NullEvaluatableExpressionFilter : EvaluatableExpressionFilterBase {
}
public class Remotion.Linq.Parsing.ExpressionVisitors.TreeEvaluation.PartialEvaluationInfo : object {
    private HashSet`1<Expression> _evaluatableExpressions;
    public int Count { get; }
    public int get_Count();
    public void AddEvaluatableExpression(Expression expression);
    public bool IsEvaluatableExpression(Expression expression);
}
[ObsoleteAttribute("Infrastructure uses NotSupportedException instead. (Version 1.15.12.0)", "True")]
public abstract class Remotion.Linq.Parsing.ParserException : Exception {
}
public abstract class Remotion.Linq.Parsing.RelinqExpressionVisitor : ExpressionVisitor {
    [IteratorStateMachineAttribute("Remotion.Linq.Parsing.RelinqExpressionVisitor/<AdjustArgumentsForNewExpression>d__0")]
public static IEnumerable`1<Expression> AdjustArgumentsForNewExpression(IList`1<Expression> arguments, IList`1<MemberInfo> members);
    protected virtual Expression VisitNew(NewExpression expression);
    protected internal virtual Expression VisitSubQuery(SubQueryExpression expression);
    protected internal virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
}
public class Remotion.Linq.Parsing.Structure.ExpressionTreeParser : object {
    private static MethodInfo s_getArrayLengthMethod;
    private UniqueIdentifierGenerator _identifierGenerator;
    private INodeTypeProvider _nodeTypeProvider;
    private IExpressionTreeProcessor _processor;
    private MethodCallExpressionParser _methodCallExpressionParser;
    public INodeTypeProvider NodeTypeProvider { get; }
    public IExpressionTreeProcessor Processor { get; }
    public ExpressionTreeParser(INodeTypeProvider nodeTypeProvider, IExpressionTreeProcessor processor);
    private static ExpressionTreeParser();
    [ObsoleteAttribute("This method has been removed. Use QueryParser.CreateDefault, or create a customized ExpressionTreeParser using the constructor. (1.13.93)", "True")]
public static ExpressionTreeParser CreateDefault();
    public static CompoundNodeTypeProvider CreateDefaultNodeTypeProvider();
    public static CompoundExpressionTreeProcessor CreateDefaultProcessor(IExpressionTranformationProvider tranformationProvider, IEvaluatableExpressionFilter evaluatableExpressionFilter);
    public INodeTypeProvider get_NodeTypeProvider();
    public IExpressionTreeProcessor get_Processor();
    public IExpressionNode ParseTree(Expression expressionTree);
    public MethodCallExpression GetQueryOperatorExpression(Expression expression);
    private IExpressionNode ParseNode(Expression expression, string associatedIdentifier);
    private IExpressionNode ParseMethodCallExpression(MethodCallExpression methodCallExpression, string associatedIdentifier);
    private IExpressionNode ParseNonQueryOperatorExpression(Expression expression, string associatedIdentifier);
    private string InferAssociatedIdentifierForSource(MethodCallExpression methodCallExpression);
    private LambdaExpression GetLambdaArgument(MethodCallExpression methodCallExpression);
    private LambdaExpression GetLambdaExpression(Expression expression);
    [CompilerGeneratedAttribute]
private LambdaExpression <GetLambdaArgument>b__19_0(Expression argument);
}
public class Remotion.Linq.Parsing.Structure.ExpressionTreeProcessors.CompoundExpressionTreeProcessor : object {
    private List`1<IExpressionTreeProcessor> _innerProcessors;
    public IList`1<IExpressionTreeProcessor> InnerProcessors { get; }
    public CompoundExpressionTreeProcessor(IEnumerable`1<IExpressionTreeProcessor> innerProcessors);
    public IList`1<IExpressionTreeProcessor> get_InnerProcessors();
    public sealed virtual Expression Process(Expression expressionTree);
}
public class Remotion.Linq.Parsing.Structure.ExpressionTreeProcessors.NullExpressionTreeProcessor : object {
    public sealed virtual Expression Process(Expression expressionTree);
}
public class Remotion.Linq.Parsing.Structure.ExpressionTreeProcessors.PartialEvaluatingExpressionTreeProcessor : object {
    private IEvaluatableExpressionFilter _filter;
    public IEvaluatableExpressionFilter Filter { get; }
    public PartialEvaluatingExpressionTreeProcessor(IEvaluatableExpressionFilter filter);
    public IEvaluatableExpressionFilter get_Filter();
    public sealed virtual Expression Process(Expression expressionTree);
}
public class Remotion.Linq.Parsing.Structure.ExpressionTreeProcessors.TransformingExpressionTreeProcessor : object {
    private IExpressionTranformationProvider _provider;
    public IExpressionTranformationProvider Provider { get; }
    public TransformingExpressionTreeProcessor(IExpressionTranformationProvider provider);
    public IExpressionTranformationProvider get_Provider();
    public sealed virtual Expression Process(Expression expressionTree);
}
public interface Remotion.Linq.Parsing.Structure.IExpressionTreeProcessor {
    public abstract virtual Expression Process(Expression expressionTree);
}
public interface Remotion.Linq.Parsing.Structure.INodeTypeProvider {
    public abstract virtual bool IsRegistered(MethodInfo method);
    public abstract virtual Type GetNodeType(MethodInfo method);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.AggregateExpressionNode : ResultOperatorExpressionNodeBase {
    private ResolvedExpressionCache`1<LambdaExpression> _cachedFunc;
    private LambdaExpression _func;
    public LambdaExpression Func { get; }
    public AggregateExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression func);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public LambdaExpression get_Func();
    public LambdaExpression GetResolvedFunc(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.AggregateFromSeedExpressionNode : ResultOperatorExpressionNodeBase {
    private ResolvedExpressionCache`1<LambdaExpression> _cachedFunc;
    private Expression _seed;
    private LambdaExpression _func;
    private LambdaExpression _optionalResultSelector;
    public Expression Seed { get; }
    public LambdaExpression Func { get; }
    public LambdaExpression OptionalResultSelector { get; }
    public AggregateFromSeedExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression seed, LambdaExpression func, LambdaExpression optionalResultSelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public Expression get_Seed();
    public LambdaExpression get_Func();
    public LambdaExpression get_OptionalResultSelector();
    public LambdaExpression GetResolvedFunc(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.AllExpressionNode : ResultOperatorExpressionNodeBase {
    private ResolvedExpressionCache`1<Expression> _cachedPredicate;
    private LambdaExpression _predicate;
    public LambdaExpression Predicate { get; }
    public AllExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression predicate);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public LambdaExpression get_Predicate();
    public Expression GetResolvedPredicate(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.AnyExpressionNode : ResultOperatorExpressionNodeBase {
    public AnyExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalPredicate);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.AsQueryableExpressionNode : ResultOperatorExpressionNodeBase {
    public AsQueryableExpressionNode(MethodCallExpressionParseInfo parseInfo);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.AverageExpressionNode : ResultOperatorExpressionNodeBase {
    public AverageExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalSelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.CastExpressionNode : ResultOperatorExpressionNodeBase {
    public Type CastItemType { get; }
    public CastExpressionNode(MethodCallExpressionParseInfo parseInfo);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public Type get_CastItemType();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.ClauseGenerationContext : ValueType {
    private Dictionary`2<IExpressionNode, object> _lookup;
    private INodeTypeProvider _nodeTypeProvider;
    public INodeTypeProvider NodeTypeProvider { get; }
    public int Count { get; }
    public ClauseGenerationContext(INodeTypeProvider nodeTypeProvider);
    public INodeTypeProvider get_NodeTypeProvider();
    public int get_Count();
    public void AddContextInfo(IExpressionNode node, object contextInfo);
    public object GetContextInfo(IExpressionNode node);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.ConcatExpressionNode : QuerySourceSetOperationExpressionNodeBase {
    public ConcatExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression source2);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    protected virtual ResultOperatorBase CreateSpecificResultOperator();
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.ContainsExpressionNode : ResultOperatorExpressionNodeBase {
    private Expression _item;
    public Expression Item { get; }
    public ContainsExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression item);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    [IteratorStateMachineAttribute("Remotion.Linq.Parsing.Structure.IntermediateModel.ContainsExpressionNode/<GetSupportedMethodNames>d__1")]
public static IEnumerable`1<NameBasedRegistrationInfo> GetSupportedMethodNames();
    public Expression get_Item();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.CountExpressionNode : ResultOperatorExpressionNodeBase {
    public CountExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalPredicate);
    [IteratorStateMachineAttribute("Remotion.Linq.Parsing.Structure.IntermediateModel.CountExpressionNode/<GetSupportedMethods>d__0")]
public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.DefaultIfEmptyExpressionNode : ResultOperatorExpressionNodeBase {
    private Expression _optionalDefaultValue;
    public Expression OptionalDefaultValue { get; }
    public DefaultIfEmptyExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression optionalDefaultValue);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public Expression get_OptionalDefaultValue();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.DistinctExpressionNode : ResultOperatorExpressionNodeBase {
    public DistinctExpressionNode(MethodCallExpressionParseInfo parseInfo);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.ExceptExpressionNode : ResultOperatorExpressionNodeBase {
    private Expression _source2;
    public Expression Source2 { get; }
    public ExceptExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression source2);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public Expression get_Source2();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.ExpressionNodeInstantiationException : Exception {
    internal ExpressionNodeInstantiationException(string message);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.ExpressionResolver : object {
    private IExpressionNode _currentNode;
    public IExpressionNode CurrentNode { get; }
    public ExpressionResolver(IExpressionNode currentNode);
    public IExpressionNode get_CurrentNode();
    public Expression GetResolvedExpression(Expression unresolvedExpression, ParameterExpression parameterToBeResolved, ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.FirstExpressionNode : ResultOperatorExpressionNodeBase {
    public FirstExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalPredicate);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.GroupByExpressionNode : ResultOperatorExpressionNodeBase {
    private ResolvedExpressionCache`1<Expression> _cachedKeySelector;
    private ResolvedExpressionCache`1<Expression> _cachedElementSelector;
    private LambdaExpression _keySelector;
    private LambdaExpression _optionalElementSelector;
    public LambdaExpression KeySelector { get; }
    public LambdaExpression OptionalElementSelector { get; }
    public GroupByExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression keySelector, LambdaExpression optionalElementSelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public LambdaExpression get_KeySelector();
    public LambdaExpression get_OptionalElementSelector();
    public Expression GetResolvedKeySelector(ClauseGenerationContext clauseGenerationContext);
    public Expression GetResolvedOptionalElementSelector(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.GroupByWithResultSelectorExpressionNode : object {
    private SelectExpressionNode _selectExpressionNode;
    public IExpressionNode Source { get; }
    public string AssociatedIdentifier { get; }
    public Expression Selector { get; }
    public GroupByWithResultSelectorExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression keySelector, LambdaExpression elementSelectorOrResultSelector, LambdaExpression resultSelectorOrNull);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    private static MethodCallExpressionParseInfo CreateParseInfoWithGroupNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression keySelector, LambdaExpression elementSelectorOrResultSelector, LambdaExpression resultSelectorOrNull);
    private static LambdaExpression CreateSelectorForSelectNode(LambdaExpression keySelector, LambdaExpression elementSelectorOrResultSelector, LambdaExpression resultSelectorOrNull);
    private static LambdaExpression GetOptionalElementSelector(LambdaExpression elementSelectorOrResultSelector, LambdaExpression resultSelectorOrNull);
    private static LambdaExpression GetResultSelector(LambdaExpression elementSelectorOrResultSelector, LambdaExpression resultSelectorOrNull);
    public sealed virtual IExpressionNode get_Source();
    public sealed virtual string get_AssociatedIdentifier();
    public Expression get_Selector();
    public sealed virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    public sealed virtual QueryModel Apply(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.GroupJoinExpressionNode : MethodCallExpressionNodeBase {
    private MethodCallExpression _parsedExpression;
    private Expression _innerSequence;
    private LambdaExpression _outerKeySelector;
    private LambdaExpression _innerKeySelector;
    private LambdaExpression _resultSelector;
    [ObsoleteAttribute("The _joinExpressionNode property contains cached information which will become stale after processing a subquery and should not be used for this purpose.")]
private JoinExpressionNode _joinExpressionNode;
    private ResolvedExpressionCache`1<Expression> _cachedResultSelector;
    [ObsoleteAttribute("The JoinExpressionNode property contains cached information which will become stale after processing a subquery and should not be used for this purpose.")]
public JoinExpressionNode JoinExpressionNode { get; }
    public MethodCallExpression ParsedExpression { get; }
    public Expression InnerSequence { get; }
    public LambdaExpression OuterKeySelector { get; }
    public LambdaExpression InnerKeySelector { get; }
    public LambdaExpression ResultSelector { get; }
    public GroupJoinExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression innerSequence, LambdaExpression outerKeySelector, LambdaExpression innerKeySelector, LambdaExpression resultSelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public JoinExpressionNode get_JoinExpressionNode();
    public MethodCallExpression get_ParsedExpression();
    public Expression get_InnerSequence();
    public LambdaExpression get_OuterKeySelector();
    public LambdaExpression get_InnerKeySelector();
    public LambdaExpression get_ResultSelector();
    public Expression GetResolvedResultSelector(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
}
public interface Remotion.Linq.Parsing.Structure.IntermediateModel.IExpressionNode {
    public IExpressionNode Source { get; }
    public string AssociatedIdentifier { get; }
    public abstract virtual IExpressionNode get_Source();
    public abstract virtual string get_AssociatedIdentifier();
    public abstract virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    public abstract virtual QueryModel Apply(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.IntersectExpressionNode : ResultOperatorExpressionNodeBase {
    private Expression _source2;
    public Expression Source2 { get; }
    public IntersectExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression source2);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public Expression get_Source2();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public interface Remotion.Linq.Parsing.Structure.IntermediateModel.IQuerySourceExpressionNode {
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.JoinExpressionNode : MethodCallExpressionNodeBase {
    private ResolvedExpressionCache`1<Expression> _cachedOuterKeySelector;
    private ResolvedExpressionCache`1<Expression> _cachedInnerKeySelector;
    private ResolvedExpressionCache`1<Expression> _cachedResultSelector;
    private Expression _innerSequence;
    private LambdaExpression _outerKeySelector;
    private LambdaExpression _innerKeySelector;
    private LambdaExpression _resultSelector;
    public Expression InnerSequence { get; }
    public LambdaExpression OuterKeySelector { get; }
    public LambdaExpression InnerKeySelector { get; }
    public LambdaExpression ResultSelector { get; }
    public JoinExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression innerSequence, LambdaExpression outerKeySelector, LambdaExpression innerKeySelector, LambdaExpression resultSelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public Expression get_InnerSequence();
    public LambdaExpression get_OuterKeySelector();
    public LambdaExpression get_InnerKeySelector();
    public LambdaExpression get_ResultSelector();
    public Expression GetResolvedOuterKeySelector(ClauseGenerationContext clauseGenerationContext);
    public Expression GetResolvedInnerKeySelector(ClauseGenerationContext clauseGenerationContext);
    public Expression GetResolvedResultSelector(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
    public JoinClause CreateJoinClause(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.LastExpressionNode : ResultOperatorExpressionNodeBase {
    public LastExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalPredicate);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.LongCountExpressionNode : ResultOperatorExpressionNodeBase {
    public LongCountExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalPredicate);
    [IteratorStateMachineAttribute("Remotion.Linq.Parsing.Structure.IntermediateModel.LongCountExpressionNode/<GetSupportedMethods>d__0")]
public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.MainSourceExpressionNode : object {
    private Type _querySourceElementType;
    private Expression _parsedExpression;
    private Type _querySourceType;
    private string _associatedIdentifier;
    public Type QuerySourceElementType { get; }
    public Type QuerySourceType { get; }
    public Expression ParsedExpression { get; }
    public string AssociatedIdentifier { get; }
    public IExpressionNode Source { get; }
    public MainSourceExpressionNode(string associatedIdentifier, Expression expression);
    public Type get_QuerySourceElementType();
    public Type get_QuerySourceType();
    public Expression get_ParsedExpression();
    public sealed virtual string get_AssociatedIdentifier();
    public sealed virtual IExpressionNode get_Source();
    public sealed virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    public sealed virtual QueryModel Apply(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
    private MainFromClause CreateMainFromClause(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.MaxExpressionNode : ResultOperatorExpressionNodeBase {
    public MaxExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalSelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public abstract class Remotion.Linq.Parsing.Structure.IntermediateModel.MethodCallExpressionNodeBase : object {
    private IExpressionNode _source;
    private Type _nodeResultType;
    private string _associatedIdentifier;
    public string AssociatedIdentifier { get; }
    public IExpressionNode Source { get; }
    public Type NodeResultType { get; }
    protected MethodCallExpressionNodeBase(MethodCallExpressionParseInfo parseInfo);
    public sealed virtual string get_AssociatedIdentifier();
    public sealed virtual IExpressionNode get_Source();
    public Type get_NodeResultType();
    public abstract virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected abstract virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
    public sealed virtual QueryModel Apply(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
    protected virtual QueryModel WrapQueryModelAfterEndOfQuery(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
    protected virtual void SetResultTypeOverride(QueryModel queryModel);
    private QueryModel WrapQueryModel(QueryModel queryModel, string associatedIdentifier, ClauseGenerationContext clauseGenerationContext);
    protected NotSupportedException CreateResolveNotSupportedException();
    protected NotSupportedException CreateOutputParameterNotSupportedException();
}
public static class Remotion.Linq.Parsing.Structure.IntermediateModel.MethodCallExpressionNodeFactory : object {
    public static IExpressionNode CreateExpressionNode(Type nodeType, MethodCallExpressionParseInfo parseInfo, Object[] additionalConstructorParameters);
    private static string GetArgumentMismatchMessage(ArgumentException ex);
    private static Object[] GetParameterArray(ConstructorInfo nodeTypeConstructor, MethodCallExpressionParseInfo parseInfo, Object[] additionalConstructorParameters);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.MethodCallExpressionParseInfo : ValueType {
    private string _associatedIdentifier;
    private IExpressionNode _source;
    private MethodCallExpression _parsedExpression;
    public string AssociatedIdentifier { get; }
    public IExpressionNode Source { get; }
    public MethodCallExpression ParsedExpression { get; }
    public MethodCallExpressionParseInfo(string associatedIdentifier, IExpressionNode source, MethodCallExpression parsedExpression);
    public string get_AssociatedIdentifier();
    public IExpressionNode get_Source();
    public MethodCallExpression get_ParsedExpression();
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.MinExpressionNode : ResultOperatorExpressionNodeBase {
    public MinExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalSelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.OfTypeExpressionNode : ResultOperatorExpressionNodeBase {
    public Type SearchedItemType { get; }
    public OfTypeExpressionNode(MethodCallExpressionParseInfo parseInfo);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public Type get_SearchedItemType();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.OrderByDescendingExpressionNode : MethodCallExpressionNodeBase {
    private ResolvedExpressionCache`1<Expression> _cachedSelector;
    private LambdaExpression _keySelector;
    public LambdaExpression KeySelector { get; }
    public OrderByDescendingExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression keySelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public LambdaExpression get_KeySelector();
    public Expression GetResolvedKeySelector(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.OrderByExpressionNode : MethodCallExpressionNodeBase {
    private ResolvedExpressionCache`1<Expression> _cachedSelector;
    private LambdaExpression _keySelector;
    public LambdaExpression KeySelector { get; }
    public OrderByExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression keySelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public LambdaExpression get_KeySelector();
    public Expression GetResolvedKeySelector(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
}
public static class Remotion.Linq.Parsing.Structure.IntermediateModel.QuerySourceExpressionNodeUtility : object {
    public static Expression ReplaceParameterWithReference(IQuerySourceExpressionNode referencedNode, ParameterExpression parameterToReplace, Expression expression, ClauseGenerationContext context);
    public static IQuerySource GetQuerySourceForNode(IQuerySourceExpressionNode node, ClauseGenerationContext context);
}
public abstract class Remotion.Linq.Parsing.Structure.IntermediateModel.QuerySourceSetOperationExpressionNodeBase : ResultOperatorExpressionNodeBase {
    private Expression _source2;
    private Type _itemType;
    public Expression Source2 { get; }
    public Type ItemType { get; }
    protected QuerySourceSetOperationExpressionNodeBase(MethodCallExpressionParseInfo parseInfo, Expression source2);
    public Expression get_Source2();
    public Type get_ItemType();
    public sealed virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected abstract virtual ResultOperatorBase CreateSpecificResultOperator();
    protected sealed virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.ResolvedExpressionCache`1 : object {
    private ExpressionResolver _resolver;
    private T _cachedExpression;
    public ResolvedExpressionCache`1(IExpressionNode currentNode);
    public T GetOrCreate(Func`2<ExpressionResolver, T> generator);
}
public abstract class Remotion.Linq.Parsing.Structure.IntermediateModel.ResultOperatorExpressionNodeBase : MethodCallExpressionNodeBase {
    private MethodCallExpression _parsedExpression;
    public MethodCallExpression ParsedExpression { get; }
    protected ResultOperatorExpressionNodeBase(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalPredicate, LambdaExpression optionalSelector);
    protected abstract virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
    public MethodCallExpression get_ParsedExpression();
    protected virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
    protected sealed virtual QueryModel WrapQueryModelAfterEndOfQuery(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
    private static MethodCallExpressionParseInfo TransformParseInfo(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalPredicate, LambdaExpression optionalSelector);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.ReverseExpressionNode : ResultOperatorExpressionNodeBase {
    public ReverseExpressionNode(MethodCallExpressionParseInfo parseInfo);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.SelectExpressionNode : MethodCallExpressionNodeBase {
    private static int c_indexSelectorParameterPosition;
    private ResolvedExpressionCache`1<Expression> _cachedSelector;
    private LambdaExpression _selector;
    public LambdaExpression Selector { get; }
    public SelectExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression selector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public LambdaExpression get_Selector();
    public Expression GetResolvedSelector(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.SelectManyExpressionNode : MethodCallExpressionNodeBase {
    private static int c_indexSelectorParameterPosition;
    private ResolvedExpressionCache`1<Expression> _cachedCollectionSelector;
    private ResolvedExpressionCache`1<Expression> _cachedResultSelector;
    private LambdaExpression _collectionSelector;
    private LambdaExpression _resultSelector;
    public LambdaExpression CollectionSelector { get; }
    public LambdaExpression ResultSelector { get; }
    public SelectManyExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression collectionSelector, LambdaExpression resultSelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public LambdaExpression get_CollectionSelector();
    public LambdaExpression get_ResultSelector();
    public Expression GetResolvedCollectionSelector(ClauseGenerationContext clauseGenerationContext);
    public Expression GetResolvedResultSelector(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.SingleExpressionNode : ResultOperatorExpressionNodeBase {
    public SingleExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalPredicate);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.SkipExpressionNode : ResultOperatorExpressionNodeBase {
    private Expression _count;
    public Expression Count { get; }
    public SkipExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression count);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public Expression get_Count();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.SumExpressionNode : ResultOperatorExpressionNodeBase {
    public SumExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression optionalSelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
[ExtensionAttribute]
internal static class Remotion.Linq.Parsing.Structure.IntermediateModel.SupportedMethodSpecifications : object {
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> WhereNameMatches(IEnumerable`1<MethodInfo> input, string name);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> WithoutEqualityComparer(IEnumerable`1<MethodInfo> input);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> WithoutComparer(IEnumerable`1<MethodInfo> input);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> WithoutSeedParameter(IEnumerable`1<MethodInfo> input);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> WithSeedParameter(IEnumerable`1<MethodInfo> input);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> WithoutResultSelector(IEnumerable`1<MethodInfo> input);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> WithResultSelector(IEnumerable`1<MethodInfo> input);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> WithoutIndexSelector(IEnumerable`1<MethodInfo> input, int parameterPosition);
    private static bool HasGenericDelegateOfType(MethodInfo methodInfo, Type genericDelegateType);
    private static bool HasIndexSelectorParameter(MethodInfo methodInfo, int parameterPosition);
    [ExtensionAttribute]
private static TypeInfo UnwrapEnumerable(TypeInfo typeInfo);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.TakeExpressionNode : ResultOperatorExpressionNodeBase {
    private Expression _count;
    public Expression Count { get; }
    public TakeExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression count);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public Expression get_Count();
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual ResultOperatorBase CreateResultOperator(ClauseGenerationContext clauseGenerationContext);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.ThenByDescendingExpressionNode : MethodCallExpressionNodeBase {
    private ResolvedExpressionCache`1<Expression> _cachedSelector;
    private LambdaExpression _keySelector;
    public LambdaExpression KeySelector { get; }
    public ThenByDescendingExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression keySelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public LambdaExpression get_KeySelector();
    public Expression GetResolvedKeySelector(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
    private OrderByClause GetOrderByClause(QueryModel queryModel);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.ThenByExpressionNode : MethodCallExpressionNodeBase {
    private ResolvedExpressionCache`1<Expression> _cachedSelector;
    private LambdaExpression _keySelector;
    public LambdaExpression KeySelector { get; }
    public ThenByExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression keySelector);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public LambdaExpression get_KeySelector();
    public Expression GetResolvedKeySelector(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
    private OrderByClause GetOrderByClause(QueryModel queryModel);
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.UnionExpressionNode : QuerySourceSetOperationExpressionNodeBase {
    public UnionExpressionNode(MethodCallExpressionParseInfo parseInfo, Expression source2);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    protected virtual ResultOperatorBase CreateSpecificResultOperator();
}
public class Remotion.Linq.Parsing.Structure.IntermediateModel.WhereExpressionNode : MethodCallExpressionNodeBase {
    private static int c_indexSelectorParameterPosition;
    private ResolvedExpressionCache`1<Expression> _cachedPredicate;
    private LambdaExpression _predicate;
    public LambdaExpression Predicate { get; }
    public WhereExpressionNode(MethodCallExpressionParseInfo parseInfo, LambdaExpression predicate);
    public static IEnumerable`1<MethodInfo> GetSupportedMethods();
    public LambdaExpression get_Predicate();
    public Expression GetResolvedPredicate(ClauseGenerationContext clauseGenerationContext);
    public virtual Expression Resolve(ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext);
    protected virtual void ApplyNodeSpecificSemantics(QueryModel queryModel, ClauseGenerationContext clauseGenerationContext);
}
public interface Remotion.Linq.Parsing.Structure.IQueryParser {
    public abstract virtual QueryModel GetParsedQuery(Expression expressionTreeRoot);
}
public class Remotion.Linq.Parsing.Structure.MethodCallExpressionParser : object {
    private INodeTypeProvider _nodeTypeProvider;
    public MethodCallExpressionParser(INodeTypeProvider nodeTypeProvider);
    public IExpressionNode Parse(string associatedIdentifier, IExpressionNode source, IEnumerable`1<Expression> arguments, MethodCallExpression expressionToParse);
    private Type GetNodeType(MethodCallExpression expressionToParse);
    private Expression ProcessArgumentExpression(Expression argumentExpression);
    private Expression UnwrapArgumentExpression(Expression expression);
    private IExpressionNode CreateExpressionNode(Type nodeType, MethodCallExpressionParseInfo parseInfo, Object[] additionalConstructorParameters);
    private NotSupportedException CreateParsingErrorException(MethodCallExpression expression, string message, Object[] args);
}
public class Remotion.Linq.Parsing.Structure.NodeTypeProviders.CompoundNodeTypeProvider : object {
    private List`1<INodeTypeProvider> _innerProviders;
    public IList`1<INodeTypeProvider> InnerProviders { get; }
    public CompoundNodeTypeProvider(IEnumerable`1<INodeTypeProvider> innerProviders);
    public IList`1<INodeTypeProvider> get_InnerProviders();
    public sealed virtual bool IsRegistered(MethodInfo method);
    public sealed virtual Type GetNodeType(MethodInfo method);
}
public class Remotion.Linq.Parsing.Structure.NodeTypeProviders.MethodInfoBasedNodeTypeRegistry : object {
    private static Dictionary`2<MethodInfo, Lazy`1<MethodInfo[]>> s_genericMethodDefinitionCandidates;
    private Dictionary`2<MethodInfo, Type> _registeredMethodInfoTypes;
    public int RegisteredMethodInfoCount { get; }
    private static MethodInfoBasedNodeTypeRegistry();
    public static MethodInfoBasedNodeTypeRegistry CreateFromRelinqAssembly();
    public static MethodInfo GetRegisterableMethodDefinition(MethodInfo method, bool throwOnAmbiguousMatch);
    private static MethodInfo[] GetGenericMethodDefinitionCandidates(MethodInfo referenceMethodDefinition);
    public int get_RegisteredMethodInfoCount();
    public void Register(IEnumerable`1<MethodInfo> methods, Type nodeType);
    public sealed virtual bool IsRegistered(MethodInfo method);
    public sealed virtual Type GetNodeType(MethodInfo method);
}
public class Remotion.Linq.Parsing.Structure.NodeTypeProviders.MethodNameBasedNodeTypeRegistry : object {
    private IDictionary`2<string, ICollection`1<KeyValuePair`2<NameBasedRegistrationInfo, Type>>> _registeredNamedTypes;
    public int RegisteredNamesCount { get; }
    public static MethodNameBasedNodeTypeRegistry CreateFromRelinqAssembly();
    public int get_RegisteredNamesCount();
    public void Register(IEnumerable`1<NameBasedRegistrationInfo> registrationInfo, Type nodeType);
    public sealed virtual bool IsRegistered(MethodInfo method);
    public sealed virtual Type GetNodeType(MethodInfo method);
}
public class Remotion.Linq.Parsing.Structure.NodeTypeProviders.NameBasedRegistrationInfo : object {
    private string _name;
    private Func`2<MethodInfo, bool> _filter;
    public string Name { get; }
    public Func`2<MethodInfo, bool> Filter { get; }
    public NameBasedRegistrationInfo(string name, Func`2<MethodInfo, bool> filter);
    public string get_Name();
    public Func`2<MethodInfo, bool> get_Filter();
}
public class Remotion.Linq.Parsing.Structure.QueryParser : object {
    private ExpressionTreeParser _expressionTreeParser;
    public ExpressionTreeParser ExpressionTreeParser { get; }
    public INodeTypeProvider NodeTypeProvider { get; }
    public IExpressionTreeProcessor Processor { get; }
    public QueryParser(ExpressionTreeParser expressionTreeParser);
    public static QueryParser CreateDefault();
    public ExpressionTreeParser get_ExpressionTreeParser();
    public INodeTypeProvider get_NodeTypeProvider();
    public IExpressionTreeProcessor get_Processor();
    public sealed virtual QueryModel GetParsedQuery(Expression expressionTreeRoot);
    private QueryModel ApplyAllNodes(IExpressionNode node, ClauseGenerationContext clauseGenerationContext);
}
public abstract class Remotion.Linq.Parsing.ThrowingExpressionVisitor : RelinqExpressionVisitor {
    private static Assembly s_systemLinqAssembly;
    private static ThrowingExpressionVisitor();
    protected abstract virtual Exception CreateUnhandledItemException(T unhandledItem, string visitMethod);
    public virtual Expression Visit(Expression expression);
    protected virtual Expression VisitUnknownStandardExpression(Expression expression, string visitMethod, Func`2<Expression, Expression> baseBehavior);
    private bool IsWellKnownStandardExpression(Expression expression);
    protected virtual TResult VisitUnhandledItem(TItem unhandledItem, string visitMethod, Func`2<TItem, TResult> baseBehavior);
    protected virtual Expression VisitExtension(Expression expression);
    protected Expression BaseVisitExtension(Expression expression);
    protected virtual Expression VisitUnary(UnaryExpression expression);
    protected Expression BaseVisitUnary(UnaryExpression expression);
    protected virtual Expression VisitBinary(BinaryExpression expression);
    protected Expression BaseVisitBinary(BinaryExpression expression);
    protected virtual Expression VisitTypeBinary(TypeBinaryExpression expression);
    protected Expression BaseVisitTypeBinary(TypeBinaryExpression expression);
    protected virtual Expression VisitConstant(ConstantExpression expression);
    protected Expression BaseVisitConstant(ConstantExpression expression);
    protected virtual Expression VisitConditional(ConditionalExpression expression);
    protected Expression BaseVisitConditional(ConditionalExpression arg);
    protected virtual Expression VisitParameter(ParameterExpression expression);
    protected Expression BaseVisitParameter(ParameterExpression expression);
    protected virtual Expression VisitLambda(Expression`1<T> expression);
    protected Expression BaseVisitLambda(Expression`1<T> expression);
    protected virtual Expression VisitMethodCall(MethodCallExpression expression);
    protected Expression BaseVisitMethodCall(MethodCallExpression expression);
    protected virtual Expression VisitInvocation(InvocationExpression expression);
    protected Expression BaseVisitInvocation(InvocationExpression expression);
    protected virtual Expression VisitMember(MemberExpression expression);
    protected Expression BaseVisitMember(MemberExpression expression);
    protected virtual Expression VisitNew(NewExpression expression);
    protected Expression BaseVisitNew(NewExpression expression);
    protected virtual Expression VisitNewArray(NewArrayExpression expression);
    protected Expression BaseVisitNewArray(NewArrayExpression expression);
    protected virtual Expression VisitMemberInit(MemberInitExpression expression);
    protected Expression BaseVisitMemberInit(MemberInitExpression expression);
    protected virtual Expression VisitListInit(ListInitExpression expression);
    protected Expression BaseVisitListInit(ListInitExpression expression);
    protected virtual Expression VisitBlock(BlockExpression expression);
    protected Expression BaseVisitBlock(BlockExpression expression);
    protected virtual Expression VisitDebugInfo(DebugInfoExpression expression);
    protected Expression BaseVisitDebugInfo(DebugInfoExpression expression);
    protected virtual Expression VisitDefault(DefaultExpression expression);
    protected Expression BaseVisitDefault(DefaultExpression expression);
    protected virtual Expression VisitGoto(GotoExpression expression);
    protected Expression BaseVisitGoto(GotoExpression expression);
    protected virtual Expression VisitIndex(IndexExpression expression);
    protected Expression BaseVisitIndex(IndexExpression expression);
    protected virtual Expression VisitLabel(LabelExpression expression);
    protected Expression BaseVisitLabel(LabelExpression expression);
    protected virtual Expression VisitLoop(LoopExpression expression);
    protected Expression BaseVisitLoop(LoopExpression expression);
    protected virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression expression);
    protected Expression BaseVisitRuntimeVariables(RuntimeVariablesExpression expression);
    protected virtual Expression VisitSwitch(SwitchExpression expression);
    protected Expression BaseVisitSwitch(SwitchExpression expression);
    protected virtual Expression VisitTry(TryExpression expression);
    protected Expression BaseVisitTry(TryExpression expression);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding expression);
    protected MemberBinding BaseVisitMemberBinding(MemberBinding expression);
    protected virtual ElementInit VisitElementInit(ElementInit elementInit);
    protected ElementInit BaseVisitElementInit(ElementInit elementInit);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment memberAssigment);
    protected MemberAssignment BaseVisitMemberAssignment(MemberAssignment memberAssigment);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected MemberMemberBinding BaseVisitMemberMemberBinding(MemberMemberBinding binding);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding listBinding);
    protected MemberListBinding BaseVisitMemberListBinding(MemberListBinding listBinding);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock expression);
    protected CatchBlock BaseVisitCatchBlock(CatchBlock expression);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget expression);
    protected LabelTarget BaseVisitLabelTarget(LabelTarget expression);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase expression);
    protected SwitchCase BaseVisitSwitchCase(SwitchCase expression);
    protected internal virtual Expression VisitSubQuery(SubQueryExpression expression);
    protected Expression BaseVisitSubQuery(SubQueryExpression expression);
    protected internal virtual Expression VisitQuerySourceReference(QuerySourceReferenceExpression expression);
    protected Expression BaseVisitQuerySourceReference(QuerySourceReferenceExpression expression);
}
public static class Remotion.Linq.Parsing.TupleExpressionBuilder : object {
    public static Expression AggregateExpressionsIntoTuple(IEnumerable`1<Expression> expressions);
    [IteratorStateMachineAttribute("Remotion.Linq.Parsing.TupleExpressionBuilder/<GetExpressionsFromTuple>d__1")]
public static IEnumerable`1<Expression> GetExpressionsFromTuple(Expression tupleExpression);
    private static Expression CreateTupleExpression(Expression left, Expression right);
}
public abstract class Remotion.Linq.QueryableBase`1 : object {
    private IQueryProvider _queryProvider;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; private set; }
    public IQueryProvider Provider { get; }
    public Type ElementType { get; }
    protected QueryableBase`1(IQueryParser queryParser, IQueryExecutor executor);
    protected QueryableBase`1(IQueryProvider provider);
    protected QueryableBase`1(IQueryProvider provider, Expression expression);
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(Expression value);
    public sealed virtual IQueryProvider get_Provider();
    public sealed virtual Type get_ElementType();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Remotion.Linq.QueryModel : object {
    private UniqueIdentifierGenerator _uniqueIdentifierGenerator;
    private MainFromClause _mainFromClause;
    private SelectClause _selectClause;
    [CompilerGeneratedAttribute]
private Type <ResultTypeOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private ObservableCollection`1<IBodyClause> <BodyClauses>k__BackingField;
    [CompilerGeneratedAttribute]
private ObservableCollection`1<ResultOperatorBase> <ResultOperators>k__BackingField;
    public Type ResultTypeOverride { get; public set; }
    public MainFromClause MainFromClause { get; public set; }
    public SelectClause SelectClause { get; public set; }
    public ObservableCollection`1<IBodyClause> BodyClauses { get; private set; }
    public ObservableCollection`1<ResultOperatorBase> ResultOperators { get; private set; }
    public QueryModel(MainFromClause mainFromClause, SelectClause selectClause);
    [CompilerGeneratedAttribute]
public Type get_ResultTypeOverride();
    [CompilerGeneratedAttribute]
public void set_ResultTypeOverride(Type value);
    public Type GetResultType();
    public IStreamedDataInfo GetOutputDataInfo();
    public MainFromClause get_MainFromClause();
    public void set_MainFromClause(MainFromClause value);
    public SelectClause get_SelectClause();
    public void set_SelectClause(SelectClause value);
    [CompilerGeneratedAttribute]
public ObservableCollection`1<IBodyClause> get_BodyClauses();
    [CompilerGeneratedAttribute]
private void set_BodyClauses(ObservableCollection`1<IBodyClause> value);
    [CompilerGeneratedAttribute]
public ObservableCollection`1<ResultOperatorBase> get_ResultOperators();
    [CompilerGeneratedAttribute]
private void set_ResultOperators(ObservableCollection`1<ResultOperatorBase> value);
    public UniqueIdentifierGenerator GetUniqueIdentfierGenerator();
    private void ResultOperators_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    public void Accept(IQueryModelVisitor visitor);
    public virtual string ToString();
    public QueryModel Clone();
    public QueryModel Clone(QuerySourceMapping querySourceMapping);
    public void TransformExpressions(Func`2<Expression, Expression> transformation);
    public string GetNewName(string prefix);
    private void BodyClauses_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    public IStreamedData Execute(IQueryExecutor executor);
    public bool IsIdentityQuery();
    public QueryModel ConvertToSubQuery(string itemName);
}
public class Remotion.Linq.QueryModelBuilder : object {
    private List`1<ResultOperatorBase> _resultOperators;
    private List`1<IBodyClause> _bodyClauses;
    [CompilerGeneratedAttribute]
private MainFromClause <MainFromClause>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectClause <SelectClause>k__BackingField;
    public MainFromClause MainFromClause { get; private set; }
    public SelectClause SelectClause { get; private set; }
    public ReadOnlyCollection`1<IBodyClause> BodyClauses { get; }
    public ReadOnlyCollection`1<ResultOperatorBase> ResultOperators { get; }
    [CompilerGeneratedAttribute]
public MainFromClause get_MainFromClause();
    [CompilerGeneratedAttribute]
private void set_MainFromClause(MainFromClause value);
    [CompilerGeneratedAttribute]
public SelectClause get_SelectClause();
    [CompilerGeneratedAttribute]
private void set_SelectClause(SelectClause value);
    public ReadOnlyCollection`1<IBodyClause> get_BodyClauses();
    public ReadOnlyCollection`1<ResultOperatorBase> get_ResultOperators();
    public void AddClause(IClause clause);
    public void AddResultOperator(ResultOperatorBase resultOperator);
    public QueryModel Build();
}
public abstract class Remotion.Linq.QueryModelVisitorBase : object {
    public virtual void VisitQueryModel(QueryModel queryModel);
    public virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
    public virtual void VisitAdditionalFromClause(AdditionalFromClause fromClause, QueryModel queryModel, int index);
    public virtual void VisitJoinClause(JoinClause joinClause, QueryModel queryModel, int index);
    public virtual void VisitJoinClause(JoinClause joinClause, QueryModel queryModel, GroupJoinClause groupJoinClause);
    public virtual void VisitGroupJoinClause(GroupJoinClause groupJoinClause, QueryModel queryModel, int index);
    public virtual void VisitWhereClause(WhereClause whereClause, QueryModel queryModel, int index);
    public virtual void VisitOrderByClause(OrderByClause orderByClause, QueryModel queryModel, int index);
    public virtual void VisitOrdering(Ordering ordering, QueryModel queryModel, OrderByClause orderByClause, int index);
    public virtual void VisitSelectClause(SelectClause selectClause, QueryModel queryModel);
    public virtual void VisitResultOperator(ResultOperatorBase resultOperator, QueryModel queryModel, int index);
    protected virtual void VisitBodyClauses(ObservableCollection`1<IBodyClause> bodyClauses, QueryModel queryModel);
    protected virtual void VisitOrderings(ObservableCollection`1<Ordering> orderings, QueryModel queryModel, OrderByClause orderByClause);
    protected virtual void VisitResultOperators(ObservableCollection`1<ResultOperatorBase> resultOperators, QueryModel queryModel);
}
public abstract class Remotion.Linq.QueryProviderBase : object {
    private static MethodInfo s_genericCreateQueryMethod;
    private IQueryParser _queryParser;
    private IQueryExecutor _executor;
    public IQueryParser QueryParser { get; }
    public IQueryExecutor Executor { get; }
    [ObsoleteAttribute("This property has been replaced by the QueryParser property. Use QueryParser instead. (1.13.92)", "True")]
public ExpressionTreeParser ExpressionTreeParser { get; }
    protected QueryProviderBase(IQueryParser queryParser, IQueryExecutor executor);
    private static QueryProviderBase();
    public IQueryParser get_QueryParser();
    public IQueryExecutor get_Executor();
    public ExpressionTreeParser get_ExpressionTreeParser();
    public sealed virtual IQueryable CreateQuery(Expression expression);
    public abstract virtual IQueryable`1<T> CreateQuery(Expression expression);
    public virtual IStreamedData Execute(Expression expression);
    private sealed virtual override TResult System.Linq.IQueryProvider.Execute(Expression expression);
    private sealed virtual override object System.Linq.IQueryProvider.Execute(Expression expression);
    public virtual QueryModel GenerateQueryModel(Expression expression);
}
public class Remotion.Linq.Transformations.SubQueryFromClauseFlattener : QueryModelVisitorBase {
    public virtual void VisitMainFromClause(MainFromClause fromClause, QueryModel queryModel);
    public virtual void VisitAdditionalFromClause(AdditionalFromClause fromClause, QueryModel queryModel, int index);
    protected virtual void FlattenSubQuery(SubQueryExpression subQueryExpression, IFromClause fromClause, QueryModel queryModel, int destinationIndex);
    protected virtual void CheckFlattenable(QueryModel subQueryModel);
    protected void InsertBodyClauses(ObservableCollection`1<IBodyClause> bodyClauses, QueryModel destinationQueryModel, int destinationIndex);
}
public class Remotion.Linq.UniqueIdentifierGenerator : object {
    private HashSet`1<string> _knownIdentifiers;
    private int _identifierCounter;
    public void AddKnownIdentifier(string identifier);
    private bool IsKnownIdentifier(string identifier);
    public void Reset();
    public string GetUniqueIdentifier(string prefix);
}
[ExtensionAttribute]
internal static class Remotion.Linq.Utilities.ExpressionExtensions : object {
    [ExtensionAttribute]
public static string BuildString(Expression expression);
}
public static class Remotion.Linq.Utilities.ItemTypeReflectionUtility : object {
    [ContractAnnotationAttribute("=>true, itemType:notnull; =>false, itemType:null")]
public static bool TryGetItemTypeOfClosedGenericIEnumerable(Type possibleEnumerableType, Type& itemType);
    private static bool IsIEnumerable(TypeInfo type);
    private static bool IsGenericIEnumerable(TypeInfo enumerableType);
}
[ExtensionAttribute]
internal static class Remotion.Linq.Utilities.ReflectionUtility : object {
    private static ReadOnlyCollection`1<MethodInfo> s_enumerableAndQueryableMethods;
    public static ReadOnlyCollection`1<MethodInfo> EnumerableAndQueryableMethods { get; }
    private static ReflectionUtility();
    public static ReadOnlyCollection`1<MethodInfo> get_EnumerableAndQueryableMethods();
    public static MethodInfo GetMethod(Expression`1<Func`1<T>> wrappedCall);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethodChecked(Type type, string methodName, Type[] parameterTypes);
    public static Type GetMemberReturnType(MemberInfo member);
    public static void CheckTypeIsClosedGenericIEnumerable(Type enumerableType, string argumentName);
    public static Type GetItemTypeOfClosedGenericIEnumerable(Type enumerableType, string argumentName);
}
internal static class Remotion.Linq.Utilities.StringUtility : object {
    public static string Join(string separator, IEnumerable`1<T> values);
}
internal static class Remotion.Utilities.ArgumentUtility : object {
    [AssertionMethodAttribute]
public static T CheckNotNull(string argumentName, T actualValue);
    [ConditionalAttribute("DEBUG")]
[AssertionMethodAttribute]
public static void DebugCheckNotNull(string argumentName, T actualValue);
    [AssertionMethodAttribute]
public static string CheckNotNullOrEmpty(string argumentName, string actualValue);
    [ConditionalAttribute("DEBUG")]
[AssertionMethodAttribute]
public static void DebugCheckNotNullOrEmpty(string argumentName, string actualValue);
    [AssertionMethodAttribute]
public static T CheckNotNullOrEmpty(string argumentName, T enumerable);
    [ConditionalAttribute("DEBUG")]
[AssertionMethodAttribute]
public static void DebugCheckNotNullOrEmpty(string argumentName, T enumerable);
    [AssertionMethodAttribute]
public static T CheckNotNullOrItemsNull(string argumentName, T enumerable);
    [AssertionMethodAttribute]
public static T CheckNotNullOrEmptyOrItemsNull(string argumentName, T enumerable);
    [AssertionMethodAttribute]
public static string CheckNotEmpty(string argumentName, string actualValue);
    [AssertionMethodAttribute]
public static T CheckNotEmpty(string argumentName, T enumerable);
    [AssertionMethodAttribute]
public static Guid CheckNotEmpty(string argumentName, Guid actualValue);
    public static object CheckNotNullAndType(string argumentName, object actualValue, Type expectedType);
    public static TExpected CheckNotNullAndType(string argumentName, object actualValue);
    [ConditionalAttribute("DEBUG")]
[AssertionMethodAttribute]
public static void DebugCheckNotNullAndType(string argumentName, object actualValue, Type expectedType);
    public static object CheckType(string argumentName, object actualValue, Type expectedType);
    public static TExpected CheckType(string argumentName, object actualValue);
    public static Type CheckNotNullAndTypeIsAssignableFrom(string argumentName, Type actualType, Type expectedType);
    public static Type CheckTypeIsAssignableFrom(string argumentName, Type actualType, Type expectedType);
    [ConditionalAttribute("DEBUG")]
[AssertionMethodAttribute]
public static void DebugCheckTypeIsAssignableFrom(string argumentName, Type actualType, Type expectedType);
    public static T CheckItemsType(string argumentName, T collection, Type itemType);
    public static T CheckItemsNotNullAndType(string argumentName, T collection, Type itemType);
    public static ArgumentException CreateArgumentEmptyException(string argumentName);
    public static ArgumentException CreateArgumentTypeException(string argumentName, Type actualType, Type expectedType);
    public static ArgumentException CreateArgumentItemTypeException(string argumentName, int index, Type expectedType, Type actualType);
    public static ArgumentNullException CreateArgumentItemNullException(string argumentName, int index);
}
internal static class Remotion.Utilities.Assertion : object {
    private static string c_msgIsTrue;
    private static string c_msgIsFalse;
    private static string c_msgIsNull;
    private static string c_msgIsNotNull;
    private static Object[] s_emptyArguments;
    private static Assertion();
    [ConditionalAttribute("DEBUG")]
[AssertionMethodAttribute]
public static void DebugAssert(bool assertion, string message);
    [ConditionalAttribute("DEBUG")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
public static void DebugAssert(bool assertion, string message, Object[] arguments);
    [ConditionalAttribute("DEBUG")]
[AssertionMethodAttribute]
public static void DebugAssert(bool assertion);
    [ConditionalAttribute("TRACE")]
[AssertionMethodAttribute]
public static void TraceAssert(bool assertion, string message);
    [ConditionalAttribute("TRACE")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
public static void TraceAssert(bool assertion, string message, Object[] arguments);
    [ConditionalAttribute("TRACE")]
[AssertionMethodAttribute]
public static void TraceAssert(bool assertion);
    [AssertionMethodAttribute]
public static void IsTrue(bool assertion, string message);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
public static void IsTrue(bool assertion, string message, Object[] arguments);
    [AssertionMethodAttribute]
public static void IsTrue(bool assertion);
    [AssertionMethodAttribute]
public static void IsFalse(bool expression, string message);
    [AssertionMethodAttribute]
public static void IsFalse(bool expression);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
public static void IsFalse(bool expression, string message, Object[] arguments);
    [AssertionMethodAttribute]
public static T IsNotNull(T obj, string message);
    [AssertionMethodAttribute]
public static T IsNotNull(T obj);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
public static T IsNotNull(T obj, string message, Object[] arguments);
    [AssertionMethodAttribute]
public static void IsNull(object obj, string message);
    [AssertionMethodAttribute]
public static void IsNull(object obj);
    [AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
public static void IsNull(object obj, string message, Object[] arguments);
}
internal static class Remotion.Utilities.NullableTypeUtility : object {
    public static bool IsNullableType(Type type);
    internal static bool IsNullableType_NoArgumentCheck(Type expectedType);
    public static Type GetNullableType(Type type);
    public static Type GetBasicType(Type type);
}
[ExtensionAttribute]
internal static class System.Reflection.ReflectionExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static MethodInfo GetGetMethod(PropertyInfo propertyInfo, bool nonPublic);
}
