[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.CopyOnWriteDictionary`1 : object {
    private static ImmutableDictionary`2<string, V> NameComparerDictionaryPrototype;
    private static ImmutableDictionary`2<string, V> OrdinalIgnoreCaseComparerDictionaryPrototype;
    private ImmutableDictionary`2<string, V> _backing;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal IEqualityComparer`1<string> Comparer { get; private set; }
    public V Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    internal CopyOnWriteDictionary`1(IEqualityComparer`1<string> keyComparer);
    protected CopyOnWriteDictionary`1(SerializationInfo info, StreamingContext context);
    private CopyOnWriteDictionary`1(CopyOnWriteDictionary`1<V> that);
    public CopyOnWriteDictionary`1(IDictionary`2<string, V> dictionary);
    private static CopyOnWriteDictionary`1();
    private static ImmutableDictionary`2<string, V> GetInitialDictionary(IEqualityComparer`1<string> keyComparer);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal IEqualityComparer`1<string> get_Comparer();
    private void set_Comparer(IEqualityComparer`1<string> value);
    public sealed virtual V get_Item(string key);
    public sealed virtual void set_Item(string key, V value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(string key, V value);
    public void SetItems(IEnumerable`1<KeyValuePair`2<string, V>> items);
    public IEnumerable`1<KeyValuePair`2<string, V>> Where(Func`2<KeyValuePair`2<string, V>, bool> predicate);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    [NullableContextAttribute("0")]
public sealed virtual bool TryGetValue(string key, V& value);
    public sealed virtual void Add(KeyValuePair`2<string, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("0")]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    internal CopyOnWriteDictionary`1<V> Clone();
    internal bool HasSameBacking(CopyOnWriteDictionary`1<V> other);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal interface Microsoft.Build.Collections.IConstrainedEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y, int indexY, int length);
    public abstract virtual int GetHashCode(T obj, int index, int length);
}
internal interface Microsoft.Build.Collections.IKeyed {
    public string Key { get; }
    public abstract virtual string get_Key();
}
internal class Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer : object {
    private static ProcessorArchitectures s_runningProcessorArchitecture;
    [CompilerGeneratedAttribute]
private static MSBuildNameIgnoreCaseComparer <Default>k__BackingField;
    internal static MSBuildNameIgnoreCaseComparer Default { get; }
    private static MSBuildNameIgnoreCaseComparer();
    [CompilerGeneratedAttribute]
internal static MSBuildNameIgnoreCaseComparer get_Default();
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
    public sealed virtual bool Equals(string compareToString, string constrainedString, int start, int lengthToCompare);
    public sealed virtual int GetHashCode(string obj, int start, int length);
}
internal class Microsoft.Build.Collections.ReadOnlyEmptyCollection`1 : object {
    private static ReadOnlyEmptyCollection`1<T> s_instance;
    public static ReadOnlyEmptyCollection`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public static ReadOnlyEmptyCollection`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.ReadOnlyEmptyCollection`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2 : object {
    private static Dictionary`2<K, V> s_backing;
    private static ReadOnlyEmptyDictionary`2<K, V> s_instance;
    public static ReadOnlyEmptyDictionary`2<K, V> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    public object Item { get; public set; }
    public V Item { get; public set; }
    private static ReadOnlyEmptyDictionary`2();
    public static ReadOnlyEmptyDictionary`2<K, V> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
}
internal static class Microsoft.Build.Evaluation.ToolsetConfigurationReaderHelpers : object {
    private static object s_syncLock;
    private static ToolsetConfigurationSection s_toolsetConfigurationSectionCache;
    private static Configuration s_configurationOfCachedSection;
    private static ToolsetConfigurationReaderHelpers();
    internal static ToolsetConfigurationSection ReadToolsetConfigurationSection(Configuration configuration);
    private static ToolsetConfigurationSection GetToolsetConfigurationSection(Configuration configuration);
}
internal class Microsoft.Build.Evaluation.ToolsetConfigurationSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("")]
public ToolsetElementCollection Toolsets { get; }
    [ConfigurationPropertyAttribute("default")]
public string Default { get; public set; }
    [ConfigurationPropertyAttribute("msbuildOverrideTasksPath")]
public string MSBuildOverrideTasksPath { get; public set; }
    [ConfigurationPropertyAttribute("DefaultOverrideToolsVersion")]
public string DefaultOverrideToolsVersion { get; public set; }
    public ToolsetElementCollection get_Toolsets();
    public string get_Default();
    public void set_Default(string value);
    public string get_MSBuildOverrideTasksPath();
    public void set_MSBuildOverrideTasksPath(string value);
    public string get_DefaultOverrideToolsVersion();
    public void set_DefaultOverrideToolsVersion(string value);
}
internal class Microsoft.Build.Evaluation.ToolsetElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("toolsVersion")]
public string toolsVersion { get; public set; }
    [ConfigurationPropertyAttribute("")]
public PropertyElementCollection PropertyElements { get; }
    [ConfigurationPropertyAttribute("projectImportSearchPaths")]
public ExtensionsPathsElementCollection AllProjectImportSearchPaths { get; }
    public string get_toolsVersion();
    public void set_toolsVersion(string value);
    public PropertyElementCollection get_PropertyElements();
    public ExtensionsPathsElementCollection get_AllProjectImportSearchPaths();
}
internal class Microsoft.Build.Evaluation.ToolsetElementCollection : ConfigurationElementCollection {
    private Dictionary`2<string, string> _previouslySeenToolsVersions;
    public ConfigurationElementCollectionType CollectionType { get; }
    protected bool ThrowOnDuplicate { get; }
    protected string ElementName { get; }
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual string get_ElementName();
    public ToolsetElement GetElement(string toolsVersion);
    public ToolsetElement GetElement(int index);
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual void BaseAdd(int index, ConfigurationElement element);
    protected virtual void BaseAdd(ConfigurationElement element);
    private void UpdateToolsVersionMap(ConfigurationElement element);
}
internal static class Microsoft.Build.Internal.Tracing : object {
    private static Dictionary`2<string, int> s_counts;
    private static DateTime s_last;
    private static TimeSpan s_interval;
    private static string s_slot;
    private static string s_currentAssemblyName;
    private static Tracing();
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, string value);
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, KeyValuePair`2<K, V> value);
    [ConditionalAttribute("DEBUG")]
internal static void Record(string counter);
    [ConditionalAttribute("DEBUG")]
internal static void List(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
internal static void Dump();
}
[SupportedOSPlatformAttribute("windows")]
internal class Microsoft.Build.Shared.AssemblyFoldersEx : object {
    private List`1<AssemblyFoldersExInfo> _directoryNames;
    private HashSet`1<string> _uniqueDirectoryPaths;
    internal IEnumerable`1<string> UniqueDirectoryPaths { get; }
    internal AssemblyFoldersEx(string registryKeyRoot, string targetRuntimeVersion, string registryKeySuffix, string osVersion, string platform, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, ProcessorArchitecture targetProcessorArchitecture, OpenBaseKey openBaseKey);
    private void FindDirectories(RegistryView view, RegistryHive hive, string registryKeyRoot, string targetRuntimeVersion, string registryKeySuffix, string osVersion, string platform, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, OpenBaseKey openBaseKey);
    private bool MatchingPlatformExists(string platform, string platformValue);
    private bool IsVersionInsideRange(Version v, RegistryKey keyPlatform);
    internal static List`1<ExtensionFoldersRegistryKey> GatherVersionStrings(string targetRuntimeVersion, IEnumerable`1<string> versions);
    private static void AddCandidateVersion(SortedDictionary`2<Version, List`1<string>> targetFrameworkVersionToRegistryVersions, string version, Version candidateVersion);
    private sealed virtual override IEnumerator`1<AssemblyFoldersExInfo> System.Collections.Generic.IEnumerable<Microsoft.Build.Utilities.AssemblyFoldersExInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal IEnumerable`1<string> get_UniqueDirectoryPaths();
}
[DataContractAttribute]
internal class Microsoft.Build.Shared.AssemblyFoldersFromConfig.AssemblyFolderCollection : object {
    [CompilerGeneratedAttribute]
private List`1<AssemblyFolderItem> <AssemblyFolders>k__BackingField;
    [DataMemberAttribute]
internal List`1<AssemblyFolderItem> AssemblyFolders { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<AssemblyFolderItem> get_AssemblyFolders();
    [CompilerGeneratedAttribute]
internal void set_AssemblyFolders(List`1<AssemblyFolderItem> value);
    internal static AssemblyFolderCollection Load(string filePath);
}
[DataContractAttribute]
[DebuggerDisplayAttribute("{Name}: FrameworkVersion = {FrameworkVersion}, Platform = {Platform}, Path= {Path}")]
internal class Microsoft.Build.Shared.AssemblyFoldersFromConfig.AssemblyFolderItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [DataMemberAttribute]
internal string Name { get; internal set; }
    [DataMemberAttribute]
internal string FrameworkVersion { get; internal set; }
    [DataMemberAttribute]
internal string Path { get; internal set; }
    [DataMemberAttribute]
internal string Platform { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal string get_FrameworkVersion();
    [CompilerGeneratedAttribute]
internal void set_FrameworkVersion(string value);
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [CompilerGeneratedAttribute]
internal string get_Platform();
    [CompilerGeneratedAttribute]
internal void set_Platform(string value);
}
internal static class Microsoft.Build.Shared.AssemblyResources : object {
    [CompilerGeneratedAttribute]
private static ResourceManager <PrimaryResources>k__BackingField;
    [CompilerGeneratedAttribute]
private static ResourceManager <SharedResources>k__BackingField;
    internal static ResourceManager PrimaryResources { get; }
    internal static ResourceManager SharedResources { get; }
    private static AssemblyResources();
    internal static string GetString(string name);
    [CompilerGeneratedAttribute]
internal static ResourceManager get_PrimaryResources();
    [CompilerGeneratedAttribute]
internal static ResourceManager get_SharedResources();
    internal static string FormatString(string unformatted, Object[] args);
    internal static string FormatResourceString(string resourceName, Object[] args);
}
internal class Microsoft.Build.Shared.BuildEnvironment : object {
    [CompilerGeneratedAttribute]
private BuildEnvironmentMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningTests>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningInMSBuildExe>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningInVisualStudio>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectoryRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory32>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectoryArm64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildConfigurationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildExePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildToolsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualStudioInstallRootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildExtensionsPath>k__BackingField;
    internal BuildEnvironmentMode Mode { get; }
    internal bool RunningTests { get; }
    internal bool RunningInMSBuildExe { get; }
    internal bool RunningInVisualStudio { get; }
    internal string MSBuildToolsDirectoryRoot { get; }
    internal string MSBuildToolsDirectory32 { get; }
    internal string MSBuildToolsDirectory64 { get; }
    internal string MSBuildToolsDirectoryArm64 { get; }
    internal string MSBuildSDKsPath { get; }
    internal string CurrentMSBuildConfigurationFile { get; }
    internal string CurrentMSBuildExePath { get; private set; }
    internal string CurrentMSBuildToolsDirectory { get; }
    internal string VisualStudioInstallRootDirectory { get; }
    internal string MSBuildExtensionsPath { get; internal set; }
    public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInMSBuildExe, bool runningInVisualStudio, string visualStudioPath);
    [CompilerGeneratedAttribute]
internal BuildEnvironmentMode get_Mode();
    [CompilerGeneratedAttribute]
internal bool get_RunningTests();
    [CompilerGeneratedAttribute]
internal bool get_RunningInMSBuildExe();
    [CompilerGeneratedAttribute]
internal bool get_RunningInVisualStudio();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectoryRoot();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory32();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory64();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectoryArm64();
    internal string get_MSBuildSDKsPath();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildConfigurationFile();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildExePath();
    [CompilerGeneratedAttribute]
private void set_CurrentMSBuildExePath(string value);
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildToolsDirectory();
    [CompilerGeneratedAttribute]
internal string get_VisualStudioInstallRootDirectory();
    [CompilerGeneratedAttribute]
internal string get_MSBuildExtensionsPath();
    [CompilerGeneratedAttribute]
internal void set_MSBuildExtensionsPath(string value);
}
internal class Microsoft.Build.Shared.BuildEnvironmentHelper : object {
    private static string CurrentVisualStudioVersion;
    private static string CurrentToolsVersion;
    private static String[] s_visualStudioProcess;
    private static String[] s_msBuildProcess;
    private static String[] s_msBuildExeNames;
    private static Nullable`1<bool> _runningTests;
    private static object _runningTestsLock;
    private static Func`1<string> s_getProcessFromRunningProcess;
    private static Func`1<string> s_getExecutingAssemblyPath;
    private static Func`1<string> s_getAppContextBaseDirectory;
    private static Func`1<IEnumerable`1<VisualStudioInstance>> s_getVisualStudioInstances;
    private static Func`2<string, string> s_getEnvironmentVariable;
    private static Func`1<bool> s_runningTests;
    public static BuildEnvironment Instance { get; }
    private static BuildEnvironmentHelper();
    public static BuildEnvironment get_Instance();
    private static BuildEnvironment Initialize();
    private static BuildEnvironment TryFromEnvironmentVariable();
    private static BuildEnvironment TryFromVisualStudioProcess();
    private static BuildEnvironment TryFromMSBuildProcess();
    private static BuildEnvironment TryFromMSBuildAssembly();
    private static BuildEnvironment TryFromMSBuildExeUnderVisualStudio(string msbuildExe, bool allowLegacyToolsVersion);
    private static BuildEnvironment TryFromDevConsole();
    private static BuildEnvironment TryFromSetupApi();
    private static BuildEnvironment TryFromAppContextBaseDirectory();
    private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePath);
    private static string GetVsRootFromMSBuildAssembly(string msBuildAssembly);
    private static string GetMSBuildExeFromVsRoot(string visualStudioRoot);
    private static bool CheckIfRunningTests();
    private static bool IsProcessInList(string processName, String[] processList);
    private static string GetProcessFromRunningProcess();
    private static string GetExecutingAssemblyPath();
    private static string GetAppContextBaseDirectory();
    private static string GetEnvironmentVariable(string variable);
    internal static void ResetInstance_ForUnitTestsOnly(Func`1<string> getProcessFromRunningProcess, Func`1<string> getExecutingAssemblyPath, Func`1<string> getAppContextBaseDirectory, Func`1<IEnumerable`1<VisualStudioInstance>> getVisualStudioInstances, Func`2<string, string> getEnvironmentVariable, Func`1<bool> runningTests);
    internal static void ResetInstance_ForUnitTestsOnly(BuildEnvironment buildEnvironment);
}
internal enum Microsoft.Build.Shared.BuildEnvironmentMode : Enum {
    public int value__;
    public static BuildEnvironmentMode VisualStudio;
    public static BuildEnvironmentMode Standalone;
    public static BuildEnvironmentMode None;
}
internal static class Microsoft.Build.Shared.CanonicalError : object {
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression;
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression2;
    private static Lazy`1<Regex> s_filenameLocationFromOrigin;
    private static Lazy`1<Regex> s_lineFromLocation;
    private static Lazy`1<Regex> s_lineLineFromLocation;
    private static Lazy`1<Regex> s_lineColFromLocation;
    private static Lazy`1<Regex> s_lineColColFromLocation;
    private static Lazy`1<Regex> s_lineColLineColFromLocation;
    private static CanonicalError();
    private static int ConvertToIntWithDefault(string value);
    internal static Parts Parse(string message);
}
internal static class Microsoft.Build.Shared.Debugging.DebugUtils : object {
    private static Lazy`1<NodeMode> ProcessNodeMode;
    public static string ProcessInfoString;
    public static bool ShouldDebugCurrentProcess;
    [CompilerGeneratedAttribute]
private static string <DebugPath>k__BackingField;
    public static string DebugPath { get; private set; }
    private static DebugUtils();
    internal static void SetDebugPath();
    private static bool CurrentProcessMatchesDebugName();
    [CompilerGeneratedAttribute]
public static string get_DebugPath();
    [CompilerGeneratedAttribute]
private static void set_DebugPath(string value);
    public static string FindNextAvailableDebugFilePath(string fileName);
    [CompilerGeneratedAttribute]
internal static NodeMode <.cctor>g__ScanNodeMode|1_1(string input);
}
internal class Microsoft.Build.Shared.Debugging.PrintLineDebugger : object {
    private static Lazy`1<PropertyInfo> CommonWriterProperty;
    public static Lazy`1<PrintLineDebugger> Default;
    public static Lazy`1<PrintLineDebugger> DefaultWithProcessInfo;
    private string _id;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`3<string, string, IEnumerable`1<string>> _writerSetByThisInstance;
    public PrintLineDebugger(string id, Action`3<string, string, IEnumerable`1<string>> writer);
    private static PrintLineDebugger();
    public sealed virtual void Dispose();
    public static Action`3<string, string, IEnumerable`1<string>> GetStaticWriter();
    public static void SetWriter(Action`3<string, string, IEnumerable`1<string>> writer);
    public static void UnsetWriter();
    public static PrintLineDebugger Create(Action`3<string, string, IEnumerable`1<string>> writer, string id, bool prependProcessInfo);
    public Action`3<string, string, IEnumerable`1<string>> GetWriter();
    public void Log(string message, string memberName, string sourceFilePath, int sourceLineNumber);
    public void Log(IEnumerable`1<string> args, string memberName, string sourceFilePath, int sourceLineNumber);
    private static string CallsiteString(string sourceFilePath, string memberName, int sourceLineNumber);
    private void ReleaseUnmanagedResources();
    protected virtual override void Finalize();
}
internal static class Microsoft.Build.Shared.Debugging.PrintLineDebuggerWriters : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Action`3<string, string, IEnumerable`1<string>> StdOutWriter;
    private static Lazy`1<string> _artifactsLogs;
    public static string ArtifactsLogDirectory { get; }
    private static PrintLineDebuggerWriters();
    public static string get_ArtifactsLogDirectory();
    public static string SimpleFormat(string id, string callsite, IEnumerable`1<string> args);
    public static string CsvFormat(string id, string callsite, IEnumerable`1<string> args);
    [CompilerGeneratedAttribute]
internal static string <CsvFormat>g__EscapeCommas|7_1(string s);
}
internal class Microsoft.Build.Shared.DirectoryExists : MulticastDelegate {
    public DirectoryExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.DirectoryGetFiles : MulticastDelegate {
    public DirectoryGetFiles(object object, IntPtr method);
    public virtual String[] Invoke(string path, string searchPattern);
    public virtual IAsyncResult BeginInvoke(string path, string searchPattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.Shared.DotNetFrameworkArchitecture : Enum {
    public int value__;
    public static DotNetFrameworkArchitecture Current;
    public static DotNetFrameworkArchitecture Bitness32;
    public static DotNetFrameworkArchitecture Bitness64;
}
internal static class Microsoft.Build.Shared.EnvironmentUtilities : object {
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
    [NullableContextAttribute("1")]
public static bool IsWellKnownEnvironmentDerivedProperty(string propertyName);
}
internal static class Microsoft.Build.Shared.ErrorUtilities : object {
    private static bool s_enableMSBuildDebugTracing;
    private static ErrorUtilities();
    public static void DebugTraceMessage(string category, string formatstring, Object[] parameters);
    internal static void VerifyThrowInternalError(bool condition, string message, Object[] args);
    internal static void ThrowInternalError(string message, Object[] args);
    internal static void ThrowInternalError(string message, Exception innerException, Object[] args);
    internal static void ThrowInternalErrorUnreachable();
    internal static void VerifyThrowInternalErrorUnreachable(bool condition);
    internal static void ThrowIfTypeDoesNotImplementToString(object param);
    internal static void VerifyThrowInternalNull(object parameter, string parameterName);
    internal static void VerifyThrowInternalLockHeld(object locker);
    internal static void VerifyThrowInternalLength(string parameterValue, string parameterName);
    public static void VerifyThrowInternalLength(T[] parameterValue, string parameterName);
    internal static void VerifyThrowInternalRooted(string value);
    internal static void VerifyThrow(bool condition, string unformattedMessage);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowInvalidOperation(string resourceName, Object[] args);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgument(string resourceName, Object[] args);
    internal static void ThrowArgument(Exception innerException, string resourceName, Object[] args);
    internal static void VerifyThrowArgument(bool condition, string resourceName);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgumentOutOfRange(string parameterName);
    internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName);
    internal static void VerifyThrowArgumentLength(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLength(IReadOnlyCollection`1<T> parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(IReadOnlyCollection`1<T> parameter, string parameterName);
    private static void ThrowArgumentLength(string parameterName);
    internal static void VerifyThrowArgumentInvalidPath(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName);
    internal static void ThrowArgumentNull(string parameterName, string resourceName);
    internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name);
    internal static void VerifyThrowObjectDisposed(bool condition, string objectName);
    internal static void ThrowObjectDisposed(string objectName);
    internal static void VerifyCollectionCopyToArguments(T[] array, string arrayParameterName, int arrayIndex, string arrayIndexParameterName, int requiredCapacity);
}
internal static class Microsoft.Build.Shared.EscapingUtilities : object {
    private static Dictionary`2<string, string> s_unescapedToEscapedStrings;
    private static Char[] s_charsToEscape;
    private static EscapingUtilities();
    private static bool TryDecodeHexDigit(char character, Int32& value);
    internal static string UnescapeAll(string escapedString, bool trim);
    internal static string EscapeWithCaching(string unescapedString);
    internal static string Escape(string unescapedString);
    private static string EscapeWithOptionalCaching(string unescapedString, bool cache);
    private static bool ContainsReservedCharacters(string unescapedString);
    internal static bool ContainsEscapedWildcards(string escapedString);
    private static char HexDigitChar(int x);
    private static void AppendEscapedChar(StringBuilder sb, char ch);
    private static void AppendEscapedString(StringBuilder sb, string unescapedString);
}
internal static class Microsoft.Build.Shared.EventArgsFormatting : object {
    private static String[] s_newLines;
    private static EventArgsFormatting();
    internal static string FormatEventMessage(BuildErrorEventArgs e, bool showProjectFile, string projectConfigurationDescription);
    internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProjectFile, string projectConfigurationDescription);
    internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription, string nonNullMessage);
    internal static string FormatEventMessage(BuildErrorEventArgs e);
    internal static string FormatEventMessage(BuildErrorEventArgs e, bool showProjectFile);
    internal static string FormatEventMessage(BuildWarningEventArgs e);
    internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProjectFile);
    internal static string FormatEventMessage(BuildMessageEventArgs e);
    internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string nonNullMessage);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, string projectFile, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId, string logOutputProperties);
    private static String[] SplitStringOnNewLines(string s);
}
internal static class Microsoft.Build.Shared.ExceptionHandling : object {
    private static string s_debugDumpPath;
    private static string s_dumpFileName;
    internal static string DebugDumpPath { get; }
    internal static string DumpFilePath { get; }
    private static ExceptionHandling();
    private static string GetDebugDumpPath();
    internal static string get_DebugDumpPath();
    internal static string get_DumpFilePath();
    internal static bool IsCriticalException(Exception e);
    internal static bool NotExpectedException(Exception e);
    internal static bool IsIoRelatedException(Exception e);
    internal static bool IsXmlException(Exception e);
    internal static LineAndColumn GetXmlLineAndColumn(Exception e);
    internal static bool NotExpectedIoOrXmlException(Exception e);
    internal static bool NotExpectedReflectionException(Exception e);
    internal static bool NotExpectedSerializationException(Exception e);
    internal static bool NotExpectedRegistryException(Exception e);
    internal static bool NotExpectedFunctionException(Exception e);
    internal static void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e);
    internal static void DumpExceptionToFile(Exception ex);
    internal static string ReadAnyExceptionFromFile(DateTime fromTimeUtc);
}
internal class Microsoft.Build.Shared.ExtensionFoldersRegistryKey : object {
    [CompilerGeneratedAttribute]
private string <RegistryKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetFrameworkVersion>k__BackingField;
    internal string RegistryKey { get; }
    internal Version TargetFrameworkVersion { get; }
    internal ExtensionFoldersRegistryKey(string registryKey, Version targetFrameworkVersion);
    [CompilerGeneratedAttribute]
internal string get_RegistryKey();
    [CompilerGeneratedAttribute]
internal Version get_TargetFrameworkVersion();
}
internal class Microsoft.Build.Shared.FileCopy : MulticastDelegate {
    public FileCopy(object object, IntPtr method);
    public virtual void Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileCreate : MulticastDelegate {
    public FileCreate(object object, IntPtr method);
    public virtual FileStream Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileStream EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileDelete : MulticastDelegate {
    public FileDelete(object object, IntPtr method);
    public virtual void Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileExists : MulticastDelegate {
    public FileExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileMatcher : object {
    private IFileSystem _fileSystem;
    private static string recursiveDirectoryMatch;
    private static string s_directorySeparator;
    private static string s_thisDirectory;
    private static Char[] s_wildcardCharacters;
    private static Char[] s_wildcardAndSemicolonCharacters;
    private static String[] s_propertyAndItemReferences;
    internal static Char[] directorySeparatorCharacters;
    private static Lazy`1<ConcurrentDictionary`2<string, IReadOnlyList`1<string>>> s_cachedGlobExpansions;
    private static Lazy`1<ConcurrentDictionary`2<string, object>> s_cachedGlobExpansionsLock;
    private ConcurrentDictionary`2<string, IReadOnlyList`1<string>> _cachedGlobExpansions;
    private Lazy`1<ConcurrentDictionary`2<string, object>> _cachedGlobExpansionsLock;
    private static Char[] s_invalidPathChars;
    public static RegexOptions DefaultRegexOptions;
    private GetFileSystemEntries _getFileSystemEntries;
    private static int FileSpecRegexMinLength;
    public static FileMatcher Default;
    public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary`2<string, IReadOnlyList`1<string>> fileEntryExpansionCache);
    internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary`2<string, IReadOnlyList`1<string>> getFileSystemDirectoryEntriesCache);
    private static FileMatcher();
    internal static void ClearFileEnumerationsCache();
    internal static bool HasWildcards(string filespec);
    internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec);
    internal static bool HasPropertyOrItemReferences(string filespec);
    private static IReadOnlyList`1<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
    private static IReadOnlyList`1<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern);
    private static bool ShouldEnforceMatching(string searchPattern);
    private static IReadOnlyList`1<string> GetAccessibleFiles(IFileSystem fileSystem, string path, string filespec, string projectDirectory, bool stripProjectDirectory);
    private static IReadOnlyList`1<string> GetAccessibleDirectories(IFileSystem fileSystem, string path, string pattern);
    internal string GetLongPathName(string path);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    private static void PreprocessFileSpecForSplitting(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveInitialDotSlash>d__35")]
private static IEnumerable`1<string> RemoveInitialDotSlash(IEnumerable`1<string> paths);
    internal static bool IsDirectorySeparator(char c);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveProjectDirectory>d__37")]
internal static IEnumerable`1<string> RemoveProjectDirectory(IEnumerable`1<string> paths, string projectDirectory);
    private void GetFilesRecursive(ConcurrentStack`1<List`1<string>> listOfFiles, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory, IList`1<RecursionState> searchesToExclude, Dictionary`2<string, List`1<RecursionState>> searchesToExcludeInSubdirs, TaskOptions taskOptions);
    private IEnumerable`1<string> GetFilesForStep(RecursiveStepResult stepResult, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory);
    private static bool MatchFileRecursionStep(RecursionState recursionState, string file);
    private static RecursiveStepResult GetFilesRecursiveStep(RecursionState recursionState);
    internal static string RegularExpressionFromFileSpec(string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart);
    private static bool IsLegalFileSpec(string wildcardDirectoryPart, string filenamePart);
    private static bool HasDotDot(string str);
    private static bool HasMisplacedRecursiveOperator(string str);
    private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBuilder regex, string fixedDir);
    private static void AppendRegularExpressionFromWildcardDirectory(ReuseableStringBuilder regex, string wildcardDir);
    private static void AppendRegularExpressionFromFilename(ReuseableStringBuilder regex, string filename);
    private static void AppendRegularExpressionFromChar(ReuseableStringBuilder regex, char ch);
    private static bool IsSpecialRegexCharacter(char ch);
    private static int LastIndexOfDirectorySequence(string str, int startIndex);
    private static int LastIndexOfDirectoryOrRecursiveSequence(string str, int startIndex);
    internal void GetFileSpecInfoWithRegexObject(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec);
    internal void GetFileSpecInfo(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, Boolean& needsRecursion, Boolean& isLegalFileSpec, FixupParts fixupParts);
    internal static bool RawFileSpecIsValid(string filespec);
    internal static bool IsFileNameMatch(string path, string pattern);
    internal static bool IsMatch(string input, string pattern);
    internal static bool IsMatch(ReadOnlySpan`1<char> input, string pattern);
    internal Result FileMatch(string filespec, string fileToMatch);
    internal static void GetRegexMatchInfo(string fileToMatch, Regex fileSpecRegex, Boolean& isMatch, String& wildcardDirectoryPart, String& filenamePart);
    internal ValueTuple`3<String[], SearchAction, string> GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludes);
    private SearchAction GetFileSearchData(string projectDirectoryUnescaped, string filespecUnescaped, Boolean& stripProjectDirectory, RecursionState& result);
    internal static string Normalize(string aString);
    internal static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart);
    private static bool IsDrivePatternWithoutSlash(char firstValue, char secondValue);
    private static bool IsFullFileSystemScan(int directoryPartIndex, int directoryPartLength, string directoryPart, string wildcardPart);
    private static bool IsValidDriveChar(char value);
    private static int SkipSlashes(string aString, int startingIndex);
    private static String[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private ValueTuple`3<String[], SearchAction, string> GetFilesImplementation(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private bool InnerExceptionsAreAllIoRelated(AggregateException ex);
    private static bool IsSubdirectoryOf(string possibleChild, string possibleParent);
    private static bool DirectoryEndsWithPattern(string directoryPath, string pattern);
    internal static bool IsAllFilesWildcard(string pattern);
    internal static bool IsRecursiveDirectoryMatch(string path);
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__CompareIgnoreCase|63_0(ReadOnlySpan`1& input, int iIndex, int pIndex, <>c__DisplayClass63_0& );
}
internal class Microsoft.Build.Shared.FileSystem.CachingFileSystemWrapper : object {
    private IFileSystem _fileSystem;
    private ConcurrentDictionary`2<string, bool> _existenceCache;
    private ConcurrentDictionary`2<string, DateTime> _lastWriteTimeCache;
    public CachingFileSystemWrapper(IFileSystem fileSystem);
    public sealed virtual bool FileOrDirectoryExists(string path);
    public sealed virtual FileAttributes GetAttributes(string path);
    public sealed virtual DateTime GetLastWriteTimeUtc(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual TextReader ReadFile(string path);
    public sealed virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual string ReadFileAllText(string path);
    public sealed virtual Byte[] ReadFileAllBytes(string path);
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    private bool CachedExistenceCheck(string path, Func`2<string, bool> existenceCheck);
    [CompilerGeneratedAttribute]
private bool <FileOrDirectoryExists>b__4_0(string p);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private DateTime <GetLastWriteTimeUtc>b__6_0(string p);
    [CompilerGeneratedAttribute]
private bool <DirectoryExists>b__7_0(string p);
    [CompilerGeneratedAttribute]
private bool <FileExists>b__8_0(string p);
}
internal enum Microsoft.Build.Shared.FileSystem.FileArtifactType : Enum {
    public byte value__;
    public static FileArtifactType File;
    public static FileArtifactType Directory;
    public static FileArtifactType FileOrDirectory;
}
internal static class Microsoft.Build.Shared.FileSystem.FileSystems : object {
    public static IFileSystem Default;
    private static FileSystems();
    private static IFileSystem GetFileSystem();
}
internal interface Microsoft.Build.Shared.FileSystem.IFileSystem {
    public abstract virtual TextReader ReadFile(string path);
    public abstract virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public abstract virtual string ReadFileAllText(string path);
    public abstract virtual Byte[] ReadFileAllBytes(string path);
    public abstract virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual FileAttributes GetAttributes(string path);
    public abstract virtual DateTime GetLastWriteTimeUtc(string path);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual bool FileExists(string path);
    public abstract virtual bool FileOrDirectoryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.ManagedFileSystem : object {
    private static ManagedFileSystem Instance;
    private static bool ShouldUseMicrosoftIO { get; }
    private static ManagedFileSystem();
    public static ManagedFileSystem Singleton();
    private static bool get_ShouldUseMicrosoftIO();
    public sealed virtual TextReader ReadFile(string path);
    public sealed virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual string ReadFileAllText(string path);
    public sealed virtual Byte[] ReadFileAllBytes(string path);
    public virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual FileAttributes GetAttributes(string path);
    public virtual DateTime GetLastWriteTimeUtc(string path);
    public virtual bool DirectoryExists(string path);
    public virtual bool FileExists(string path);
    public virtual bool FileOrDirectoryExists(string path);
}
[SupportedOSPlatformAttribute("windows")]
internal class Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem : object {
    private static MSBuildOnWindowsFileSystem Instance;
    private static MSBuildOnWindowsFileSystem();
    public static MSBuildOnWindowsFileSystem Singleton();
    public sealed virtual TextReader ReadFile(string path);
    public sealed virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual string ReadFileAllText(string path);
    public sealed virtual Byte[] ReadFileAllBytes(string path);
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual FileAttributes GetAttributes(string path);
    public sealed virtual DateTime GetLastWriteTimeUtc(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool FileOrDirectoryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.NativeWin32Exception : Win32Exception {
    public NativeWin32Exception(int nativeErrorCode, string messagePrefix);
    public NativeWin32Exception(int nativeErrorCode);
    public static string GetFormattedMessageForNativeErrorCode(int nativeErrorCode, string messagePrefix);
    public static int HResultFromWin32(int nativeErrorCode);
}
internal class Microsoft.Build.Shared.FileSystem.SafeFindFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
[SupportedOSPlatformAttribute("windows")]
internal class Microsoft.Build.Shared.FileSystem.WindowsFileSystem : ManagedFileSystem {
    private static WindowsFileSystem Instance;
    private static WindowsFileSystem();
    public static WindowsFileSystem Singleton();
    public virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public virtual bool DirectoryExists(string path);
    public virtual bool FileExists(string path);
    public virtual bool FileOrDirectoryExists(string path);
    public virtual DateTime GetLastWriteTimeUtc(string path);
    private static IEnumerable`1<string> EnumerateFileOrDirectories(string directoryPath, FileArtifactType fileArtifactType, string searchPattern, SearchOption searchOption);
    private static EnumerateDirectoryResult CustomEnumerateDirectoryEntries(string directoryPath, FileArtifactType fileArtifactType, string pattern, SearchOption searchOption, ICollection`1<string> result);
}
internal static class Microsoft.Build.Shared.FileSystem.WindowsNative : object {
    public static int MaxPath;
    public static int ErrorSuccess;
    public static int ErrorFileNotFound;
    public static int ErrorPathNotFound;
    public static int ErrorDirectory;
    public static int ErrorAccessDenied;
    public static UInt32 ErrorNoMoreFiles;
    public static SafeFindFileHandle FindFirstFileW(string lpFileName, Win32FindData& lpFindFileData);
    public static bool FindNextFileW(SafeHandle hFindFile, Win32FindData& lpFindFileData);
    public static int PathMatchSpecExW(string pszFileParam, string pszSpec, int flags);
    internal static bool FindClose(IntPtr findFileHandle);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.FileUtilities : object {
    internal static string cacheDirectory;
    internal static StringComparison PathComparison;
    internal static StringComparer PathComparer;
    internal static Char[] InvalidPathChars;
    internal static Char[] InvalidFileNameChars;
    internal static Char[] Slashes;
    internal static string DirectorySeparatorString;
    private static ConcurrentDictionary`2<string, bool> FileExistenceCache;
    private static IFileSystem DefaultFileSystem;
    internal static string FileTimeFormat;
    private static int userRWX;
    private static string tempFileDirectory;
    private static string msbuildTempFolderPrefix;
    internal static string ExecutingAssemblyPath { get; }
    internal static string TempFileDirectory { get; }
    private static FileUtilities();
    internal static void ClearCacheDirectoryPath();
    public static bool GetIsFileSystemCaseSensitive();
    internal static string GetCacheDirectory();
    internal static string GetHexHash(string stringToHash);
    internal static int GetPathsHash(IEnumerable`1<string> assemblyPaths);
    internal static bool CanWriteToDirectory(string directory);
    internal static void ClearCacheDirectory();
    internal static string EnsureTrailingSlash(string fileSpec);
    internal static string EnsureNoLeadingOrTrailingSlash(string path, int start);
    internal static string EnsureTrailingNoLeadingSlash(string path, int start);
    internal static string EnsureNoTrailingSlash(string path);
    internal static string EnsureSingleQuotes(string path);
    internal static string EnsureDoubleQuotes(string path);
    internal static string EnsureQuotes(string path, bool isSingleQuote);
    internal static bool EndsWithSlash(string fileSpec);
    internal static bool IsSlash(char c);
    internal static string TrimAndStripAnyQuotes(string path);
    internal static string GetDirectoryNameOfFullPath(string fullPath);
    internal static string TruncatePathToTrailingSegments(string path, int trailingSegmentsToKeep);
    internal static bool ContainsRelativePathSegments(string path);
    private static bool RelativePathBoundsAreValid(string path, int leftIndex, int rightIndex);
    private static bool IsValidRelativePathBound(Nullable`1<char> c);
    internal static string NormalizePath(string path);
    internal static string NormalizePath(string directory, string file);
    internal static string NormalizePath(String[] paths);
    private static string GetFullPath(string path);
    internal static string FixFilePath(string path);
    internal static string MaybeAdjustFilePath(string value, string baseDirectory);
    [ExtensionAttribute]
internal static bool TryGetPathValue(IReadOnlyDictionary`2<TKey, string> dictionary, TKey key, String& value);
    internal static ReadOnlyMemory`1<char> MaybeAdjustFilePath(ReadOnlyMemory`1<char> value, string baseDirectory);
    private static Span`1<char> ConvertToUnixSlashes(Span`1<char> path);
    private static Span`1<char> CollapseSlashes(Span`1<char> str);
    private static Span`1<char> RemoveQuotes(Span`1<char> path);
    internal static bool IsAnySlash(char c);
    internal static bool LooksLikeUnixFilePath(string value, string baseDirectory);
    internal static bool LooksLikeUnixFilePath(ReadOnlySpan`1<char> value, string baseDirectory);
    internal static string GetDirectory(string fileSpec);
    internal static bool HasExtension(string fileName, String[] allowedExtensions);
    internal static string get_ExecutingAssemblyPath();
    internal static string GetFullPath(string fileSpec, string currentDirectory);
    internal static string GetFullPathNoThrow(string path);
    internal static bool ComparePathsNoThrow(string first, string second, string currentDirectory, bool alwaysIgnoreCase);
    internal static string NormalizePathForComparisonNoThrow(string path, string currentDirectory);
    internal static bool PathIsInvalid(string path);
    internal static void DeleteNoThrow(string path);
    internal static void DeleteDirectoryNoThrow(string path, bool recursive, int retryCount, int retryTimeOut);
    internal static void DeleteWithoutTrailingBackslash(string path, bool recursive);
    internal static FileInfo GetFileInfoNoThrow(string filePath);
    internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool IsSolutionFilename(string filename);
    internal static bool IsSolutionFilterFilename(string filename);
    internal static bool IsVCProjFilename(string filename);
    internal static bool IsDspFilename(string filename);
    internal static bool IsMetaprojectFilename(string filename);
    internal static bool IsBinaryLogFilename(string filename);
    private static bool HasExtension(string filename, string extension);
    internal static string MakeRelative(string basePath, string path);
    internal static string AttemptToShortenPath(string path);
    private static bool IsPathTooLong(string path);
    private static bool IsPathTooLongIfRooted(string path);
    private static bool IsRootedNoThrow(string path);
    internal static string GetFolderAbove(string path, int count);
    internal static string CombinePaths(string root, String[] paths);
    [ExtensionAttribute]
internal static string TrimTrailingSlashes(string s);
    [ExtensionAttribute]
internal static string ToSlash(string s);
    [ExtensionAttribute]
internal static string ToBackslash(string s);
    [ExtensionAttribute]
internal static string ToPlatformSlash(string s);
    [ExtensionAttribute]
internal static string WithTrailingSlash(string s);
    [ExtensionAttribute]
internal static string NormalizeForPathComparison(string s);
    internal static bool PathsEqual(string path1, string path2);
    internal static StreamWriter OpenWrite(string path, bool append, Encoding encoding);
    internal static StreamReader OpenRead(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName, IFileSystem fileSystem);
    internal static string GetPathOfFileAbove(string file, string startingDirectory, IFileSystem fileSystem);
    internal static void EnsureDirectoryExists(string directoryPath);
    private static bool PathsEqualNonAscii(string strA, string strB, int i, int length);
    internal static void ClearFileExistenceCache();
    internal static string get_TempFileDirectory();
    internal static void ClearTempFileDirectory();
    private static string CreateFolderUnderTemp();
    internal static string GetTemporaryDirectory(bool createDirectory, string subfolder);
    internal static string GetTemporaryFileName();
    internal static string GetTemporaryFileName(string extension);
    internal static string GetTemporaryFile();
    internal static string GetTemporaryFile(string fileName, string extension, bool createFile);
    internal static string GetTemporaryFile(string extension);
    internal static string GetTemporaryFile(string directory, string fileName, string extension, bool createFile);
    internal static void CopyDirectory(string source, string dest);
}
internal static class Microsoft.Build.Shared.FileUtilitiesRegex : object {
    private static char _backSlash;
    private static char _forwardSlash;
    internal static bool IsDrivePattern(string pattern);
    internal static bool IsDrivePatternWithSlash(string pattern);
    internal static bool StartsWithDrivePattern(string pattern);
    internal static bool StartsWithDrivePatternWithSlash(string pattern);
    internal static bool IsUncPattern(string pattern);
    internal static bool StartsWithUncPattern(string pattern);
    internal static int StartsWithUncPatternMatchLength(string pattern);
    internal static bool MeetsUncPatternMinimumRequirements(string pattern);
}
internal static class Microsoft.Build.Shared.FrameworkLocationHelper : object {
    internal static string dotNetFrameworkIdentifier;
    internal static Version dotNetFrameworkVersion11;
    internal static Version dotNetFrameworkVersion20;
    internal static Version dotNetFrameworkVersion30;
    internal static Version dotNetFrameworkVersion35;
    internal static Version dotNetFrameworkVersion40;
    internal static Version dotNetFrameworkVersion45;
    internal static Version dotNetFrameworkVersion451;
    internal static Version dotNetFrameworkVersion452;
    internal static Version dotNetFrameworkVersion46;
    internal static Version dotNetFrameworkVersion461;
    internal static Version dotNetFrameworkVersion462;
    internal static Version dotNetFrameworkVersion47;
    internal static Version dotNetFrameworkVersion471;
    internal static Version dotNetFrameworkVersion472;
    internal static Version dotNetFrameworkVersion48;
    internal static Version dotNetFrameworkVersion481;
    internal static Version visualStudioVersion100;
    internal static Version visualStudioVersion110;
    internal static Version visualStudioVersion120;
    internal static Version visualStudioVersion140;
    internal static Version visualStudioVersion150;
    internal static Version visualStudioVersion160;
    internal static Version visualStudioVersion170;
    internal static Version visualStudioVersionLatest;
    private static string dotNetFrameworkRegistryPath;
    private static string dotNetFrameworkSetupRegistryPath;
    private static string dotNetFrameworkSetupRegistryInstalledName;
    internal static string fullDotNetFrameworkRegistryKey;
    internal static string dotNetFrameworkSdkInstallKeyValueV11;
    internal static string dotNetFrameworkVersionFolderPrefixV11;
    private static string dotNetFrameworkVersionV11;
    private static string dotNetFrameworkRegistryKeyV11;
    internal static string dotNetFrameworkSdkInstallKeyValueV20;
    internal static string dotNetFrameworkVersionFolderPrefixV20;
    private static string dotNetFrameworkVersionV20;
    private static string dotNetFrameworkRegistryKeyV20;
    internal static string dotNetFrameworkVersionFolderPrefixV30;
    private static string s_dotNetFrameworkRegistryKeyV30;
    internal static string fallbackDotNetFrameworkSdkInstallKeyValue;
    private static string dotNetFrameworkSdkRegistryPathForV35ToolsOnWinSDK70A;
    private static string fullDotNetFrameworkSdkRegistryPathForV35ToolsOnWinSDK70A;
    private static string dotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
    private static string fullDotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
    internal static string dotNetFrameworkVersionFolderPrefixV35;
    private static string s_dotNetFrameworkRegistryKeyV35;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS10;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS11;
    internal static string dotNetFrameworkVersionFolderPrefixV40;
    internal static string dotNetFrameworkVersionFolderPrefixV45;
    internal static string programFiles;
    internal static string programFiles32;
    internal static string programFiles64;
    internal static string programFilesReferenceAssemblyLocation;
    private static string s_fallbackDotNetFrameworkSdkInstallPath;
    private static string s_pathToV35ToolsInFallbackDotNetFrameworkSdk;
    private static string s_pathToV4ToolsInFallbackDotNetFrameworkSdk;
    private static Lazy`1<VisualStudioSpec[]> VisualStudioSpecs;
    private static Lazy`1<IReadOnlyDictionary`2<Version, DotNetFrameworkSpec>> DotNetFrameworkSpecDict;
    private static Lazy`1<IReadOnlyDictionary`2<Version, VisualStudioSpec>> VisualStudioSpecDict;
    internal static string PathToDotNetFrameworkV11 { get; }
    internal static string PathToDotNetFrameworkV20 { get; }
    internal static string PathToDotNetFrameworkV30 { get; }
    internal static string PathToDotNetFrameworkV35 { get; }
    internal static string PathToDotNetFrameworkV40 { get; }
    internal static string PathToDotNetFrameworkV45 { get; }
    internal static string PathToDotNetFrameworkSdkV11 { get; }
    internal static string PathToDotNetFrameworkSdkV20 { get; }
    private static string FallbackDotNetFrameworkSdkInstallPath { get; }
    private static string PathToV35ToolsInFallbackDotNetFrameworkSdk { get; }
    private static string PathToV4ToolsInFallbackDotNetFrameworkSdk { get; }
    private static FrameworkLocationHelper();
    private static DotNetFrameworkSpec[] DotNetFrameworkSpecs();
    internal static string get_PathToDotNetFrameworkV11();
    internal static string get_PathToDotNetFrameworkV20();
    internal static string get_PathToDotNetFrameworkV30();
    internal static string get_PathToDotNetFrameworkV35();
    internal static string get_PathToDotNetFrameworkV40();
    internal static string get_PathToDotNetFrameworkV45();
    internal static string get_PathToDotNetFrameworkSdkV11();
    internal static string get_PathToDotNetFrameworkSdkV20();
    private static string get_FallbackDotNetFrameworkSdkInstallPath();
    private static string get_PathToV35ToolsInFallbackDotNetFrameworkSdk();
    private static string get_PathToV4ToolsInFallbackDotNetFrameworkSdk();
    internal static string GetDotNetFrameworkSdkRootRegistryKey(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetDotNetFrameworkSdkInstallKeyValue(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetDotNetFrameworkVersionFolderPrefix(Version dotNetFrameworkVersion);
    internal static string GetPathToWindowsSdk(Version dotNetFrameworkVersion);
    internal static string GetPathToDotNetFrameworkReferenceAssemblies(Version dotNetFrameworkVersion);
    internal static string GetPathToDotNetFrameworkSdkTools(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetPathToDotNetFrameworkSdk(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetPathToDotNetFrameworkV11(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV20(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV30(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV40(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV45(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFramework(Version version);
    internal static string GetPathToDotNetFramework(Version version, DotNetFrameworkArchitecture architecture);
    internal static string FindDotNetFrameworkPath(string currentRuntimePath, string prefix, DirectoryExists directoryExists, GetDirectories getDirectories, DotNetFrameworkArchitecture architecture);
    internal static string GenerateProgramFiles32();
    internal static string GenerateProgramFiles64();
    internal static string GenerateProgramFilesReferenceAssemblyRoot();
    internal static string GeneratePathToBuildToolsForToolsVersion(string toolsVersion, DotNetFrameworkArchitecture architecture);
    internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootPath, FrameworkName frameworkName);
    internal static string RemoveDirectories(string path, int numberOfLevelsToRemove);
    private static string GetPathToBuildToolsFromEnvironment(DotNetFrameworkArchitecture architecture);
    private static string GenerateReferenceAssemblyDirectory(string versionPrefix);
    private static VisualStudioSpec GetVisualStudioSpec(Version version);
    private static DotNetFrameworkSpec GetDotNetFrameworkSpec(Version version);
    private static DotNetFrameworkSpec CreateDotNetFrameworkSpecForV4(Version version, Version visualStudioVersion);
    private static void RedirectVersionsIfNecessary(Version& dotNetFrameworkVersion, Version& visualStudioVersion);
}
internal class Microsoft.Build.Shared.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue : MulticastDelegate {
    public GetRegistrySubKeyDefaultValue(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual string Invoke(RegistryKey baseKey, string subKey);
    public virtual IAsyncResult BeginInvoke(RegistryKey baseKey, string subKey, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.GetRegistrySubKeyNames : MulticastDelegate {
    public GetRegistrySubKeyNames(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<string> Invoke(RegistryKey baseKey, string subKey);
    public virtual IAsyncResult BeginInvoke(RegistryKey baseKey, string subKey, AsyncCallback callback, object object);
    public virtual IEnumerable`1<string> EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.OpenBaseKey : MulticastDelegate {
    public OpenBaseKey(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual RegistryKey Invoke(RegistryHive hive, RegistryView view);
    public virtual IAsyncResult BeginInvoke(RegistryHive hive, RegistryView view, AsyncCallback callback, object object);
    public virtual RegistryKey EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.ProcessExtensions : object {
    [ExtensionAttribute]
public static void KillTree(Process process, int timeoutMilliseconds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
internal static class Microsoft.Build.Shared.RegistryHelper : object {
    internal static IEnumerable`1<string> GetSubKeyNames(RegistryKey baseKey, string subkey);
    internal static string GetDefaultValue(RegistryKey baseKey, string subkey);
    internal static RegistryKey OpenBaseKey(RegistryHive hive, RegistryView view);
}
internal static class Microsoft.Build.Shared.ResourceUtilities : object {
    internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, String& code);
    private static string GetHelpKeyword(string resourceName);
    internal static string GetResourceString(string resourceName);
    internal static string FormatResourceStringStripCodeAndKeyword(String& code, String& helpKeyword, string resourceName, Object[] args);
    [ObsoleteAttribute("Use GetResourceString instead.", "True")]
[EditorBrowsableAttribute("1")]
internal static string FormatResourceString(string resourceName);
    internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, Object[] args);
    internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, Object[] args);
    internal static string FormatString(string unformatted, Object[] args);
    [ConditionalAttribute("DEBUG")]
internal static void VerifyResourceStringExists(string resourceName);
}
internal class Microsoft.Build.Shared.ReverseStringGenericComparer : object {
    internal static ReverseStringGenericComparer Comparer;
    private static ReverseStringGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string x, string y);
}
internal class Microsoft.Build.Shared.ReverseVersionGenericComparer : object {
    internal static ReverseVersionGenericComparer Comparer;
    private static ReverseVersionGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.Version>.Compare(Version x, Version y);
}
internal static class Microsoft.Build.Shared.VersionUtilities : object {
    internal static Version ConvertToVersion(string version);
    internal static SortedDictionary`2<Version, List`1<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions);
    internal static Version ConvertToVersion(string version, bool throwException);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig : object {
    private List`1<AssemblyFoldersFromConfigInfo> _directoryNames;
    internal AssemblyFoldersFromConfig(string configFile, string targetRuntimeVersion, ProcessorArchitecture targetArchitecture);
    private void FindDirectories(List`1<AssemblyFolderItem> assemblyTargets, Func`2<AssemblyFolderItem, bool> platformFilter);
    private static List`1<AssemblyFolderItem> GatherVersionStrings(string targetRuntimeVersion, AssemblyFolderCollection collection);
    private static Version GetFrameworkVersion(string version);
    private sealed virtual override IEnumerator`1<AssemblyFoldersFromConfigInfo> System.Collections.Generic.IEnumerable<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Utilities.ApiContract : ValueType {
    internal string Name;
    internal string Version;
    private ApiContract(string name, string version);
    internal static bool IsContainedApiContractsElement(string elementName);
    internal static bool IsVersionedContentElement(string elementName);
    internal static void ReadContractsElement(XmlElement element, ICollection`1<ApiContract> apiContracts);
}
[LoadInSeparateAppDomainAttribute]
[ObsoleteAttribute("AppDomains are no longer supported in .NET Core or .NET 5.0 or higher.")]
public abstract class Microsoft.Build.Utilities.AppDomainIsolatedTask : MarshalByRefObject {
    [CompilerGeneratedAttribute]
private IBuildEngine <BuildEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskHost <HostObject>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskLoggingHelper <Log>k__BackingField;
    public IBuildEngine BuildEngine { get; public set; }
    public ITaskHost HostObject { get; public set; }
    public TaskLoggingHelper Log { get; }
    protected ResourceManager TaskResources { get; protected set; }
    protected string HelpKeywordPrefix { get; protected set; }
    protected AppDomainIsolatedTask(ResourceManager taskResources);
    protected AppDomainIsolatedTask(ResourceManager taskResources, string helpKeywordPrefix);
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    [CompilerGeneratedAttribute]
public TaskLoggingHelper get_Log();
    protected ResourceManager get_TaskResources();
    protected void set_TaskResources(ResourceManager value);
    protected string get_HelpKeywordPrefix();
    protected void set_HelpKeywordPrefix(string value);
    public abstract virtual bool Execute();
    [SecurityCriticalAttribute]
[ObsoleteAttribute("AppDomains are no longer supported in .NET Core or .NET 5.0 or higher.")]
public virtual object InitializeLifetimeService();
}
[SupportedOSPlatformAttribute("windows")]
public class Microsoft.Build.Utilities.AssemblyFoldersExInfo : object {
    [CompilerGeneratedAttribute]
private RegistryHive <Hive>k__BackingField;
    [CompilerGeneratedAttribute]
private RegistryView <View>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetFrameworkVersion>k__BackingField;
    public RegistryHive Hive { get; }
    public RegistryView View { get; }
    public string Key { get; }
    public string DirectoryPath { get; }
    public Version TargetFrameworkVersion { get; }
    public AssemblyFoldersExInfo(RegistryHive hive, RegistryView view, string registryKey, string directoryPath, Version targetFrameworkVersion);
    [CompilerGeneratedAttribute]
public RegistryHive get_Hive();
    [CompilerGeneratedAttribute]
public RegistryView get_View();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    [CompilerGeneratedAttribute]
public Version get_TargetFrameworkVersion();
}
[DebuggerDisplayAttribute("DirectoryPath: {DirectoryPath}, TargetFrameworkVersion = {TargetFrameworkVersion}")]
public class Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo : object {
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetFrameworkVersion>k__BackingField;
    public string DirectoryPath { get; }
    public Version TargetFrameworkVersion { get; }
    public AssemblyFoldersFromConfigInfo(string directoryPath, Version targetFrameworkVersion);
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    [CompilerGeneratedAttribute]
public Version get_TargetFrameworkVersion();
}
public class Microsoft.Build.Utilities.CommandLineBuilder : object {
    [CompilerGeneratedAttribute]
private StringBuilder <CommandLine>k__BackingField;
    private static string s_allowedUnquotedRegexNoHyphen;
    private static string s_definitelyNeedQuotesRegexWithHyphen;
    private static string s_allowedUnquotedRegexWithHyphen;
    private static string s_definitelyNeedQuotesRegexNoHyphen;
    private bool _quoteHyphens;
    private bool _useNewLineSeparator;
    private Regex _allowedUnquoted;
    private Regex _definitelyNeedQuotes;
    public int Length { get; }
    protected StringBuilder CommandLine { get; }
    private Regex DefinitelyNeedQuotes { get; }
    private Regex AllowedUnquoted { get; }
    public CommandLineBuilder(bool quoteHyphensOnCommandLine);
    public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparator);
    public int get_Length();
    [CompilerGeneratedAttribute]
protected StringBuilder get_CommandLine();
    public virtual string ToString();
    private Regex get_DefinitelyNeedQuotes();
    private Regex get_AllowedUnquoted();
    protected virtual bool IsQuotingRequired(string parameter);
    protected void AppendSpaceIfNotEmpty();
    protected void AppendTextWithQuoting(string textToAppend);
    protected void AppendQuotedTextToBuffer(StringBuilder buffer, string unquotedTextToAppend);
    public void AppendTextUnquoted(string textToAppend);
    protected void AppendFileNameWithQuoting(string fileName);
    public void AppendFileNameIfNotNull(string fileName);
    public void AppendFileNameIfNotNull(ITaskItem fileItem);
    public void AppendFileNamesIfNotNull(String[] fileNames, string delimiter);
    public void AppendFileNamesIfNotNull(ITaskItem[] fileItems, string delimiter);
    public void AppendSwitch(string switchName);
    public void AppendSwitchIfNotNull(string switchName, string parameter);
    protected virtual void VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter);
    public void AppendSwitchIfNotNull(string switchName, ITaskItem parameter);
    public void AppendSwitchIfNotNull(string switchName, String[] parameters, string delimiter);
    public void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, string delimiter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, string parameter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, ITaskItem parameter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, String[] parameters, string delimiter);
    public void AppendSwitchUnquotedIfNotNull(string switchName, ITaskItem[] parameters, string delimiter);
}
public enum Microsoft.Build.Utilities.DotNetFrameworkArchitecture : Enum {
    public int value__;
    public static DotNetFrameworkArchitecture Current;
    public static DotNetFrameworkArchitecture Bitness32;
    public static DotNetFrameworkArchitecture Bitness64;
}
internal class Microsoft.Build.Utilities.ExtensionSDK : object {
    private string _path;
    private string _sdkMoniker;
    private Version _sdkVersion;
    private string _sdkIdentifier;
    private SDKManifest _manifest;
    private Version _minVSVersion;
    private Version _maxPlatformVersion;
    public Version Version { get; }
    public string Identifier { get; }
    public SDKType SDKType { get; }
    public Version MinVSVersion { get; }
    public Version MaxPlatformVersion { get; }
    public ICollection`1<ApiContract> ApiContracts { get; }
    private SDKManifest Manifest { get; }
    public ExtensionSDK(string extensionSdkMoniker, string extensionSdkPath);
    public Version get_Version();
    public string get_Identifier();
    public SDKType get_SDKType();
    public Version get_MinVSVersion();
    public Version get_MaxPlatformVersion();
    public ICollection`1<ApiContract> get_ApiContracts();
    private SDKManifest get_Manifest();
    private void ParseMoniker(string moniker);
}
public enum Microsoft.Build.Utilities.HostObjectInitializationStatus : Enum {
    public int value__;
    public static HostObjectInitializationStatus UseHostObjectToExecute;
    public static HostObjectInitializationStatus UseAlternateToolToExecute;
    public static HostObjectInitializationStatus NoActionReturnSuccess;
    public static HostObjectInitializationStatus NoActionReturnFailure;
}
public static class Microsoft.Build.Utilities.LockCheck : object {
    private static string RestartManagerDll;
    private static int CCH_RM_MAX_APP_NAME;
    private static int CCH_RM_MAX_SVC_NAME;
    private static int ERROR_SEM_TIMEOUT;
    private static int ERROR_BAD_ARGUMENTS;
    private static int ERROR_MAX_SESSIONS_REACHED;
    private static int ERROR_WRITE_FAULT;
    private static int ERROR_OUTOFMEMORY;
    private static int ERROR_MORE_DATA;
    private static int ERROR_ACCESS_DENIED;
    private static int ERROR_INVALID_HANDLE;
    private static int ERROR_CANCELLED;
    private static int RM_SESSION_KEY_LEN;
    private static int CCH_RM_SESSION_KEY;
    private static LockCheck();
    private static int RmRegisterResources(UInt32 pSessionHandle, UInt32 nFiles, String[] rgsFilenames, UInt32 nApplications, RM_UNIQUE_PROCESS[] rgApplications, UInt32 nServices, String[] rgsServiceNames);
    private static int RmStartSession(UInt32& pSessionHandle, int dwSessionFlags, Char* strSessionKey);
    private static int RmEndSession(UInt32 pSessionHandle);
    internal static int RmGetList(UInt32 dwSessionHandle, UInt32& pnProcInfoNeeded, UInt32& pnProcInfo, RM_PROCESS_INFO[] rgAffectedApps, UInt32& lpdwRebootReasons);
    internal static string GetProcessesLockingFile(string filePath);
    public static string GetLockedFileMessage(string filePath);
    [SupportedOSPlatformAttribute("windows")]
private static string GetLockedFileMessageWindows(string filePath);
    internal static IEnumerable`1<ProcessInfo> GetLockingProcessInfos(String[] paths);
    private static Exception GetException(int res, string apiName, string message);
}
public abstract class Microsoft.Build.Utilities.Logger : object {
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public virtual void set_Parameters(string value);
    public abstract virtual void Initialize(IEventSource eventSource);
    public virtual void Shutdown();
    public virtual string FormatErrorEvent(BuildErrorEventArgs args);
    public virtual string FormatWarningEvent(BuildWarningEventArgs args);
    public bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity);
}
public enum Microsoft.Build.Utilities.MultipleVersionSupport : Enum {
    public int value__;
    public static MultipleVersionSupport Allow;
    public static MultipleVersionSupport Warning;
    public static MultipleVersionSupport Error;
}
public class Microsoft.Build.Utilities.MuxLogger : object {
    private Dictionary`2<int, SubmissionRecord> _submissionRecords;
    private BuildStartedEventArgs _buildStartedEvent;
    private IEventSource _eventSourceForBuild;
    private BuildStartedEventHandler _buildStartedEventHandler;
    private BuildFinishedEventHandler _buildFinishedEventHandler;
    private ProjectStartedEventHandler _projectStartedEventHandler;
    private ProjectFinishedEventHandler _projectFinishedEventHandler;
    private Dictionary`2<int, int> _submissionProjectsInProgress;
    private int _maxNodeCount;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEvaluationMetaprojects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEvaluationProfiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeTaskInputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEvaluationPropertiesAndItems>k__BackingField;
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public bool IncludeEvaluationMetaprojects { get; public set; }
    public bool IncludeEvaluationProfiles { get; public set; }
    public bool IncludeTaskInputs { get; public set; }
    public bool IncludeEvaluationPropertiesAndItems { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEvaluationMetaprojects();
    [CompilerGeneratedAttribute]
public void set_IncludeEvaluationMetaprojects(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEvaluationProfiles();
    [CompilerGeneratedAttribute]
public void set_IncludeEvaluationProfiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeTaskInputs();
    [CompilerGeneratedAttribute]
public void set_IncludeTaskInputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEvaluationPropertiesAndItems();
    [CompilerGeneratedAttribute]
public void set_IncludeEvaluationPropertiesAndItems(bool value);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Initialize(IEventSource eventSource, int maxNodeCount);
    public sealed virtual void Shutdown();
    public void RegisterLogger(int submissionId, ILogger logger);
    public bool UnregisterLoggers(int submissionId);
    private void BuildStarted(object sender, BuildStartedEventArgs e);
    private void BuildFinished(object sender, BuildFinishedEventArgs e);
    private void ProjectStarted(object sender, ProjectStartedEventArgs e);
    private void ProjectFinished(object sender, ProjectFinishedEventArgs e);
}
internal class Microsoft.Build.Utilities.PlatformManifest : object {
    private string _pathToManifest;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<DependentPlatform> <DependentPlatforms>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ApiContract> <ApiContracts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VersionedContent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReadErrorMessage>k__BackingField;
    public string Name { get; private set; }
    public string FriendlyName { get; private set; }
    public string PlatformVersion { get; private set; }
    public ICollection`1<DependentPlatform> DependentPlatforms { get; private set; }
    public ICollection`1<ApiContract> ApiContracts { get; private set; }
    public bool VersionedContent { get; private set; }
    public bool ReadError { get; }
    public string ReadErrorMessage { get; private set; }
    public PlatformManifest(string pathToManifest);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_FriendlyName();
    [CompilerGeneratedAttribute]
private void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public string get_PlatformVersion();
    [CompilerGeneratedAttribute]
private void set_PlatformVersion(string value);
    [CompilerGeneratedAttribute]
public ICollection`1<DependentPlatform> get_DependentPlatforms();
    [CompilerGeneratedAttribute]
private void set_DependentPlatforms(ICollection`1<DependentPlatform> value);
    [CompilerGeneratedAttribute]
public ICollection`1<ApiContract> get_ApiContracts();
    [CompilerGeneratedAttribute]
private void set_ApiContracts(ICollection`1<ApiContract> value);
    [CompilerGeneratedAttribute]
public bool get_VersionedContent();
    [CompilerGeneratedAttribute]
private void set_VersionedContent(bool value);
    public bool get_ReadError();
    [CompilerGeneratedAttribute]
public string get_ReadErrorMessage();
    [CompilerGeneratedAttribute]
private void set_ReadErrorMessage(string value);
    private void LoadManifestFile();
}
public static class Microsoft.Build.Utilities.ProcessorArchitecture : object {
    public static string X86;
    public static string IA64;
    public static string AMD64;
    public static string MSIL;
    public static string ARM;
    public static string ARM64;
    public static string WASM;
    public static string S390X;
    public static string LOONGARCH64;
    public static string ARMV6;
    public static string PPC64LE;
    public static string CurrentProcessArchitecture { get; }
    public static string get_CurrentProcessArchitecture();
    private static string GetCurrentProcessArchitecture();
}
public class Microsoft.Build.Utilities.SDKManifest : object {
    private static string s_extensionSDKPathPattern;
    private static string s_defaultMaxPlatformVersion;
    private static string s_defaultMinOSVersion;
    private static string s_defaultMaxOSVersionTested;
    private MultipleVersionSupport _supportsMultipleVersions;
    private string _pathToSdk;
    private IDictionary`2<string, string> _appxLocations;
    private IDictionary`2<string, string> _frameworkIdentities;
    private string _maxOSVersionTested;
    private string _minOSVersion;
    private string _maxPlatformVersion;
    private SDKType _sdkType;
    [CompilerGeneratedAttribute]
private string <PlatformIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportPrefer32Bit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyRedistToSubDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportedArchitectures>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DependsOnSDK>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductFamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformMinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinVSVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MoreInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReadErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ApiContract> <ApiContracts>k__BackingField;
    public MultipleVersionSupport SupportsMultipleVersions { get; }
    public IDictionary`2<string, string> FrameworkIdentities { get; }
    public IDictionary`2<string, string> AppxLocations { get; }
    public string PlatformIdentity { get; private set; }
    public string FrameworkIdentity { get; private set; }
    public string SupportPrefer32Bit { get; private set; }
    public SDKType SDKType { get; }
    public string CopyRedistToSubDirectory { get; private set; }
    public string SupportedArchitectures { get; private set; }
    public string DependsOnSDK { get; private set; }
    public string ProductFamilyName { get; private set; }
    public string TargetPlatform { get; private set; }
    public string TargetPlatformMinVersion { get; private set; }
    public string TargetPlatformVersion { get; private set; }
    public string DisplayName { get; private set; }
    public string MinVSVersion { get; private set; }
    public string MinOSVersion { get; }
    public string MaxPlatformVersion { get; }
    public string MaxOSVersionTested { get; }
    public string MoreInfo { get; private set; }
    public bool ReadError { get; private set; }
    public string ReadErrorMessage { get; private set; }
    internal ICollection`1<ApiContract> ApiContracts { get; private set; }
    private bool IsFrameworkExtensionSdkManifest { get; }
    public SDKManifest(string pathToSdk);
    private static SDKManifest();
    public MultipleVersionSupport get_SupportsMultipleVersions();
    public IDictionary`2<string, string> get_FrameworkIdentities();
    public IDictionary`2<string, string> get_AppxLocations();
    [CompilerGeneratedAttribute]
public string get_PlatformIdentity();
    [CompilerGeneratedAttribute]
private void set_PlatformIdentity(string value);
    [CompilerGeneratedAttribute]
public string get_FrameworkIdentity();
    [CompilerGeneratedAttribute]
private void set_FrameworkIdentity(string value);
    [CompilerGeneratedAttribute]
public string get_SupportPrefer32Bit();
    [CompilerGeneratedAttribute]
private void set_SupportPrefer32Bit(string value);
    public SDKType get_SDKType();
    [CompilerGeneratedAttribute]
public string get_CopyRedistToSubDirectory();
    [CompilerGeneratedAttribute]
private void set_CopyRedistToSubDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_SupportedArchitectures();
    [CompilerGeneratedAttribute]
private void set_SupportedArchitectures(string value);
    [CompilerGeneratedAttribute]
public string get_DependsOnSDK();
    [CompilerGeneratedAttribute]
private void set_DependsOnSDK(string value);
    [CompilerGeneratedAttribute]
public string get_ProductFamilyName();
    [CompilerGeneratedAttribute]
private void set_ProductFamilyName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatform();
    [CompilerGeneratedAttribute]
private void set_TargetPlatform(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformMinVersion();
    [CompilerGeneratedAttribute]
private void set_TargetPlatformMinVersion(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
private void set_TargetPlatformVersion(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
private void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_MinVSVersion();
    [CompilerGeneratedAttribute]
private void set_MinVSVersion(string value);
    public string get_MinOSVersion();
    public string get_MaxPlatformVersion();
    public string get_MaxOSVersionTested();
    [CompilerGeneratedAttribute]
public string get_MoreInfo();
    [CompilerGeneratedAttribute]
private void set_MoreInfo(string value);
    [CompilerGeneratedAttribute]
public bool get_ReadError();
    [CompilerGeneratedAttribute]
private void set_ReadError(bool value);
    [CompilerGeneratedAttribute]
public string get_ReadErrorMessage();
    [CompilerGeneratedAttribute]
private void set_ReadErrorMessage(string value);
    [CompilerGeneratedAttribute]
internal ICollection`1<ApiContract> get_ApiContracts();
    [CompilerGeneratedAttribute]
private void set_ApiContracts(ICollection`1<ApiContract> value);
    private bool get_IsFrameworkExtensionSdkManifest();
    private void LoadManifestFile();
    private void ReadFileListAttributes(XmlAttributeCollection attributes);
    private static MultipleVersionSupport ParseSupportMultipleVersions(string multipleVersionsValue);
}
public enum Microsoft.Build.Utilities.SDKType : Enum {
    public int value__;
    public static SDKType Unspecified;
    public static SDKType External;
    public static SDKType Platform;
    public static SDKType Framework;
}
public enum Microsoft.Build.Utilities.TargetDotNetFrameworkVersion : Enum {
    public int value__;
    public static TargetDotNetFrameworkVersion Version11;
    public static TargetDotNetFrameworkVersion Version20;
    public static TargetDotNetFrameworkVersion Version30;
    public static TargetDotNetFrameworkVersion Version35;
    public static TargetDotNetFrameworkVersion Version40;
    public static TargetDotNetFrameworkVersion Version45;
    public static TargetDotNetFrameworkVersion Version451;
    public static TargetDotNetFrameworkVersion Version46;
    public static TargetDotNetFrameworkVersion Version461;
    public static TargetDotNetFrameworkVersion Version452;
    public static TargetDotNetFrameworkVersion Version462;
    public static TargetDotNetFrameworkVersion Version47;
    public static TargetDotNetFrameworkVersion Version471;
    public static TargetDotNetFrameworkVersion Version472;
    public static TargetDotNetFrameworkVersion Version48;
    public static TargetDotNetFrameworkVersion Version481;
    public static TargetDotNetFrameworkVersion VersionLatest;
    public static TargetDotNetFrameworkVersion Latest;
}
public class Microsoft.Build.Utilities.TargetPlatformSDK : object {
    private string _path;
    private SDKManifest _manifest;
    private Version _minVSVersion;
    private Version _minOSVersion;
    [CompilerGeneratedAttribute]
private string <TargetPlatformIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ExtensionSDKs>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Platforms>k__BackingField;
    public Version MinVSVersion { get; }
    public Version MinOSVersion { get; }
    public string TargetPlatformIdentifier { get; }
    public Version TargetPlatformVersion { get; }
    public string Path { get; public set; }
    public string DisplayName { get; }
    internal Dictionary`2<string, string> ExtensionSDKs { get; }
    internal Dictionary`2<string, string> Platforms { get; }
    private SDKManifest Manifest { get; }
    public TargetPlatformSDK(string targetPlatformIdentifier, Version targetPlatformVersion, string path);
    public Version get_MinVSVersion();
    public Version get_MinOSVersion();
    [CompilerGeneratedAttribute]
public string get_TargetPlatformIdentifier();
    [CompilerGeneratedAttribute]
public Version get_TargetPlatformVersion();
    public string get_Path();
    public void set_Path(string value);
    public string get_DisplayName();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_ExtensionSDKs();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_Platforms();
    private SDKManifest get_Manifest();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TargetPlatformSDK other);
    public bool ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion);
    internal static string GetSdkKey(string sdkIdentifier, string sdkVersion);
}
public abstract class Microsoft.Build.Utilities.Task : object {
    [CompilerGeneratedAttribute]
private IBuildEngine <BuildEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskHost <HostObject>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskLoggingHelper <Log>k__BackingField;
    public IBuildEngine BuildEngine { get; public set; }
    public IBuildEngine2 BuildEngine2 { get; }
    public IBuildEngine3 BuildEngine3 { get; }
    public IBuildEngine4 BuildEngine4 { get; }
    public IBuildEngine5 BuildEngine5 { get; }
    public IBuildEngine6 BuildEngine6 { get; }
    public IBuildEngine7 BuildEngine7 { get; }
    public IBuildEngine8 BuildEngine8 { get; }
    public IBuildEngine9 BuildEngine9 { get; }
    public ITaskHost HostObject { get; public set; }
    public TaskLoggingHelper Log { get; }
    protected ResourceManager TaskResources { get; protected set; }
    protected string HelpKeywordPrefix { get; protected set; }
    protected Task(ResourceManager taskResources);
    protected Task(ResourceManager taskResources, string helpKeywordPrefix);
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    public IBuildEngine2 get_BuildEngine2();
    public IBuildEngine3 get_BuildEngine3();
    public IBuildEngine4 get_BuildEngine4();
    public IBuildEngine5 get_BuildEngine5();
    public IBuildEngine6 get_BuildEngine6();
    public IBuildEngine7 get_BuildEngine7();
    public IBuildEngine8 get_BuildEngine8();
    public IBuildEngine9 get_BuildEngine9();
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    [CompilerGeneratedAttribute]
public TaskLoggingHelper get_Log();
    protected ResourceManager get_TaskResources();
    protected void set_TaskResources(ResourceManager value);
    protected string get_HelpKeywordPrefix();
    protected void set_HelpKeywordPrefix(string value);
    public abstract virtual bool Execute();
}
public class Microsoft.Build.Utilities.TaskItem : object {
    private string _itemSpec;
    private CopyOnWriteDictionary`1<string> _metadata;
    private string _fullPath;
    private string _definingProject;
    public string ItemSpec { get; public set; }
    private string Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped { get; private set; }
    public ICollection MetadataNames { get; }
    public int MetadataCount { get; }
    private CopyOnWriteDictionary`1<string> Metadata { get; private set; }
    public TaskItem(string itemSpec);
    public TaskItem(string itemSpec, IDictionary itemMetadata);
    public TaskItem(ITaskItem sourceItem);
    public sealed virtual string get_ItemSpec();
    public sealed virtual void set_ItemSpec(string value);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.get_EvaluatedIncludeEscaped();
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.set_EvaluatedIncludeEscaped(string value);
    public sealed virtual ICollection get_MetadataNames();
    public sealed virtual int get_MetadataCount();
    private CopyOnWriteDictionary`1<string> get_Metadata();
    private void set_Metadata(CopyOnWriteDictionary`1<string> value);
    public sealed virtual void RemoveMetadata(string metadataName);
    public sealed virtual void SetMetadata(string metadataName, string metadataValue);
    public sealed virtual string GetMetadata(string metadataName);
    public sealed virtual void CopyMetadataTo(ITaskItem destinationItem);
    public sealed virtual IDictionary CloneCustomMetadata();
    public virtual string ToString();
    public static string op_Explicit(TaskItem taskItemToCast);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue);
    private sealed virtual override IDictionary Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped();
    private sealed virtual override IEnumerable`1<KeyValuePair`2<string, string>> Microsoft.Build.Framework.IMetadataContainer.EnumerateMetadata();
    private sealed virtual override void Microsoft.Build.Framework.IMetadataContainer.ImportMetadata(IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    private IEnumerable`1<KeyValuePair`2<string, string>> EnumerateMetadataEager();
    [IteratorStateMachineAttribute("Microsoft.Build.Utilities.TaskItem/<EnumerateMetadataLazy>d__34")]
private IEnumerable`1<KeyValuePair`2<string, string>> EnumerateMetadataLazy();
}
public class Microsoft.Build.Utilities.TaskLoggingHelper : object {
    private ITask _taskInstance;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    private string _taskNameUpperCase;
    private IBuildEngine _buildEngine;
    [CompilerGeneratedAttribute]
private ResourceManager <TaskResources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeywordPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLoggedErrors>k__BackingField;
    protected string TaskName { get; }
    private string TaskNameUpperCase { get; }
    protected IBuildEngine BuildEngine { get; }
    public ResourceManager TaskResources { get; public set; }
    public string HelpKeywordPrefix { get; public set; }
    public bool HasLoggedErrors { get; private set; }
    public bool IsTaskInputLoggingEnabled { get; }
    public TaskLoggingHelper(ITask taskInstance);
    public TaskLoggingHelper(IBuildEngine buildEngine, string taskName);
    [CompilerGeneratedAttribute]
protected string get_TaskName();
    private string get_TaskNameUpperCase();
    protected IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public ResourceManager get_TaskResources();
    [CompilerGeneratedAttribute]
public void set_TaskResources(ResourceManager value);
    [CompilerGeneratedAttribute]
public string get_HelpKeywordPrefix();
    [CompilerGeneratedAttribute]
public void set_HelpKeywordPrefix(string value);
    [CompilerGeneratedAttribute]
public bool get_HasLoggedErrors();
    [CompilerGeneratedAttribute]
private void set_HasLoggedErrors(bool value);
    public string ExtractMessageCode(string message, String& messageWithoutCodePrefix);
    public virtual string FormatResourceString(string resourceName, Object[] args);
    public virtual string FormatString(string unformatted, Object[] args);
    public virtual string GetResourceMessage(string resourceName);
    public bool get_IsTaskInputLoggingEnabled();
    public bool LogsMessagesOfImportance(MessageImportance importance);
    public void LogMessage(string message, Object[] messageArgs);
    public void LogMessage(MessageImportance importance, string message, Object[] messageArgs);
    public void LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, MessageImportance importance, string message, Object[] messageArgs);
    public void LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogMessageFromResources(string messageResourceName, Object[] messageArgs);
    public void LogMessageFromResources(MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public void LogIncludeGeneratedFile(string filePath, string content);
    public static string GetInnerExceptionMessageString(Exception e);
    public void LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames);
    public void LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded);
    public void LogCommandLine(string commandLine);
    public void LogCommandLine(MessageImportance importance, string commandLine);
    public void LogError(string message, Object[] messageArgs);
    public void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogErrorFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorFromException(Exception exception);
    public void LogErrorFromException(Exception exception, bool showStackTrace);
    public void LogErrorFromException(Exception exception, bool showStackTrace, bool showDetail, string file);
    public void LogWarning(string message, Object[] messageArgs);
    public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogWarningFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningFromException(Exception exception);
    public void LogWarningFromException(Exception exception, bool showStackTrace);
    public bool LogMessagesFromFile(string fileName);
    public bool LogMessagesFromFile(string fileName, MessageImportance messageImportance);
    public bool LogMessagesFromStream(TextReader stream, MessageImportance messageImportance);
    public bool LogMessageFromText(string lineOfText, MessageImportance messageImportance);
    public void LogTelemetry(string eventName, IDictionary`2<string, string> properties);
}
public static class Microsoft.Build.Utilities.ToolLocationHelper : object {
    private static Dictionary`2<string, string> s_chainedReferenceAssemblyPath;
    private static object s_locker;
    private static Dictionary`2<string, IList`1<string>> s_cachedReferenceAssemblyPaths;
    private static Dictionary`2<string, FrameworkName> s_cachedHighestFrameworkNameForTargetFrameworkIdentifier;
    private static Dictionary`2<string, IEnumerable`1<TargetPlatformSDK>> s_cachedTargetPlatforms;
    private static Dictionary`2<string, TargetPlatformSDK> s_cachedExtensionSdks;
    private static Dictionary`2<string, string> s_cachedTargetFrameworkDisplayNames;
    private static Dictionary`2<string, String[]> s_cachedTargetPlatformReferences;
    private static Dictionary`2<string, String[]> s_cachedExtensionSdkReferences;
    private static List`1<string> s_targetFrameworkMonikers;
    private static Dictionary`2<string, String[]> s_vsInstallFolders;
    private static Char[] _separatorForFallbackSearchPaths;
    private static string retailConfigurationName;
    private static string neutralArchitectureName;
    private static string commonConfigurationFolderName;
    private static string redistFolderName;
    private static string referencesFolderName;
    private static string designTimeFolderName;
    private static string platformsFolderName;
    private static string uapDirectoryName;
    private static string uapRegistryName;
    private static int uapVersion;
    private static Char[] s_diskRootSplitChars;
    public static string CurrentToolsVersion { get; }
    public static string PathToSystem { get; }
    private static ToolLocationHelper();
    public static string get_CurrentToolsVersion();
    [SupportedOSPlatformAttribute("windows")]
public static IList`1<AssemblyFoldersExInfo> GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, ProcessorArchitecture targetProcessorArchitecture);
    public static IList`1<AssemblyFoldersFromConfigInfo> GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, ProcessorArchitecture targetProcessorArchitecture);
    public static IDictionary`2<string, string> GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, string> GetPlatformExtensionSDKLocations(String[] diskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, string> GetPlatformExtensionSDKLocations(String[] diskRoots, String[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, Tuple`2<string, string>> GetPlatformExtensionSDKLocationsAndVersions(string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, Tuple`2<string, string>> GetPlatformExtensionSDKLocationsAndVersions(String[] diskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static IDictionary`2<string, Tuple`2<string, string>> GetPlatformExtensionSDKLocationsAndVersions(String[] diskRoots, String[] multiPlatformDiskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    private static IEnumerable`1<TargetPlatformSDK> GetTargetPlatformMonikers(String[] diskRoots, String[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, Version targetPlatformVersion);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, Version targetPlatformVersion, String[] diskRoots, string registryRoot);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, Version targetPlatformVersion, String[] diskRoots, String[] extensionDiskRoots, string registryRoot);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static string GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string extensionDiskRoots, string registryRoot);
    public static IDictionary`2<string, string> FilterPlatformExtensionSDKs(Version targetPlatformVersion, IDictionary`2<string, string> extensionSdks);
    public static IList`1<string> GetSDKReferenceFolders(string sdkRoot);
    public static IList`1<string> GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture);
    private static void AddSDKPaths(string sdkRoot, string folderName, string targetConfiguration, string targetArchitecture, List`1<string> directories);
    public static IList`1<string> GetSDKRedistFolders(string sdkRoot);
    public static IList`1<string> GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture);
    public static IList`1<string> GetSDKDesignTimeFolders(string sdkRoot);
    public static IList`1<string> GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture);
    public static IList`1<TargetPlatformSDK> GetTargetPlatformSdks();
    public static IList`1<TargetPlatformSDK> GetTargetPlatformSdks(String[] diskRoots, string registryRoot);
    public static IList`1<TargetPlatformSDK> FilterTargetPlatformSdks(IList`1<TargetPlatformSDK> targetPlatformSdkList, Version osVersion, Version vsVersion);
    public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion);
    public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static String[] GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion);
    public static String[] GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static String[] GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot);
    public static String[] GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, string targetPlatformVersion);
    private static string GetPlatformVersion(TargetPlatformSDK targetSdk, string targetPlatformIdentifier, string targetPlatformVersion);
    private static String[] GetLegacyTargetPlatformReferences(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot);
    private static String[] GetTargetPlatformReferencesFromManifest(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot);
    internal static String[] GetApiContractReferences(IEnumerable`1<ApiContract> apiContracts, string targetPlatformSdkRoot);
    internal static String[] GetApiContractReferences(IEnumerable`1<ApiContract> apiContracts, string targetPlatformSdkRoot, string targetPlatformSdkVersion);
    private static bool TryGetPlatformManifest(TargetPlatformSDK matchingSdk, string platformKey, PlatformManifest& manifest);
    public static string GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, Version targetPlatformVersion);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, Version targetPlatformVersion, String[] diskRoots, string registryRoot);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion);
    public static string GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion);
    public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot);
    public static IEnumerable`1<string> GetPlatformsForSDK(string sdkIdentifier, Version sdkVersion);
    public static IEnumerable`1<string> GetPlatformsForSDK(string sdkIdentifier, Version sdkVersion, String[] diskRoots, string registryRoot);
    public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion);
    public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, String[] sdkRoots);
    public static IEnumerable`1<string> GetFoldersInVSInstalls(Version minVersion, Version maxVersion, string subFolder);
    public static string GetFoldersInVSInstallsAsString(string minVersionString, string maxVersionString, string subFolder);
    public static string FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths);
    private static bool TryParsePlatformVersion(string platformMoniker, Version& platformVersion);
    private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string multiPlatformDiskRoots, string registryRoot);
    private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIdentifier, Version targetPlatformVersion, String[] diskRoots, String[] multiPlatformDiskRoots, string registryRoot);
    private static string GenerateDefaultSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion);
    public static string get_PathToSystem();
    public static string GetDotNetFrameworkVersionFolderPrefix(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkRootRegistryKey(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion version);
    public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion version, DotNetFrameworkArchitecture architecture);
    public static string GetPathToDotNetFrameworkSdk();
    public static string GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion version);
    public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile);
    public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget);
    public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath);
    public static string GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths);
    public static IList`1<string> GetPathToReferenceAssemblies(FrameworkName frameworkName);
    private static string VersionToDotNetFrameworkPath(VersionToPath PathToDotNetFramework, TargetDotNetFrameworkVersion version);
    private static string VersionToDotNetReferenceAssemblies(VersionToPath PathToDotReferenceAssemblies, TargetDotNetFrameworkVersion version);
    internal static IList`1<string> HandleLegacyDotNetFrameworkReferenceAssemblyPaths(VersionToPath PathToDotNetFramework, VersionToPath PathToReferenceAssemblies, FrameworkName frameworkName);
    private static string GetPathToDotNetFrameworkSdkToolsFolderRoot(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    private static Version TargetDotNetFrameworkVersionToSystemVersion(TargetDotNetFrameworkVersion version);
    private static Version VisualStudioVersionToSystemVersion(VisualStudioVersion version);
    private static string GenerateReferenceAssemblyCacheKey(string targetFrameworkRootPath, FrameworkName frameworkName);
    private static void CreateReferenceAssemblyPathsCache();
    private static IList`1<string> HandleLegacy35(VersionToPath PathToDotNetFramework, VersionToPath PathToReferenceAssemblies);
    private static IList`1<string> HandleLegacy30(VersionToPath PathToDotNetFramework, VersionToPath PathToReferenceAssemblies);
    private static IList`1<string> HandleLegacy20(VersionToPath PathToDotNetFramework);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, FrameworkName frameworkName);
    public static IList`1<string> GetPathToReferenceAssemblies(string targetFrameworkRootPath, FrameworkName frameworkName);
    public static string GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, FrameworkName frameworkName);
    private static IList`1<string> GetPathAndChainReferenceAssemblyLocations(string targetFrameworkRootPath, FrameworkName frameworkName, bool chain);
    public static void ClearSDKStaticCache();
    internal static void ClearStaticCaches();
    private static string RemapSdkArchitecture(string targetArchitecture);
    private static void AddSDKPath(string sdkRoot, string contentFolderName, string targetConfiguration, string targetArchitecture, List`1<string> contentDirectories);
    private static IEnumerable`1<TargetPlatformSDK> RetrieveTargetPlatformList(String[] diskRoots, String[] extensionDiskRoots, string registrySearchLocation);
    private static void GatherExtensionSDKListFromDirectory(IEnumerable`1<string> diskRoots, TargetPlatformSDK extensionSdk);
    internal static void GatherExtensionSDKs(DirectoryInfo extensionSdksDirectory, TargetPlatformSDK targetPlatformSDK);
    internal static void GatherSDKListFromDirectory(List`1<string> diskroots, Dictionary`2<TargetPlatformSDK, TargetPlatformSDK> platformSDKs);
    [SupportedOSPlatformAttribute("windows")]
internal static void GatherSDKsFromRegistryImpl(Dictionary`2<TargetPlatformSDK, TargetPlatformSDK> platformMonikers, string registryKeyRoot, RegistryView registryView, RegistryHive registryHive, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, OpenBaseKey openBaseKey, FileExists fileExists);
    [SupportedOSPlatformAttribute("windows")]
private static void GatherSDKListFromRegistry(string registryRoot, Dictionary`2<TargetPlatformSDK, TargetPlatformSDK> platformMonikers);
    private static void GetDefaultSDKDiskRoots(List`1<string> diskRoots);
    private static void ExtractSdkDiskRootsFromEnvironment(List`1<string> diskRoots, string directoryRoots);
    private static List`1<string> GetTargetPlatformMonikerDiskRoots(String[] diskRoots);
    private static List`1<string> GetExtensionSdkDiskRoots(String[] diskRoots);
    private static string GetTargetPlatformMonikerRegistryRoots(string registryRootLocation);
    private static void GatherPlatformsForSdk(TargetPlatformSDK sdk);
    internal static string ChainReferenceAssemblyPath(string targetFrameworkDirectory);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, DotNetFrameworkArchitecture architecture);
    public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture);
    private static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture, bool canFallBackIfNecessary);
    internal static string GetPathToDotNetFrameworkSdkFile(string fileName, string pathToSdk, string processorArchitecture);
    internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture(DotNetFrameworkArchitecture architecture);
    [ObsoleteAttribute("Consider using GetPlatformSDKLocation instead")]
public static string GetPathToWindowsSdk(TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    [ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion);
    [ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture);
    [ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
private static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, DotNetFrameworkArchitecture architecture, bool canFallBackIfNecessary);
    [ObsoleteAttribute("Consider using GetPlatformSDKLocationFile instead")]
private static string GetPathToWindowsSdkFile(string fileName, string pathToSdk, string processorArchitecture);
    public static string GetPathToBuildTools(string toolsVersion);
    public static string GetPathToBuildTools(string toolsVersion, DotNetFrameworkArchitecture architecture);
    public static string GetPathToBuildToolsFile(string fileName, string toolsVersion);
    public static string GetPathToBuildToolsFile(string fileName, string toolsVersion, DotNetFrameworkArchitecture architecture);
    public static string GetPathToDotNetFrameworkFile(string fileName, TargetDotNetFrameworkVersion version);
    public static string GetPathToDotNetFrameworkFile(string fileName, TargetDotNetFrameworkVersion version, DotNetFrameworkArchitecture architecture);
    public static string GetPathToSystemFile(string fileName);
    public static IList`1<string> GetSupportedTargetFrameworks();
    public static FrameworkName HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier);
    public static string GetProgramFilesReferenceAssemblyRoot();
    private static DotNetFrameworkArchitecture ConvertToSharedDotNetFrameworkArchitecture(DotNetFrameworkArchitecture architecture);
    private static Version ConvertTargetFrameworkVersionToVersion(string targetFrameworkVersion);
    internal static IList`1<string> GetFrameworkIdentifiers(string frameworkReferenceRoot);
    private static IList`1<string> GetFrameworkVersions(string frameworkReferenceRoot, string frameworkIdentifier);
    private static IList`1<string> GetFrameworkProfiles(string frameworkReferenceRoot, string frameworkIdentifier, string frameworkVersion);
    private static IList`1<string> GetFx35AndEarlierVersions(string frameworkReferenceRoot);
    [CompilerGeneratedAttribute]
internal static Version <VisualStudioVersionToSystemVersion>g__Unsupported|109_0(<>c__DisplayClass109_0& );
}
public abstract class Microsoft.Build.Utilities.ToolTask : Task {
    private static bool s_preserveTempFiles;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <YieldDuringToolExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCommandProcessor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EchoOff>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TaskProcessTerminationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private ManualResetEvent <ToolCanceled>k__BackingField;
    private string _temporaryBatchFile;
    private Encoding _encoding;
    [CompilerGeneratedAttribute]
private string <ToolPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UseUtf8Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardOutputImportance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardErrorImportance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogStandardErrorAsError>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskLoggingHelper <LogPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskLoggingHelper <LogShared>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <canBeIncremental>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    private object _eventCloseLock;
    private static Char[] s_equalsSplitter;
    private MessageImportance _standardOutputImportanceToUse;
    private MessageImportance _standardErrorImportanceToUse;
    private Queue _standardErrorData;
    private Queue _standardOutputData;
    private ManualResetEvent _standardErrorDataAvailable;
    private ManualResetEvent _standardOutputDataAvailable;
    private ManualResetEvent _toolExited;
    private bool _terminatedTool;
    private ManualResetEvent _toolTimeoutExpired;
    private Timer _toolTimer;
    private string _toolExe;
    private bool _eventsDisposed;
    private List`1<KeyValuePair`2<string, string>> _environmentVariablePairs;
    [OutputAttribute]
public int ExitCode { get; private set; }
    public bool YieldDuringToolExecution { get; public set; }
    public bool UseCommandProcessor { get; public set; }
    public bool EchoOff { get; public set; }
    protected int TaskProcessTerminationTimeout { get; protected set; }
    protected ManualResetEvent ToolCanceled { get; private set; }
    protected string ToolName { get; }
    public string ToolExe { get; public set; }
    public string ToolPath { get; public set; }
    public string UseUtf8Encoding { get; public set; }
    public String[] EnvironmentVariables { get; public set; }
    public int Timeout { get; public set; }
    protected Encoding ResponseFileEncoding { get; }
    protected Encoding StandardOutputEncoding { get; }
    protected Encoding StandardErrorEncoding { get; }
    [ObsoleteAttribute("Use EnvironmentVariables property")]
protected Dictionary`2<string, string> EnvironmentOverride { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    protected bool HasLoggedErrors { get; }
    public string StandardOutputImportance { get; public set; }
    public string StandardErrorImportance { get; public set; }
    public bool LogStandardErrorAsError { get; public set; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    protected MessageImportance StandardOutputImportanceToUse { get; }
    protected MessageImportance StandardErrorImportanceToUse { get; }
    private TaskLoggingHelper LogPrivate { get; }
    private TaskLoggingHelper LogShared { get; }
    protected bool canBeIncremental { get; protected set; }
    public bool FailIfNotIncremental { get; public set; }
    protected ToolTask(ResourceManager taskResources);
    protected ToolTask(ResourceManager taskResources, string helpKeywordPrefix);
    private static ToolTask();
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
private void set_ExitCode(int value);
    [CompilerGeneratedAttribute]
public bool get_YieldDuringToolExecution();
    [CompilerGeneratedAttribute]
public void set_YieldDuringToolExecution(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseCommandProcessor();
    [CompilerGeneratedAttribute]
public void set_UseCommandProcessor(bool value);
    [CompilerGeneratedAttribute]
public bool get_EchoOff();
    [CompilerGeneratedAttribute]
public void set_EchoOff(bool value);
    [CompilerGeneratedAttribute]
protected int get_TaskProcessTerminationTimeout();
    [CompilerGeneratedAttribute]
protected void set_TaskProcessTerminationTimeout(int value);
    [CompilerGeneratedAttribute]
protected ManualResetEvent get_ToolCanceled();
    [CompilerGeneratedAttribute]
private void set_ToolCanceled(ManualResetEvent value);
    protected abstract virtual string get_ToolName();
    public virtual string get_ToolExe();
    public virtual void set_ToolExe(string value);
    [CompilerGeneratedAttribute]
public void set_ToolPath(string value);
    [CompilerGeneratedAttribute]
public string get_ToolPath();
    [CompilerGeneratedAttribute]
public string get_UseUtf8Encoding();
    [CompilerGeneratedAttribute]
public void set_UseUtf8Encoding(string value);
    [CompilerGeneratedAttribute]
public String[] get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(String[] value);
    [CompilerGeneratedAttribute]
public virtual void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public virtual int get_Timeout();
    protected virtual Encoding get_ResponseFileEncoding();
    protected virtual string ResponseFileEscape(string responseString);
    protected virtual Encoding get_StandardOutputEncoding();
    protected virtual Encoding get_StandardErrorEncoding();
    protected virtual Dictionary`2<string, string> get_EnvironmentOverride();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual bool get_HasLoggedErrors();
    [CompilerGeneratedAttribute]
public string get_StandardOutputImportance();
    [CompilerGeneratedAttribute]
public void set_StandardOutputImportance(string value);
    [CompilerGeneratedAttribute]
public string get_StandardErrorImportance();
    [CompilerGeneratedAttribute]
public void set_StandardErrorImportance(string value);
    [CompilerGeneratedAttribute]
public bool get_LogStandardErrorAsError();
    [CompilerGeneratedAttribute]
public void set_LogStandardErrorAsError(bool value);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected MessageImportance get_StandardOutputImportanceToUse();
    protected MessageImportance get_StandardErrorImportanceToUse();
    [CompilerGeneratedAttribute]
private TaskLoggingHelper get_LogPrivate();
    [CompilerGeneratedAttribute]
private TaskLoggingHelper get_LogShared();
    protected virtual void ProcessStarted();
    protected abstract virtual string GenerateFullPathToTool();
    protected virtual string GetWorkingDirectory();
    protected internal virtual bool ValidateParameters();
    protected virtual bool SkipTaskExecution();
    [CompilerGeneratedAttribute]
protected bool get_canBeIncremental();
    [CompilerGeneratedAttribute]
protected void set_canBeIncremental(bool value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    protected virtual string GenerateResponseFileCommands();
    protected virtual string GenerateCommandLineCommands();
    protected virtual string GetResponseFileSwitch(string responseFilePath);
    protected virtual bool HandleTaskExecutionErrors();
    protected virtual bool CallHostObjectToExecute();
    protected virtual HostObjectInitializationStatus InitializeHostObject();
    protected virtual void LogToolCommand(string message);
    protected virtual void LogPathToTool(string toolName, string pathToTool);
    private string ComputePathToTool();
    private string GetTemporaryResponseFile(string responseFileCommands, String& responseFileSwitch);
    protected virtual ProcessStartInfo GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch);
    protected virtual Process StartToolProcess(Process proc);
    protected virtual int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands);
    public virtual void Cancel();
    protected void DeleteTempFile(string fileName);
    private void HandleToolNotifications(Process proc);
    private void KillToolProcessOnTimeout(Process proc, bool isBeingCancelled);
    private void TerminateToolProcess(Process proc, bool isBeingCancelled);
    private static void WaitForProcessExit(Process proc);
    private void LogMessagesFromStandardError();
    private void LogMessagesFromStandardOutput();
    private void LogMessagesFromStandardErrorOrOutput(Queue dataQueue, ManualResetEvent dataAvailableSignal, MessageImportance messageImportance, StandardOutputOrErrorQueueType queueType);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    private void ReceiveTimeoutNotification(object unused);
    protected void ReceiveExitNotification(object sender, EventArgs e);
    protected void ReceiveStandardErrorData(object sender, DataReceivedEventArgs e);
    protected void ReceiveStandardOutputData(object sender, DataReceivedEventArgs e);
    private void ReceiveStandardErrorOrOutputData(DataReceivedEventArgs e, Queue dataQueue, ManualResetEvent dataAvailableSignal);
    private bool AssignStandardStreamLoggingImportance();
    internal static string FindOnPath(string filename);
    public virtual bool Execute();
    protected virtual string AdjustCommandsForOperatingSystem(string input);
    private bool LogEnvironmentVariable(bool alreadyLoggedEnvironmentHeader, string key, string value);
}
public static class Microsoft.Build.Utilities.TrackedDependencies : object {
    public static ITaskItem[] ExpandWildcards(ITaskItem[] expand);
    internal static bool ItemsExist(ITaskItem[] files);
}
public enum Microsoft.Build.Utilities.VisualStudioVersion : Enum {
    public int value__;
    public static VisualStudioVersion Version100;
    public static VisualStudioVersion Version110;
    public static VisualStudioVersion Version120;
    public static VisualStudioVersion Version140;
    public static VisualStudioVersion Version150;
    public static VisualStudioVersion Version160;
    public static VisualStudioVersion Version170;
    public static VisualStudioVersion VersionLatest;
}
