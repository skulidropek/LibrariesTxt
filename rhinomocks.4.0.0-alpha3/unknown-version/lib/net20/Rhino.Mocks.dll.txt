[AttributeUsageAttribute("4")]
[CLSCompliantAttribute("False")]
public class __ProtectAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
internal abstract class Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter : object {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public abstract virtual bool Contains(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public sealed virtual ICollection get_Keys();
    public sealed virtual void Remove(object key);
    public sealed virtual ICollection get_Values();
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal abstract class Castle.Components.DictionaryAdapter.AbstractDictionaryAdapterVisitor : object {
    private Dictionary`2<IDictionaryAdapter, int> scopes;
    [CompilerGeneratedAttribute]
private bool <Cancelled>k__BackingField;
    protected bool Cancelled { get; protected set; }
    protected AbstractDictionaryAdapterVisitor(AbstractDictionaryAdapterVisitor parent);
    [CompilerGeneratedAttribute]
protected bool get_Cancelled();
    [CompilerGeneratedAttribute]
protected void set_Cancelled(bool value);
    public virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, object state);
    public virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, Func`2<PropertyDescriptor, bool> selector, object state);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor.VisitProperty(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    protected virtual void VisitProperty(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor.VisitInterface(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    protected virtual void VisitInterface(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor.VisitCollection(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, Type collectionItemType, object state);
    protected virtual void VisitCollection(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, Type collectionItemType, object state);
    private bool PushScope(IDictionaryAdapter dictionaryAdapter);
    private void PopScope(IDictionaryAdapter dictionaryAdapter);
    private static bool IsCollection(PropertyDescriptor property, Type& collectionItemType);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.BindingList`1 : object {
    private BindingList`1<T> list;
    public BindingList`1<T> InnerList { get; }
    public IBindingList AsBindingList { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool AllowNew { get; public set; }
    public bool AllowEdit { get; public set; }
    public bool AllowRemove { get; public set; }
    public bool RaiseListChangedEvents { get; public set; }
    private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsChangeNotification { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSearching { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSorting { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.IsSorted { get; }
    private PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.SortProperty { get; }
    private ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.SortDirection { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public BindingList`1(IList`1<T> list);
    public BindingList`1(BindingList`1<T> list);
    public BindingList`1<T> get_InnerList();
    public sealed virtual IBindingList get_AsBindingList();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool get_AllowNew();
    public void set_AllowNew(bool value);
    public sealed virtual bool get_AllowEdit();
    public void set_AllowEdit(bool value);
    public sealed virtual bool get_AllowRemove();
    public void set_AllowRemove(bool value);
    public bool get_RaiseListChangedEvents();
    public void set_RaiseListChangedEvents(bool value);
    private sealed virtual override bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsChangeNotification();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSearching();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSorting();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_IsSorted();
    private sealed virtual override PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortProperty();
    private sealed virtual override ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortDirection();
    private sealed virtual override int Castle.Components.DictionaryAdapter.IBindingList<T>.Find(PropertyDescriptor property, object key);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.AddIndex(PropertyDescriptor property);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveSort();
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T AddNew();
    public sealed virtual void CancelNew(int index);
    public sealed virtual void EndNew(int index);
    public sealed virtual void Add(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public sealed virtual void Clear();
    public void ResetBindings();
    public void ResetItem(int index);
}
internal class Castle.Components.DictionaryAdapter.BindingListInitializer`1 : object {
    private Func`1<object> addNew;
    private Func`3<int, object, object> addAt;
    private Func`3<int, object, object> setAt;
    private Action`1<int> removeAt;
    private Action reset;
    private bool addingNew;
    public BindingListInitializer`1(Func`3<int, object, object> addAt, Func`1<object> addNew, Func`3<int, object, object> setAt, Action`1<int> removeAt, Action reset);
    public sealed virtual void Initialize(IDictionaryAdapter dictionaryAdapter, object value);
    [CompilerGeneratedAttribute]
private void <Initialize>b__0(object sender, AddingNewEventArgs args);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.CascadingDictionaryAdapter : AbstractDictionaryAdapter {
    private IDictionary primary;
    private IDictionary secondary;
    public IDictionary Primary { get; }
    public IDictionary Secondary { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public CascadingDictionaryAdapter(IDictionary primary, IDictionary secondary);
    public IDictionary get_Primary();
    public IDictionary get_Secondary();
    public virtual bool get_IsReadOnly();
    public virtual bool Contains(object key);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.ComponentAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public bool NoPrefix { get; public set; }
    public string Prefix { get; public set; }
    public bool get_NoPrefix();
    public void set_NoPrefix(bool value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    public sealed virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
}
internal class Castle.Components.DictionaryAdapter.DefaultPropertyGetter : object {
    private TypeConverter converter;
    public int ExecutionOrder { get; }
    public DefaultPropertyGetter(TypeConverter converter);
    public sealed virtual int get_ExecutionOrder();
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    public sealed virtual IDictionaryBehavior Copy();
}
[AttributeUsageAttribute("4")]
internal class Castle.Components.DictionaryAdapter.DictionaryAdapterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <InterfaceType>k__BackingField;
    public Type InterfaceType { get; private set; }
    public DictionaryAdapterAttribute(Type interfaceType);
    [CompilerGeneratedAttribute]
public Type get_InterfaceType();
    [CompilerGeneratedAttribute]
private void set_InterfaceType(Type value);
}
[DefaultMemberAttribute("Item")]
internal abstract class Castle.Components.DictionaryAdapter.DictionaryAdapterBase : object {
    private int suppressEditingCount;
    private Stack`1<Dictionary`2<string, Edit>> updates;
    private HashSet`1<IEditableObject> editDependencies;
    [ThreadStaticAttribute]
private static TrackPropertyChangeScope readOnlyTrackingScope;
    private int suppressNotificationCount;
    private PropertyChangingEventHandler PropertyChanging;
    private PropertyChangedEventHandler PropertyChanged;
    private ICollection`1<IDictionaryValidator> validators;
    [CompilerGeneratedAttribute]
private DictionaryAdapterInstance <This>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsMultiLevelEdit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanNotify>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanValidate>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<PropertyDescriptor, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Dictionary`2<string, Edit>, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<PropertyDescriptor, bool> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<IChangeTracking, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate18;
    public DictionaryAdapterMeta Meta { get; }
    public DictionaryAdapterInstance This { get; private set; }
    public bool CanEdit { get; public set; }
    public bool IsEditing { get; }
    public bool SupportsMultiLevelEdit { get; public set; }
    public bool IsChanged { get; }
    public bool CanNotify { get; public set; }
    public bool ShouldNotify { get; }
    public bool CanValidate { get; public set; }
    public bool IsValid { get; }
    public string Error { get; }
    public string Item { get; }
    public IEnumerable`1<IDictionaryValidator> Validators { get; }
    public DictionaryAdapterBase(DictionaryAdapterInstance instance);
    public sealed virtual void CopyTo(IDictionaryAdapter other);
    public sealed virtual void CopyTo(IDictionaryAdapter other, Func`2<PropertyDescriptor, bool> selector);
    public sealed virtual T Coerce();
    public sealed virtual object Coerce(Type type);
    public sealed virtual T Create();
    public sealed virtual object Create(Type type);
    public sealed virtual T Create(IDictionary dictionary);
    public sealed virtual object Create(Type type, IDictionary dictionary);
    public sealed virtual T Create(Action`1<T> init);
    public sealed virtual T Create(IDictionary dictionary, Action`1<T> init);
    public abstract virtual DictionaryAdapterMeta get_Meta();
    [CompilerGeneratedAttribute]
public sealed virtual DictionaryAdapterInstance get_This();
    [CompilerGeneratedAttribute]
private void set_This(DictionaryAdapterInstance value);
    public sealed virtual string GetKey(string propertyName);
    public virtual object GetProperty(string propertyName, bool ifExists);
    public sealed virtual T GetPropertyOfType(string propertyName);
    public sealed virtual object ReadProperty(string key);
    public virtual bool SetProperty(string propertyName, Object& value);
    public sealed virtual void StoreProperty(PropertyDescriptor property, string key, object value);
    public sealed virtual void ClearProperty(PropertyDescriptor property, string key);
    public sealed virtual bool ShouldClearProperty(PropertyDescriptor property, object value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void Initialize();
    private static IDictionary GetDictionary(IDictionary dictionary, String& key);
    public sealed virtual bool get_CanEdit();
    public void set_CanEdit(bool value);
    public sealed virtual bool get_IsEditing();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SupportsMultiLevelEdit();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SupportsMultiLevelEdit(bool value);
    public sealed virtual bool get_IsChanged();
    public sealed virtual void BeginEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void EndEdit();
    public sealed virtual void RejectChanges();
    public sealed virtual void AcceptChanges();
    public sealed virtual IDisposable SuppressEditingBlock();
    public sealed virtual void SuppressEditing();
    public sealed virtual void ResumeEditing();
    protected bool GetEditedProperty(string propertyName, Object& propertyValue);
    protected bool EditProperty(PropertyDescriptor property, string key, object propertyValue);
    protected bool ClearEditProperty(PropertyDescriptor property, string key);
    protected void AddEditDependency(IEditableObject editDependency);
    public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanNotify();
    [CompilerGeneratedAttribute]
public void set_CanNotify(bool value);
    public sealed virtual bool get_ShouldNotify();
    public sealed virtual IDisposable SuppressNotificationsBlock();
    public sealed virtual void SuppressNotifications();
    public sealed virtual void ResumeNotifications();
    protected bool NotifyPropertyChanging(PropertyDescriptor property, object oldValue, object newValue);
    protected void NotifyPropertyChanged(PropertyDescriptor property, object oldValue, object newValue);
    protected void NotifyPropertyChanged(string propertyName);
    protected TrackPropertyChangeScope TrackPropertyChange(PropertyDescriptor property, object oldValue, object newValue);
    protected TrackPropertyChangeScope TrackReadonlyPropertyChanges();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanValidate();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CanValidate(bool value);
    public sealed virtual bool get_IsValid();
    public sealed virtual string get_Error();
    public sealed virtual string get_Item(string columnName);
    public sealed virtual DictionaryValidateGroup ValidateGroups(Object[] groups);
    public sealed virtual IEnumerable`1<IDictionaryValidator> get_Validators();
    public sealed virtual void AddValidator(IDictionaryValidator validator);
    protected internal void Invalidate();
    [CompilerGeneratedAttribute]
private static bool <CopyTo>b__1(PropertyDescriptor property);
    [CompilerGeneratedAttribute]
private static bool <get_IsChanged>b__9(Dictionary`2<string, Edit> level);
    [CompilerGeneratedAttribute]
private static bool <get_IsChanged>b__a(PropertyDescriptor prop);
    [CompilerGeneratedAttribute]
private object <get_IsChanged>b__b(PropertyDescriptor prop);
    [CompilerGeneratedAttribute]
private static bool <get_IsChanged>b__c(IChangeTracking track);
    [CompilerGeneratedAttribute]
private bool <get_IsValid>b__10(IDictionaryValidator v);
    [CompilerGeneratedAttribute]
private string <get_Error>b__12(IDictionaryValidator v);
    [CompilerGeneratedAttribute]
private static bool <get_Error>b__13(string e);
    [CompilerGeneratedAttribute]
private static bool <get_Item>b__17(string e);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.DictionaryAdapterExtensions : object {
    [ExtensionAttribute]
public static IVirtual AsVirtual(IDictionaryAdapter dictionaryAdapter);
}
internal class Castle.Components.DictionaryAdapter.DictionaryAdapterFactory : object {
    private Dictionary`2<Type, DictionaryAdapterMeta> interfaceToMeta;
    private Lock interfaceToMetaLock;
    private static PropertyInfo AdapterGetMeta;
    private static ConstructorInfo BaseCtor;
    private static Type[] ConstructorParameterTypes;
    private static MethodInfo AdapterGetProperty;
    private static MethodInfo AdapterSetProperty;
    private static HashSet`1<Type> InfrastructureTypes;
    [CompilerGeneratedAttribute]
private static Func`2<FetchAttribute, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate14;
    private static DictionaryAdapterFactory();
    public sealed virtual T GetAdapter(IDictionary dictionary);
    public sealed virtual object GetAdapter(Type type, IDictionary dictionary);
    public sealed virtual object GetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor);
    public T GetAdapter(IDictionary`2<string, R> dictionary);
    public object GetAdapter(Type type, IDictionary`2<string, R> dictionary);
    public sealed virtual T GetAdapter(NameValueCollection nameValues);
    public sealed virtual object GetAdapter(Type type, NameValueCollection nameValues);
    public sealed virtual T GetAdapter(XmlNode xmlNode);
    public sealed virtual object GetAdapter(Type type, XmlNode xmlNode);
    public sealed virtual DictionaryAdapterMeta GetAdapterMeta(Type type);
    public sealed virtual DictionaryAdapterMeta GetAdapterMeta(Type type, PropertyDescriptor descriptor);
    public sealed virtual DictionaryAdapterMeta GetAdapterMeta(Type type, DictionaryAdapterMeta other);
    private DictionaryAdapterMeta InternalGetAdapterMeta(Type type, PropertyDescriptor descriptor, DictionaryAdapterMeta other);
    private object InternalGetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor);
    private static TypeBuilder CreateTypeBuilder(Type type, AppDomain appDomain);
    private static TypeBuilder CreateAdapterType(Type type, ModuleBuilder moduleBuilder);
    private DictionaryAdapterMeta CreateAdapterMeta(Type type, TypeBuilder typeBuilder, PropertyDescriptor descriptor);
    private static ConstructorInfo CreateAdapterConstructor(TypeBuilder typeBuilder);
    private static void CreateAdapterFactoryMethod(TypeBuilder typeBuilder, ConstructorInfo constructor);
    private static void CreateMetaProperty(TypeBuilder typeBuilder, PropertyInfo prop, FieldInfo field);
    private static void CreateAdapterProperty(TypeBuilder typeBuilder, PropertyDescriptor descriptor);
    private static void PreparePropertyMethod(PropertyDescriptor descriptor, ILGenerator propILGenerator);
    private static void CreatePropertyGetMethod(TypeBuilder typeBuilder, PropertyBuilder propertyBuilder, PropertyDescriptor descriptor, MethodAttributes propAttribs);
    private static void CreatePropertySetMethod(TypeBuilder typeBuilder, PropertyBuilder propertyBuilder, PropertyDescriptor descriptor, MethodAttributes propAttribs);
    private static Dictionary`2<string, PropertyDescriptor> GetPropertyDescriptors(Type type, PropertyDescriptor initializers, Object[]& typeBehaviors);
    private static IEnumerable`1<object> ExpandBehaviors(IEnumerable`1<object> behaviors);
    private static void CollectProperties(Type currentType, Action`1<PropertyInfo> onProperty);
    private static void AddDefaultGetter(PropertyDescriptor descriptor);
    [CompilerGeneratedAttribute]
private static bool <GetPropertyDescriptors>b__0(FetchAttribute b);
    [CompilerGeneratedAttribute]
private static bool <CollectProperties>b__13(Type t);
}
internal class Castle.Components.DictionaryAdapter.DictionaryAdapterInstance : object {
    private IDictionary extendedProperties;
    private List`1<IDictionaryCopyStrategy> copyStrategies;
    private static IDictionaryInitializer[] NoInitializers;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <OldHashCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary <Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryAdapterFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryInitializer[] <Initializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, PropertyDescriptor> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryEqualityHashCodeStrategy <EqualityHashCodeStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryCreateStrategy <CreateStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryCoerceStrategy <CoerceStrategy>k__BackingField;
    internal Nullable`1<int> OldHashCode { get; internal set; }
    public IDictionary Dictionary { get; private set; }
    public PropertyDescriptor Descriptor { get; private set; }
    public IDictionaryAdapterFactory Factory { get; private set; }
    public IDictionaryInitializer[] Initializers { get; private set; }
    public IDictionary`2<string, PropertyDescriptor> Properties { get; private set; }
    public IDictionaryEqualityHashCodeStrategy EqualityHashCodeStrategy { get; public set; }
    public IDictionaryCreateStrategy CreateStrategy { get; public set; }
    public IDictionaryCoerceStrategy CoerceStrategy { get; public set; }
    public IEnumerable`1<IDictionaryCopyStrategy> CopyStrategies { get; }
    public IDictionary ExtendedProperties { get; }
    public DictionaryAdapterInstance(IDictionary dictionary, DictionaryAdapterMeta meta, PropertyDescriptor descriptor, IDictionaryAdapterFactory factory);
    private static DictionaryAdapterInstance();
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_OldHashCode();
    [CompilerGeneratedAttribute]
internal void set_OldHashCode(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IDictionary get_Dictionary();
    [CompilerGeneratedAttribute]
private void set_Dictionary(IDictionary value);
    [CompilerGeneratedAttribute]
public PropertyDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
private void set_Descriptor(PropertyDescriptor value);
    [CompilerGeneratedAttribute]
public IDictionaryAdapterFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(IDictionaryAdapterFactory value);
    [CompilerGeneratedAttribute]
public IDictionaryInitializer[] get_Initializers();
    [CompilerGeneratedAttribute]
private void set_Initializers(IDictionaryInitializer[] value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, PropertyDescriptor> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, PropertyDescriptor> value);
    [CompilerGeneratedAttribute]
public IDictionaryEqualityHashCodeStrategy get_EqualityHashCodeStrategy();
    [CompilerGeneratedAttribute]
public void set_EqualityHashCodeStrategy(IDictionaryEqualityHashCodeStrategy value);
    [CompilerGeneratedAttribute]
public IDictionaryCreateStrategy get_CreateStrategy();
    [CompilerGeneratedAttribute]
public void set_CreateStrategy(IDictionaryCreateStrategy value);
    [CompilerGeneratedAttribute]
public IDictionaryCoerceStrategy get_CoerceStrategy();
    [CompilerGeneratedAttribute]
public void set_CoerceStrategy(IDictionaryCoerceStrategy value);
    public IEnumerable`1<IDictionaryCopyStrategy> get_CopyStrategies();
    public void AddCopyStrategy(IDictionaryCopyStrategy copyStrategy);
    public IDictionary get_ExtendedProperties();
    private static IDictionaryInitializer[] MergeInitializers(IDictionaryInitializer[] source, List`1<IDictionaryBehavior> behaviors);
    private static IDictionary`2<string, PropertyDescriptor> MergeProperties(IDictionary`2<string, PropertyDescriptor> source);
    private static IDictionary`2<string, PropertyDescriptor> MergeProperties(IDictionary`2<string, PropertyDescriptor> source, List`1<IDictionaryBehavior> behaviors);
}
[DebuggerDisplayAttribute("Type: {Type.FullName,nq}")]
internal class Castle.Components.DictionaryAdapter.DictionaryAdapterMeta : object {
    private IDictionary extendedProperties;
    private Func`2<DictionaryAdapterInstance, IDictionaryAdapter> creator;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Implementation>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Behaviors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryAdapterFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, PropertyDescriptor> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryMetaInitializer[] <MetaInitializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionaryInitializer[] <Initializers>k__BackingField;
    public Type Type { get; private set; }
    public Type Implementation { get; private set; }
    public Object[] Behaviors { get; private set; }
    public IDictionaryAdapterFactory Factory { get; private set; }
    public IDictionary`2<string, PropertyDescriptor> Properties { get; private set; }
    public IDictionaryMetaInitializer[] MetaInitializers { get; private set; }
    public IDictionaryInitializer[] Initializers { get; private set; }
    public IDictionary ExtendedProperties { get; }
    public DictionaryAdapterMeta(Type type, Type implementation, Object[] behaviors, IDictionaryMetaInitializer[] metaInitializers, IDictionaryInitializer[] initializers, IDictionary`2<string, PropertyDescriptor> properties, IDictionaryAdapterFactory factory, Func`2<DictionaryAdapterInstance, IDictionaryAdapter> creator);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public Type get_Implementation();
    [CompilerGeneratedAttribute]
private void set_Implementation(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_Behaviors();
    [CompilerGeneratedAttribute]
private void set_Behaviors(Object[] value);
    [CompilerGeneratedAttribute]
public IDictionaryAdapterFactory get_Factory();
    [CompilerGeneratedAttribute]
private void set_Factory(IDictionaryAdapterFactory value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, PropertyDescriptor> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, PropertyDescriptor> value);
    [CompilerGeneratedAttribute]
public IDictionaryMetaInitializer[] get_MetaInitializers();
    [CompilerGeneratedAttribute]
private void set_MetaInitializers(IDictionaryMetaInitializer[] value);
    [CompilerGeneratedAttribute]
public IDictionaryInitializer[] get_Initializers();
    [CompilerGeneratedAttribute]
private void set_Initializers(IDictionaryInitializer[] value);
    public IDictionary get_ExtendedProperties();
    public PropertyDescriptor CreateDescriptor();
    private static List`1<T> CollectSharedBehaviors(T[] source, IDictionaryMetaInitializer[] predicates);
    public DictionaryAdapterMeta GetAdapterMeta(Type type);
    public object CreateInstance(IDictionary dictionary, PropertyDescriptor descriptor);
    private void InitializeMeta();
}
internal abstract class Castle.Components.DictionaryAdapter.DictionaryBehaviorAttribute : Attribute {
    public static int FirstExecutionOrder;
    public static int DefaultExecutionOrder;
    public static int LastExecutionOrder;
    [CompilerGeneratedAttribute]
private int <ExecutionOrder>k__BackingField;
    public int ExecutionOrder { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_ExecutionOrder();
    [CompilerGeneratedAttribute]
public void set_ExecutionOrder(int value);
    public virtual IDictionaryBehavior Copy();
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.DictionaryValidateGroup : object {
    private Object[] groups;
    private IDictionaryAdapter adapter;
    private String[] propertyNames;
    private PropertyChangedEventHandler propertyChanged;
    private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private static Func`2<PropertyDescriptor, IEnumerable`1<GroupAttribute>> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`3<PropertyDescriptor, GroupAttribute, <>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute>> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute>, string> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegated;
    public bool CanValidate { get; public set; }
    public bool IsValid { get; }
    public string Error { get; }
    public string Item { get; }
    public IEnumerable`1<IDictionaryValidator> Validators { get; }
    public DictionaryValidateGroup(Object[] groups, IDictionaryAdapter adapter);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual bool get_CanValidate();
    public sealed virtual void set_CanValidate(bool value);
    public sealed virtual bool get_IsValid();
    public sealed virtual string get_Error();
    public sealed virtual string get_Item(string columnName);
    public sealed virtual DictionaryValidateGroup ValidateGroups(Object[] groups);
    public sealed virtual IEnumerable`1<IDictionaryValidator> get_Validators();
    public sealed virtual void AddValidator(IDictionaryValidator validator);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private static IEnumerable`1<GroupAttribute> <.ctor>b__1(PropertyDescriptor property);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute> <.ctor>b__2(PropertyDescriptor property, GroupAttribute groupings);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__3(<>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private static string <.ctor>b__4(<>f__AnonymousType1`2<PropertyDescriptor, GroupAttribute> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5(object sender, PropertyChangedEventArgs args);
    [CompilerGeneratedAttribute]
private string <get_Error>b__b(string propertyName);
    [CompilerGeneratedAttribute]
private static bool <get_Error>b__c(string errors);
}
internal abstract class Castle.Components.DictionaryAdapter.DynamicValue`1 : object {
    public T Value { get; }
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDynamicValue.GetValue();
    public abstract virtual T get_Value();
    public virtual string ToString();
}
internal class Castle.Components.DictionaryAdapter.DynamicValueDelegate`1 : DynamicValue`1<T> {
    private Func`1<T> dynamicDelegate;
    public T Value { get; }
    public DynamicValueDelegate`1(Func`1<T> dynamicDelegate);
    public virtual T get_Value();
}
internal class Castle.Components.DictionaryAdapter.EditableBindingList`1 : BindingList`1<T> {
    private bool isEditing;
    private List`1<T> snapshot;
    public bool IsChanged { get; }
    public EditableBindingList`1(IList`1<T> initial);
    public sealed virtual bool get_IsChanged();
    public sealed virtual void BeginEdit();
    public sealed virtual void EndEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void AcceptChanges();
    public sealed virtual void RejectChanges();
}
internal class Castle.Components.DictionaryAdapter.EditableList : EditableList`1<object> {
    public EditableList(IEnumerable`1<object> collection);
}
internal class Castle.Components.DictionaryAdapter.EditableList`1 : List`1<T> {
    private bool isEditing;
    private List`1<T> snapshot;
    public bool IsChanged { get; }
    public EditableList`1(IEnumerable`1<T> collection);
    public sealed virtual void BeginEdit();
    public sealed virtual bool get_IsChanged();
    public sealed virtual void EndEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void AcceptChanges();
    public sealed virtual void RejectChanges();
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.FetchAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Fetch>k__BackingField;
    public bool Fetch { get; private set; }
    public FetchAttribute(bool fetch);
    [CompilerGeneratedAttribute]
public bool get_Fetch();
    [CompilerGeneratedAttribute]
private void set_Fetch(bool value);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.GenericDictionaryAdapter : object {
    [ExtensionAttribute]
public static GenericDictionaryAdapter`1<TValue> ForDictionaryAdapter(IDictionary`2<string, TValue> dictionary);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.GenericDictionaryAdapter`1 : AbstractDictionaryAdapter {
    private IDictionary`2<string, TValue> dictionary;
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public GenericDictionaryAdapter`1(IDictionary`2<string, TValue> dictionary);
    public virtual bool get_IsReadOnly();
    public virtual bool Contains(object key);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    private static string GetKey(object key);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.GroupAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Object[] <Group>k__BackingField;
    public Object[] Group { get; private set; }
    public GroupAttribute(object group);
    public GroupAttribute(Object[] group);
    [CompilerGeneratedAttribute]
public Object[] get_Group();
    [CompilerGeneratedAttribute]
private void set_Group(Object[] value);
}
internal interface Castle.Components.DictionaryAdapter.IBindingList`1 {
    public bool AllowNew { get; }
    public bool AllowEdit { get; }
    public bool AllowRemove { get; }
    public bool SupportsChangeNotification { get; }
    public bool SupportsSearching { get; }
    public bool SupportsSorting { get; }
    public bool IsSorted { get; }
    public PropertyDescriptor SortProperty { get; }
    public ListSortDirection SortDirection { get; }
    public abstract virtual bool get_AllowNew();
    public abstract virtual bool get_AllowEdit();
    public abstract virtual bool get_AllowRemove();
    public abstract virtual bool get_SupportsChangeNotification();
    public abstract virtual bool get_SupportsSearching();
    public abstract virtual bool get_SupportsSorting();
    public abstract virtual bool get_IsSorted();
    public abstract virtual PropertyDescriptor get_SortProperty();
    public abstract virtual ListSortDirection get_SortDirection();
    public abstract virtual void add_ListChanged(ListChangedEventHandler value);
    public abstract virtual void remove_ListChanged(ListChangedEventHandler value);
    public abstract virtual T AddNew();
    public abstract virtual int Find(PropertyDescriptor property, object key);
    public abstract virtual void AddIndex(PropertyDescriptor property);
    public abstract virtual void RemoveIndex(PropertyDescriptor property);
    public abstract virtual void ApplySort(PropertyDescriptor property, ListSortDirection direction);
    public abstract virtual void RemoveSort();
}
internal interface Castle.Components.DictionaryAdapter.IBindingListSource {
    public IBindingList AsBindingList { get; }
    public abstract virtual IBindingList get_AsBindingList();
}
[DefaultMemberAttribute("Item")]
internal interface Castle.Components.DictionaryAdapter.ICollectionAdapter`1 {
    public IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    public T Item { get; public set; }
    public bool HasSnapshot { get; }
    public int SnapshotCount { get; }
    public abstract virtual void Initialize(ICollectionAdapterObserver`1<T> advisor);
    public abstract virtual IEqualityComparer`1<T> get_Comparer();
    public abstract virtual int get_Count();
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual T AddNew();
    public abstract virtual bool Add(T value);
    public abstract virtual bool Insert(int index, T value);
    public abstract virtual void Remove(int index);
    public abstract virtual void Clear();
    public abstract virtual void ClearReferences();
    public abstract virtual bool get_HasSnapshot();
    public abstract virtual int get_SnapshotCount();
    public abstract virtual T GetCurrentItem(int index);
    public abstract virtual T GetSnapshotItem(int index);
    public abstract virtual void SaveSnapshot();
    public abstract virtual void LoadSnapshot();
    public abstract virtual void DropSnapshot();
}
internal interface Castle.Components.DictionaryAdapter.ICollectionAdapterObserver`1 {
    public abstract virtual bool OnInserting(T newValue);
    public abstract virtual bool OnReplacing(T oldValue, T newValue);
    public abstract virtual void OnRemoving(T oldValue);
    public abstract virtual void OnInserted(T newValue, int index);
    public abstract virtual void OnReplaced(T oldValue, T newValue, int index);
    public abstract virtual void OnRemoved(T oldValue, int index);
}
internal interface Castle.Components.DictionaryAdapter.ICollectionProjection {
    public abstract virtual void Replace(IEnumerable source);
    public abstract virtual void Clear();
    public abstract virtual void ClearReferences();
}
internal interface Castle.Components.DictionaryAdapter.ICondition {
    public abstract virtual bool SatisfiedBy(object value);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryAdapter {
    public DictionaryAdapterMeta Meta { get; }
    public DictionaryAdapterInstance This { get; }
    public abstract virtual DictionaryAdapterMeta get_Meta();
    public abstract virtual DictionaryAdapterInstance get_This();
    public abstract virtual string GetKey(string propertyName);
    public abstract virtual object GetProperty(string propertyName, bool ifExists);
    public abstract virtual object ReadProperty(string key);
    public abstract virtual T GetPropertyOfType(string propertyName);
    public abstract virtual bool SetProperty(string propertyName, Object& value);
    public abstract virtual void StoreProperty(PropertyDescriptor property, string key, object value);
    public abstract virtual void ClearProperty(PropertyDescriptor property, string key);
    public abstract virtual bool ShouldClearProperty(PropertyDescriptor property, object value);
    public abstract virtual void CopyTo(IDictionaryAdapter other);
    public abstract virtual void CopyTo(IDictionaryAdapter other, Func`2<PropertyDescriptor, bool> selector);
    public abstract virtual T Coerce();
    public abstract virtual object Coerce(Type type);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory {
    public abstract virtual T GetAdapter(IDictionary dictionary);
    public abstract virtual object GetAdapter(Type type, IDictionary dictionary);
    public abstract virtual object GetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor);
    public abstract virtual T GetAdapter(NameValueCollection nameValues);
    public abstract virtual object GetAdapter(Type type, NameValueCollection nameValues);
    public abstract virtual T GetAdapter(XmlNode xmlNode);
    public abstract virtual object GetAdapter(Type type, XmlNode xmlNode);
    public abstract virtual DictionaryAdapterMeta GetAdapterMeta(Type type);
    public abstract virtual DictionaryAdapterMeta GetAdapterMeta(Type type, PropertyDescriptor descriptor);
    public abstract virtual DictionaryAdapterMeta GetAdapterMeta(Type type, DictionaryAdapterMeta other);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor {
    public abstract virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, object state);
    public abstract virtual bool VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter, Func`2<PropertyDescriptor, bool> selector, object state);
    public abstract virtual void VisitProperty(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    public abstract virtual void VisitInterface(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, object state);
    public abstract virtual void VisitCollection(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, Type collectionItemType, object state);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryBehavior {
    public int ExecutionOrder { get; }
    public abstract virtual int get_ExecutionOrder();
    public abstract virtual IDictionaryBehavior Copy();
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder {
    public abstract virtual Object[] BuildBehaviors();
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryCoerceStrategy {
    public abstract virtual object Coerce(IDictionaryAdapter adapter, Type type);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryCopyStrategy {
    public abstract virtual bool Copy(IDictionaryAdapter source, IDictionaryAdapter target, Func`2& selector);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryCreate {
    public abstract virtual T Create();
    public abstract virtual object Create(Type type);
    public abstract virtual T Create(IDictionary dictionary);
    public abstract virtual object Create(Type type, IDictionary dictionary);
    public abstract virtual T Create(Action`1<T> init);
    public abstract virtual T Create(IDictionary dictionary, Action`1<T> init);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryCreateStrategy {
    public abstract virtual object Create(IDictionaryAdapter adapter, Type type, IDictionary dictionary);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryEdit {
    public bool CanEdit { get; }
    public bool IsEditing { get; }
    public bool SupportsMultiLevelEdit { get; public set; }
    public abstract virtual bool get_CanEdit();
    public abstract virtual bool get_IsEditing();
    public abstract virtual bool get_SupportsMultiLevelEdit();
    public abstract virtual void set_SupportsMultiLevelEdit(bool value);
    public abstract virtual IDisposable SuppressEditingBlock();
    public abstract virtual void SuppressEditing();
    public abstract virtual void ResumeEditing();
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryEqualityHashCodeStrategy {
    public abstract virtual bool Equals(IDictionaryAdapter adapter1, IDictionaryAdapter adapter2);
    public abstract virtual bool GetHashCode(IDictionaryAdapter adapter, Int32& hashCode);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryInitializer {
    public abstract virtual void Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder {
    public abstract virtual string GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer {
    public abstract virtual void Initialize(IDictionaryAdapterFactory factory, DictionaryAdapterMeta dictionaryMeta);
    public abstract virtual bool ShouldHaveBehavior(object behavior);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryNotify {
    public bool CanNotify { get; }
    public bool ShouldNotify { get; }
    public abstract virtual bool get_CanNotify();
    public abstract virtual bool get_ShouldNotify();
    public abstract virtual IDisposable SuppressNotificationsBlock();
    public abstract virtual void SuppressNotifications();
    public abstract virtual void ResumeNotifications();
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter {
    public abstract virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryPropertySetter {
    public abstract virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryReferenceManager {
    public abstract virtual bool IsReferenceProperty(IDictionaryAdapter dictionaryAdapter, string propertyName);
    public abstract virtual bool TryGetReference(object keyObject, Object& inGraphObject);
    public abstract virtual void AddReference(object keyObject, object relatedObject, bool isInGraph);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryValidate {
    public bool CanValidate { get; public set; }
    public bool IsValid { get; }
    public IEnumerable`1<IDictionaryValidator> Validators { get; }
    public abstract virtual bool get_CanValidate();
    public abstract virtual void set_CanValidate(bool value);
    public abstract virtual bool get_IsValid();
    public abstract virtual DictionaryValidateGroup ValidateGroups(Object[] groups);
    public abstract virtual IEnumerable`1<IDictionaryValidator> get_Validators();
    public abstract virtual void AddValidator(IDictionaryValidator validator);
}
internal interface Castle.Components.DictionaryAdapter.IDictionaryValidator {
    public abstract virtual bool IsValid(IDictionaryAdapter dictionaryAdapter);
    public abstract virtual string Validate(IDictionaryAdapter dictionaryAdapter);
    public abstract virtual string Validate(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);
    public abstract virtual void Invalidate(IDictionaryAdapter dictionaryAdapter);
}
internal interface Castle.Components.DictionaryAdapter.IDynamicValue {
    public abstract virtual object GetValue();
}
internal interface Castle.Components.DictionaryAdapter.IDynamicValue`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.IfExistsAttribute : Attribute {
}
internal interface Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer {
    public abstract virtual void Initialize(PropertyDescriptor propertyDescriptor, Object[] behaviors);
}
internal interface Castle.Components.DictionaryAdapter.IValueInitializer {
    public abstract virtual void Initialize(IDictionaryAdapter dictionaryAdapter, object value);
}
internal interface Castle.Components.DictionaryAdapter.IVirtual {
    public bool IsReal { get; }
    public abstract virtual bool get_IsReal();
    public abstract virtual void Realize();
    public abstract virtual void add_Realized(EventHandler value);
    public abstract virtual void remove_Realized(EventHandler value);
}
internal interface Castle.Components.DictionaryAdapter.IVirtual`1 {
    public abstract virtual T Realize();
    public abstract virtual void AddSite(IVirtualSite`1<T> site);
    public abstract virtual void RemoveSite(IVirtualSite`1<T> site);
}
internal interface Castle.Components.DictionaryAdapter.IVirtualSite`1 {
    public abstract virtual void OnRealizing(T node);
}
internal interface Castle.Components.DictionaryAdapter.IVirtualTarget`2 {
    public abstract virtual void OnRealizing(TNode node, TMember member);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.KeyAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; private set; }
    public KeyAttribute(string key);
    public KeyAttribute(String[] keys);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
[AttributeUsageAttribute("1024")]
internal class Castle.Components.DictionaryAdapter.KeyPrefixAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <KeyPrefix>k__BackingField;
    public string KeyPrefix { get; public set; }
    public KeyPrefixAttribute(string keyPrefix);
    [CompilerGeneratedAttribute]
public string get_KeyPrefix();
    [CompilerGeneratedAttribute]
public void set_KeyPrefix(string value);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.KeySubstitutionAttribute : DictionaryBehaviorAttribute {
    private string oldValue;
    private string newValue;
    public KeySubstitutionAttribute(string oldValue, string newValue);
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Castle.Components.DictionaryAdapter.ListProjectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}, Adapter = {Adapter}")]
internal class Castle.Components.DictionaryAdapter.ListProjection`1 : object {
    private static int NoIndex;
    private ICollectionAdapter`1<T> adapter;
    private int addNewIndex;
    private int addedIndex;
    private int suspendLevel;
    private int changedIndex;
    private PropertyChangedEventHandler propertyHandler;
    private static PropertyDescriptorCollection itemProperties;
    private ListChangedEventHandler ListChanged;
    public int Count { get; }
    public IBindingList AsBindingList { get; }
    public ICollectionAdapter`1<T> Adapter { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.AllowEdit { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.AllowNew { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.AllowRemove { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsChangeNotification { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSearching { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.SupportsSorting { get; }
    private bool Castle.Components.DictionaryAdapter.IBindingList<T>.IsSorted { get; }
    private PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.SortProperty { get; }
    private ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.SortDirection { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public bool IsChanged { get; }
    public bool EventsEnabled { get; }
    public ListProjection`1(ICollectionAdapter`1<T> adapter);
    public sealed virtual int get_Count();
    public sealed virtual IBindingList get_AsBindingList();
    public ICollectionAdapter`1<T> get_Adapter();
    public IEqualityComparer`1<T> get_Comparer();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_AllowEdit();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_AllowNew();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_AllowRemove();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsChangeNotification();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSearching();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_SupportsSorting();
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IBindingList<T>.get_IsSorted();
    private sealed virtual override PropertyDescriptor Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortProperty();
    private sealed virtual override ListSortDirection Castle.Components.DictionaryAdapter.IBindingList<T>.get_SortDirection();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public void Replace(IEnumerable`1<T> items);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionProjection.Replace(IEnumerable items);
    protected virtual bool OnReplacing(T oldValue, T newValue);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnReplacing(T oldValue, T newValue);
    protected virtual void OnReplaced(T oldValue, T newValue, int index);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnReplaced(T oldValue, T newValue, int index);
    public virtual T AddNew();
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    public bool IsNew(int index);
    public virtual void EndNew(int index);
    public virtual void CancelNew(int index);
    public virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    protected virtual bool OnInserting(T value);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnInserting(T value);
    protected virtual void OnInserted(T newValue, int index);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnInserted(T newValue, int index);
    public virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public virtual void RemoveAt(int index);
    public virtual void Clear();
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionProjection.ClearReferences();
    protected virtual void OnRemoving(T oldValue);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnRemoving(T oldValue);
    protected virtual void OnRemoved(T oldValue, int index);
    private sealed virtual override void Castle.Components.DictionaryAdapter.ICollectionAdapterObserver<T>.OnRemoved(T oldValue, int index);
    public sealed virtual bool get_IsChanged();
    public sealed virtual void BeginEdit();
    public sealed virtual void EndEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual void AcceptChanges();
    public sealed virtual void RejectChanges();
    private void AttachPropertyChanged(T value);
    private void DetachPropertyChanged(T value);
    private void HandlePropertyChanged(object sender, PropertyChangedEventArgs e);
    private bool CanHandle(object sender, PropertyChangedEventArgs e);
    private bool TryGetChangedItem(object sender, T& item);
    private bool TryGetChangedIndex(T item);
    private static PropertyDescriptor GetChangedProperty(PropertyChangedEventArgs e);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    protected virtual void OnListChanged(ListChangedEventArgs args);
    protected void NotifyListChanged(ListChangedType type, int index);
    protected void NotifyListReset();
    public bool get_EventsEnabled();
    public void SuspendEvents();
    public bool ResumeEvents();
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.AddIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override int Castle.Components.DictionaryAdapter.IBindingList<T>.Find(PropertyDescriptor property, object key);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IBindingList<T>.RemoveSort();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
}
internal class Castle.Components.DictionaryAdapter.ListProjectionDebugView`1 : object {
    private ListProjection`1<T> projection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionAdapter`1<T> Adapter { get; }
    public ListProjectionDebugView`1(ListProjection`1<T> projection);
    public T[] get_Items();
    public ICollectionAdapter`1<T> get_Adapter();
}
internal class Castle.Components.DictionaryAdapter.MemberwiseEqualityHashCodeStrategy : DictionaryBehaviorAttribute {
    public sealed virtual bool Equals(IDictionaryAdapter adapter1, IDictionaryAdapter adapter2);
    public sealed virtual int GetHashCode(IDictionaryAdapter adapter);
    public sealed virtual bool GetHashCode(IDictionaryAdapter adapter, Int32& hashCode);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryInitializer.Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
}
[AttributeUsageAttribute("1024")]
internal class Castle.Components.DictionaryAdapter.MultiLevelEditAttribute : DictionaryBehaviorAttribute {
    public sealed virtual void Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.NameValueCollectionAdapter : AbstractDictionaryAdapter {
    private NameValueCollection nameValues;
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public NameValueCollectionAdapter(NameValueCollection nameValues);
    public virtual bool get_IsReadOnly();
    public virtual bool Contains(object key);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public static NameValueCollectionAdapter Adapt(NameValueCollection nameValues);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.NewGuidAttribute : DictionaryBehaviorAttribute {
    private static Guid UnassignedGuid;
    private static NewGuidAttribute();
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.OnDemandAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<ConstructorInfo, <>f__AnonymousType0`2<ConstructorInfo, ParameterInfo[]>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType0`2<ConstructorInfo, ParameterInfo[]>, ConstructorInfo> CS$<>9__CachedAnonymousMethodDelegate6;
    public Type Type { get; private set; }
    public object Value { get; private set; }
    public OnDemandAttribute(Type type);
    public OnDemandAttribute(object value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private static bool IsAcceptedType(Type type);
    private static Type GetInferredType(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property, IValueInitializer& initializer);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType0`2<ConstructorInfo, ParameterInfo[]> <GetPropertyValue>b__1(ConstructorInfo ctor);
    [CompilerGeneratedAttribute]
private static ConstructorInfo <GetPropertyValue>b__3(<>f__AnonymousType0`2<ConstructorInfo, ParameterInfo[]> <>h__TransparentIdentifier0);
}
internal class Castle.Components.DictionaryAdapter.PropertyChangedEventArgsEx : PropertyChangedEventArgs {
    private object oldValue;
    private object newValue;
    public object OldValue { get; }
    public object NewValue { get; }
    public PropertyChangedEventArgsEx(string propertyName, object oldValue, object newValue);
    public object get_OldValue();
    public object get_NewValue();
}
internal class Castle.Components.DictionaryAdapter.PropertyChangingEventArgsEx : PropertyChangingEventArgs {
    private object oldValue;
    private object newValue;
    private bool cancel;
    public object OldValue { get; }
    public object NewValue { get; }
    public bool Cancel { get; public set; }
    public PropertyChangingEventArgsEx(string propertyName, object oldValue, object newValue);
    public object get_OldValue();
    public object get_NewValue();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
[DebuggerDisplayAttribute("{Property.DeclaringType.FullName,nq}.{PropertyName,nq}")]
internal class Castle.Components.DictionaryAdapter.PropertyDescriptor : object {
    private IDictionary state;
    private Dictionary`2<object, object> extendedProperties;
    protected List`1<IDictionaryBehavior> dictionaryBehaviors;
    private static Object[] NoAnnotations;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamicProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Fetch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IfExists>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressNotifications>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Annotations>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeConverter <TypeConverter>k__BackingField;
    public int ExecutionOrder { get; }
    public string PropertyName { get; }
    public Type PropertyType { get; }
    public PropertyInfo Property { get; private set; }
    public bool IsDynamicProperty { get; private set; }
    public IDictionary State { get; }
    public bool Fetch { get; public set; }
    public bool IfExists { get; public set; }
    public bool SuppressNotifications { get; public set; }
    public Object[] Annotations { get; private set; }
    public TypeConverter TypeConverter { get; private set; }
    public IDictionary ExtendedProperties { get; }
    public IEnumerable`1<IDictionaryBehavior> Behaviors { get; }
    internal List`1<IDictionaryBehavior> BehaviorsInternal { get; }
    public IEnumerable`1<IDictionaryKeyBuilder> KeyBuilders { get; }
    public IEnumerable`1<IDictionaryPropertySetter> Setters { get; }
    public IEnumerable`1<IDictionaryPropertyGetter> Getters { get; }
    public IEnumerable`1<IDictionaryInitializer> Initializers { get; }
    public IEnumerable`1<IDictionaryMetaInitializer> MetaInitializers { get; }
    public PropertyDescriptor(PropertyInfo property, Object[] annotations);
    public PropertyDescriptor(Object[] annotations);
    public PropertyDescriptor(PropertyDescriptor source, bool copyBehaviors);
    private static PropertyDescriptor();
    public sealed virtual int get_ExecutionOrder();
    public string get_PropertyName();
    public Type get_PropertyType();
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(PropertyInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsDynamicProperty();
    [CompilerGeneratedAttribute]
private void set_IsDynamicProperty(bool value);
    public IDictionary get_State();
    [CompilerGeneratedAttribute]
public bool get_Fetch();
    [CompilerGeneratedAttribute]
public void set_Fetch(bool value);
    [CompilerGeneratedAttribute]
public bool get_IfExists();
    [CompilerGeneratedAttribute]
public void set_IfExists(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressNotifications();
    [CompilerGeneratedAttribute]
public void set_SuppressNotifications(bool value);
    [CompilerGeneratedAttribute]
public Object[] get_Annotations();
    [CompilerGeneratedAttribute]
private void set_Annotations(Object[] value);
    [CompilerGeneratedAttribute]
public TypeConverter get_TypeConverter();
    [CompilerGeneratedAttribute]
private void set_TypeConverter(TypeConverter value);
    public IDictionary get_ExtendedProperties();
    public IEnumerable`1<IDictionaryBehavior> get_Behaviors();
    internal List`1<IDictionaryBehavior> get_BehaviorsInternal();
    public IEnumerable`1<IDictionaryKeyBuilder> get_KeyBuilders();
    public IEnumerable`1<IDictionaryPropertySetter> get_Setters();
    public IEnumerable`1<IDictionaryPropertyGetter> get_Getters();
    public IEnumerable`1<IDictionaryInitializer> get_Initializers();
    public IEnumerable`1<IDictionaryMetaInitializer> get_MetaInitializers();
    public sealed virtual string GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor descriptor);
    public sealed virtual object GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor descriptor, bool ifExists);
    public sealed virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor descriptor);
    public PropertyDescriptor AddBehavior(IDictionaryBehavior behavior);
    public static void MergeBehavior(List`1& dictionaryBehaviors, T behavior);
    public PropertyDescriptor AddBehaviors(IDictionaryBehavior[] behaviors);
    public PropertyDescriptor AddBehaviors(IEnumerable`1<IDictionaryBehavior> behaviors);
    public PropertyDescriptor CopyBehaviors(PropertyDescriptor other);
    public sealed virtual IDictionaryBehavior Copy();
    private void ObtainTypeConverter();
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.ReferenceAttribute : Attribute {
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.RemoveIfAttribute : DictionaryBehaviorAttribute {
    private ICondition condition;
    unknown Type Condition {public set; }
    public RemoveIfAttribute(Object[] values);
    public RemoveIfAttribute(Object[] values, Type comparerType);
    protected RemoveIfAttribute(ICondition condition);
    public void set_Condition(Type value);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    internal bool ShouldRemove(object value);
    private static TBase Construct(Type type, string paramName);
}
internal class Castle.Components.DictionaryAdapter.RemoveIfEmptyAttribute : RemoveIfAttribute {
    [CompilerGeneratedAttribute]
private Type <Condition>k__BackingField;
    private Type Condition { get; private set; }
    [CompilerGeneratedAttribute]
private Type get_Condition();
    [CompilerGeneratedAttribute]
private void set_Condition(Type value);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.StringFormatAttribute : DictionaryBehaviorAttribute {
    private static Char[] PropertyDelimeters;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Properties>k__BackingField;
    public string Format { get; private set; }
    public string Properties { get; private set; }
    public StringFormatAttribute(string format, string properties);
    private static StringFormatAttribute();
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
    [CompilerGeneratedAttribute]
public string get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(string value);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private Object[] GetFormatArguments(IDictionaryAdapter dictionaryAdapter, string formattedPropertyName);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.StringListAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private char <Separator>k__BackingField;
    public char Separator { get; public set; }
    [CompilerGeneratedAttribute]
public char get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(char value);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    internal static string BuildString(IEnumerable enumerable, char separator);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.StringStorageAttribute : DictionaryBehaviorAttribute {
    public sealed virtual bool SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.StringValuesAttribute : DictionaryBehaviorAttribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    private string GetPropertyAsString(PropertyDescriptor property, object value);
}
[AttributeUsageAttribute("128")]
internal class Castle.Components.DictionaryAdapter.SuppressNotificationsAttribute : DictionaryBehaviorAttribute {
    public sealed virtual void Initialize(PropertyDescriptor propertyDescriptor, Object[] behaviors);
}
[AttributeUsageAttribute("1024")]
internal class Castle.Components.DictionaryAdapter.TypeKeyPrefixAttribute : DictionaryBehaviorAttribute {
    private sealed virtual override string Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
}
internal abstract class Castle.Components.DictionaryAdapter.VirtualObject`1 : object {
    private List`1<IVirtualSite`1<TNode>> sites;
    private EventHandler Realized;
    public bool IsReal { get; }
    protected VirtualObject`1(IVirtualSite`1<TNode> site);
    public abstract virtual bool get_IsReal();
    protected void AddSite(IVirtualSite`1<TNode> site);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual<TNode>.AddSite(IVirtualSite`1<TNode> site);
    protected void RemoveSite(IVirtualSite`1<TNode> site);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual<TNode>.RemoveSite(IVirtualSite`1<TNode> site);
    public sealed virtual TNode Realize();
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual.Realize();
    protected abstract virtual bool TryRealize(TNode& node);
    public sealed virtual void add_Realized(EventHandler value);
    public sealed virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
}
internal class Castle.Components.DictionaryAdapter.VirtualSite`2 : object {
    private IVirtualTarget`2<TNode, TMember> target;
    private TMember member;
    private static IEqualityComparer`1<IVirtualTarget`2<TNode, TMember>> TargetComparer;
    private static IEqualityComparer`1<TMember> MemberComparer;
    public IVirtualTarget`2<TNode, TMember> Target { get; }
    public TMember Member { get; }
    public VirtualSite`2(IVirtualTarget`2<TNode, TMember> target, TMember member);
    private static VirtualSite`2();
    public IVirtualTarget`2<TNode, TMember> get_Target();
    public TMember get_Member();
    public sealed virtual void OnRealizing(TNode node);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VirtualSite`2<TNode, TMember> other);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.VolatileAttribute : Attribute {
}
internal class Castle.Components.DictionaryAdapter.Xml.CompiledXPath : object {
    private XPathExpression path;
    private CompiledXPathStep firstStep;
    private int depth;
    private static IList`1<CompiledXPathStep> NoSteps;
    public XPathExpression Path { get; internal set; }
    public CompiledXPathStep FirstStep { get; internal set; }
    public CompiledXPathStep LastStep { get; }
    public int Depth { get; internal set; }
    public bool IsCreatable { get; }
    private static CompiledXPath();
    public XPathExpression get_Path();
    internal void set_Path(XPathExpression value);
    public CompiledXPathStep get_FirstStep();
    internal void set_FirstStep(CompiledXPathStep value);
    public CompiledXPathStep get_LastStep();
    public int get_Depth();
    internal void set_Depth(int value);
    public bool get_IsCreatable();
    internal void MakeNotCreatable();
    internal void Prepare();
    public void SetContext(XsltContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.CompiledXPathNode : object {
    private string prefix;
    private string localName;
    private bool isAttribute;
    private XPathExpression value;
    private CompiledXPathNode next;
    private CompiledXPathNode previous;
    private IList`1<CompiledXPathNode> dependencies;
    private static IList`1<CompiledXPathNode> NoDependencies;
    public string Prefix { get; internal set; }
    public string LocalName { get; internal set; }
    public bool IsAttribute { get; internal set; }
    public bool IsSelfReference { get; }
    public bool IsSimple { get; }
    public XPathExpression Value { get; internal set; }
    public CompiledXPathNode NextNode { get; internal set; }
    public CompiledXPathNode PreviousNode { get; internal set; }
    public IList`1<CompiledXPathNode> Dependencies { get; }
    private static CompiledXPathNode();
    public string get_Prefix();
    internal void set_Prefix(string value);
    public string get_LocalName();
    internal void set_LocalName(string value);
    public bool get_IsAttribute();
    internal void set_IsAttribute(bool value);
    public bool get_IsSelfReference();
    public bool get_IsSimple();
    public XPathExpression get_Value();
    internal void set_Value(XPathExpression value);
    public CompiledXPathNode get_NextNode();
    internal void set_NextNode(CompiledXPathNode value);
    public CompiledXPathNode get_PreviousNode();
    internal void set_PreviousNode(CompiledXPathNode value);
    public IList`1<CompiledXPathNode> get_Dependencies();
    private bool HasNoRealDependencies();
    private XPathExpression GetSelfReferenceValue();
    internal virtual void Prepare();
    internal virtual void SetContext(XsltContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.CompiledXPathStep : CompiledXPathNode {
    private XPathExpression path;
    public XPathExpression Path { get; internal set; }
    public CompiledXPathStep NextStep { get; }
    public XPathExpression get_Path();
    internal void set_Path(XPathExpression value);
    public CompiledXPathStep get_NextStep();
    internal virtual void SetContext(XsltContext context);
}
[FlagsAttribute]
internal enum Castle.Components.DictionaryAdapter.Xml.CursorFlags : Enum {
    public int value__;
    public static CursorFlags None;
    public static CursorFlags Elements;
    public static CursorFlags Attributes;
    public static CursorFlags Multiple;
    public static CursorFlags Mutable;
    public static CursorFlags AllNodes;
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.CursorFlagsExtensions : object {
    [ExtensionAttribute]
public static CursorFlags MutableIf(CursorFlags flags, bool mutable);
    [ExtensionAttribute]
public static bool IncludesElements(CursorFlags flags);
    [ExtensionAttribute]
public static bool IncludesAttributes(CursorFlags flags);
    [ExtensionAttribute]
public static bool AllowsMultipleItems(CursorFlags flags);
    [ExtensionAttribute]
public static bool SupportsMutation(CursorFlags flags);
}
internal class Castle.Components.DictionaryAdapter.Xml.DefaultXmlReferenceFormat : object {
    private static NumberStyles IntegerStyle;
    public static DefaultXmlReferenceFormat Instance;
    private static IFormatProvider Culture;
    private static DefaultXmlReferenceFormat();
    public sealed virtual bool TryGetIdentity(IXmlNode node, Int32& id);
    public sealed virtual bool TryGetReference(IXmlNode node, Int32& id);
    public sealed virtual void SetIdentity(IXmlNode node, int id);
    public sealed virtual void SetReference(IXmlNode node, int id);
    public sealed virtual void ClearIdentity(IXmlNode node);
    public sealed virtual void ClearReference(IXmlNode node);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.DictionaryAdapterExtensions : object {
    private static string XmlAccessorKey;
    private static string XmlMetaKey;
    private static string XmlTypeKey;
    [ExtensionAttribute]
public static object CreateChildAdapter(IDictionaryAdapter parent, Type type, XmlAdapter adapter);
    [ExtensionAttribute]
public static object CreateChildAdapter(IDictionaryAdapter parent, Type type, XmlAdapter adapter, IDictionary dictionary);
    [ExtensionAttribute]
public static bool HasAccessor(PropertyDescriptor property);
    [ExtensionAttribute]
public static XmlAccessor GetAccessor(PropertyDescriptor property);
    [ExtensionAttribute]
public static void SetAccessor(PropertyDescriptor property, XmlAccessor accessor);
    [ExtensionAttribute]
public static bool HasXmlMeta(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static XmlMetadata GetXmlMeta(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static void SetXmlMeta(DictionaryAdapterMeta meta, XmlMetadata xmlMeta);
    [ExtensionAttribute]
public static bool HasXmlType(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static string GetXmlType(DictionaryAdapterMeta meta);
    [ExtensionAttribute]
public static void SetXmlType(DictionaryAdapterMeta meta, string value);
}
internal static class Castle.Components.DictionaryAdapter.Xml.Error : object {
    internal static Exception ArgumentNull(string paramName);
    internal static Exception ArgumentOutOfRange(string paramName);
    internal static Exception InvalidOperation();
    internal static Exception NotSupported();
    internal static Exception ObjectDisposed(string objectName);
    internal static Exception AttributeConflict(string propertyName);
    internal static Exception SeparateGetterSetterOnComplexType(string propertyName);
    internal static Exception XmlMetadataNotAvailable(Type clrType);
    internal static Exception NotDictionaryAdapter(string paramName);
    internal static Exception NoInstanceDescriptor(string paramName);
    internal static Exception NoXmlAdapter(string paramName);
    internal static Exception NotRealizable();
    internal static Exception CursorNotMutable();
    internal static Exception CursorNotInCreatableState();
    internal static Exception CursorNotInRemovableState();
    internal static Exception CursorNotInCoercibleState();
    internal static Exception CursorNotInRealizableState();
    internal static Exception CursorCannotMoveToGivenNode();
    internal static Exception CannotSetAttribute(IXmlIdentity identity);
    internal static Exception NotXmlKnownType(Type clrType);
    internal static Exception UnsupportedCollectionType(Type clrType);
    internal static Exception NotCollectionType(string paramName);
    internal static Exception InvalidLocalName();
    internal static Exception InvalidNamespaceUri();
    internal static Exception NoDefaultKnownType();
    internal static Exception XPathNotCreatable(CompiledXPath path);
    internal static Exception XPathNavigationFailed(XPathExpression path);
    internal static Exception ObjectIdNotFound(string id);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IConfigurable`1 {
    public abstract virtual void Configure(T value);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IRealizable`1 {
    public bool IsReal { get; }
    public T Value { get; }
    public abstract virtual bool get_IsReal();
    public abstract virtual T get_Value();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IRealizableSource {
    public abstract virtual IRealizable`1<T> AsRealizable();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlAccessor {
    public Type ClrType { get; }
    public XmlTypeSerializer Serializer { get; }
    public IXmlContext Context { get; }
    public bool IsNillable { get; }
    public bool IsReference { get; }
    public abstract virtual Type get_ClrType();
    public abstract virtual XmlTypeSerializer get_Serializer();
    public abstract virtual IXmlContext get_Context();
    public abstract virtual bool get_IsNillable();
    public abstract virtual bool get_IsReference();
    public abstract virtual object GetValue(IXmlNode node, IDictionaryAdapter parentObject, XmlReferenceManager references, bool nodeExists, bool orStub);
    public abstract virtual void SetValue(IXmlCursor cursor, IDictionaryAdapter parentObject, XmlReferenceManager references, bool hasCurrent, object oldValue, Object& newValue);
    public abstract virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlBehaviorSemantics`1 {
    public abstract virtual string GetLocalName(T behavior);
    public abstract virtual string GetNamespaceUri(T behavior);
    public abstract virtual Type GetClrType(T behavior);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlCollectionAccessor {
    public abstract virtual IXmlCursor SelectCollectionItems(IXmlNode parentNode, bool mutable);
    public abstract virtual void GetCollectionItems(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, IList values);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlContext {
    public string ChildNamespaceUri { get; }
    public abstract virtual string get_ChildNamespaceUri();
    public abstract virtual IXmlContext Clone();
    public abstract virtual XmlName GetDefaultXsiType(Type clrType);
    public abstract virtual IEnumerable`1<IXmlIncludedType> GetIncludedTypes(Type baseType);
    public abstract virtual bool IsReservedNamespaceUri(string namespaceUri);
    public abstract virtual void AddVariable(XPathVariableAttribute attribute);
    public abstract virtual void AddFunction(XPathFunctionAttribute attribute);
    public abstract virtual void Enlist(CompiledXPath path);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlCursor {
    public abstract virtual void Reset();
    public abstract virtual void MoveTo(IXmlNode node);
    public abstract virtual void MoveToEnd();
    public abstract virtual void Create(Type type);
    public abstract virtual void Coerce(Type type);
    public abstract virtual void Remove();
    public abstract virtual void RemoveAllNext();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlIdentity {
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public abstract virtual XmlName get_Name();
    public abstract virtual XmlName get_XsiType();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlIncludedType {
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public abstract virtual XmlName get_XsiType();
    public abstract virtual Type get_ClrType();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap {
    public IXmlIncludedType Default { get; }
    public abstract virtual IXmlIncludedType get_Default();
    public abstract virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public abstract virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlIterator {
    public abstract virtual bool MoveNext();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlKnownType {
    public Type ClrType { get; }
    public abstract virtual Type get_ClrType();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap {
    public IXmlKnownType Default { get; }
    public abstract virtual IXmlKnownType get_Default();
    public abstract virtual bool TryGet(IXmlIdentity xmlNode, IXmlKnownType& knownType);
    public abstract virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlNamespaceSource {
    public abstract virtual string GetElementPrefix(IXmlNode node, string namespaceUri);
    public abstract virtual string GetAttributePrefix(IXmlNode node, string namespaceUri);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlNode {
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public IXmlNode Parent { get; }
    public IXmlNamespaceSource Namespaces { get; }
    public object UnderlyingObject { get; }
    public CompiledXPath Path { get; }
    public abstract virtual bool get_IsElement();
    public abstract virtual bool get_IsAttribute();
    public abstract virtual bool get_IsNil();
    public abstract virtual void set_IsNil(bool value);
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    public abstract virtual string get_Xml();
    public abstract virtual IXmlNode get_Parent();
    public abstract virtual IXmlNamespaceSource get_Namespaces();
    public abstract virtual string GetAttribute(XmlName name);
    public abstract virtual void SetAttribute(XmlName name, string value);
    public abstract virtual string LookupPrefix(string namespaceUri);
    public abstract virtual string LookupNamespaceUri(string prefix);
    public abstract virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    public abstract virtual object get_UnderlyingObject();
    public abstract virtual bool UnderlyingPositionEquals(IXmlNode node);
    public abstract virtual IXmlNode Save();
    public abstract virtual IXmlCursor SelectSelf(Type clrType);
    public abstract virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public abstract virtual IXmlIterator SelectSubtree();
    public abstract virtual CompiledXPath get_Path();
    public abstract virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public abstract virtual object Evaluate(CompiledXPath path);
    public abstract virtual void Clear();
    public abstract virtual XmlReader ReadSubtree();
    public abstract virtual XmlWriter WriteAttributes();
    public abstract virtual XmlWriter WriteChildren();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlNodeSource {
    public IXmlNode Node { get; }
    public abstract virtual IXmlNode get_Node();
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlPropertyAccessor {
    public abstract virtual object GetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    public abstract virtual void SetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, object oldValue, Object& newValue);
}
internal interface Castle.Components.DictionaryAdapter.Xml.IXmlReferenceFormat {
    public abstract virtual bool TryGetIdentity(IXmlNode node, Int32& id);
    public abstract virtual bool TryGetReference(IXmlNode node, Int32& id);
    public abstract virtual void SetIdentity(IXmlNode node, int id);
    public abstract virtual void SetReference(IXmlNode node, int id);
    public abstract virtual void ClearIdentity(IXmlNode node);
    public abstract virtual void ClearReference(IXmlNode node);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.RealizableExtensions : object {
    [ExtensionAttribute]
public static IRealizable`1<T> RequireRealizable(IRealizableSource obj);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.Xml.SingletonDispenser`2 : object {
    private Lock locker;
    private Dictionary`2<TKey, object> items;
    private Func`2<TKey, TItem> factory;
    public TItem Item { get; protected set; }
    public SingletonDispenser`2(Func`2<TKey, TItem> factory);
    public TItem get_Item(TKey key);
    protected void set_Item(TKey key, TItem value);
    private TItem GetOrCreate(TKey key);
    private bool TryGetExistingItem(TKey key, Object& item);
    private TItem WaitForCreate(TKey key, object item);
    private TItem Create(TKey key, object item);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.StringExtensions : object {
    [ExtensionAttribute]
public static string NonEmpty(string s);
}
internal class Castle.Components.DictionaryAdapter.Xml.SysXmlCursor : SysXmlNode {
    private State state;
    private int index;
    private IXmlKnownTypeMap knownTypes;
    private CursorFlags flags;
    private EventHandler Realized;
    protected static StringComparer DefaultComparer;
    public bool IsReal { get; }
    public bool HasCurrent { get; }
    public Type ClrType { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public SysXmlCursor(IXmlNode parent, IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    private static SysXmlCursor();
    public virtual bool get_IsReal();
    public bool get_HasCurrent();
    public virtual Type get_ClrType();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public virtual object Evaluate(CompiledXPath path);
    public sealed virtual bool MoveNext();
    private bool MoveNextCore();
    private bool IsMatch();
    private bool Advance();
    protected virtual bool AdvanceToFirstElement();
    private bool AdvanceToNextElement();
    protected virtual bool AdvanceToFirstAttribute();
    private bool AdvanceToNextAttribute();
    private bool AdvanceElement(XmlNode next);
    private bool AdvanceAttribute(XmlNode parent);
    private bool Succeed(State state);
    private bool Fail(State state);
    private bool IsAtEnd();
    public sealed virtual void MoveTo(IXmlNode position);
    private void SetMovedToElement();
    private void SetMovedToAttribute();
    public sealed virtual void MoveToEnd();
    public sealed virtual void Reset();
    private void MoveToParentOfElement();
    private void MoveToParentOfAttribute();
    private void MoveToRealizedParent();
    public virtual void add_Realized(EventHandler value);
    public virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
    protected virtual void Realize();
    public void MakeNext(Type clrType);
    public sealed virtual void Coerce(Type clrType);
    private void CoerceElement(IXmlKnownType knownType);
    private void CoerceAttribute(IXmlKnownType knownType);
    public sealed virtual void Create(Type type);
    private void CreateElement(IXmlKnownType knownType, XmlNode position);
    private void CreateAttribute(IXmlKnownType knownType, XmlNode position);
    private XmlElement CreateElementCore(XmlNode parent, XmlName name);
    private XmlAttribute CreateAttributeCore(XmlNode parent, XmlName name);
    private void RequireNoXsiType(IXmlKnownType knownType);
    private XmlName GetEffectiveName(IXmlKnownType knownType, XmlNode parent);
    public sealed virtual void RemoveAllNext();
    public sealed virtual void Remove();
    private void RemoveElement(XmlNode node);
    private void RemoveAttribute(XmlNode node);
    public virtual IXmlNode Save();
    private XmlNode RequireCreatable();
    private void RequireCoercible();
    private void RequireRemovable();
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.SysXmlExtensions : object {
    [ExtensionAttribute]
public static void DefineNamespace(XmlElement node, string prefix, string namespaceUri);
    [ExtensionAttribute]
public static bool IsNamespace(XmlAttribute attribute);
    [ExtensionAttribute]
public static XmlElement FindRoot(XmlElement node);
    [ExtensionAttribute]
public static bool IsXsiType(XmlAttribute attribute);
}
internal class Castle.Components.DictionaryAdapter.Xml.SysXmlNode : XmlNodeBase {
    protected XmlNode node;
    public object UnderlyingObject { get; }
    private XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.Value { get; }
    private XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.Value { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    protected SysXmlNode(IXmlNamespaceSource namespaces, IXmlNode parent);
    public SysXmlNode(XmlNode node, Type type, IXmlNamespaceSource namespaces);
    public sealed virtual object get_UnderlyingObject();
    private sealed virtual override XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.get_Value();
    private sealed virtual override XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.get_Value();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public sealed virtual bool UnderlyingPositionEquals(IXmlNode node);
    public sealed virtual string GetAttribute(XmlName name);
    public sealed virtual void SetAttribute(XmlName name, string value);
    private void SetAttributeCore(XmlName name, string value);
    private void ClearAttribute(XmlName name);
    public sealed virtual string LookupPrefix(string namespaceUri);
    public sealed virtual string LookupNamespaceUri(string prefix);
    public sealed virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    private XmlElement GetNamespaceTargetElement();
    public virtual IXmlNode Save();
    public sealed virtual IXmlCursor SelectSelf(Type clrType);
    public sealed virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual IXmlIterator SelectSubtree();
    public sealed virtual XmlReader ReadSubtree();
    public sealed virtual XmlWriter WriteAttributes();
    public sealed virtual XmlWriter WriteChildren();
    public sealed virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public virtual object Evaluate(CompiledXPath path);
    public XmlNode GetNode();
    public sealed virtual void Clear();
    private void ClearAttributes();
    private void ClearChildren();
}
internal class Castle.Components.DictionaryAdapter.Xml.SysXmlSubtreeIterator : SysXmlNode {
    private State state;
    public SysXmlSubtreeIterator(IXmlNode parent, IXmlNamespaceSource namespaces);
    public sealed virtual bool MoveNext();
    private bool MoveToInitial();
    private bool MoveToSubsequent();
    private bool MoveToElement(XmlNode node);
    private bool SetNext(XmlNode node);
    public virtual IXmlNode Save();
}
internal static class Castle.Components.DictionaryAdapter.Xml.Try : object {
    [DebuggerHiddenAttribute]
public static bool Failure(T& result);
    [DebuggerHiddenAttribute]
public static bool Success(T& result, T value);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.TypeExtensions : object {
    [ExtensionAttribute]
public static Type NonNullable(Type type);
    [ExtensionAttribute]
public static Type GetCollectionItemType(Type type);
    [ExtensionAttribute]
public static Type GetComponentType(object obj);
    [ExtensionAttribute]
internal static bool IsCustomSerializable(Type type);
}
internal static class Castle.Components.DictionaryAdapter.Xml.Wsdl : object {
    public static string Prefix;
    public static string NamespaceUri;
    internal static XmlNamespaceAttribute Namespace;
    private static Wsdl();
}
internal abstract class Castle.Components.DictionaryAdapter.Xml.XmlAccessor : object {
    private Type clrType;
    private XmlName xsiType;
    private XmlTypeSerializer serializer;
    private IXmlContext context;
    protected States state;
    public Type ClrType { get; }
    public XmlName XsiType { get; }
    public XmlTypeSerializer Serializer { get; }
    public IXmlContext Context { get; protected set; }
    public bool IsCollection { get; }
    public bool IsIgnored { get; }
    public bool IsNillable { get; }
    public bool IsVolatile { get; }
    public bool IsReference { get; }
    protected XmlAccessor(Type clrType, IXmlContext context);
    public sealed virtual Type get_ClrType();
    public XmlName get_XsiType();
    public sealed virtual XmlTypeSerializer get_Serializer();
    public sealed virtual IXmlContext get_Context();
    protected void set_Context(IXmlContext value);
    public bool get_IsCollection();
    public virtual bool get_IsIgnored();
    public sealed virtual bool get_IsNillable();
    public bool get_IsVolatile();
    public sealed virtual bool get_IsReference();
    public virtual void ConfigureNillable(bool nillable);
    public void ConfigureVolatile(bool isVolatile);
    public virtual void ConfigureReference(bool isReference);
    public virtual void Prepare();
    protected IXmlContext CloneContext();
    private void SetContext(IXmlContext value);
    public virtual bool IsPropertyDefined(IXmlNode parentNode);
    public virtual object GetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    public sealed virtual object GetValue(IXmlNode node, IDictionaryAdapter parentObject, XmlReferenceManager references, bool nodeExists, bool orStub);
    private object GetValueCore(IXmlNode node, IDictionaryAdapter parentObject, bool nodeExists, bool orStub);
    public virtual void SetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, object oldValue, Object& value);
    public virtual void SetValue(IXmlCursor cursor, IDictionaryAdapter parentObject, XmlReferenceManager references, bool hasCurrent, object oldValue, Object& newValue);
    private void Coerce(IXmlCursor cursor, Type clrType, bool replace);
    public sealed virtual void GetCollectionItems(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, IList values);
    protected void RemoveCollectionItems(IXmlNode parentNode, XmlReferenceManager references, object value);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    protected IXmlCollectionAccessor GetDefaultCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode parentNode, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode parentNode, bool mutable);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode parentNode, bool mutable);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlAccessorFactory`1 : MulticastDelegate {
    public XmlAccessorFactory`1(object object, IntPtr method);
    public virtual TAccessor Invoke(string name, Type type, IXmlContext context);
    public virtual IAsyncResult BeginInvoke(string name, Type type, IXmlContext context, AsyncCallback callback, object object);
    public virtual TAccessor EndInvoke(IAsyncResult result);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlAdapter : DictionaryBehaviorAttribute {
    private IXmlNode node;
    private object source;
    private XmlReferenceManager references;
    private XmlMetadata primaryXmlMeta;
    private Dictionary`2<Type, XmlMetadata> secondaryXmlMetas;
    private bool isRoot;
    private EventHandler Realized;
    public bool IsReal { get; }
    public IXmlNode Node { get; }
    internal XmlReferenceManager References { get; }
    public XmlAdapter(XmlNode node);
    public XmlAdapter(IXmlNode node, XmlReferenceManager references);
    public sealed virtual bool get_IsReal();
    public sealed virtual IXmlNode get_Node();
    internal XmlReferenceManager get_References();
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryCreateStrategy.Create(IDictionaryAdapter parent, Type type, IDictionary dictionary);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryInitializer.Initialize(IDictionaryAdapter dictionaryAdapter, Object[] behaviors);
    private void InitializePrimary(DictionaryAdapterMeta meta, IDictionaryAdapter dictionaryAdapter);
    private void InitializeSecondary(DictionaryAdapterMeta meta);
    private void InitializeBaseTypes(DictionaryAdapterMeta meta);
    private void InitializeStrategies(IDictionaryAdapter dictionaryAdapter);
    private void InitializeReference(object value);
    private void AddSecondaryXmlMeta(DictionaryAdapterMeta meta);
    private static void RequireXmlMeta(DictionaryAdapterMeta meta);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryCopyStrategy.Copy(IDictionaryAdapter source, IDictionaryAdapter target, Func`2& selector);
    private sealed virtual override object Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, object storedValue, PropertyDescriptor property, bool ifExists);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(IDictionaryAdapter dictionaryAdapter, string key, Object& value, PropertyDescriptor property);
    private static string EnsureKey(string key, PropertyDescriptor property);
    private IXmlNode GetBaseNode();
    private IXmlNode GetSourceNode();
    private bool TryGetAccessor(string key, PropertyDescriptor property, bool requireVolatile, XmlAccessor& accessor);
    private XmlAccessor CreateAccessor(string key, PropertyDescriptor property);
    private bool TryApplyBehavior(string key, PropertyDescriptor property, object behavior, XmlAccessor& accessor);
    private bool TryApplyBehavior(string key, PropertyDescriptor property, object behavior, XmlAccessor& accessor, XmlAccessorFactory`1<TAccessor> factory);
    private TAccessor CreateAccessor(string key, PropertyDescriptor property, XmlAccessorFactory`1<TAccessor> factory);
    private XmlMetadata GetXmlMetadata(Type type);
    private static bool IsIgnoreBehavior(object behavior);
    private static bool IsVolatileBehavior(object behavior);
    private static bool IsReferenceBehavior(object behavior);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual.Realize();
    public sealed virtual void add_Realized(EventHandler value);
    public sealed virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
    private void HandleNodeRealized(object sender, EventArgs e);
    private void AttachObservers(object value, IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);
    private void HandleListChanged(object value, ListChangedEventArgs args, IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryReferenceManager.IsReferenceProperty(IDictionaryAdapter dictionaryAdapter, string propertyName);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryReferenceManager.TryGetReference(object keyObject, Object& inGraphObject);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryReferenceManager.AddReference(object keyObject, object relatedObject, bool isInGraph);
    public virtual IDictionaryBehavior Copy();
    public static XmlAdapter For(object obj);
    public static XmlAdapter For(object obj, bool required);
    public static bool IsPropertyDefined(string propertyName, IDictionaryAdapter dictionaryAdapter);
    public bool HasProperty(string propertyName, IDictionaryAdapter dictionaryAdapter);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlArrayBehaviorAccessor : XmlNodeAccessor {
    private static CursorFlags PropertyFlags;
    private static CursorFlags CollectionItemFlags;
    private ItemAccessor itemAccessor;
    internal static XmlAccessorFactory`1<XmlArrayBehaviorAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XmlArrayBehaviorAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    public XmlArrayBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlArrayBehaviorAccessor();
    public sealed virtual void Configure(XmlArrayAttribute attribute);
    public sealed virtual void Configure(XmlArrayItemAttribute attribute);
    public virtual void Prepare();
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    [CompilerGeneratedAttribute]
private static XmlArrayBehaviorAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlArraySerializer : XmlTypeSerializer {
    public static XmlArraySerializer Instance;
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    private static XmlArraySerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
    private static object GetItemSafe(Array array, int index);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlAttributeBehaviorAccessor : XmlNodeAccessor {
    internal static XmlAccessorFactory`1<XmlAttributeBehaviorAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XmlAttributeBehaviorAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    public XmlAttributeBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlAttributeBehaviorAccessor();
    public sealed virtual void Configure(XmlAttributeAttribute attribute);
    public virtual void ConfigureNillable(bool nillable);
    public virtual void ConfigureReference(bool isReference);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    [CompilerGeneratedAttribute]
private static XmlAttributeBehaviorAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Components.DictionaryAdapter.Xml.XmlCollectionAdapter`1 : object {
    private List`1<XmlCollectionItem`1<T>> items;
    private List`1<XmlCollectionItem`1<T>> snapshot;
    private ICollectionAdapterObserver`1<T> advisor;
    private IXmlCursor cursor;
    private IXmlCollectionAccessor accessor;
    private IXmlNode parentNode;
    private IDictionaryAdapter parentObject;
    private XmlReferenceManager references;
    public IXmlNode Node { get; }
    public XmlReferenceManager References { get; }
    public int Count { get; }
    public T Item { get; public set; }
    public IEqualityComparer`1<T> Comparer { get; }
    public bool HasSnapshot { get; }
    public int SnapshotCount { get; }
    public XmlCollectionAdapter`1(IXmlNode parentNode, IDictionaryAdapter parentObject, IXmlCollectionAccessor accessor);
    public sealed virtual IXmlNode get_Node();
    public XmlReferenceManager get_References();
    public sealed virtual int get_Count();
    public sealed virtual void Initialize(ICollectionAdapterObserver`1<T> advisor);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual T AddNew();
    public sealed virtual bool Add(T value);
    public sealed virtual bool Insert(int index, T value);
    private bool InsertCore(int index, T value, bool append);
    private bool CommitInsert(int index, IXmlNode node, T value, bool append);
    private bool RollbackInsert();
    public sealed virtual void Remove(int index);
    public sealed virtual void Clear();
    public sealed virtual void ClearReferences();
    private void OnRemoving(XmlCollectionItem`1<T> item);
    private T GetValue(IXmlNode node);
    private void SetValue(IXmlCursor cursor, object oldValue, T& value);
    private static Type GetTypeOrDefault(T value);
    public sealed virtual IEqualityComparer`1<T> get_Comparer();
    public sealed virtual bool get_HasSnapshot();
    public sealed virtual int get_SnapshotCount();
    public sealed virtual T GetCurrentItem(int index);
    public sealed virtual T GetSnapshotItem(int index);
    public sealed virtual void SaveSnapshot();
    public sealed virtual void LoadSnapshot();
    public sealed virtual void DropSnapshot();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlCollectionItem`1 : ValueType {
    public IXmlNode Node;
    public T Value;
    public bool HasValue;
    public XmlCollectionItem`1(IXmlNode node);
    public XmlCollectionItem`1(IXmlNode node, T value);
    private XmlCollectionItem`1(IXmlNode node, T value, bool hasValue);
    public XmlCollectionItem`1<T> WithValue(T value);
}
internal abstract class Castle.Components.DictionaryAdapter.Xml.XmlCollectionSerializer : XmlTypeSerializer {
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    public Type ListTypeConstructor { get; }
    public virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public abstract virtual Type get_ListTypeConstructor();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    private object GetValueCore(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlComponentSerializer : XmlTypeSerializer {
    public static XmlComponentSerializer Instance;
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    private static XmlComponentSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlContext : XmlContextBase {
    private XmlMetadata metadata;
    public string ChildNamespaceUri { get; }
    public XmlContext(XmlMetadata metadata);
    protected XmlContext(XmlContext parent);
    public sealed virtual IXmlContext Clone();
    public sealed virtual string get_ChildNamespaceUri();
    public sealed virtual bool IsReservedNamespaceUri(string namespaceUri);
    public sealed virtual XmlName GetDefaultXsiType(Type clrType);
    public sealed virtual IEnumerable`1<IXmlIncludedType> GetIncludedTypes(Type baseType);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlContextBase : XsltContext {
    private XmlContextBase parent;
    private Dictionary`2<string, string> rootNamespaces;
    private bool hasNamespaces;
    private XPathContext xPathContext;
    private Dictionary`2<XmlName, IXsltContextVariable> variables;
    private Dictionary`2<XmlName, IXsltContextFunction> functions;
    private XPathContext XPathContext { get; }
    public bool Whitespace { get; }
    protected XmlContextBase(XmlContextBase parent);
    private static NameTable GetNameTable(XmlContextBase parent);
    public void AddNamespace(XmlNamespaceAttribute attribute);
    public virtual void AddNamespace(string prefix, string uri);
    private Dictionary`2<string, string> EnsureRootNamespaces();
    public virtual string LookupNamespace(string prefix);
    public virtual string LookupPrefix(string uri);
    public sealed virtual string GetElementPrefix(IXmlNode node, string namespaceUri);
    public sealed virtual string GetAttributePrefix(IXmlNode node, string namespaceUri);
    private static bool TryGetDefinedPrefix(IXmlNode node, string namespaceUri, String& prefix);
    private bool TryGetPreferredPrefix(IXmlNode node, string namespaceUri, String& prefix);
    private static string GeneratePrefix(IXmlNode node);
    private bool ShouldDefineOnRoot(string prefix, string uri);
    private bool ShouldDefineOnRootCore(string prefix, string uri);
    private XPathContext get_XPathContext();
    public virtual bool get_Whitespace();
    public virtual bool PreserveWhitespace(XPathNavigator node);
    public virtual int CompareDocument(string baseUriA, string baseUriB);
    public void AddVariable(string prefix, string name, IXsltContextVariable variable);
    public void AddFunction(string prefix, string name, IXsltContextFunction function);
    public sealed virtual void AddVariable(XPathVariableAttribute attribute);
    public sealed virtual void AddFunction(XPathFunctionAttribute attribute);
    public void AddVariable(XmlName name, IXsltContextVariable variable);
    public void AddFunction(XmlName name, IXsltContextFunction function);
    private Dictionary`2<XmlName, IXsltContextVariable> EnsureVariables();
    private Dictionary`2<XmlName, IXsltContextFunction> EnsureFunctions();
    public virtual IXsltContextVariable ResolveVariable(string prefix, string name);
    public virtual IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes);
    private IXsltContextVariable ResolveVariableCore(string prefix, string name);
    private IXsltContextFunction ResolveFunctionCore(string prefix, string name, XPathResultType[] argTypes);
    public sealed virtual void Enlist(CompiledXPath path);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlCustomSerializer : XmlTypeSerializer {
    public static XmlCustomSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlCustomSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlDefaultBehaviorAccessor : XmlNodeAccessor {
    internal static XmlAccessorFactory`1<XmlDefaultBehaviorAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XmlDefaultBehaviorAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    public XmlDefaultBehaviorAccessor(Type type, IXmlContext context);
    public XmlDefaultBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlDefaultBehaviorAccessor();
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode node, bool mutable);
    [CompilerGeneratedAttribute]
private static XmlDefaultBehaviorAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlDefaultSerializer : XmlTypeSerializer {
    private XmlSerializer serializer;
    public static XmlRootAttribute Root;
    public XmlTypeKind Kind { get; }
    public XmlDefaultSerializer(Type type);
    private static XmlDefaultSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlDynamicSerializer : XmlTypeSerializer {
    public static XmlDynamicSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlDynamicSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlElementBehaviorAccessor : XmlNodeAccessor {
    private ItemAccessor itemAccessor;
    private List`1<XmlElementAttribute> attributes;
    internal static XmlAccessorFactory`1<XmlElementBehaviorAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XmlElementBehaviorAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    public XmlElementBehaviorAccessor(string name, Type type, IXmlContext context);
    private static XmlElementBehaviorAccessor();
    public sealed virtual void Configure(XmlElementAttribute attribute);
    public virtual void Prepare();
    public virtual void SetValue(IXmlCursor cursor, IDictionaryAdapter parentObject, XmlReferenceManager references, bool hasCurrent, object oldValue, Object& newValue);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    public sealed virtual string GetLocalName(XmlElementAttribute attribute);
    public sealed virtual string GetNamespaceUri(XmlElementAttribute attribute);
    public sealed virtual Type GetClrType(XmlElementAttribute attribute);
    [CompilerGeneratedAttribute]
private static XmlElementBehaviorAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlEnumerationSerializer : XmlStringSerializer {
    public static XmlEnumerationSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlEnumerationSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XmlExtensions : object {
    [ExtensionAttribute]
public static bool PositionEquals(IXmlNode nodeA, IXmlNode nodeB);
    [ExtensionAttribute]
public static void CopyTo(IXmlNode source, IXmlNode target);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlIgnoreBehaviorAccessor : XmlAccessor {
    public static XmlIgnoreBehaviorAccessor Instance;
    public bool IsIgnored { get; }
    private static XmlIgnoreBehaviorAccessor();
    public virtual bool get_IsIgnored();
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool mutable);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode node, bool mutable);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlIncludedType : object {
    private XmlName xsiType;
    private Type clrType;
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public XmlIncludedType(XmlName xsiType, Type clrType);
    public XmlIncludedType(string localName, string namespaceUri, Type clrType);
    public sealed virtual XmlName get_XsiType();
    public sealed virtual Type get_ClrType();
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XmlIncludedTypeMapExtensions : object {
    [ExtensionAttribute]
public static IXmlIncludedType Require(IXmlIncludedTypeMap includedTypes, Type clrType);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlIncludedTypeSet : object {
    private Dictionary`2<XmlName, IXmlIncludedType> itemsByXsiType;
    private Dictionary`2<Type, IXmlIncludedType> itemsByClrType;
    public static IList`1<IXmlIncludedType> DefaultEntries;
    private IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.Default { get; }
    private static XmlIncludedTypeSet();
    private sealed virtual override IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.get_Default();
    public void Add(IXmlIncludedType includedType);
    public sealed virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public sealed virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
    public sealed virtual IEnumerator`1<IXmlIncludedType> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlKnownType : object {
    private XmlName name;
    private XmlName xsiType;
    private Type clrType;
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public XmlKnownType(XmlName name, XmlName xsiType, Type clrType);
    public XmlKnownType(string nameLocalName, string nameNamespaceUri, string xsiTypeLocalName, string xsiTypeNamespaceUri, Type clrType);
    public sealed virtual XmlName get_Name();
    public sealed virtual XmlName get_XsiType();
    public sealed virtual Type get_ClrType();
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XmlKnownTypeMapExtensions : object {
    [ExtensionAttribute]
public static IXmlKnownType Require(IXmlKnownTypeMap map, Type clrType);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlKnownTypeSet : object {
    private Dictionary`2<IXmlIdentity, IXmlKnownType> itemsByXmlIdentity;
    private Dictionary`2<Type, IXmlKnownType> itemsByClrType;
    private Type defaultType;
    private static StringComparer NameComparer;
    private static XmlNameComparer XsiTypeComparer;
    public IXmlKnownType Default { get; }
    public XmlKnownTypeSet(Type defaultType);
    private static XmlKnownTypeSet();
    public sealed virtual IXmlKnownType get_Default();
    public void Add(IXmlKnownType knownType, bool overwrite);
    public void AddXsiTypeDefaults();
    public sealed virtual bool TryGet(IXmlIdentity xmlIdentity, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
    public IXmlKnownType[] ToArray();
    public sealed virtual IEnumerator`1<IXmlKnownType> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlListSerializer : XmlCollectionSerializer {
    public static XmlListSerializer Instance;
    public Type ListTypeConstructor { get; }
    private static XmlListSerializer();
    public virtual Type get_ListTypeConstructor();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlMetadata : object {
    private static CursorFlags RootFlags;
    private Type clrType;
    private Nullable`1<bool> qualified;
    private Nullable`1<bool> isNullable;
    private Nullable`1<bool> isReference;
    private string rootLocalName;
    private string rootNamespaceUri;
    private string childNamespaceUri;
    private string typeLocalName;
    private string typeNamespaceUri;
    private HashSet`1<string> reservedNamespaceUris;
    private List`1<Type> pendingIncludes;
    private XmlIncludedTypeSet includedTypes;
    private XmlContext context;
    private DictionaryAdapterMeta source;
    private CompiledXPath path;
    protected static StringComparer NameComparer;
    public Type ClrType { get; }
    public Nullable`1<bool> Qualified { get; }
    public Nullable`1<bool> IsNullable { get; }
    public Nullable`1<bool> IsReference { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    private XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.XsiType { get; }
    public string ChildNamespaceUri { get; }
    public IEnumerable`1<string> ReservedNamespaceUris { get; }
    public XmlIncludedTypeSet IncludedTypes { get; }
    public IXmlContext Context { get; }
    public CompiledXPath Path { get; }
    private IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.Default { get; }
    private IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.Default { get; }
    public XmlMetadata(DictionaryAdapterMeta meta, IEnumerable`1<string> reservedNamespaceUris);
    private static XmlMetadata();
    public sealed virtual Type get_ClrType();
    public Nullable`1<bool> get_Qualified();
    public Nullable`1<bool> get_IsNullable();
    public Nullable`1<bool> get_IsReference();
    public sealed virtual XmlName get_Name();
    public sealed virtual XmlName get_XsiType();
    private sealed virtual override XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.get_XsiType();
    public string get_ChildNamespaceUri();
    public IEnumerable`1<string> get_ReservedNamespaceUris();
    public XmlIncludedTypeSet get_IncludedTypes();
    public IXmlContext get_Context();
    public CompiledXPath get_Path();
    private sealed virtual override IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.get_Default();
    private sealed virtual override IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.get_Default();
    public bool IsReservedNamespaceUri(string namespaceUri);
    public IXmlCursor SelectBase(IXmlNode node);
    private bool IsMatch(IXmlIdentity xmlIdentity);
    private bool IsMatch(Type clrType);
    public sealed virtual bool TryGet(IXmlIdentity xmlIdentity, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public sealed virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
    private void AddPendingInclude(XmlIncludeAttribute attribute);
    private void ProcessPendingIncludes();
    public XmlName GetDefaultXsiType(Type clrType);
    public IEnumerable`1<IXmlIncludedType> GetIncludedTypes(Type baseType);
    private bool TryGetXmlMetadata(Type clrType, XmlMetadata& metadata);
    private XmlMetadata GetXmlMetadata(Type clrType);
    private string GetDefaultTypeLocalName(Type clrType);
    private static bool IsInterfaceName(string name);
    private static bool TryCast(object obj, T& result);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlMetadataBehavior : DictionaryBehaviorAttribute {
    public static XmlMetadataBehavior Default;
    private HashSet`1<string> reservedNamespaceUris;
    public IEnumerable`1<string> ReservedNamespaceUris { get; }
    private static XmlMetadataBehavior();
    public IEnumerable`1<string> get_ReservedNamespaceUris();
    public XmlMetadataBehavior AddReservedNamespaceUri(string uri);
    private sealed virtual override void Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.Initialize(IDictionaryAdapterFactory factory, DictionaryAdapterMeta meta);
    private sealed virtual override bool Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.ShouldHaveBehavior(object behavior);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlName : ValueType {
    public static XmlName Empty;
    private string localName;
    private string namespaceUri;
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public XmlName(string localName, string namespaceUri);
    private static XmlName();
    public string get_LocalName();
    public string get_NamespaceUri();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(XmlName other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(XmlName x, XmlName y);
    public static bool op_Inequality(XmlName x, XmlName y);
    public XmlName WithNamespaceUri(string namespaceUri);
    public virtual string ToString();
    public static XmlName ParseQName(string text);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlNameComparer : object {
    public static XmlNameComparer Default;
    public static XmlNameComparer IgnoreCase;
    private StringComparer comparer;
    private XmlNameComparer(StringComparer comparer);
    private static XmlNameComparer();
    public sealed virtual int GetHashCode(XmlName name);
    public sealed virtual bool Equals(XmlName x, XmlName y);
}
internal abstract class Castle.Components.DictionaryAdapter.Xml.XmlNodeAccessor : XmlAccessor {
    private string localName;
    private string namespaceUri;
    private XmlKnownTypeSet knownTypes;
    protected static StringComparer NameComparer;
    public XmlName Name { get; }
    private XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.XsiType { get; }
    protected IXmlKnownTypeMap KnownTypes { get; }
    private IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.Default { get; }
    protected XmlNodeAccessor(Type type, IXmlContext context);
    protected XmlNodeAccessor(string name, Type type, IXmlContext context);
    private static XmlNodeAccessor();
    public sealed virtual XmlName get_Name();
    private sealed virtual override XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIdentity.get_XsiType();
    protected IXmlKnownTypeMap get_KnownTypes();
    private sealed virtual override IXmlKnownType Castle.Components.DictionaryAdapter.Xml.IXmlKnownTypeMap.get_Default();
    public sealed virtual bool TryGet(IXmlIdentity xmlName, IXmlKnownType& knownType);
    public sealed virtual bool TryGet(Type clrType, IXmlKnownType& knownType);
    protected virtual bool IsMatch(IXmlIdentity xmlIdentity);
    private bool IsMatchOnNamespaceUri(IXmlIdentity xmlIdentity);
    private bool IsMatchOnXsiType(IXmlIdentity xmlIdentity);
    private bool ShouldIgnoreAttributeNamespaceUri(IXmlIdentity xmlName);
    protected virtual bool IsMatch(Type clrType);
    protected void ConfigureLocalName(string localName);
    protected void ConfigureNamespaceUri(string namespaceUri);
    private void ConfigureField(String& field, string value, States mask);
    protected void ConfigureKnownTypesFromParent(XmlNodeAccessor accessor);
    protected void ConfigureKnownTypesFromAttributes(IEnumerable`1<T> attributes, IXmlBehaviorSemantics`1<T> semantics);
    public virtual void Prepare();
    private void ConfigureDefaultAndIncludedTypes();
    private void ConfigureIncludedTypes(IXmlKnownType knownType);
    private void AddKnownType(XmlName name, XmlName xsiType, Type clrType, bool overwrite);
    private void AddSelfAsKnownType();
}
internal abstract class Castle.Components.DictionaryAdapter.Xml.XmlNodeBase : object {
    protected Type type;
    private IXmlNode parent;
    private IXmlNamespaceSource namespaces;
    public bool IsReal { get; }
    public Type ClrType { get; }
    public IXmlNode Parent { get; }
    public IXmlNamespaceSource Namespaces { get; }
    public CompiledXPath Path { get; }
    protected XmlNodeBase(IXmlNamespaceSource namespaces, IXmlNode parent);
    public virtual bool get_IsReal();
    public virtual Type get_ClrType();
    public sealed virtual IXmlNode get_Parent();
    public sealed virtual IXmlNamespaceSource get_Namespaces();
    public virtual CompiledXPath get_Path();
    private sealed virtual override IRealizable`1<T> Castle.Components.DictionaryAdapter.Xml.IRealizableSource.AsRealizable();
    protected virtual void Realize();
    private sealed virtual override void Castle.Components.DictionaryAdapter.IVirtual.Realize();
    public virtual void add_Realized(EventHandler value);
    public virtual void remove_Realized(EventHandler value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlNodeList`1 : ListProjection`1<T> {
    public IXmlNode Node { get; }
    public XmlNodeList`1(IXmlNode parentNode, IDictionaryAdapter parentObject, IXmlCollectionAccessor accessor);
    public sealed virtual IXmlNode get_Node();
}
internal static class Castle.Components.DictionaryAdapter.Xml.Xmlns : object {
    public static string Prefix;
    public static string NamespaceUri;
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlPositionComparer : object {
    public static XmlPositionComparer Instance;
    private static XmlPositionComparer();
    public bool Equals(IXmlNode nodeA, IXmlNode nodeB);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlReferenceManager : object {
    private Dictionary`2<int, Entry> entriesById;
    private WeakKeyDictionary`2<object, Entry> entriesByValue;
    private IXmlReferenceFormat format;
    private int nextId;
    private static Type StringType;
    private static object CreateEntryToken;
    public XmlReferenceManager(IXmlNode root, IXmlReferenceFormat format);
    private static XmlReferenceManager();
    private void Populate(IXmlNode node);
    private void PopulateFromNode(IXmlIterator node, ICollection`1<Reference> references);
    private void PopulateIdentity(int id, IXmlNode node);
    private void PopulateReference(int id, IXmlNode node, ICollection`1<Reference> references);
    private void PopulateDeferredReferences(ICollection`1<Reference> references);
    public bool TryGet(object keyObject, Object& inGraphObject);
    public void Add(IXmlNode node, object keyValue, object newValue, bool isInGraph);
    public bool OnGetStarting(IXmlNode& node, Object& value, Object& token);
    public void OnGetCompleted(IXmlNode node, object value, object token);
    public bool OnAssigningNull(IXmlNode node, object oldValue);
    public bool OnAssigningValue(IXmlNode node, object oldValue, Object& newValue, Object& token);
    private bool ShouldAssignmentProceed(Entry oldEntry, Entry newEntry, object token);
    private Entry OnReplacingValue(IXmlNode node, object oldValue);
    public void OnAssignedValue(IXmlNode node, object givenValue, object storedValue, object token);
    private void AddReference(IXmlNode node, Entry entry);
    private void GenerateId(Entry entry);
    private void AddValue(Entry entry, Type type, object value, XmlAdapter xmlAdapter);
    private void AddValueCore(Entry entry, Type type, object value, bool isInGraph);
    private void ClearReference(Entry entry, IXmlNode node);
    private void PrepareForReuse(Entry entry);
    private bool TryGetEntry(IXmlNode node, Entry& entry, Boolean& reference);
    private bool TryGetCompatibleValue(Entry entry, Type type, Object& value);
    private static void SetNotInGraph(Entry entry, object value);
    private static bool ShouldExclude(Type type);
    private static void SetNotInGraphCore(Entry entry, object value);
    private static IXmlNode RedirectNode(IXmlNode& node, Entry entry);
    public void UnionWith(XmlReferenceManager other);
    private static Exception IdNotFoundError(int id);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSelfAccessor : XmlAccessor {
    internal static XmlAccessorFactory`1<XmlSelfAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XmlSelfAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    public XmlSelfAccessor(Type clrType, IXmlContext context);
    private static XmlSelfAccessor();
    public virtual void ConfigureNillable(bool nillable);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode parentNode, bool mutable);
    [CompilerGeneratedAttribute]
private static XmlSelfAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSelfCursor : object {
    private IXmlNode node;
    private Type clrType;
    private int position;
    public CursorFlags Flags { get; }
    public CompiledXPath Path { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public Type ClrType { get; }
    public bool IsReal { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public IXmlNode Parent { get; }
    public IXmlNamespaceSource Namespaces { get; }
    public object UnderlyingObject { get; }
    public XmlSelfCursor(IXmlNode node, Type clrType);
    public CursorFlags get_Flags();
    public sealed virtual CompiledXPath get_Path();
    public sealed virtual XmlName get_Name();
    public sealed virtual XmlName get_XsiType();
    public sealed virtual Type get_ClrType();
    public sealed virtual bool get_IsReal();
    public sealed virtual bool get_IsElement();
    public sealed virtual bool get_IsAttribute();
    public sealed virtual bool get_IsNil();
    public sealed virtual void set_IsNil(bool value);
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    public sealed virtual string get_Xml();
    public sealed virtual IXmlNode get_Parent();
    public sealed virtual IXmlNamespaceSource get_Namespaces();
    public sealed virtual object get_UnderlyingObject();
    public sealed virtual bool UnderlyingPositionEquals(IXmlNode node);
    public sealed virtual IRealizable`1<T> AsRealizable();
    public sealed virtual void Realize();
    public sealed virtual void add_Realized(EventHandler value);
    public sealed virtual void remove_Realized(EventHandler value);
    public sealed virtual string GetAttribute(XmlName name);
    public sealed virtual void SetAttribute(XmlName name, string value);
    public sealed virtual string LookupPrefix(string namespaceUri);
    public sealed virtual string LookupNamespaceUri(string prefix);
    public sealed virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    public sealed virtual bool MoveNext();
    public sealed virtual void MoveToEnd();
    public sealed virtual void Reset();
    public sealed virtual void MoveTo(IXmlNode position);
    public sealed virtual IXmlNode Save();
    public sealed virtual IXmlCursor SelectSelf(Type clrType);
    public sealed virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual IXmlIterator SelectSubtree();
    public sealed virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual object Evaluate(CompiledXPath path);
    public sealed virtual XmlReader ReadSubtree();
    public sealed virtual XmlWriter WriteAttributes();
    public sealed virtual XmlWriter WriteChildren();
    public void MakeNext(Type type);
    public sealed virtual void Create(Type type);
    public sealed virtual void Coerce(Type type);
    public sealed virtual void Clear();
    public sealed virtual void Remove();
    public sealed virtual void RemoveAllNext();
}
internal static class Castle.Components.DictionaryAdapter.Xml.XmlSimpleSerializer : object {
    public static XmlTypeSerializer ForBoolean;
    public static XmlTypeSerializer ForChar;
    public static XmlTypeSerializer ForSByte;
    public static XmlTypeSerializer ForInt16;
    public static XmlTypeSerializer ForInt32;
    public static XmlTypeSerializer ForInt64;
    public static XmlTypeSerializer ForByte;
    public static XmlTypeSerializer ForUInt16;
    public static XmlTypeSerializer ForUInt32;
    public static XmlTypeSerializer ForUInt64;
    public static XmlTypeSerializer ForSingle;
    public static XmlTypeSerializer ForDouble;
    public static XmlTypeSerializer ForDecimal;
    public static XmlTypeSerializer ForTimeSpan;
    public static XmlTypeSerializer ForDateTime;
    public static XmlTypeSerializer ForDateTimeOffset;
    public static XmlTypeSerializer ForGuid;
    public static XmlTypeSerializer ForByteArray;
    public static XmlTypeSerializer ForUri;
    [CompilerGeneratedAttribute]
private static Func`2<Uri, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<string, Uri> CS$<>9__CachedAnonymousMethodDelegate3;
    private static XmlSimpleSerializer();
    private static string XmlConvert_ToString(DateTime value);
    private static DateTime XmlConvert_ToDateTime(string value);
    [CompilerGeneratedAttribute]
private static string <.cctor>b__0(Uri u);
    [CompilerGeneratedAttribute]
private static Uri <.cctor>b__1(string s);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSimpleSerializer`1 : XmlTypeSerializer {
    private Func`2<T, string> getString;
    private Func`2<string, T> getObject;
    public XmlTypeKind Kind { get; }
    public XmlSimpleSerializer`1(Func`2<T, string> getString, Func`2<string, T> getObject);
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlStringSerializer : XmlTypeSerializer {
    public static XmlStringSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlStringSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSubtreeReader : XmlReader {
    private static ulong HasValueMask;
    private string rootLocalName;
    private string rootNamespaceURI;
    private string underlyingNamespaceURI;
    private XmlReader reader;
    public bool IsDisposed { get; }
    protected XmlReader Reader { get; }
    public ReadState ReadState { get; }
    public int Depth { get; }
    public XmlNodeType NodeType { get; }
    public bool IsAtRootElement { get; }
    public bool EOF { get; }
    public string Prefix { get; }
    public string LocalName { get; }
    public string NamespaceURI { get; }
    public bool HasValue { get; }
    public string Value { get; }
    public bool IsEmptyElement { get; }
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlSubtreeReader(IXmlNode node, XmlRootAttribute root);
    public XmlSubtreeReader(IXmlNode node, string rootLocalName, string rootNamespaceUri);
    protected virtual void Dispose(bool managed);
    private void DisposeReader();
    public bool get_IsDisposed();
    private void RequireNotDisposed();
    protected XmlReader get_Reader();
    public virtual ReadState get_ReadState();
    public virtual int get_Depth();
    public virtual XmlNodeType get_NodeType();
    public bool get_IsAtRootElement();
    public virtual bool get_EOF();
    public virtual string get_Prefix();
    public virtual string get_LocalName();
    public virtual string get_NamespaceURI();
    private string CaptureNamespaceUri();
    private string TranslateNamespaceURI();
    public virtual bool get_HasValue();
    public virtual string get_Value();
    public virtual bool get_IsEmptyElement();
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual XmlNameTable get_NameTable();
    public virtual bool Read();
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual bool ReadAttributeValue();
    public virtual string GetAttribute(int i);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string LookupNamespace(string prefix);
    public virtual void ResolveEntity();
    public virtual void Close();
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlSubtreeWriter : XmlWriter {
    private IXmlNode node;
    private XmlWriter rootWriter;
    private XmlWriter childWriter;
    private WriteState state;
    private int depth;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate2e;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate30;
    [CompilerGeneratedAttribute]
private static Action`1<XmlWriter> CS$<>9__CachedAnonymousMethodDelegate32;
    private XmlWriter RootWriter { get; }
    private XmlWriter ChildWriter { get; }
    private bool IsInRootAttribute { get; }
    private bool IsInRoot { get; }
    private bool IsInChild { get; }
    public WriteState WriteState { get; }
    public XmlSubtreeWriter(IXmlNode node);
    protected virtual void Dispose(bool managed);
    private void DisposeWriter(XmlWriter& writer);
    private XmlWriter get_RootWriter();
    private XmlWriter get_ChildWriter();
    private bool get_IsInRootAttribute();
    private bool get_IsInRoot();
    private bool get_IsInChild();
    public virtual WriteState get_WriteState();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartDocument();
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    private void WriteEndElement(Action`1<XmlWriter> action);
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    private void WriteAttribute(Action`1<XmlWriter> action, WriteState entryState, WriteState exitState);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteEndAttribute();
    private void WriteElementOrAttributeContent(Action`1<XmlWriter> action);
    public virtual void WriteString(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteEntityRef(string name);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    private void WriteElementContent(Action`1<XmlWriter> action);
    public virtual void WriteCData(string text);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void WithWriters(Action`1<XmlWriter> action, bool worksIfClosed, Nullable`1<WriteState> resetTo);
    public virtual void Flush();
    public virtual void WriteEndDocument();
    public virtual void Close();
    public virtual string LookupPrefix(string ns);
    private void RequireNotClosed();
    private void RequireState(WriteState state);
    private void RequireState(WriteState state1, WriteState state2);
    private void Reset(WriteState state);
    [CompilerGeneratedAttribute]
private static void <WriteEndElement>b__0(XmlWriter w);
    [CompilerGeneratedAttribute]
private static void <WriteFullEndElement>b__2(XmlWriter w);
    [CompilerGeneratedAttribute]
private static void <WriteEndAttribute>b__7(XmlWriter w);
    [CompilerGeneratedAttribute]
private static void <Flush>b__2d(XmlWriter w);
    [CompilerGeneratedAttribute]
private static void <WriteEndDocument>b__2f(XmlWriter w);
    [CompilerGeneratedAttribute]
private static void <Close>b__31(XmlWriter w);
}
internal enum Castle.Components.DictionaryAdapter.Xml.XmlTypeKind : Enum {
    public int value__;
    public static XmlTypeKind Simple;
    public static XmlTypeKind Complex;
    public static XmlTypeKind Collection;
}
internal abstract class Castle.Components.DictionaryAdapter.Xml.XmlTypeSerializer : object {
    public XmlTypeKind Kind { get; }
    public bool CanGetStub { get; }
    public abstract virtual XmlTypeKind get_Kind();
    public virtual bool get_CanGetStub();
    public virtual object GetStub(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public abstract virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public abstract virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
    public static XmlTypeSerializer For(Type type);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlTypeSerializerCache : SingletonDispenser`2<Type, XmlTypeSerializer> {
    public static XmlTypeSerializerCache Instance;
    private static XmlTypeSerializerCache();
    private static XmlTypeSerializer CreateSerializer(Type type);
}
internal class Castle.Components.DictionaryAdapter.Xml.XmlXmlNodeSerializer : XmlTypeSerializer {
    public static XmlXmlNodeSerializer Instance;
    public XmlTypeKind Kind { get; }
    private static XmlXmlNodeSerializer();
    public virtual XmlTypeKind get_Kind();
    public virtual object GetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor);
    public virtual void SetValue(IXmlNode node, IDictionaryAdapter parent, IXmlAccessor accessor, object oldValue, Object& value);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.Xml.XPathAttribute : Attribute {
    private CompiledXPath getPath;
    private CompiledXPath setPath;
    [CompilerGeneratedAttribute]
private bool <Nullable>k__BackingField;
    public CompiledXPath GetPath { get; }
    public CompiledXPath SetPath { get; }
    public bool Nullable { get; public set; }
    public XPathAttribute(string path);
    public XPathAttribute(string get, string set);
    public CompiledXPath get_GetPath();
    public CompiledXPath get_SetPath();
    [CompilerGeneratedAttribute]
public bool get_Nullable();
    [CompilerGeneratedAttribute]
public void set_Nullable(bool value);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathBehaviorAccessor : XmlAccessor {
    private CompiledXPath path;
    private XmlIncludedTypeSet includedTypes;
    private XmlAccessor defaultAccessor;
    private XmlAccessor itemAccessor;
    internal static XmlAccessorFactory`1<XPathBehaviorAccessor> Factory;
    [CompilerGeneratedAttribute]
private static XmlAccessorFactory`1<XPathBehaviorAccessor> CS$<>9__CachedAnonymousMethodDelegate1;
    private XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIncludedType.XsiType { get; }
    private IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.Default { get; }
    private bool SelectsNodes { get; }
    private bool CreatesAttributes { get; }
    protected XPathBehaviorAccessor(Type type, IXmlContext context);
    private static XPathBehaviorAccessor();
    private sealed virtual override XmlName Castle.Components.DictionaryAdapter.Xml.IXmlIncludedType.get_XsiType();
    private sealed virtual override IXmlIncludedType Castle.Components.DictionaryAdapter.Xml.IXmlIncludedTypeMap.get_Default();
    private bool get_SelectsNodes();
    private bool get_CreatesAttributes();
    public sealed virtual void Configure(XPathAttribute attribute);
    public sealed virtual void Configure(XPathVariableAttribute attribute);
    public sealed virtual void Configure(XPathFunctionAttribute attribute);
    public virtual void Prepare();
    public virtual bool IsPropertyDefined(IXmlNode parentNode);
    public virtual object GetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    private object GetPropertyValueCore(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    private object GetDefaultPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, bool orStub);
    private object Evaluate(IXmlNode node);
    public virtual void SetPropertyValue(IXmlNode parentNode, IDictionaryAdapter parentObject, XmlReferenceManager references, object oldValue, Object& value);
    public virtual IXmlCollectionAccessor GetCollectionAccessor(Type itemType);
    public virtual IXmlCursor SelectPropertyNode(IXmlNode node, bool create);
    public virtual IXmlCursor SelectCollectionNode(IXmlNode node, bool create);
    public virtual IXmlCursor SelectCollectionItems(IXmlNode node, bool create);
    public sealed virtual bool TryGet(XmlName xsiType, IXmlIncludedType& includedType);
    public sealed virtual bool TryGet(Type clrType, IXmlIncludedType& includedType);
    [CompilerGeneratedAttribute]
private static XPathBehaviorAccessor <.cctor>b__0(string name, Type type, IXmlContext context);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathBufferedNodeIterator : XPathNodeIterator {
    private IList`1<XPathNavigator> items;
    private int index;
    public int CurrentPosition { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public XPathNavigator Current { get; }
    public XPathBufferedNodeIterator(XPathNodeIterator iterator);
    private XPathBufferedNodeIterator(XPathBufferedNodeIterator iterator);
    public virtual int get_CurrentPosition();
    public virtual int get_Count();
    public bool get_IsEmpty();
    public virtual XPathNavigator get_Current();
    public void Reset();
    public virtual bool MoveNext();
    public void MoveToEnd();
    public virtual XPathNodeIterator Clone();
}
internal static class Castle.Components.DictionaryAdapter.Xml.XPathCompiler : object {
    private static Func`1<CompiledXPathNode> NodeFactory;
    private static Func`1<CompiledXPathStep> StepFactory;
    [CompilerGeneratedAttribute]
private static Func`1<CompiledXPathNode> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`1<CompiledXPathStep> CS$<>9__CachedAnonymousMethodDelegate3;
    private static XPathCompiler();
    public static CompiledXPath Compile(string path);
    private static bool ParsePath(Tokenizer source, CompiledXPath path);
    private static bool ParseStep(Tokenizer source, CompiledXPath path, CompiledXPathStep& step);
    private static bool ParseNodeCore(Tokenizer source, Func`1<TNode> factory, TNode& node);
    private static bool ParsePredicateList(Tokenizer source, CompiledXPathNode parent);
    private static bool ParsePredicate(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseAndExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseLeftToRightExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseRightToLeftExpression(Tokenizer source, CompiledXPathNode parent);
    private static bool ParseNestedPath(Tokenizer source, CompiledXPathNode parent, CompiledXPathNode& node);
    private static bool ParseNode(Tokenizer source, CompiledXPathNode parent, CompiledXPathNode& node);
    private static bool ParseValue(Tokenizer source, XPathExpression& value);
    private static bool ParseQualifiedName(Tokenizer source, CompiledXPathNode node);
    private static bool ParseName(Tokenizer source, String& name);
    private static bool Consume(Tokenizer source, Token token);
    private static void LinkNodes(CompiledXPathNode previous, CompiledXPathNode next);
    [CompilerGeneratedAttribute]
private static CompiledXPathNode <.cctor>b__0();
    [CompilerGeneratedAttribute]
private static CompiledXPathStep <.cctor>b__1();
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathContext : XsltContext {
    private XsltContext context;
    public string DefaultNamespace { get; }
    public bool Whitespace { get; }
    public XPathContext(XsltContext xpathContext);
    public virtual string get_DefaultNamespace();
    public virtual string LookupNamespace(string prefix);
    public virtual bool get_Whitespace();
    public virtual bool PreserveWhitespace(XPathNavigator node);
    public virtual int CompareDocument(string baseUri, string nextbaseUri);
    public virtual IXsltContextFunction ResolveFunction(string prefix, string name, XPathResultType[] argTypes);
    public virtual IXsltContextVariable ResolveVariable(string prefix, string name);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XPathExtensions : object {
    [ExtensionAttribute]
public static XPathNavigator CreateNavigatorSafe(IXPathNavigable source);
    [ExtensionAttribute]
public static bool MoveToLastChild(XPathNavigator navigator);
    [ExtensionAttribute]
public static bool MoveToLastAttribute(XPathNavigator navigator);
    [ExtensionAttribute]
public static XPathNavigator GetRootElement(XPathNavigator navigator);
    [ExtensionAttribute]
public static XPathNavigator GetParent(XPathNavigator navigator);
    [ExtensionAttribute]
public static void DeleteChildren(XPathNavigator node);
}
[AttributeUsageAttribute("1152")]
internal abstract class Castle.Components.DictionaryAdapter.Xml.XPathFunctionAttribute : Attribute {
    public static XPathResultType[] NoArgs;
    public XmlName Name { get; }
    public XPathResultType ReturnType { get; }
    public XPathResultType[] ArgTypes { get; }
    public int Maxargs { get; }
    public int Minargs { get; }
    private static XPathFunctionAttribute();
    public abstract virtual XmlName get_Name();
    public abstract virtual XPathResultType get_ReturnType();
    public virtual XPathResultType[] get_ArgTypes();
    public virtual int get_Maxargs();
    public virtual int get_Minargs();
    public abstract virtual object Invoke(XsltContext context, Object[] args, XPathNavigator node);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathMutableCursor : XPathNode {
    private XPathBufferedNodeIterator iterator;
    private CompiledXPathStep step;
    private int depth;
    private IXmlIncludedTypeMap knownTypes;
    private CursorFlags flags;
    private EventHandler Realized;
    public bool IsReal { get; }
    public bool HasCurrent { get; }
    public bool HasPartialOrCurrent { get; }
    public Type ClrType { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    public XPathMutableCursor(IXmlNode parent, CompiledXPath path, IXmlIncludedTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public virtual bool get_IsReal();
    public bool get_HasCurrent();
    public bool get_HasPartialOrCurrent();
    public virtual Type get_ClrType();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public virtual object Evaluate(CompiledXPath path);
    public sealed virtual bool MoveNext();
    private bool SeekCurrent();
    private bool Consume(XPathNodeIterator iterator, bool multiple);
    private bool SetAtEnd();
    public sealed virtual void Reset();
    public sealed virtual void MoveToEnd();
    private void ResetCurrent();
    private void ResetDepth();
    private int Descend();
    public sealed virtual void MoveTo(IXmlNode position);
    public virtual void add_Realized(EventHandler value);
    public virtual void remove_Realized(EventHandler value);
    protected virtual void OnRealized();
    protected virtual void Realize();
    public void MakeNext(Type clrType);
    public sealed virtual void Coerce(Type clrType);
    public sealed virtual void Create(Type type);
    private void Insert();
    private void Append();
    private void Complete();
    private XmlWriter CreateWriterForAppend();
    private void WriteNode(CompiledXPathNode node, XmlWriter writer);
    private void WriteAttribute(CompiledXPathNode node, XmlWriter writer);
    private void WriteSimpleElement(CompiledXPathNode node, XmlWriter writer);
    private void WriteComplexElement(CompiledXPathNode node, XmlWriter writer);
    private void WriteSubnodes(CompiledXPathNode parent, XmlWriter writer, bool attributes);
    private void WriteValue(CompiledXPathNode node, XmlWriter writer);
    private void SeekCurrentAfterCreate(bool moved);
    public sealed virtual void RemoveAllNext();
    public sealed virtual void Remove();
    public virtual IXmlNode Save();
    private void RequireRemovable();
    private void RequireMoved(bool result);
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathNode : XmlNodeBase {
    protected XPathNavigator node;
    protected CompiledXPath xpath;
    public object UnderlyingObject { get; }
    private XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.Value { get; }
    private XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.Value { get; }
    public CompiledXPath Path { get; }
    public XmlName Name { get; }
    public XmlName XsiType { get; }
    public bool IsElement { get; }
    public bool IsAttribute { get; }
    public bool IsNil { get; public set; }
    public string Value { get; public set; }
    public string Xml { get; }
    protected XPathNode(CompiledXPath path, IXmlNamespaceSource namespaces, IXmlNode parent);
    public XPathNode(XPathNavigator node, Type type, IXmlNamespaceSource namespaces);
    public sealed virtual object get_UnderlyingObject();
    private sealed virtual override XPathNavigator Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XPath.XPathNavigator>.get_Value();
    private sealed virtual override XmlNode Castle.Components.DictionaryAdapter.Xml.IRealizable<System.Xml.XmlNode>.get_Value();
    public virtual CompiledXPath get_Path();
    public virtual XmlName get_Name();
    public virtual XmlName get_XsiType();
    public virtual bool get_IsElement();
    public virtual bool get_IsAttribute();
    public virtual bool get_IsNil();
    public virtual void set_IsNil(bool value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_Xml();
    public sealed virtual string GetAttribute(XmlName name);
    public sealed virtual void SetAttribute(XmlName name, string value);
    private void SetAttributeCore(XmlName name, string value);
    private void ClearAttribute(XmlName name);
    public sealed virtual string LookupPrefix(string namespaceUri);
    public sealed virtual string LookupNamespaceUri(string prefix);
    public sealed virtual void DefineNamespace(string prefix, string namespaceUri, bool root);
    public sealed virtual bool UnderlyingPositionEquals(IXmlNode node);
    public virtual IXmlNode Save();
    public sealed virtual IXmlCursor SelectSelf(Type clrType);
    public sealed virtual IXmlCursor SelectChildren(IXmlKnownTypeMap knownTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual IXmlIterator SelectSubtree();
    public sealed virtual IXmlCursor Select(CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public virtual object Evaluate(CompiledXPath path);
    public virtual XmlReader ReadSubtree();
    public virtual XmlWriter WriteAttributes();
    public virtual XmlWriter WriteChildren();
    public virtual void Clear();
}
internal class Castle.Components.DictionaryAdapter.Xml.XPathReadOnlyCursor : XPathNode {
    private XPathNodeIterator iterator;
    private IXmlIncludedTypeMap includedTypes;
    private CursorFlags flags;
    public XPathReadOnlyCursor(IXmlNode parent, CompiledXPath path, IXmlIncludedTypeMap includedTypes, IXmlNamespaceSource namespaces, CursorFlags flags);
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    private bool SetAtEnd();
    private bool SetAtNext();
    public sealed virtual void MoveTo(IXmlNode position);
    public sealed virtual void MoveToEnd();
    public void MakeNext(Type type);
    public sealed virtual void Create(Type type);
    public sealed virtual void Coerce(Type type);
    public sealed virtual void Remove();
    public sealed virtual void RemoveAllNext();
    public virtual IXmlNode Save();
}
[AttributeUsageAttribute("1152")]
internal abstract class Castle.Components.DictionaryAdapter.Xml.XPathVariableAttribute : Attribute {
    public XmlName Name { get; }
    public XPathResultType VariableType { get; }
    private bool System.Xml.Xsl.IXsltContextVariable.IsLocal { get; }
    private bool System.Xml.Xsl.IXsltContextVariable.IsParam { get; }
    public abstract virtual XmlName get_Name();
    public abstract virtual XPathResultType get_VariableType();
    private sealed virtual override bool System.Xml.Xsl.IXsltContextVariable.get_IsLocal();
    private sealed virtual override bool System.Xml.Xsl.IXsltContextVariable.get_IsParam();
    public abstract virtual object Evaluate(XsltContext context);
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.XRef : object {
    public static string Prefix;
    public static string NamespaceUri;
    public static XmlName Id;
    public static XmlName Ref;
    internal static XmlNamespaceAttribute Namespace;
    private static XRef();
    [ExtensionAttribute]
public static string GetId(IXmlNode node);
    [ExtensionAttribute]
public static void SetId(IXmlCursor node, string id);
    [ExtensionAttribute]
public static string GetReference(IXmlNode node);
    [ExtensionAttribute]
public static void SetReference(IXmlCursor cursor, string id);
}
internal static class Castle.Components.DictionaryAdapter.Xml.Xsd : object {
    public static string Prefix;
    public static string NamespaceUri;
    internal static XmlNamespaceAttribute Namespace;
    private static Xsd();
}
[ExtensionAttribute]
internal static class Castle.Components.DictionaryAdapter.Xml.Xsi : object {
    public static string Prefix;
    public static string NamespaceUri;
    public static string NilValue;
    public static XmlName Type;
    public static XmlName Nil;
    internal static XmlNamespaceAttribute Namespace;
    private static Xsi();
    [ExtensionAttribute]
public static XmlName GetXsiType(IXmlNode node);
    [ExtensionAttribute]
public static void SetXsiType(IXmlNode node, XmlName xsiType);
    [ExtensionAttribute]
public static bool IsXsiNil(IXmlNode node);
    [ExtensionAttribute]
public static void SetXsiNil(IXmlNode node, bool nil);
}
[AttributeUsageAttribute("1024")]
internal class Castle.Components.DictionaryAdapter.XmlDefaultsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Qualified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullable>k__BackingField;
    public bool Qualified { get; public set; }
    public bool IsNullable { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Qualified();
    [CompilerGeneratedAttribute]
public void set_Qualified(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNullable();
    [CompilerGeneratedAttribute]
public void set_IsNullable(bool value);
}
[AttributeUsageAttribute("1152")]
internal class Castle.Components.DictionaryAdapter.XmlNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public bool Root { get; public set; }
    public bool Default { get; public set; }
    public string NamespaceUri { get; private set; }
    public string Prefix { get; private set; }
    public XmlNamespaceAttribute(string namespaceUri, string prefix);
    [CompilerGeneratedAttribute]
public bool get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(bool value);
    [CompilerGeneratedAttribute]
public bool get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(bool value);
    [CompilerGeneratedAttribute]
public string get_NamespaceUri();
    [CompilerGeneratedAttribute]
private void set_NamespaceUri(string value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
private void set_Prefix(string value);
}
internal abstract class Castle.Core.Configuration.AbstractConfiguration : object {
    private ConfigurationAttributeCollection attributes;
    private ConfigurationCollection children;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public ConfigurationAttributeCollection Attributes { get; }
    public ConfigurationCollection Children { get; }
    public string Name { get; protected set; }
    public string Value { get; protected set; }
    public virtual ConfigurationAttributeCollection get_Attributes();
    public virtual ConfigurationCollection get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
protected void set_Value(string value);
    public virtual object GetValue(Type type, object defaultValue);
}
internal class Castle.Core.Configuration.ConfigurationAttributeCollection : NameValueCollection {
    protected ConfigurationAttributeCollection(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Core.Configuration.ConfigurationCollection : List`1<IConfiguration> {
    public IConfiguration Item { get; }
    public ConfigurationCollection(IEnumerable`1<IConfiguration> value);
    public IConfiguration get_Item(string name);
}
internal interface Castle.Core.Configuration.IConfiguration {
    public string Name { get; }
    public string Value { get; }
    public ConfigurationCollection Children { get; }
    public ConfigurationAttributeCollection Attributes { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Value();
    public abstract virtual ConfigurationCollection get_Children();
    public abstract virtual ConfigurationAttributeCollection get_Attributes();
    public abstract virtual object GetValue(Type type, object defaultValue);
}
internal class Castle.Core.Configuration.MutableConfiguration : AbstractConfiguration {
    public string Value { get; public set; }
    public MutableConfiguration(string name);
    public MutableConfiguration(string name, string value);
    public string get_Value();
    public void set_Value(string value);
    public static MutableConfiguration Create(string name);
    public MutableConfiguration Attribute(string name, string value);
    public MutableConfiguration CreateChild(string name);
    public MutableConfiguration CreateChild(string name, string value);
}
internal class Castle.Core.Configuration.Xml.XmlConfigurationDeserializer : object {
    public IConfiguration Deserialize(XmlNode node);
    public static string GetConfigValue(string value);
    public static IConfiguration GetDeserializedNode(XmlNode node);
    public static bool IsTextNode(XmlNode node);
}
[ExtensionAttribute]
internal static class Castle.Core.Internal.AttributesUtil : object {
    private static AttributeUsageAttribute DefaultAttributeUsage;
    private static AttributesUtil();
    [ExtensionAttribute]
public static T GetAttribute(ICustomAttributeProvider member);
    [ExtensionAttribute]
public static T[] GetAttributes(ICustomAttributeProvider member);
    [ExtensionAttribute]
public static T GetTypeAttribute(Type type);
    public static T[] GetTypeAttributes(Type type);
    public static Object[] GetInterfaceAttributes(Type type);
    [ExtensionAttribute]
public static AttributeUsageAttribute GetAttributeUsage(Type attributeType);
    public static Type GetTypeConverter(MemberInfo member);
    [ExtensionAttribute]
public static bool HasAttribute(ICustomAttributeProvider member);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
internal static class Castle.Core.Internal.CollectionExtensions : object {
    [ExtensionAttribute]
public static TResult[] ConvertAll(T[] items, Converter`2<T, TResult> transformation);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> items, Action`1<T> action);
    [ExtensionAttribute]
public static T Find(T[] items, Predicate`1<T> predicate);
    [ExtensionAttribute]
public static T[] FindAll(T[] items, Predicate`1<T> predicate);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(IEnumerable this);
}
internal interface Castle.Core.Internal.ILockHolder {
    public bool LockAcquired { get; }
    public abstract virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.InterfaceAttributeUtil : object {
    private Aged`1[] types;
    private Dictionary`2<Type, Aged`1<object>> singletons;
    private List`1<object> results;
    private int index;
    private static object ConflictMarker;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<Type, int>, Aged`1<Type>> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<Aged`1<Type>, int> CS$<>9__CachedAnonymousMethodDelegate3;
    private Type CurrentType { get; }
    private int CurrentAge { get; }
    private bool IsMostDerivedType { get; }
    private InterfaceAttributeUtil(Type derivedType, Type[] baseTypes);
    private static InterfaceAttributeUtil();
    private Type get_CurrentType();
    private int get_CurrentAge();
    private bool get_IsMostDerivedType();
    public static Object[] GetAttributes(Type type, bool inherit);
    private Aged`1[] CollectTypes(Type derivedType, Type[] baseTypes);
    private Object[] GetAttributes(Object[] attributes);
    private void ProcessType(Object[] attributes);
    private void AddSingleton(object attribute, Type attributeType);
    private void CollectSingletons();
    private void HandleAttributeConflict(Type attributeType);
    private static bool ShouldConsiderType(Type type);
    private Aged`1<T> MakeAged(T value);
    [CompilerGeneratedAttribute]
private static Aged`1<Type> <CollectTypes>b__0(KeyValuePair`2<Type, int> a);
    [CompilerGeneratedAttribute]
private static int <CollectTypes>b__1(Aged`1<Type> t);
}
internal class Castle.Core.Internal.InternalsVisible : object {
    public static string ToCastleCore;
    public static string ToDynamicProxyGenAssembly2;
}
internal interface Castle.Core.Internal.IUpgradeableLockHolder {
    public abstract virtual ILockHolder Upgrade();
    public abstract virtual ILockHolder Upgrade(bool waitForLock);
}
internal abstract class Castle.Core.Internal.Lock : object {
    public abstract virtual IUpgradeableLockHolder ForReadingUpgradeable();
    public abstract virtual ILockHolder ForReading();
    public abstract virtual ILockHolder ForWriting();
    public abstract virtual IUpgradeableLockHolder ForReadingUpgradeable(bool waitForLock);
    public abstract virtual ILockHolder ForReading(bool waitForLock);
    public abstract virtual ILockHolder ForWriting(bool waitForLock);
    public static Lock Create();
}
internal class Castle.Core.Internal.MonitorLockHolder : object {
    private object locker;
    private bool lockAcquired;
    public bool LockAcquired { get; }
    public MonitorLockHolder(object locker, bool waitForLock);
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.MonitorUpgradeableLockHolder : object {
    private object locker;
    private bool lockAcquired;
    public bool LockAcquired { get; }
    public MonitorUpgradeableLockHolder(object locker, bool waitForLock);
    public sealed virtual void Dispose();
    public sealed virtual ILockHolder Upgrade();
    public sealed virtual ILockHolder Upgrade(bool waitForLock);
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.NoOpLock : object {
    public static ILockHolder Lock;
    public bool LockAcquired { get; }
    private static NoOpLock();
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.NoOpUpgradeableLock : object {
    public static IUpgradeableLockHolder Lock;
    public bool LockAcquired { get; }
    private static NoOpUpgradeableLock();
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
    public sealed virtual ILockHolder Upgrade();
    public sealed virtual ILockHolder Upgrade(bool waitForLock);
}
[ExtensionAttribute]
internal static class Castle.Core.Internal.PermissionUtil : object {
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static bool IsGranted(IPermission permission);
}
internal class Castle.Core.Internal.SlimReadLockHolder : object {
    private ReaderWriterLockSlim locker;
    private bool lockAcquired;
    public bool LockAcquired { get; }
    public SlimReadLockHolder(ReaderWriterLockSlim locker, bool waitForLock);
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.SlimReadWriteLock : Lock {
    private ReaderWriterLockSlim locker;
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public virtual IUpgradeableLockHolder ForReadingUpgradeable();
    public virtual ILockHolder ForReading();
    public virtual ILockHolder ForWriting();
    public virtual IUpgradeableLockHolder ForReadingUpgradeable(bool waitForLock);
    public virtual ILockHolder ForReading(bool waitForLock);
    public virtual ILockHolder ForWriting(bool waitForLock);
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
}
internal class Castle.Core.Internal.SlimUpgradeableReadLockHolder : object {
    private ReaderWriterLockSlim locker;
    private bool lockAcquired;
    private SlimWriteLockHolder writerLock;
    private bool wasLockAlreadyHeld;
    public bool LockAcquired { get; }
    public SlimUpgradeableReadLockHolder(ReaderWriterLockSlim locker, bool waitForLock, bool wasLockAlreadyHelf);
    public sealed virtual void Dispose();
    public sealed virtual ILockHolder Upgrade();
    public sealed virtual ILockHolder Upgrade(bool waitForLock);
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.SlimWriteLockHolder : object {
    private ReaderWriterLockSlim locker;
    private bool lockAcquired;
    public bool LockAcquired { get; }
    public SlimWriteLockHolder(ReaderWriterLockSlim locker, bool waitForLock);
    public sealed virtual void Dispose();
    public sealed virtual bool get_LockAcquired();
}
internal class Castle.Core.Internal.WeakKey : WeakReference {
    private int hashCode;
    public object Target { get; public set; }
    public WeakKey(object target, int hashCode);
    public virtual object get_Target();
    public virtual void set_Target(object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
internal class Castle.Core.Internal.WeakKeyComparer`1 : object {
    public static WeakKeyComparer`1<TKey> Default;
    private IEqualityComparer`1<TKey> comparer;
    public WeakKeyComparer`1(IEqualityComparer`1<TKey> comparer);
    private static WeakKeyComparer`1();
    public object Wrap(TKey key);
    public TKey Unwrap(object obj);
    public sealed virtual int GetHashCode(object obj);
    public sealed virtual bool Equals(object objA, object objB);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Core.Internal.WeakKeyDictionary`2 : object {
    private static int AgeThreshold;
    private Dictionary`2<object, TValue> dictionary;
    private WeakKeyComparer`1<TKey> comparer;
    private KeyCollection<TKey, TValue> keys;
    private int age;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public WeakKeyDictionary`2(int capacity);
    public WeakKeyDictionary`2(IEqualityComparer`1<TKey> comparer);
    public WeakKeyDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    private void Age(int amount);
    public void TrimDeadObjects();
}
internal interface Castle.Core.IServiceEnabledComponent {
    public abstract virtual void Service(IServiceProvider provider);
}
internal interface Castle.Core.IServiceProviderEx {
    public abstract virtual T GetService();
}
internal interface Castle.Core.IServiceProviderExAccessor {
    public IServiceProviderEx ServiceProvider { get; }
    public abstract virtual IServiceProviderEx get_ServiceProvider();
}
internal abstract class Castle.Core.Logging.AbstractExtendedLoggerFactory : MarshalByRefObject {
    public virtual IExtendedLogger Create(Type type);
    public abstract virtual IExtendedLogger Create(string name);
    public virtual IExtendedLogger Create(Type type, LoggerLevel level);
    public abstract virtual IExtendedLogger Create(string name, LoggerLevel level);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(Type type);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(string name);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(Type type, LoggerLevel level);
    private sealed virtual override ILogger Castle.Core.Logging.ILoggerFactory.Create(string name, LoggerLevel level);
    protected static FileInfo GetConfigFile(string fileName);
}
internal abstract class Castle.Core.Logging.AbstractLoggerFactory : MarshalByRefObject {
    public virtual ILogger Create(Type type);
    public virtual ILogger Create(Type type, LoggerLevel level);
    public abstract virtual ILogger Create(string name);
    public abstract virtual ILogger Create(string name, LoggerLevel level);
    protected static FileInfo GetConfigFile(string fileName);
}
internal class Castle.Core.Logging.ConsoleFactory : MarshalByRefObject {
    private Nullable`1<LoggerLevel> level;
    public ConsoleFactory(LoggerLevel level);
    public sealed virtual ILogger Create(Type type);
    public sealed virtual ILogger Create(string name);
    public sealed virtual ILogger Create(Type type, LoggerLevel level);
    public sealed virtual ILogger Create(string name, LoggerLevel level);
}
internal class Castle.Core.Logging.ConsoleLogger : LevelFilteredLogger {
    public ConsoleLogger(LoggerLevel logLevel);
    public ConsoleLogger(string name);
    public ConsoleLogger(string name, LoggerLevel logLevel);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    public virtual ILogger CreateChildLogger(string loggerName);
}
internal class Castle.Core.Logging.DiagnosticsLogger : LevelFilteredLogger {
    private EventLog eventLog;
    public DiagnosticsLogger(string logName);
    public DiagnosticsLogger(string logName, string source);
    public DiagnosticsLogger(string logName, string machineName, string source);
    public virtual ILogger CreateChildLogger(string loggerName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    protected virtual void Finalize();
    private static EventLogEntryType TranslateLevel(LoggerLevel level);
}
internal class Castle.Core.Logging.DiagnosticsLoggerFactory : AbstractLoggerFactory {
    private static string DefaultLogName;
    public virtual ILogger Create(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
}
[DefaultMemberAttribute("Item")]
internal interface Castle.Core.Logging.IContextProperties {
    public object Item { get; public set; }
    public abstract virtual object get_Item(string key);
    public abstract virtual void set_Item(string key, object value);
}
internal interface Castle.Core.Logging.IContextStack {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual void Clear();
    public abstract virtual string Pop();
    public abstract virtual IDisposable Push(string message);
}
[DefaultMemberAttribute("Item")]
internal interface Castle.Core.Logging.IContextStacks {
    public IContextStack Item { get; }
    public abstract virtual IContextStack get_Item(string key);
}
internal interface Castle.Core.Logging.IExtendedLogger {
    public IContextProperties GlobalProperties { get; }
    public IContextProperties ThreadProperties { get; }
    public IContextStacks ThreadStacks { get; }
    public abstract virtual IContextProperties get_GlobalProperties();
    public abstract virtual IContextProperties get_ThreadProperties();
    public abstract virtual IContextStacks get_ThreadStacks();
}
internal interface Castle.Core.Logging.IExtendedLoggerFactory {
    public abstract virtual IExtendedLogger Create(Type type);
    public abstract virtual IExtendedLogger Create(string name);
    public abstract virtual IExtendedLogger Create(Type type, LoggerLevel level);
    public abstract virtual IExtendedLogger Create(string name, LoggerLevel level);
}
internal interface Castle.Core.Logging.ILogger {
    public bool IsDebugEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsFatalEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    public abstract virtual ILogger CreateChildLogger(string loggerName);
    public abstract virtual void Debug(string message);
    public abstract virtual void Debug(Func`1<string> messageFactory);
    public abstract virtual void Debug(string message, Exception exception);
    public abstract virtual void DebugFormat(string format, Object[] args);
    public abstract virtual void DebugFormat(Exception exception, string format, Object[] args);
    public abstract virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void DebugFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Error(string message);
    public abstract virtual void Error(Func`1<string> messageFactory);
    public abstract virtual void Error(string message, Exception exception);
    public abstract virtual void ErrorFormat(string format, Object[] args);
    public abstract virtual void ErrorFormat(Exception exception, string format, Object[] args);
    public abstract virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void ErrorFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Fatal(string message);
    public abstract virtual void Fatal(Func`1<string> messageFactory);
    public abstract virtual void Fatal(string message, Exception exception);
    public abstract virtual void FatalFormat(string format, Object[] args);
    public abstract virtual void FatalFormat(Exception exception, string format, Object[] args);
    public abstract virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void FatalFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Info(string message);
    public abstract virtual void Info(Func`1<string> messageFactory);
    public abstract virtual void Info(string message, Exception exception);
    public abstract virtual void InfoFormat(string format, Object[] args);
    public abstract virtual void InfoFormat(Exception exception, string format, Object[] args);
    public abstract virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void InfoFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void Warn(string message);
    public abstract virtual void Warn(Func`1<string> messageFactory);
    public abstract virtual void Warn(string message, Exception exception);
    public abstract virtual void WarnFormat(string format, Object[] args);
    public abstract virtual void WarnFormat(Exception exception, string format, Object[] args);
    public abstract virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] args);
    public abstract virtual void WarnFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
}
internal interface Castle.Core.Logging.ILoggerFactory {
    public abstract virtual ILogger Create(Type type);
    public abstract virtual ILogger Create(string name);
    public abstract virtual ILogger Create(Type type, LoggerLevel level);
    public abstract virtual ILogger Create(string name, LoggerLevel level);
}
internal abstract class Castle.Core.Logging.LevelFilteredLogger : MarshalByRefObject {
    private LoggerLevel level;
    private string name;
    public LoggerLevel Level { get; public set; }
    public string Name { get; }
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    protected LevelFilteredLogger(string name);
    protected LevelFilteredLogger(LoggerLevel loggerLevel);
    protected LevelFilteredLogger(string loggerName, LoggerLevel loggerLevel);
    public virtual object InitializeLifetimeService();
    public abstract virtual ILogger CreateChildLogger(string loggerName);
    public LoggerLevel get_Level();
    public void set_Level(LoggerLevel value);
    public string get_Name();
    public sealed virtual void Debug(string message);
    public sealed virtual void Debug(Func`1<string> messageFactory);
    public sealed virtual void Debug(string message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, string format, Object[] args);
    public sealed virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Info(string message);
    public sealed virtual void Info(Func`1<string> messageFactory);
    public sealed virtual void Info(string message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, string format, Object[] args);
    public sealed virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Warn(string message);
    public sealed virtual void Warn(Func`1<string> messageFactory);
    public sealed virtual void Warn(string message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, string format, Object[] args);
    public sealed virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(Func`1<string> messageFactory);
    public sealed virtual void Error(string message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, string format, Object[] args);
    public sealed virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Fatal(string message);
    public sealed virtual void Fatal(Func`1<string> messageFactory);
    public sealed virtual void Fatal(string message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, string format, Object[] args);
    public sealed virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    protected abstract virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    protected void ChangeName(string newName);
    private void Log(LoggerLevel loggerLevel, string message, Exception exception);
}
internal class Castle.Core.Logging.LoggerException : Exception {
    public LoggerException(string message);
    public LoggerException(string message, Exception innerException);
    protected LoggerException(SerializationInfo info, StreamingContext context);
}
internal enum Castle.Core.Logging.LoggerLevel : Enum {
    public int value__;
    public static LoggerLevel Off;
    public static LoggerLevel Fatal;
    public static LoggerLevel Error;
    public static LoggerLevel Warn;
    public static LoggerLevel Info;
    public static LoggerLevel Debug;
}
internal class Castle.Core.Logging.NullLogFactory : AbstractLoggerFactory {
    public virtual ILogger Create(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
}
internal class Castle.Core.Logging.NullLogger : object {
    public static NullLogger Instance;
    public IContextProperties GlobalProperties { get; }
    public IContextProperties ThreadProperties { get; }
    public IContextStacks ThreadStacks { get; }
    public bool IsDebugEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    private static NullLogger();
    public sealed virtual IContextProperties get_GlobalProperties();
    public sealed virtual IContextProperties get_ThreadProperties();
    public sealed virtual IContextStacks get_ThreadStacks();
    public sealed virtual bool get_IsDebugEnabled();
    public sealed virtual bool get_IsErrorEnabled();
    public sealed virtual bool get_IsFatalEnabled();
    public sealed virtual bool get_IsInfoEnabled();
    public sealed virtual bool get_IsWarnEnabled();
    public sealed virtual ILogger CreateChildLogger(string loggerName);
    public sealed virtual void Debug(string message);
    public sealed virtual void Debug(Func`1<string> messageFactory);
    public sealed virtual void Debug(string message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, string format, Object[] args);
    public sealed virtual void DebugFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void DebugFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(Func`1<string> messageFactory);
    public sealed virtual void Error(string message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, string format, Object[] args);
    public sealed virtual void ErrorFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void ErrorFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Fatal(string message);
    public sealed virtual void Fatal(Func`1<string> messageFactory);
    public sealed virtual void Fatal(string message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, string format, Object[] args);
    public sealed virtual void FatalFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void FatalFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Info(string message);
    public sealed virtual void Info(Func`1<string> messageFactory);
    public sealed virtual void Info(string message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, string format, Object[] args);
    public sealed virtual void InfoFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void InfoFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void Warn(string message);
    public sealed virtual void Warn(Func`1<string> messageFactory);
    public sealed virtual void Warn(string message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, string format, Object[] args);
    public sealed virtual void WarnFormat(IFormatProvider formatProvider, string format, Object[] args);
    public sealed virtual void WarnFormat(Exception exception, IFormatProvider formatProvider, string format, Object[] args);
}
internal class Castle.Core.Logging.StreamLogger : LevelFilteredLogger {
    private StreamWriter writer;
    public StreamLogger(string name, Stream stream);
    public StreamLogger(string name, Stream stream, Encoding encoding);
    public StreamLogger(string name, Stream stream, Encoding encoding, int bufferSize);
    protected StreamLogger(string name, StreamWriter writer);
    protected virtual void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    public virtual ILogger CreateChildLogger(string loggerName);
}
internal class Castle.Core.Logging.StreamLoggerFactory : AbstractLoggerFactory {
    public virtual ILogger Create(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
}
internal class Castle.Core.Logging.TraceLogger : LevelFilteredLogger {
    private static Dictionary`2<string, TraceSource> cache;
    private TraceSource traceSource;
    public TraceLogger(string name);
    public TraceLogger(string name, LoggerLevel level);
    private static TraceLogger();
    public virtual ILogger CreateChildLogger(string loggerName);
    private ILogger InternalCreateChildLogger(string loggerName);
    protected virtual void Log(LoggerLevel loggerLevel, string loggerName, string message, Exception exception);
    private void Initialize();
    private static string ShortenName(string name);
    private static bool IsSourceConfigured(TraceSource source);
    private static LoggerLevel MapLoggerLevel(SourceLevels level);
    private static SourceLevels MapSourceLevels(LoggerLevel level);
    private static TraceEventType MapTraceEventType(LoggerLevel level);
}
internal class Castle.Core.Logging.TraceLoggerFactory : AbstractLoggerFactory {
    public virtual ILogger Create(string name);
    private ILogger InternalCreate(string name);
    public virtual ILogger Create(string name, LoggerLevel level);
    private ILogger InternalCreate(string name, LoggerLevel level);
}
internal class Castle.Core.Pair`2 : object {
    private TFirst first;
    private TSecond second;
    public TFirst First { get; }
    public TSecond Second { get; }
    public Pair`2(TFirst first, TSecond second);
    public TFirst get_First();
    public TSecond get_Second();
    public virtual string ToString();
    public sealed virtual bool Equals(Pair`2<TFirst, TSecond> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Castle.Core.ProxyServices : object {
    public static bool IsDynamicProxy(Type type);
}
internal class Castle.Core.ReferenceEqualityComparer`1 : object {
    private static ReferenceEqualityComparer`1<T> instance;
    public static ReferenceEqualityComparer`1<T> Instance { get; }
    private static ReferenceEqualityComparer`1();
    public sealed virtual int GetHashCode(object obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<T>.Equals(T x, T y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<T>.GetHashCode(T obj);
    public static ReferenceEqualityComparer`1<T> get_Instance();
}
[DefaultMemberAttribute("Item")]
internal class Castle.Core.ReflectionBasedDictionaryAdapter : object {
    private Dictionary`2<string, object> properties;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    public ReflectionBasedDictionaryAdapter(object target);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Remove(object key);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public static void Read(IDictionary targetDictionary, object valuesAsAnonymousObject);
    private static object GetPropertyValue(object target, PropertyInfo property);
    private static IEnumerable`1<PropertyInfo> GetReadableProperties(Type targetType);
    private static bool IsReadable(PropertyInfo property);
}
internal abstract class Castle.Core.Resource.AbstractResource : object {
    protected static string DefaultBasePath;
    public string FileBasePath { get; }
    private static AbstractResource();
    public virtual string get_FileBasePath();
    public abstract virtual TextReader GetStreamReader();
    public abstract virtual TextReader GetStreamReader(Encoding encoding);
    public abstract virtual IResource CreateRelative(string relativePath);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal abstract class Castle.Core.Resource.AbstractStreamResource : AbstractResource {
    private StreamFactory createStream;
    public StreamFactory CreateStream { get; public set; }
    protected virtual void Finalize();
    public StreamFactory get_CreateStream();
    public void set_CreateStream(StreamFactory value);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
}
internal class Castle.Core.Resource.AssemblyBundleResource : AbstractResource {
    private CustomUri resource;
    public AssemblyBundleResource(CustomUri resource);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
    public virtual IResource CreateRelative(string relativePath);
    private static Assembly ObtainAssembly(string assemblyName);
}
internal class Castle.Core.Resource.AssemblyResource : AbstractStreamResource {
    private string assemblyName;
    private string resourcePath;
    private string basePath;
    public AssemblyResource(CustomUri resource);
    public AssemblyResource(CustomUri resource, string basePath);
    public AssemblyResource(string resource);
    public virtual IResource CreateRelative(string relativePath);
    public virtual string ToString();
    private Stream CreateResourceFromPath(string resource, string path);
    private Stream CreateResourceFromUri(CustomUri resourcex, string path);
    private string GetNameFound(String[] names);
    private string ConvertToResourceName(string assembly, string resource);
    private string GetSimpleName(string assembly);
    private string ConvertToPath(string resource);
    private static Assembly ObtainAssembly(string assemblyName);
}
internal class Castle.Core.Resource.AssemblyResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
internal class Castle.Core.Resource.ConfigResource : AbstractResource {
    private XmlNode configSectionNode;
    private string sectionName;
    public ConfigResource(CustomUri uri);
    public ConfigResource(string sectionName);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
    public virtual IResource CreateRelative(string relativePath);
    public virtual string ToString();
}
internal class Castle.Core.Resource.ConfigResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
internal class Castle.Core.Resource.CustomUri : object {
    public static string SchemeDelimiter;
    public static string UriSchemeFile;
    public static string UriSchemeAssembly;
    private string scheme;
    private string host;
    private string path;
    private bool isUnc;
    private bool isFile;
    private bool isAssembly;
    public bool IsUnc { get; }
    public bool IsFile { get; }
    public bool IsAssembly { get; }
    public string Scheme { get; }
    public string Host { get; }
    public string Path { get; }
    public CustomUri(string resourceIdentifier);
    private static CustomUri();
    public bool get_IsUnc();
    public bool get_IsFile();
    public bool get_IsAssembly();
    public string get_Scheme();
    public string get_Host();
    public string get_Path();
    private void ParseIdentifier(string identifier);
}
internal class Castle.Core.Resource.FileResource : AbstractStreamResource {
    private string filePath;
    private string basePath;
    public string FileBasePath { get; }
    public FileResource(CustomUri resource);
    public FileResource(CustomUri resource, string basePath);
    public FileResource(string resourceName);
    public FileResource(string resourceName, string basePath);
    public virtual string ToString();
    public virtual string get_FileBasePath();
    public virtual IResource CreateRelative(string relativePath);
    private Stream CreateStreamFromUri(CustomUri resource, string rootPath);
    private Stream CreateStreamFromPath(string resourcePath, string rootPath);
    private static void CheckFileExists(string path);
}
internal class Castle.Core.Resource.FileResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
internal interface Castle.Core.Resource.IResource {
    public string FileBasePath { get; }
    public abstract virtual string get_FileBasePath();
    public abstract virtual TextReader GetStreamReader();
    public abstract virtual TextReader GetStreamReader(Encoding encoding);
    public abstract virtual IResource CreateRelative(string relativePath);
}
internal interface Castle.Core.Resource.IResourceFactory {
    public abstract virtual bool Accept(CustomUri uri);
    public abstract virtual IResource Create(CustomUri uri);
    public abstract virtual IResource Create(CustomUri uri, string basePath);
}
internal class Castle.Core.Resource.ResourceException : Exception {
    public ResourceException(string message);
    public ResourceException(string message, Exception innerException);
    protected ResourceException(SerializationInfo info, StreamingContext context);
}
internal class Castle.Core.Resource.StaticContentResource : AbstractResource {
    private string contents;
    public StaticContentResource(string contents);
    public virtual TextReader GetStreamReader();
    public virtual TextReader GetStreamReader(Encoding encoding);
    public virtual IResource CreateRelative(string relativePath);
}
internal class Castle.Core.Resource.StreamFactory : MulticastDelegate {
    public StreamFactory(object object, IntPtr method);
    public virtual Stream Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual Stream EndInvoke(IAsyncResult result);
}
internal class Castle.Core.Resource.UncResource : AbstractStreamResource {
    private string basePath;
    private string filePath;
    public string FileBasePath { get; }
    public UncResource(CustomUri resource);
    public UncResource(CustomUri resource, string basePath);
    public UncResource(string resourceName);
    public UncResource(string resourceName, string basePath);
    public virtual string get_FileBasePath();
    public virtual IResource CreateRelative(string relativePath);
    public virtual string ToString();
    private Stream CreateStreamFromUri(CustomUri resource, string rootPath);
    private static void CheckFileExists(string path);
}
internal class Castle.Core.Resource.UncResourceFactory : object {
    public sealed virtual bool Accept(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri);
    public sealed virtual IResource Create(CustomUri uri, string basePath);
}
internal class Castle.Core.Smtp.DefaultSmtpSender : object {
    private bool asyncSend;
    private string hostname;
    private int port;
    private Nullable`1<int> timeout;
    private bool useSsl;
    private NetworkCredential credentials;
    public int Port { get; public set; }
    public string Hostname { get; }
    public bool AsyncSend { get; public set; }
    public int Timeout { get; public set; }
    public bool UseSsl { get; public set; }
    public string Domain { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    private bool HasCredentials { get; }
    public DefaultSmtpSender(string hostname);
    public int get_Port();
    public void set_Port(int value);
    public string get_Hostname();
    public bool get_AsyncSend();
    public void set_AsyncSend(bool value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public bool get_UseSsl();
    public void set_UseSsl(bool value);
    public sealed virtual void Send(string from, string to, string subject, string messageText);
    public sealed virtual void Send(MailMessage message);
    private void InternalSend(MailMessage message);
    public sealed virtual void Send(IEnumerable`1<MailMessage> messages);
    public string get_Domain();
    public void set_Domain(string value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Password();
    public void set_Password(string value);
    protected virtual void Configure(SmtpClient smtpClient);
    private bool get_HasCredentials();
    private static bool CanAccessCredentials();
}
internal interface Castle.Core.Smtp.IEmailSender {
    public abstract virtual void Send(string from, string to, string subject, string messageText);
    public abstract virtual void Send(MailMessage message);
    public abstract virtual void Send(IEnumerable`1<MailMessage> messages);
}
[DefaultMemberAttribute("Item")]
internal class Castle.Core.StringObjectDictionaryAdapter : object {
    private IDictionary dictionary;
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public StringObjectDictionaryAdapter(IDictionary dictionary);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    public bool Contains(object key);
    public void Add(object key, object value);
    public sealed virtual void Clear();
    public void Remove(object key);
    public object get_Item(object key);
    public void set_Item(object key, object value);
    public ICollection get_Keys();
    public ICollection get_Values();
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsFixedSize();
    public void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public object get_SyncRoot();
    public bool get_IsSynchronized();
    public sealed virtual IEnumerator GetEnumerator();
}
public abstract class Castle.DynamicProxy.AbstractInvocation : object {
    private IInterceptor[] interceptors;
    private Object[] arguments;
    private int currentInterceptorIndex;
    private Type[] genericMethodArguments;
    private MethodInfo proxiedMethod;
    protected object proxyObject;
    [CompilerGeneratedAttribute]
private object <ReturnValue>k__BackingField;
    public object InvocationTarget { get; }
    public Type TargetType { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public Type[] GenericArguments { get; }
    public object Proxy { get; }
    public MethodInfo Method { get; }
    public object ReturnValue { get; public set; }
    public Object[] Arguments { get; }
    protected AbstractInvocation(object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    public void SetGenericMethodArguments(Type[] arguments);
    public abstract virtual object get_InvocationTarget();
    public abstract virtual Type get_TargetType();
    public abstract virtual MethodInfo get_MethodInvocationTarget();
    public sealed virtual Type[] get_GenericArguments();
    public sealed virtual object get_Proxy();
    public sealed virtual MethodInfo get_Method();
    public sealed virtual MethodInfo GetConcreteMethod();
    public sealed virtual MethodInfo GetConcreteMethodInvocationTarget();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ReturnValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReturnValue(object value);
    public sealed virtual Object[] get_Arguments();
    public sealed virtual void SetArgumentValue(int index, object value);
    public sealed virtual object GetArgumentValue(int index);
    public sealed virtual void Proceed();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected abstract virtual void InvokeMethodOnTarget();
    protected void ThrowOnNoTarget();
    private MethodInfo EnsureClosedMethod(MethodInfo method);
}
internal class Castle.DynamicProxy.AllMethodsHook : object {
    protected static ICollection`1<Type> SkippedTypes;
    private static AllMethodsHook();
    public virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
    public virtual void NonProxyableMemberNotification(Type type, MemberInfo memberInfo);
    public virtual void MethodsInspected();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Castle.DynamicProxy.Contributors.ClassMembersCollector : MembersCollector {
    public ClassMembersCollector(Type targetType);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
}
internal class Castle.DynamicProxy.Contributors.ClassProxyInstanceContributor : ProxyInstanceContributor {
    private bool delegateToBaseGetObjectData;
    private bool implementISerializable;
    private ConstructorInfo serializationConstructor;
    private IList`1<FieldReference> serializedFields;
    public ClassProxyInstanceContributor(Type targetType, IList`1<MethodInfo> methodsToSkip, Type[] interfaces, string typeId);
    protected virtual Expression GetTargetReferenceExpression(ClassEmitter emitter);
    public virtual void Generate(ClassEmitter class, ProxyGenerationOptions options);
    protected virtual void AddAddValueInvocation(ArgumentReference serializationInfo, MethodEmitter getObjectData, FieldReference field);
    protected virtual void CustomizeGetObjectData(AbstractCodeBuilder codebuilder, ArgumentReference serializationInfo, ArgumentReference streamingContext, ClassEmitter emitter);
    private void EmitCustomGetObjectData(AbstractCodeBuilder codebuilder, ArgumentReference serializationInfo);
    private void EmitCallToBaseGetObjectData(AbstractCodeBuilder codebuilder, ArgumentReference serializationInfo, ArgumentReference streamingContext);
    private void Constructor(ClassEmitter emitter);
    private void GenerateSerializationConstructor(ClassEmitter emitter);
    private bool VerifyIfBaseImplementsGetObjectData(Type baseType, IList`1<MethodInfo> methodsToSkip);
    private bool IsDelegate(Type baseType);
}
internal class Castle.DynamicProxy.Contributors.ClassProxyTargetContributor : CompositeTypeContributor {
    private IList`1<MethodInfo> methodsToSkip;
    private Type targetType;
    public ClassProxyTargetContributor(Type targetType, IList`1<MethodInfo> methodsToSkip, INamingScope namingScope);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private Type BuildInvocationType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    private MethodBuilder CreateCallbackMethod(ClassEmitter emitter, MethodInfo methodInfo, MethodInfo methodOnTarget);
    private bool ExplicitlyImplementedInterfaceMethod(MetaMethod method);
    private MethodGenerator ExplicitlyImplementedInterfaceMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private IInvocationCreationContributor GetContributor(Type delegate, MetaMethod method);
    private Type GetDelegateType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    private Type GetInvocationType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    [CompilerGeneratedAttribute]
private Expression <GetMethodGenerator>b__a(ClassEmitter c, MethodInfo m);
    [CompilerGeneratedAttribute]
private Expression <ExplicitlyImplementedInterfaceMethodGenerator>b__b(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Contributors.ClassProxyWithTargetTargetContributor : CompositeTypeContributor {
    private IList`1<MethodInfo> methodsToSkip;
    private Type targetType;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegated;
    public ClassProxyWithTargetTargetContributor(Type targetType, IList`1<MethodInfo> methodsToSkip, INamingScope namingScope);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private Type BuildInvocationType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    private IInvocationCreationContributor GetContributor(Type delegate, MetaMethod method);
    private Type GetDelegateType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    private Type GetInvocationType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    private MethodGenerator IndirectlyCalledMethodGenerator(MetaMethod method, ClassEmitter proxy, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private bool IsDirectlyAccessible(MetaMethod method);
    [CompilerGeneratedAttribute]
private static Expression <GetMethodGenerator>b__a(ClassEmitter c, MethodInfo m);
    [CompilerGeneratedAttribute]
private static Expression <IndirectlyCalledMethodGenerator>b__c(ClassEmitter c, MethodInfo m);
}
internal abstract class Castle.DynamicProxy.Contributors.CompositeTypeContributor : object {
    protected INamingScope namingScope;
    protected ICollection`1<Type> interfaces;
    private ILogger logger;
    private ICollection`1<MetaProperty> properties;
    private ICollection`1<MetaEvent> events;
    private ICollection`1<MetaMethod> methods;
    public ILogger Logger { get; public set; }
    protected CompositeTypeContributor(INamingScope namingScope);
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    public sealed virtual void CollectElementsToProxy(IProxyGenerationHook hook, MetaType model);
    protected abstract virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    public virtual void Generate(ClassEmitter class, ProxyGenerationOptions options);
    public void AddInterfaceToProxy(Type interface);
    private void ImplementEvent(ClassEmitter emitter, MetaEvent event, ProxyGenerationOptions options);
    private void ImplementProperty(ClassEmitter emitter, MetaProperty property, ProxyGenerationOptions options);
    protected abstract virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private void ImplementMethod(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
}
internal class Castle.DynamicProxy.Contributors.DelegateProxyTargetContributor : CompositeTypeContributor {
    private Type targetType;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegate6;
    public DelegateProxyTargetContributor(Type targetType, INamingScope namingScope);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private Type GetInvocationType(MetaMethod method, ClassEmitter emitter, ProxyGenerationOptions options);
    [CompilerGeneratedAttribute]
private static Expression <GetMethodGenerator>b__5(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Contributors.DelegateTypeGenerator : object {
    private static TypeAttributes DelegateFlags;
    private MetaMethod method;
    private Type targetType;
    public DelegateTypeGenerator(MetaMethod method, Type targetType);
    public sealed virtual AbstractTypeEmitter Generate(ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    private void BuildConstructor(AbstractTypeEmitter emitter);
    private void BuildInvokeMethod(AbstractTypeEmitter delegate);
    private AbstractTypeEmitter GetEmitter(ClassEmitter class, INamingScope namingScope);
    private Type[] GetParamTypes(AbstractTypeEmitter delegate);
}
internal class Castle.DynamicProxy.Contributors.ForwardingMethodGenerator : MethodGenerator {
    private GetTargetReferenceDelegate getTargetReference;
    public ForwardingMethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod, GetTargetReferenceDelegate getTargetReference);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
}
internal class Castle.DynamicProxy.Contributors.GetTargetExpressionDelegate : MulticastDelegate {
    public GetTargetExpressionDelegate(object object, IntPtr method);
    public virtual Expression Invoke(ClassEmitter class, MethodInfo method);
    public virtual IAsyncResult BeginInvoke(ClassEmitter class, MethodInfo method, AsyncCallback callback, object object);
    public virtual Expression EndInvoke(IAsyncResult result);
}
internal class Castle.DynamicProxy.Contributors.GetTargetReferenceDelegate : MulticastDelegate {
    public GetTargetReferenceDelegate(object object, IntPtr method);
    public virtual Reference Invoke(ClassEmitter class, MethodInfo method);
    public virtual IAsyncResult BeginInvoke(ClassEmitter class, MethodInfo method, AsyncCallback callback, object object);
    public virtual Reference EndInvoke(IAsyncResult result);
}
internal class Castle.DynamicProxy.Contributors.InterfaceMembersCollector : MembersCollector {
    public InterfaceMembersCollector(Type interface);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
}
internal class Castle.DynamicProxy.Contributors.InterfaceMembersOnClassCollector : MembersCollector {
    private InterfaceMapping map;
    private bool onlyProxyVirtual;
    public InterfaceMembersOnClassCollector(Type type, bool onlyProxyVirtual, InterfaceMapping map);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    private MethodInfo GetMethodOnTarget(MethodInfo method);
    private bool IsVirtuallyImplementedInterfaceMethod(MethodInfo method);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyInstanceContributor : ProxyInstanceContributor {
    public InterfaceProxyInstanceContributor(Type targetType, string proxyGeneratorId, Type[] interfaces);
    protected virtual Expression GetTargetReferenceExpression(ClassEmitter emitter);
    protected virtual void CustomizeGetObjectData(AbstractCodeBuilder codebuilder, ArgumentReference serializationInfo, ArgumentReference streamingContext, ClassEmitter emitter);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyTargetContributor : CompositeTypeContributor {
    private bool canChangeTarget;
    private Type proxyTargetType;
    [CompilerGeneratedAttribute]
private static GetTargetReferenceDelegate CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegatea;
    public InterfaceProxyTargetContributor(Type proxyTargetType, bool canChangeTarget, INamingScope namingScope);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MembersCollector GetCollectorForInterface(Type interface);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private Type GetInvocationType(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options);
    [CompilerGeneratedAttribute]
private static Reference <GetMethodGenerator>b__7(ClassEmitter c, MethodInfo m);
    [CompilerGeneratedAttribute]
private static Expression <GetMethodGenerator>b__8(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyWithOptionalTargetContributor : InterfaceProxyWithoutTargetContributor {
    private GetTargetReferenceDelegate getTargetReference;
    public InterfaceProxyWithOptionalTargetContributor(INamingScope namingScope, GetTargetExpressionDelegate getTarget, GetTargetReferenceDelegate getTargetReference);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyWithoutTargetContributor : CompositeTypeContributor {
    private GetTargetExpressionDelegate getTargetExpression;
    protected bool canChangeTarget;
    public InterfaceProxyWithoutTargetContributor(INamingScope namingScope, GetTargetExpressionDelegate getTarget);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private Type GetInvocationType(MetaMethod method, ClassEmitter emitter, ProxyGenerationOptions options);
}
internal class Castle.DynamicProxy.Contributors.InterfaceProxyWithTargetInterfaceTargetContributor : InterfaceProxyTargetContributor {
    public InterfaceProxyWithTargetInterfaceTargetContributor(Type proxyTargetType, bool allowChangeTarget, INamingScope namingScope);
    protected virtual MembersCollector GetCollectorForInterface(Type interface);
}
internal class Castle.DynamicProxy.Contributors.InvocationWithDelegateContributor : object {
    private Type delegateType;
    private MetaMethod method;
    private INamingScope namingScope;
    private Type targetType;
    public InvocationWithDelegateContributor(Type delegateType, Type targetType, MetaMethod method, INamingScope namingScope);
    public sealed virtual ConstructorEmitter CreateConstructor(ArgumentReference[] baseCtorArguments, AbstractTypeEmitter invocation);
    public sealed virtual MethodInfo GetCallbackMethod();
    public sealed virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, Expression[] args, Reference targetField, MethodEmitter invokeMethodOnTarget);
    public sealed virtual Expression[] GetConstructorInvocationArguments(Expression[] arguments, ClassEmitter proxy);
    private FieldReference BuildDelegateToken(ClassEmitter proxy);
    private Expression[] GetAllArgs(Expression[] args, Reference targetField);
    private ArgumentReference[] GetArguments(ArgumentReference[] baseCtorArguments);
}
internal class Castle.DynamicProxy.Contributors.InvocationWithGenericDelegateContributor : object {
    private Type delegateType;
    private MetaMethod method;
    private Reference targetReference;
    public InvocationWithGenericDelegateContributor(Type delegateType, MetaMethod method, Reference targetReference);
    public sealed virtual ConstructorEmitter CreateConstructor(ArgumentReference[] baseCtorArguments, AbstractTypeEmitter invocation);
    public sealed virtual MethodInfo GetCallbackMethod();
    public sealed virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, Expression[] args, Reference targetField, MethodEmitter invokeMethodOnTarget);
    public sealed virtual Expression[] GetConstructorInvocationArguments(Expression[] arguments, ClassEmitter proxy);
    private Reference GetDelegate(AbstractTypeEmitter invocation, MethodEmitter invokeMethodOnTarget);
    private AssignStatement SetDelegate(LocalReference localDelegate, ReferenceExpression localTarget, Type closedDelegateType, MethodInfo closedMethodOnTarget);
}
internal interface Castle.DynamicProxy.Contributors.ITypeContributor {
    public abstract virtual void CollectElementsToProxy(IProxyGenerationHook hook, MetaType model);
    public abstract virtual void Generate(ClassEmitter class, ProxyGenerationOptions options);
}
internal abstract class Castle.DynamicProxy.Contributors.MembersCollector : object {
    private static BindingFlags Flags;
    private ILogger logger;
    private ICollection`1<MethodInfo> checkedMethods;
    private IDictionary`2<PropertyInfo, MetaProperty> properties;
    private IDictionary`2<EventInfo, MetaEvent> events;
    private IDictionary`2<MethodInfo, MetaMethod> methods;
    protected Type type;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate1;
    public ILogger Logger { get; public set; }
    public IEnumerable`1<MetaMethod> Methods { get; }
    public IEnumerable`1<MetaProperty> Properties { get; }
    public IEnumerable`1<MetaEvent> Events { get; }
    protected MembersCollector(Type type);
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    public IEnumerable`1<MetaMethod> get_Methods();
    public IEnumerable`1<MetaProperty> get_Properties();
    public IEnumerable`1<MetaEvent> get_Events();
    public virtual void CollectMembersToProxy(IProxyGenerationHook hook);
    private void CollectProperties(IProxyGenerationHook hook);
    private void CollectEvents(IProxyGenerationHook hook);
    private void CollectMethods(IProxyGenerationHook hook);
    private void AddProperty(PropertyInfo property, IProxyGenerationHook hook);
    private void AddEvent(EventInfo event, IProxyGenerationHook hook);
    private MetaMethod AddMethod(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    protected abstract virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    protected bool AcceptMethod(MethodInfo method, bool onlyVirtuals, IProxyGenerationHook hook);
    private static bool IsInternalAndNotVisibleToDynamicProxy(MethodInfo method);
    [CompilerGeneratedAttribute]
private static Type <AddProperty>b__0(ParameterInfo a);
}
internal class Castle.DynamicProxy.Contributors.MinimialisticMethodGenerator : MethodGenerator {
    public MinimialisticMethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    private void InitOutParameters(MethodEmitter emitter, ParameterInfo[] parameters);
}
internal class Castle.DynamicProxy.Contributors.MixinContributor : CompositeTypeContributor {
    private bool canChangeTarget;
    private IList`1<Type> empty;
    private IDictionary`2<Type, FieldReference> fields;
    private GetTargetExpressionDelegate getTargetExpression;
    public IEnumerable`1<FieldReference> Fields { get; }
    public MixinContributor(INamingScope namingScope, bool canChangeTarget);
    public IEnumerable`1<FieldReference> get_Fields();
    public void AddEmptyInterface(Type interface);
    public virtual void Generate(ClassEmitter class, ProxyGenerationOptions options);
    protected virtual IEnumerable`1<MembersCollector> CollectElementsToProxyInternal(IProxyGenerationHook hook);
    protected virtual MethodGenerator GetMethodGenerator(MetaMethod method, ClassEmitter class, ProxyGenerationOptions options, OverrideMethodDelegate overrideMethod);
    private GetTargetExpressionDelegate BuildGetTargetExpression();
    private FieldReference BuildTargetField(ClassEmitter class, Type type);
    private Type GetInvocationType(MetaMethod method, ClassEmitter emitter, ProxyGenerationOptions options);
    [CompilerGeneratedAttribute]
private Reference <GetMethodGenerator>b__7(ClassEmitter c, MethodInfo i);
    [CompilerGeneratedAttribute]
private Expression <BuildGetTargetExpression>b__9(ClassEmitter c, MethodInfo m);
    [CompilerGeneratedAttribute]
private Expression <BuildGetTargetExpression>b__a(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Contributors.OptionallyForwardingMethodGenerator : MethodGenerator {
    private GetTargetReferenceDelegate getTargetReference;
    public OptionallyForwardingMethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod, GetTargetReferenceDelegate getTargetReference);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    private Expression IfNotNull(Reference targetReference);
    private Expression IfNull(Type returnType);
    private void InitOutParameters(MultiStatementExpression expression, ParameterInfo[] parameters);
}
internal class Castle.DynamicProxy.Contributors.OverrideMethodDelegate : MulticastDelegate {
    public OverrideMethodDelegate(object object, IntPtr method);
    public virtual MethodEmitter Invoke(string name, MethodAttributes attributes, MethodInfo methodToOverride);
    public virtual IAsyncResult BeginInvoke(string name, MethodAttributes attributes, MethodInfo methodToOverride, AsyncCallback callback, object object);
    public virtual MethodEmitter EndInvoke(IAsyncResult result);
}
internal abstract class Castle.DynamicProxy.Contributors.ProxyInstanceContributor : object {
    protected Type targetType;
    private string proxyTypeId;
    private Type[] interfaces;
    protected ProxyInstanceContributor(Type targetType, Type[] interfaces, string proxyTypeId);
    protected abstract virtual Expression GetTargetReferenceExpression(ClassEmitter emitter);
    public virtual void Generate(ClassEmitter class, ProxyGenerationOptions options);
    protected void ImplementProxyTargetAccessor(ClassEmitter emitter, FieldReference interceptorsField);
    protected void ImplementGetObjectData(ClassEmitter emitter);
    protected virtual void AddAddValueInvocation(ArgumentReference serializationInfo, MethodEmitter getObjectData, FieldReference field);
    protected abstract virtual void CustomizeGetObjectData(AbstractCodeBuilder builder, ArgumentReference serializationInfo, ArgumentReference streamingContext, ClassEmitter emitter);
    public sealed virtual void CollectElementsToProxy(IProxyGenerationHook hook, MetaType model);
}
internal class Castle.DynamicProxy.Contributors.WrappedClassMembersCollector : ClassMembersCollector {
    public WrappedClassMembersCollector(Type type);
    public virtual void CollectMembersToProxy(IProxyGenerationHook hook);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
    protected bool IsGeneratedByTheCompiler(FieldInfo field);
    protected virtual bool IsOKToBeOnProxy(FieldInfo field);
    private void CollectFields(IProxyGenerationHook hook);
}
internal class Castle.DynamicProxy.DefaultProxyBuilder : object {
    private ModuleScope scope;
    private ILogger logger;
    public ILogger Logger { get; public set; }
    public ModuleScope ModuleScope { get; }
    public DefaultProxyBuilder(ModuleScope scope);
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    public sealed virtual ModuleScope get_ModuleScope();
    public sealed virtual Type CreateClassProxyType(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public sealed virtual Type CreateClassProxyTypeWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public sealed virtual Type CreateInterfaceProxyTypeWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, Type targetType, ProxyGenerationOptions options);
    public sealed virtual Type CreateInterfaceProxyTypeWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public sealed virtual Type CreateInterfaceProxyTypeWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    private void AssertValidType(Type target);
    private void AssertValidTypes(IEnumerable`1<Type> targetTypes);
    private bool IsAccessible(Type target);
    private bool IsPublic(Type target);
    private static bool IsInternal(Type target);
}
internal class Castle.DynamicProxy.Generators.AttributeDisassembler : object {
    public sealed virtual CustomAttributeBuilder Disassemble(Attribute attribute);
    protected virtual CustomAttributeBuilder HandleError(Type attributeType, Exception exception);
    private static Object[] GetConstructorAndArgs(Type attributeType, Attribute attribute, ConstructorInfo& ctor);
    private static Object[] GetPropertyValues(Type attType, PropertyInfo[]& properties, Attribute original, Attribute replicated);
    private static Object[] GetFieldValues(Type attType, FieldInfo[]& fields, Attribute original, Attribute replicated);
    private static Object[] InitializeConstructorArgs(Type attributeType, Attribute attribute, ParameterInfo[] parameters);
    private static object GetArgumentValue(Type attributeType, Attribute attribute, ParameterInfo parameter);
    private static PropertyInfo ReplaceIfBetterMatch(ParameterInfo parameterInfo, PropertyInfo propertyInfo, PropertyInfo bestMatch);
    private static object ConvertValue(object obj, Type paramType);
    private static object GetDefaultValueFor(ParameterInfo parameter);
    private static List`1<PropertyInfo> GetPropertyCandidates(Type attributeType);
    private static bool AreAttributeElementsEqual(object first, object second);
    private static bool AreStringsEqual(string first, string second);
    public bool Equals(AttributeDisassembler other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class Castle.DynamicProxy.Generators.AttributesToAvoidReplicating : object {
    private static IList`1<Type> attributes;
    private static AttributesToAvoidReplicating();
    public static void Add(Type attribute);
    public static void Add();
    public static bool Contains(Type type);
}
internal abstract class Castle.DynamicProxy.Generators.BaseProxyGenerator : object {
    protected Type targetType;
    private ModuleScope scope;
    private ILogger logger;
    private ProxyGenerationOptions proxyGenerationOptions;
    public ILogger Logger { get; public set; }
    protected ProxyGenerationOptions ProxyGenerationOptions { get; protected set; }
    protected ModuleScope Scope { get; }
    protected BaseProxyGenerator(ModuleScope scope, Type targetType);
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    protected ProxyGenerationOptions get_ProxyGenerationOptions();
    protected void set_ProxyGenerationOptions(ProxyGenerationOptions value);
    protected ModuleScope get_Scope();
    protected void AddMapping(Type interface, ITypeContributor implementer, IDictionary`2<Type, ITypeContributor> mapping);
    protected void AddMappingForISerializable(IDictionary`2<Type, ITypeContributor> typeImplementerMapping, ITypeContributor instance);
    protected void AddMappingNoCheck(Type interface, ITypeContributor implementer, IDictionary`2<Type, ITypeContributor> mapping);
    protected void AddToCache(CacheKey key, Type type);
    protected virtual ClassEmitter BuildClassEmitter(string typeName, Type parentType, IEnumerable`1<Type> interfaces);
    protected void CheckNotGenericTypeDefinition(Type type, string argumentName);
    protected void CheckNotGenericTypeDefinitions(IEnumerable`1<Type> types, string argumentName);
    protected void CompleteInitCacheMethod(ConstructorCodeBuilder constCodeBuilder);
    protected virtual void CreateFields(ClassEmitter emitter);
    protected void CreateInterceptorsField(ClassEmitter emitter);
    protected FieldReference CreateOptionsField(ClassEmitter emitter);
    protected void CreateSelectorField(ClassEmitter emitter);
    protected virtual void CreateTypeAttributes(ClassEmitter emitter);
    protected void EnsureOptionsOverrideEqualsAndGetHashCode(ProxyGenerationOptions options);
    protected void GenerateConstructor(ClassEmitter emitter, ConstructorInfo baseConstructor, FieldReference[] fields);
    protected void GenerateConstructors(ClassEmitter emitter, Type baseType, FieldReference[] fields);
    protected void GenerateParameterlessConstructor(ClassEmitter emitter, Type baseClass, FieldReference interceptorField);
    protected ConstructorEmitter GenerateStaticConstructor(ClassEmitter emitter);
    protected Type GetFromCache(CacheKey key);
    protected void HandleExplicitlyPassedProxyTargetAccessor(ICollection`1<Type> targetInterfaces, ICollection`1<Type> additionalInterfaces);
    protected void InitializeStaticFields(Type builtType);
    protected Type ObtainProxyType(CacheKey cacheKey, Func`3<string, INamingScope, Type> factory);
    private bool IsConstructorVisible(ConstructorInfo constructor);
    private bool OverridesEqualsAndGetHashCode(Type type);
}
internal class Castle.DynamicProxy.Generators.CacheKey : object {
    private MemberInfo target;
    private Type[] interfaces;
    private ProxyGenerationOptions options;
    private Type type;
    public CacheKey(MemberInfo target, Type type, Type[] interfaces, ProxyGenerationOptions options);
    public CacheKey(Type target, Type[] interfaces, ProxyGenerationOptions options);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Castle.DynamicProxy.Generators.ClassProxyGenerator : BaseProxyGenerator {
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegate8;
    public ClassProxyGenerator(ModuleScope scope, Type targetType);
    public Type GenerateCode(Type[] interfaces, ProxyGenerationOptions options);
    protected virtual Type GenerateType(string name, Type[] interfaces, INamingScope namingScope);
    protected virtual IEnumerable`1<Type> GetTypeImplementerMapping(Type[] interfaces, IEnumerable`1& contributors, INamingScope namingScope);
    private void EnsureDoesNotImplementIProxyTargetAccessor(Type type, string name);
    [CompilerGeneratedAttribute]
private static Expression <GetTypeImplementerMapping>b__7(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Generators.ClassProxyWithTargetGenerator : BaseProxyGenerator {
    private Type[] additionalInterfacesToProxy;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegate5;
    public ClassProxyWithTargetGenerator(ModuleScope scope, Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public Type GetGeneratedType();
    protected virtual IEnumerable`1<Type> GetTypeImplementerMapping(IEnumerable`1& contributors, INamingScope namingScope);
    private FieldReference CreateTargetField(ClassEmitter emitter);
    private void EnsureDoesNotImplementIProxyTargetAccessor(Type type, string name);
    private Type GenerateType(string name, INamingScope namingScope);
    [CompilerGeneratedAttribute]
private static Expression <GetTypeImplementerMapping>b__4(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Generators.CompositionInvocationTypeGenerator : InvocationTypeGenerator {
    public static Type BaseType;
    public CompositionInvocationTypeGenerator(Type target, MetaMethod method, MethodInfo callback, bool canChangeTarget, IInvocationCreationContributor contributor);
    private static CompositionInvocationTypeGenerator();
    protected virtual ArgumentReference[] GetBaseCtorArguments(Type targetFieldType, ProxyGenerationOptions proxyGenerationOptions, ConstructorInfo& baseConstructor);
    protected virtual Type GetBaseType();
    protected virtual FieldReference GetTargetReference();
    protected virtual void ImplementInvokeMethodOnTarget(AbstractTypeEmitter invocation, ParameterInfo[] parameters, MethodEmitter invokeMethodOnTarget, Reference targetField);
}
internal class Castle.DynamicProxy.Generators.DelegateMembersCollector : MembersCollector {
    public DelegateMembersCollector(Type type);
    protected virtual MetaMethod GetMethodToGenerate(MethodInfo method, IProxyGenerationHook hook, bool isStandalone);
}
internal class Castle.DynamicProxy.Generators.DelegateProxyGenerationHook : object {
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void MethodsInspected();
    public sealed virtual void NonProxyableMemberNotification(Type type, MemberInfo memberInfo);
    public sealed virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
}
internal class Castle.DynamicProxy.Generators.DelegateProxyGenerator : BaseProxyGenerator {
    public DelegateProxyGenerator(ModuleScope scope, Type delegateType);
    public Type GetProxyType();
    protected virtual IEnumerable`1<Type> GetTypeImplementerMapping(IEnumerable`1& contributors, INamingScope namingScope);
    private FieldReference CreateTargetField(ClassEmitter emitter);
    private Type GenerateType(string name, INamingScope namingScope);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.AbstractTypeEmitter : object {
    private static MethodAttributes defaultAttributes;
    private ConstructorCollection constructors;
    private EventCollection events;
    private IDictionary`2<string, FieldReference> fields;
    private MethodCollection methods;
    private Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType;
    private NestedClassCollection nested;
    private PropertiesCollection properties;
    private TypeBuilder typebuilder;
    private GenericTypeParameterBuilder[] genericTypeParams;
    [CompilerGeneratedAttribute]
private TypeConstructorEmitter <ClassConstructor>k__BackingField;
    public Type BaseType { get; }
    public TypeConstructorEmitter ClassConstructor { get; private set; }
    public ConstructorCollection Constructors { get; }
    public GenericTypeParameterBuilder[] GenericTypeParams { get; }
    public NestedClassCollection Nested { get; }
    public TypeBuilder TypeBuilder { get; }
    protected AbstractTypeEmitter(TypeBuilder typeBuilder);
    public Type get_BaseType();
    [CompilerGeneratedAttribute]
public TypeConstructorEmitter get_ClassConstructor();
    [CompilerGeneratedAttribute]
private void set_ClassConstructor(TypeConstructorEmitter value);
    public ConstructorCollection get_Constructors();
    public GenericTypeParameterBuilder[] get_GenericTypeParams();
    public NestedClassCollection get_Nested();
    public TypeBuilder get_TypeBuilder();
    public void AddCustomAttributes(ProxyGenerationOptions proxyGenerationOptions);
    public virtual Type BuildType();
    public void CopyGenericParametersFromMethod(MethodInfo methodToCopyGenericsFrom);
    public ConstructorEmitter CreateConstructor(ArgumentReference[] arguments);
    public void CreateDefaultConstructor();
    public EventEmitter CreateEvent(string name, EventAttributes atts, Type type);
    public FieldReference CreateField(string name, Type fieldType);
    public FieldReference CreateField(string name, Type fieldType, bool serializable);
    public FieldReference CreateField(string name, Type fieldType, FieldAttributes atts);
    public MethodEmitter CreateMethod(string name, MethodAttributes attrs, Type returnType, Type[] argumentTypes);
    public MethodEmitter CreateMethod(string name, Type returnType, Type[] parameterTypes);
    public MethodEmitter CreateMethod(string name, MethodInfo methodToUseAsATemplate);
    public MethodEmitter CreateMethod(string name, MethodAttributes attributes, MethodInfo methodToUseAsATemplate);
    public PropertyEmitter CreateProperty(string name, PropertyAttributes attributes, Type propertyType, Type[] arguments);
    public FieldReference CreateStaticField(string name, Type fieldType);
    public FieldReference CreateStaticField(string name, Type fieldType, FieldAttributes atts);
    public ConstructorEmitter CreateTypeConstructor();
    public void DefineCustomAttribute(CustomAttributeBuilder attribute);
    public void DefineCustomAttribute(Object[] constructorArguments);
    public void DefineCustomAttribute();
    public void DefineCustomAttributeFor(FieldReference field);
    public IEnumerable`1<FieldReference> GetAllFields();
    public FieldReference GetField(string name);
    public Type GetGenericArgument(string genericArgumentName);
    public Type[] GetGenericArgumentsFor(Type genericType);
    public Type[] GetGenericArgumentsFor(MethodInfo genericMethod);
    public void SetGenericTypeParameters(GenericTypeParameterBuilder[] genericTypeParameterBuilders);
    protected Type CreateType(TypeBuilder type);
    protected virtual void EnsureBuildersAreInAValidState();
}
internal class Castle.DynamicProxy.Generators.Emitters.ApplyGenArgs : MulticastDelegate {
    public ApplyGenArgs(object object, IntPtr method);
    public virtual GenericTypeParameterBuilder[] Invoke(String[] argumentNames);
    public virtual IAsyncResult BeginInvoke(String[] argumentNames, AsyncCallback callback, object object);
    public virtual GenericTypeParameterBuilder[] EndInvoke(IAsyncResult result);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.ArgumentsUtil : object {
    public static Expression[] ConvertArgumentReferenceToExpression(ArgumentReference[] args);
    public static ArgumentReference[] ConvertToArgumentReference(Type[] args);
    public static ArgumentReference[] ConvertToArgumentReference(ParameterInfo[] args);
    public static ReferenceExpression[] ConvertToArgumentReferenceExpression(ParameterInfo[] args);
    public static void EmitLoadOwnerAndReference(Reference reference, ILGenerator il);
    public static Type[] GetTypes(ParameterInfo[] parameters);
    public static Type[] InitializeAndConvert(ArgumentReference[] args);
    public static void InitializeArgumentsByPosition(ArgumentReference[] args, bool isStatic);
    public static bool IsAnyByRef(ParameterInfo[] parameters);
}
internal class Castle.DynamicProxy.Generators.Emitters.ClassEmitter : AbstractTypeEmitter {
    private static TypeAttributes DefaultAttributes;
    private ModuleScope moduleScope;
    public ModuleScope ModuleScope { get; }
    public ClassEmitter(ModuleScope modulescope, string name, Type baseType, IEnumerable`1<Type> interfaces);
    public ClassEmitter(ModuleScope modulescope, string name, Type baseType, IEnumerable`1<Type> interfaces, TypeAttributes flags);
    public ClassEmitter(ModuleScope modulescope, string name, Type baseType, IEnumerable`1<Type> interfaces, TypeAttributes flags, bool forceUnsigned);
    public ClassEmitter(TypeBuilder typeBuilder);
    public ModuleScope get_ModuleScope();
    protected virtual IEnumerable`1<Type> InitializeGenericArgumentsFromBases(Type& baseType, IEnumerable`1<Type> interfaces);
    private static TypeBuilder CreateTypeBuilder(ModuleScope modulescope, string name, Type baseType, IEnumerable`1<Type> interfaces, TypeAttributes flags, bool forceUnsigned);
    private static bool ShouldForceUnsigned();
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.CodeBuilders.AbstractCodeBuilder : object {
    private ILGenerator generator;
    private List`1<Reference> ilmarkers;
    private List`1<Statement> stmts;
    private bool isEmpty;
    public ILGenerator Generator { get; }
    internal bool IsEmpty { get; }
    protected AbstractCodeBuilder(ILGenerator generator);
    public ILGenerator get_Generator();
    internal bool get_IsEmpty();
    public AbstractCodeBuilder AddExpression(Expression expression);
    public AbstractCodeBuilder AddStatement(Statement stmt);
    public LocalReference DeclareLocal(Type type);
    public void SetNonEmpty();
    internal void Generate(IMemberEmitter member, ILGenerator il);
}
internal class Castle.DynamicProxy.Generators.Emitters.CodeBuilders.ConstructorCodeBuilder : AbstractCodeBuilder {
    private Type baseType;
    public ConstructorCodeBuilder(Type baseType, ILGenerator generator);
    public void InvokeBaseConstructor();
    public void InvokeBaseConstructor(ConstructorInfo constructor);
    public void InvokeBaseConstructor(ConstructorInfo constructor, ArgumentReference[] arguments);
}
internal class Castle.DynamicProxy.Generators.Emitters.CodeBuilders.MethodCodeBuilder : AbstractCodeBuilder {
    public MethodCodeBuilder(ILGenerator generator);
}
internal class Castle.DynamicProxy.Generators.Emitters.ConstructorCollection : Collection`1<ConstructorEmitter> {
}
internal class Castle.DynamicProxy.Generators.Emitters.ConstructorEmitter : object {
    private ConstructorBuilder builder;
    private AbstractTypeEmitter maintype;
    private ConstructorCodeBuilder constructorCodeBuilder;
    public ConstructorCodeBuilder CodeBuilder { get; }
    public ConstructorBuilder ConstructorBuilder { get; }
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    private bool ImplementedByRuntime { get; }
    protected internal ConstructorEmitter(AbstractTypeEmitter maintype, ConstructorBuilder builder);
    internal ConstructorEmitter(AbstractTypeEmitter maintype, ArgumentReference[] arguments);
    public virtual ConstructorCodeBuilder get_CodeBuilder();
    public ConstructorBuilder get_ConstructorBuilder();
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    private bool get_ImplementedByRuntime();
    public virtual void EnsureValidCodeBlock();
    public virtual void Generate();
}
internal class Castle.DynamicProxy.Generators.Emitters.EventCollection : Collection`1<EventEmitter> {
}
internal class Castle.DynamicProxy.Generators.Emitters.EventEmitter : object {
    private EventBuilder eventBuilder;
    private Type type;
    private AbstractTypeEmitter typeEmitter;
    private MethodEmitter addMethod;
    private MethodEmitter removeMethod;
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    public EventEmitter(AbstractTypeEmitter typeEmitter, string name, EventAttributes attributes, Type type);
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    public MethodEmitter CreateAddMethod(string addMethodName, MethodAttributes attributes, MethodInfo methodToOverride);
    public MethodEmitter CreateRemoveMethod(string removeMethodName, MethodAttributes attributes, MethodInfo methodToOverride);
    public sealed virtual void EnsureValidCodeBlock();
    public sealed virtual void Generate();
}
internal class Castle.DynamicProxy.Generators.Emitters.GenericUtil : object {
    public static GenericTypeParameterBuilder[] CopyGenericArguments(MethodInfo methodToCopyGenericsFrom, TypeBuilder builder, Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType);
    public static GenericTypeParameterBuilder[] CopyGenericArguments(MethodInfo methodToCopyGenericsFrom, MethodBuilder builder, Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType);
    public static Type ExtractCorrectType(Type paramType, Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType);
    public static Type[] ExtractParametersTypes(ParameterInfo[] baseMethodParameters, Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType);
    public static Dictionary`2<string, GenericTypeParameterBuilder> GetGenericArgumentsMap(AbstractTypeEmitter parentEmitter);
    private static Type AdjustConstraintToNewGenericParameters(Type constraint, MethodInfo methodToCopyGenericsFrom, Type[] originalGenericParameters, GenericTypeParameterBuilder[] newGenericParameters);
    private static Type[] AdjustGenericConstraints(MethodInfo methodToCopyGenericsFrom, GenericTypeParameterBuilder[] newGenericParameters, Type[] originalGenericArguments, Type[] constraints);
    private static GenericTypeParameterBuilder[] CopyGenericArguments(MethodInfo methodToCopyGenericsFrom, Dictionary`2<string, GenericTypeParameterBuilder> name2GenericType, ApplyGenArgs genericParameterGenerator);
    private static void CopyNonInheritableAttributes(GenericTypeParameterBuilder newGenericParameter, Type originalGenericArgument);
    private static String[] GetArgumentNames(Type[] originalGenericArguments);
}
internal interface Castle.DynamicProxy.Generators.Emitters.IMemberEmitter {
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    public abstract virtual MemberInfo get_Member();
    public abstract virtual Type get_ReturnType();
    public abstract virtual void EnsureValidCodeBlock();
    public abstract virtual void Generate();
}
[DefaultMemberAttribute("Item")]
internal class Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary : Dictionary`2<Type, OpCode> {
    private static LdcOpCodesDictionary dict;
    private static OpCode emptyOpCode;
    public OpCode Item { get; }
    public static OpCode EmptyOpCode { get; }
    public static LdcOpCodesDictionary Instance { get; }
    private static LdcOpCodesDictionary();
    public OpCode get_Item(Type type);
    public static OpCode get_EmptyOpCode();
    public static LdcOpCodesDictionary get_Instance();
}
[DefaultMemberAttribute("Item")]
internal class Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary : Dictionary`2<Type, OpCode> {
    private static LdindOpCodesDictionary dict;
    private static OpCode emptyOpCode;
    public OpCode Item { get; }
    public static OpCode EmptyOpCode { get; }
    public static LdindOpCodesDictionary Instance { get; }
    private static LdindOpCodesDictionary();
    public OpCode get_Item(Type type);
    public static OpCode get_EmptyOpCode();
    public static LdindOpCodesDictionary get_Instance();
}
internal class Castle.DynamicProxy.Generators.Emitters.MethodCollection : Collection`1<MethodEmitter> {
}
[DebuggerDisplayAttribute("{builder.Name}")]
internal class Castle.DynamicProxy.Generators.Emitters.MethodEmitter : object {
    private MethodBuilder builder;
    private GenericTypeParameterBuilder[] genericTypeParams;
    private ArgumentReference[] arguments;
    private MethodCodeBuilder codebuilder;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type[]> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type[]> CS$<>9__CachedAnonymousMethodDelegate3;
    public ArgumentReference[] Arguments { get; }
    public MethodCodeBuilder CodeBuilder { get; }
    public GenericTypeParameterBuilder[] GenericTypeParams { get; }
    public MethodBuilder MethodBuilder { get; }
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    private bool ImplementedByRuntime { get; }
    protected internal MethodEmitter(MethodBuilder builder);
    internal MethodEmitter(AbstractTypeEmitter owner, string name, MethodAttributes attributes);
    internal MethodEmitter(AbstractTypeEmitter owner, string name, MethodAttributes attributes, Type returnType, Type[] argumentTypes);
    internal MethodEmitter(AbstractTypeEmitter owner, string name, MethodAttributes attributes, MethodInfo methodToUseAsATemplate);
    public ArgumentReference[] get_Arguments();
    public virtual MethodCodeBuilder get_CodeBuilder();
    public GenericTypeParameterBuilder[] get_GenericTypeParams();
    public MethodBuilder get_MethodBuilder();
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    private bool get_ImplementedByRuntime();
    public void DefineCustomAttribute(CustomAttributeBuilder attribute);
    public void SetParameters(Type[] paramTypes);
    public virtual void EnsureValidCodeBlock();
    public virtual void Generate();
    private void DefineParameters(ParameterInfo[] parameters);
    private void SetReturnType(Type returnType);
    private void SetSignature(Type returnType, ParameterInfo returnParameter, Type[] parameters, ParameterInfo[] baseMethodParameters);
    [CompilerGeneratedAttribute]
private static Type[] <SetSignature>b__0(ParameterInfo x);
    [CompilerGeneratedAttribute]
private static Type[] <SetSignature>b__1(ParameterInfo x);
}
internal class Castle.DynamicProxy.Generators.Emitters.NestedClassCollection : Collection`1<NestedClassEmitter> {
}
internal class Castle.DynamicProxy.Generators.Emitters.NestedClassEmitter : AbstractTypeEmitter {
    public NestedClassEmitter(AbstractTypeEmitter maintype, string name, Type baseType, Type[] interfaces);
    public NestedClassEmitter(AbstractTypeEmitter maintype, string name, TypeAttributes attributes, Type baseType, Type[] interfaces);
    public NestedClassEmitter(AbstractTypeEmitter maintype, TypeBuilder typeBuilder);
    private static TypeBuilder CreateTypeBuilder(AbstractTypeEmitter maintype, string name, TypeAttributes attributes, Type baseType, Type[] interfaces);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.OpCodeUtil : object {
    public static void EmitLoadIndirectOpCodeForType(ILGenerator gen, Type type);
    public static void EmitLoadOpCodeForConstantValue(ILGenerator gen, object value);
    public static void EmitLoadOpCodeForDefaultValueOfType(ILGenerator gen, Type type);
    public static void EmitStoreIndirectOpCodeForType(ILGenerator gen, Type type);
    private static Type GetUnderlyingTypeOfEnum(Type enumType);
    private static bool Is64BitTypeLoadedAsInt32(Type type);
}
internal class Castle.DynamicProxy.Generators.Emitters.PropertiesCollection : Collection`1<PropertyEmitter> {
}
internal class Castle.DynamicProxy.Generators.Emitters.PropertyEmitter : object {
    private PropertyBuilder builder;
    private AbstractTypeEmitter parentTypeEmitter;
    private MethodEmitter getMethod;
    private MethodEmitter setMethod;
    public MemberInfo Member { get; }
    public Type ReturnType { get; }
    public PropertyEmitter(AbstractTypeEmitter parentTypeEmitter, string name, PropertyAttributes attributes, Type propertyType, Type[] arguments);
    public sealed virtual MemberInfo get_Member();
    public sealed virtual Type get_ReturnType();
    public MethodEmitter CreateGetMethod(string name, MethodAttributes attrs, MethodInfo methodToOverride, Type[] parameters);
    public MethodEmitter CreateGetMethod(string name, MethodAttributes attributes, MethodInfo methodToOverride);
    public MethodEmitter CreateSetMethod(string name, MethodAttributes attrs, MethodInfo methodToOverride, Type[] parameters);
    public MethodEmitter CreateSetMethod(string name, MethodAttributes attributes, MethodInfo methodToOverride);
    public void DefineCustomAttribute(CustomAttributeBuilder attribute);
    public sealed virtual void EnsureValidCodeBlock();
    public sealed virtual void Generate();
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AddressOfReferenceExpression : Expression {
    private Reference reference;
    public AddressOfReferenceExpression(Reference reference);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("argument {Type}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ArgumentReference : TypeReference {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    internal int Position { get; internal set; }
    public ArgumentReference(Type argumentType);
    public ArgumentReference(Type argumentType, int position);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(int value);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AssignArgumentStatement : Statement {
    private ArgumentReference argument;
    private Expression expression;
    public AssignArgumentStatement(ArgumentReference argument, Expression expression);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AssignArrayStatement : Statement {
    private Reference targetArray;
    private int targetPosition;
    private Expression value;
    public AssignArrayStatement(Reference targetArray, int targetPosition, Expression value);
    public virtual void Emit(IMemberEmitter member, ILGenerator il);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AssignStatement : Statement {
    private Expression expression;
    private Reference target;
    public AssignStatement(Reference target, Expression expression);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("{reference} as {type}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.AsTypeReference : Reference {
    private Reference reference;
    private Type type;
    public AsTypeReference(Reference reference, Type type);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.BindDelegateExpression : Expression {
    private ConstructorInfo delegateCtor;
    private MethodInfo methodToBindTo;
    private Expression owner;
    public BindDelegateExpression(Type delegate, Expression owner, MethodInfo methodToBindTo, GenericTypeParameterBuilder[] genericTypeParams);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("&{localReference}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ByRefReference : TypeReference {
    private LocalReference localReference;
    public ByRefReference(LocalReference localReference);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
[DebuggerDisplayAttribute("{value}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ConstReference : TypeReference {
    private object value;
    public ConstReference(object value);
    public virtual void Generate(ILGenerator gen);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ConstructorInvocationStatement : Statement {
    private Expression[] args;
    private ConstructorInfo cmethod;
    public ConstructorInvocationStatement(ConstructorInfo method, Expression[] args);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ConvertExpression : Expression {
    private Expression right;
    private Type fromType;
    private Type target;
    public ConvertExpression(Type targetType, Expression right);
    public ConvertExpression(Type targetType, Type fromType, Expression right);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
    private static void EmitCastIfNeeded(Type from, Type target, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.DefaultValueExpression : Expression {
    private Type type;
    public DefaultValueExpression(Type type);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
    private void EmitByRef(ILGenerator gen);
    private bool IsPrimitiveOrClass(Type type);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.EndExceptionBlockStatement : Statement {
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.SimpleAST.Expression : object {
    public abstract virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ExpressionStatement : Statement {
    private Expression expression;
    public ExpressionStatement(Expression expression);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("{fieldbuilder.Name} ({fieldbuilder.FieldType})")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference : Reference {
    private FieldInfo field;
    private FieldBuilder fieldbuilder;
    private bool isStatic;
    public FieldBuilder Fieldbuilder { get; }
    public FieldInfo Reference { get; }
    public FieldReference(FieldInfo field);
    public FieldReference(FieldBuilder fieldbuilder);
    public FieldBuilder get_Fieldbuilder();
    public FieldInfo get_Reference();
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.FinallyStatement : Statement {
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.IfNullExpression : Expression {
    private IILEmitter ifNotNull;
    private IILEmitter ifNull;
    private Reference reference;
    public IfNullExpression(Reference reference, IILEmitter ifNull, IILEmitter ifNotNull);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal interface Castle.DynamicProxy.Generators.Emitters.SimpleAST.IILEmitter {
    public abstract virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("&{OwnerReference}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference : TypeReference {
    public IndirectReference(TypeReference byRefReference);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
    public static TypeReference WrapIfByRef(TypeReference reference);
    public static TypeReference[] WrapIfByRef(TypeReference[] references);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LiteralIntExpression : Expression {
    private int value;
    public LiteralIntExpression(int value);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LoadArrayElementExpression : Expression {
    private Reference arrayReference;
    private ConstReference index;
    private Type returnType;
    public LoadArrayElementExpression(int index, Reference arrayReference, Type returnType);
    public LoadArrayElementExpression(ConstReference index, Reference arrayReference, Type returnType);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LoadRefArrayElementExpression : Expression {
    private Reference arrayReference;
    private ConstReference index;
    public LoadRefArrayElementExpression(int index, Reference arrayReference);
    public LoadRefArrayElementExpression(ConstReference index, Reference arrayReference);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("local {Type}")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.LocalReference : TypeReference {
    private LocalBuilder localbuilder;
    public LocalReference(Type type);
    public virtual void Generate(ILGenerator gen);
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.MethodInvocationExpression : Expression {
    protected Expression[] args;
    protected MethodInfo method;
    protected Reference owner;
    [CompilerGeneratedAttribute]
private bool <VirtualCall>k__BackingField;
    public bool VirtualCall { get; public set; }
    public MethodInvocationExpression(MethodInfo method, Expression[] args);
    public MethodInvocationExpression(MethodEmitter method, Expression[] args);
    public MethodInvocationExpression(Reference owner, MethodEmitter method, Expression[] args);
    public MethodInvocationExpression(Reference owner, MethodInfo method, Expression[] args);
    [CompilerGeneratedAttribute]
public bool get_VirtualCall();
    [CompilerGeneratedAttribute]
public void set_VirtualCall(bool value);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.MethodTokenExpression : Expression {
    private MethodInfo method;
    private Type declaringType;
    public MethodTokenExpression(MethodInfo method);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.MultiStatementExpression : Expression {
    private List`1<Statement> statements;
    public void AddStatement(Statement statement);
    public void AddExpression(Expression expression);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression : Expression {
    private Type arrayType;
    private int size;
    public NewArrayExpression(int size, Type arrayType);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewInstanceExpression : Expression {
    private Expression[] arguments;
    private Type[] constructorArgs;
    private Type type;
    private ConstructorInfo constructor;
    public NewInstanceExpression(ConstructorInfo constructor, Expression[] args);
    public NewInstanceExpression(Type target, Type[] constructor_args, Expression[] args);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NopStatement : Statement {
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NullCoalescingOperatorExpression : Expression {
    private Expression default;
    private Expression expression;
    public NullCoalescingOperatorExpression(Expression expression, Expression default);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.NullExpression : Expression {
    public static NullExpression Instance;
    private static NullExpression();
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.SimpleAST.Reference : object {
    protected Reference owner;
    public Reference OwnerReference { get; public set; }
    protected Reference(Reference owner);
    public Reference get_OwnerReference();
    public void set_OwnerReference(Reference value);
    public abstract virtual void LoadAddressOfReference(ILGenerator gen);
    public abstract virtual void LoadReference(ILGenerator gen);
    public abstract virtual void StoreReference(ILGenerator gen);
    public virtual void Generate(ILGenerator gen);
    public virtual Expression ToAddressOfExpression();
    public virtual Expression ToExpression();
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferenceExpression : Expression {
    private Reference reference;
    public ReferenceExpression(Reference reference);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression : Expression {
    private TypeReference[] args;
    public ReferencesToObjectArrayExpression(TypeReference[] args);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReturnStatement : Statement {
    private Expression expression;
    private Reference reference;
    public ReturnStatement(Reference reference);
    public ReturnStatement(Expression expression);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DebuggerDisplayAttribute("this")]
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.SelfReference : Reference {
    public static SelfReference Self;
    private static SelfReference();
    public virtual void LoadAddressOfReference(ILGenerator gen);
    public virtual void LoadReference(ILGenerator gen);
    public virtual void StoreReference(ILGenerator gen);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.SimpleAST.Statement : object {
    public abstract virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.ThrowStatement : Statement {
    private string errorMessage;
    private Type exceptionType;
    public ThrowStatement(Type exceptionType, string errorMessage);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.TryStatement : Statement {
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
internal abstract class Castle.DynamicProxy.Generators.Emitters.SimpleAST.TypeReference : Reference {
    private Type type;
    public Type Type { get; }
    protected TypeReference(Type argumentType);
    protected TypeReference(Reference owner, Type type);
    public Type get_Type();
}
internal class Castle.DynamicProxy.Generators.Emitters.SimpleAST.TypeTokenExpression : Expression {
    private Type type;
    public TypeTokenExpression(Type type);
    public virtual void Emit(IMemberEmitter member, ILGenerator gen);
}
[DefaultMemberAttribute("Item")]
internal class Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary : Dictionary`2<Type, OpCode> {
    private static StindOpCodesDictionary dict;
    private static OpCode emptyOpCode;
    public OpCode Item { get; }
    public static OpCode EmptyOpCode { get; }
    public static StindOpCodesDictionary Instance { get; }
    private static StindOpCodesDictionary();
    public OpCode get_Item(Type type);
    public static OpCode get_EmptyOpCode();
    public static StindOpCodesDictionary get_Instance();
}
[ExtensionAttribute]
internal static class Castle.DynamicProxy.Generators.Emitters.StrongNameUtil : object {
    private static IDictionary`2<Assembly, bool> signedAssemblyCache;
    private static object lockObject;
    [CompilerGeneratedAttribute]
private static bool <CanStrongNameAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public static bool CanStrongNameAssembly { get; public set; }
    private static StrongNameUtil();
    [ExtensionAttribute]
public static bool IsAssemblySigned(Assembly assembly);
    [ExtensionAttribute]
private static bool ContainsPublicKey(Assembly assembly);
    public static bool IsAnyTypeFromUnsignedAssembly(IEnumerable`1<Type> types);
    public static bool IsAnyTypeFromUnsignedAssembly(Type baseType, IEnumerable`1<Type> interfaces);
    [CompilerGeneratedAttribute]
public static bool get_CanStrongNameAssembly();
    [CompilerGeneratedAttribute]
public static void set_CanStrongNameAssembly(bool value);
    [CompilerGeneratedAttribute]
private static bool <IsAnyTypeFromUnsignedAssembly>b__0(Type t);
}
internal class Castle.DynamicProxy.Generators.Emitters.TypeConstructorEmitter : ConstructorEmitter {
    internal TypeConstructorEmitter(AbstractTypeEmitter maintype);
    public virtual void EnsureValidCodeBlock();
}
internal class Castle.DynamicProxy.Generators.GeneratorException : Exception {
    public GeneratorException(string message);
    public GeneratorException(string message, Exception innerException);
    public GeneratorException(SerializationInfo info, StreamingContext context);
}
internal static class Castle.DynamicProxy.Generators.GeneratorUtil : object {
    public static void CopyOutAndRefParameters(TypeReference[] dereferencedArguments, LocalReference invocation, MethodInfo method, MethodEmitter emitter);
    private static ConvertExpression Argument(int i, LocalReference invocationArgs, TypeReference[] arguments);
    private static AssignStatement AssignArgument(TypeReference[] dereferencedArguments, int i, LocalReference invocationArgs);
    private static AssignStatement GetArguments(LocalReference invocationArgs, LocalReference invocation);
    private static LocalReference StoreInvocationArgumentsInLocal(MethodEmitter emitter, LocalReference invocation);
}
internal interface Castle.DynamicProxy.Generators.IGenerator`1 {
    public abstract virtual T Generate(ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
}
internal interface Castle.DynamicProxy.Generators.IInvocationCreationContributor {
    public abstract virtual ConstructorEmitter CreateConstructor(ArgumentReference[] baseCtorArguments, AbstractTypeEmitter invocation);
    public abstract virtual MethodInfo GetCallbackMethod();
    public abstract virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, Expression[] args, Reference targetField, MethodEmitter invokeMethodOnTarget);
    public abstract virtual Expression[] GetConstructorInvocationArguments(Expression[] arguments, ClassEmitter proxy);
}
internal interface Castle.DynamicProxy.Generators.INamingScope {
    public INamingScope ParentScope { get; }
    public abstract virtual INamingScope get_ParentScope();
    public abstract virtual string GetUniqueName(string suggestedName);
    public abstract virtual INamingScope SafeSubScope();
}
internal class Castle.DynamicProxy.Generators.InheritanceInvocationTypeGenerator : InvocationTypeGenerator {
    public static Type BaseType;
    public InheritanceInvocationTypeGenerator(Type targetType, MetaMethod method, MethodInfo callback, IInvocationCreationContributor contributor);
    private static InheritanceInvocationTypeGenerator();
    protected virtual ArgumentReference[] GetBaseCtorArguments(Type targetFieldType, ProxyGenerationOptions proxyGenerationOptions, ConstructorInfo& baseConstructor);
    protected virtual Type GetBaseType();
    protected virtual FieldReference GetTargetReference();
}
internal class Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator : InterfaceProxyWithTargetGenerator {
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegateb;
    protected string GeneratorType { get; }
    public InterfaceProxyWithoutTargetGenerator(ModuleScope scope, Type interface);
    protected virtual string get_GeneratorType();
    protected virtual ITypeContributor AddMappingForTargetType(IDictionary`2<Type, ITypeContributor> interfaceTypeImplementerMapping, Type proxyTargetType, ICollection`1<Type> targetInterfaces, ICollection`1<Type> additionalInterfaces, INamingScope namingScope);
    protected virtual Type GenerateType(string typeName, Type proxyTargetType, Type[] interfaces, INamingScope namingScope);
    [CompilerGeneratedAttribute]
private static Expression <AddMappingForTargetType>b__a(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator : BaseProxyGenerator {
    protected FieldReference targetField;
    [CompilerGeneratedAttribute]
private static GetTargetExpressionDelegate CS$<>9__CachedAnonymousMethodDelegate6;
    protected bool AllowChangeTarget { get; }
    protected string GeneratorType { get; }
    public InterfaceProxyWithTargetGenerator(ModuleScope scope, Type interface);
    protected virtual bool get_AllowChangeTarget();
    protected virtual string get_GeneratorType();
    public Type GenerateCode(Type proxyTargetType, Type[] interfaces, ProxyGenerationOptions options);
    protected virtual ITypeContributor AddMappingForTargetType(IDictionary`2<Type, ITypeContributor> typeImplementerMapping, Type proxyTargetType, ICollection`1<Type> targetInterfaces, ICollection`1<Type> additionalInterfaces, INamingScope namingScope);
    protected virtual void CreateTypeAttributes(ClassEmitter emitter);
    protected virtual Type GenerateType(string typeName, Type proxyTargetType, Type[] interfaces, INamingScope namingScope);
    protected virtual InterfaceProxyWithoutTargetContributor GetContributorForAdditionalInterfaces(INamingScope namingScope);
    protected virtual IEnumerable`1<Type> GetTypeImplementerMapping(Type[] interfaces, Type proxyTargetType, IEnumerable`1& contributors, INamingScope namingScope);
    protected virtual Type Init(string typeName, ClassEmitter& emitter, Type proxyTargetType, FieldReference& interceptorsField, IEnumerable`1<Type> interfaces);
    private void CreateFields(ClassEmitter emitter, Type proxyTargetType);
    private void EnsureValidBaseType(Type type);
    private bool ImplementedByTarget(ICollection`1<Type> targetInterfaces, Type interface);
    private void ThrowInvalidBaseType(Type type, string doesNotHaveAccessibleParameterlessConstructor);
    [CompilerGeneratedAttribute]
private static Expression <GetContributorForAdditionalInterfaces>b__5(ClassEmitter c, MethodInfo m);
}
internal class Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator : InterfaceProxyWithTargetGenerator {
    protected bool AllowChangeTarget { get; }
    protected string GeneratorType { get; }
    public InterfaceProxyWithTargetInterfaceGenerator(ModuleScope scope, Type interface);
    protected virtual bool get_AllowChangeTarget();
    protected virtual string get_GeneratorType();
    protected virtual ITypeContributor AddMappingForTargetType(IDictionary`2<Type, ITypeContributor> typeImplementerMapping, Type proxyTargetType, ICollection`1<Type> targetInterfaces, ICollection`1<Type> additionalInterfaces, INamingScope namingScope);
    protected virtual InterfaceProxyWithoutTargetContributor GetContributorForAdditionalInterfaces(INamingScope namingScope);
    private Reference GetTarget(ClassEmitter class, MethodInfo method);
    private Expression GetTargetExpression(ClassEmitter class, MethodInfo method);
}
internal abstract class Castle.DynamicProxy.Generators.InvocationTypeGenerator : object {
    protected MetaMethod method;
    protected Type targetType;
    private MethodInfo callback;
    private bool canChangeTarget;
    private IInvocationCreationContributor contributor;
    protected InvocationTypeGenerator(Type targetType, MetaMethod method, MethodInfo callback, bool canChangeTarget, IInvocationCreationContributor contributor);
    protected abstract virtual ArgumentReference[] GetBaseCtorArguments(Type targetFieldType, ProxyGenerationOptions proxyGenerationOptions, ConstructorInfo& baseConstructor);
    protected abstract virtual Type GetBaseType();
    protected abstract virtual FieldReference GetTargetReference();
    public sealed virtual AbstractTypeEmitter Generate(ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    protected virtual MethodInvocationExpression GetCallbackMethodInvocation(AbstractTypeEmitter invocation, Expression[] args, MethodInfo callbackMethod, Reference targetField, MethodEmitter invokeMethodOnTarget);
    protected virtual void ImplementInvokeMethodOnTarget(AbstractTypeEmitter invocation, ParameterInfo[] parameters, MethodEmitter invokeMethodOnTarget, Reference targetField);
    private void AssignBackByRefArguments(MethodEmitter invokeMethodOnTarget, Dictionary`2<int, LocalReference> byRefArguments);
    private void CreateConstructor(AbstractTypeEmitter invocation, ProxyGenerationOptions options);
    private ConstructorEmitter CreateConstructor(AbstractTypeEmitter invocation, ArgumentReference[] baseCtorArguments);
    private AbstractCodeBuilder EmitCallEnsureValidTarget(MethodEmitter invokeMethodOnTarget);
    private void EmitCallThrowOnNoTarget(MethodEmitter invokeMethodOnTarget);
    private MethodInfo GetCallbackMethod(AbstractTypeEmitter invocation);
    private AbstractTypeEmitter GetEmitter(ClassEmitter class, Type[] interfaces, INamingScope namingScope, MethodInfo methodInfo);
    private void ImplemementInvokeMethodOnTarget(AbstractTypeEmitter invocation, ParameterInfo[] parameters, FieldReference targetField, MethodInfo callbackMethod);
    private void ImplementChangeInvocationTarget(AbstractTypeEmitter invocation, FieldReference targetField);
    private void ImplementChangeProxyTarget(AbstractTypeEmitter invocation, ClassEmitter class);
    private void ImplementChangeProxyTargetInterface(ClassEmitter class, AbstractTypeEmitter invocation, FieldReference targetField);
}
internal class Castle.DynamicProxy.Generators.MetaEvent : MetaTypeElement {
    private MetaMethod adder;
    private MetaMethod remover;
    private Type type;
    private EventEmitter emitter;
    private string name;
    [CompilerGeneratedAttribute]
private EventAttributes <Attributes>k__BackingField;
    public MetaMethod Adder { get; }
    public EventAttributes Attributes { get; private set; }
    public EventEmitter Emitter { get; }
    public MetaMethod Remover { get; }
    public MetaEvent(string name, Type declaringType, Type eventDelegateType, MetaMethod adder, MetaMethod remover, EventAttributes attributes);
    public MetaMethod get_Adder();
    [CompilerGeneratedAttribute]
public EventAttributes get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(EventAttributes value);
    public EventEmitter get_Emitter();
    public MetaMethod get_Remover();
    public void BuildEventEmitter(ClassEmitter classEmitter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetaEvent other);
    internal virtual void SwitchToExplicitImplementation();
}
[DebuggerDisplayAttribute("{Method}")]
internal class Castle.DynamicProxy.Generators.MetaMethod : MetaTypeElement {
    private static MethodAttributes ExplicitImplementationAttributes;
    private string name;
    [CompilerGeneratedAttribute]
private MethodAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <MethodOnTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Proxyable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Standalone>k__BackingField;
    public MethodAttributes Attributes { get; private set; }
    public bool HasTarget { get; private set; }
    public MethodInfo Method { get; private set; }
    public MethodInfo MethodOnTarget { get; private set; }
    public string Name { get; }
    public bool Proxyable { get; private set; }
    public bool Standalone { get; private set; }
    public MetaMethod(MethodInfo method, MethodInfo methodOnTarget, bool standalone, bool proxyable, bool hasTarget);
    [CompilerGeneratedAttribute]
public MethodAttributes get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(MethodAttributes value);
    [CompilerGeneratedAttribute]
public bool get_HasTarget();
    [CompilerGeneratedAttribute]
private void set_HasTarget(bool value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_MethodOnTarget();
    [CompilerGeneratedAttribute]
private void set_MethodOnTarget(MethodInfo value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_Proxyable();
    [CompilerGeneratedAttribute]
private void set_Proxyable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Standalone();
    [CompilerGeneratedAttribute]
private void set_Standalone(bool value);
    public sealed virtual bool Equals(MetaMethod other);
    internal virtual void SwitchToExplicitImplementation();
    private MethodAttributes ObtainAttributes();
}
internal class Castle.DynamicProxy.Generators.MetaProperty : MetaTypeElement {
    private Type[] arguments;
    private PropertyAttributes attributes;
    private IEnumerable`1<CustomAttributeBuilder> customAttributes;
    private MetaMethod getter;
    private MetaMethod setter;
    private Type type;
    private PropertyEmitter emitter;
    private string name;
    public Type[] Arguments { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public PropertyEmitter Emitter { get; }
    public MethodInfo GetMethod { get; }
    public MetaMethod Getter { get; }
    public MethodInfo SetMethod { get; }
    public MetaMethod Setter { get; }
    public MetaProperty(string name, Type propertyType, Type declaringType, MetaMethod getter, MetaMethod setter, IEnumerable`1<CustomAttributeBuilder> customAttributes, Type[] arguments);
    public Type[] get_Arguments();
    public bool get_CanRead();
    public bool get_CanWrite();
    public PropertyEmitter get_Emitter();
    public MethodInfo get_GetMethod();
    public MetaMethod get_Getter();
    public MethodInfo get_SetMethod();
    public MetaMethod get_Setter();
    public void BuildPropertyEmitter(ClassEmitter classEmitter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetaProperty other);
    internal virtual void SwitchToExplicitImplementation();
}
internal class Castle.DynamicProxy.Generators.MetaType : object {
    private ICollection`1<MetaEvent> events;
    private ICollection`1<MetaMethod> methods;
    private ICollection`1<MetaProperty> properties;
    public IEnumerable`1<MetaEvent> Events { get; }
    public IEnumerable`1<MetaMethod> Methods { get; }
    public IEnumerable`1<MetaProperty> Properties { get; }
    public IEnumerable`1<MetaEvent> get_Events();
    public IEnumerable`1<MetaMethod> get_Methods();
    public IEnumerable`1<MetaProperty> get_Properties();
    public void AddEvent(MetaEvent event);
    public void AddMethod(MetaMethod method);
    public void AddProperty(MetaProperty property);
}
internal abstract class Castle.DynamicProxy.Generators.MetaTypeElement : object {
    protected Type sourceType;
    internal bool CanBeImplementedExplicitly { get; }
    protected MetaTypeElement(Type sourceType);
    internal bool get_CanBeImplementedExplicitly();
    internal abstract virtual void SwitchToExplicitImplementation();
}
internal class Castle.DynamicProxy.Generators.MethodFinder : object {
    private static Dictionary`2<Type, object> cachedMethodInfosByType;
    private static object lockObject;
    private static MethodFinder();
    public static MethodInfo[] GetAllInstanceMethods(Type type, BindingFlags flags);
    private static MethodInfo[] MakeFilteredCopy(MethodInfo[] methodsInCache, BindingFlags visibilityFlags);
    private static object RemoveDuplicates(MethodInfo[] infos);
}
internal abstract class Castle.DynamicProxy.Generators.MethodGenerator : object {
    private MetaMethod method;
    private OverrideMethodDelegate overrideMethod;
    protected MethodInfo MethodOnTarget { get; }
    protected MethodInfo MethodToOverride { get; }
    protected MethodGenerator(MetaMethod method, OverrideMethodDelegate overrideMethod);
    protected MethodInfo get_MethodOnTarget();
    protected MethodInfo get_MethodToOverride();
    protected abstract virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    public sealed virtual MethodEmitter Generate(ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
}
internal class Castle.DynamicProxy.Generators.MethodSignatureComparer : object {
    public static MethodSignatureComparer Instance;
    private static MethodSignatureComparer();
    public bool EqualGenericParameters(MethodInfo x, MethodInfo y);
    public bool EqualParameters(MethodInfo x, MethodInfo y);
    public bool EqualSignatureTypes(Type x, Type y);
    public sealed virtual bool Equals(MethodInfo x, MethodInfo y);
    public sealed virtual int GetHashCode(MethodInfo obj);
    private bool EqualNames(MethodInfo x, MethodInfo y);
}
internal class Castle.DynamicProxy.Generators.MethodWithInvocationGenerator : MethodGenerator {
    private IInvocationCreationContributor contributor;
    private GetTargetExpressionDelegate getTargetExpression;
    private Reference interceptors;
    private Type invocation;
    [CompilerGeneratedAttribute]
private static Predicate`1<Type> CS$<>9__CachedAnonymousMethodDelegate2;
    public MethodWithInvocationGenerator(MetaMethod method, Reference interceptors, Type invocation, GetTargetExpressionDelegate getTargetExpression, OverrideMethodDelegate createMethod, IInvocationCreationContributor contributor);
    protected FieldReference BuildMethodInterceptorsField(ClassEmitter class, MethodInfo method, INamingScope namingScope);
    protected virtual MethodEmitter BuildProxiedMethodBody(MethodEmitter emitter, ClassEmitter class, ProxyGenerationOptions options, INamingScope namingScope);
    private Expression SetMethodInterceptors(ClassEmitter class, INamingScope namingScope, MethodEmitter emitter, Expression proxiedMethodTokenExpression);
    private void EmitLoadGenricMethodArguments(MethodEmitter methodEmitter, MethodInfo method, Reference invocationLocal);
    private Expression[] GetCtorArguments(ClassEmitter class, Expression proxiedMethodTokenExpression, TypeReference[] dereferencedArguments, Expression methodInterceptors);
    private Expression[] ModifyArguments(ClassEmitter class, Expression[] arguments);
    private bool HasByRefArguments(ArgumentReference[] arguments);
    [CompilerGeneratedAttribute]
private static bool <EmitLoadGenricMethodArguments>b__1(Type t);
}
internal class Castle.DynamicProxy.Generators.NamingScope : object {
    private IDictionary`2<string, int> names;
    private INamingScope parentScope;
    public INamingScope ParentScope { get; }
    private NamingScope(INamingScope parent);
    public sealed virtual INamingScope get_ParentScope();
    public sealed virtual string GetUniqueName(string suggestedName);
    public sealed virtual INamingScope SafeSubScope();
}
internal class Castle.DynamicProxy.Generators.TypeElementCollection`1 : object {
    private ICollection`1<TElement> items;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TElement>.IsReadOnly { get; }
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TElement>.get_IsReadOnly();
    public sealed virtual void Add(TElement item);
    public sealed virtual bool Contains(TElement item);
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<TElement>.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<TElement>.CopyTo(TElement[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<TElement>.Remove(TElement item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal interface Castle.DynamicProxy.IAttributeDisassembler {
    public abstract virtual CustomAttributeBuilder Disassemble(Attribute attribute);
}
internal interface Castle.DynamicProxy.IChangeProxyTarget {
    public abstract virtual void ChangeInvocationTarget(object target);
    public abstract virtual void ChangeProxyTarget(object target);
}
public interface Castle.DynamicProxy.IInterceptor {
    public abstract virtual void Intercept(IInvocation invocation);
}
public interface Castle.DynamicProxy.IInterceptorSelector {
    public abstract virtual IInterceptor[] SelectInterceptors(Type type, MethodInfo method, IInterceptor[] interceptors);
}
public interface Castle.DynamicProxy.IInvocation {
    public Object[] Arguments { get; }
    public Type[] GenericArguments { get; }
    public object InvocationTarget { get; }
    public MethodInfo Method { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public object Proxy { get; }
    public object ReturnValue { get; public set; }
    public Type TargetType { get; }
    public abstract virtual Object[] get_Arguments();
    public abstract virtual Type[] get_GenericArguments();
    public abstract virtual object get_InvocationTarget();
    public abstract virtual MethodInfo get_Method();
    public abstract virtual MethodInfo get_MethodInvocationTarget();
    public abstract virtual object get_Proxy();
    public abstract virtual object get_ReturnValue();
    public abstract virtual void set_ReturnValue(object value);
    public abstract virtual Type get_TargetType();
    public abstract virtual object GetArgumentValue(int index);
    public abstract virtual MethodInfo GetConcreteMethod();
    public abstract virtual MethodInfo GetConcreteMethodInvocationTarget();
    public abstract virtual void Proceed();
    public abstract virtual void SetArgumentValue(int index, object value);
}
[ExtensionAttribute]
internal static class Castle.DynamicProxy.Internal.AttributeUtil : object {
    private static IDictionary`2<Type, IAttributeDisassembler> disassemblers;
    private static IAttributeDisassembler fallbackDisassembler;
    public static IAttributeDisassembler FallbackDisassembler { get; public set; }
    private static AttributeUtil();
    public static IAttributeDisassembler get_FallbackDisassembler();
    public static void set_FallbackDisassembler(IAttributeDisassembler value);
    public static void AddDisassembler(IAttributeDisassembler disassembler);
    public static CustomAttributeBuilder CreateBuilder(CustomAttributeData attribute);
    private static Object[] GetArguments(IList`1<CustomAttributeTypedArgument> constructorArguments);
    private static object ReadAttributeValue(CustomAttributeTypedArgument argument);
    private static void GetSettersAndFields(IEnumerable`1<CustomAttributeNamedArgument> namedArguments, PropertyInfo[]& properties, Object[]& propertyValues, FieldInfo[]& fields, Object[]& fieldValues);
    [ExtensionAttribute]
public static IEnumerable`1<CustomAttributeBuilder> GetNonInheritableAttributes(MemberInfo member);
    [ExtensionAttribute]
public static IEnumerable`1<CustomAttributeBuilder> GetNonInheritableAttributes(ParameterInfo parameter);
    private static bool ShouldSkipAttributeReplication(Type attribute);
    private static bool SpecialCaseAttributThatShouldNotBeReplicated(Type attribute);
    public static CustomAttributeBuilder CreateBuilder();
    public static CustomAttributeBuilder CreateBuilder(Type attribute, Object[] constructorArguments);
    internal static CustomAttributeBuilder CreateBuilder(Attribute attribute);
    private static Type[] GetTypes(Object[] objects);
}
public abstract class Castle.DynamicProxy.Internal.CompositionInvocation : AbstractInvocation {
    protected object target;
    public object InvocationTarget { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public Type TargetType { get; }
    protected CompositionInvocation(object target, object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    public virtual object get_InvocationTarget();
    public virtual MethodInfo get_MethodInvocationTarget();
    public virtual Type get_TargetType();
    protected void EnsureValidProxyTarget(object newTarget);
    protected void EnsureValidTarget();
}
public abstract class Castle.DynamicProxy.Internal.InheritanceInvocation : AbstractInvocation {
    private Type targetType;
    public object InvocationTarget { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public Type TargetType { get; }
    protected InheritanceInvocation(Type targetType, object proxy, IInterceptor[] interceptors, MethodInfo proxiedMethod, Object[] arguments);
    public virtual object get_InvocationTarget();
    public virtual MethodInfo get_MethodInvocationTarget();
    public virtual Type get_TargetType();
    protected abstract virtual void InvokeMethodOnTarget();
}
[ExtensionAttribute]
internal static class Castle.DynamicProxy.Internal.InternalsUtil : object {
    private static IDictionary`2<Assembly, bool> internalsToDynProxy;
    private static Lock internalsToDynProxyLock;
    private static InternalsUtil();
    [ExtensionAttribute]
public static bool IsInternal(MethodBase method);
    [ExtensionAttribute]
public static bool IsInternalToDynamicProxy(Assembly asm);
    private static bool VisibleToDynamicProxy(InternalsVisibleToAttribute attribute);
    [ExtensionAttribute]
public static bool IsAccessible(MethodBase method);
}
internal static class Castle.DynamicProxy.Internal.InvocationHelper : object {
    private static Dictionary`2<KeyValuePair`2<MethodInfo, Type>, MethodInfo> cache;
    private static Lock lock;
    private static InvocationHelper();
    public static MethodInfo GetMethodOnObject(object target, MethodInfo proxiedMethod);
    public static MethodInfo GetMethodOnType(Type type, MethodInfo proxiedMethod);
    private static MethodInfo GetFromCache(MethodInfo methodInfo, Type type);
    private static MethodInfo ObtainMethod(MethodInfo proxiedMethod, Type type);
    private static void PutToCache(MethodInfo methodInfo, Type type, MethodInfo value);
}
[ExtensionAttribute]
public static class Castle.DynamicProxy.Internal.TypeUtil : object {
    [CompilerGeneratedAttribute]
private static Comparison`1<MemberInfo> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Comparison`1<Type> CS$<>9__CachedAnonymousMethodDelegate3;
    [ExtensionAttribute]
public static FieldInfo[] GetAllFields(Type type);
    public static Type[] GetAllInterfaces(Type[] types);
    [ExtensionAttribute]
public static Type[] GetAllInterfaces(Type type);
    [ExtensionAttribute]
public static Type GetClosedParameterType(AbstractTypeEmitter type, Type parameter);
    public static Type GetTypeOrNull(object target);
    [ExtensionAttribute]
public static bool IsFinalizer(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsGetType(MethodInfo methodInfo);
    [ExtensionAttribute]
public static bool IsMemberwiseClone(MethodInfo methodInfo);
    [ExtensionAttribute]
public static void SetStaticField(Type type, string fieldName, BindingFlags additionalFlags, object value);
    public static MemberInfo[] Sort(MemberInfo[] members);
    private static bool CloseGenericParametersIfAny(AbstractTypeEmitter emitter, Type[] arguments);
    private static Type[] Sort(ICollection`1<Type> types);
    [CompilerGeneratedAttribute]
private static int <Sort>b__0(MemberInfo l, MemberInfo r);
    [CompilerGeneratedAttribute]
private static int <Sort>b__2(Type l, Type r);
}
internal class Castle.DynamicProxy.InvalidMixinConfigurationException : Exception {
    public InvalidMixinConfigurationException(string message);
    public InvalidMixinConfigurationException(string message, Exception innerException);
    protected InvalidMixinConfigurationException(SerializationInfo info, StreamingContext context);
}
internal class Castle.DynamicProxy.InvalidProxyConstructorArgumentsException : ArgumentException {
    [CompilerGeneratedAttribute]
private Type <ClassToProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ProxyType>k__BackingField;
    public Type ClassToProxy { get; private set; }
    public Type ProxyType { get; private set; }
    public InvalidProxyConstructorArgumentsException(string message, Type proxyType, Type classToProxy);
    [CompilerGeneratedAttribute]
public Type get_ClassToProxy();
    [CompilerGeneratedAttribute]
private void set_ClassToProxy(Type value);
    [CompilerGeneratedAttribute]
public Type get_ProxyType();
    [CompilerGeneratedAttribute]
private void set_ProxyType(Type value);
}
internal interface Castle.DynamicProxy.IProxyBuilder {
    public ILogger Logger { get; public set; }
    public ModuleScope ModuleScope { get; }
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual ModuleScope get_ModuleScope();
    public abstract virtual Type CreateClassProxyType(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public abstract virtual Type CreateClassProxyTypeWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public abstract virtual Type CreateInterfaceProxyTypeWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, Type targetType, ProxyGenerationOptions options);
    public abstract virtual Type CreateInterfaceProxyTypeWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    public abstract virtual Type CreateInterfaceProxyTypeWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
}
internal interface Castle.DynamicProxy.IProxyGenerationHook {
    public abstract virtual void MethodsInspected();
    public abstract virtual void NonProxyableMemberNotification(Type type, MemberInfo memberInfo);
    public abstract virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
}
public interface Castle.DynamicProxy.IProxyTargetAccessor {
    public abstract virtual object DynProxyGetTarget();
    public abstract virtual IInterceptor[] GetInterceptors();
}
internal class Castle.DynamicProxy.MixinData : object {
    private Dictionary`2<Type, int> mixinPositions;
    private List`1<object> mixinsImpl;
    [CompilerGeneratedAttribute]
private static Comparison`1<Type> CS$<>9__CachedAnonymousMethodDelegate1;
    public IEnumerable`1<Type> MixinInterfaces { get; }
    public IEnumerable`1<object> Mixins { get; }
    public MixinData(IEnumerable`1<object> mixinInstances);
    public IEnumerable`1<Type> get_MixinInterfaces();
    public IEnumerable`1<object> get_Mixins();
    public bool ContainsMixin(Type mixinInterfaceType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public object GetMixinInstance(Type mixinInterfaceType);
    public int GetMixinPosition(Type mixinInterfaceType);
    [CompilerGeneratedAttribute]
private static int <.ctor>b__0(Type x, Type y);
}
internal class Castle.DynamicProxy.ModuleScope : object {
    public static string DEFAULT_FILE_NAME;
    public static string DEFAULT_ASSEMBLY_NAME;
    private ModuleBuilder moduleBuilderWithStrongName;
    private ModuleBuilder moduleBuilder;
    private string strongAssemblyName;
    private string weakAssemblyName;
    private string strongModulePath;
    private string weakModulePath;
    private Dictionary`2<CacheKey, Type> typeCache;
    private Lock cacheLock;
    private object moduleLocker;
    private bool savePhysicalAssembly;
    private bool disableSignedModule;
    private INamingScope namingScope;
    public INamingScope NamingScope { get; }
    public Lock Lock { get; }
    public ModuleBuilder StrongNamedModule { get; }
    public string StrongNamedModuleName { get; }
    public string StrongNamedModuleDirectory { get; }
    public ModuleBuilder WeakNamedModule { get; }
    public string WeakNamedModuleName { get; }
    public string WeakNamedModuleDirectory { get; }
    public ModuleScope(bool savePhysicalAssembly);
    public ModuleScope(bool savePhysicalAssembly, bool disableSignedModule);
    public ModuleScope(bool savePhysicalAssembly, bool disableSignedModule, string strongAssemblyName, string strongModulePath, string weakAssemblyName, string weakModulePath);
    public ModuleScope(bool savePhysicalAssembly, bool disableSignedModule, INamingScope namingScope, string strongAssemblyName, string strongModulePath, string weakAssemblyName, string weakModulePath);
    private static ModuleScope();
    public INamingScope get_NamingScope();
    public Lock get_Lock();
    public Type GetFromCache(CacheKey key);
    public void RegisterInCache(CacheKey key, Type type);
    public static Byte[] GetKeyPair();
    public ModuleBuilder get_StrongNamedModule();
    public string get_StrongNamedModuleName();
    public string get_StrongNamedModuleDirectory();
    public ModuleBuilder get_WeakNamedModule();
    public string get_WeakNamedModuleName();
    public string get_WeakNamedModuleDirectory();
    public ModuleBuilder ObtainDynamicModule(bool isStrongNamed);
    public ModuleBuilder ObtainDynamicModuleWithStrongName();
    public ModuleBuilder ObtainDynamicModuleWithWeakName();
    private ModuleBuilder CreateModule(bool signStrongName);
    private AssemblyName GetAssemblyName(bool signStrongName);
    public string SaveAssembly();
    public string SaveAssembly(bool strongNamed);
    private void AddCacheMappings(AssemblyBuilder builder);
    public void LoadAssemblyIntoCache(Assembly assembly);
    public TypeBuilder DefineType(bool inSignedModulePreferably, string name, TypeAttributes flags);
}
internal class Castle.DynamicProxy.PersistentProxyBuilder : DefaultProxyBuilder {
    public string SaveAssembly();
}
internal class Castle.DynamicProxy.ProxyGenerationException : Exception {
    public ProxyGenerationException(string message);
    public ProxyGenerationException(string message, Exception innerException);
}
internal class Castle.DynamicProxy.ProxyGenerationOptions : object {
    public static ProxyGenerationOptions Default;
    private List`1<object> mixins;
    internal IList`1<Attribute> attributesToAddToGeneratedTypes;
    private IList`1<CustomAttributeBuilder> additionalAttributes;
    private MixinData mixinData;
    [CompilerGeneratedAttribute]
private IProxyGenerationHook <Hook>k__BackingField;
    [CompilerGeneratedAttribute]
private IInterceptorSelector <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BaseTypeForInterfaceProxy>k__BackingField;
    public IProxyGenerationHook Hook { get; public set; }
    public IInterceptorSelector Selector { get; public set; }
    public Type BaseTypeForInterfaceProxy { get; public set; }
    [ObsoleteAttribute("This property is obsolete and will be removed in future versions. Use AdditionalAttributes property instead. You can use AttributeUtil class to simplify creating CustomAttributeBuilder instances for common cases.")]
public IList`1<Attribute> AttributesToAddToGeneratedTypes { get; }
    public IList`1<CustomAttributeBuilder> AdditionalAttributes { get; }
    public MixinData MixinData { get; }
    public bool HasMixins { get; }
    public ProxyGenerationOptions(IProxyGenerationHook hook);
    private ProxyGenerationOptions(SerializationInfo info, StreamingContext context);
    private static ProxyGenerationOptions();
    public void Initialize();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IProxyGenerationHook get_Hook();
    [CompilerGeneratedAttribute]
public void set_Hook(IProxyGenerationHook value);
    [CompilerGeneratedAttribute]
public IInterceptorSelector get_Selector();
    [CompilerGeneratedAttribute]
public void set_Selector(IInterceptorSelector value);
    [CompilerGeneratedAttribute]
public Type get_BaseTypeForInterfaceProxy();
    [CompilerGeneratedAttribute]
public void set_BaseTypeForInterfaceProxy(Type value);
    public IList`1<Attribute> get_AttributesToAddToGeneratedTypes();
    public IList`1<CustomAttributeBuilder> get_AdditionalAttributes();
    public MixinData get_MixinData();
    public void AddMixinInstance(object instance);
    public Object[] MixinsAsArray();
    public bool get_HasMixins();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[CLSCompliantAttribute("True")]
internal class Castle.DynamicProxy.ProxyGenerator : object {
    private ILogger logger;
    private IProxyBuilder proxyBuilder;
    public ILogger Logger { get; public set; }
    public IProxyBuilder ProxyBuilder { get; }
    public ProxyGenerator(IProxyBuilder builder);
    public ProxyGenerator(bool disableSignedModule);
    private bool HasSecurityPermission();
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    public IProxyBuilder get_ProxyBuilder();
    public TInterface CreateInterfaceProxyWithTarget(TInterface target, IInterceptor[] interceptors);
    public TInterface CreateInterfaceProxyWithTarget(TInterface target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithTarget(Type interfaceToProxy, object target, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithTarget(Type interfaceToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public virtual object CreateInterfaceProxyWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    protected List`1<object> GetConstructorArguments(object target, IInterceptor[] interceptors, ProxyGenerationOptions options);
    public object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, object target, IInterceptor[] interceptors);
    public TInterface CreateInterfaceProxyWithTargetInterface(TInterface target, IInterceptor[] interceptors);
    public TInterface CreateInterfaceProxyWithTargetInterface(TInterface target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateInterfaceProxyWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public TInterface CreateInterfaceProxyWithoutTarget(IInterceptor interceptor);
    public TInterface CreateInterfaceProxyWithoutTarget(IInterceptor[] interceptors);
    public TInterface CreateInterfaceProxyWithoutTarget(ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, IInterceptor interceptor);
    public object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, IInterceptor[] interceptors);
    public object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateInterfaceProxyWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public TClass CreateClassProxyWithTarget(TClass target, IInterceptor[] interceptors);
    public TClass CreateClassProxyWithTarget(TClass target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, object target, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, object target, Object[] constructorArguments, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, object target, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateClassProxyWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, object target, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public TClass CreateClassProxy(IInterceptor[] interceptors);
    public TClass CreateClassProxy(ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, Object[] constructorArguments, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, IInterceptor[] interceptors);
    public virtual object CreateClassProxy(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options, Object[] constructorArguments, IInterceptor[] interceptors);
    protected object CreateClassProxyInstance(Type proxyType, List`1<object> proxyArguments, Type classToProxy, Object[] constructorArguments);
    protected void CheckNotGenericTypeDefinition(Type type, string argumentName);
    protected void CheckNotGenericTypeDefinitions(IEnumerable`1<Type> types, string argumentName);
    protected List`1<object> BuildArgumentListForClassProxyWithTarget(object target, ProxyGenerationOptions options, IInterceptor[] interceptors);
    protected List`1<object> BuildArgumentListForClassProxy(ProxyGenerationOptions options, IInterceptor[] interceptors);
    protected Type CreateClassProxyType(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    protected Type CreateInterfaceProxyTypeWithTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, Type targetType, ProxyGenerationOptions options);
    protected Type CreateInterfaceProxyTypeWithTargetInterface(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    protected Type CreateInterfaceProxyTypeWithoutTarget(Type interfaceToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
    protected Type CreateClassProxyTypeWithTarget(Type classToProxy, Type[] additionalInterfacesToProxy, ProxyGenerationOptions options);
}
internal class Castle.DynamicProxy.ProxyUtil : object {
    public static object GetUnproxiedInstance(object instance);
    public static Type GetUnproxiedType(object instance);
    public static bool IsProxy(object instance);
    public static bool IsProxyType(Type type);
}
[CLSCompliantAttribute("False")]
[AttributeUsageAttribute("1")]
internal class Castle.DynamicProxy.Serialization.CacheMappingsAttribute : Attribute {
    private static ConstructorInfo constructor;
    private Byte[] serializedCacheMappings;
    public Byte[] SerializedCacheMappings { get; }
    public CacheMappingsAttribute(Byte[] serializedCacheMappings);
    private static CacheMappingsAttribute();
    public Byte[] get_SerializedCacheMappings();
    public Dictionary`2<CacheKey, string> GetDeserializedMappings();
    public static void ApplyTo(AssemblyBuilder assemblyBuilder, Dictionary`2<CacheKey, string> mappings);
}
internal class Castle.DynamicProxy.Serialization.ProxyObjectReference : object {
    private static ModuleScope scope;
    private SerializationInfo info;
    private StreamingContext context;
    private Type baseType;
    private Type[] interfaces;
    private object proxy;
    private ProxyGenerationOptions proxyGenerationOptions;
    private bool isInterfaceProxy;
    private bool delegateToBase;
    public static ModuleScope ModuleScope { get; }
    protected ProxyObjectReference(SerializationInfo info, StreamingContext context);
    private static ProxyObjectReference();
    public static void ResetScope();
    public static void SetScope(ModuleScope scope);
    public static ModuleScope get_ModuleScope();
    private Type DeserializeTypeFromString(string key);
    protected virtual object RecreateProxy();
    private object RecreateClassProxyWithTarget();
    public object RecreateInterfaceProxy(string generatorType);
    public object RecreateClassProxy();
    private object InstantiateClassProxy(Type proxy_type);
    protected void InvokeCallback(object target);
    public sealed virtual object GetRealObject(StreamingContext context);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void OnDeserialization(object sender);
    private void DeserializeProxyMembers();
    private void DeserializeProxyState();
    private void SetTarget(object target);
    private void SetInterceptors(IInterceptor[] interceptors);
    private T GetValue(string name);
}
internal static class Castle.DynamicProxy.Serialization.ProxyTypeConstants : object {
    public static string Class;
    public static string ClassWithTarget;
    public static string InterfaceWithTarget;
    public static string InterfaceWithTargetInterface;
    public static string InterfaceWithoutTarget;
    private static ProxyTypeConstants();
}
internal class Castle.DynamicProxy.Serialization.RemotableInvocation : MarshalByRefObject {
    private IInvocation parent;
    public Type[] GenericArguments { get; }
    public object Proxy { get; }
    public object InvocationTarget { get; }
    public Type TargetType { get; }
    public Object[] Arguments { get; }
    public MethodInfo Method { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public object ReturnValue { get; public set; }
    public RemotableInvocation(IInvocation parent);
    protected RemotableInvocation(SerializationInfo info, StreamingContext context);
    public sealed virtual void SetArgumentValue(int index, object value);
    public sealed virtual object GetArgumentValue(int index);
    public sealed virtual Type[] get_GenericArguments();
    public sealed virtual void Proceed();
    public sealed virtual object get_Proxy();
    public sealed virtual object get_InvocationTarget();
    public sealed virtual Type get_TargetType();
    public sealed virtual Object[] get_Arguments();
    public sealed virtual MethodInfo get_Method();
    public sealed virtual MethodInfo GetConcreteMethod();
    public sealed virtual MethodInfo get_MethodInvocationTarget();
    public sealed virtual MethodInfo GetConcreteMethodInvocationTarget();
    public sealed virtual object get_ReturnValue();
    public sealed virtual void set_ReturnValue(object value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Castle.DynamicProxy.StandardInterceptor : MarshalByRefObject {
    public sealed virtual void Intercept(IInvocation invocation);
    protected virtual void PerformProceed(IInvocation invocation);
    protected virtual void PreProceed(IInvocation invocation);
    protected virtual void PostProceed(IInvocation invocation);
}
internal static class Castle.DynamicProxy.Tokens.DelegateMethods : object {
    public static MethodInfo CreateDelegate;
    private static DelegateMethods();
}
internal static class Castle.DynamicProxy.Tokens.FormatterServicesMethods : object {
    public static MethodInfo GetObjectData;
    public static MethodInfo GetSerializableMembers;
    private static FormatterServicesMethods();
}
internal static class Castle.DynamicProxy.Tokens.InterceptorSelectorMethods : object {
    public static MethodInfo SelectInterceptors;
    private static InterceptorSelectorMethods();
}
internal static class Castle.DynamicProxy.Tokens.InvocationMethods : object {
    public static ConstructorInfo CompositionInvocationConstructor;
    public static MethodInfo EnsureValidTarget;
    public static MethodInfo GetArgumentValue;
    public static MethodInfo GetArguments;
    public static MethodInfo GetReturnValue;
    public static ConstructorInfo InheritanceInvocationConstructor;
    public static ConstructorInfo InheritanceInvocationConstructorWithSelector;
    public static MethodInfo Proceed;
    public static FieldInfo ProxyObject;
    public static MethodInfo SetArgumentValue;
    public static MethodInfo SetGenericMethodArguments;
    public static MethodInfo SetReturnValue;
    public static FieldInfo Target;
    public static MethodInfo ThrowOnNoTarget;
    private static InvocationMethods();
}
internal static class Castle.DynamicProxy.Tokens.MethodBaseMethods : object {
    public static MethodInfo GetMethodFromHandle1;
    public static MethodInfo GetMethodFromHandle2;
    private static MethodBaseMethods();
}
internal static class Castle.DynamicProxy.Tokens.SerializationInfoMethods : object {
    public static MethodInfo AddValue_Bool;
    public static MethodInfo AddValue_Int32;
    public static MethodInfo AddValue_Object;
    public static MethodInfo GetValue;
    public static MethodInfo SetType;
    private static SerializationInfoMethods();
}
internal static class Castle.DynamicProxy.Tokens.TypeBuilderMethods : object {
    public static MethodInfo DefineProperty;
    private static TypeBuilderMethods();
}
internal static class Castle.DynamicProxy.Tokens.TypeMethods : object {
    public static MethodInfo GetTypeFromHandle;
    public static MethodInfo StaticGetType;
    private static TypeMethods();
}
internal static class Castle.DynamicProxy.Tokens.TypeUtilMethods : object {
    public static MethodInfo Sort;
    public static MethodInfo GetTypeOrNull;
    private static TypeUtilMethods();
}
public static class Rhino.Mocks.Arg : object {
    public static TextArg Text { get; }
    public static TextArg get_Text();
    public static T Is(T source);
}
public static class Rhino.Mocks.Arg`1 : object {
    public static IsArg`1<T> Is { get; }
    public static ListArg`1<T> List { get; }
    public static IsArg`1<T> get_Is();
    public static ListArg`1<T> get_List();
    public static T Matches(AbstractConstraint constraint);
    public static T Matches(Expression`1<Func`2<T, bool>> expression);
    public static ByRefDummy`1<T> Out(T value);
    public static ByRefDummy`1<T> Ref(T value);
    public static ByRefDummy`1<T> Ref(AbstractConstraint constraint, T value);
}
public abstract class Rhino.Mocks.Constraints.AbstractConstraint : object {
    public string Message { get; }
    public abstract virtual string get_Message();
    public abstract virtual bool Eval(object arg);
    public static AbstractConstraint op_BitwiseAnd(AbstractConstraint arg1, AbstractConstraint arg2);
    public static AbstractConstraint op_BitwiseOr(AbstractConstraint arg1, AbstractConstraint arg2);
    public static AbstractConstraint op_LogicalNot(AbstractConstraint arg1);
    public static bool op_False(AbstractConstraint arg1);
    public static bool op_True(AbstractConstraint arg1);
}
public class Rhino.Mocks.Constraints.Anything : AbstractConstraint {
    public string Message { get; }
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.CollectionCount : AbstractConstraint {
    private AbstractConstraint arg1;
    public string Message { get; }
    public CollectionCount(AbstractConstraint arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.CollectionEqual : AbstractConstraint {
    private ICollection arg1;
    public string Message { get; }
    public CollectionEqual(ICollection arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.Comparison : AbstractConstraint {
    private IComparable arg1;
    private bool largerThan;
    private bool andEqualTo;
    public string Message { get; }
    public Comparison(IComparable arg1, bool largerThan, bool andEqualTo);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.Contains : AbstractConstraint {
    private string arg1;
    public string Message { get; }
    public Contains(string arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.ContainsAll : AbstractConstraint {
    private ICollection arg1;
    private List`1<object> missing;
    public string Message { get; }
    public ContainsAll(ICollection arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.EndsWith : AbstractConstraint {
    private string arg1;
    public string Message { get; }
    public EndsWith(string arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.Equal : AbstractConstraint {
    private object arg1;
    public string Message { get; }
    public Equal(object arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
    public static bool CollectionsAreEqual(ICollection expected, ICollection actual);
    private static bool SafeEquals(object expected, object actual);
}
public class Rhino.Mocks.Constraints.IsIn : AbstractConstraint {
    private object arg1;
    public string Message { get; }
    public IsIn(object arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.KeyedListElement`1 : AbstractConstraint {
    private static BindingFlags GetFlags;
    private T key;
    private AbstractConstraint arg1;
    public string Message { get; }
    public KeyedListElement`1(T key, AbstractConstraint arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
    private MethodInfo FindGetItemMethod(object arg);
}
public class Rhino.Mocks.Constraints.LambdaConstraint : AbstractConstraint {
    private LambdaExpression expression;
    public string Message { get; }
    public LambdaConstraint(LambdaExpression expression);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.Like : AbstractConstraint {
    private string pattern;
    private Regex expression;
    public string Message { get; }
    public Like(string pattern);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.ListElement : AbstractConstraint {
    private int index;
    private AbstractConstraint arg1;
    public string Message { get; }
    public ListElement(int index, AbstractConstraint arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.OneOf : AbstractConstraint {
    private ICollection arg1;
    public string Message { get; }
    public OneOf(ICollection arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.OperatorAnd : AbstractConstraint {
    private AbstractConstraint arg1;
    private AbstractConstraint arg2;
    public string Message { get; }
    public OperatorAnd(AbstractConstraint arg1, AbstractConstraint arg2);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.OperatorNot : AbstractConstraint {
    private AbstractConstraint arg1;
    public string Message { get; }
    public OperatorNot(AbstractConstraint arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.OperatorOr : AbstractConstraint {
    private AbstractConstraint arg1;
    private AbstractConstraint arg2;
    public string Message { get; }
    public OperatorOr(AbstractConstraint arg1, AbstractConstraint arg2);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.PredicateConstraint`1 : AbstractConstraint {
    private Func`2<T, bool> predicate;
    [CompilerGeneratedAttribute]
private static Func`3<Array, int, string> CS$<>9__CachedAnonymousMethodDelegate1;
    public string Message { get; }
    public PredicateConstraint`1(Func`2<T, bool> predicate);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
    [CompilerGeneratedAttribute]
private static string <get_Message>b__0(Array arr, int i);
}
public class Rhino.Mocks.Constraints.Same : AbstractConstraint {
    private object arg1;
    public string Message { get; }
    public Same(object arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.StartsWith : AbstractConstraint {
    private string arg1;
    public string Message { get; }
    public StartsWith(string arg1);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Constraints.TypeOf : AbstractConstraint {
    private Type type;
    public string Message { get; }
    public TypeOf(Type type);
    public virtual string get_Message();
    public virtual bool Eval(object arg);
}
public class Rhino.Mocks.Exceptions.ExpectationViolationException : Exception {
    public ExpectationViolationException(string message);
    protected ExpectationViolationException(SerializationInfo info, StreamingContext context);
}
public class Rhino.Mocks.Expectations.Actuals : object {
    private MethodInfo method;
    private Object[] arguments;
    private int hashcode;
    internal int HashCode { get; }
    public MethodInfo Method { get; }
    public Object[] Arguments { get; }
    internal Actuals(MethodInfo method, Object[] arguments);
    internal int get_HashCode();
    public MethodInfo get_Method();
    public Object[] get_Arguments();
}
public abstract class Rhino.Mocks.Expectations.Expectation : object {
    private List`1<Actuals> actuals;
    private Range range;
    private bool consider;
    [CompilerGeneratedAttribute]
private Action`1<MethodInvocation> <DelegateToIntercept>k__BackingField;
    [CompilerGeneratedAttribute]
private Delegate <DelegateToInvoke>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DelegateReturnsValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ExceptionToThrow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceProceed>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ReturnArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowsException>k__BackingField;
    internal ExpectationType Type { get; }
    public int ActualCount { get; }
    public Range ExpectedCount { get; }
    public bool ExpectationMet { get; }
    public bool ExpectationSatisfied { get; }
    public bool HasActuals { get; }
    public bool HasDelegateToIntercept { get; }
    public bool HasDelegateToInvoke { get; }
    public bool HasReturnValue { get; }
    public object ReturnValue { get; }
    public Type ReturnType { get; }
    public Action`1<MethodInvocation> DelegateToIntercept { get; public set; }
    public Delegate DelegateToInvoke { get; public set; }
    public bool DelegateReturnsValue { get; public set; }
    public Exception ExceptionToThrow { get; public set; }
    public bool ForceProceed { get; public set; }
    public Object[] ReturnArguments { get; public set; }
    public bool ThrowsException { get; public set; }
    protected Expectation(Range range);
    internal abstract virtual ExpectationType get_Type();
    public int get_ActualCount();
    public Range get_ExpectedCount();
    public bool get_ExpectationMet();
    public bool get_ExpectationSatisfied();
    public bool get_HasActuals();
    public bool get_HasDelegateToIntercept();
    public bool get_HasDelegateToInvoke();
    public virtual bool get_HasReturnValue();
    public virtual object get_ReturnValue();
    public virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public Action`1<MethodInvocation> get_DelegateToIntercept();
    [CompilerGeneratedAttribute]
public void set_DelegateToIntercept(Action`1<MethodInvocation> value);
    [CompilerGeneratedAttribute]
public Delegate get_DelegateToInvoke();
    [CompilerGeneratedAttribute]
public void set_DelegateToInvoke(Delegate value);
    [CompilerGeneratedAttribute]
public bool get_DelegateReturnsValue();
    [CompilerGeneratedAttribute]
public void set_DelegateReturnsValue(bool value);
    [CompilerGeneratedAttribute]
public Exception get_ExceptionToThrow();
    [CompilerGeneratedAttribute]
public void set_ExceptionToThrow(Exception value);
    [CompilerGeneratedAttribute]
public bool get_ForceProceed();
    [CompilerGeneratedAttribute]
public void set_ForceProceed(bool value);
    [CompilerGeneratedAttribute]
public Object[] get_ReturnArguments();
    [CompilerGeneratedAttribute]
public void set_ReturnArguments(Object[] value);
    [CompilerGeneratedAttribute]
public bool get_ThrowsException();
    [CompilerGeneratedAttribute]
public void set_ThrowsException(bool value);
    public void AddActualCall(Actuals item);
    public bool HandledActual(Actuals item);
    public abstract virtual string GetDisplayName(IInvocation invocation);
    public abstract virtual void HandleMethodCall(MethodInfo method, Object[] arguments);
    public abstract virtual bool MatchesCall(MethodInfo method, Object[] arguments);
    public void SetExpectedCount(Range expected);
    public virtual void SetReturnValue(object value);
}
public abstract class Rhino.Mocks.Expectations.Expectation`1 : Expectation {
    private T returnValue;
    private bool returnValueIsSet;
    public bool HasReturnValue { get; }
    public object ReturnValue { get; }
    public Type ReturnType { get; }
    protected Expectation`1(Range range);
    public virtual bool get_HasReturnValue();
    public virtual object get_ReturnValue();
    public virtual Type get_ReturnType();
    public virtual void SetReturnValue(object value);
}
internal enum Rhino.Mocks.Expectations.ExpectationType : Enum {
    public int value__;
    public static ExpectationType Method;
    public static ExpectationType Property;
    public static ExpectationType Event;
}
public class Rhino.Mocks.Expectations.ExpectEvent : Expectation {
    [CompilerGeneratedAttribute]
private AbstractConstraint[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    internal ExpectationType Type { get; }
    public AbstractConstraint[] Arguments { get; public set; }
    public MethodInfo Method { get; public set; }
    protected ExpectEvent(Range range);
    internal virtual ExpectationType get_Type();
    [CompilerGeneratedAttribute]
public AbstractConstraint[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(AbstractConstraint[] value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(MethodInfo value);
    public virtual string GetDisplayName(IInvocation invocation);
    public virtual void HandleMethodCall(MethodInfo method, Object[] arguments);
    public virtual bool MatchesCall(MethodInfo method, Object[] arguments);
    public bool MatchesCallArguments(Object[] arguments);
    private sealed virtual override IEventOptions Rhino.Mocks.Interfaces.IEventOptions.IgnoreArguments();
    private sealed virtual override IEventOptions Rhino.Mocks.Interfaces.IEventOptions.Throws();
    private sealed virtual override IEventOptions Rhino.Mocks.Interfaces.IEventOptions.Throws(TException exception);
    [CompilerGeneratedAttribute]
private string <GetDisplayName>b__0(Array x, int i);
}
public class Rhino.Mocks.Expectations.ExpectMethod : Expectation {
    private IRepeatOptions repeatOptions;
    [CompilerGeneratedAttribute]
private AbstractConstraint[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    internal ExpectationType Type { get; }
    private IRepeatOptions Rhino.Mocks.Interfaces.IMethodOptions.Repeat { get; }
    public AbstractConstraint[] Arguments { get; public set; }
    public MethodInfo Method { get; public set; }
    protected ExpectMethod(Range range);
    internal virtual ExpectationType get_Type();
    private sealed virtual override IRepeatOptions Rhino.Mocks.Interfaces.IMethodOptions.get_Repeat();
    [CompilerGeneratedAttribute]
public AbstractConstraint[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(AbstractConstraint[] value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(MethodInfo value);
    public virtual string GetDisplayName(IInvocation invocation);
    public virtual void HandleMethodCall(MethodInfo method, Object[] arguments);
    public virtual bool MatchesCall(MethodInfo method, Object[] arguments);
    public bool MatchesCallArguments(Object[] arguments);
    private void ValidateDelegateArguments(Delegate action);
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.CallOriginalMethod();
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.DoInstead(Delegate action);
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.IgnoreArguments();
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.Intercept(Action`1<MethodInvocation> action);
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.OutRef(Object[] parameters);
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.Throws();
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.Throws(TException exception);
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.WhenCalled(Action action);
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.WhenCalled(Action`1<TArg> action);
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.WhenCalled(Action`2<TArg1, TArg2> action);
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.WhenCalled(Action`3<TArg1, TArg2, TArg3> action);
    private sealed virtual override IMethodOptions Rhino.Mocks.Interfaces.IMethodOptions.WhenCalled(Action`4<TArg1, TArg2, TArg3, TArg4> action);
    [CompilerGeneratedAttribute]
private string <GetDisplayName>b__0(Array x, int i);
}
public class Rhino.Mocks.Expectations.ExpectMethod`1 : Expectation`1<T> {
    private IRepeatOptions`1<T> repeatOptions;
    [CompilerGeneratedAttribute]
private AbstractConstraint[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    internal ExpectationType Type { get; }
    private IRepeatOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.Repeat { get; }
    public AbstractConstraint[] Arguments { get; public set; }
    public MethodInfo Method { get; public set; }
    protected ExpectMethod`1(Range range);
    internal virtual ExpectationType get_Type();
    private sealed virtual override IRepeatOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.get_Repeat();
    [CompilerGeneratedAttribute]
public AbstractConstraint[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(AbstractConstraint[] value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(MethodInfo value);
    public virtual string GetDisplayName(IInvocation invocation);
    public virtual void HandleMethodCall(MethodInfo method, Object[] arguments);
    public virtual bool MatchesCall(MethodInfo method, Object[] arguments);
    public bool MatchesCallArguments(Object[] arguments);
    private void ValidateDelegateArguments(Delegate action);
    private void ValidateDelegateReturnType(Delegate action);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.CallOriginalMethod();
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.DoInstead(Delegate action);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.IgnoreArguments();
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.Intercept(Action`1<MethodInvocation> action);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.OutRef(Object[] parameters);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.Return(T value);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.Returns(Func`1<T> func);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.Throws();
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.Throws(TException exception);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.WhenCalled(Action action);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.WhenCalled(Action`1<TArg> action);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.WhenCalled(Action`2<TArg1, TArg2> action);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.WhenCalled(Action`3<TArg1, TArg2, TArg3> action);
    private sealed virtual override IMethodOptions`1<T> Rhino.Mocks.Interfaces.IMethodOptions<T>.WhenCalled(Action`4<TArg1, TArg2, TArg3, TArg4> action);
    [CompilerGeneratedAttribute]
private string <GetDisplayName>b__0(Array x, int i);
}
public class Rhino.Mocks.Expectations.ExpectProperty`1 : Expectation`1<T> {
    [CompilerGeneratedAttribute]
private AbstractConstraint[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <MethodGet>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <MethodSet>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    internal ExpectationType Type { get; }
    public AbstractConstraint[] Arguments { get; public set; }
    public MethodInfo MethodGet { get; public set; }
    public MethodInfo MethodSet { get; public set; }
    public PropertyInfo Property { get; public set; }
    protected ExpectProperty`1(Range range);
    internal virtual ExpectationType get_Type();
    [CompilerGeneratedAttribute]
public AbstractConstraint[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(AbstractConstraint[] value);
    [CompilerGeneratedAttribute]
public MethodInfo get_MethodGet();
    [CompilerGeneratedAttribute]
public void set_MethodGet(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_MethodSet();
    [CompilerGeneratedAttribute]
public void set_MethodSet(MethodInfo value);
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(PropertyInfo value);
    public virtual string GetDisplayName(IInvocation invocation);
    public virtual void HandleMethodCall(MethodInfo method, Object[] arguments);
    public virtual bool MatchesCall(MethodInfo method, Object[] arguments);
    public bool MatchesCallArguments(Object[] arguments);
    private sealed virtual override IPropertyOptions`1<T> Rhino.Mocks.Interfaces.IPropertyOptions<T>.CallOriginalProperty();
    private sealed virtual override IPropertyOptions`1<T> Rhino.Mocks.Interfaces.IPropertyOptions<T>.IgnoreArguments();
    private sealed virtual override IPropertyOptions`1<T> Rhino.Mocks.Interfaces.IPropertyOptions<T>.Return(T value);
    private sealed virtual override IPropertyOptions`1<T> Rhino.Mocks.Interfaces.IPropertyOptions<T>.Returns(Func`1<T> func);
    private sealed virtual override IPropertyOptions`1<T> Rhino.Mocks.Interfaces.IPropertyOptions<T>.Throws();
    private sealed virtual override IPropertyOptions`1<T> Rhino.Mocks.Interfaces.IPropertyOptions<T>.Throws(TException exception);
    [CompilerGeneratedAttribute]
private string <GetDisplayName>b__0(Array x, int i);
}
public class Rhino.Mocks.Expectations.Range : object {
    private int minimum;
    private Nullable`1<int> maximum;
    public int Minimum { get; }
    public Nullable`1<int> Maximum { get; }
    public Range(int minimum, Nullable`1<int> maximum);
    public int get_Minimum();
    public Nullable`1<int> get_Maximum();
    public virtual string ToString();
}
public class Rhino.Mocks.Expectations.RepeatOptions : object {
    private ExpectMethod expectation;
    public RepeatOptions(ExpectMethod expectation);
    public sealed virtual IMethodOptions Once();
    public sealed virtual IMethodOptions Twice();
    public sealed virtual IMethodOptions Times(int expected);
    public sealed virtual IMethodOptions AtLeast(int expected);
    public sealed virtual IMethodOptions AtMost(int expected);
    public sealed virtual IMethodOptions Any();
    public sealed virtual IMethodOptions Never();
}
public class Rhino.Mocks.Expectations.RepeatOptions`1 : object {
    private ExpectMethod`1<T> expectation;
    public RepeatOptions`1(ExpectMethod`1<T> expectation);
    public sealed virtual IMethodOptions`1<T> Once();
    public sealed virtual IMethodOptions`1<T> Twice();
    public sealed virtual IMethodOptions`1<T> Times(int expected);
    public sealed virtual IMethodOptions`1<T> AtLeast(int expected);
    public sealed virtual IMethodOptions`1<T> AtMost(int expected);
    public sealed virtual IMethodOptions`1<T> Any();
    public sealed virtual IMethodOptions`1<T> Never();
}
internal class Rhino.Mocks.Helpers.ArgumentManager : object {
    [ThreadStaticAttribute]
private static List`1<ArgumentInstance> arguments;
    internal static bool HasBeenUsed { get; }
    internal static bool get_HasBeenUsed();
    internal static void Clear();
    internal static void AddArgument(AbstractConstraint constraint);
    internal static void AddOutArgument(object value);
    internal static void AddRefArgument(AbstractConstraint constraint, object value);
    internal static AbstractConstraint[] GetConstraints();
    internal static Object[] GetReturnValues();
    internal static void ValidateMethodSignature(MethodInfo method);
    private static void Initialize();
}
public class Rhino.Mocks.Helpers.ByRefDummy`1 : object {
    public T Dummy;
}
public class Rhino.Mocks.Helpers.EventRaiser : object {
    private object instance;
    public EventRaiser(object instance);
    public void Raise(Delegate subscription, Object[] args);
    private void AssertParametersMatch(MethodInfo method, Object[] args);
    private void PreserveStack(Exception exception);
}
public static class Rhino.Mocks.Helpers.Is : object {
    public static AbstractConstraint GreaterThan(IComparable objToCompare);
    public static AbstractConstraint GreaterThanOrEqual(IComparable objToCompare);
    public static AbstractConstraint LessThan(IComparable objToCompare);
    public static AbstractConstraint LessThanOrEqual(IComparable objToCompare);
    public static AbstractConstraint Equal(object obj);
    public static AbstractConstraint NotEqual(object obj);
    public static AbstractConstraint Same(object obj);
    public static AbstractConstraint NotSame(object obj);
    public static AbstractConstraint Anything();
    public static AbstractConstraint Null();
    public static AbstractConstraint NotNull();
    public static AbstractConstraint TypeOf(Type type);
    public static AbstractConstraint TypeOf();
    public static AbstractConstraint Matching(Func`2<T, bool> predicate);
}
public class Rhino.Mocks.Helpers.IsArg`1 : object {
    public T Anything { get; }
    public T Null { get; }
    public T NotNull { get; }
    public T TypeOf { get; }
    public T get_Anything();
    public T get_Null();
    public T get_NotNull();
    public T get_TypeOf();
    public T GreaterThan(IComparable source);
    public T GreaterThanOrEqual(IComparable source);
    public T LessThan(IComparable source);
    public T LessThanOrEqual(IComparable source);
    public T Equal(object source);
    public T NotEqual(object source);
    public T Same(object source);
    public T NotSame(object source);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private IComparable ConvertObjectType(IComparable obj);
    private object ConvertObjectType(object obj);
}
public static class Rhino.Mocks.Helpers.List : object {
    public static AbstractConstraint IsIn(object item);
    public static AbstractConstraint ContainsAll(ICollection collection);
    public static AbstractConstraint OneOf(ICollection collection);
    public static AbstractConstraint Equal(ICollection collection);
    public static AbstractConstraint Count(AbstractConstraint constraint);
    public static AbstractConstraint Element(int index, AbstractConstraint constraint);
    public static AbstractConstraint Element(T key, AbstractConstraint constraint);
}
public class Rhino.Mocks.Helpers.ListArg`1 : object {
    public T IsIn(object item);
    public T ContainsAll(ICollection collection);
    public T OneOf(ICollection collection);
    public T Equal(ICollection collection);
    public T Count(AbstractConstraint constraint);
    public T Element(int index, AbstractConstraint constraint);
    public T Element(TItem item, AbstractConstraint constraint);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class Rhino.Mocks.Helpers.MethodFormatter : object {
    public static string ToString(IInvocation invocation, MethodInfo method);
    public static string ToString(IInvocation invocation, MethodInfo method, Func`3<Array, int, string> func);
    public static string ToString(IInvocation invocation, MethodInfo method, Object[] args);
    public static string ToString(IInvocation invocation, MethodInfo method, Object[] args, Func`3<Array, int, string> func);
    private static string FormatArgument(Array arguments, int currentIndex);
}
public static class Rhino.Mocks.Helpers.Text : object {
    public static AbstractConstraint StartsWith(string value);
    public static AbstractConstraint EndsWith(string value);
    public static AbstractConstraint Contains(string value);
    public static AbstractConstraint Like(string pattern);
}
public class Rhino.Mocks.Helpers.TextArg : object {
    public string StartsWith(string value);
    public string EndsWith(string value);
    public string Contains(string value);
    public string Like(string pattern);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Rhino.Mocks.Interceptors.MockInterceptor : MarshalByRefObject {
    private IMockInstance instance;
    public MockInterceptor(IMockInstance instance);
    public sealed virtual void Intercept(IInvocation invocation);
}
public class Rhino.Mocks.Interceptors.ObjectInterceptor : MarshalByRefObject {
    public sealed virtual void Intercept(IInvocation invocation);
}
public class Rhino.Mocks.Interceptors.ProxyInterceptor : MarshalByRefObject {
    private IMockInstance instance;
    public ProxyInterceptor(IMockInstance instance);
    public sealed virtual void Intercept(IInvocation invocation);
    private object IdentifyDefaultValue(Type type);
    private object IdentifyReturnType(Type type);
    private Expectation ParseRecursiveExpectation(IMockExpectationContainer container, Expectation current, Type type);
}
public interface Rhino.Mocks.Interfaces.IEventOptions {
    public abstract virtual IEventOptions IgnoreArguments();
    public abstract virtual IEventOptions Throws();
    public abstract virtual IEventOptions Throws(TException exception);
}
public interface Rhino.Mocks.Interfaces.IExpectationLogger {
    public abstract virtual void LogExpectation(IInvocation invocation);
    public abstract virtual void LogExpectedMethodCall(IInvocation invocation);
    public abstract virtual void LogUnexpectedMethodCall(IInvocation invocation, string message);
}
public interface Rhino.Mocks.Interfaces.IExpectationOptions {
    public abstract virtual IExpectationOptions Throws();
    public abstract virtual IExpectationOptions Throws(TException exception);
}
public interface Rhino.Mocks.Interfaces.IExpectationOptions`1 {
    public abstract virtual IExpectationOptions`1<T> Throws();
    public abstract virtual IExpectationOptions`1<T> Throws(TException exception);
}
public interface Rhino.Mocks.Interfaces.IMethodOptions {
    public IRepeatOptions Repeat { get; }
    public abstract virtual IRepeatOptions get_Repeat();
    public abstract virtual IMethodOptions CallOriginalMethod();
    public abstract virtual IMethodOptions DoInstead(Delegate action);
    public abstract virtual IMethodOptions IgnoreArguments();
    public abstract virtual IMethodOptions Intercept(Action`1<MethodInvocation> action);
    public abstract virtual IMethodOptions OutRef(Object[] parameters);
    public abstract virtual IMethodOptions Throws();
    public abstract virtual IMethodOptions Throws(TException exception);
    public abstract virtual IMethodOptions WhenCalled(Action action);
    public abstract virtual IMethodOptions WhenCalled(Action`1<TArg> action);
    public abstract virtual IMethodOptions WhenCalled(Action`2<TArg1, TArg2> action);
    public abstract virtual IMethodOptions WhenCalled(Action`3<TArg1, TArg2, TArg3> action);
    public abstract virtual IMethodOptions WhenCalled(Action`4<TArg1, TArg2, TArg3, TArg4> action);
}
public interface Rhino.Mocks.Interfaces.IMethodOptions`1 {
    public IRepeatOptions`1<T> Repeat { get; }
    public abstract virtual IRepeatOptions`1<T> get_Repeat();
    public abstract virtual IMethodOptions`1<T> CallOriginalMethod();
    public abstract virtual IMethodOptions`1<T> DoInstead(Delegate action);
    public abstract virtual IMethodOptions`1<T> IgnoreArguments();
    public abstract virtual IMethodOptions`1<T> Intercept(Action`1<MethodInvocation> action);
    public abstract virtual IMethodOptions`1<T> OutRef(Object[] parameters);
    public abstract virtual IMethodOptions`1<T> Return(T value);
    public abstract virtual IMethodOptions`1<T> Returns(Func`1<T> func);
    public abstract virtual IMethodOptions`1<T> Throws();
    public abstract virtual IMethodOptions`1<T> Throws(TException exception);
    public abstract virtual IMethodOptions`1<T> WhenCalled(Action action);
    public abstract virtual IMethodOptions`1<T> WhenCalled(Action`1<TArg> action);
    public abstract virtual IMethodOptions`1<T> WhenCalled(Action`2<TArg1, TArg2> action);
    public abstract virtual IMethodOptions`1<T> WhenCalled(Action`3<TArg1, TArg2, TArg3> action);
    public abstract virtual IMethodOptions`1<T> WhenCalled(Action`4<TArg1, TArg2, TArg3, TArg4> action);
}
public interface Rhino.Mocks.Interfaces.IMockExpectation {
    public bool HasReturnValue { get; }
    public bool ForceProceed { get; }
    public MethodInfo Method { get; }
    public object ReturnValue { get; }
    public abstract virtual bool get_HasReturnValue();
    public abstract virtual bool get_ForceProceed();
    public abstract virtual MethodInfo get_Method();
    public abstract virtual object get_ReturnValue();
}
public interface Rhino.Mocks.Interfaces.IMockExpectationContainer {
    public bool ExpectationMarked { get; }
    public abstract virtual bool get_ExpectationMarked();
    public abstract virtual Delegate GetEventSubscribers(string name);
    public abstract virtual Expectation GetMarkedExpectation();
    public abstract virtual Actuals[] ListActuals();
    public abstract virtual Expectation[] ListExpectations();
    public abstract virtual void AddExpectation(Expectation expectation);
    public abstract virtual void MarkForAssertion(Expectation expectation);
    public abstract virtual void MarkForExpectation(Expectation expectation);
    public abstract virtual void RemoveExpectation(Expectation expectation);
    public abstract virtual object HandleMethodCall(IInvocation invocation, MethodInfo method, Object[] arguments);
}
public interface Rhino.Mocks.Interfaces.IMockInstance {
    public int HashCode { get; }
    public Type[] ImplementedTypes { get; }
    public bool IsPartialInstance { get; public set; }
    public Object[] ConstructorArguments { get; public set; }
    public object ProxyInstance { get; public set; }
    public abstract virtual int get_HashCode();
    public abstract virtual Type[] get_ImplementedTypes();
    public abstract virtual bool get_IsPartialInstance();
    public abstract virtual void set_IsPartialInstance(bool value);
    public abstract virtual Object[] get_ConstructorArguments();
    public abstract virtual void set_ConstructorArguments(Object[] value);
    public abstract virtual object get_ProxyInstance();
    public abstract virtual void set_ProxyInstance(object value);
}
public interface Rhino.Mocks.Interfaces.IPropertyOptions`1 {
    public abstract virtual IPropertyOptions`1<T> CallOriginalProperty();
    public abstract virtual IPropertyOptions`1<T> IgnoreArguments();
    public abstract virtual IPropertyOptions`1<T> Return(T value);
    public abstract virtual IPropertyOptions`1<T> Returns(Func`1<T> func);
    public abstract virtual IPropertyOptions`1<T> Throws();
    public abstract virtual IPropertyOptions`1<T> Throws(TException exception);
}
public interface Rhino.Mocks.Interfaces.IRepeatOptions {
    public abstract virtual IMethodOptions Once();
    public abstract virtual IMethodOptions Twice();
    public abstract virtual IMethodOptions Times(int expected);
    public abstract virtual IMethodOptions AtLeast(int expected);
    public abstract virtual IMethodOptions AtMost(int expected);
    public abstract virtual IMethodOptions Any();
    public abstract virtual IMethodOptions Never();
}
public interface Rhino.Mocks.Interfaces.IRepeatOptions`1 {
    public abstract virtual IMethodOptions`1<T> Once();
    public abstract virtual IMethodOptions`1<T> Twice();
    public abstract virtual IMethodOptions`1<T> Times(int expected);
    public abstract virtual IMethodOptions`1<T> AtLeast(int expected);
    public abstract virtual IMethodOptions`1<T> AtMost(int expected);
    public abstract virtual IMethodOptions`1<T> Any();
    public abstract virtual IMethodOptions`1<T> Never();
}
public class Rhino.Mocks.Loggers.NullLogger : object {
    public sealed virtual void LogExpectation(IInvocation invocation);
    public sealed virtual void LogExpectedMethodCall(IInvocation invocation);
    public sealed virtual void LogUnexpectedMethodCall(IInvocation invocation, string message);
}
public class Rhino.Mocks.Loggers.TextWriterLogger : object {
    private TextWriter writer;
    public TextWriterLogger(TextWriter writer);
    public sealed virtual void LogExpectation(IInvocation invocation);
    public sealed virtual void LogExpectedMethodCall(IInvocation invocation);
    public sealed virtual void LogUnexpectedMethodCall(IInvocation invocation, string message);
}
public class Rhino.Mocks.Loggers.TraceWriterLogger : object {
    public sealed virtual void LogExpectation(IInvocation invocation);
    public sealed virtual void LogExpectedMethodCall(IInvocation invocation);
    public sealed virtual void LogUnexpectedMethodCall(IInvocation invocation, string message);
}
public class Rhino.Mocks.Loggers.TraceWriterWithStackTraceLogger : object {
    [CompilerGeneratedAttribute]
private TextWriter <AlternativeWriter>k__BackingField;
    public TextWriter AlternativeWriter { get; public set; }
    [CompilerGeneratedAttribute]
public TextWriter get_AlternativeWriter();
    [CompilerGeneratedAttribute]
public void set_AlternativeWriter(TextWriter value);
    public sealed virtual void LogExpectation(IInvocation invocation);
    public sealed virtual void LogExpectedMethodCall(IInvocation invocation);
    public sealed virtual void LogUnexpectedMethodCall(IInvocation invocation, string message);
    private void WriteStackTrace();
}
public class Rhino.Mocks.MethodInvocation : object {
    private IInvocation invocation;
    public Object[] Arguments { get; }
    public MethodInfo Method { get; }
    public object ReturnValue { get; public set; }
    internal MethodInvocation(IInvocation invocation);
    public Object[] get_Arguments();
    public MethodInfo get_Method();
    public object get_ReturnValue();
    public void set_ReturnValue(object value);
}
public class Rhino.Mocks.MockInstance : object {
    private List`1<Actuals> actuals;
    private List`1<Expectation> container;
    private Stack`1<Expectation> stack;
    private Dictionary`2<string, object> dynamicProperties;
    private Dictionary`2<string, Delegate> eventSubscriptions;
    private Dictionary`2<string, Expectation> expectedProperties;
    private Type[] types;
    private int hashcode;
    [CompilerGeneratedAttribute]
private bool <IsPartialInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpectationMarked>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ConstructorArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ProxyInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Expectation, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Expectation, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<Expectation, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<Expectation, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<Expectation, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    public int HashCode { get; }
    public Type[] ImplementedTypes { get; }
    public bool IsPartialInstance { get; public set; }
    public bool ExpectationMarked { get; private set; }
    public Object[] ConstructorArguments { get; public set; }
    public object ProxyInstance { get; public set; }
    public MockInstance(Type[] types);
    public sealed virtual int get_HashCode();
    public sealed virtual Type[] get_ImplementedTypes();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPartialInstance();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsPartialInstance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ExpectationMarked();
    [CompilerGeneratedAttribute]
private void set_ExpectationMarked(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Object[] get_ConstructorArguments();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConstructorArguments(Object[] value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_ProxyInstance();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProxyInstance(object value);
    public sealed virtual Delegate GetEventSubscribers(string name);
    public sealed virtual Expectation GetMarkedExpectation();
    public sealed virtual Actuals[] ListActuals();
    public sealed virtual Expectation[] ListExpectations();
    public sealed virtual void AddExpectation(Expectation expectation);
    public sealed virtual void MarkForAssertion(Expectation expectation);
    public sealed virtual void MarkForExpectation(Expectation expectation);
    public sealed virtual void RemoveExpectation(Expectation expectation);
    public sealed virtual object HandleMethodCall(IInvocation invocation, MethodInfo method, Object[] arguments);
    public object HandleEventCall(IInvocation invocation, MethodInfo method, Object[] arguments);
    public object HandlePropertyCall(IInvocation invocation, MethodInfo method, Object[] arguments);
    public object HandleUnexpectedMethodCall(IInvocation invocation, MethodInfo method, Object[] arguments);
    private void HandleEventSubscription(MethodInfo method, Delegate subscription);
    private static string GeneratePropertyKey(MethodInfo method, Object[] arguments);
    private static object GetDefaultValue(Type type);
    [CompilerGeneratedAttribute]
private static bool <HandleMethodCall>b__0(Expectation x);
    [CompilerGeneratedAttribute]
private static bool <HandleMethodCall>b__1(Expectation x);
    [CompilerGeneratedAttribute]
private static bool <HandleMethodCall>b__2(Expectation x);
    [CompilerGeneratedAttribute]
private static bool <HandleEventCall>b__6(Expectation x);
    [CompilerGeneratedAttribute]
private static bool <HandlePropertyCall>b__8(Expectation x);
}
public class Rhino.Mocks.MockInstanceEquality : object {
    private static MockInstanceEquality instance;
    private static int hashcode;
    public static MockInstanceEquality Instance { get; }
    internal static int NextHash { get; }
    private static MockInstanceEquality();
    public static MockInstanceEquality get_Instance();
    internal static int get_NextHash();
    internal bool AreEqual(object arg1, object arg2);
    public sealed virtual int GetHashCode(object obj);
    public sealed virtual int Compare(object x, object y);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object x, object y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object obj);
    private static IMockInstance GetMockOrNull(object obj);
}
public class Rhino.Mocks.MockRepository : object {
    private static Dictionary`2<Type, ProxyGenerator> generators;
    private static ObjectInterceptor objectInterceptor;
    private RepositoryForDelegates delegateRepository;
    private ProxyGenerationOptions generatorOptions;
    private ProxyGenerationOptions defaultOptions;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    private static MockRepository();
    internal static ExpectMethod GetMethodCallArguments(T instance, Action`1<T> action);
    internal static ExpectMethod`1<TResult> GetMethodCallArguments(T instance, Func`2<T, TResult> func);
    public static T Mock();
    public static T Mock(Object[] arguments);
    public static T Mock();
    public static T Mock(Object[] arguments);
    public static T Mock();
    public static T Mock(Object[] arguments);
    public static T MockMulti(Type[] extraTypes, Object[] arguments);
    public static T MockWithRemoting();
    public static T Partial();
    public static T Partial(Object[] arguments);
    public static T Partial();
    public static T Partial(Object[] arguments);
    public static T Partial();
    public static T Partial(Object[] arguments);
    public static T PartialMulti(Type[] extraTypes, Object[] arguments);
    internal T CreateMockObject(Type[] extraTypes);
    internal T CreateMockObject(Object[] arguments);
    internal T CreateMockObject(Type[] extraTypes, Object[] arguments);
    internal object CreateMockObject(Type type, Type[] extraTypes);
    internal object CreateMockObject(Type type, Object[] arguments);
    internal object CreateMockObject(Type type, Type[] extraTypes, Object[] arguments);
    internal static IMockExpectationContainer GetExpectationContainer(object instance);
    private object CreateMockClass(Type type, Type[] extraTypes, Object[] arguments, bool isPartial);
    private object CreateMockDelegate(Type type);
    private object CreateMockInterface(Type type, Type[] extraTypes);
    private object CreateMockRemoted(Type type);
    private static ProxyGenerator IdentifyGenerator(Type type);
    [CompilerGeneratedAttribute]
private static bool <PartialMulti>b__2(Type x);
    [CompilerGeneratedAttribute]
private static bool <CreateMockObject>b__3(Type x);
}
internal interface Rhino.Mocks.Remoting.IRemotingProxyOperation {
    public abstract virtual void Process(RemotingProxy proxy);
}
internal class Rhino.Mocks.Remoting.RemotingInvocation : object {
    private IMethodCallMessage message;
    private RealProxy proxy;
    private Object[] arguments;
    [CompilerGeneratedAttribute]
private object <ReturnValue>k__BackingField;
    public Object[] Arguments { get; }
    public Type[] GenericArguments { get; }
    public object InvocationTarget { get; }
    public MethodInfo Method { get; }
    public MethodInfo MethodInvocationTarget { get; }
    public object Proxy { get; }
    public object ReturnValue { get; public set; }
    public Type TargetType { get; }
    public RemotingInvocation(RealProxy proxy, IMethodCallMessage message);
    public sealed virtual Object[] get_Arguments();
    public sealed virtual Type[] get_GenericArguments();
    public sealed virtual object get_InvocationTarget();
    public sealed virtual MethodInfo get_Method();
    public sealed virtual MethodInfo get_MethodInvocationTarget();
    public sealed virtual object get_Proxy();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ReturnValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReturnValue(object value);
    public sealed virtual Type get_TargetType();
    public sealed virtual object GetArgumentValue(int index);
    public sealed virtual MethodInfo GetConcreteMethod();
    public sealed virtual MethodInfo GetConcreteMethodInvocationTarget();
    public sealed virtual void Proceed();
    public sealed virtual void SetArgumentValue(int index, object value);
}
internal class Rhino.Mocks.Remoting.RemotingProxy : RealProxy {
    private IInterceptor interceptor;
    private IMockInstance instance;
    public IMockInstance MockInstance { get; }
    public RemotingProxy(Type type, IInterceptor interceptor, IMockInstance instance);
    public IMockInstance get_MockInstance();
    public virtual IMessage Invoke(IMessage msg);
    private bool IsEqualsCall(IMethodCallMessage mcm);
    private bool IsGetHashCodeCall(IMethodCallMessage mcm);
    private bool IsGetTypeCall(IMethodCallMessage mcm);
    private bool IsToStringCall(IMethodCallMessage mcm);
    private bool HandleEquals(IMethodMessage mm);
    private IMessage ReturnValue(object value, IMethodCallMessage mcm);
    private IMessage ReturnValue(object value, Object[] outArgs, IMethodCallMessage mcm);
}
internal class Rhino.Mocks.Remoting.RemotingProxyDetector : object {
    [CompilerGeneratedAttribute]
private bool <Detected>k__BackingField;
    internal bool Detected { get; private set; }
    [CompilerGeneratedAttribute]
internal bool get_Detected();
    [CompilerGeneratedAttribute]
private void set_Detected(bool value);
    public sealed virtual void Process(RemotingProxy proxy);
}
internal class Rhino.Mocks.Remoting.RemotingProxySelector : object {
    [CompilerGeneratedAttribute]
private IMockInstance <MockInstance>k__BackingField;
    internal IMockInstance MockInstance { get; private set; }
    [CompilerGeneratedAttribute]
internal IMockInstance get_MockInstance();
    [CompilerGeneratedAttribute]
private void set_MockInstance(IMockInstance value);
    public sealed virtual void Process(RemotingProxy proxy);
}
[ExtensionAttribute]
public static class Rhino.Mocks.RepositoryExtensions : object {
    [ExtensionAttribute]
public static void AssertWasCalled(T instance, Action`1<T> action);
    [ExtensionAttribute]
public static void AssertWasCalled(T instance, Func`2<T, TResult> func);
    [ExtensionAttribute]
public static void AssertWasNotCalled(T instance, Action`1<T> action);
    [ExtensionAttribute]
public static void AssertWasNotCalled(T instance, Func`2<T, TResult> func);
    [ExtensionAttribute]
public static IMethodOptions Expect(T instance, Action`1<T> action);
    [ExtensionAttribute]
public static IMethodOptions`1<TResult> Expect(T instance, Func`2<T, TResult> func);
    [ExtensionAttribute]
public static IEventOptions ExpectEvent(T instance, Action`1<T> action);
    [ExtensionAttribute]
public static IPropertyOptions`1<TResult> ExpectProperty(T instance, Func`2<T, TResult> func);
    [ExtensionAttribute]
public static Actuals[] GetArgumentsForCallsMadeOn(T instance, Action`1<T> action);
    [ExtensionAttribute]
public static Actuals[] GetArgumentsForCallsMadeOn(T instance, Func`2<T, TResult> func);
    [ExtensionAttribute]
public static void Raise(T instance, Action`1<T> eventSubscription, Object[] args);
    [ExtensionAttribute]
public static void Raise(T instance, Action`1<T> eventSubscription, EventArgs args);
    [ExtensionAttribute]
public static IMethodOptions Stub(T instance, Action`1<T> action);
    [ExtensionAttribute]
public static IMethodOptions`1<TResult> Stub(T instance, Func`2<T, TResult> func);
    [ExtensionAttribute]
public static IEventOptions StubEvent(T instance, Action`1<T> action);
    [ExtensionAttribute]
public static void VerifyAllExpectations(T instance);
    [ExtensionAttribute]
public static void VerifyExpectations(T instance);
    [ExtensionAttribute]
public static void VerifyExpectations(T instance, bool strictly);
    private static IMockExpectationContainer GetExpectationContainer(object instance);
    [CompilerGeneratedAttribute]
private static bool <VerifyExpectations>b__8(Expectation x);
}
internal class Rhino.Mocks.RepositoryForDelegates : object {
    private ModuleScope scope;
    private Dictionary`2<Type, Type> dictionary;
    private long counter;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate1;
    public Type CreateTargetInterface(Type type);
    private Type GenerateTargetInterface(Type type);
    [CompilerGeneratedAttribute]
private static Type <GenerateTargetInterface>b__0(ParameterInfo x);
}
internal class Rhino.Mocks.RepositoryForRemoting : object {
    internal object CreateMockRemoting(Type type, IInterceptor interceptor, IMockInstance instance);
    internal static bool IsRemotingProxy(object obj);
    internal static IMockInstance GetMockedInstanceFromProxy(object obj);
}
public static class Rhino.Mocks.RhinoMocks : object {
    public static string StrongName;
    public static string NormalName;
    public static IExpectationLogger Logger;
    private static RhinoMocks();
}
internal class Rhino.Mocks.RhinoSelector : object {
    [CompilerGeneratedAttribute]
private static Func`2<IInterceptor, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<IInterceptor, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<IInterceptor, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<IInterceptor, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    public sealed virtual IInterceptor[] SelectInterceptors(Type type, MethodInfo method, IInterceptor[] interceptors);
    [CompilerGeneratedAttribute]
private static bool <SelectInterceptors>b__0(IInterceptor x);
    [CompilerGeneratedAttribute]
private static bool <SelectInterceptors>b__1(IInterceptor x);
    [CompilerGeneratedAttribute]
private static bool <SelectInterceptors>b__2(IInterceptor x);
    [CompilerGeneratedAttribute]
private static bool <SelectInterceptors>b__3(IInterceptor x);
}
