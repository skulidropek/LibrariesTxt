[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AbstractTypeShouldNotHavePublicConstructorsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddBracesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeElseClause(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCommonForEachStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeForStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeUsingStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeWhileStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDoStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLockStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFixedStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddBracesToIfElseAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeElseClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddBracesToIfElseWhenMultiLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddBracesToSwitchSectionWithMultipleStatementsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSwitchSection(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddBracesWhenMultilineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCommonForEachStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeForStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeUsingStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeWhileStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDoStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLockStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFixedStatement(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, StatementSyntax statement, StatementSyntax embeddedStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddExceptionToDocumentationCommentAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeThrowStatement(SyntaxNodeAnalysisContext context, INamedTypeSymbol exceptionSymbol);
    private static void AnalyzeThrowExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol exceptionSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddOrRemoveAccessibilityModifiersAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableDictionary`2<Accessibility, ImmutableDictionary`2<string, string>> _properties;
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    private static ImmutableDictionary`2<Accessibility, ImmutableDictionary`2<string, string>> Properties { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ImmutableDictionary`2<Accessibility, ImmutableDictionary`2<string, string>> get_Properties();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeClassDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEventDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEventFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInterfaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeStructDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeRecordDeclaration(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, MemberDeclarationSyntax declaration, SyntaxTokenList modifiers);
    private static Accessibility GetAccessibility(SyntaxNodeAnalysisContext context, MemberDeclarationSyntax declaration, SyntaxTokenList modifiers);
    private static Nullable`1<Accessibility> GetPartialAccessibility(SyntaxNodeAnalysisContext context, MemberDeclarationSyntax declaration);
    private static Location GetLocation(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<Accessibility, ImmutableDictionary`2<string, string>> <get_Properties>g__CreateProperties|2_0();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddOrRemoveParenthesesFromConditionInConditionalExpressionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConditionalExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddOrRemoveParenthesesWhenCreatingNewObjectAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeObjectCreationExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddOrRemoveRegionNameAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEndRegionDirectiveTrivia(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddOrRemoveTrailingCommaAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInitializerExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAnonymousObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void ReportAdd(SyntaxNodeAnalysisContext context, SyntaxNode lastNode);
    private static void ReportRemove(SyntaxNodeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddParagraphToDocumentationCommentAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSingleLineDocumentationCommentTrivia(SyntaxNodeAnalysisContext context);
    internal static ValueTuple`3<TextSpan, TextSpan, List`1<TextSpan>> FindFixableSpan(SyntaxList`1<XmlNodeSyntax> nodes, bool stopOnFirstMatch, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ValueTuple`3<TextSpan, TextSpan, List`1<TextSpan>> <FindFixableSpan>g__CreateResult|5_0(<>c__DisplayClass5_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddParenthesesWhenNecessaryAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBinaryExpression(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, ExpressionSyntax expression, SyntaxKind binaryExpressionKind);
    private static bool IsNestedDiagnostic(SyntaxNode node);
    internal static bool IsFixable(SyntaxNode node);
    private static bool IsFixable(SyntaxNode node, SyntaxKind binaryExpressionKind);
    private static int GetGroupNumber(SyntaxNode node);
    private static int GetGroupNumber(SyntaxKind kind);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AddStaticModifierToAllPartialClassDeclarationsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamedType(SymbolAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AnalyzerOptionIsObsoleteAnalyzer : AbstractAnalyzerOptionIsObsoleteAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void Validate(SyntaxTreeAnalysisContext& context, CompilationOptions compilationOptions, AnalyzerConfigOptions configOptions, Flags flag, Flags& flags, DiagnosticDescriptor analyzer, ConfigOptionDescriptor option, LegacyConfigOptionDescriptor legacyOption, string newValue);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AnonymousMethodAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAnonymousMethod(SyntaxNodeAnalysisContext context);
    private static void FadeOut(SyntaxNodeAnalysisContext context, AnonymousMethodExpressionSyntax anonymousMethod);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AsyncSuffixAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static bool IsAsyncEnumerableLike(ITypeSymbol typeSymbol);
    [CompilerGeneratedAttribute]
internal static bool <IsAsyncEnumerableLike>g__IsAsyncEnumerable|5_0(ITypeSymbol typeSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AttributeArgumentListAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAttributeArgumentList(SyntaxNodeAnalysisContext context);
}
internal static class Roslynator.CSharp.Analysis.AvoidBoxingOfValueTypeAnalysis : object {
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AvoidBoxingOfValueTypeAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInterpolation(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AvoidChainOfAssignmentsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAssignment(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEqualsValueClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AvoidEmptyCatchClauseThatCatchesSystemExceptionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCatchClause(SyntaxNodeAnalysisContext context, ITypeSymbol exceptionSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AvoidLockingOnPubliclyAccessibleInstanceAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeLockStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AvoidNullReferenceExceptionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static void AnalyzeAsExpression(SyntaxNodeAnalysisContext context);
    private static ExpressionSyntax GetAccessExpression(ExpressionSyntax expression);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__ContainsComplementMethod|4_0(IMethodSymbol methodSymbol, ImmutableArray`1<ISymbol> symbols);
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__TypeSymbolEquals|4_1(ITypeSymbol symbol1, ITypeSymbol symbol2);
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__ParameterSymbolEquals|4_2(IParameterSymbol x, IParameterSymbol y);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AvoidUsageOfDoStatementToCreateInfiniteLoopAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeDoStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AvoidUsageOfForStatementToCreateInfiniteLoopAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeForStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AvoidUsageOfUsingAliasDirectiveAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeUsingDirective(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.AvoidUsageOfWhileStatementToCreateInfiniteLoopAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeWhileStatement(SyntaxNodeAnalysisContext context);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public abstract class Roslynator.CSharp.Analysis.BaseDiagnosticAnalyzer : DiagnosticAnalyzer {
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private string get_DebuggerDisplay();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.BinaryOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSimpleMemberAccessExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeGreaterThanOrEqualExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeGreaterThanExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLessThanOrEqualExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLessThanExpression(SyntaxNodeAnalysisContext context);
    private static bool IsAlwaysEqualToTrueOrFalse(BinaryExpressionSyntax binaryExpression, ExpressionSyntax left, ExpressionSyntax right, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsUnnecessaryRelationalOperator(ExpressionSyntax left, ExpressionSyntax right, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsCountOrLengthProperty(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static void AnalyzeLogicalOrExpression(SyntaxNodeAnalysisContext context);
    private static void ReportExpressionAlwaysEqualToTrueOrFalse(SyntaxNodeAnalysisContext context, string booleanName);
    private static void ReportExpressionAlwaysEqualToTrueOrFalse(SyntaxNodeAnalysisContext context, SyntaxNode node, string booleanName);
    private static void ReportUnnecessaryRelationalOperator(SyntaxNodeAnalysisContext context, SyntaxToken operatorToken);
    [CompilerGeneratedAttribute]
internal static bool <IsAlwaysEqualToTrueOrFalse>g__IsReversedForStatement|9_0(<>c__DisplayClass9_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.BitwiseOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBinaryExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol flagsAttribute);
    private static void AnalyzeBitwiseNotExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol flagsAttribute);
    private static bool IsEnumWithoutFlags(ExpressionSyntax expression, INamedTypeSymbol flagsAttribute, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.BooleanLiteralAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeForStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIsPatternExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEqualsExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeNotEqualsExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLogicalAndExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLogicalOrExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEqualsNotEquals(SyntaxNodeAnalysisContext context, BinaryExpressionSyntax binaryExpression, ExpressionSyntax left, ExpressionSyntax right, SyntaxKind kind, SyntaxKind kind2);
    private static void AnalyzeLogicalAndLogicalOr(SyntaxNodeAnalysisContext context, BinaryExpressionSyntax binaryExpression, ExpressionSyntax left, ExpressionSyntax right, SyntaxKind kind);
    private static AnalysisResult AnalyzeExpression(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Analysis.CallCastInsteadOfSelectAnalysis : object {
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    internal static CastExpressionSyntax GetCastExpression(CSharpSyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.CallExtensionMethodAsInstanceMethodAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInvocationExpression(SyntaxNodeAnalysisContext context);
}
internal static class Roslynator.CSharp.Analysis.CallThenByInsteadOfOrderByAnalysis : object {
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static bool IsOrderByOrOrderByDescending(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Analysis.CombineEnumerableWhereMethodChainAnalysis : object {
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo, SimpleMemberInvocationExpressionInfo& invocationInfo2);
    private static bool AreEquivalentLambdas(ExpressionSyntax expression1, ExpressionSyntax expression2);
    private static bool ParameterIdentifierEquals(ParameterSyntax parameter1, ParameterSyntax parameter2);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ConditionalExpressionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConditionalExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ConfigureAwaitAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AddCallToConfigureAwait(SyntaxNodeAnalysisContext context);
    private static void RemoveCallToConfigureAwait(SyntaxNodeAnalysisContext context);
    public static bool IsConfigureAwait(ExpressionSyntax expression);
    private static bool IsConfigureAwait(SimpleMemberInvocationExpressionInfo invocationInfo);
    private static bool IsConfigureAwaitable(ITypeSymbol typeSymbol, SemanticModel semanticModel, int position);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ConstantValuesShouldBePlacedOnRightSideOfComparisonsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBinaryExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ConvertCommentToDocumentationCommentAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeClassDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeStructDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeRecordDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInterfaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEnumMembers(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members);
    private static void AnalyzeDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDestructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEventFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEventDeclaration(SyntaxNodeAnalysisContext context);
    private static bool AnalyzeLeading(SyntaxNodeAnalysisContext context);
    private static bool AnalyzeLeading(SyntaxNodeAnalysisContext context, SyntaxNode node);
    private static Nullable`1<TrailingAnalysis> AnalyzeTrailing(Nullable`1<SyntaxNodeOrToken> nodeOrToken);
    private static Nullable`1<TrailingAnalysis> AnalyzeTrailing(SyntaxNodeOrToken nodeOrToken);
    private static Nullable`1<TrailingAnalysis> AnalyzeTrailing(SyntaxList`1<TNode> nodes);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, Nullable`1<TrailingAnalysis> analysis);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, TextSpan span);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ConvertInterpolatedStringToConcatenationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInterpolatedStringExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.DeclareEachAttributeSeparatelyAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAttributeList(SyntaxNodeAnalysisContext context);
    public static bool IsFixable(AttributeListSyntax attributeList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.DeclareEachTypeInSeparateFileAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, MemberDeclarationSyntax member);
    private static bool ContainsSingleNamespaceWithSingleNonNamespaceMember(SyntaxList`1<MemberDeclarationSyntax> members);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeCompilationUnit>g__Analyze|4_0(SyntaxList`1<MemberDeclarationSyntax> members, <>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.DeclareTypeInsideNamespaceAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamedType(SymbolAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.DeclareUsingDirectiveOnTopLevelAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamespaceDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.DefaultExpressionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    public static void AnalyzeDefaultExpression(SyntaxNodeAnalysisContext context);
    private static bool IsTypeInferredFromDefaultExpression(SyntaxNodeAnalysisContext context, SyntaxNode node);
    private static bool IsTypeInferredFromDefaultExpression2(SyntaxNodeAnalysisContext context, SyntaxNode anonymousFunction);
    private static bool IsGenericInvocation(InvocationExpressionSyntax invocationExpression);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeDefaultExpression>g__ReportDiagnostic|4_0(<>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.DefaultLabelShouldBeLastLabelInSwitchSectionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSwitchSection(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.DisposeResourceAsynchronouslyAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeLocalDeclarationStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeUsingStatement(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, StatementSyntax statement, SyntaxToken usingKeyword, ExpressionSyntax value);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxTokenList modifiers, SyntaxToken usingKeyword, SyntaxNode containingMethod);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxToken usingKeyword);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.DuplicateWordInCommentAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeXmlText(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeXmlText>g__ScanWord|4_0(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeXmlText>g__ScanToWord|4_1(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeXmlText>g__ScanToNextWord|4_2(<>c__DisplayClass4_0& );
}
internal static class Roslynator.CSharp.Analysis.EmbeddedStatementAnalysis : object {
    public static bool FormattingSupportsEmbeddedStatement(IfStatementSyntax ifStatement);
    public static bool FormattingSupportsEmbeddedStatement(DoStatementSyntax doStatement);
    public static bool FormattingSupportsEmbeddedStatement(CommonForEachStatementSyntax forEachStatement);
    public static bool FormattingSupportsEmbeddedStatement(ForStatementSyntax forStatement);
    public static bool FormattingSupportsEmbeddedStatement(UsingStatementSyntax usingStatement);
    public static bool FormattingSupportsEmbeddedStatement(WhileStatementSyntax whileStatement);
    public static bool FormattingSupportsEmbeddedStatement(LockStatementSyntax lockStatement);
    public static bool FormattingSupportsEmbeddedStatement(FixedStatementSyntax fixedStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.EnumShouldDeclareExplicitValuesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.EnumSymbolAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamedType(SymbolAnalysisContext context);
    private static bool ContainsFieldWithZeroValue(ImmutableArray`1<ISymbol> members);
    private static bool IsMaxValue(ulong value, SpecialType numericType);
    private static void ReportUndefinedFlag(SymbolAnalysisContext context, ISymbol fieldSymbol, string value);
    private static void ReportDuplicateValue(SymbolAnalysisContext context, EnumMemberDeclarationSyntax enumMember, ExpressionSyntax value);
    private static void ReportDuplicateValue(SymbolAnalysisContext context, SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.FileContainsNoCodeAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
}
public static class Roslynator.CSharp.Analysis.FixDocumentationCommentTagAnalysis : object {
    public static void Analyze(SyntaxNodeAnalysisContext context, XmlElementInfo elementInfo);
    private static void AnalyzeList(SyntaxNodeAnalysisContext context, XmlElementInfo elementInfo);
    private static void AnalyzeCElement(SyntaxNodeAnalysisContext context, XmlElementInfo elementInfo);
    private static void AnalyzeCodeElement(SyntaxNodeAnalysisContext context, XmlElementInfo elementInfo);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.FormatDocumentationCommentSummaryAnalyzer : BaseDiagnosticAnalyzer {
    internal static Regex SingleLineSummaryRegex;
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FormatDocumentationCommentSummaryAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSingleLineDocumentationCommentTrivia(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.FormatSummaryOnMultipleLinesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSingleLineDocumentationCommentTrivia(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.FormatSummaryOnSingleLineAnalyzer : BaseDiagnosticAnalyzer {
    private static Regex _regex;
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FormatSummaryOnSingleLineAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSingleLineDocumentationCommentTrivia(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.IfStatementAnalyzer : BaseDiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private static IfAnalysisOptions <AnalysisOptions>k__BackingField;
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    internal static IfAnalysisOptions AnalysisOptions { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IfStatementAnalyzer();
    [CompilerGeneratedAttribute]
internal static IfAnalysisOptions get_AnalysisOptions();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ImplementExceptionConstructorsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamedType(SymbolAnalysisContext context, INamedTypeSymbol exceptionSymbol);
    private static bool IsSerializationConstructor(IMethodSymbol methodSymbol);
}
internal class Roslynator.CSharp.Analysis.ImplicitOrExplicitArrayCreationAnalysis : ImplicitOrExplicitCreationAnalysis {
    [CompilerGeneratedAttribute]
private static ImplicitOrExplicitArrayCreationAnalysis <Instance>k__BackingField;
    public static ImplicitOrExplicitArrayCreationAnalysis Instance { get; }
    private static ImplicitOrExplicitArrayCreationAnalysis();
    [CompilerGeneratedAttribute]
public static ImplicitOrExplicitArrayCreationAnalysis get_Instance();
    public virtual void AnalyzeCollectionExpression(SyntaxNodeAnalysisContext& context);
    public virtual void AnalyzeExplicitCreation(SyntaxNodeAnalysisContext& context);
    private void AnalyzeExplicitObvious(SyntaxNodeAnalysisContext& context, bool allowCollectionExpression);
    private void AnalyzeExplicitNotObvious(SyntaxNodeAnalysisContext& context, bool allowCollectionExpression);
    private bool AnalyzeExplicit(SyntaxNodeAnalysisContext& context, bool isObvious, bool allowCollectionExpression);
    public virtual void AnalyzeImplicitCreation(SyntaxNodeAnalysisContext& context);
    protected virtual bool IsInitializerObvious(SyntaxNodeAnalysisContext& context);
    private static bool IsInitializerObvious(SyntaxNodeAnalysisContext& context, ExpressionSyntax creationExpression, InitializerExpressionSyntax initializer);
    public virtual TypeStyle GetTypeStyle(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportExplicitToImplicit(SyntaxNodeAnalysisContext& context);
    private static Location GetLocationFromExplicit(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportImplicitToExplicit(SyntaxNodeAnalysisContext& context);
    private static Location GetLocationFromImplicit(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportVarToExplicit(SyntaxNodeAnalysisContext& context, TypeSyntax type);
    private static bool IsInitializerObvious(SyntaxNodeAnalysisContext& context, CollectionExpressionSyntax collectionExpression);
    protected virtual bool UseCollectionExpressionFromImplicit(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportExplicitToCollectionExpression(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportImplicitToCollectionExpression(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportCollectionExpressionToImplicit(SyntaxNodeAnalysisContext& context);
    private static bool CanConvertCollectionExpression(SyntaxNodeAnalysisContext& context, CollectionExpressionSyntax collectionExpression);
}
internal abstract class Roslynator.CSharp.Analysis.ImplicitOrExplicitCreationAnalysis : object {
    protected static ImmutableDictionary`2<string, string> _implicitToCollectionExpression;
    protected static ImmutableDictionary`2<string, string> _collectionExpressionToImplicit;
    protected static ImmutableDictionary`2<string, string> _explicitToCollectionExpression;
    protected static ImmutableDictionary`2<string, string> _varToExplicit;
    private static ImplicitOrExplicitCreationAnalysis();
    public abstract virtual TypeStyle GetTypeStyle(SyntaxNodeAnalysisContext& context);
    protected abstract virtual void ReportExplicitToImplicit(SyntaxNodeAnalysisContext& context);
    protected abstract virtual void ReportImplicitToExplicit(SyntaxNodeAnalysisContext& context);
    protected abstract virtual void ReportVarToExplicit(SyntaxNodeAnalysisContext& context, TypeSyntax type);
    protected abstract virtual void ReportExplicitToCollectionExpression(SyntaxNodeAnalysisContext& context);
    protected abstract virtual void ReportImplicitToCollectionExpression(SyntaxNodeAnalysisContext& context);
    protected abstract virtual void ReportCollectionExpressionToImplicit(SyntaxNodeAnalysisContext& context);
    public abstract virtual void AnalyzeCollectionExpression(SyntaxNodeAnalysisContext& context);
    protected virtual bool IsInitializerObvious(SyntaxNodeAnalysisContext& context);
    public virtual void AnalyzeExplicitCreation(SyntaxNodeAnalysisContext& context);
    public virtual void AnalyzeImplicitCreation(SyntaxNodeAnalysisContext& context);
    protected void AnalyzeImplicit(SyntaxNodeAnalysisContext& context);
    private void AnalyzeType(SyntaxNodeAnalysisContext& context, ExpressionSyntax creationExpression, TypeSyntax type, bool extractGenericType);
    private void AnalyzeArrayType(SyntaxNodeAnalysisContext& context, ExpressionSyntax creationExpression, TypeSyntax type);
    private void AnalyzeExpression(SyntaxNodeAnalysisContext& context, ExpressionSyntax creationExpression, ExpressionSyntax expression, bool extractGenericType);
    private void AnalyzeTypeSymbol(SyntaxNodeAnalysisContext& context, ExpressionSyntax creationExpression, ITypeSymbol typeSymbol1);
    protected static TypeSyntax DetermineReturnType(SyntaxNode node);
    private bool AnalyzeImplicitObvious(SyntaxNodeAnalysisContext& context);
    private bool AnalyzeImplicitNotObvious(SyntaxNodeAnalysisContext& context);
    private bool AnalyzeImplicit(SyntaxNodeAnalysisContext& context, bool isObvious, bool allowCollectionExpression);
    protected static bool IsSingleReturnStatement(SyntaxNode parent);
    protected abstract virtual bool UseCollectionExpressionFromImplicit(SyntaxNodeAnalysisContext& context);
    protected static bool UseCollectionExpression(SyntaxNodeAnalysisContext& context);
}
internal class Roslynator.CSharp.Analysis.ImplicitOrExplicitObjectCreationAnalysis : ImplicitOrExplicitCreationAnalysis {
    [CompilerGeneratedAttribute]
private static ImplicitOrExplicitObjectCreationAnalysis <Instance>k__BackingField;
    public static ImplicitOrExplicitObjectCreationAnalysis Instance { get; }
    private static ImplicitOrExplicitObjectCreationAnalysis();
    [CompilerGeneratedAttribute]
public static ImplicitOrExplicitObjectCreationAnalysis get_Instance();
    public virtual TypeStyle GetTypeStyle(SyntaxNodeAnalysisContext& context);
    public virtual void AnalyzeCollectionExpression(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportExplicitToImplicit(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportImplicitToExplicit(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportVarToExplicit(SyntaxNodeAnalysisContext& context, TypeSyntax type);
    protected virtual bool UseCollectionExpressionFromImplicit(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportExplicitToCollectionExpression(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportImplicitToCollectionExpression(SyntaxNodeAnalysisContext& context);
    protected virtual void ReportCollectionExpressionToImplicit(SyntaxNodeAnalysisContext& context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.InlineLocalVariableAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeLocalDeclarationStatement(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxList`1<StatementSyntax> statements, SingleLocalDeclarationStatementInfo& localDeclarationInfo, int index, ExpressionStatementSyntax expressionStatement);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxList`1<StatementSyntax> statements, SingleLocalDeclarationStatementInfo& localDeclarationInfo, int index, LocalDeclarationStatementSyntax localDeclaration2);
    private static ISymbol GetLocalSymbol(SingleLocalDeclarationStatementInfo& localDeclarationInfo, ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SingleLocalDeclarationStatementInfo& localDeclarationInfo, ExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.InvalidArgumentNullCheckAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeParameterList(SyntaxNodeAnalysisContext context, ParameterListSyntax parameterList, BlockSyntax body);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeParameterList>g__IsNullableReferenceType|6_0(SyntaxNodeAnalysisContext context, ParameterSyntax parameter);
    [CompilerGeneratedAttribute]
internal static ParameterSyntax <AnalyzeParameterList>g__FindParameter|6_1(string name, <>c__DisplayClass6_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.InvocationExpressionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInvocationExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.JoinStringExpressionsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAddExpression(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, ExpressionSyntax firstExpression, ExpressionSyntax lastExpression, bool isVerbatim);
    private static bool CheckHexadecimalEscapeSequence(StringLiteralExpressionInfo& stringLiteral);
    private static bool CheckHexadecimalEscapeSequence(InterpolatedStringExpressionSyntax interpolatedString);
    private static bool CheckHexadecimalEscapeSequence(string text, int start, int length);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.LambdaExpressionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeLambdaExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.MakeClassSealedAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamedType(SymbolAnalysisContext context);
    private static bool ContainsDerivedType(INamedTypeSymbol typeSymbol, ImmutableArray`1<INamedTypeSymbol> typeMembers);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.MakeClassStaticAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeClassDeclaration(SyntaxNodeAnalysisContext context);
    public static bool AnalyzeMembers(ImmutableArray`1<ISymbol> members);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.MakeMemberReadOnly.MakeMemberReadOnlyAnalyzer : BaseDiagnosticAnalyzer {
    private static MetadataName Microsoft_AspNetCore_Components_ParameterAttribute;
    private static MetadataName Microsoft_AspNetCore_Components_CascadingParameterAttribute;
    private static MetadataName Microsoft_AspNetCore_Components_InjectAttribute;
    private static MetadataName Newtonsoft_Json_JsonPropertyAttribute;
    private static MetadataName UnityEngine_SerializeField;
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MakeMemberReadOnlyAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTypeDeclaration(SyntaxNodeAnalysisContext context, TypeDeclarationSyntax typeDeclaration, MakeMemberReadOnlyWalker walker);
    private static bool AnalyzePropertyAttributes(IPropertySymbol propertySymbol);
    private static bool ValidateType(ITypeSymbol type);
}
internal class Roslynator.CSharp.Analysis.MakeMemberReadOnly.MakeMemberReadOnlyWalker : AssignedExpressionWalker {
    private int _classOrStructDepth;
    private int _localFunctionDepth;
    private int _anonymousFunctionDepth;
    private bool _isInInstanceConstructor;
    private bool _isInStaticConstructor;
    [ThreadStaticAttribute]
private static MakeMemberReadOnlyWalker _cachedInstance;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ValueTuple`2<SyntaxNode, ISymbol>> <Symbols>k__BackingField;
    public SemanticModel SemanticModel { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public Dictionary`2<string, ValueTuple`2<SyntaxNode, ISymbol>> Symbols { get; }
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public void set_SemanticModel(SemanticModel value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ValueTuple`2<SyntaxNode, ISymbol>> get_Symbols();
    public static MakeMemberReadOnlyWalker GetInstance();
    public static void Free(MakeMemberReadOnlyWalker walker);
    private void Reset();
    public virtual void VisitAssignedExpression(ExpressionSyntax expression);
    private void AnalyzeAssigned(IdentifierNameSyntax identifierName, bool isInInstanceConstructor);
    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual void VisitRefExpression(RefExpressionSyntax node);
    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node);
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual void VisitStructDeclaration(StructDeclarationSyntax node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.MakeMethodExtensionMethodAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeClassDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.MarkLocalVariableAsConst.LocalDeclarationStatementAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeLocalDeclarationStatement(SyntaxNodeAnalysisContext context);
    private static bool CanBeMarkedAsConst(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables, SyntaxList`1<StatementSyntax> statements, int startIndex);
    private static bool HasConstantValue(ExpressionSyntax expression, ITypeSymbol typeSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ContainsInterpolatedString(SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
}
internal class Roslynator.CSharp.Analysis.MarkLocalVariableAsConst.MarkLocalVariableAsConstWalker : AssignedExpressionWalker {
    [ThreadStaticAttribute]
private static MarkLocalVariableAsConstWalker _cachedInstance;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ILocalSymbol> <Identifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Result>k__BackingField;
    public Dictionary`2<string, ILocalSymbol> Identifiers { get; }
    public SemanticModel SemanticModel { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public bool Result { get; public set; }
    protected bool ShouldVisit { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ILocalSymbol> get_Identifiers();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public void set_SemanticModel(SemanticModel value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public bool get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(bool value);
    protected virtual bool get_ShouldVisit();
    public virtual void VisitAssignedExpression(ExpressionSyntax expression);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    private bool IsLocalReference(SyntaxNode node);
    private bool IsLocalReference(IdentifierNameSyntax identifierName);
    public static MarkLocalVariableAsConstWalker GetInstance();
    public static void Free(MarkLocalVariableAsConstWalker walker);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.MarkTypeWithDebuggerDisplayAttributeAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    public static void AnalyzerNamedTypeSymbol(SymbolAnalysisContext context, INamedTypeSymbol debuggerDisplayAttributeSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.MergeElseWithNestedIfAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeElseClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.MergeIfWithNestedIfAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, IfStatementSyntax ifStatement, IfStatementSyntax nestedIf);
    private static bool CheckTrivia(IfStatementSyntax ifStatement, IfStatementSyntax nestedIf);
    internal static IfStatementSyntax GetNestedIfStatement(IfStatementSyntax ifStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.MergePreprocessorDirectivesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzePragmaWarningDirectiveTrivia(SyntaxNodeAnalysisContext context);
    private static bool IsSuppressingThisAnalyzer(SeparatedSyntaxList`1<ExpressionSyntax> errorCodes);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.MergeSwitchSectionsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSwitchStatement(SyntaxNodeAnalysisContext context);
    private static SwitchSectionSyntax FindFixableSection(SyntaxList`1<SwitchSectionSyntax> sections);
    private static bool AreEquivalent(SyntaxList`1<StatementSyntax> statements1, SyntaxList`1<StatementSyntax> statements2);
    private static bool AreEquivalent(StatementSyntax statement1, StatementSyntax statement2);
    private static bool AreEquivalentJumpStatements(StatementSyntax statement1, StatementSyntax statement2);
    internal static SyntaxList`1<StatementSyntax> GetStatementsOrDefault(SwitchSectionSyntax section);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.NamedTypeSymbolAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamedType(SymbolAnalysisContext context);
    private static void ReportDiagnostic(SymbolAnalysisContext context, INamedTypeSymbol symbol, string interfaceName, string genericInterfaceName);
    [CompilerGeneratedAttribute]
internal static SyntaxToken <ReportDiagnostic>g__GetIdentifier|5_0(<>c__DisplayClass5_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.NormalizeFormatOfEnumFlagValueAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static bool IsFlag(SyntaxNodeAnalysisContext context, EnumMemberDeclarationSyntax declaration);
    private static void Analyze(SyntaxNodeAnalysisContext context, EnumMemberDeclarationSyntax member, ExpressionSyntax value, EnumFlagValueStyle style);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.NormalizeNullCheckAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEqualsExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeNotEqualsExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIsPatternExpression(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, ExpressionSyntax expression, string messageArg);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.NormalizeUsageOfInfiniteLoopAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeForStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeWhileStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDoStatement(SyntaxNodeAnalysisContext context);
}
internal static class Roslynator.CSharp.Analysis.OptimizeLinqMethodCallAnalysis : object {
    public static void AnalyzeAny(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeWhere(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeSelectAndAverageOrMinOrMaxOrSum(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeSelectAndToList(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static void SimplifyLinqMethodChain(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo, string methodName, ImmutableDictionary`2<string, string> properties);
    public static void AnalyzeFirstOrDefault(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeWhereAndAny(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeWhereAndCast(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeOfType(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeFirst(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeCount(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeOrderByAndWhere(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeOrderByAndReverse(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void AnalyzeOrderByIdentity(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static bool AnalyzeSelectManyAndCount(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static ExpressionSyntax GetLambdaExpression(ExpressionSyntax expression);
    private static bool CheckInfiniteRecursion(ITypeSymbol typeSymbol, string propertyName, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static void ReportNameWithArgumentList(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo, bool checkDirectives, ImmutableDictionary`2<string, string> properties, String[] messageArgs);
    private static void Report(SyntaxNodeAnalysisContext context, SyntaxNode node, bool checkDirectives, ImmutableDictionary`2<string, string> properties, String[] messageArgs);
    private static void Report(SyntaxNodeAnalysisContext context, SyntaxNode node, TextSpan span, bool checkDirectives, ImmutableDictionary`2<string, string> properties, String[] messageArgs);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeCount>g__CanBeReplacedWithMemberAccessExpression|10_0(ExpressionSyntax e, <>c__DisplayClass10_0& );
}
internal static class Roslynator.CSharp.Analysis.OptimizeMethodCallAnalysis : object {
    public static void OptimizeStringCompare(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void OptimizeDebugAssert(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void OptimizeStringJoin(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void OptimizeDictionaryContainsKey(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    public static void OptimizeAdd(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    [CompilerGeneratedAttribute]
internal static bool <OptimizeDebugAssert>g__ContainsFailMethod|1_0(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static IfStatementSyntax <OptimizeDictionaryContainsKey>g__GetIfStatement|3_0(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static bool <OptimizeDictionaryContainsKey>g__IsDictionaryContainsKey|3_1(IMethodSymbol symbol);
    [CompilerGeneratedAttribute]
internal static bool <OptimizeDictionaryContainsKey>g__IsDictionaryAdd|3_2(IMethodSymbol symbol);
}
internal static class Roslynator.CSharp.Analysis.OptimizeStringBuilderAppendCallAnalysis : object {
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    [CompilerGeneratedAttribute]
internal static void <Analyze>g__ReportDiagnostic|0_0(SyntaxNode node, <>c__DisplayClass0_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.OrderModifiersAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeClassDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEventDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEventFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInterfaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeStructDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeRecordDeclaration(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxTokenList modifiers);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.OrderNamedArgumentsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBaseArgumentList(SyntaxNodeAnalysisContext context);
    internal static ValueTuple`2<int, int> FindFixableSpan(SeparatedSyntaxList`1<ArgumentSyntax> arguments, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsFixable(int firstIndex, SeparatedSyntaxList`1<ArgumentSyntax> arguments, ImmutableArray`1<IParameterSymbol> parameters);
    private static ValueTuple`2<int, int> GetFixableSpan(int firstIndex, SeparatedSyntaxList`1<ArgumentSyntax> arguments, ImmutableArray`1<IParameterSymbol> parameters);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.OrderTypeParameterConstraintsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTypeParameterList(SyntaxNodeAnalysisContext context);
    private static bool IsFixable(SeparatedSyntaxList`1<TypeParameterSyntax> typeParameters, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    internal static int IndexOf(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, string name);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.OverridingMemberShouldNotChangeParamsModifierAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodSymbol(SymbolAnalysisContext context);
    private static void AnalyzePropertySymbol(SymbolAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ParameterNameDiffersFromBaseAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodSymbol(SymbolAnalysisContext context);
    private static void AnalyzePropertySymbol(SymbolAnalysisContext context);
    private static void Analyze(SymbolAnalysisContext context, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<IParameterSymbol> parameters2);
}
public static class Roslynator.CSharp.Analysis.PatternMatchingVariableDeclarationHelper : object {
    public static bool AnyDeclaredVariablesMatch(PatternSyntax pattern, ImmutableHashSet`1<string> variableNames);
    internal static bool AnyDeclaredVariablesMatch(VariableDesignationSyntax designation, ImmutableHashSet`1<string> variableNames);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ReduceIfNestingAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RefReadOnlyParameterAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLocalFunction(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxNode declaration, ParameterListSyntax parameterList, CSharpSyntaxNode bodyOrExpressionBody);
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__IsReferencedAsMethodGroup|9_0(<>c__DisplayClass9_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveBracesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCommonForEachStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeForStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeUsingStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeWhileStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDoStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLockStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFixedStatement(SyntaxNodeAnalysisContext context);
    private static BlockSyntax GetFixableBlock(StatementSyntax statement);
    private static void Analyze(SyntaxNodeAnalysisContext context, BlockSyntax block);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveBracesFromIfElseAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveEmptyDestructorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeDestructorDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveEmptyElseClauseAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeElseClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveEmptyFinallyClauseAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeFinallyClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveEmptyInitializerAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeObjectCreationExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveEmptyNamespaceDeclarationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamespaceDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveEmptyRegionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeRegionDirective(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveEmptyStatementAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEmptyStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveEmptySyntaxAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeDestructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeElseClause(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFinallyClause(SyntaxNodeAnalysisContext context);
    private static void AnalyzeObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFileScopedNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeRegionDirective(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEmptyStatement(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxNode node, string name);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveEnumDefaultUnderlyingTypeAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveOriginalExceptionFromThrowStatementAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCatchClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemovePartialModifierFromTypeWithSinglePartAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    private static MetadataName[] _metadataNames;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RemovePartialModifierFromTypeWithSinglePartAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTypeDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantAsOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAsExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantAssignmentAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeLocalDeclarationStatement(SyntaxNodeAnalysisContext context);
    private static bool IsReferenced(ILocalSymbol localSymbol, SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static void AnalyzeSimpleAssignment(SyntaxNodeAnalysisContext context);
    private static bool IsDeclaredInTryStatementOrCatchClauseAndReferencedInFinallyClause(SyntaxNodeAnalysisContext context, StatementSyntax statement, ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeSimpleAssignment>g__IsAssignedInsideAnonymousFunctionButDeclaredOutsideOfIt|6_0(<>c__DisplayClass6_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantAsyncAwaitAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxToken asyncKeyword, RemoveAsyncAwaitAnalysis analysis);
    [CompilerGeneratedAttribute]
internal static void <ReportDiagnostic>g__ReportAwaitAndConfigureAwait|8_0(AwaitExpressionSyntax awaitExpression, <>c__DisplayClass8_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantAutoPropertyInitializationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static bool CanBeConstantValue(ExpressionSyntax value);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantBaseConstructorCallAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantBaseInterfaceAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBaseList(SyntaxNodeAnalysisContext context);
    private static bool IsExplicitlyImplemented(SymbolInterfaceInfo& interfaceInfo, ImmutableArray`1<ISymbol> members);
    private static bool IsImplementedWithNewKeyword(SymbolInterfaceInfo& interfaceInfo, INamedTypeSymbol typeSymbol, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeBaseList>g__Analyze|4_0(SymbolInterfaceInfo& interfaceInfo, SymbolInterfaceInfo& interfaceInfo2, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsExplicitlyImplemented>g__IsExplicitlyImplemented|5_0(ISymbol interfaceSymbol, <>c__DisplayClass5_0& );
}
internal static class Roslynator.CSharp.Analysis.RemoveRedundantBooleanLiteralAnalysis : object {
    public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, BinaryExpressionSyntax binaryExpression, ExpressionSyntax left, ExpressionSyntax right);
    public static TextSpan GetSpanToRemove(BinaryExpressionSyntax binaryExpression, ExpressionSyntax left, ExpressionSyntax right);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantCastAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCastExpression(SyntaxNodeAnalysisContext context);
    private static bool CheckExplicitImplementation(ITypeSymbol typeSymbol, ISymbol symbol);
    private static bool CheckAccessibility(ITypeSymbol expressionTypeSymbol, ISymbol accessedSymbol, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ExpressionSyntax GetAccessedExpression(SyntaxNode node);
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantCommaInInitializerAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInitializerExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantConstructorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static bool CheckStructWithFieldInitializer(ConstructorDeclarationSyntax constructor);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantDefaultSwitchSectionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSwitchStatement(SyntaxNodeAnalysisContext context);
    private static bool ContainsOnlyBreakStatement(SwitchSectionSyntax switchSection);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantDelegateCreationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAssignmentExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantDisposeOrCloseCallAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeUsingStatement(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, ExpressionStatementSyntax expressionStatement, string methodName);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantFieldInitializationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static bool CanBeConstantValue(ExpressionSyntax value);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantOverridingMemberAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static bool CheckModifiers(SyntaxTokenList modifiers);
    private static bool CheckParameters(BaseParameterListSyntax parameterList, BaseArgumentListSyntax argumentList, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IParameterSymbol GetParameterSymbol(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CheckDefaultValues(ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<IParameterSymbol> baseParameters);
    private static ExpressionSyntax GetMethodExpression(MethodDeclarationSyntax methodDeclaration);
    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context);
    internal static bool IsFixable(PropertyDeclarationSyntax propertyDeclaration, AccessorDeclarationSyntax accessor, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static void AnalyzeIndexerDeclaration(SyntaxNodeAnalysisContext context);
    internal static bool IsFixable(IndexerDeclarationSyntax indexerDeclaration, AccessorDeclarationSyntax accessor, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ExpressionSyntax GetGetAccessorExpression(AccessorDeclarationSyntax accessor);
    private static ExpressionSyntax GetSetAccessorExpression(AccessorDeclarationSyntax accessor);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantParenthesesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeParenthesizedExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeParenthesizedExpression>g__ReportDiagnostic|4_1(SyntaxNodeAnalysisContext context, ParenthesizedExpressionSyntax parenthesizedExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantSealedModifierAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethod(SymbolAnalysisContext context);
    private static void AnalyzeProperty(SymbolAnalysisContext context);
    private static void Analyze(SymbolAnalysisContext context, ISymbol symbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveRedundantStatementAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeContinueStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeReturnStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeYieldBreakStatement(SyntaxNodeAnalysisContext context);
}
internal static class Roslynator.CSharp.Analysis.RemoveRedundantStringToCharArrayCallAnalysis : object {
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static bool ParentIsElementAccessOrForEachExpression(ExpressionSyntax expression);
}
internal static class Roslynator.CSharp.Analysis.RemoveRedundantToStringCallAnalysis : object {
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static bool IsFixable(SimpleMemberInvocationExpressionInfo& invocationInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsNotHidden(IMethodSymbol methodSymbol, INamedTypeSymbol containingType);
    [CompilerGeneratedAttribute]
internal static bool <IsFixable>g__IsToString|1_0(IMethodSymbol methodSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveUnnecessaryBlankLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeClassDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeStructDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeRecordDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInterfaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTryStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeElseClause(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCommonForEachStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeForStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeUsingStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeWhileStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDoStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLockStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFixedStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEmbeddedStatement(SyntaxNodeAnalysisContext context, SyntaxToken token, StatementSyntax statement);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxNode node1, SyntaxNode node2);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxToken token, SyntaxNode node);
    private static void AnalyzeDeclaration(SyntaxNodeAnalysisContext context, SyntaxList`1<TMember> members, SyntaxToken openBrace, SyntaxToken closeBrace);
    private static void AnalyzeDeclaration(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<TMember> members, SyntaxToken openBrace, SyntaxToken closeBrace);
    private static void AnalyzeBlock(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSingleLineDocumentationCommentTrivia(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInitializer(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAccessorList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void AnalyzeStart(SyntaxNodeAnalysisContext context, SyntaxNode node, SyntaxToken brace);
    private static void AnalyzeEnd(SyntaxNodeAnalysisContext context, SyntaxNodeOrToken nodeOrToken, SyntaxToken brace);
    private static void AnalyzeEmptyBraces(SyntaxNodeAnalysisContext context, SyntaxToken openBrace, SyntaxToken closeBrace);
    private static Nullable`1<TextSpan> GetEmptyLineSpan(SyntaxTriviaList triviaList, bool isEnd);
    private static bool IsStandardTriviaBetweenLines(SyntaxTriviaList trailingTrivia, SyntaxTriviaList leadingTrivia);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, TextSpan span);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeInitializer>g__IsExpectedTrailingTrivia|27_0(SyntaxTriviaList triviaList);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveUnnecessaryBracesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeRecordDeclaration(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, TypeDeclarationSyntax typeDeclaration);
    private static void AnalyzeTypeDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveUnnecessaryBracesInSwitchSectionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    public static void AnalyzerSwitchSection(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzerSwitchSection>g__AnalyzeTrivia|4_0(SyntaxTriviaList trivia);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveUnnecessaryCaseLabelAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSwitchSection(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.RemoveUnnecessaryElseAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    public static void Analyze(SyntaxNodeAnalysisContext context);
    private static bool IsFixable(ElseClauseSyntax elseClause, SemanticModel semanticModel);
    private static bool LocalDeclaredVariablesOverlap(BlockSyntax elseBlock, BlockSyntax ifBlock, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Roslynator.CSharp.Analysis.RequiredConfigOptionNotSetAnalyzer : AbstractRequiredConfigOptionNotSetAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    private static ConfigOptionDescriptor[] _useBlockBodyOrExpressionBodyOptions;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RequiredConfigOptionNotSetAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void Validate(SyntaxTreeAnalysisContext& context, CompilationOptions compilationOptions, AnalyzerConfigOptions configOptions, Flags flag, Flags& flags, DiagnosticDescriptor analyzer, ConfigOptionDescriptor option);
    private static void Validate(SyntaxTreeAnalysisContext& context, CompilationOptions compilationOptions, AnalyzerConfigOptions configOptions, Flags flag, Flags& flags, DiagnosticDescriptor analyzer, ConfigOptionDescriptor[] options);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ReturnTaskInsteadOfNull.ReturnCompletedTaskInsteadOfNullAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLocalFunction(SyntaxNodeAnalysisContext context);
    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAnonymousMethod(SyntaxNodeAnalysisContext context);
    private static void AnalyzeGetAccessor(SyntaxNodeAnalysisContext context, AccessorDeclarationSyntax getter);
    private static void AnalyzeBlock(SyntaxNodeAnalysisContext context, BlockSyntax body);
    public static bool IsTaskOrTaskOfT(ITypeSymbol typeSymbol);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeMethodDeclaration>g__ReturnsTaskOrTaskOfT|4_0(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeLocalFunction>g__ReturnsTaskOrTaskOfT|5_0(<>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzePropertyDeclaration>g__ReturnsTaskOrTaskOfT|6_0(<>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeIndexerDeclaration>g__ReturnsTaskOrTaskOfT|7_0(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeLambdaExpression>g__ReturnsTaskOrTaskOfT|8_0(<>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeAnonymousMethod>g__ReturnsTaskOrTaskOfT|9_0(<>c__DisplayClass9_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SimplifyArgumentNullCheckAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, IfStatementSyntax ifStatement);
}
internal static class Roslynator.CSharp.Analysis.SimplifyBooleanComparisonAnalysis : object {
    public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, BinaryExpressionSyntax binaryExpression, ExpressionSyntax left, ExpressionSyntax right, bool fadeOut);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SimplifyCoalesceExpressionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCoalesceExpression(SyntaxNodeAnalysisContext context);
    private static TextSpan GetRedundantSpan(BinaryExpressionSyntax coalesceExpression, ExpressionSyntax left, ExpressionSyntax right, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static BinaryExpressionPart GetRedundantPart(ExpressionSyntax left, ExpressionSyntax right, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsDefaultOfReferenceOrNullableType(DefaultExpressionSyntax defaultExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SimplifyCodeBranchingAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    internal static Nullable`1<SimplifyCodeBranchingKind> GetKind(IfStatementSyntax ifStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsFixableIfElseWithEmptyIf(IfStatementSyntax ifStatement, ElseClauseSyntax elseClause);
    private static bool IsFixableIfElseWithReturnOrContinueInsideIf(IfStatementSyntax ifStatement, ElseClauseSyntax elseClause);
    private static bool IsFixableIfElseInsideWhile(IfStatementSyntax ifStatement, ElseClauseSyntax elseClause);
    private static bool IsFixableSimpleIfInsideWhileOrDo(IfStatementSyntax ifStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ContainsLocalDefinedInLoopBody(ExpressionSyntax condition, TextSpan span, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal enum Roslynator.CSharp.Analysis.SimplifyCodeBranchingKind : Enum {
    public int value__;
    public static SimplifyCodeBranchingKind IfElseWithEmptyIf;
    public static SimplifyCodeBranchingKind IfElseInsideWhile;
    public static SimplifyCodeBranchingKind SimplifyIfInsideWhileOrDo;
    public static SimplifyCodeBranchingKind SimpleIfContainingOnlyDo;
    public static SimplifyCodeBranchingKind LastIfElseWithReturnOrContinueInsideIf;
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SimplifyConditionalExpressionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConditionalExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeConditionalExpression>g__ReportDiagnostic|4_0(<>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SimplifyLazyInitializationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeGetAccessorDeclaration(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxNode node, BlockSyntax body);
    private static bool ExpressionEquals(ExpressionSyntax expression1, ExpressionSyntax expression2);
    private static bool IdentifierNameEquals(IdentifierNameSyntax identifierName1, IdentifierNameSyntax identifierName2);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SimplifyLogicalNegationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeLogicalNotExpression(SyntaxNodeAnalysisContext context);
    public static bool IsNumericType(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    internal static ExpressionSyntax GetReturnExpression(CSharpSyntaxNode node);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeLogicalNotExpression>g__ReportDiagnostic|4_0(<>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SimplifyNestedUsingStatementAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeUsingStatement(SyntaxNodeAnalysisContext context);
    public static bool ContainsEmbeddableUsingStatement(UsingStatementSyntax usingStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SimplifyNullableOfTAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeGenericName(SyntaxNodeAnalysisContext context);
    private static void AnalyzeQualifiedName(SyntaxNodeAnalysisContext context);
    private static bool IsWithinNameOfExpression(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SimplifyNullCheckAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConditionalExpression(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, ConditionalExpressionInfo& conditionalExpressionInfo, ExpressionSyntax whenNull, ExpressionSyntax whenNotNull, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsDefaultOfNullableStruct(ITypeSymbol typeSymbol, ExpressionSyntax whenNull, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SingleLineDocumentationCommentTriviaAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSingleLineDocumentationCommentTrivia(SyntaxNodeAnalysisContext context);
    private static void AnalyzeUnusedElement(SyntaxNodeAnalysisContext context, XmlElementInfo info, XmlTag tag, bool checkAttributes);
    private static bool IsMissing(DocumentationCommentTriviaSyntax documentationComment, ParameterSyntax parameter);
    private static bool IsMissing(DocumentationCommentTriviaSyntax documentationComment, TypeParameterSyntax typeParameter);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxList`1<XmlNodeSyntax> xmlNodes, SeparatedSyntaxList`1<TNode> nodes, XmlTag tag, Func`3<SeparatedSyntaxList`1<TNode>, string, int> indexOf);
    [CompilerGeneratedAttribute]
internal static string <Analyze>g__GetElementName|8_0(XmlTag tag);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SortEnumMembersAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static bool IsListUnsorted(SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.SplitVariableDeclarationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.StaticMemberInGenericTypeShouldUseTypeParameterAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamedType(SymbolAnalysisContext context);
    private static bool IsTypeParameterReferenced(ImmutableArray`1<ITypeParameterSymbol> typeParameters, ExpressionSyntax value);
    private static bool ContainsAnyTypeParameter(ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters);
    private static bool ContainsAnyTypeParameter(ImmutableArray`1<ITypeParameterSymbol> typeParameters, ITypeSymbol typeSymbol);
    private static bool ContainsAnyTypeParameter(ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<ITypeSymbol> typeArguments);
    private static void ReportDiagnostic(SymbolAnalysisContext context, ISymbol member);
    [CompilerGeneratedAttribute]
internal static bool <IsTypeParameterReferenced>g__IsTypeParameter|5_0(IdentifierNameSyntax identifierName, ImmutableArray`1<ITypeParameterSymbol> typeParameters);
}
internal static class Roslynator.CSharp.Analysis.SwitchLocallyDeclaredVariablesHelper : object {
    internal static bool BlockDeclaredVariablesOverlapWithOtherSwitchSections(BlockSyntax block, SwitchStatementSyntax switchStatement, SemanticModel semanticModel);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ThrowingOfNewNotImplementedExceptionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeThrowStatement(SyntaxNodeAnalysisContext context, INamedTypeSymbol exceptionSymbol);
    private static void AnalyzeThrowExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol exceptionSymbol);
    private static void Analyze(SyntaxNodeAnalysisContext context, ExpressionSyntax expression, INamedTypeSymbol exceptionSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnconstrainedTypeParameterCheckedForNullAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEqualsExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeNotEqualsExpression(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, BinaryExpressionSyntax binaryExpression, NullCheckStyles allowedStyles);
    private static bool IsUnconstrainedTypeParameter(ITypeSymbol typeSymbol);
    private static bool VerifyConstraint(ITypeParameterSymbol typeParameterSymbol, bool allowReference, bool allowValueType, bool allowConstructor);
    private static bool VerifyConstraint(ImmutableArray`1<ITypeSymbol> constraintTypes, bool allowReference, bool allowValueType, bool allowConstructor);
    private static bool CheckConstraint(ITypeParameterSymbol typeParameterSymbol, bool allowReference, bool allowValueType, bool allowConstructor);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessaryAssignmentAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSwitchStatement(SyntaxNodeAnalysisContext context);
    internal static ReturnStatementSyntax FindReturnStatementBelow(SyntaxList`1<StatementSyntax> statements, StatementSyntax statement);
    private static bool IsLocalDeclaredInScopeOrNonRefOrOutParameterOfEnclosingSymbol(ISymbol symbol, SyntaxNode containingNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsSymbolAssignedInStatementWithCorrectType(ISymbol symbol, StatementSyntax statement, SemanticModel semanticModel, ITypeSymbol typeSymbol, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessaryEnumFlagAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBitwiseOrExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeBitwiseOrExpression>g__ReportDiagnostic|4_0(ExpressionSyntax expression, ExpressionSyntax expression2, <>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessaryExplicitUseOfEnumeratorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeUsingStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessaryInterpolatedStringAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInterpolatedStringExpression(SyntaxNodeAnalysisContext context);
    private static TextSpan GetDollarSpan(InterpolatedStringExpressionSyntax interpolatedString);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeInterpolatedStringExpression>g__IsNonNullStringExpression|4_0(ExpressionSyntax expression, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeInterpolatedStringExpression>g__CheckConvertedType|4_1(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessaryInterpolationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInterpolation(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessaryNullCheckAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeLogicalAndExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeLogicalAndExpression>g__Analyze|4_0(ExpressionSyntax expression1, ExpressionSyntax expression2, ExpressionSyntax expression3, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static void <AnalyzeLogicalAndExpression>g__AnalyzeSimpleMemberAccessExpression|4_1(ExpressionSyntax expression, MemberAccessExpressionSyntax memberAccessExpression, ExpressionSyntax expression3, <>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessaryNullForgivingOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static MetadataName System_Diagnostics_CodeAnalysis_MaybeNullWhenAttribute;
    private static MetadataName System_Diagnostics_CodeAnalysis_NotNullIfNotNullAttribute;
    private static MetadataName System_Diagnostics_CodeAnalysis_NotNullWhenAttribute;
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UnnecessaryNullForgivingOperatorAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSuppressNullableWarningExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeSuppressNullableWarningExpression>g__IsNullableReferenceType|7_0(SyntaxNodeAnalysisContext context, TypeSyntax type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessaryRawStringLiteralAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeStringLiteralExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInterpolatedStringExpression(SyntaxNodeAnalysisContext context);
    private static bool ContainsBackSlashOrQuote(string text, int start, int length);
    private static bool ContainsBackSlashOrQuoteOrOpenBrace(string text, int start, int length);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessarySemicolonAtEndOfDeclarationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeClassDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInterfaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeStructDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeRecordDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessaryUnsafeContextAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeUnsafeStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDestructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEventDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEventFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeMemberDeclaration(SyntaxNodeAnalysisContext context, SyntaxNode node, SyntaxTokenList modifiers);
    private static bool AncestorContainsUnsafeModifier(SyntaxNode node);
}
internal class Roslynator.CSharp.Analysis.UnnecessaryUsageOfEnumeratorWalker : BaseCSharpSyntaxWalker {
    [ThreadStaticAttribute]
private static UnnecessaryUsageOfEnumeratorWalker _cachedInstance;
    private ISymbol _symbol;
    private VariableDeclaratorSyntax _variableDeclarator;
    private string _name;
    private SemanticModel _semanticModel;
    private CancellationToken _cancellationToken;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsFixable>k__BackingField;
    public Nullable`1<bool> IsFixable { get; private set; }
    protected bool ShouldVisit { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsFixable();
    [CompilerGeneratedAttribute]
private void set_IsFixable(Nullable`1<bool> value);
    public void SetValues(VariableDeclaratorSyntax variableDeclarator, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool get_ShouldVisit();
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    public static UnnecessaryUsageOfEnumeratorWalker GetInstance();
    public static void Free(UnnecessaryUsageOfEnumeratorWalker walker);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnnecessaryUsageOfVerbatimStringLiteralAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeStringLiteralExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInterpolatedStringExpression(SyntaxNodeAnalysisContext context);
    private static bool ContainsQuoteOrBackslashOrCarriageReturnOrLinefeed(string text, int start, int length);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnusedMember.UnusedMemberAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static bool IsMainMethod(MethodDeclarationSyntax methodDeclaration, SyntaxTokenList modifiers, string methodName);
    private static void RemoveMethodsAndPropertiesThatAreInDebuggerDisplayAttributeValue(string value, Collection`1& nodes);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxNode node);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxNode node, string declarationName);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeTypeDeclaration>g__ShouldAnalyzeDebuggerDisplayAttribute|4_1(<>c__DisplayClass4_0& );
}
internal class Roslynator.CSharp.Analysis.UnusedMember.UnusedMemberWalker : TypeSyntaxWalker {
    [ThreadStaticAttribute]
private static UnusedMemberWalker _cachedInstance;
    private bool _isEmpty;
    private IMethodSymbol _containingMethodSymbol;
    [CompilerGeneratedAttribute]
private Collection`1<NodeSymbolInfo> <Nodes>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnyNodeConst>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnyNodeDelegate>k__BackingField;
    public Collection`1<NodeSymbolInfo> Nodes { get; }
    public SemanticModel SemanticModel { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public bool IsAnyNodeConst { get; private set; }
    public bool IsAnyNodeDelegate { get; private set; }
    protected bool ShouldVisit { get; }
    [CompilerGeneratedAttribute]
public Collection`1<NodeSymbolInfo> get_Nodes();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public void set_SemanticModel(SemanticModel value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public bool get_IsAnyNodeConst();
    [CompilerGeneratedAttribute]
private void set_IsAnyNodeConst(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAnyNodeDelegate();
    [CompilerGeneratedAttribute]
private void set_IsAnyNodeDelegate(bool value);
    protected virtual bool get_ShouldVisit();
    public void Reset();
    public void AddDelegate(string name, SyntaxNode node);
    public void AddNode(string name, SyntaxNode node);
    public void AddNodes(VariableDeclarationSyntax declaration, bool isConst);
    private void RemoveNodeAt(int index);
    private void VisitSimpleName(SimpleNameSyntax node, string name);
    public virtual void VisitGenericName(GenericNameSyntax node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node);
    protected virtual void VisitType(TypeSyntax node);
    public virtual void VisitGotoStatement(GotoStatementSyntax node);
    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual void VisitNameColon(NameColonSyntax node);
    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual void VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual void VisitBaseList(BaseListSyntax node);
    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public virtual void VisitParameterList(ParameterListSyntax node);
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual void VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual void VisitRecordDeclaration(RecordDeclarationSyntax node);
    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual void VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node);
    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node);
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    private void VisitMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    private void VisitMemberDeclaration(MemberDeclarationSyntax node);
    private void VisitAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public static UnusedMemberWalker GetInstance();
    public static void Free(UnusedMemberWalker walker);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UnusedParameter.UnusedParameterAnalyzer : BaseDiagnosticAnalyzer {
    private static MetadataNameSet _attributes;
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UnusedParameterAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSimpleLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, ParameterInfo& parameterInfo, bool isIndexer);
    private static void FindUnusedNodes(ParameterInfo& parameterInfo, UnusedParameterWalker walker, IMethodSymbol methodSymbol);
    private static void AddParameter(UnusedParameterWalker walker, ParameterSyntax parameter, int index, IMethodSymbol methodSymbol);
    private static bool IsArgListOrDiscard(ParameterSyntax parameter);
    private static bool IsDiscardName(string value);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxNode node);
    private static bool ContainsOnlyThrowNewExpression(CSharpSyntaxNode node);
    private static bool ContainsOnlyThrowNewExpression(BlockSyntax body);
    private static bool ContainsOnlyThrowNewExpression(ArrowExpressionClauseSyntax expressionBody);
}
internal class Roslynator.CSharp.Analysis.UnusedParameter.UnusedParameterWalker : TypeSyntaxWalker {
    [ThreadStaticAttribute]
private static UnusedParameterWalker _cachedInstance;
    private static StringComparer _ordinalComparer;
    private bool _isEmpty;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, NodeSymbolInfo> <Nodes>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIndexer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnyTypeParameter>k__BackingField;
    public Dictionary`2<string, NodeSymbolInfo> Nodes { get; }
    public SemanticModel SemanticModel { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public bool IsIndexer { get; public set; }
    public bool IsAnyTypeParameter { get; public set; }
    protected bool ShouldVisit { get; }
    private static UnusedParameterWalker();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, NodeSymbolInfo> get_Nodes();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public void set_SemanticModel(SemanticModel value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public bool get_IsIndexer();
    [CompilerGeneratedAttribute]
public void set_IsIndexer(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAnyTypeParameter();
    [CompilerGeneratedAttribute]
public void set_IsAnyTypeParameter(bool value);
    protected virtual bool get_ShouldVisit();
    public void SetValues(SemanticModel semanticModel, CancellationToken cancellationToken, bool isIndexer);
    public void AddParameter(ParameterSyntax parameter);
    public void AddTypeParameter(TypeParameterSyntax typeParameter);
    private void AddNode(string name, SyntaxNode node);
    private void RemoveNode(string name);
    protected virtual void VisitType(TypeSyntax node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    private static ISymbol GetIndexerParameterSymbol(IdentifierNameSyntax identifierName, ISymbol symbol);
    public virtual void VisitAttributeList(AttributeListSyntax node);
    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual void VisitGotoStatement(GotoStatementSyntax node);
    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual void VisitNameColon(NameColonSyntax node);
    public virtual void VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node);
    public virtual void VisitParameterList(ParameterListSyntax node);
    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public static UnusedParameterWalker GetInstance();
    public static void Free(UnusedParameterWalker walker);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseAnonymousFunctionOrMethodGroupAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSimpleLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static bool ExpressionIsParameter(ExpressionSyntax expression, ParameterSyntax parameter);
    private static bool ExpressionIsParameter(ExpressionSyntax expression, ParameterListSyntax parameterList);
    private static bool CheckInvokeMethod(AnonymousFunctionExpressionSyntax anonymousFunction, IMethodSymbol methodSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CheckParameters(SeparatedSyntaxList`1<ParameterSyntax> parameters, SeparatedSyntaxList`1<ArgumentSyntax> arguments, ImmutableArray`1<IParameterSymbol> parameterSymbols);
    private static bool CheckParameter(ParameterSyntax parameter, ExpressionSyntax expression, IParameterSymbol parameterSymbol);
    private static bool CheckSpeculativeSymbol(AnonymousFunctionExpressionSyntax anonymousFunction, ExpressionSyntax expression, IMethodSymbol methodSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsSimpleInvocation(ExpressionSyntax expression);
    internal static InvocationExpressionSyntax GetInvocationExpression(SyntaxNode node);
    private static ExpressionSyntax GetExpression(SyntaxNode node);
    private static void AnalyzeArgument(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEqualsValueClause(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAssignment(SyntaxNodeAnalysisContext context);
    private static void AnalyzeReturnStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeYieldReturnStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeArrowExpressionClause(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSwitchExpressionArm(SyntaxNodeAnalysisContext context);
    private static void AnalyzeArrayInitializer(SyntaxNodeAnalysisContext context);
    private static bool ConvertToAnonymousFunction(SyntaxNodeAnalysisContext context);
    private static bool ConvertToMethodGroup(SyntaxNodeAnalysisContext context);
    private static void ReportAnonymousFunction(SyntaxNodeAnalysisContext context, AnonymousFunctionExpressionSyntax anonymousMethod);
    private static void ReportMethodGroup(SyntaxNodeAnalysisContext context, ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static bool <CheckSpeculativeSymbol>g__CheckSpeculativeSymbol|12_0(SymbolInfo symbolInfo, <>c__DisplayClass12_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseAsyncAwaitAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSimpleLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAnonymousMethodExpression(SyntaxNodeAnalysisContext context);
    private static bool IsFixable(BlockSyntax body, SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseAttributeUsageAttributeAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    public static void AnalyzerNamedTypeSymbol(SymbolAnalysisContext context, INamedTypeSymbol attributeSymbol, INamedTypeSymbol attributeUsageAttributeSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseAutoPropertyAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static bool IsFixableBackingField(PropertyDeclarationSyntax propertyDeclaration, IPropertySymbol propertySymbol, IFieldSymbol fieldSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IFieldSymbol GetBackingFieldSymbol(IdentifierNameSyntax identifierName, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IFieldSymbol GetBackingFieldSymbol(AccessorDeclarationSyntax getter, AccessorDeclarationSyntax setter, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IdentifierNameSyntax GetIdentifierNameFromGetter(AccessorDeclarationSyntax getter);
    private static IdentifierNameSyntax GetIdentifierNameFromSetter(AccessorDeclarationSyntax setter);
    private static IdentifierNameSyntax GetIdentifierNameFromExpression(ExpressionSyntax expression);
    private static bool HasStructLayoutAttributeWithExplicitKind(INamedTypeSymbol typeSymbol);
    private static bool CheckPreprocessorDirectives(PropertyDeclarationSyntax property);
    private static bool CheckPreprocessorDirectives(VariableDeclaratorSyntax declarator);
    [CompilerGeneratedAttribute]
internal static void <AnalyzePropertyDeclaration>g__FadeOut|4_0(AccessorDeclarationSyntax accessor, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static IdentifierNameSyntax <GetIdentifierNameFromSetter>g__GetIdentifierName|9_0(ExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseBlockBodyOrExpressionBodyAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDestructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAccessorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAccessorDeclarationBlock(SyntaxNodeAnalysisContext context, AccessorDeclarationSyntax accessor, BlockSyntax body);
    private static void AnalyzeBlock(SyntaxNodeAnalysisContext context, BlockSyntax block, BlockExpressionAnalysis analysis, BodyStyle style);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, AccessorListSyntax accessorList);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, BlockSyntax block);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, ArrowExpressionClauseSyntax expressionBody);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseCoalesceExpressionAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static bool CanUseCoalesceExpression(StatementSyntax statement, ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeIfStatement>g__IsPartOfLazyInitialization|4_1(<>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseCompoundAssignmentAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSimpleAssignment(SyntaxNodeAnalysisContext context);
    internal static string GetCompoundAssignmentOperatorText(BinaryExpressionSyntax binaryExpression);
    private static void AnalyzeCoalesceExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeSimpleAssignment>g__CanBeReplacedWithCompoundAssignment|4_0(ExpressionSyntax expression, <>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseConditionalAccessAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeBinaryExpression(SyntaxNodeAnalysisContext context);
    private static bool IsFixable(ExpressionSyntax left, ExpressionSyntax right, SyntaxKind binaryExpressionKind, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static ExpressionSyntax FindExpressionThatCanBeConditionallyAccessed(ExpressionSyntax expressionToFind, ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static ExpressionSyntax FindExpressionThatCanBeConditionallyAccessed(ExpressionSyntax expressionToFind, ExpressionSyntax expression, bool isNullable, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ValidateRightExpression(ExpressionSyntax expression, SyntaxKind binaryExpressionKind, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static ValueTuple`2<ExpressionSyntax, ExpressionSyntax> GetFixableExpressions(BinaryExpressionSyntax binaryExpression, SyntaxKind kind, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeBinaryExpression>g__ExistsImplicitConversionToBoolean|5_0(INamedTypeSymbol typeSymbol);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <GetFixableExpressions>g__GetLastChild|10_0(SyntaxNode node, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <GetFixableExpressions>g__GetPreviousSibling|10_1(SyntaxNode node, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetFixableExpressions>g__IsFirstChild|10_2(SyntaxNode node, <>c__DisplayClass10_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseConstantInsteadOfFieldAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeFieldDeclaration(SyntaxNodeAnalysisContext context);
}
internal static class Roslynator.CSharp.Analysis.UseCountOrLengthPropertyInsteadOfAnyMethodAnalysis : object {
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseEmptyStringLiteralOrStringEmptyAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSimpleMemberAccessExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeStringLiteralExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInterpolatedStringExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseEnumFieldExplicitlyAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCastExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseEventArgsEmptyAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeObjectCreationExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseExceptionFilterAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCatchClause(SyntaxNodeAnalysisContext context);
    private static bool IsThrowStatementWithoutExpression(StatementSyntax statement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseExclusiveOrOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeLogicalOrExpression(SyntaxNodeAnalysisContext context);
    private static ExpressionPair GetExpressionPair(BinaryExpressionSyntax logicalAnd);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseExplicitlyOrImplicitlyTypedArrayAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeImplicitArrayCreationExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCollectionExpression(SyntaxNodeAnalysisContext context);
}
[ObsoleteAttribute("Use analyzer 'UseVarOrExplicitTypeAnalyzer' instead.")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseExplicitTypeInsteadOfVarInForEachAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeForEachStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeForEachVariableStatement(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, TypeSyntax type);
}
[ObsoleteAttribute("Use analyzer 'UseVarOrExplicitTypeAnalyzer' instead.")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseExplicitTypeInsteadOfVarWhenTypeIsNotObviousAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDeclarationExpression(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, TypeSyntax type);
}
[ObsoleteAttribute("Use analyzer 'UseVarOrExplicitTypeAnalyzer' instead.")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseExplicitTypeInsteadOfVarWhenTypeIsObviousAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDeclarationExpression(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, TypeSyntax type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseForStatementInsteadOfWhileStatementAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeWhileStatement(SyntaxNodeAnalysisContext context);
    private static ExpressionSyntax GetIncrementedExpression(StatementSyntax statement);
    private static SingleLocalDeclarationStatementInfo GetLocalInfo(StatementSyntax statement);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeWhileStatement>g__ContainsContinueStatement|4_0(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeWhileStatement>g__IsLocalVariableReferencedAfterWhileStatement|4_1(<>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseGenericEventHandlerAnalyzer : BaseDiagnosticAnalyzer {
    private static MetadataName System_Windows_RoutedEventHandler;
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseGenericEventHandlerAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEvent(SymbolAnalysisContext context);
    private static TypeSyntax GetTypeSyntax(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseHasFlagMethodOrBitwiseOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBitwiseAndExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInvocationExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeBitwiseAndExpression>g__IsSuitableAsExpressionOfHasFlag|4_0(ExpressionSyntax expression, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeBitwiseAndExpression>g__IsSuitableAsArgumentOfHasFlag|4_1(ExpressionSyntax expression, <>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseImplicitOrExplicitObjectCreationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeImplicitObjectCreationExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCollectionExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseIsOperatorInsteadOfAsOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEqualsExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeNotEqualsExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIsPatternExpression(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseNameOfOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static void AnalyzeArgument(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, ArgumentSyntax argument, ExpressionSyntax expression, ParameterInfo& parameterInfo);
    private static ParameterSyntax FindMatchingParameter(ParameterInfo parameterInfo, string name);
    private static ParameterInfo GetNextParametersInScope(SyntaxNode node);
    private static void Analyze(SyntaxNodeAnalysisContext context, ArgumentSyntax argument, ExpressionSyntax expression);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, LiteralExpressionSyntax literalExpression, string identifier);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UsePatternMatching.UsePatternMatchingInsteadOfAsAndNullCheckAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAsExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UsePatternMatching.UsePatternMatchingInsteadOfIsAndCastAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIsExpression(SyntaxNodeAnalysisContext context);
    private static bool IsFixable(SyntaxNode node, IdentifierNameSyntax identifierName, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Roslynator.CSharp.Analysis.UsePatternMatching.UsePatternMatchingWalker : BaseCSharpSyntaxWalker {
    [ThreadStaticAttribute]
private static UsePatternMatchingWalker _cachedInstance;
    private ISymbol _symbol;
    private IdentifierNameSyntax _identifierName;
    private string _name;
    private SemanticModel _semanticModel;
    private CancellationToken _cancellationToken;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsFixable>k__BackingField;
    public Nullable`1<bool> IsFixable { get; private set; }
    protected bool ShouldVisit { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsFixable();
    [CompilerGeneratedAttribute]
private void set_IsFixable(Nullable`1<bool> value);
    protected virtual bool get_ShouldVisit();
    public void SetValues(IdentifierNameSyntax identifierName, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    public static UsePatternMatchingWalker GetInstance();
    public static void Free(UsePatternMatchingWalker walker);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UsePredefinedTypeAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIdentifierName(SyntaxNodeAnalysisContext context);
    private static void AnalyzeXmlCrefAttribute(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, CrefSyntax cref, NameMemberCrefSyntax nameMemberCref);
    private static void AnalyzeQualifiedName(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSimpleMemberAccessExpression(SyntaxNodeAnalysisContext context);
    private static bool IsArgumentExpressionOfNameOfExpression(SyntaxNodeAnalysisContext context, SyntaxNode node);
    private static bool SupportsPredefinedType(IdentifierNameSyntax identifierName);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseRawStringLiteralAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeStringLiteralExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInterpolatedStringExpression(SyntaxNodeAnalysisContext context);
}
internal static class Roslynator.CSharp.Analysis.UseRegexInstanceInsteadOfStaticMethodAnalysis : object {
    internal static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__ValidateArgument|0_0(ArgumentSyntax argument, <>c__DisplayClass0_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseShortCircuitingOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    public static void Analyze(SyntaxNodeAnalysisContext context);
}
internal static class Roslynator.CSharp.Analysis.UseStringComparisonAnalysis : object {
    public static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo, SimpleMemberInvocationExpressionInfo& invocationInfo2);
    private static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo, ArgumentSyntax argument);
    private static bool IsFixable(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo, ArgumentSyntax argument, SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    private static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo, ExpressionSyntax leftOrRight, BinaryExpressionSyntax binaryExpression);
    private static bool TryCreateCaseChangingInvocation(ExpressionSyntax expression, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static bool CheckSymbol(SimpleMemberInvocationExpressionInfo& invocationInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo& invocationInfo);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxNode node);
}
internal static class Roslynator.CSharp.Analysis.UseStringInterpolationInsteadOfStringConcatAnalysis : object {
    internal static void Analyze(SyntaxNodeAnalysisContext context, SimpleMemberInvocationExpressionInfo invocationInfo);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseStringIsNullOrEmptyMethodAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBinaryExpression(SyntaxNodeAnalysisContext context);
    private static bool IsFixable(ExpressionSyntax left, BinaryExpressionSyntax right, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool SymbolEquals(ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseStringLengthInsteadOfComparisonWithEmptyStringAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEqualsExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseUnaryOperatorInsteadOfAssignmentAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSimpleAssignmentExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAddAssignmentExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSubtractAssignmentExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAddOrSubtractAssignmentExpression(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, AssignmentExpressionSyntax assignment, string operatorText);
    public static bool UseIncrementOperator(AssignmentExpressionSyntax assignment);
    public static string GetOperatorText(AssignmentExpressionSyntax assignment);
}
[ObsoleteAttribute("Use analyzer 'UseVarOrExplicitTypeAnalyzer' instead.")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseVarInsteadOfExplicitTypeInForEachAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeForEachStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeForEachVariableStatement(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxNode node);
}
[ObsoleteAttribute("Use analyzer 'UseVarOrExplicitTypeAnalyzer' instead.")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseVarInsteadOfExplicitTypeWhenTypeIsNotObviousAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDeclarationExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTupleExpression(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxNode node);
}
[ObsoleteAttribute("Use analyzer 'UseVarOrExplicitTypeAnalyzer' instead.")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseVarInsteadOfExplicitTypeWhenTypeIsObviousAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTupleExpression(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.UseVarOrExplicitTypeAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDeclarationExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTupleExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeForEachStatement(SyntaxNodeAnalysisContext context);
    private static void ReportExplicitToImplicit(SyntaxNodeAnalysisContext context, SyntaxNode node);
    private static void ReportImplicitToExplicit(SyntaxNodeAnalysisContext context, SyntaxNode node);
    private static bool IsPartOfTupleExpression(DeclarationExpressionSyntax declarationExpression);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeDeclarationExpression>g__IsObviousTupleExpression|5_0(DeclarationExpressionSyntax declarationExpression);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeDeclarationExpression>g__IsObvious|5_1(DeclarationExpressionSyntax declarationExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ValidateArgumentsCorrectlyAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static bool IsConditionWithThrow(StatementSyntax statement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.ValueTypeObjectIsNeverEqualToNullAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEqualsExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeNotEqualsExpression(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, BinaryExpressionSyntax binaryExpression);
    private static bool IsStructButNotNullableOfT(ITypeSymbol typeSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.Analysis.WhitespaceAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTrailingTrivia(SyntaxTreeAnalysisContext context);
}
public static class Roslynator.CSharp.AnalyzerOptionDiagnosticIdentifiers : object {
    public static string UseImplicitlyTypedArrayWhenTypeIsObvious;
    public static string UseImplicitlyTypedArray;
    public static string ConvertExpressionBodyToBlockBodyWhenExpressionIsMultiLine;
    public static string ConvertExpressionBodyToBlockBodyWhenDeclarationIsMultiLine;
    public static string ConvertExpressionBodyToBlockBody;
    public static string RemoveAccessibilityModifiers;
    public static string RemoveEmptyLineBetweenClosingBraceAndSwitchSection;
    public static string RemoveParenthesesWhenCreatingNewObject;
    public static string RemoveParenthesesFromConditionOfConditionalExpressionWhenExpressionIsSingleToken;
    public static string UseStringEmptyInsteadOfEmptyStringLiteral;
    public static string RemoveCallToConfigureAwait;
    public static string ConvertBitwiseOperationToHasFlagCall;
    public static string ConvertMethodGroupToAnonymousFunction;
    public static string UseComparisonInsteadPatternMatchingToCheckForNull;
}
public static class Roslynator.CSharp.AnalyzerOptions : object {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.CSharp.Analysis.RemoveRedundantCatchBlockAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCatchClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.CSharp.Analysis.SimplifyNumericComparisonAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeComparison(SyntaxNodeAnalysisContext context);
}
internal static class Roslynator.CSharp.CSharpDiagnosticHelpers : object {
    public static void ReportBraces(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, BlockSyntax block, Object[] messageArgs);
    public static void ReportBraces(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, AccessorListSyntax accessorList, Object[] messageArgs);
    public static void ReportParentheses(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, ArgumentListSyntax argumentList, Object[] messageArgs);
}
public static class Roslynator.CSharp.DiagnosticIdentifiers : object {
    public static string AddBracesWhenExpressionSpansOverMultipleLines;
    public static string RemoveBraces;
    public static string AddBracesToIfElseWhenExpressionSpansOverMultipleLines;
    public static string RemoveBracesFromIfElse;
    public static string SimplifyNestedUsingStatement;
    public static string MergeElseWithNestedIf;
    public static string AddBraces;
    public static string UseExplicitTypeInsteadOfVarWhenTypeIsNotObvious;
    public static string UseExplicitTypeInsteadOfVarInForEach;
    public static string UseVarInsteadOfExplicitTypeWhenTypeIsObvious;
    public static string UseExplicitTypeInsteadOfVarWhenTypeIsObvious;
    public static string UsePredefinedType;
    public static string UseExplicitlyOrImplicitlyTypedArray;
    public static string UseNameOfOperator;
    public static string UseBlockBodyOrExpressionBody;
    public static string AddOrRemoveAccessibilityModifiers;
    public static string OrderModifiers;
    public static string SimplifyNullableOfT;
    public static string ConvertLambdaExpressionBodyToExpressionBody;
    public static string RemoveUnnecessaryBracesInSwitchSection;
    public static string RemoveRedundantParentheses;
    public static string RemoveRedundantBooleanLiteral;
    public static string RemoveRedundantSealedModifier;
    public static string RemoveRedundantCommaInInitializer;
    public static string RemoveUnnecessaryBlankLine;
    public static string RemoveTrailingWhitespace;
    public static string RemoveEmptyStatement;
    public static string RemoveArgumentListFromAttribute;
    public static string RemoveEmptyElseClause;
    public static string RemoveEmptyInitializer;
    public static string RemoveEnumDefaultUnderlyingType;
    public static string RemovePartialModifierFromTypeWithSinglePart;
    public static string RemoveOriginalExceptionFromThrowStatement;
    public static string AsynchronousMethodNameShouldEndWithAsync;
    public static string NonAsynchronousMethodNameShouldNotEndWithAsync;
    public static string UseLambdaExpressionInsteadOfAnonymousMethod;
    public static string SimplifyBooleanComparison;
    public static string IncludeParenthesesWhenCreatingNewObject;
    public static string AddOrRemoveParenthesesFromConditionInConditionalOperator;
    public static string DeclareEachAttributeSeparately;
    public static string UnnecessarySemicolonAtEndOfDeclaration;
    public static string AvoidUsageOfUsingAliasDirective;
    public static string UseCompoundAssignment;
    public static string AvoidLockingOnPubliclyAccessibleInstance;
    public static string DeclareEachTypeInSeparateFile;
    public static string MergeIfWithNestedIf;
    public static string AvoidUsageOfDoStatementToCreateInfiniteLoop;
    public static string AvoidUsageOfForStatementToCreateInfiniteLoop;
    public static string AvoidUsageOfWhileStatementToCreateInfiniteLoop;
    public static string RemoveEmptyFinallyClause;
    public static string SimplifyLogicalNegation;
    public static string RemoveUnnecessaryCaseLabel;
    public static string RemoveRedundantDefaultSwitchSection;
    public static string RemoveRedundantBaseConstructorCall;
    public static string RemoveEmptyNamespaceDeclaration;
    public static string ConvertIfToReturnStatement;
    public static string RemoveRedundantConstructor;
    public static string AvoidEmptyCatchClauseThatCatchesSystemException;
    public static string OptimizeLinqMethodCall;
    public static string UseEmptyStringLiteralOrStringEmpty;
    public static string ThrowingOfNewNotImplementedException;
    public static string UseCountOrLengthPropertyInsteadOfAnyMethod;
    public static string SplitVariableDeclaration;
    public static string UseCoalesceExpressionInsteadOfConditionalExpression;
    public static string UseAutoProperty;
    public static string UseUnaryOperatorInsteadOfAssignment;
    public static string ConfigureAwait;
    public static string RemoveEmptyRegion;
    public static string FileContainsNoCode;
    public static string DeclareUsingDirectiveOnTopLevel;
    public static string UseHasFlagMethodOrBitwiseOperator;
    public static string RemoveRedundantToStringCall;
    public static string ConstantValuesShouldBePlacedOnRightSideOfComparisons;
    public static string DefaultLabelShouldBeLastLabelInSwitchSection;
    public static string FormatDocumentationSummaryOnSingleLine;
    public static string FormatDocumentationSummaryOnMultipleLines;
    public static string MakeClassStatic;
    public static string ConvertIfToAssignment;
    public static string SimplifyConditionalExpression;
    public static string UnnecessaryInterpolation;
    public static string RemoveEmptyDestructor;
    public static string RemoveRedundantStringToCharArrayCall;
    public static string AddStaticModifierToAllPartialClassDeclarations;
    public static string DeclareTypeInsideNamespace;
    public static string AddBracesToSwitchSectionWithMultipleStatements;
    public static string CombineEnumerableWhereMethodChain;
    public static string UseStringIsNullOrEmptyMethod;
    public static string RemoveRedundantDelegateCreation;
    public static string MarkLocalVariableAsConst;
    public static string AddParenthesesWhenNecessary;
    public static string InlineLocalVariable;
    public static string AddBracesToIfElse;
    public static string UseCoalesceExpression;
    public static string RemoveRedundantFieldInitialization;
    public static string BitwiseOperationOnEnumWithoutFlagsAttribute;
    public static string RemoveRedundantOverridingMember;
    public static string RemoveRedundantDisposeOrCloseCall;
    public static string RemoveRedundantStatement;
    public static string DeclareEnumMemberWithZeroValue;
    public static string MergeSwitchSectionsWithEquivalentContent;
    public static string AddSummaryToDocumentationComment;
    public static string AddSummaryElementToDocumentationComment;
    public static string AddExceptionToDocumentationComment;
    public static string AddParamElementToDocumentationComment;
    public static string AddTypeParamElementToDocumentationComment;
    public static string SimplifyCoalesceExpression;
    public static string RemoveRedundantAsOperator;
    public static string UseConditionalAccess;
    public static string RemoveRedundantCast;
    public static string SortEnumMembers;
    public static string UseStringComparison;
    public static string UseStringLengthInsteadOfComparisonWithEmptyString;
    public static string CompositeEnumValueContainsUndefinedFlag;
    public static string StaticMemberInGenericTypeShouldUseTypeParameter;
    public static string UseGenericEventHandler;
    public static string AbstractTypeShouldNotHavePublicConstructors;
    public static string EnumShouldDeclareExplicitValues;
    public static string AvoidChainOfAssignments;
    public static string UnusedParameter;
    public static string UnusedTypeParameter;
    public static string UnconstrainedTypeParameterCheckedForNull;
    public static string ValueTypeObjectIsNeverEqualToNull;
    public static string ParameterNameDiffersFromBase;
    public static string MakeFieldReadOnly;
    public static string UseReadOnlyAutoProperty;
    public static string SimplifyLazyInitialization;
    public static string UseIsOperatorInsteadOfAsOperator;
    public static string UseCoalesceExpressionInsteadOfIf;
    public static string RemoveRedundantAsyncAwait;
    public static string UnusedThisParameter;
    public static string UseVarInsteadOfExplicitTypeWhenTypeIsNotObvious;
    public static string UseVarInsteadOfExplicitTypeInForEach;
    public static string UnnecessaryAssignment;
    public static string InlineLazyInitialization;
    public static string ConvertCommentToDocumentationComment;
    public static string RemoveRedundantBaseInterface;
    public static string UseRegexInstanceInsteadOfStaticMethod;
    public static string UseConstantInsteadOfField;
    public static string RemoveRedundantAutoPropertyInitialization;
    public static string AddOrRemoveRegionName;
    public static string JoinStringExpressions;
    public static string DeclareEnumValueAsCombinationOfNames;
    public static string UnnecessaryUsageOfVerbatimStringLiteral;
    public static string OverridingMemberShouldNotChangeParamsModifier;
    public static string ImplementExceptionConstructors;
    public static string UseExclusiveOrOperator;
    public static string CallExtensionMethodAsInstanceMethod;
    public static string OptimizeStringBuilderAppendCall;
    public static string AvoidBoxingOfValueType;
    public static string UnnecessaryNullCheck;
    public static string CallThenByInsteadOfOrderBy;
    public static string UseMethodChaining;
    public static string AvoidNullReferenceException;
    public static string UseAttributeUsageAttribute;
    public static string UseEventArgsEmpty;
    public static string OrderNamedArguments;
    public static string UseConditionalAccessInsteadOfConditionalExpression;
    public static string UseAnonymousFunctionOrMethodGroup;
    public static string ReduceIfNesting;
    public static string OrderTypeParameterConstraints;
    public static string ReturnCompletedTaskInsteadOfNull;
    public static string RemoveUnnecessaryElse;
    public static string RemoveRedundantAssignment;
    public static string RemoveUnusedMemberDeclaration;
    public static string UnnecessaryInterpolatedString;
    public static string ExpressionIsAlwaysEqualToTrueOrFalse;
    public static string UnnecessaryUnsafeContext;
    public static string ConvertInterpolatedStringToConcatenation;
    public static string SimplifyCodeBranching;
    public static string UsePatternMatchingInsteadOfIsAndCast;
    public static string UsePatternMatchingInsteadOfAsAndNullCheck;
    public static string MergePreprocessorDirectives;
    public static string MarkTypeWithDebuggerDisplayAttribute;
    public static string MakeMethodExtensionMethod;
    public static string MakeClassSealed;
    public static string AddParagraphToDocumentationComment;
    public static string ValidateArgumentsCorrectly;
    public static string UnusedElementInDocumentationComment;
    public static string UseAsyncAwait;
    public static string UnnecessaryExplicitUseOfEnumerator;
    public static string MakeParameterRefReadOnly;
    public static string OrderElementsInDocumentationComment;
    public static string UseShortCircuitingOperator;
    public static string DuplicateEnumValue;
    public static string OptimizeMethodCall;
    public static string UseExceptionFilter;
    public static string UseBitShiftOperator;
    public static string AvoidNestedConditionalOperators;
    public static string UseForStatementInsteadOfWhileStatement;
    public static string UnnecessaryOperator;
    public static string ImplementNonGenericCounterpart;
    public static string DoNotPassNonReadOnlyStructByReadOnlyReference;
    public static string DuplicateWordInComment;
    public static string SimplifyDefaultExpression;
    public static string UseElementAccess;
    public static string FixDocumentationCommentTag;
    public static string NormalizeNullCheck;
    public static string UnnecessaryNullForgivingOperator;
    public static string UseImplicitOrExplicitObjectCreation;
    public static string RemoveUnnecessaryBraces;
    public static string NormalizeUsageOfInfiniteLoop;
    public static string FormatDocumentationCommentSummary;
    public static string NormalizeFormatOfEnumFlagValue;
    public static string SimplifyArgumentNullCheck;
    public static string InvalidArgumentNullCheck;
    public static string UseEnumFieldExplicitly;
    public static string UnnecessaryEnumFlag;
    public static string RemoveEmptySyntax;
    public static string AddOrRemoveTrailingComma;
    public static string DisposeResourceAsynchronously;
    public static string UnnecessaryRawStringLiteral;
    public static string InvalidReferenceInDocumentationComment;
    public static string UseVarOrExplicitType;
    public static string RemoveRedundantCatchBlock;
    public static string UseRawStringLiteral;
    public static string UseStringInterpolationInsteadOfStringConcat;
    public static string SimplifyNumericComparison;
}
public static class Roslynator.CSharp.DiagnosticRules : object {
    public static DiagnosticDescriptor AddBracesWhenExpressionSpansOverMultipleLines;
    public static DiagnosticDescriptor RemoveBraces;
    public static DiagnosticDescriptor RemoveBracesFadeOut;
    public static DiagnosticDescriptor AddBracesToIfElseWhenExpressionSpansOverMultipleLines;
    public static DiagnosticDescriptor RemoveBracesFromIfElse;
    public static DiagnosticDescriptor RemoveBracesFromIfElseFadeOut;
    public static DiagnosticDescriptor SimplifyNestedUsingStatement;
    public static DiagnosticDescriptor SimplifyNestedUsingStatementFadeOut;
    public static DiagnosticDescriptor MergeElseWithNestedIf;
    public static DiagnosticDescriptor MergeElseWithNestedIfFadeOut;
    public static DiagnosticDescriptor AddBraces;
    public static DiagnosticDescriptor UseExplicitTypeInsteadOfVarWhenTypeIsNotObvious;
    public static DiagnosticDescriptor UseExplicitTypeInsteadOfVarInForEach;
    public static DiagnosticDescriptor UseVarInsteadOfExplicitTypeWhenTypeIsObvious;
    public static DiagnosticDescriptor UseExplicitTypeInsteadOfVarWhenTypeIsObvious;
    public static DiagnosticDescriptor UsePredefinedType;
    public static DiagnosticDescriptor UseExplicitlyOrImplicitlyTypedArray;
    public static DiagnosticDescriptor UseNameOfOperator;
    public static DiagnosticDescriptor UseNameOfOperatorFadeOut;
    public static DiagnosticDescriptor UseBlockBodyOrExpressionBody;
    public static DiagnosticDescriptor AddOrRemoveAccessibilityModifiers;
    public static DiagnosticDescriptor OrderModifiers;
    public static DiagnosticDescriptor SimplifyNullableOfT;
    public static DiagnosticDescriptor ConvertLambdaExpressionBodyToExpressionBody;
    public static DiagnosticDescriptor ConvertLambdaExpressionBodyToExpressionBodyFadeOut;
    public static DiagnosticDescriptor RemoveUnnecessaryBracesInSwitchSection;
    public static DiagnosticDescriptor RemoveUnnecessaryBracesInSwitchSectionFadeOut;
    public static DiagnosticDescriptor RemoveRedundantParentheses;
    public static DiagnosticDescriptor RemoveRedundantParenthesesFadeOut;
    public static DiagnosticDescriptor RemoveRedundantBooleanLiteral;
    public static DiagnosticDescriptor RemoveRedundantSealedModifier;
    public static DiagnosticDescriptor RemoveRedundantCommaInInitializer;
    public static DiagnosticDescriptor RemoveUnnecessaryBlankLine;
    public static DiagnosticDescriptor RemoveTrailingWhitespace;
    public static DiagnosticDescriptor RemoveEmptyStatement;
    public static DiagnosticDescriptor RemoveArgumentListFromAttribute;
    public static DiagnosticDescriptor RemoveEmptyElseClause;
    public static DiagnosticDescriptor RemoveEmptyInitializer;
    public static DiagnosticDescriptor RemoveEnumDefaultUnderlyingType;
    public static DiagnosticDescriptor RemovePartialModifierFromTypeWithSinglePart;
    public static DiagnosticDescriptor RemoveOriginalExceptionFromThrowStatement;
    public static DiagnosticDescriptor AsynchronousMethodNameShouldEndWithAsync;
    public static DiagnosticDescriptor NonAsynchronousMethodNameShouldNotEndWithAsync;
    public static DiagnosticDescriptor NonAsynchronousMethodNameShouldNotEndWithAsyncFadeOut;
    public static DiagnosticDescriptor UseLambdaExpressionInsteadOfAnonymousMethod;
    public static DiagnosticDescriptor UseLambdaExpressionInsteadOfAnonymousMethodFadeOut;
    public static DiagnosticDescriptor SimplifyBooleanComparison;
    public static DiagnosticDescriptor SimplifyBooleanComparisonFadeOut;
    public static DiagnosticDescriptor IncludeParenthesesWhenCreatingNewObject;
    public static DiagnosticDescriptor AddOrRemoveParenthesesFromConditionInConditionalOperator;
    public static DiagnosticDescriptor DeclareEachAttributeSeparately;
    public static DiagnosticDescriptor UnnecessarySemicolonAtEndOfDeclaration;
    public static DiagnosticDescriptor AvoidUsageOfUsingAliasDirective;
    public static DiagnosticDescriptor UseCompoundAssignment;
    public static DiagnosticDescriptor UseCompoundAssignmentFadeOut;
    public static DiagnosticDescriptor AvoidLockingOnPubliclyAccessibleInstance;
    public static DiagnosticDescriptor DeclareEachTypeInSeparateFile;
    public static DiagnosticDescriptor MergeIfWithNestedIf;
    public static DiagnosticDescriptor MergeIfWithNestedIfFadeOut;
    public static DiagnosticDescriptor AvoidUsageOfDoStatementToCreateInfiniteLoop;
    public static DiagnosticDescriptor AvoidUsageOfForStatementToCreateInfiniteLoop;
    public static DiagnosticDescriptor AvoidUsageOfWhileStatementToCreateInfiniteLoop;
    public static DiagnosticDescriptor RemoveEmptyFinallyClause;
    public static DiagnosticDescriptor RemoveEmptyFinallyClauseFadeOut;
    public static DiagnosticDescriptor SimplifyLogicalNegation;
    public static DiagnosticDescriptor RemoveUnnecessaryCaseLabel;
    public static DiagnosticDescriptor RemoveRedundantDefaultSwitchSection;
    public static DiagnosticDescriptor RemoveRedundantBaseConstructorCall;
    public static DiagnosticDescriptor RemoveEmptyNamespaceDeclaration;
    public static DiagnosticDescriptor ConvertIfToReturnStatement;
    public static DiagnosticDescriptor ConvertIfToReturnStatementFadeOut;
    public static DiagnosticDescriptor RemoveRedundantConstructor;
    public static DiagnosticDescriptor AvoidEmptyCatchClauseThatCatchesSystemException;
    public static DiagnosticDescriptor OptimizeLinqMethodCall;
    public static DiagnosticDescriptor UseEmptyStringLiteralOrStringEmpty;
    public static DiagnosticDescriptor ThrowingOfNewNotImplementedException;
    public static DiagnosticDescriptor UseCountOrLengthPropertyInsteadOfAnyMethod;
    public static DiagnosticDescriptor SplitVariableDeclaration;
    public static DiagnosticDescriptor UseCoalesceExpressionInsteadOfConditionalExpression;
    public static DiagnosticDescriptor UseAutoProperty;
    public static DiagnosticDescriptor UseAutoPropertyFadeOut;
    public static DiagnosticDescriptor UseUnaryOperatorInsteadOfAssignment;
    public static DiagnosticDescriptor UseUnaryOperatorInsteadOfAssignmentFadeOut;
    public static DiagnosticDescriptor ConfigureAwait;
    public static DiagnosticDescriptor RemoveEmptyRegion;
    public static DiagnosticDescriptor RemoveEmptyRegionFadeOut;
    public static DiagnosticDescriptor FileContainsNoCode;
    public static DiagnosticDescriptor DeclareUsingDirectiveOnTopLevel;
    public static DiagnosticDescriptor UseHasFlagMethodOrBitwiseOperator;
    public static DiagnosticDescriptor RemoveRedundantToStringCall;
    public static DiagnosticDescriptor ConstantValuesShouldBePlacedOnRightSideOfComparisons;
    public static DiagnosticDescriptor DefaultLabelShouldBeLastLabelInSwitchSection;
    public static DiagnosticDescriptor FormatDocumentationSummaryOnSingleLine;
    public static DiagnosticDescriptor FormatDocumentationSummaryOnMultipleLines;
    public static DiagnosticDescriptor MakeClassStatic;
    public static DiagnosticDescriptor ConvertIfToAssignment;
    public static DiagnosticDescriptor SimplifyConditionalExpression;
    public static DiagnosticDescriptor UnnecessaryInterpolation;
    public static DiagnosticDescriptor RemoveEmptyDestructor;
    public static DiagnosticDescriptor RemoveRedundantStringToCharArrayCall;
    public static DiagnosticDescriptor AddStaticModifierToAllPartialClassDeclarations;
    public static DiagnosticDescriptor DeclareTypeInsideNamespace;
    public static DiagnosticDescriptor AddBracesToSwitchSectionWithMultipleStatements;
    public static DiagnosticDescriptor CombineEnumerableWhereMethodChain;
    public static DiagnosticDescriptor CombineEnumerableWhereMethodChainFadeOut;
    public static DiagnosticDescriptor UseStringIsNullOrEmptyMethod;
    public static DiagnosticDescriptor RemoveRedundantDelegateCreation;
    public static DiagnosticDescriptor RemoveRedundantDelegateCreationFadeOut;
    public static DiagnosticDescriptor MarkLocalVariableAsConst;
    public static DiagnosticDescriptor AddParenthesesWhenNecessary;
    public static DiagnosticDescriptor InlineLocalVariable;
    public static DiagnosticDescriptor InlineLocalVariableFadeOut;
    public static DiagnosticDescriptor AddBracesToIfElse;
    public static DiagnosticDescriptor UseCoalesceExpression;
    public static DiagnosticDescriptor RemoveRedundantFieldInitialization;
    public static DiagnosticDescriptor BitwiseOperationOnEnumWithoutFlagsAttribute;
    public static DiagnosticDescriptor RemoveRedundantOverridingMember;
    public static DiagnosticDescriptor RemoveRedundantDisposeOrCloseCall;
    public static DiagnosticDescriptor RemoveRedundantStatement;
    public static DiagnosticDescriptor DeclareEnumMemberWithZeroValue;
    public static DiagnosticDescriptor MergeSwitchSectionsWithEquivalentContent;
    public static DiagnosticDescriptor AddSummaryToDocumentationComment;
    public static DiagnosticDescriptor AddSummaryElementToDocumentationComment;
    public static DiagnosticDescriptor AddExceptionToDocumentationComment;
    public static DiagnosticDescriptor AddParamElementToDocumentationComment;
    public static DiagnosticDescriptor AddTypeParamElementToDocumentationComment;
    public static DiagnosticDescriptor SimplifyCoalesceExpression;
    public static DiagnosticDescriptor RemoveRedundantAsOperator;
    public static DiagnosticDescriptor UseConditionalAccess;
    public static DiagnosticDescriptor RemoveRedundantCast;
    public static DiagnosticDescriptor SortEnumMembers;
    public static DiagnosticDescriptor UseStringComparison;
    public static DiagnosticDescriptor UseStringLengthInsteadOfComparisonWithEmptyString;
    public static DiagnosticDescriptor CompositeEnumValueContainsUndefinedFlag;
    public static DiagnosticDescriptor StaticMemberInGenericTypeShouldUseTypeParameter;
    public static DiagnosticDescriptor UseGenericEventHandler;
    public static DiagnosticDescriptor AbstractTypeShouldNotHavePublicConstructors;
    public static DiagnosticDescriptor EnumShouldDeclareExplicitValues;
    public static DiagnosticDescriptor AvoidChainOfAssignments;
    public static DiagnosticDescriptor UnusedParameter;
    public static DiagnosticDescriptor UnusedTypeParameter;
    public static DiagnosticDescriptor UnconstrainedTypeParameterCheckedForNull;
    public static DiagnosticDescriptor ValueTypeObjectIsNeverEqualToNull;
    public static DiagnosticDescriptor ParameterNameDiffersFromBase;
    public static DiagnosticDescriptor MakeFieldReadOnly;
    public static DiagnosticDescriptor UseReadOnlyAutoProperty;
    public static DiagnosticDescriptor SimplifyLazyInitialization;
    public static DiagnosticDescriptor UseIsOperatorInsteadOfAsOperator;
    public static DiagnosticDescriptor UseCoalesceExpressionInsteadOfIf;
    public static DiagnosticDescriptor RemoveRedundantAsyncAwait;
    public static DiagnosticDescriptor RemoveRedundantAsyncAwaitFadeOut;
    public static DiagnosticDescriptor UnusedThisParameter;
    public static DiagnosticDescriptor UseVarInsteadOfExplicitTypeWhenTypeIsNotObvious;
    public static DiagnosticDescriptor UseVarInsteadOfExplicitTypeInForEach;
    public static DiagnosticDescriptor UnnecessaryAssignment;
    public static DiagnosticDescriptor InlineLazyInitialization;
    public static DiagnosticDescriptor ConvertCommentToDocumentationComment;
    public static DiagnosticDescriptor RemoveRedundantBaseInterface;
    public static DiagnosticDescriptor UseRegexInstanceInsteadOfStaticMethod;
    public static DiagnosticDescriptor UseConstantInsteadOfField;
    public static DiagnosticDescriptor RemoveRedundantAutoPropertyInitialization;
    public static DiagnosticDescriptor AddOrRemoveRegionName;
    public static DiagnosticDescriptor JoinStringExpressions;
    public static DiagnosticDescriptor DeclareEnumValueAsCombinationOfNames;
    public static DiagnosticDescriptor UnnecessaryUsageOfVerbatimStringLiteral;
    public static DiagnosticDescriptor OverridingMemberShouldNotChangeParamsModifier;
    public static DiagnosticDescriptor ImplementExceptionConstructors;
    public static DiagnosticDescriptor UseExclusiveOrOperator;
    public static DiagnosticDescriptor CallExtensionMethodAsInstanceMethod;
    public static DiagnosticDescriptor OptimizeStringBuilderAppendCall;
    public static DiagnosticDescriptor AvoidBoxingOfValueType;
    public static DiagnosticDescriptor UnnecessaryNullCheck;
    public static DiagnosticDescriptor CallThenByInsteadOfOrderBy;
    public static DiagnosticDescriptor UseMethodChaining;
    public static DiagnosticDescriptor AvoidNullReferenceException;
    public static DiagnosticDescriptor UseAttributeUsageAttribute;
    public static DiagnosticDescriptor UseEventArgsEmpty;
    public static DiagnosticDescriptor OrderNamedArguments;
    public static DiagnosticDescriptor UseConditionalAccessInsteadOfConditionalExpression;
    public static DiagnosticDescriptor UseAnonymousFunctionOrMethodGroup;
    public static DiagnosticDescriptor ReduceIfNesting;
    public static DiagnosticDescriptor OrderTypeParameterConstraints;
    public static DiagnosticDescriptor ReturnCompletedTaskInsteadOfNull;
    public static DiagnosticDescriptor RemoveUnnecessaryElse;
    public static DiagnosticDescriptor RemoveRedundantAssignment;
    public static DiagnosticDescriptor RemoveRedundantAssignmentFadeOut;
    public static DiagnosticDescriptor RemoveUnusedMemberDeclaration;
    public static DiagnosticDescriptor UnnecessaryInterpolatedString;
    public static DiagnosticDescriptor UnnecessaryInterpolatedStringFadeOut;
    public static DiagnosticDescriptor ExpressionIsAlwaysEqualToTrueOrFalse;
    public static DiagnosticDescriptor UnnecessaryUnsafeContext;
    public static DiagnosticDescriptor ConvertInterpolatedStringToConcatenation;
    public static DiagnosticDescriptor ConvertInterpolatedStringToConcatenationFadeOut;
    public static DiagnosticDescriptor SimplifyCodeBranching;
    public static DiagnosticDescriptor UsePatternMatchingInsteadOfIsAndCast;
    public static DiagnosticDescriptor UsePatternMatchingInsteadOfAsAndNullCheck;
    public static DiagnosticDescriptor MergePreprocessorDirectives;
    public static DiagnosticDescriptor MarkTypeWithDebuggerDisplayAttribute;
    public static DiagnosticDescriptor MakeMethodExtensionMethod;
    public static DiagnosticDescriptor MakeClassSealed;
    public static DiagnosticDescriptor AddParagraphToDocumentationComment;
    public static DiagnosticDescriptor ValidateArgumentsCorrectly;
    public static DiagnosticDescriptor UnusedElementInDocumentationComment;
    public static DiagnosticDescriptor UseAsyncAwait;
    public static DiagnosticDescriptor UnnecessaryExplicitUseOfEnumerator;
    public static DiagnosticDescriptor MakeParameterRefReadOnly;
    public static DiagnosticDescriptor OrderElementsInDocumentationComment;
    public static DiagnosticDescriptor UseShortCircuitingOperator;
    public static DiagnosticDescriptor DuplicateEnumValue;
    public static DiagnosticDescriptor OptimizeMethodCall;
    public static DiagnosticDescriptor UseExceptionFilter;
    public static DiagnosticDescriptor UseBitShiftOperator;
    public static DiagnosticDescriptor AvoidNestedConditionalOperators;
    public static DiagnosticDescriptor UseForStatementInsteadOfWhileStatement;
    public static DiagnosticDescriptor UnnecessaryOperator;
    public static DiagnosticDescriptor ImplementNonGenericCounterpart;
    public static DiagnosticDescriptor DoNotPassNonReadOnlyStructByReadOnlyReference;
    public static DiagnosticDescriptor DuplicateWordInComment;
    public static DiagnosticDescriptor SimplifyDefaultExpression;
    public static DiagnosticDescriptor UseElementAccess;
    public static DiagnosticDescriptor FixDocumentationCommentTag;
    public static DiagnosticDescriptor NormalizeNullCheck;
    public static DiagnosticDescriptor UnnecessaryNullForgivingOperator;
    public static DiagnosticDescriptor UseImplicitOrExplicitObjectCreation;
    public static DiagnosticDescriptor RemoveUnnecessaryBraces;
    public static DiagnosticDescriptor NormalizeUsageOfInfiniteLoop;
    public static DiagnosticDescriptor FormatDocumentationCommentSummary;
    public static DiagnosticDescriptor NormalizeFormatOfEnumFlagValue;
    public static DiagnosticDescriptor SimplifyArgumentNullCheck;
    public static DiagnosticDescriptor InvalidArgumentNullCheck;
    public static DiagnosticDescriptor UseEnumFieldExplicitly;
    public static DiagnosticDescriptor UnnecessaryEnumFlag;
    public static DiagnosticDescriptor RemoveEmptySyntax;
    public static DiagnosticDescriptor AddOrRemoveTrailingComma;
    public static DiagnosticDescriptor DisposeResourceAsynchronously;
    public static DiagnosticDescriptor UnnecessaryRawStringLiteral;
    public static DiagnosticDescriptor InvalidReferenceInDocumentationComment;
    public static DiagnosticDescriptor UseVarOrExplicitType;
    public static DiagnosticDescriptor RemoveRedundantCatchBlock;
    public static DiagnosticDescriptor UseRawStringLiteral;
    public static DiagnosticDescriptor UseStringInterpolationInsteadOfStringConcat;
    public static DiagnosticDescriptor SimplifyNumericComparison;
    private static DiagnosticRules();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.CSharp.NodeSymbolInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    public string Name { get; }
    public SyntaxNode Node { get; }
    public ISymbol Symbol { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal bool CanBeInDebuggerDisplayAttribute { get; }
    public NodeSymbolInfo(string name, SyntaxNode node, ISymbol symbol);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public SyntaxNode get_Node();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    private string get_DebuggerDisplay();
    internal bool get_CanBeInDebuggerDisplayAttribute();
}
[IsReadOnlyAttribute]
internal class Roslynator.CSharp.RawStringLiteralInfo : ValueType {
    [CompilerGeneratedAttribute]
private LiteralExpressionSyntax <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QuoteCount>k__BackingField;
    public LiteralExpressionSyntax Expression { get; }
    public string Text { get; }
    public int QuoteCount { get; }
    public bool IsDefault { get; }
    public RawStringLiteralInfo(LiteralExpressionSyntax expression, int quoteCount);
    [CompilerGeneratedAttribute]
public LiteralExpressionSyntax get_Expression();
    public string get_Text();
    [CompilerGeneratedAttribute]
public int get_QuoteCount();
    public bool get_IsDefault();
    public static bool TryCreate(LiteralExpressionSyntax literalExpression, RawStringLiteralInfo& info);
    public static RawStringLiteralInfo Create(LiteralExpressionSyntax literalExpression);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
