[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public abstract class Roslynator.AbstractAnalyzerOptionIsObsoleteAnalyzer : DiagnosticAnalyzer {
    protected static bool TryReportObsoleteOption(SyntaxTreeAnalysisContext context, AnalyzerConfigOptions configOptions, LegacyConfigOptionDescriptor legacyOption, ConfigOptionDescriptor newOption, string newValue);
}
internal abstract class Roslynator.AbstractRequiredConfigOptionNotSetAnalyzer : DiagnosticAnalyzer {
    protected static bool TryReportRequiredOptionNotSet(SyntaxTreeAnalysisContext context, AnalyzerConfigOptions configOptions, DiagnosticDescriptor descriptor, ConfigOptionDescriptor option);
    protected static bool TryReportRequiredOptionNotSet(SyntaxTreeAnalysisContext context, AnalyzerConfigOptions configOptions, DiagnosticDescriptor descriptor, ConfigOptionDescriptor[] options);
    private static bool IsOptionSet(AnalyzerConfigOptions configOptions, ConfigOptionDescriptor option);
    private static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor);
}
internal static class Roslynator.CommonDiagnosticRules : object {
    public static DiagnosticDescriptor AnalyzerIsObsolete;
    public static DiagnosticDescriptor AnalyzerOptionIsObsolete;
    public static DiagnosticDescriptor RequiredConfigOptionNotSet;
    private static CommonDiagnosticRules();
}
[ExtensionAttribute]
internal static class Roslynator.CommonExtensions : object {
    [ExtensionAttribute]
public static bool IsEnabled(SyntaxNodeAnalysisContext context, ConfigOptionDescriptor option, Nullable`1<bool> defaultValue);
    [ExtensionAttribute]
public static bool IsEnabled(AnalyzerOptions analyzerOptions, ConfigOptionDescriptor option, SyntaxTree syntaxTree, Nullable`1<bool> defaultValue);
    [ExtensionAttribute]
public static bool TryGetOptionAsBool(SyntaxNodeAnalysisContext context, ConfigOptionDescriptor option, Boolean& result);
    [ExtensionAttribute]
public static bool TryGetOptionAsBool(AnalyzerOptions analyzerOptions, ConfigOptionDescriptor option, SyntaxTree syntaxTree, Boolean& result);
    [ExtensionAttribute]
public static bool TryGetOptionAsInt(AnalyzerOptions analyzerOptions, ConfigOptionDescriptor option, SyntaxTree syntaxTree, Int32& result);
    [ExtensionAttribute]
public static int GetOptionAsInt(AnalyzerOptions analyzerOptions, ConfigOptionDescriptor option, SyntaxTree syntaxTree, int defaultValue);
    [ExtensionAttribute]
internal static bool IsEnabled(AnalyzerConfigOptions analyzerConfigOptions, ConfigOptionDescriptor option);
    [ExtensionAttribute]
internal static bool ContainsKey(AnalyzerConfigOptions analyzerConfigOptions, ConfigOptionDescriptor option);
    [ExtensionAttribute]
internal static bool ContainsKey(AnalyzerConfigOptions analyzerConfigOptions, string key);
    [ExtensionAttribute]
internal static bool TryGetValueAsBool(AnalyzerConfigOptions analyzerConfigOptions, ConfigOptionDescriptor option, Boolean& value);
    [ExtensionAttribute]
internal static bool TryGetValueAsBool(AnalyzerConfigOptions analyzerConfigOptions, string key, Boolean& value);
    [ExtensionAttribute]
internal static AnalyzerConfigOptions GetConfigOptions(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
internal static AnalyzerConfigOptions GetConfigOptions(SyntaxTreeAnalysisContext context);
}
internal static class Roslynator.ConfigOptionDefaultValues : object {
    public static int MaxLineLength;
    public static bool PrefixFieldIdentifierWithUnderscore;
}
public class Roslynator.ConfigOptionDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DefaultValueAsBool>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValuePlaceholder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Key { get; }
    public string DefaultValue { get; }
    internal Nullable`1<bool> DefaultValueAsBool { get; }
    public string DefaultValuePlaceholder { get; }
    public string Description { get; }
    public ConfigOptionDescriptor(string key, string defaultValue, string defaultValuePlaceholder, string description);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_DefaultValue();
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_DefaultValueAsBool();
    [CompilerGeneratedAttribute]
public string get_DefaultValuePlaceholder();
    [CompilerGeneratedAttribute]
public string get_Description();
}
internal static class Roslynator.ConfigOptionKeys : object {
    public static string Prefix;
    public static string AnalyzersEnabledByDefault;
    public static string CompilerDiagnosticFixesEnabled;
    public static string CompilerDiagnosticFixPrefix;
    public static string RefactoringsEnabled;
    public static string RefactoringPrefix;
    public static string AccessibilityModifiers;
    public static string AccessorBracesStyle;
    public static string ArrayCreationTypeStyle;
    public static string ArrowTokenNewLine;
    public static string BinaryOperatorNewLine;
    public static string BlankLineAfterFileScopedNamespaceDeclaration;
    public static string BlankLineBetweenClosingBraceAndSwitchSection;
    public static string BlankLineBetweenSingleLineAccessors;
    public static string BlankLineBetweenSwitchSections;
    public static string BlankLineBetweenUsingDirectives;
    public static string BlockBracesStyle;
    public static string BodyStyle;
    public static string ConditionalOperatorConditionParenthesesStyle;
    public static string ConditionalOperatorNewLine;
    public static string ConfigureAwait;
    public static string DocCommentSummaryStyle;
    public static string EmptyStringStyle;
    public static string EnumFlagValueStyle;
    public static string EnumHasFlagStyle;
    public static string EqualsTokenNewLine;
    public static string InfiniteLoopStyle;
    public static string MaxLineLength;
    public static string NewLineAtEndOfFile;
    public static string NewLineBeforeWhileInDoStatement;
    public static string NullCheckStyle;
    public static string NullConditionalOperatorNewLine;
    public static string ObjectCreationParenthesesStyle;
    public static string ObjectCreationTypeStyle;
    public static string PrefixFieldIdentifierWithUnderscore;
    public static string SuppressUnityScriptMethods;
    public static string TabLength;
    public static string TrailingCommaStyle;
    public static string UnityCodeAnalysisEnabled;
    public static string UseAnonymousFunctionOrMethodGroup;
    public static string UseBlockBodyWhenDeclarationSpansOverMultipleLines;
    public static string UseBlockBodyWhenExpressionSpansOverMultipleLines;
    public static string UseCollectionExpression;
    public static string UseVar;
    public static string UseVarInsteadOfImplicitObjectCreation;
}
public static class Roslynator.ConfigOptions : object {
    private static ImmutableDictionary`2<string, string> _requiredOptions;
    public static ConfigOptionDescriptor AccessibilityModifiers;
    public static ConfigOptionDescriptor AccessorBracesStyle;
    public static ConfigOptionDescriptor ArrayCreationTypeStyle;
    public static ConfigOptionDescriptor ArrowTokenNewLine;
    public static ConfigOptionDescriptor BinaryOperatorNewLine;
    public static ConfigOptionDescriptor BlankLineAfterFileScopedNamespaceDeclaration;
    public static ConfigOptionDescriptor BlankLineBetweenClosingBraceAndSwitchSection;
    public static ConfigOptionDescriptor BlankLineBetweenSingleLineAccessors;
    public static ConfigOptionDescriptor BlankLineBetweenSwitchSections;
    public static ConfigOptionDescriptor BlankLineBetweenUsingDirectives;
    public static ConfigOptionDescriptor BlockBracesStyle;
    public static ConfigOptionDescriptor BodyStyle;
    public static ConfigOptionDescriptor ConditionalOperatorConditionParenthesesStyle;
    public static ConfigOptionDescriptor ConditionalOperatorNewLine;
    public static ConfigOptionDescriptor ConfigureAwait;
    public static ConfigOptionDescriptor DocCommentSummaryStyle;
    public static ConfigOptionDescriptor EmptyStringStyle;
    public static ConfigOptionDescriptor EnumFlagValueStyle;
    public static ConfigOptionDescriptor EnumHasFlagStyle;
    public static ConfigOptionDescriptor EqualsTokenNewLine;
    public static ConfigOptionDescriptor InfiniteLoopStyle;
    public static ConfigOptionDescriptor MaxLineLength;
    public static ConfigOptionDescriptor NewLineAtEndOfFile;
    public static ConfigOptionDescriptor NewLineBeforeWhileInDoStatement;
    public static ConfigOptionDescriptor NullCheckStyle;
    public static ConfigOptionDescriptor NullConditionalOperatorNewLine;
    public static ConfigOptionDescriptor ObjectCreationParenthesesStyle;
    public static ConfigOptionDescriptor ObjectCreationTypeStyle;
    public static ConfigOptionDescriptor PrefixFieldIdentifierWithUnderscore;
    [ObsoleteAttribute("", "False")]
public static ConfigOptionDescriptor SuppressUnityScriptMethods;
    public static ConfigOptionDescriptor TabLength;
    public static ConfigOptionDescriptor TrailingCommaStyle;
    public static ConfigOptionDescriptor UnityCodeAnalysisEnabled;
    public static ConfigOptionDescriptor UseAnonymousFunctionOrMethodGroup;
    public static ConfigOptionDescriptor UseBlockBodyWhenDeclarationSpansOverMultipleLines;
    public static ConfigOptionDescriptor UseBlockBodyWhenExpressionSpansOverMultipleLines;
    public static ConfigOptionDescriptor UseCollectionExpression;
    public static ConfigOptionDescriptor UseVar;
    public static ConfigOptionDescriptor UseVarInsteadOfImplicitObjectCreation;
    private static ConfigOptions();
    public static string GetRequiredOptions(DiagnosticDescriptor descriptor);
    private static string JoinOptionKeys(String[] values);
    public static bool TryGetValue(AnalyzerConfigOptions configOptions, ConfigOptionDescriptor option, String& value, string defaultValue);
    public static string GetValue(AnalyzerConfigOptions configOptions, ConfigOptionDescriptor option, string defaultValue);
    public static bool TryGetValueAsBool(AnalyzerConfigOptions configOptions, ConfigOptionDescriptor option, Boolean& value, Nullable`1<bool> defaultValue);
    public static Nullable`1<bool> GetValueAsBool(AnalyzerConfigOptions configOptions, ConfigOptionDescriptor option, Nullable`1<bool> defaultValue);
    [IteratorStateMachineAttribute("Roslynator.ConfigOptions/<GetRequiredOptions>d__46")]
private static IEnumerable`1<KeyValuePair`2<string, string>> GetRequiredOptions();
}
internal static class Roslynator.ConfigOptionValues : object {
    public static string AccessibilityModifiers_Explicit;
    public static string AccessibilityModifiers_Implicit;
    public static string AccessorBracesStyle_MultiLine;
    public static string AccessorBracesStyle_SingleLineWhenExpressionIsOnSingleLine;
    public static string ArrayCreationTypeStyle_Explicit;
    public static string ArrayCreationTypeStyle_Implicit;
    public static string ArrayCreationTypeStyle_ImplicitWhenTypeIsObvious;
    public static string ArrowTokenNewLine_After;
    public static string ArrowTokenNewLine_Before;
    public static string BinaryOperatorNewLine_After;
    public static string BinaryOperatorNewLine_Before;
    public static string BlankLineBetweenSwitchSections_Include;
    public static string BlankLineBetweenSwitchSections_Omit;
    public static string BlankLineBetweenSwitchSections_OmitAfterBlock;
    public static string BlankLineBetweenUsingDirectives_Never;
    public static string BlankLineBetweenUsingDirectives_SeparateGroups;
    public static string BlockBracesStyle_MultiLine;
    public static string BlockBracesStyle_SingleLineWhenEmpty;
    public static string BodyStyle_Block;
    public static string BodyStyle_Expression;
    public static string ConditionalOperatorConditionParenthesesStyle_Include;
    public static string ConditionalOperatorConditionParenthesesStyle_Omit;
    public static string ConditionalOperatorConditionParenthesesStyle_OmitWhenConditionIsSingleToken;
    public static string ConditionalOperatorNewLine_After;
    public static string ConditionalOperatorNewLine_Before;
    public static string DocCommentSummaryStyle_MultiLine;
    public static string DocCommentSummaryStyle_SingleLine;
    public static string EmptyStringStyle_Field;
    public static string EmptyStringStyle_Literal;
    public static string EnumFlagValueStyle_DecimalNumber;
    public static string EnumFlagValueStyle_ShiftOperator;
    public static string EnumHasFlagStyle_Method;
    public static string EnumHasFlagStyle_Operator;
    public static string EqualsTokenNewLine_After;
    public static string EqualsTokenNewLine_Before;
    public static string InfiniteLoopStyle_For;
    public static string InfiniteLoopStyle_While;
    public static string NullCheckStyle_EqualityOperator;
    public static string NullCheckStyle_PatternMatching;
    public static string NullConditionalOperatorNewLine_After;
    public static string NullConditionalOperatorNewLine_Before;
    public static string ObjectCreationParenthesesStyle_Include;
    public static string ObjectCreationParenthesesStyle_Omit;
    public static string ObjectCreationTypeStyle_Explicit;
    public static string ObjectCreationTypeStyle_Implicit;
    public static string ObjectCreationTypeStyle_ImplicitWhenTypeIsObvious;
    public static string TrailingCommaStyle_Include;
    public static string TrailingCommaStyle_Omit;
    public static string TrailingCommaStyle_OmitWhenSingleLine;
    public static string UseAnonymousFunctionOrMethodGroup_AnonymousFunction;
    public static string UseAnonymousFunctionOrMethodGroup_MethodGroup;
    public static string UseVar_Always;
    public static string UseVar_Never;
    public static string UseVar_WhenTypeIsObvious;
}
public class Roslynator.Configuration.CodeAnalysisConfig : object {
    private ImmutableDictionary`2<string, bool> _editorConfigBoolOptions;
    [CompilerGeneratedAttribute]
private static CodeAnalysisConfig <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private EditorConfigCodeAnalysisConfig <EditorConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlCodeAnalysisConfig <XmlConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private VisualStudioCodeAnalysisConfig <VisualStudioConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxLineLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PrefixFieldIdentifierWithUnderscore>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <RefactoringsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CompilerDiagnosticFixesEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, bool> <Refactorings>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, bool> <CodeFixes>k__BackingField;
    [CompilerGeneratedAttribute]
private static EventHandler Updated;
    public static CodeAnalysisConfig Instance { get; private set; }
    internal EditorConfigCodeAnalysisConfig EditorConfig { get; }
    internal XmlCodeAnalysisConfig XmlConfig { get; }
    internal VisualStudioCodeAnalysisConfig VisualStudioConfig { get; }
    public Nullable`1<int> MaxLineLength { get; }
    public Nullable`1<bool> PrefixFieldIdentifierWithUnderscore { get; }
    public Nullable`1<bool> RefactoringsEnabled { get; }
    public Nullable`1<bool> CompilerDiagnosticFixesEnabled { get; }
    public ImmutableDictionary`2<string, bool> Refactorings { get; }
    public ImmutableDictionary`2<string, bool> CodeFixes { get; }
    private CodeAnalysisConfig(XmlCodeAnalysisConfig xmlConfig, EditorConfigCodeAnalysisConfig editorConfig, VisualStudioCodeAnalysisConfig visualStudioConfig);
    private static CodeAnalysisConfig();
    [CompilerGeneratedAttribute]
public static CodeAnalysisConfig get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(CodeAnalysisConfig value);
    [CompilerGeneratedAttribute]
internal EditorConfigCodeAnalysisConfig get_EditorConfig();
    [CompilerGeneratedAttribute]
internal XmlCodeAnalysisConfig get_XmlConfig();
    [CompilerGeneratedAttribute]
internal VisualStudioCodeAnalysisConfig get_VisualStudioConfig();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxLineLength();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PrefixFieldIdentifierWithUnderscore();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_RefactoringsEnabled();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CompilerDiagnosticFixesEnabled();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, bool> get_Refactorings();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, bool> get_CodeFixes();
    [CompilerGeneratedAttribute]
public static void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_Updated(EventHandler value);
    public Nullable`1<bool> GetOptionAsBool(string key);
    internal static void UpdateVisualStudioConfig(Func`2<VisualStudioCodeAnalysisConfig, VisualStudioCodeAnalysisConfig> config);
    public bool IsRefactoringEnabled(string id);
    public Nullable`1<DiagnosticSeverity> GetDiagnosticSeverity(string id, string category, bool isEnabledByDefault);
    public bool IsDiagnosticEnabledByDefault(string id, string category, bool defaultValue);
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__SetRefactorings|5_4(Dictionary`2<string, bool> options, ImmutableDictionary`2<string, bool> options2);
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__SetCodeFixes|5_5(Dictionary`2<string, bool> options, ImmutableDictionary`2<string, bool> options2);
}
internal static class Roslynator.Configuration.ConfigMigrator : object {
    public static void MigrateToEditorConfig();
    private static void Migrate(string path);
    [CompilerGeneratedAttribute]
internal static void <Migrate>g__MarkFileAsMigrated|1_0(string path);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<string, string> <Migrate>g__MapRuleSetOptionToEditorConfigOption|1_1(KeyValuePair`2<string, ReportDiagnostic> kvp);
}
internal class Roslynator.Configuration.EditorConfigCodeAnalysisConfig : object {
    public static string FileName;
    internal static string FileDefaultContent;
    [CompilerGeneratedAttribute]
private static EditorConfigCodeAnalysisConfig <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxLineLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PrefixFieldIdentifierWithUnderscore>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, string> <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ReportDiagnostic> <Analyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ReportDiagnostic> <AnalyzerCategories>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, bool> <Refactorings>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, bool> <CodeFixes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AnalyzersEnabledByDefault>k__BackingField;
    internal static EditorConfigCodeAnalysisConfig Empty { get; }
    public Nullable`1<int> MaxLineLength { get; }
    public Nullable`1<bool> PrefixFieldIdentifierWithUnderscore { get; }
    public ImmutableDictionary`2<string, string> Options { get; }
    public ImmutableDictionary`2<string, ReportDiagnostic> Analyzers { get; }
    public ImmutableDictionary`2<string, ReportDiagnostic> AnalyzerCategories { get; }
    public ImmutableDictionary`2<string, bool> Refactorings { get; }
    public ImmutableDictionary`2<string, bool> CodeFixes { get; }
    public Nullable`1<bool> AnalyzersEnabledByDefault { get; }
    public EditorConfigCodeAnalysisConfig(IEnumerable`1<KeyValuePair`2<string, string>> options, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> analyzers, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> analyzerCategories, IEnumerable`1<KeyValuePair`2<string, bool>> refactorings, IEnumerable`1<KeyValuePair`2<string, bool>> codeFixes, Nullable`1<bool> analyzersEnabledByDefault);
    private static EditorConfigCodeAnalysisConfig();
    [CompilerGeneratedAttribute]
internal static EditorConfigCodeAnalysisConfig get_Empty();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxLineLength();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PrefixFieldIdentifierWithUnderscore();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, string> get_Options();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ReportDiagnostic> get_Analyzers();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ReportDiagnostic> get_AnalyzerCategories();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, bool> get_Refactorings();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, bool> get_CodeFixes();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AnalyzersEnabledByDefault();
    internal IReadOnlyDictionary`2<string, bool> GetRefactorings();
    internal IReadOnlyDictionary`2<string, bool> GetCodeFixes();
    public static string GetDefaultConfigFilePath();
    public Nullable`1<DiagnosticSeverity> GetDiagnosticSeverity(string id, string category, bool isEnabledByDefault);
    public Nullable`1<bool> IsDiagnosticEnabledByDefault(string id, string category, bool defaultValue);
    private Nullable`1<ReportDiagnostic> GetReportDiagnostic(string id, string category, bool isEnabledByDefault);
    public static void Save(string path, IEnumerable`1<KeyValuePair`2<string, string>> options, IEnumerable`1<KeyValuePair`2<string, bool>> refactorings, IEnumerable`1<KeyValuePair`2<string, bool>> codeFixes);
    internal static string CreateDefaultConfigFileIfNotExists();
}
internal static class Roslynator.Configuration.EditorConfigCodeAnalysisConfigLoader : object {
    public static EditorConfigCodeAnalysisConfig Load(IEnumerable`1<string> paths);
    internal static EditorConfigCodeAnalysisConfig LoadAndCatchIfThrows(IEnumerable`1<string> paths, Action`1<Exception> exceptionHandler);
    private static EditorConfigCodeAnalysisConfig LoadInternal(IEnumerable`1<string> paths);
    private static EditorConfigData LoadFile(string path);
    [CompilerGeneratedAttribute]
internal static Nullable`1<ReportDiagnostic> <LoadInternal>g__ParseReportDiagnostic|2_0(string value);
}
internal class Roslynator.Configuration.EditorConfigWriter : object {
    public static string AnalyzerCategoryPrefix;
    private TextWriter _writer;
    private bool _disposed;
    public EditorConfigWriter(TextWriter writer);
    public void WriteGlobalDirective();
    public void WriteEntries(IEnumerable`1<KeyValuePair`2<string, string>> entries, string keyPrefix);
    public void WriteRefactorings(IEnumerable`1<KeyValuePair`2<string, bool>> entries);
    public void WriteRefactoring(string id, bool enabled);
    public void WriteCompilerDiagnosticFixes(IEnumerable`1<KeyValuePair`2<string, bool>> entries);
    public void WriteCompilerDiagnosticFix(string id, bool enabled);
    public void WriteAnalyzers(IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> entries);
    public void WriteAnalyzer(string id, ReportDiagnostic reportDiagnostic);
    public void WriteAnalyzerCategory(string categoryName, ReportDiagnostic reportDiagnostic);
    public void WriteAnalyzerCategory(string categoryName, string severity);
    public void WriteEntry(KeyValuePair`2<string, string> entry);
    public void WriteEntry(string key, bool value);
    public void WriteEntry(string key, ReportDiagnostic reportDiagnostic);
    public void WriteEntry(string key, string value);
    private void WriteSeparator();
    public void WriteCommentChar();
    private void WriteValue(bool value);
    public void Write(string value);
    public void WriteLine();
    public void WriteLine(string value);
    public void WriteLineIf(bool condition);
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private static string MapReportDiagnostic(ReportDiagnostic reportDiagnostic);
}
internal class Roslynator.Configuration.VisualStudioCodeAnalysisConfig : object {
    [CompilerGeneratedAttribute]
private static VisualStudioCodeAnalysisConfig <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrefixFieldIdentifierWithUnderscore>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, bool> <Refactorings>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, bool> <CodeFixes>k__BackingField;
    internal static VisualStudioCodeAnalysisConfig Empty { get; }
    public bool PrefixFieldIdentifierWithUnderscore { get; }
    public ImmutableDictionary`2<string, bool> Refactorings { get; }
    public ImmutableDictionary`2<string, bool> CodeFixes { get; }
    public VisualStudioCodeAnalysisConfig(bool prefixFieldIdentifierWithUnderscore, IEnumerable`1<KeyValuePair`2<string, bool>> refactorings, IEnumerable`1<KeyValuePair`2<string, bool>> codeFixes);
    private static VisualStudioCodeAnalysisConfig();
    [CompilerGeneratedAttribute]
internal static VisualStudioCodeAnalysisConfig get_Empty();
    [CompilerGeneratedAttribute]
public bool get_PrefixFieldIdentifierWithUnderscore();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, bool> get_Refactorings();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, bool> get_CodeFixes();
    public VisualStudioCodeAnalysisConfig WithPrefixFieldIdentifierWithUnderscore(bool value);
    public VisualStudioCodeAnalysisConfig WithRefactorings(IEnumerable`1<KeyValuePair`2<string, bool>> refactorings);
    public VisualStudioCodeAnalysisConfig WithCodeFixes(IEnumerable`1<KeyValuePair`2<string, bool>> codeFixes);
}
public class Roslynator.Configuration.XmlCodeAnalysisConfig : object {
    public static string FileName;
    private static IEqualityComparer`1<string> _keyComparer;
    [CompilerGeneratedAttribute]
private static XmlCodeAnalysisConfig <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, bool> <Analyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, bool> <CodeFixes>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, bool> <Refactorings>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <RuleSets>k__BackingField;
    [CompilerGeneratedAttribute]
private ReportDiagnostic <GeneralDiagnosticOption>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ReportDiagnostic> <SpecificDiagnosticOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PrefixFieldIdentifierWithUnderscore>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxLineLength>k__BackingField;
    public static XmlCodeAnalysisConfig Empty { get; }
    public ImmutableArray`1<string> Includes { get; }
    public ImmutableDictionary`2<string, bool> Analyzers { get; }
    public ImmutableDictionary`2<string, bool> CodeFixes { get; }
    public ImmutableDictionary`2<string, bool> Refactorings { get; }
    public ImmutableArray`1<string> RuleSets { get; }
    public ReportDiagnostic GeneralDiagnosticOption { get; }
    public ImmutableDictionary`2<string, ReportDiagnostic> SpecificDiagnosticOptions { get; }
    public Nullable`1<bool> PrefixFieldIdentifierWithUnderscore { get; }
    public Nullable`1<int> MaxLineLength { get; }
    internal XmlCodeAnalysisConfig(IEnumerable`1<string> includes, IEnumerable`1<KeyValuePair`2<string, bool>> analyzers, IEnumerable`1<KeyValuePair`2<string, bool>> codeFixes, IEnumerable`1<KeyValuePair`2<string, bool>> refactorings, IEnumerable`1<string> ruleSets, Nullable`1<bool> prefixFieldIdentifierWithUnderscore, Nullable`1<int> maxLineLength);
    private static XmlCodeAnalysisConfig();
    [CompilerGeneratedAttribute]
public static XmlCodeAnalysisConfig get_Empty();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Includes();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, bool> get_Analyzers();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, bool> get_CodeFixes();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, bool> get_Refactorings();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_RuleSets();
    [CompilerGeneratedAttribute]
public ReportDiagnostic get_GeneralDiagnosticOption();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ReportDiagnostic> get_SpecificDiagnosticOptions();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PrefixFieldIdentifierWithUnderscore();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxLineLength();
    public static string GetDefaultConfigFilePath();
    public Nullable`1<DiagnosticSeverity> GetDiagnosticSeverity(string id);
    public Nullable`1<bool> IsDiagnosticEnabledByDefault(string id);
}
internal static class Roslynator.Configuration.XmlCodeAnalysisConfigLoader : object {
    public static XmlCodeAnalysisConfig Load(string path);
    internal static XmlCodeAnalysisConfig LoadAndCatchIfThrows(string uri, XmlConfigLoadOptions options, Action`1<Exception> exceptionHandler);
    internal static XmlCodeAnalysisConfig Load(string path, XmlConfigLoadOptions options);
    private static void Load(string uri, Builder& builder, Queue`1& includes);
    private static void LoadSettings(XElement element, Builder builder, string filePath);
    private static void LoadGeneral(XElement element, Builder builder);
    private static void LoadFormatting(XElement element, Builder builder);
    private static void LoadAnalyzers(XElement element, Builder builder);
    private static void LoadRefactorings(XElement element, Builder builder);
    private static void LoadCodeFixes(XElement element, Builder builder);
    private static void LoadRuleSets(XElement element, Builder builder, string filePath);
    private static string LoadPath(XAttribute attribute, string basePath);
    private static bool TryGetNormalizedFullPath(string path, String& result);
    private static bool TryGetNormalizedFullPath(string path, string basePath, String& result);
}
[FlagsAttribute]
internal enum Roslynator.Configuration.XmlConfigLoadOptions : Enum {
    public int value__;
    public static XmlConfigLoadOptions None;
    public static XmlConfigLoadOptions SkipIncludes;
}
[ExtensionAttribute]
internal static class Roslynator.Configuration.XmlExtensions : object {
    [ExtensionAttribute]
public static bool HasName(XElement element, string name, StringComparison comparison);
    [ExtensionAttribute]
public static bool HasName(XAttribute attribute, string name, StringComparison comparison);
    [ExtensionAttribute]
public static Nullable`1<bool> GetValueAsBoolean(XAttribute attribute);
}
internal static class Roslynator.CSharp.Analysis.AddBracesToSwitchSectionAnalysis : object {
    public static bool CanAddBraces(SwitchSectionSyntax section);
}
internal static class Roslynator.CSharp.Analysis.AddExceptionToDocumentationComment.AddExceptionToDocumentationCommentAnalysis : object {
    [CompilerGeneratedAttribute]
private static AddExceptionToDocumentationCommentAnalysisResult <Fail>k__BackingField;
    private static AddExceptionToDocumentationCommentAnalysisResult Fail { get; }
    private static AddExceptionToDocumentationCommentAnalysis();
    [CompilerGeneratedAttribute]
private static AddExceptionToDocumentationCommentAnalysisResult get_Fail();
    public static AddExceptionToDocumentationCommentAnalysisResult Analyze(ThrowStatementSyntax throwStatement, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static AddExceptionToDocumentationCommentAnalysisResult Analyze(ThrowExpressionSyntax throwExpression, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static AddExceptionToDocumentationCommentAnalysisResult Analyze(SyntaxNode node, ExpressionSyntax expression, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CanAddExceptionToComment(DocumentationCommentTriviaSyntax comment, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ContainsException(XmlElementSyntax xmlElement, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ContainsException(XmlEmptyElementSyntax xmlEmptyElement, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ContainsException(SyntaxList`1<XmlAttributeSyntax> attributes, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static ISymbol GetDeclarationSymbol(int position, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ISymbol GetDeclarationSymbol(ISymbol symbol);
    private static bool InheritsFromException(ITypeSymbol typeSymbol, INamedTypeSymbol exceptionSymbol);
    private static bool IsExceptionTypeCaughtInMethod(SyntaxNode node, ITypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Roslynator.CSharp.Analysis.AddExceptionToDocumentationComment.AddExceptionToDocumentationCommentAnalysisResult : ValueType {
    [CompilerGeneratedAttribute]
private ThrowInfo <ThrowInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxTrivia <DocumentationComment>k__BackingField;
    internal ThrowInfo ThrowInfo { get; }
    public bool Success { get; }
    public ISymbol DeclarationSymbol { get; }
    public SyntaxTrivia DocumentationComment { get; }
    internal AddExceptionToDocumentationCommentAnalysisResult(ThrowInfo info, SyntaxTrivia documentationComment);
    [CompilerGeneratedAttribute]
internal ThrowInfo get_ThrowInfo();
    public bool get_Success();
    public ISymbol get_DeclarationSymbol();
    [CompilerGeneratedAttribute]
public SyntaxTrivia get_DocumentationComment();
}
internal class Roslynator.CSharp.Analysis.AddExceptionToDocumentationComment.ThrowExpressionInfo : ThrowInfo {
    internal ThrowExpressionInfo(ThrowExpressionSyntax node, ExpressionSyntax expression, ITypeSymbol exceptionSymbol, ISymbol declarationSymbol);
    protected virtual IParameterSymbol GetParameterSymbolCore(SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal abstract class Roslynator.CSharp.Analysis.AddExceptionToDocumentationComment.ThrowInfo : object {
    [CompilerGeneratedAttribute]
private SyntaxNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <ExceptionSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <DeclarationSymbol>k__BackingField;
    public SyntaxNode Node { get; }
    public ITypeSymbol ExceptionSymbol { get; }
    public ExpressionSyntax Expression { get; }
    public ISymbol DeclarationSymbol { get; }
    protected ThrowInfo(SyntaxNode node, ExpressionSyntax expression, ITypeSymbol exceptionSymbol, ISymbol declarationSymbol);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Node();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_ExceptionSymbol();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression();
    [CompilerGeneratedAttribute]
public ISymbol get_DeclarationSymbol();
    public static ThrowInfo Create(SyntaxNode node, ITypeSymbol exceptionSymbol, ISymbol declarationSymbol);
    public IParameterSymbol GetParameterSymbol(SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual IParameterSymbol GetParameterSymbolCore(SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Roslynator.CSharp.Analysis.AddExceptionToDocumentationComment.ThrowStatementInfo : ThrowInfo {
    internal ThrowStatementInfo(ThrowStatementSyntax node, ExpressionSyntax expression, ITypeSymbol exceptionSymbol, ISymbol declarationSymbol);
    protected virtual IParameterSymbol GetParameterSymbolCore(SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Roslynator.CSharp.Analysis.AnalysisOptions : object {
    [CompilerGeneratedAttribute]
private bool <CanContainDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanContainComments>k__BackingField;
    public bool CanContainDirectives { get; }
    public bool CanContainComments { get; }
    public AnalysisOptions(bool canContainDirectives, bool canContainComments);
    [CompilerGeneratedAttribute]
public bool get_CanContainDirectives();
    [CompilerGeneratedAttribute]
public bool get_CanContainComments();
}
[IsReadOnlyAttribute]
internal class Roslynator.CSharp.Analysis.BlockExpressionAnalysis : ValueType {
    [CompilerGeneratedAttribute]
private StatementSyntax <Statement>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <SemicolonToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <ReturnOrThrowKeyword>k__BackingField;
    public StatementSyntax Statement { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    public SyntaxToken ReturnOrThrowKeyword { get; }
    public BlockSyntax Block { get; }
    public bool Success { get; }
    private BlockExpressionAnalysis(StatementSyntax statement, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxToken returnOrThrowKeyword);
    [CompilerGeneratedAttribute]
public StatementSyntax get_Statement();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression();
    [CompilerGeneratedAttribute]
public SyntaxToken get_SemicolonToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_ReturnOrThrowKeyword();
    public BlockSyntax get_Block();
    public bool get_Success();
    public static bool SupportsExpressionBody(BlockSyntax block, bool allowExpressionStatement);
    public static BlockExpressionAnalysis Create(AccessorListSyntax accessorList);
    public static BlockExpressionAnalysis Create(AccessorDeclarationSyntax accessor);
    public static BlockExpressionAnalysis Create(BlockSyntax block, bool allowExpressionStatement);
}
public static class Roslynator.CSharp.Analysis.CallExtensionMethodAsInstanceMethodAnalysis : object {
    public static string Title;
    [CompilerGeneratedAttribute]
private static CallExtensionMethodAsInstanceMethodAnalysisResult <Fail>k__BackingField;
    private static CallExtensionMethodAsInstanceMethodAnalysisResult Fail { get; }
    [CompilerGeneratedAttribute]
private static CallExtensionMethodAsInstanceMethodAnalysisResult get_Fail();
    public static CallExtensionMethodAsInstanceMethodAnalysisResult Analyze(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, bool allowAnyExpression, CancellationToken cancellationToken);
    public static SyntaxNodeOrToken GetNodeOrToken(ExpressionSyntax expression);
    private static InvocationExpressionSyntax GetNewInvocation(InvocationExpressionSyntax invocation);
    [CompilerGeneratedAttribute]
internal static MemberAccessExpressionSyntax <GetNewInvocation>g__CreateNewMemberAccessExpression|6_0(<>c__DisplayClass6_0& );
}
[IsReadOnlyAttribute]
public class Roslynator.CSharp.Analysis.CallExtensionMethodAsInstanceMethodAnalysisResult : ValueType {
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <InvocationExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <NewInvocationExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <MethodSymbol>k__BackingField;
    public InvocationExpressionSyntax InvocationExpression { get; }
    public InvocationExpressionSyntax NewInvocationExpression { get; }
    public IMethodSymbol MethodSymbol { get; }
    public bool Success { get; }
    public CallExtensionMethodAsInstanceMethodAnalysisResult(InvocationExpressionSyntax invocationExpression, InvocationExpressionSyntax newInvocationExpression, IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
public InvocationExpressionSyntax get_InvocationExpression();
    [CompilerGeneratedAttribute]
public InvocationExpressionSyntax get_NewInvocationExpression();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_MethodSymbol();
    public bool get_Success();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CallExtensionMethodAsInstanceMethodAnalysisResult other);
    public virtual int GetHashCode();
    public static bool op_Equality(CallExtensionMethodAsInstanceMethodAnalysisResult& analysis1, CallExtensionMethodAsInstanceMethodAnalysisResult& analysis2);
    public static bool op_Inequality(CallExtensionMethodAsInstanceMethodAnalysisResult& analysis1, CallExtensionMethodAsInstanceMethodAnalysisResult& analysis2);
}
internal static class Roslynator.CSharp.Analysis.ChangeAccessibilityAnalysis : object {
    private static ImmutableDictionary`2<Accessibility, ImmutableArray`1<Accessibility>> _accessibilityArrayMap;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<Accessibility> <AvailableAccessibilities>k__BackingField;
    private static ImmutableArray`1<Accessibility> AvailableAccessibilities { get; }
    private static ChangeAccessibilityAnalysis();
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<Accessibility> get_AvailableAccessibilities();
    public static AccessibilityFilter GetValidAccessibilityFilter(MemberDeclarationListSelection selectedMembers, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static ISymbol GetBaseSymbolOrDefault(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsBaseDeclarationWithoutSource(MemberDeclarationSyntax member, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ISymbol <GetBaseSymbolOrDefault>g__GetDeclaredSymbol|5_0(<>c__DisplayClass5_0& );
}
internal static class Roslynator.CSharp.Analysis.ConvertCommentToDocumentationCommentAnalysis : object {
    public static TextSpan GetFixableSpan(SyntaxTrivia trivia);
    public static LeadingAnalysis AnalyzeLeadingTrivia(SyntaxNode declaration);
    public static TrailingAnalysis AnalyzeTrailingTrivia(SyntaxNodeOrToken nodeOrToken);
    private static bool IsTaskListItem(SyntaxTrivia singleLineComment);
}
internal static class Roslynator.CSharp.Analysis.ConvertHasFlagCallToBitwiseOperationAnalysis : object {
    public static bool IsFixable(InvocationExpressionSyntax invocation, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsFixable(SimpleMemberInvocationExpressionInfo& invocationInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Analysis.ConvertInterpolatedStringToStringLiteralAnalysis : object {
    public static bool IsFixable(InterpolatedStringExpressionSyntax interpolatedString);
    public static bool IsFixable(SyntaxList`1<InterpolatedStringContentSyntax> contents);
}
internal static class Roslynator.CSharp.Analysis.ConvertLambdaExpressionBodyToExpressionBodyAnalysis : object {
    public static bool IsFixable(LambdaExpressionSyntax lambda);
    private static ExpressionSyntax GetExpression(StatementSyntax statement);
}
public static class Roslynator.CSharp.Analysis.ConvertMethodGroupToAnonymousFunctionAnalysis : object {
    public static bool IsFixable(IdentifierNameSyntax identifierName, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsFixable(MemberAccessExpressionSyntax memberAccessExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool CanBeMethodGroup(ExpressionSyntax expression);
}
internal static class Roslynator.CSharp.Analysis.DiagnosticPropertyKeys : object {
    internal static string ImplicitToCollectionExpression;
    internal static string CollectionExpressionToImplicit;
    internal static string ExplicitToCollectionExpression;
    internal static string VarToExplicit;
    private static DiagnosticPropertyKeys();
}
internal static class Roslynator.CSharp.Analysis.ExpandExpressionBodyAnalysis : object {
    public static bool IsFixable(ArrowExpressionClauseSyntax arrowExpressionClause);
}
internal static class Roslynator.CSharp.Analysis.GenerateBaseConstructorsAnalysis : object {
    public static List`1<IMethodSymbol> GetMissingBaseConstructors(ClassDeclarationSyntax classDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static List`1<IMethodSymbol> GetMissingBaseConstructors(RecordDeclarationSyntax recordDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static List`1<IMethodSymbol> GetMissingBaseConstructors(INamedTypeSymbol symbol, INamedTypeSymbol baseSymbol);
    public static bool IsAnyBaseConstructorMissing(INamedTypeSymbol symbol, INamedTypeSymbol baseSymbol, Func`2<IMethodSymbol, bool> predicate);
    private static ImmutableArray`1<IMethodSymbol> GetBaseConstructors(INamedTypeSymbol baseSymbol);
    private static bool IsAccessibleFromDerivedClass(IMethodSymbol methodSymbol);
}
internal class Roslynator.CSharp.Analysis.If.AssignmentAndIfToAssignmentWithConditionalExpressionAnalysis : ToAssignmentWithConditionalExpressionAnalysis`1<ExpressionStatementSyntax> {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Right>k__BackingField;
    public ExpressionSyntax Right { get; }
    public IfAnalysisKind Kind { get; }
    internal AssignmentAndIfToAssignmentWithConditionalExpressionAnalysis(ExpressionStatementSyntax statement, ExpressionSyntax right, IfStatementSyntax ifStatement, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Right();
    public virtual IfAnalysisKind get_Kind();
}
internal abstract class Roslynator.CSharp.Analysis.If.IfAnalysis : object {
    [CompilerGeneratedAttribute]
private static IfAnalysisOptions <DefaultOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IfStatementSyntax <IfStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    public static IfAnalysisOptions DefaultOptions { get; }
    private static ImmutableArray`1<IfAnalysis> Empty { get; }
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public IfStatementSyntax IfStatement { get; }
    public SemanticModel SemanticModel { get; }
    protected IfAnalysis(IfStatementSyntax ifStatement, SemanticModel semanticModel);
    private static IfAnalysis();
    [CompilerGeneratedAttribute]
public static IfAnalysisOptions get_DefaultOptions();
    private static ImmutableArray`1<IfAnalysis> get_Empty();
    public abstract virtual IfAnalysisKind get_Kind();
    public abstract virtual string get_Title();
    [CompilerGeneratedAttribute]
public IfStatementSyntax get_IfStatement();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    public static ImmutableArray`1<IfAnalysis> Analyze(IfStatementSyntax ifStatement, IfAnalysisOptions options, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<IfAnalysis> Analyze(IfStatementSyntax ifStatement, ExpressionSyntax condition, ExpressionSyntax expression1, ExpressionSyntax expression2, IfAnalysisOptions options, bool isYield, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IfAnalysis CreateIfToReturnStatement(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, NullCheckExpressionInfo& nullCheck, IfAnalysisOptions options, bool isYield, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<IfAnalysis> Analyze(IfStatementSyntax ifStatement, ExpressionSyntax condition, ExpressionStatementSyntax expressionStatement1, ExpressionStatementSyntax expressionStatement2, IfAnalysisOptions options, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IfAnalysis CreateIfToAssignment(IfStatementSyntax ifStatement, ExpressionSyntax left, ExpressionSyntax expression1, ExpressionSyntax expression2, NullCheckExpressionInfo& nullCheck, IfAnalysisOptions options, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static ImmutableArray`1<IfAnalysis> Analyze(StatementListSelection selectedStatements, IfAnalysisOptions options, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<IfAnalysis> Analyze(LocalDeclarationStatementSyntax localDeclarationStatement, IfStatementSyntax ifStatement, IfAnalysisOptions options, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<IfAnalysis> Analyze(ExpressionStatementSyntax expressionStatement, IfStatementSyntax ifStatement, IfAnalysisOptions options, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<IfAnalysis> Analyze(IfStatementSyntax ifStatement, ReturnStatementSyntax returnStatement, IfAnalysisOptions options, SemanticModel semanticModel, CancellationToken cancellationToken);
    private ImmutableArray`1<IfAnalysis> ToImmutableArray();
    private static ImmutableArray`1<IfAnalysis> ToImmutableArray(IfAnalysis refactoring1, IfAnalysis refactoring2);
    private static ExpressionSyntax GetNullableOfTValueProperty(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsNullLiteralConvertedToNullableOfT(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool CheckDirectivesAndComments(SyntaxNode node1, SyntaxNode node2, AnalysisOptions options);
    public static bool CheckDirectivesAndComments(SyntaxNode node, AnalysisOptions options, bool includeLeadingTrivia, bool includeTrailingTrivia);
    [CompilerGeneratedAttribute]
internal static IfAnalysis <CreateIfToReturnStatement>g__CreateIfToReturnStatement|18_0(bool isNullable, <>c__DisplayClass18_0& );
    [CompilerGeneratedAttribute]
internal static IfAnalysis <CreateIfToAssignment>g__CreateIfToAssignment|20_0(bool isNullable, <>c__DisplayClass20_0& );
}
internal class Roslynator.CSharp.Analysis.If.IfAnalysisOptions : AnalysisOptions {
    [CompilerGeneratedAttribute]
private bool <UseCoalesceExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseConditionalExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseBooleanExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseExpression>k__BackingField;
    public bool UseCoalesceExpression { get; }
    public bool UseConditionalExpression { get; }
    public bool UseBooleanExpression { get; }
    public bool UseExpression { get; }
    public IfAnalysisOptions(bool useCoalesceExpression, bool useConditionalExpression, bool useBooleanExpression, bool useExpression);
    [CompilerGeneratedAttribute]
public bool get_UseCoalesceExpression();
    [CompilerGeneratedAttribute]
public bool get_UseConditionalExpression();
    [CompilerGeneratedAttribute]
public bool get_UseBooleanExpression();
    [CompilerGeneratedAttribute]
public bool get_UseExpression();
}
internal class Roslynator.CSharp.Analysis.If.IfElseToAssignmentWithCoalesceExpressionAnalysis : IfAnalysis {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Right1>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Right2>k__BackingField;
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public ExpressionSyntax Left { get; }
    public ExpressionSyntax Right1 { get; }
    public ExpressionSyntax Right2 { get; }
    public IfElseToAssignmentWithCoalesceExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax left, ExpressionSyntax right1, ExpressionSyntax right2, SemanticModel semanticModel);
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Left();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Right1();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Right2();
}
internal class Roslynator.CSharp.Analysis.If.IfElseToAssignmentWithConditionalExpressionAnalysis : ToAssignmentWithConditionalExpressionAnalysis {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Left>k__BackingField;
    public ExpressionSyntax Left { get; }
    public IfAnalysisKind Kind { get; }
    internal IfElseToAssignmentWithConditionalExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax left, ExpressionSyntax right1, ExpressionSyntax right2, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Left();
    public virtual IfAnalysisKind get_Kind();
}
internal class Roslynator.CSharp.Analysis.If.IfElseToAssignmentWithConditionAnalysis : IfAnalysis {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Invert>k__BackingField;
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public ExpressionSyntax Left { get; }
    public ExpressionSyntax Right { get; }
    public bool Invert { get; }
    public IfElseToAssignmentWithConditionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax left, ExpressionSyntax right, SemanticModel semanticModel, bool invert);
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Left();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Right();
    [CompilerGeneratedAttribute]
public bool get_Invert();
}
internal class Roslynator.CSharp.Analysis.If.IfElseToAssignmentWithExpressionAnalysis : IfAnalysis {
    [CompilerGeneratedAttribute]
private ExpressionStatementSyntax <ExpressionStatement>k__BackingField;
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public ExpressionStatementSyntax ExpressionStatement { get; }
    public IfElseToAssignmentWithExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionStatementSyntax expressionStatement, SemanticModel semanticModel);
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public ExpressionStatementSyntax get_ExpressionStatement();
}
internal class Roslynator.CSharp.Analysis.If.IfElseToReturnWithBooleanExpressionAnalysis : IfToReturnWithBooleanExpressionAnalysis {
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public IfElseToReturnWithBooleanExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel);
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
}
internal class Roslynator.CSharp.Analysis.If.IfElseToReturnWithConditionalExpressionAnalysis : IfToReturnWithConditionalExpressionAnalysis {
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public IfElseToReturnWithConditionalExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel);
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
}
internal class Roslynator.CSharp.Analysis.If.IfElseToYieldReturnWithBooleanExpressionAnalysis : IfToReturnWithBooleanExpressionAnalysis {
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public IfElseToYieldReturnWithBooleanExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel);
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
}
internal class Roslynator.CSharp.Analysis.If.IfElseToYieldReturnWithConditionalExpressionAnalysis : IfToReturnWithConditionalExpressionAnalysis {
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public IfElseToYieldReturnWithConditionalExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel);
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
}
internal class Roslynator.CSharp.Analysis.If.IfReturnToReturnWithBooleanExpressionAnalysis : IfToReturnWithBooleanExpressionAnalysis {
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public IfReturnToReturnWithBooleanExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel);
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
}
internal class Roslynator.CSharp.Analysis.If.IfReturnToReturnWithConditionalExpressionAnalysis : IfToReturnWithConditionalExpressionAnalysis {
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public IfReturnToReturnWithConditionalExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel);
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
}
internal abstract class Roslynator.CSharp.Analysis.If.IfToReturnWithBooleanExpressionAnalysis : IfAnalysis {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression1>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression2>k__BackingField;
    public ExpressionSyntax Expression1 { get; }
    public ExpressionSyntax Expression2 { get; }
    protected IfToReturnWithBooleanExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression1();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression2();
    public static IfToReturnWithBooleanExpressionAnalysis Create(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel, bool isYield);
}
internal class Roslynator.CSharp.Analysis.If.IfToReturnWithCoalesceExpressionAnalysis : IfAnalysis {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsYield>k__BackingField;
    public ExpressionSyntax Left { get; }
    public ExpressionSyntax Right { get; }
    public bool IsYield { get; }
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public IfToReturnWithCoalesceExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax left, ExpressionSyntax right, SemanticModel semanticModel, bool isYield);
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Left();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Right();
    [CompilerGeneratedAttribute]
public bool get_IsYield();
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
}
internal abstract class Roslynator.CSharp.Analysis.If.IfToReturnWithConditionalExpressionAnalysis : IfAnalysis {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression1>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression2>k__BackingField;
    public ExpressionSyntax Expression1 { get; }
    public ExpressionSyntax Expression2 { get; }
    protected IfToReturnWithConditionalExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression1();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression2();
    public static IfToReturnWithConditionalExpressionAnalysis Create(IfStatementSyntax ifStatement, ExpressionSyntax expression1, ExpressionSyntax expression2, SemanticModel semanticModel, bool isYield);
}
internal class Roslynator.CSharp.Analysis.If.IfToReturnWithExpressionAnalysis : IfAnalysis {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Invert>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsYield>k__BackingField;
    public ExpressionSyntax Expression { get; }
    public bool Invert { get; }
    public bool IsYield { get; }
    public IfAnalysisKind Kind { get; }
    public string Title { get; }
    public IfToReturnWithExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax expression, bool isYield, bool invert, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression();
    [CompilerGeneratedAttribute]
public bool get_Invert();
    [CompilerGeneratedAttribute]
public bool get_IsYield();
    public virtual IfAnalysisKind get_Kind();
    public virtual string get_Title();
}
internal class Roslynator.CSharp.Analysis.If.LocalDeclarationAndIfElseToAssignmentWithConditionalExpressionAnalysis : ToAssignmentWithConditionalExpressionAnalysis`1<LocalDeclarationStatementSyntax> {
    public IfAnalysisKind Kind { get; }
    internal LocalDeclarationAndIfElseToAssignmentWithConditionalExpressionAnalysis(LocalDeclarationStatementSyntax statement, IfStatementSyntax ifStatement, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse, SemanticModel semanticModel);
    public virtual IfAnalysisKind get_Kind();
}
internal abstract class Roslynator.CSharp.Analysis.If.ToAssignmentWithConditionalExpressionAnalysis : IfAnalysis {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <WhenTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <WhenFalse>k__BackingField;
    public string Title { get; }
    public ExpressionSyntax WhenTrue { get; }
    public ExpressionSyntax WhenFalse { get; }
    protected ToAssignmentWithConditionalExpressionAnalysis(IfStatementSyntax ifStatement, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse, SemanticModel semanticModel);
    public virtual string get_Title();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_WhenTrue();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_WhenFalse();
}
internal abstract class Roslynator.CSharp.Analysis.If.ToAssignmentWithConditionalExpressionAnalysis`1 : ToAssignmentWithConditionalExpressionAnalysis {
    [CompilerGeneratedAttribute]
private TStatement <Statement>k__BackingField;
    public TStatement Statement { get; }
    protected ToAssignmentWithConditionalExpressionAnalysis`1(TStatement statement, IfStatementSyntax ifStatement, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
public TStatement get_Statement();
}
internal enum Roslynator.CSharp.Analysis.IfAnalysisKind : Enum {
    public int value__;
    public static IfAnalysisKind IfElseToAssignmentWithCoalesceExpression;
    public static IfAnalysisKind IfElseToAssignmentWithConditionalExpression;
    public static IfAnalysisKind IfElseToAssignmentWithExpression;
    public static IfAnalysisKind IfElseToAssignmentWithCondition;
    public static IfAnalysisKind AssignmentAndIfToAssignmentWithConditionalExpression;
    public static IfAnalysisKind LocalDeclarationAndIfElseAssignmentWithConditionalExpression;
    public static IfAnalysisKind IfElseToReturnWithCoalesceExpression;
    public static IfAnalysisKind IfElseToReturnWithConditionalExpression;
    public static IfAnalysisKind IfElseToReturnWithBooleanExpression;
    public static IfAnalysisKind IfElseToReturnWithExpression;
    public static IfAnalysisKind IfElseToYieldReturnWithCoalesceExpression;
    public static IfAnalysisKind IfElseToYieldReturnWithConditionalExpression;
    public static IfAnalysisKind IfElseToYieldReturnWithBooleanExpression;
    public static IfAnalysisKind IfElseToYieldReturnWithExpression;
    public static IfAnalysisKind IfReturnToReturnWithCoalesceExpression;
    public static IfAnalysisKind IfReturnToReturnWithConditionalExpression;
    public static IfAnalysisKind IfReturnToReturnWithBooleanExpression;
    public static IfAnalysisKind IfReturnToReturnWithExpression;
}
internal static class Roslynator.CSharp.Analysis.ReduceIfNesting.IfStatementLocalVariableAnalysis : object {
    public static bool DoDeclaredVariablesOverlapWithOuterScope(IfStatementSyntax ifStatement, SemanticModel semanticModel);
}
internal static class Roslynator.CSharp.Analysis.ReduceIfNesting.ReduceIfNestingAnalysis : object {
    private static ReduceIfNestingAnalysisResult Success(SyntaxKind jumpKind, SyntaxNode topNode);
    private static ReduceIfNestingAnalysisResult Fail(SyntaxNode topNode);
    public static ReduceIfNestingAnalysisResult Analyze(IfStatementSyntax ifStatement, SemanticModel semanticModel, ReduceIfNestingOptions options, CancellationToken cancellationToken);
    private static ReduceIfNestingAnalysisResult AnalyzeCore(IfStatementSyntax ifStatement, SemanticModel semanticModel, SyntaxKind jumpKind, ReduceIfNestingOptions options, CancellationToken cancellationToken);
    private static bool IsNestedFix(SyntaxNode node, SemanticModel semanticModel, ReduceIfNestingOptions options, CancellationToken cancellationToken);
    private static bool IsFixable(IfStatementSyntax ifStatement, SyntaxList`1<StatementSyntax> statements, SyntaxKind& jumpKind);
    private static bool IsFixableJumpStatement(StatementSyntax statement, SyntaxKind& kind);
    internal static SyntaxKind GetJumpKind(StatementSyntax statement);
    internal static bool IsFixableRecursively(IfStatementSyntax ifStatement, SyntaxKind jumpKind);
    internal static bool IsFixable(IfStatementSyntax ifStatement);
}
[IsReadOnlyAttribute]
internal class Roslynator.CSharp.Analysis.ReduceIfNesting.ReduceIfNestingAnalysisResult : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxKind <JumpKind>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <TopNode>k__BackingField;
    public SyntaxKind JumpKind { get; }
    public SyntaxNode TopNode { get; }
    public bool Success { get; }
    public ReduceIfNestingAnalysisResult(SyntaxKind jumpKind, SyntaxNode topNode);
    [CompilerGeneratedAttribute]
public SyntaxKind get_JumpKind();
    [CompilerGeneratedAttribute]
public SyntaxNode get_TopNode();
    public bool get_Success();
}
[FlagsAttribute]
internal enum Roslynator.CSharp.Analysis.ReduceIfNesting.ReduceIfNestingOptions : Enum {
    public int value__;
    public static ReduceIfNestingOptions None;
    public static ReduceIfNestingOptions AllowNestedFix;
    public static ReduceIfNestingOptions AllowIfInsideIfElse;
    public static ReduceIfNestingOptions AllowLoop;
    public static ReduceIfNestingOptions AllowSwitchSection;
}
[ExtensionAttribute]
internal static class Roslynator.CSharp.Analysis.ReduceIfNesting.ReduceIfNestingOptionsExtensions : object {
    [ExtensionAttribute]
public static bool AllowNestedFix(ReduceIfNestingOptions options);
    [ExtensionAttribute]
public static bool AllowLoop(ReduceIfNestingOptions options);
    [ExtensionAttribute]
public static bool AllowSwitchSection(ReduceIfNestingOptions options);
    [ExtensionAttribute]
public static bool AllowIfInsideIfElse(ReduceIfNestingOptions options);
}
[IsReadOnlyAttribute]
internal class Roslynator.CSharp.Analysis.RemoveAsyncAwaitAnalysis : ValueType {
    [CompilerGeneratedAttribute]
private AwaitExpressionSyntax <AwaitExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private AwaitExpressionWalker <Walker>k__BackingField;
    public bool Success { get; }
    public AwaitExpressionSyntax AwaitExpression { get; }
    public AwaitExpressionWalker Walker { get; }
    private RemoveAsyncAwaitAnalysis(AwaitExpressionWalker walker);
    private RemoveAsyncAwaitAnalysis(AwaitExpressionSyntax awaitExpression);
    public bool get_Success();
    [CompilerGeneratedAttribute]
public AwaitExpressionSyntax get_AwaitExpression();
    [CompilerGeneratedAttribute]
public AwaitExpressionWalker get_Walker();
    public static RemoveAsyncAwaitAnalysis Create(MethodDeclarationSyntax methodDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static RemoveAsyncAwaitAnalysis Create(LocalFunctionStatementSyntax localFunction, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static RemoveAsyncAwaitAnalysis Create(AnonymousMethodExpressionSyntax anonymousMethod, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static RemoveAsyncAwaitAnalysis AnalyzeExpressionBody(SyntaxNode node, ArrowExpressionClauseSyntax expressionBody, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static RemoveAsyncAwaitAnalysis Create(LambdaExpressionSyntax lambda, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static RemoveAsyncAwaitAnalysis AnalyzeMethodBody(SyntaxNode node, BlockSyntax body, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool VerifyIfStatement(IfStatementSyntax ifStatement, int expectedCount, bool endsWithElse);
    private static bool VerifySwitchStatement(SwitchStatementSyntax switchStatement, int expectedCount, bool containsDefaultSection);
    private static AwaitExpressionSyntax GetAwaitExpression(StatementSyntax statement);
    private static AwaitExpressionSyntax GetAwaitExpression(ReturnStatementSyntax returnStatement);
    private static bool VerifyTypes(SyntaxNode node, HashSet`1<AwaitExpressionSyntax> awaitExpressions, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool VerifyTypes(SyntaxNode node, AwaitExpressionSyntax awaitExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool VerifyAwaitType(AwaitExpressionSyntax awaitExpression, ITypeSymbol typeArgument, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IMethodSymbol GetMethodSymbol(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static AwaitExpressionWalker <AnalyzeMethodBody>g__VisitStatements|15_0(<>c__DisplayClass15_0& );
}
internal class Roslynator.CSharp.Analysis.RemoveRedundantStatement.RemoveRedundantContinueStatementAnalysis : RemoveRedundantStatementAnalysis`1<ContinueStatementSyntax> {
    [CompilerGeneratedAttribute]
private static RemoveRedundantContinueStatementAnalysis <Instance>k__BackingField;
    public static RemoveRedundantContinueStatementAnalysis Instance { get; }
    private static RemoveRedundantContinueStatementAnalysis();
    [CompilerGeneratedAttribute]
public static RemoveRedundantContinueStatementAnalysis get_Instance();
    protected virtual bool IsFixable(StatementSyntax statement, StatementSyntax containingStatement, BlockSyntax block, SyntaxKind parentKind);
}
internal class Roslynator.CSharp.Analysis.RemoveRedundantStatement.RemoveRedundantReturnStatementAnalysis : RemoveRedundantStatementAnalysis`1<ReturnStatementSyntax> {
    [CompilerGeneratedAttribute]
private static RemoveRedundantReturnStatementAnalysis <Instance>k__BackingField;
    public static RemoveRedundantReturnStatementAnalysis Instance { get; }
    private static RemoveRedundantReturnStatementAnalysis();
    [CompilerGeneratedAttribute]
public static RemoveRedundantReturnStatementAnalysis get_Instance();
    public virtual bool IsFixable(ReturnStatementSyntax statement);
    protected virtual bool IsFixable(StatementSyntax statement, StatementSyntax containingStatement, BlockSyntax block, SyntaxKind parentKind);
}
internal static class Roslynator.CSharp.Analysis.RemoveRedundantStatement.RemoveRedundantStatementAnalysis : object {
    public static bool IsFixable(StatementSyntax statement, SyntaxKind statementKind);
    public static bool IsFixable(ContinueStatementSyntax continueStatement);
    public static bool IsFixable(ReturnStatementSyntax returnStatement);
    public static bool IsFixable(YieldStatementSyntax yieldBreakStatement);
}
internal abstract class Roslynator.CSharp.Analysis.RemoveRedundantStatement.RemoveRedundantStatementAnalysis`1 : object {
    public virtual bool IsFixable(TStatement statement);
    internal bool IsFixable(StatementSyntax statement, BlockSyntax block);
    protected abstract virtual bool IsFixable(StatementSyntax statement, StatementSyntax containingStatement, BlockSyntax block, SyntaxKind parentKind);
}
internal class Roslynator.CSharp.Analysis.RemoveRedundantStatement.RemoveRedundantYieldBreakStatementAnalysis : RemoveRedundantStatementAnalysis`1<YieldStatementSyntax> {
    [CompilerGeneratedAttribute]
private static RemoveRedundantYieldBreakStatementAnalysis <Instance>k__BackingField;
    public static RemoveRedundantYieldBreakStatementAnalysis Instance { get; }
    private static RemoveRedundantYieldBreakStatementAnalysis();
    [CompilerGeneratedAttribute]
public static RemoveRedundantYieldBreakStatementAnalysis get_Instance();
    protected virtual bool IsFixable(StatementSyntax statement, StatementSyntax containingStatement, BlockSyntax block, SyntaxKind parentKind);
}
internal static class Roslynator.CSharp.Analysis.ReplaceAsWithCastAnalysis : object {
    public static bool IsFixable(BinaryExpressionSyntax binaryExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Analysis.SplitVariableDeclarationAnalysis : object {
    public static bool IsFixable(VariableDeclarationSyntax variableDeclaration);
    public static string GetTitle(VariableDeclarationSyntax variableDeclaration);
    [CompilerGeneratedAttribute]
internal static string <GetTitle>g__GetName|1_0(<>c__DisplayClass1_0& );
}
internal static class Roslynator.CSharp.Analysis.UseConstantInsteadOfFieldAnalysis : object {
    public static bool IsFixable(FieldDeclarationSyntax fieldDeclaration, SemanticModel semanticModel, bool onlyPrivate, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Analysis.UseElementAccessAnalysis : object {
    public static bool IsFixableElementAt(SimpleMemberInvocationExpressionInfo& invocationInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsFixableFirst(SimpleMemberInvocationExpressionInfo& invocationInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsFixableLast(SimpleMemberInvocationExpressionInfo& invocationInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CheckInfiniteRecursion(IPropertySymbol indexerSymbol, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Analysis.UseLambdaInsteadOfAnonymousMethodAnalysis : object {
    public static bool IsFixable(AnonymousMethodExpressionSyntax anonymousMethod);
}
internal class Roslynator.CSharp.Analysis.UseMethodChaining.MethodChainingWithAssignmentAnalysis : UseMethodChainingAnalysis {
    public virtual bool IsFixableStatement(StatementSyntax statement, string name, ITypeSymbol typeSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsReferenced(SyntaxNode node, IdentifierNameSyntax identifierName, string name, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Roslynator.CSharp.Analysis.UseMethodChaining.MethodChainingWithoutAssignmentAnalysis : UseMethodChainingAnalysis {
    public virtual bool IsFixableStatement(StatementSyntax statement, string name, ITypeSymbol typeSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal abstract class Roslynator.CSharp.Analysis.UseMethodChaining.UseMethodChainingAnalysis : object {
    [CompilerGeneratedAttribute]
private static MethodChainingWithoutAssignmentAnalysis <WithoutAssignmentAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private static MethodChainingWithAssignmentAnalysis <WithAssignmentAnalysis>k__BackingField;
    public static MethodChainingWithoutAssignmentAnalysis WithoutAssignmentAnalysis { get; }
    public static MethodChainingWithAssignmentAnalysis WithAssignmentAnalysis { get; }
    private static UseMethodChainingAnalysis();
    [CompilerGeneratedAttribute]
public static MethodChainingWithoutAssignmentAnalysis get_WithoutAssignmentAnalysis();
    [CompilerGeneratedAttribute]
public static MethodChainingWithAssignmentAnalysis get_WithAssignmentAnalysis();
    public static bool IsFixable(SimpleMemberInvocationExpressionInfo& invocationInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    public bool Analyze(SimpleMemberInvocationExpressionInfo& invocationInfo, StatementSyntax statement, string name, SemanticModel semanticModel, CancellationToken cancellationToken);
    public abstract virtual bool IsFixableStatement(StatementSyntax statement, string name, ITypeSymbol typeSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static SimpleMemberInvocationExpressionInfo WalkDownMethodChain(SimpleMemberInvocationExpressionInfo invocationInfo);
}
[IsReadOnlyAttribute]
internal class Roslynator.CSharp.ArgumentNullCheckAnalysis : ValueType {
    [CompilerGeneratedAttribute]
private ArgumentNullCheckStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    public ArgumentNullCheckStyle Style { get; }
    public string Name { get; }
    public bool Success { get; }
    private ArgumentNullCheckAnalysis(ArgumentNullCheckStyle style, string name, bool success);
    [CompilerGeneratedAttribute]
public ArgumentNullCheckStyle get_Style();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_Success();
    public static ArgumentNullCheckAnalysis Create(StatementSyntax statement, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static ArgumentNullCheckAnalysis Create(StatementSyntax statement, SemanticModel semanticModel, string name, CancellationToken cancellationToken);
    private static ArgumentNullCheckAnalysis CreateFromArgumentNullExceptionThrowIfNullCheck(StatementSyntax statement, SemanticModel semanticModel, string name, CancellationToken cancellationToken);
    public static bool IsArgumentNullExceptionThrowIfNullCheck(StatementSyntax statement, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsArgumentNullCheck(StatementSyntax statement, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsArgumentNullCheck(StatementSyntax statement, SemanticModel semanticModel, string name, CancellationToken cancellationToken);
}
internal enum Roslynator.CSharp.ArgumentNullCheckStyle : Enum {
    public int value__;
    public static ArgumentNullCheckStyle None;
    public static ArgumentNullCheckStyle IfStatement;
    public static ArgumentNullCheckStyle ThrowIfNullMethod;
}
internal enum Roslynator.CSharp.CodeStyle.AccessibilityModifierStyle : Enum {
    public int value__;
    public static AccessibilityModifierStyle None;
    public static AccessibilityModifierStyle Explicit;
    public static AccessibilityModifierStyle Implicit;
}
internal enum Roslynator.CSharp.CodeStyle.AccessorBracesStyle : Enum {
    public int value__;
    public static AccessorBracesStyle None;
    public static AccessorBracesStyle MultiLine;
    public static AccessorBracesStyle SingleLineWhenExpressionIsOnSingleLine;
}
internal enum Roslynator.CSharp.CodeStyle.BlankLineBetweenSwitchSections : Enum {
    public int value__;
    public static BlankLineBetweenSwitchSections None;
    public static BlankLineBetweenSwitchSections Include;
    public static BlankLineBetweenSwitchSections Omit;
    public static BlankLineBetweenSwitchSections OmitAfterBlock;
}
internal enum Roslynator.CSharp.CodeStyle.BlankLineStyle : Enum {
    public int value__;
    public static BlankLineStyle None;
    public static BlankLineStyle Add;
    public static BlankLineStyle Remove;
}
internal enum Roslynator.CSharp.CodeStyle.BlockBracesStyle : Enum {
    public int value__;
    public static BlockBracesStyle None;
    public static BlockBracesStyle MultiLine;
    public static BlockBracesStyle SingleLineWhenEmpty;
}
[IsReadOnlyAttribute]
internal class Roslynator.CSharp.CodeStyle.BodyStyle : ValueType {
    private BodyStyleOption _option;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseBlockWhenDeclarationIsMultiLine>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseBlockWhenExpressionIsMultiLine>k__BackingField;
    public bool IsDefault { get; }
    public bool UseExpression { get; }
    public bool UseBlock { get; }
    public Nullable`1<bool> UseBlockWhenDeclarationIsMultiLine { get; }
    public Nullable`1<bool> UseBlockWhenExpressionIsMultiLine { get; }
    private BodyStyle(BodyStyleOption option, Nullable`1<bool> useBlockWhenDeclarationIsMultiLine, Nullable`1<bool> useBlockWhenExpressionIsMultiLine);
    public bool get_IsDefault();
    public bool get_UseExpression();
    public bool get_UseBlock();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseBlockWhenDeclarationIsMultiLine();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseBlockWhenExpressionIsMultiLine();
    public static BodyStyle Create(SyntaxNodeAnalysisContext context);
}
internal enum Roslynator.CSharp.CodeStyle.ConditionalExpressionParenthesesStyle : Enum {
    public int value__;
    public static ConditionalExpressionParenthesesStyle None;
    public static ConditionalExpressionParenthesesStyle Include;
    public static ConditionalExpressionParenthesesStyle Omit;
    public static ConditionalExpressionParenthesesStyle OmitWhenConditionIsSingleToken;
}
internal enum Roslynator.CSharp.CodeStyle.ConfigureAwaitStyle : Enum {
    public int value__;
    public static ConfigureAwaitStyle None;
    public static ConfigureAwaitStyle Include;
    public static ConfigureAwaitStyle Omit;
}
internal enum Roslynator.CSharp.CodeStyle.DocCommentSummaryStyle : Enum {
    public int value__;
    public static DocCommentSummaryStyle None;
    public static DocCommentSummaryStyle SingleLine;
    public static DocCommentSummaryStyle MultiLine;
}
internal enum Roslynator.CSharp.CodeStyle.EmptyStringStyle : Enum {
    public int value__;
    public static EmptyStringStyle None;
    public static EmptyStringStyle Field;
    public static EmptyStringStyle Literal;
}
internal enum Roslynator.CSharp.CodeStyle.EnumFlagOperationStyle : Enum {
    public int value__;
    public static EnumFlagOperationStyle None;
    public static EnumFlagOperationStyle HasFlagMethod;
    public static EnumFlagOperationStyle BitwiseOperator;
}
internal enum Roslynator.CSharp.CodeStyle.EnumFlagValueStyle : Enum {
    public int value__;
    public static EnumFlagValueStyle None;
    public static EnumFlagValueStyle DecimalNumber;
    public static EnumFlagValueStyle ShiftOperator;
}
internal enum Roslynator.CSharp.CodeStyle.InfiniteLoopStyle : Enum {
    public int value__;
    public static InfiniteLoopStyle None;
    public static InfiniteLoopStyle ForStatement;
    public static InfiniteLoopStyle WhileStatement;
}
internal enum Roslynator.CSharp.CodeStyle.NewLinePosition : Enum {
    public int value__;
    public static NewLinePosition None;
    public static NewLinePosition After;
    public static NewLinePosition Before;
}
internal enum Roslynator.CSharp.CodeStyle.NewLineStyle : Enum {
    public int value__;
    public static NewLineStyle None;
    public static NewLineStyle Add;
    public static NewLineStyle Remove;
}
internal enum Roslynator.CSharp.CodeStyle.NullCheckStyle : Enum {
    public int value__;
    public static NullCheckStyle None;
    public static NullCheckStyle EqualityOperator;
    public static NullCheckStyle PatternMatching;
}
internal enum Roslynator.CSharp.CodeStyle.ObjectCreationParenthesesStyle : Enum {
    public int value__;
    public static ObjectCreationParenthesesStyle None;
    public static ObjectCreationParenthesesStyle Include;
    public static ObjectCreationParenthesesStyle Omit;
}
internal enum Roslynator.CSharp.CodeStyle.TrailingCommaStyle : Enum {
    public int value__;
    public static TrailingCommaStyle None;
    public static TrailingCommaStyle Include;
    public static TrailingCommaStyle Omit;
    public static TrailingCommaStyle OmitWhenSingleLine;
}
internal enum Roslynator.CSharp.CodeStyle.TypeStyle : Enum {
    public int value__;
    public static TypeStyle None;
    public static TypeStyle Explicit;
    public static TypeStyle Implicit;
    public static TypeStyle ImplicitWhenTypeIsObvious;
}
internal enum Roslynator.CSharp.CodeStyle.UsingDirectiveBlankLineStyle : Enum {
    public int value__;
    public static UsingDirectiveBlankLineStyle None;
    public static UsingDirectiveBlankLineStyle Never;
    public static UsingDirectiveBlankLineStyle SeparateGroups;
}
[ExtensionAttribute]
internal static class Roslynator.CSharp.CodeStyleExtensions : object {
    [ExtensionAttribute]
public static bool TryGetTabLength(AnalyzerConfigOptions configOptions, Int32& tabLength);
    [ExtensionAttribute]
public static bool TryGetIndentSize(AnalyzerConfigOptions configOptions, Int32& indentSize);
    [ExtensionAttribute]
public static bool TryGetIndentStyle(AnalyzerConfigOptions configOptions, IndentStyle& indentStyle);
    [ExtensionAttribute]
public static bool GetPrefixFieldIdentifierWithUnderscore(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static int GetMaxLineLength(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static Nullable`1<bool> UseVarInsteadOfImplicitObjectCreation(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static Nullable`1<bool> PreferNewLineAtEndOfFile(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static Nullable`1<bool> PreferNewLineAtEndOfFile(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static NewLineStyle GetNewLineBeforeWhileInDoStatement(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static NewLinePosition GetBinaryOperatorNewLinePosition(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static NewLinePosition GetConditionalOperatorNewLinePosition(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static NewLinePosition GetArrowTokenNewLinePosition(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static NewLinePosition GetEqualsTokenNewLinePosition(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static NewLinePosition GetNullConditionalOperatorNewLinePosition(AnalyzerConfigOptions configOptions, NewLinePosition defaultValue);
    [ExtensionAttribute]
public static UsingDirectiveBlankLineStyle GetBlankLineBetweenUsingDirectives(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static AccessorBracesStyle GetAccessorBracesStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static BlockBracesStyle GetBlockBracesStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static BlankLineStyle GetBlankLineBetweenSingleLineAccessors(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static Nullable`1<bool> PreferAnonymousFunctionOrMethodGroup(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static EnumFlagOperationStyle GetEnumHasFlagStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static ConfigureAwaitStyle GetConfigureAwaitStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static EmptyStringStyle GetEmptyStringStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static NullCheckStyle GetNullCheckStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static ConditionalExpressionParenthesesStyle GetConditionalExpressionParenthesesStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static ObjectCreationParenthesesStyle GetObjectCreationParenthesesStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static AccessibilityModifierStyle GetAccessModifiersStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static TrailingCommaStyle GetTrailingCommaStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static TypeStyle GetObjectCreationTypeStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static TypeStyle GetTypeStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static Nullable`1<bool> UseCollectionExpression(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static Nullable`1<bool> UseCollectionExpression(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static TypeStyle GetArrayCreationTypeStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static InfiniteLoopStyle GetInfiniteLoopStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static InfiniteLoopStyle GetInfiniteLoopStyle(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static DocCommentSummaryStyle GetDocCommentSummaryStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static EnumFlagValueStyle GetEnumFlagValueStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static EnumFlagValueStyle GetEnumFlagValueStyle(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static BodyStyle GetBodyStyle(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static Nullable`1<bool> GetBlankLineBetweenClosingBraceAndSwitchSection(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static BlankLineStyle GetBlankLineAfterFileScopedNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static Nullable`1<bool> IsUnityCodeAnalysisEnabled(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static BlankLineBetweenSwitchSections GetBlankLineBetweenSwitchSections(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static NewLinePosition GetEqualsSignNewLinePosition(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static NewLinePosition GetArrowTokenNewLinePosition(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static NewLinePosition GetConditionalExpressionNewLinePosition(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static NewLinePosition GetBinaryExpressionNewLinePosition(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static NewLinePosition GetNullConditionalOperatorNewLinePosition(SyntaxNodeAnalysisContext context, NewLinePosition defaultValue);
    private static bool TryGetNewLinePosition(AnalyzerConfigOptions configOptions, ConfigOptionDescriptor option, NewLinePosition& newLinePosition);
}
[ExtensionAttribute]
internal static class Roslynator.CSharp.CommonCSharpExtensions : object {
    [ExtensionAttribute]
public static bool SupportsCollectionExpression(CSharpCompilation compilation);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.CSharp.IndentationAnalysis : object {
    private Nullable`1<int> _indentSize;
    private Nullable`1<SyntaxTrivia> _indentStep;
    [CompilerGeneratedAttribute]
private SyntaxTrivia <Indentation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<IndentStyle> <IndentStyle>k__BackingField;
    public SyntaxTrivia Indentation { get; }
    public Nullable`1<IndentStyle> IndentStyle { get; }
    public int IndentSize { get; }
    public int IndentationLength { get; }
    public int IncreasedIndentationLength { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private IndentationAnalysis(SyntaxTrivia indentation, Nullable`1<IndentStyle> indentStyle, Nullable`1<int> indentSize, Nullable`1<SyntaxTrivia> indentStep);
    [CompilerGeneratedAttribute]
public SyntaxTrivia get_Indentation();
    [CompilerGeneratedAttribute]
public Nullable`1<IndentStyle> get_IndentStyle();
    public int get_IndentSize();
    public int get_IndentationLength();
    public int get_IncreasedIndentationLength();
    private string get_DebuggerDisplay();
    public static IndentationAnalysis Create(SyntaxNode node, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    public string GetIncreasedIndentation();
    public SyntaxTrivia GetIncreasedIndentationTrivia();
    public SyntaxTriviaList GetIncreasedIndentationTriviaList();
    public string GetSingleIndentation();
    private static ValueTuple`3<SyntaxTrivia, SyntaxTrivia, bool> DetermineSingleIndentation(SyntaxNode node, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private string <GetSingleIndentation>g__GetSpaces|21_0();
    [CompilerGeneratedAttribute]
internal static SyntaxTrivia <DetermineSingleIndentation>g__DetermineIndentationSize|22_0(CompilationUnitSyntax compilationUnit, <>c__DisplayClass22_0& );
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<SyntaxTrivia, SyntaxTrivia> <DetermineSingleIndentation>g__GetIndentationSize|22_1(SyntaxNodeOrToken nodeOrToken1, SyntaxNodeOrToken nodeOrToken2, <>c__DisplayClass22_0& );
    [CompilerGeneratedAttribute]
internal static StatementSyntax <DetermineSingleIndentation>g__GetContainedStatement|22_2(StatementSyntax statement);
}
internal static class Roslynator.CSharp.SyntaxTriviaAnalysis : object {
    public static bool IsExteriorTriviaEmptyOrWhitespace(SyntaxNode node);
    public static bool IsExteriorTriviaEmptyOrWhitespace(SyntaxToken token);
    public static SyntaxTrivia DetermineEndOfLine(SyntaxNodeOrToken nodeOrToken, Nullable`1<SyntaxTrivia> defaultValue);
    public static SyntaxTrivia DetermineEndOfLine(SyntaxNode node, Nullable`1<SyntaxTrivia> defaultValue);
    public static SyntaxTrivia DetermineEndOfLine(SyntaxToken token, Nullable`1<SyntaxTrivia> defaultValue);
    private static SyntaxTrivia FindEndOfLine(SyntaxToken token);
    public static IndentationAnalysis AnalyzeIndentation(SyntaxNode node, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    public static SyntaxTrivia DetermineIndentation(SyntaxNodeOrToken nodeOrToken, CancellationToken cancellationToken);
    public static string GetIncreasedIndentation(SyntaxNode node, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    public static SyntaxTrivia GetIncreasedIndentationTrivia(SyntaxNode node, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    public static SyntaxTriviaList GetIncreasedIndentationTriviaList(SyntaxNode node, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Roslynator.CSharp.SyntaxTriviaAnalysis/<FindIndentations>d__11")]
public static IEnumerable`1<IndentationInfo> FindIndentations(SyntaxNode node, TextSpan span);
    public static TNode SetIndentation(TNode expression, SyntaxNode containingDeclaration, AnalyzerConfigOptions configOptions, int increaseCount);
    [CompilerGeneratedAttribute]
internal static bool <DetermineIndentation>g__IsMemberDeclarationOrStatementOrAccessorDeclaration|7_0(SyntaxNode node);
}
internal class Roslynator.CSharp.SyntaxWalkers.AwaitExpressionWalker : BaseCSharpSyntaxWalker {
    [ThreadStaticAttribute]
private static AwaitExpressionWalker _cachedInstance;
    private bool _shouldVisit;
    [CompilerGeneratedAttribute]
private HashSet`1<AwaitExpressionSyntax> <AwaitExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopOnFirstAwaitExpression>k__BackingField;
    public HashSet`1<AwaitExpressionSyntax> AwaitExpressions { get; }
    private bool StopOnFirstAwaitExpression { get; private set; }
    protected bool ShouldVisit { get; }
    [CompilerGeneratedAttribute]
public HashSet`1<AwaitExpressionSyntax> get_AwaitExpressions();
    [CompilerGeneratedAttribute]
private bool get_StopOnFirstAwaitExpression();
    [CompilerGeneratedAttribute]
private void set_StopOnFirstAwaitExpression(bool value);
    protected virtual bool get_ShouldVisit();
    public void Reset();
    public static bool ContainsAwaitExpression(ExpressionSyntax expression);
    public void VisitStatements(SyntaxList`1<StatementSyntax> statements, StatementSyntax lastStatement);
    public virtual void VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual void VisitReturnStatement(ReturnStatementSyntax node);
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node);
    public static AwaitExpressionWalker GetInstance();
    public static void Free(AwaitExpressionWalker walker);
}
[IsReadOnlyAttribute]
internal class Roslynator.CSharp.TriviaBlock : ValueType {
    [CompilerGeneratedAttribute]
private TriviaBlockKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNodeOrToken <First>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNodeOrToken <Second>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsSingleLineComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsDocumentationComment>k__BackingField;
    public TriviaBlockKind Kind { get; }
    internal int Position { get; }
    public SyntaxNodeOrToken First { get; }
    public SyntaxNodeOrToken Second { get; }
    public SyntaxNodeOrToken FirstOrSecond { get; }
    public bool Success { get; }
    public bool ContainsComment { get; }
    public bool ContainsSingleLineComment { get; }
    public bool ContainsDocumentationComment { get; }
    public bool IsWrapped { get; }
    private TriviaBlock(SyntaxNodeOrToken first, SyntaxNodeOrToken second, TriviaBlockKind kind, int position, bool singleLineComment, bool documentationComment);
    [CompilerGeneratedAttribute]
public TriviaBlockKind get_Kind();
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
public SyntaxNodeOrToken get_First();
    [CompilerGeneratedAttribute]
public SyntaxNodeOrToken get_Second();
    public SyntaxNodeOrToken get_FirstOrSecond();
    public bool get_Success();
    public bool get_ContainsComment();
    [CompilerGeneratedAttribute]
public bool get_ContainsSingleLineComment();
    [CompilerGeneratedAttribute]
public bool get_ContainsDocumentationComment();
    public bool get_IsWrapped();
    public Location GetLocation();
    public TriviaBlockReader CreateReader();
    public static TriviaBlock FromLeading(SyntaxNodeOrToken nodeOrToken);
    public static TriviaBlock FromTrailing(SyntaxNodeOrToken nodeOrToken);
    public static TriviaBlock FromSurrounding(SyntaxToken token, SyntaxNode nextNode, NewLinePosition newLinePosition);
    public static TriviaBlock FromBetween(SyntaxNodeOrToken first, SyntaxNodeOrToken second);
    private static TriviaBlock Analyze(SyntaxNodeOrToken first, SyntaxNodeOrToken second, int position);
    [CompilerGeneratedAttribute]
internal static TriviaBlockKind <Analyze>g__GetKind|33_0(State state, State triviaBeforeComment);
}
internal enum Roslynator.CSharp.TriviaBlockKind : Enum {
    public int value__;
    public static TriviaBlockKind Unknown;
    public static TriviaBlockKind NoNewLine;
    public static TriviaBlockKind NewLine;
    public static TriviaBlockKind BlankLine;
}
internal class Roslynator.CSharp.TriviaBlockReader : ValueType {
    private bool _isSecondTrivia;
    private int _index;
    private SyntaxTriviaList _list;
    private SyntaxNodeOrToken _second;
    public SyntaxTrivia Current { get; }
    internal TriviaBlockReader(SyntaxNodeOrToken first, SyntaxNodeOrToken second);
    [IsReadOnlyAttribute]
public SyntaxTrivia get_Current();
    public SyntaxTrivia ReadLine();
    public void ReadTo(int position);
    public bool ReadWhiteSpaceTrivia();
    public bool Read(SyntaxKind kind);
    public void ReadWhiteSpace();
    public void ReadBlankLines();
    [IsReadOnlyAttribute]
public SyntaxTrivia Peek(int offset);
    private bool MoveNext();
}
public static class Roslynator.DiagnosticCategories : object {
    internal static string Roslynator;
    [ObsoleteAttribute]
internal static string AnalyzerOption;
    [ObsoleteAttribute]
public static string Design;
    [ObsoleteAttribute]
public static string FadeOut;
    [ObsoleteAttribute]
public static string Formatting;
    [ObsoleteAttribute]
public static string General;
    [ObsoleteAttribute]
public static string Maintainability;
    [ObsoleteAttribute]
public static string Naming;
    [ObsoleteAttribute]
public static string Performance;
    [ObsoleteAttribute]
public static string Readability;
    [ObsoleteAttribute]
public static string Redundancy;
    [ObsoleteAttribute]
public static string Reliability;
    [ObsoleteAttribute]
public static string Simplification;
    [ObsoleteAttribute]
public static string Style;
    [ObsoleteAttribute]
public static string Usage;
    [ObsoleteAttribute]
public static string ErrorFix;
}
internal static class Roslynator.DiagnosticDescriptorFactory : object {
    public static DiagnosticDescriptor Create(string id, string title, string messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, string description, string helpLinkUri, String[] customTags);
    public static DiagnosticDescriptor CreateFadeOut(DiagnosticDescriptor descriptor);
}
internal static class Roslynator.DiagnosticHelpers : object {
    public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, Object[] messageArgs);
    public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, Object[] messageArgs);
    public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, Object[] messageArgs);
    public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, Object[] messageArgs);
    public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, Object[] messageArgs);
    public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    private static void ReportDiagnostic(SymbolAnalysisContext context, Diagnostic diagnostic);
    public static void ReportDiagnosticIfEffective(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, Object[] messageArgs);
    public static void ReportDiagnosticIfEffective(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static void ReportToken(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, Object[] messageArgs);
    public static void ReportNode(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, Diagnostic diagnostic);
    public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    private static void ReportDiagnostic(SyntaxTreeAnalysisContext context, Diagnostic diagnostic);
    [ConditionalAttribute("DEBUG")]
private static void VerifyDiagnostic(Diagnostic diagnostic);
    internal static bool IsAnyEffective(SyntaxNodeAnalysisContext context, ImmutableArray`1<DiagnosticDescriptor> descriptors);
    internal static bool IsAnyEffective(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor1, DiagnosticDescriptor descriptor2);
    internal static bool IsAnyEffective(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor1, DiagnosticDescriptor descriptor2, DiagnosticDescriptor descriptor3);
    internal static bool IsAnyEffective(Compilation compilation, ImmutableArray`1<DiagnosticDescriptor> descriptors);
    internal static bool IsAnyEffective(Compilation compilation, DiagnosticDescriptor descriptor1, DiagnosticDescriptor descriptor2);
    internal static bool IsAnyEffective(Compilation compilation, DiagnosticDescriptor descriptor1, DiagnosticDescriptor descriptor2, DiagnosticDescriptor descriptor3);
    private static Diagnostic CreateDiagnostic(DiagnosticDescriptor descriptor, Location location, Object[] messageArgs);
    private static Diagnostic CreateDiagnostic(DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, Object[] messageArgs);
    private static Diagnostic CreateDiagnostic(DiagnosticDescriptor descriptor, Location location, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    private static Diagnostic CreateDiagnostic(DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    [ConditionalAttribute("DEBUG")]
private static void VerifyMessageArgs(DiagnosticDescriptor descriptor, Object[] messageArgs);
}
internal static class Roslynator.DiagnosticProperties : object {
    public static ImmutableDictionary`2<string, string> NewLinePosition_After;
    private static ImmutableDictionary`2<string, string> _analyzerOption_Invert;
    private static string AnalyzerOptionKey;
    private static string InvertValue;
    public static ImmutableDictionary`2<string, string> AnalyzerOption_Invert { get; }
    private static DiagnosticProperties();
    public static ImmutableDictionary`2<string, string> get_AnalyzerOption_Invert();
    public static bool ContainsInvert(ImmutableDictionary`2<string, string> properties);
}
internal static class Roslynator.EquivalenceKey : object {
    private static string Prefix;
    private static string Separator;
    public static string Create(RefactoringDescriptor descriptor, string additionalKey1, string additionalKey2);
    public static string Create(Diagnostic diagnostic, string additionalKey1, string additionalKey2);
    public static string Create(string key, string additionalKey1, string additionalKey2);
    internal static string Join(string value1, string value2);
}
[ExtensionAttribute]
internal static class Roslynator.HashSetExtensions : object {
    [ExtensionAttribute]
public static bool ContainsAny(HashSet`1<T> items, T item1, T item2);
    [ExtensionAttribute]
public static bool ContainsAny(HashSet`1<T> items, T item1, T item2, T item3);
    [ExtensionAttribute]
public static bool ContainsAny(HashSet`1<T> items, T item1, T item2, T item3, T item4);
}
public enum Roslynator.IndentStyle : Enum {
    public int value__;
    public static IndentStyle Space;
    public static IndentStyle Tab;
}
public class Roslynator.LegacyConfigOptionDescriptor : ConfigOptionDescriptor {
    public LegacyConfigOptionDescriptor(string key, string defaultValue, string defaultValuePlaceholder, string description);
}
public static class Roslynator.LegacyConfigOptions : object {
    public static LegacyConfigOptionDescriptor MaxLineLength;
    public static LegacyConfigOptionDescriptor PrefixFieldIdentifierWithUnderscore;
    public static LegacyConfigOptionDescriptor AddNewLineAfterBinaryOperatorInsteadOfBeforeIt;
    public static LegacyConfigOptionDescriptor AddNewLineAfterConditionalOperatorInsteadOfBeforeIt;
    public static LegacyConfigOptionDescriptor AddNewLineAfterEqualsSignInsteadOfBeforeIt;
    public static LegacyConfigOptionDescriptor AddNewLineAfterExpressionBodyArrowInsteadOfBeforeIt;
    public static LegacyConfigOptionDescriptor ConvertBitwiseOperationToHasFlagCall;
    public static LegacyConfigOptionDescriptor ConvertExpressionBodyToBlockBody;
    public static LegacyConfigOptionDescriptor ConvertExpressionBodyToBlockBodyWhenDeclarationIsMultiLine;
    public static LegacyConfigOptionDescriptor ConvertExpressionBodyToBlockBodyWhenExpressionIsMultiLine;
    public static LegacyConfigOptionDescriptor ConvertMethodGroupToAnonymousFunction;
    public static LegacyConfigOptionDescriptor DoNotRenamePrivateStaticFieldToCamelCaseWithUnderscore;
    public static LegacyConfigOptionDescriptor RemoveAccessibilityModifiers;
    public static LegacyConfigOptionDescriptor RemoveCallToConfigureAwait;
    public static LegacyConfigOptionDescriptor RemoveEmptyLineBetweenClosingBraceAndSwitchSection;
    public static LegacyConfigOptionDescriptor RemoveEmptyLineBetweenSingleLineAccessors;
    public static LegacyConfigOptionDescriptor RemoveEmptyLineBetweenUsingDirectivesWithDifferentRootNamespace;
    public static LegacyConfigOptionDescriptor RemoveNewLineBetweenClosingBraceAndWhileKeyword;
    public static LegacyConfigOptionDescriptor RemoveParenthesesFromConditionOfConditionalExpressionWhenExpressionIsSingleToken;
    public static LegacyConfigOptionDescriptor RemoveParenthesesWhenCreatingNewObject;
    public static LegacyConfigOptionDescriptor SuppressUnityScriptMethods;
    public static LegacyConfigOptionDescriptor UseComparisonInsteadPatternMatchingToCheckForNull;
    public static LegacyConfigOptionDescriptor UseImplicitlyTypedArray;
    public static LegacyConfigOptionDescriptor UseImplicitlyTypedArrayWhenTypeIsObvious;
    public static LegacyConfigOptionDescriptor UseStringEmptyInsteadOfEmptyStringLiteral;
    private static LegacyConfigOptions();
}
public abstract class Roslynator.OptionSet`1 : object {
    [CompilerGeneratedAttribute]
private HashSet`1<T> <Disabled>k__BackingField;
    public HashSet`1<T> Disabled { get; }
    [CompilerGeneratedAttribute]
public HashSet`1<T> get_Disabled();
    public void Reset(CodeAnalysisConfig configuration);
    public void Reset(CodeAnalysisConfig configuration1, CodeAnalysisConfig configuration2);
    protected abstract virtual void SetValues(CodeAnalysisConfig configuration);
    public bool IsEnabled(T item);
    public bool IsAnyEnabled(T item, T item2);
    public bool IsAnyEnabled(T item, T item2, T item3);
    public bool IsAnyEnabled(T item, T item2, T item3, T item4);
    public bool IsAnyEnabled(T item, T item2, T item3, T item4, T item5);
    public bool IsAnyEnabled(T item, T item2, T item3, T item4, T item5, T item6);
    public void Disable(T item);
    public void Enable(T item);
    public void Set(T item, bool isEnabled);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.RefactoringDescriptor : ValueType {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabledByDefault>k__BackingField;
    public string Id { get; }
    public string OptionKey { get; }
    public bool IsEnabledByDefault { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public RefactoringDescriptor(string id, string optionKey, bool isEnabledByDefault);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_OptionKey();
    [CompilerGeneratedAttribute]
public bool get_IsEnabledByDefault();
    private string get_DebuggerDisplay();
}
internal static class Roslynator.RoslynMetadataNames : object {
    public static MetadataName Microsoft_CodeAnalysis;
    public static MetadataName Microsoft_CodeAnalysis_CodeFixes;
    public static MetadataName Microsoft_CodeAnalysis_CodeFixes_ExportCodeFixProviderAttribute;
    public static MetadataName Microsoft_CodeAnalysis_CodeRefactorings;
    public static MetadataName Microsoft_CodeAnalysis_CodeRefactorings_ExportCodeRefactoringProviderAttribute;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_CSharpExtensions;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_CSharpSyntaxNode;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_AnonymousFunctionExpressionSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_BaseExpressionColonSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_BaseTypeSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_CrefSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_ExpressionSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_InterpolatedStringContentSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_MemberCrefSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_MemberDeclarationSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_PatternSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_QueryClauseSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_SelectOrGroupClauseSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_SimpleNameSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_StatementSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_SwitchLabelSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_TypeParameterConstraintSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_TypeSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_VariableDesignationSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_XmlAttributeSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_XmlNodeSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_Syntax_CollectionElementSyntax;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_SyntaxKind;
    public static MetadataName Microsoft_CodeAnalysis_CSharpExtensions;
    public static MetadataName Microsoft_CodeAnalysis_Diagnostics;
    public static MetadataName Microsoft_CodeAnalysis_Diagnostics_DiagnosticAnalyzerAttribute;
    public static MetadataName Microsoft_CodeAnalysis_SyntaxTriviaList;
    public static MetadataName Microsoft_CodeAnalysis_Text_TextSpan;
    private static RoslynMetadataNames();
}
internal static class Roslynator.RuleSetLoader : object {
    private static RuleSet _emptyRuleSet;
    internal static string DefaultRuleSetName;
    public static RuleSet EmptyRuleSet { get; }
    public static RuleSet get_EmptyRuleSet();
    public static RuleSet Load(string path, ImmutableArray`1<string> additionalPaths);
    private static RuleSet Load(string path);
    public static RuleSet Combine(RuleSet ruleSet, RuleSet parent);
    private static bool IsStricterThan(ReportDiagnostic action1, ReportDiagnostic action2);
    [CompilerGeneratedAttribute]
internal static RuleSet <get_EmptyRuleSet>g__CreateEmptyRuleSet|3_0();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
