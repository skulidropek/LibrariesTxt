[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Flags}")]
internal class Roslynator.CSharp.BracesAnalysis : ValueType {
    [CompilerGeneratedAttribute]
private BracesAnalysisFlags <Flags>k__BackingField;
    public bool AddBraces { get; }
    public bool RemoveBraces { get; }
    internal BracesAnalysisFlags Flags { get; }
    private BracesAnalysis(BracesAnalysisFlags flags);
    public bool get_AddBraces();
    public bool get_RemoveBraces();
    [CompilerGeneratedAttribute]
internal BracesAnalysisFlags get_Flags();
    public bool Any(BracesAnalysisFlags flags);
    public static BracesAnalysis AnalyzeBraces(SwitchSectionSyntax switchSection);
    public static BracesAnalysis AnalyzeBraces(IfStatementSyntax ifStatement);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BracesAnalysis other);
    public virtual int GetHashCode();
    public static BracesAnalysis op_Implicit(BracesAnalysisFlags value);
    public static BracesAnalysisFlags op_Implicit(BracesAnalysis& value);
    public static bool op_Equality(BracesAnalysis& analysis1, BracesAnalysis& analysis2);
    public static bool op_Inequality(BracesAnalysis& analysis1, BracesAnalysis& analysis2);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeBraces>g__SupportsEmbedded|10_0(StatementSyntax statement);
}
[FlagsAttribute]
internal enum Roslynator.CSharp.BracesAnalysisFlags : Enum {
    public int value__;
    public static BracesAnalysisFlags None;
    public static BracesAnalysisFlags AddBraces;
    public static BracesAnalysisFlags RemoveBraces;
}
[FlagsAttribute]
public enum Roslynator.CSharp.CommentFilter : Enum {
    public int value__;
    public static CommentFilter None;
    public static CommentFilter SingleLine;
    public static CommentFilter MultiLine;
    public static CommentFilter NonDocumentation;
    public static CommentFilter SingleLineDocumentation;
    public static CommentFilter MultiLineDocumentation;
    public static CommentFilter Documentation;
    public static CommentFilter All;
}
internal static class Roslynator.CSharp.CompilerDiagnosticIdentifiers : object {
    public static string CS0019_OperatorCannotBeAppliedToOperands;
    public static string CS0021_CannotApplyIndexingToExpression;
    public static string CS0023_OperatorCannotBeAppliedToOperand;
    public static string CS0029_CannotImplicitlyConvertType;
    public static string CS0030_CannotConvertType;
    public static string CS0037_CannotConvertNullToTypeBecauseItIsNonNullableValueType;
    public static string CS0069_EventInInterfaceCannotHaveAddOrRemoveAccessors;
    public static string CS0077_AsOperatorMustBeUsedWithReferenceTypeOrNullableType;
    public static string CS0080_ConstraintsAreNotAllowedOnNonGenericDeclarations;
    public static string CS0101_NamespaceAlreadyContainsDefinition;
    public static string CS0102_TypeAlreadyContainsDefinition;
    public static string CS0103_NameDoesNotExistInCurrentContext;
    public static string CS0106_ModifierIsNotValidForThisItem;
    public static string CS0107_MoreThanOneProtectionModifier;
    public static string CS0108_MemberHidesInheritedMemberUseNewKeywordIfHidingWasIntended;
    public static string CS0109_MemberDoesNotHideAccessibleMember;
    public static string CS0112_StaticMemberCannotBeMarkedOverrideVirtualOrAbstract;
    public static string CS0114_MemberHidesInheritedMemberToMakeCurrentMethodOverrideThatImplementationAddOverrideKeyword;
    public static string CS0115_NoSuitableMethodFoundToOverride;
    public static string CS0119_NameIsNotValidInGivenContext;
    public static string CS0120_ObjectReferenceIsRequiredForNonStaticMember;
    public static string CS0123_NoOverloadMatchesDelegate;
    public static string CS0126_ObjectOfTypeConvertibleToTypeIsRequired;
    public static string CS0127_SinceMethodReturnsVoidReturnKeywordMustNotBeFollowedByObjectExpression;
    public static string CS0128_LocalVariableOrFunctionIsAlreadyDefinedInThisScope;
    public static string CS0131_LeftHandSideOfAssignmentMustBeVariablePropertyOrIndexer;
    public static string CS0132_StaticConstructorMustBeParameterless;
    public static string CS0133_ExpressionBeingAssignedMustBeConstant;
    public static string CS0136_LocalOrParameterCannotBeDeclaredInThisScopeBecauseThatNameIsUsedInEnclosingScopeToDefineLocalOrParameter;
    public static string CS0139_NoEnclosingLoopOutOfWhichToBreakOrContinue;
    public static string CS0152_SwitchStatementContainsMultipleCasesWithSameLabelValue;
    public static string CS0161_NotAllCodePathsReturnValue;
    public static string CS0162_UnreachableCodeDetected;
    public static string CS0163_ControlCannotFallThroughFromOneCaseLabelToAnother;
    public static string CS0164_LabelHasNotBeenReferenced;
    public static string CS0165_UseOfUnassignedLocalVariable;
    public static string CS0168_VariableIsDeclaredButNeverUsed;
    public static string CS0173_TypeOfConditionalExpressionCannotBeDetermined;
    public static string CS0177_OutParameterMustBeAssignedToBeforeControlLeavesCurrentMethod;
    public static string CS0191_ReadOnlyFieldCannotBeAssignedTo;
    public static string CS0192_ReadOnlyFieldCannotBePassedAsRefOrOutValue;
    public static string CS0201_OnlyAssignmentCallIncrementDecrementAndNewObjectExpressionsCanBeUsedAsStatement;
    public static string CS0214_PointersAndFixedSizeBuffersMayOnlyBeUsedInUnsafeContext;
    public static string CS0216_OperatorRequiresMatchingOperatorToAlsoBeDefined;
    public static string CS0219_VariableIsAssignedButItsValueIsNeverUsed;
    public static string CS0221_ConstantValueCannotBeConverted;
    public static string CS0225_ParamsParameterMustBeSingleDimensionalArray;
    public static string CS0238_MemberCannotBeSealedBecauseItIsNotOverride;
    public static string CS0246_TypeOrNamespaceNameCouldNotBeFound;
    public static string CS0260_MissingPartialModifier;
    public static string CS0262_PartialDeclarationsHaveConflictingAccessibilityModifiers;
    public static string CS0266_CannotImplicitlyConvertTypeExplicitConversionExists;
    public static string CS0267_PartialModifierCanOnlyAppearImmediatelyBeforeClassStructInterfaceOrVoid;
    public static string CS0272_PropertyOrIndexerCannotBeUsedInThisContextBecauseSetAccessorIsAccessible;
    public static string CS0275_AccessibilityModifiersMayNotBeUsedOnAccessorsInInterface;
    public static string CS0305_UsingGenericTypeRequiresNumberOfTypeArguments;
    public static string CS0401_NewConstraintMustBeLastConstraintSpecified;
    public static string CS0403_CannotConvertNullToTypeParameterBecauseItCouldBeNonNullableValueType;
    public static string CS0405_DuplicateConstraintForTypeParameter;
    public static string CS0407_MethodHasWrongReturnType;
    public static string CS0409_ConstraintClauseHasAlreadyBeenSpecified;
    public static string CS0428_CannotConvertMethodGroupToNonDelegateType;
    public static string CS0441_ClassCannotBeBothStaticAndSealed;
    public static string CS0442_AbstractPropertiesCannotHavePrivateAccessors;
    public static string CS0449_ClassOrStructConstraintMustComeBeforeAnyOtherConstraints;
    public static string CS0450_CannotSpecifyBothConstraintClassAndClassOrStructConstraint;
    public static string CS0451_NewConstraintCannotBeUsedWithStructConstraint;
    public static string CS0472_ResultOfExpressionIsAlwaysConstantSinceValueIsNeverEqualToNull;
    public static string CS0500_MemberCannotDeclareBodyBecauseItIsMarkedAbstract;
    public static string CS0501_MemberMustDeclareBodyBecauseItIsNotMarkedAbstractExternOrPartial;
    public static string CS0507_CannotChangeAccessModifiersWhenOverridingInheritedMember;
    public static string CS0508_MethodReturnTypeMustMatchOverriddenMethodReturnType;
    public static string CS0513_MemberIsAbstractButItIsContainedInNonAbstractClass;
    public static string CS0515_AccessModifiersAreNotAllowedOnStaticConstructors;
    public static string CS0524_InterfacesCannotDeclareTypes;
    public static string CS0525_InterfacesCannotContainFields;
    public static string CS0527_TypeInInterfaceListIsNotInterface;
    public static string CS0531_InterfaceMembersCannotHaveDefinition;
    public static string CS0539_ExplicitInterfaceDeclarationIsNotMemberOfInterface;
    public static string CS0541_ExplicitInterfaceDeclarationCanOnlyBeDeclaredInClassOrStruct;
    public static string CS0549_NewVirtualMemberInSealedClass;
    public static string CS0558_UserDefinedOperatorMustBeDeclaredStaticAndPublic;
    public static string CS0567_InterfacesCannotContainOperators;
    public static string CS0568_StructsCannotContainExplicitParameterlessConstructors;
    public static string CS0573_CannotHaveInstancePropertyOrFieldInitializersInStruct;
    public static string CS0574_NameOfDestructorMustMatchNameOfClass;
    public static string CS0575_OnlyClassTypesCanContainDestructors;
    public static string CS0579_DuplicateAttribute;
    public static string CS0592_AttributeIsNotValidOnThisDeclarationType;
    public static string CS0621_VirtualOrAbstractMembersCannotBePrivate;
    public static string CS0628_NewProtectedMemberDeclaredInSealedClass;
    public static string CS0659_TypeOverridesObjectEqualsButDoesNotOverrideObjectGetHashCode;
    public static string CS0660_TypeDefinesEqualityOperatorButDoesNotOverrideObjectEquals;
    public static string CS0661_TypeDefinesEqualityOperatorButDoesNotOverrideObjectGetHashCode;
    public static string CS0678_FieldCanNotBeBothVolatileAndReadOnly;
    public static string CS0693_TypeParameterHasSameNameAsTypeParameterFromOuterType;
    public static string CS0708_CannotDeclareInstanceMembersInStaticClass;
    public static string CS0710_StaticClassesCannotHaveInstanceConstructors;
    public static string CS0713_StaticClassCannotDeriveFromType;
    public static string CS0714_StaticClassCannotImplementInterfaces;
    public static string CS0718_StaticTypesCannotBeUsedAsTypeArguments;
    public static string CS0750_PartialMethodCannotHaveAccessModifiersOrVirtualAbstractOverrideNewSealedOrExternModifiers;
    public static string CS0751_PartialMethodMustBeDeclaredInPartialClassOrPartialStruct;
    public static string CS0753_OnlyMethodsClassesStructsOrInterfacesMayBePartial;
    public static string CS0756_PartialMethodMayNotHaveMultipleDefiningDeclarations;
    public static string CS0759_NoDefiningDeclarationFoundForImplementingDeclarationOfPartialMethod;
    public static string CS0766_PartialMethodsMustHaveVoidReturnType;
    public static string CS0815_CannotAssignMethodGroupToImplicitlyTypedVariable;
    public static string CS0819_ImplicitlyTypedVariablesCannotHaveMultipleDeclarators;
    public static string CS0822_ImplicitlyTypedVariablesCannotBeConstant;
    public static string CS1002_SemicolonExpected;
    public static string CS1003_SyntaxErrorCharExpected;
    public static string CS1004_DuplicateModifier;
    public static string CS1012_TooManyCharactersInCharacterLiteral;
    public static string CS1023_EmbeddedStatementCannotBeDeclarationOrLabeledStatement;
    public static string CS1031_TypeExpected;
    public static string CS1057_StaticClassesCannotContainProtectedMembers;
    public static string CS1061_TypeDoesNotContainDefinitionAndNoExtensionMethodCouldBeFound;
    public static string CS1100_MethodHasParameterModifierThisWhichIsNotOnFirstParameter;
    public static string CS1105_ExtensionMethodMustBeStatic;
    public static string CS1106_ExtensionMethodMustBeDefinedInNonGenericStaticClass;
    public static string CS1503_CannotConvertArgumentType;
    public static string CS1522_EmptySwitchBlock;
    public static string CS1526_NewExpressionRequiresParenthesesOrBracketsOrBracesAfterType;
    public static string CS1527_ElementsDefinedInNamespaceCannotBeExplicitlyDeclaredAsPrivateProtectedOrProtectedInternal;
    public static string CS1591_MissingXmlCommentForPubliclyVisibleTypeOrMember;
    public static string CS1597_SemicolonAfterMethodOrAccessorBlockIsNotValid;
    public static string CS1609_ModifiersCannotBePlacedOnEventAccessorDeclarations;
    public static string CS1615_ArgumentShouldNotBePassedWithRefOrOutKeyword;
    public static string CS1620_ArgumentMustBePassedWithRefOrOutKeyword;
    public static string CS1621_YieldStatementCannotBeUsedInsideAnonymousMethodOrLambdaExpression;
    public static string CS1622_CannotReturnValueFromIterator;
    public static string CS1623_IteratorsCannotHaveRefOrOutParameters;
    public static string CS1624_BodyCannotBeIteratorBlockBecauseTypeIsNotIteratorInterfaceType;
    public static string CS1643_NotAllCodePathsReturnValueInAnonymousFunction;
    public static string CS1674_TypeUsedInUsingStatementMustBeImplicitlyConvertibleToIDisposable;
    public static string CS1689_AttributeIsOnlyValidOnMethodsOrAttributeClasses;
    public static string CS1715_MemberTypeMustMatchOverriddenMemberType;
    public static string CS1717_AssignmentMadeToSameVariable;
    public static string CS1722_BaseClassMustComeBeforeAnyInterface;
    public static string CS1737_OptionalParametersMustAppearAfterAllRequiredParameters;
    public static string CS1741_RefOrOutParameterCannotHaveDefaultValue;
    public static string CS1743_CannotSpecifyDefaultValueForThisParameter;
    public static string CS1750_ValueCannotBeUsedAsDefaultParameter;
    public static string CS1751_CannotSpecifyDefaultValueForParameterArray;
    public static string CS1955_NonInvocableMemberCannotBeUsedLikeMethod;
    public static string CS1983_ReturnTypeOfAsyncMethodMustBeVoidOrTaskOrTaskOfT;
    public static string CS1988_AsyncMethodsCannotHaveRefOrOutParameters;
    public static string CS1994_AsyncModifierCanOnlyBeUsedInMethodsThatHaveBody;
    public static string CS1997_SinceMethodIsAsyncMethodThatReturnsTaskReturnKeywordMustNotBeFollowedByObjectExpression;
    public static string CS3000_MethodsWithVariableArgumentsAreNotCLSCompliant;
    public static string CS3001_ArgumentTypeIsNotCLSCompliant;
    public static string CS3002_ReturnTypeIsNotCLSCompliant;
    public static string CS3003_TypeOfVariableIsNotCLSCompliant;
    public static string CS3005_IdentifierDifferingOnlyInCaseIsNotCLSCompliant;
    public static string CS3006_OverloadedMethodDifferingOnlyInRefOrOutOrInArrayRankIsNotCLSCompliant;
    public static string CS3007_OverloadedMethodDifferingOnlyByUnnamedArrayTypesIsNotCLSCompliant;
    public static string CS3008_IdentifierIsNotCLSCompliant;
    public static string CS3009_BaseTypeIsNotCLSCompliant;
    public static string CS3016_ArraysAsAttributeArgumentsIsNotCLSCompliant;
    public static string CS3024_ConstraintTypeIsNotCLSCompliant;
    public static string CS3027_TypeIsNotCLSCompliantBecauseBaseInterfaceIsNotCLSCompliant;
    public static string CS7036_ThereIsNoArgumentGivenThatCorrespondsToRequiredFormalParameter;
    public static string CS8050_OnlyAutoImplementedPropertiesCanHaveInitializers;
    public static string CS8070_ControlCannotFallOutOfSwitchFromFinalCaseLabel;
    public static string CS8112_LocalFunctionMustAlwaysHaveBody;
    public static string CS8139_CannotChangeTupleElementNameWhenOverridingInheritedMember;
    public static string CS8340_InstanceFieldsOfReadOnlyStructsMustBeReadOnly;
    public static string CS8403_MethodWithIteratorBlockMustBeAsyncToReturnIAsyncEnumerableOfT;
    public static string CS8600_ConvertingNullLiteralOrPossibleNullValueToNonNullableType;
    public static string CS8602_DereferenceOfPossiblyNullReference;
    public static string CS8604_PossibleNullReferenceArgumentForParameter;
    public static string CS8610_NullabilityOfReferenceTypesInTypeOfParameterDoesNotMatchOverriddenMember;
    public static string CS8618_NonNullableMemberIsUninitialized;
    public static string CS8625_CannotConvertNullLiteralToNonNullableReferenceType;
    public static string CS8632_AnnotationForNullableReferenceTypesShouldOnlyBeUsedWithinNullableAnnotationsContext;
    public static string CS8765_NullabilityOfTypeOfParameterDoesNotMatchOverriddenMember;
    public static string CS8767_NullabilityDoesNotMatchImplementedMember;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Roslynator.CSharp.CSharpExtensions : object {
    [ExtensionAttribute]
internal static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, LocalFunctionStatementSyntax localFunction, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetSymbol(SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetSymbol(SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetSymbol(SemanticModel semanticModel, CrefSyntax cref, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetSymbol(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetSymbol(SemanticModel semanticModel, OrderingSyntax ordering, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetSymbol(SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol GetTypeSymbol(SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol GetTypeSymbol(SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol GetTypeSymbol(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol GetTypeSymbol(SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsExplicitConversion(SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destinationType, bool isExplicitInSource);
    [ExtensionAttribute]
internal static bool IsImplicitConversion(SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destinationType, bool isExplicitInSource);
    [ExtensionAttribute]
public static IParameterSymbol DetermineParameter(SemanticModel semanticModel, ArgumentSyntax argument, bool allowParams, bool allowCandidate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IParameterSymbol DetermineParameter(SemanticModel semanticModel, AttributeArgumentSyntax attributeArgument, bool allowParams, bool allowCandidate, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsDefaultValue(SemanticModel semanticModel, ITypeSymbol typeSymbol, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ExtensionMethodSymbolInfo GetExtensionMethodInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ExtensionMethodSymbolInfo GetReducedExtensionMethodInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetMethodSymbol(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static MethodDeclarationSyntax GetOtherPart(SemanticModel semanticModel, MethodDeclarationSyntax methodDeclaration, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool HasConstantValue(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Roslynator.CSharp.CSharpFactory : object {
    public static SyntaxTrivia EmptyWhitespace();
    public static SyntaxTrivia NewLine();
    internal static SyntaxToken OpenParenToken();
    internal static SyntaxToken CloseParenToken();
    internal static SyntaxToken OpenBraceToken();
    internal static SyntaxToken CloseBraceToken();
    internal static SyntaxToken OpenBracketToken();
    internal static SyntaxToken CloseBracketToken();
    internal static SyntaxToken SemicolonToken();
    internal static SyntaxToken CommaToken();
    public static PredefinedTypeSyntax PredefinedBoolType();
    public static PredefinedTypeSyntax PredefinedByteType();
    public static PredefinedTypeSyntax PredefinedSByteType();
    public static PredefinedTypeSyntax PredefinedIntType();
    public static PredefinedTypeSyntax PredefinedUIntType();
    public static PredefinedTypeSyntax PredefinedShortType();
    public static PredefinedTypeSyntax PredefinedUShortType();
    public static PredefinedTypeSyntax PredefinedLongType();
    public static PredefinedTypeSyntax PredefinedULongType();
    public static PredefinedTypeSyntax PredefinedFloatType();
    public static PredefinedTypeSyntax PredefinedDoubleType();
    public static PredefinedTypeSyntax PredefinedDecimalType();
    public static PredefinedTypeSyntax PredefinedStringType();
    public static PredefinedTypeSyntax PredefinedCharType();
    public static PredefinedTypeSyntax PredefinedObjectType();
    public static PredefinedTypeSyntax VoidType();
    private static PredefinedTypeSyntax PredefinedType(SyntaxKind syntaxKind);
    public static SyntaxTokenList TokenList(Accessibility accessibility);
    public static SyntaxTokenList TokenList(SyntaxKind kind);
    public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2);
    public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    public static ArgumentListSyntax ArgumentList(ArgumentSyntax[] arguments);
    public static ArgumentListSyntax ArgumentList(ArgumentSyntax argument);
    public static BracketedArgumentListSyntax BracketedArgumentList(ArgumentSyntax[] arguments);
    public static BracketedArgumentListSyntax BracketedArgumentList(ArgumentSyntax argument);
    public static AttributeListSyntax AttributeList(AttributeSyntax attribute);
    public static AttributeListSyntax AttributeList(AttributeSyntax[] attributes);
    public static AttributeArgumentListSyntax AttributeArgumentList(AttributeArgumentSyntax[] attributeArguments);
    public static AttributeArgumentListSyntax AttributeArgumentList(AttributeArgumentSyntax attributeArgument);
    public static AccessorListSyntax AccessorList(AccessorDeclarationSyntax[] accessors);
    public static AccessorListSyntax AccessorList(AccessorDeclarationSyntax accessor);
    public static ParameterListSyntax ParameterList(ParameterSyntax parameter);
    public static ParameterListSyntax ParameterList(ParameterSyntax[] parameters);
    public static BracketedParameterListSyntax BracketedParameterList(ParameterSyntax parameter);
    public static BracketedParameterListSyntax BracketedParameterList(ParameterSyntax[] parameters);
    public static TypeArgumentListSyntax TypeArgumentList(TypeSyntax argument);
    public static TypeArgumentListSyntax TypeArgumentList(TypeSyntax[] arguments);
    public static TypeParameterListSyntax TypeParameterList(TypeParameterSyntax parameter);
    public static TypeParameterListSyntax TypeParameterList(TypeParameterSyntax[] parameters);
    public static BaseListSyntax BaseList(BaseTypeSyntax type);
    public static BaseListSyntax BaseList(BaseTypeSyntax[] types);
    public static BaseListSyntax BaseList(SyntaxToken colonToken, BaseTypeSyntax baseType);
    public static BaseListSyntax BaseList(SyntaxToken colonToken, BaseTypeSyntax[] types);
    internal static NamespaceDeclarationSyntax NamespaceDeclaration(string name, MemberDeclarationSyntax member);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, MemberDeclarationSyntax member);
    internal static NamespaceDeclarationSyntax NamespaceDeclaration(string name, SyntaxList`1<MemberDeclarationSyntax> members);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList`1<MemberDeclarationSyntax> members);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList`1<MemberDeclarationSyntax> members);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList`1<MemberDeclarationSyntax> members);
    internal static ClassDeclarationSyntax ClassDeclaration(StructDeclarationSyntax structDeclaration);
    public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList`1<MemberDeclarationSyntax> members);
    public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList`1<MemberDeclarationSyntax> members);
    internal static StructDeclarationSyntax StructDeclaration(ClassDeclarationSyntax classDeclaration);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList`1<MemberDeclarationSyntax> members);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList`1<MemberDeclarationSyntax> members);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, ExpressionSyntax value);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, ExpressionSyntax value);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, EqualsValueClauseSyntax value);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, EqualsValueClauseSyntax value);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, ExpressionSyntax value);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier);
    public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, AccessorListSyntax accessorList);
    public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, string identifier, ParameterListSyntax parameterList);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body);
    public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body);
    public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList, ExpressionSyntax value);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ArrowExpressionClauseSyntax expressionBody);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax AutoGetAccessorDeclaration(SyntaxTokenList modifiers);
    public static AccessorDeclarationSyntax AutoSetAccessorDeclaration(SyntaxTokenList modifiers);
    public static AccessorDeclarationSyntax AutoInitAccessorDeclaration(SyntaxTokenList modifiers);
    internal static AccessorDeclarationSyntax AutoAccessorDeclaration(SyntaxKind kind, SyntaxTokenList modifiers);
    private static SyntaxKind AccessorDeclarationKeywordKind(SyntaxKind kind);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, ExpressionSyntax value);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static YieldStatementSyntax YieldReturnStatement(ExpressionSyntax expression);
    public static YieldStatementSyntax YieldBreakStatement();
    public static TryStatementSyntax TryStatement(BlockSyntax block, CatchClauseSyntax catch, FinallyClauseSyntax finally);
    public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BlockSyntax Block(StatementSyntax statement);
    public static BlockSyntax Block(SyntaxToken openBrace, StatementSyntax statement, SyntaxToken closeBrace);
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    internal static ThrowStatementSyntax ThrowNewStatement(TypeSyntax exceptionType);
    public static ForStatementSyntax ForStatement(VariableDeclarationSyntax declaration, ExpressionSyntax condition, ExpressionSyntax incrementor, StatementSyntax statement);
    public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand);
    public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand);
    public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PostfixUnaryExpressionSyntax SuppressNullableWarningExpression(ExpressionSyntax operand);
    public static PostfixUnaryExpressionSyntax SuppressNullableWarningExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax CoalesceAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax CoalesceAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static LiteralExpressionSyntax StringLiteralExpression(string value);
    public static LiteralExpressionSyntax CharacterLiteralExpression(char value);
    public static LiteralExpressionSyntax NumericLiteralExpression(int value);
    public static LiteralExpressionSyntax NumericLiteralExpression(UInt32 value);
    public static LiteralExpressionSyntax NumericLiteralExpression(sbyte value);
    public static LiteralExpressionSyntax NumericLiteralExpression(decimal value);
    public static LiteralExpressionSyntax NumericLiteralExpression(double value);
    public static LiteralExpressionSyntax NumericLiteralExpression(float value);
    public static LiteralExpressionSyntax NumericLiteralExpression(long value);
    public static LiteralExpressionSyntax NumericLiteralExpression(ulong value);
    internal static LiteralExpressionSyntax NumericLiteralExpression(ulong value, SpecialType numericType);
    public static LiteralExpressionSyntax TrueLiteralExpression();
    public static LiteralExpressionSyntax FalseLiteralExpression();
    public static LiteralExpressionSyntax BooleanLiteralExpression(bool value);
    public static LiteralExpressionSyntax NullLiteralExpression();
    public static LiteralExpressionSyntax DefaultLiteralExpression();
    public static LiteralExpressionSyntax LiteralExpression(object value);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList);
    public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name);
    public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentSyntax argument);
    public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentListSyntax argumentList);
    public static InvocationExpressionSyntax NameOfExpression(string identifier);
    public static InvocationExpressionSyntax NameOfExpression(ExpressionSyntax expression);
    public static InitializerExpressionSyntax ArrayInitializerExpression(SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public static InitializerExpressionSyntax ArrayInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static InitializerExpressionSyntax CollectionInitializerExpression(SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public static InitializerExpressionSyntax CollectionInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static InitializerExpressionSyntax ComplexElementInitializerExpression(SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public static InitializerExpressionSyntax ComplexElementInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static InitializerExpressionSyntax ObjectInitializerExpression(SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public static InitializerExpressionSyntax ObjectInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static CheckedExpressionSyntax CheckedExpression(ExpressionSyntax expression);
    public static CheckedExpressionSyntax CheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static CheckedExpressionSyntax UncheckedExpression(ExpressionSyntax expression);
    public static CheckedExpressionSyntax UncheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    internal static ThrowExpressionSyntax ThrowNewExpression(TypeSyntax exceptionType);
    public static IdentifierNameSyntax VarType();
    public static GenericNameSyntax GenericName(string identifier, TypeSyntax typeArgument);
    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeSyntax typeArgument);
    public static VariableDeclaratorSyntax VariableDeclarator(string identifier, EqualsValueClauseSyntax initializer);
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, string identifier, ExpressionSyntax value);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, VariableDeclaratorSyntax variable);
    public static UsingDirectiveSyntax UsingStaticDirective(NameSyntax name);
    public static UsingDirectiveSyntax UsingStaticDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameSyntax name, SyntaxToken semicolonToken);
    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentSyntax argument);
    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, ExpressionSyntax expression);
    public static AttributeArgumentSyntax AttributeArgument(NameColonSyntax nameColon, ExpressionSyntax expression);
    public static ArgumentSyntax Argument(NameColonSyntax nameColon, ExpressionSyntax expression);
    public static ParameterSyntax Parameter(TypeSyntax type, string identifier, ExpressionSyntax default);
    public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax default);
    public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax default);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name, TypeParameterConstraintSyntax typeParameterConstraint);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax identifierName, TypeParameterConstraintSyntax typeParameterConstraint);
    public static ClassOrStructConstraintSyntax ClassConstraint();
    public static ClassOrStructConstraintSyntax StructConstraint();
    public static ConstructorInitializerSyntax BaseConstructorInitializer(ArgumentListSyntax argumentList);
    public static ConstructorInitializerSyntax BaseConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList);
    public static ConstructorInitializerSyntax ThisConstructorInitializer(ArgumentListSyntax argumentList);
    public static ConstructorInitializerSyntax ThisConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList);
    public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, StatementSyntax statement);
    public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, SyntaxList`1<StatementSyntax> statements);
    public static SwitchSectionSyntax SwitchSection(SyntaxList`1<SwitchLabelSyntax> switchLabels, StatementSyntax statement);
    public static SwitchSectionSyntax DefaultSwitchSection(StatementSyntax statement);
    public static SwitchSectionSyntax DefaultSwitchSection(SyntaxList`1<StatementSyntax> statements);
    public static CompilationUnitSyntax CompilationUnit(MemberDeclarationSyntax member);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList`1<UsingDirectiveSyntax> usings, MemberDeclarationSyntax member);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<MemberDeclarationSyntax> members);
    internal static SyntaxList`1<UsingDirectiveSyntax> UsingDirectives(string name);
    internal static SyntaxList`1<UsingDirectiveSyntax> UsingDirectives(String[] names);
    public static UnaryPatternSyntax NotPattern(PatternSyntax pattern);
    internal static bool AreEquivalent(SyntaxNode node1, SyntaxNode node2, bool topLevel);
    internal static bool AreEquivalent(SyntaxNode node1, SyntaxNode node2, SyntaxNode node3, bool topLevel);
}
public static class Roslynator.CSharp.CSharpFacts : object {
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<SyntaxKind> <AssignmentExpressionKinds>k__BackingField;
    internal static ImmutableArray`1<SyntaxKind> AssignmentExpressionKinds { get; }
    private static CSharpFacts();
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<SyntaxKind> get_AssignmentExpressionKinds();
    [NullableContextAttribute("1")]
internal static string GetTitle(SyntaxNode node);
    public static bool IsCommentTrivia(SyntaxKind kind);
    public static bool CanHaveStatements(SyntaxKind kind);
    public static bool CanHaveMembers(SyntaxKind kind);
    public static bool IsFunction(SyntaxKind kind);
    public static bool IsIterationStatement(SyntaxKind kind);
    public static bool IsBooleanLiteralExpression(SyntaxKind kind);
    public static bool IsLambdaExpression(SyntaxKind kind);
    public static bool IsAnonymousFunctionExpression(SyntaxKind kind);
    public static bool IsJumpStatement(SyntaxKind kind);
    internal static bool IsJumpStatementOrYieldBreakStatement(SyntaxKind kind);
    public static bool IsIncrementOrDecrementExpression(SyntaxKind kind);
    public static bool IsCompoundAssignmentExpression(SyntaxKind kind);
    public static bool CanHaveModifiers(SyntaxKind kind);
    internal static bool CanHaveUnsafeModifier(SyntaxKind kind);
    public static bool CanHaveExpressionBody(SyntaxKind kind);
    public static bool CanHaveEmbeddedStatement(SyntaxKind kind);
    public static bool CanBeEmbeddedStatement(SyntaxKind kind);
    internal static bool IsSingleTokenExpression(SyntaxKind kind);
    public static bool IsPredefinedType(SpecialType specialType);
    public static bool IsSimpleType(SpecialType specialType);
    public static bool IsNumericType(SpecialType specialType);
    public static bool SupportsPrefixOrPostfixUnaryOperator(SpecialType specialType);
    [NullableContextAttribute("1")]
internal static string GetTitle(SyntaxKind kind);
    internal static bool ExistsImplicitNumericConversion(SpecialType from, SpecialType to);
    public static bool IsSwitchLabel(SyntaxKind kind);
    public static bool IsBooleanExpression(SyntaxKind kind);
    public static bool IsConstraint(SyntaxKind kind);
    public static bool IsLiteralExpression(SyntaxKind kind);
    public static bool IsIfElseDirective(SyntaxKind kind);
    internal static bool IsStatement(SyntaxKind kind);
    internal static SyntaxKind GetCompoundAssignmentKind(SyntaxKind binaryExpressionKind);
    internal static SyntaxKind GetCompoundAssignmentOperatorKind(SyntaxKind compoundAssignmentKind);
    internal static bool CanBeInitializerExpressionInForStatement(SyntaxKind kind);
    internal static int GetOperatorPrecedence(SyntaxKind kind);
    internal static bool CanBeVirtualDeclaration(SyntaxKind kind);
    internal static bool HasParameterList(SyntaxKind kind);
    internal static bool HasTypeParameterList(SyntaxKind kind);
}
internal enum Roslynator.CSharp.CSharpLanguageFeature : Enum {
    public int value__;
    public static CSharpLanguageFeature Unknown;
    public static CSharpLanguageFeature NameOf;
    public static CSharpLanguageFeature AsyncMain;
    public static CSharpLanguageFeature DefaultLiteral;
    public static CSharpLanguageFeature InferredTupleElementNames;
    public static CSharpLanguageFeature PatternMatchingWithGenerics;
    public static CSharpLanguageFeature NullCoalescingAssignmentOperator;
    public static CSharpLanguageFeature NotPattern;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CSharp.CSharpNameGenerator : object {
    private static NameGenerator _generator;
    private static CSharpNameGenerator();
    public static string EnsureUniqueName(string baseName, SemanticModel semanticModel, int position);
    public static string EnsureUniqueEnumMemberName(string baseName, INamedTypeSymbol enumType);
    public static string EnsureUniqueLocalName(string baseName, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public static ImmutableArray`1<string> EnsureUniqueLocalNames(string baseName, SemanticModel semanticModel, int position, int count, CancellationToken cancellationToken);
    public static string EnsureUniqueParameterName(string baseName, ISymbol containingSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static string CreateUniqueLocalName(ITypeSymbol typeSymbol, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    internal static string CreateUniqueLocalName(ITypeSymbol typeSymbol, string oldName, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    internal static string CreateUniqueParameterName(string oldName, IParameterSymbol parameterSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CSharp.CSharpOverriddenSymbolInfo : object {
    [CompilerGeneratedAttribute]
private static OverriddenSymbolInfo <Default>k__BackingField;
    private static OverriddenSymbolInfo Default { get; }
    private static CSharpOverriddenSymbolInfo();
    [CompilerGeneratedAttribute]
private static OverriddenSymbolInfo get_Default();
    public static bool CanCreate(SyntaxNode node);
    internal static OverriddenSymbolInfo Create(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static OverriddenSymbolInfo CreateImpl(MethodDeclarationSyntax methodDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static OverriddenSymbolInfo CreateImpl(BasePropertyDeclarationSyntax basePropertyDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static OverriddenSymbolInfo CreateImpl(EventDeclarationSyntax eventDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static OverriddenSymbolInfo CreateImpl(VariableDeclaratorSyntax variableDeclarator, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static OverriddenSymbolInfo CreateImpl(AccessorDeclarationSyntax accessorDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CSharp.CSharpTypeAnalysis : object {
    public static TypeAnalysis AnalyzeType(VariableDeclarationSyntax variableDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsImplicitThatCanBeExplicit(VariableDeclarationSyntax variableDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsImplicitThatCanBeExplicit(VariableDeclarationSyntax variableDeclaration, SemanticModel semanticModel, TypeAppearance typeAppearance, CancellationToken cancellationToken);
    public static bool IsExplicitThatCanBeImplicit(VariableDeclarationSyntax variableDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsExplicitThatCanBeImplicit(VariableDeclarationSyntax variableDeclaration, SemanticModel semanticModel, TypeAppearance typeAppearance, CancellationToken cancellationToken);
    public static bool IsTypeObvious(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsTypeObvious(ExpressionSyntax expression, ITypeSymbol typeSymbol, bool includeNullability, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SymbolEqualityComparer GetEqualityComparer(bool includeNullability);
    public static TypeAnalysis AnalyzeType(DeclarationExpressionSyntax declarationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsImplicitThatCanBeExplicit(DeclarationExpressionSyntax declarationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsImplicitThatCanBeExplicit(DeclarationExpressionSyntax declarationExpression, SemanticModel semanticModel, TypeAppearance typeAppearance, CancellationToken cancellationToken);
    public static bool IsExplicitThatCanBeImplicit(DeclarationExpressionSyntax declarationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsExplicitThatCanBeImplicit(TupleExpressionSyntax tupleExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsExplicitThatCanBeImplicit(TupleExpressionSyntax tupleExpression, SemanticModel semanticModel, TypeAppearance typeAppearance, CancellationToken cancellationToken);
    private static bool IsExplicitThatCanBeImplicit(TupleExpressionSyntax tupleExpression, AssignmentExpressionSyntax assignment, TypeAppearance typeAppearance, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static TypeAnalysis AnalyzeType(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
    public static TypeAnalysis AnalyzeType(ForEachVariableStatementSyntax forEachStatement, SemanticModel semanticModel);
    public static bool IsImplicitThatCanBeExplicit(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
    public static bool IsImplicitThatCanBeExplicit(ForEachVariableStatementSyntax forEachStatement, SemanticModel semanticModel);
    public static bool IsExplicitThatCanBeImplicit(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
    public static bool IsExplicitThatCanBeImplicit(ForEachVariableStatementSyntax forEachStatement, SemanticModel semanticModel);
    private static bool IsExplicitThatCanBeImplicit(TupleExpressionSyntax tupleExpression, ForEachVariableStatementSyntax forEachStatement, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
internal static bool <IsImplicitThatCanBeExplicit>g__IsLocalThatSupportsExplicitDeclaration|10_0(VariableDesignationSyntax variableDesignation, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsExplicitThatCanBeImplicit>g__AnalyzeArgument|11_0(ArgumentSyntax argument, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CSharp.CSharpUtility : object {
    public static bool IsNullableReferenceType(TypeSyntax type, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static string GetCountOrLengthPropertyName(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsNamespaceInScope(SyntaxNode node, INamespaceSymbol namespaceSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsNamespace(INamespaceSymbol namespaceSymbol, SyntaxList`1<UsingDirectiveSyntax> usings, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsNamespace(INamespaceSymbol namespaceSymbol, NameSyntax name, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsStaticClassInScope(SyntaxNode node, INamedTypeSymbol staticClassSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsEmptyStringExpression(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsNameOfExpression(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsNameOfExpression(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsStringConcatenation(BinaryExpressionSyntax addExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsStringLiteralConcatenation(BinaryExpressionSyntax binaryExpression);
    public static bool IsStringExpression(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static SyntaxToken GetIdentifier(SyntaxNode node);
    public static bool IsPartOfExpressionThatMustBeConstant(ExpressionSyntax expression);
    public static ArrowExpressionClauseSyntax GetExpressionBody(SyntaxNode node);
    public static bool IsConditionallyAccessed(SyntaxNode node);
    public static ExpressionSyntax GetTopmostExpressionInCallChain(ExpressionSyntax expression);
    internal static IFieldSymbol FindEnumDefaultField(INamedTypeSymbol enumSymbol);
    public static TypeSyntax GetTypeOrReturnType(SyntaxNode node);
    public static bool ContainsOutArgumentWithLocalOrParameter(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static SeparatedSyntaxList`1<ParameterSyntax> GetParameters(SyntaxNode declaration);
    public static BaseParameterListSyntax GetParameterList(SyntaxNode declaration);
    public static SeparatedSyntaxList`1<TypeParameterSyntax> GetTypeParameters(SyntaxNode declaration);
    public static TypeParameterListSyntax GetTypeParameterList(SyntaxNode declaration);
    public static bool IsSymbolObsolete(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CSharp.DetermineParameterHelper : object {
    public static IParameterSymbol DetermineParameter(ArgumentSyntax argument, SemanticModel semanticModel, bool allowParams, bool allowCandidate, CancellationToken cancellationToken);
    internal static IParameterSymbol DetermineParameter(ArgumentSyntax argument, SeparatedSyntaxList`1<ArgumentSyntax> arguments, ImmutableArray`1<IParameterSymbol> parameters, bool allowParams);
    public static IParameterSymbol DetermineParameter(AttributeArgumentSyntax attributeArgument, SemanticModel semanticModel, bool allowParams, bool allowCandidate, CancellationToken cancellationToken);
    internal static IParameterSymbol DetermineParameter(AttributeArgumentSyntax attributeArgument, SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments, ImmutableArray`1<IParameterSymbol> parameters, bool allowParams);
    private static ISymbol GetSymbol(SyntaxNode node, bool allowCandidate, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SymbolInfo GetSymbolInfo(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CSharp.DetermineParameterTypeHelper : object {
    public static ImmutableArray`1<ITypeSymbol> DetermineParameterTypes(ArgumentSyntax argument, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SymbolInfo GetSymbolInfo(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ITypeSymbol DetermineParameterType(ISymbol symbol, ArgumentSyntax argument, BaseArgumentListSyntax argumentList);
    private static IParameterSymbol DetermineParameterSymbol(ISymbol symbol, ArgumentSyntax argument, BaseArgumentListSyntax argumentList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.Documentation.AddBaseOrNewDocumentationCommentRewriter : AddNewDocumentationCommentRewriter {
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public SemanticModel SemanticModel { get; }
    public CancellationToken CancellationToken { get; }
    public AddBaseOrNewDocumentationCommentRewriter(SemanticModel semanticModel, DocumentationCommentGeneratorSettings settings, bool skipNamespaceDeclaration, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    protected virtual MemberDeclarationSyntax AddDocumentationComment(MemberDeclarationSyntax memberDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.Documentation.AddNewDocumentationCommentRewriter : CSharpSyntaxRewriter {
    [CompilerGeneratedAttribute]
private bool <SkipNamespaceDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentationCommentGeneratorSettings <Settings>k__BackingField;
    public bool SkipNamespaceDeclaration { get; }
    public DocumentationCommentGeneratorSettings Settings { get; }
    [NullableContextAttribute("2")]
public AddNewDocumentationCommentRewriter(DocumentationCommentGeneratorSettings settings, bool skipNamespaceDeclaration);
    [CompilerGeneratedAttribute]
public bool get_SkipNamespaceDeclaration();
    [CompilerGeneratedAttribute]
public DocumentationCommentGeneratorSettings get_Settings();
    protected virtual MemberDeclarationSyntax AddDocumentationComment(MemberDeclarationSyntax memberDeclaration);
    public virtual SyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual SyntaxNode VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual SyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual SyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual SyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual SyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual SyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
    public virtual SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual SyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual SyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual SyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node);
    public virtual SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual SyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CSharp.Documentation.DocumentationCommentGenerator : object {
    private static XmlReaderSettings _xmlReaderSettings;
    private static DocumentationCommentGenerator();
    public static SyntaxTriviaList Generate(MemberDeclarationSyntax memberDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(NamespaceDeclarationSyntax namespaceDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(ClassDeclarationSyntax classDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(RecordDeclarationSyntax recordDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(StructDeclarationSyntax structDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(InterfaceDeclarationSyntax interfaceDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(EnumDeclarationSyntax enumDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(DelegateDeclarationSyntax delegateDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(EnumMemberDeclarationSyntax enumMemberDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(FieldDeclarationSyntax fieldDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(EventFieldDeclarationSyntax eventFieldDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(MethodDeclarationSyntax methodDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(OperatorDeclarationSyntax operatorDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(ConstructorDeclarationSyntax constructorDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(DestructorDeclarationSyntax destructorDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(PropertyDeclarationSyntax propertyDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(EventDeclarationSyntax eventDeclaration, DocumentationCommentGeneratorSettings settings);
    public static SyntaxTriviaList Generate(IndexerDeclarationSyntax indexerDeclaration, DocumentationCommentGeneratorSettings settings);
    [NullableContextAttribute("2")]
private static SyntaxTriviaList Generate(TypeParameterListSyntax typeParameterList, BaseParameterListSyntax parameterList, bool canGenerateReturns, DocumentationCommentGeneratorSettings settings);
    [NullableContextAttribute("2")]
private static SyntaxTriviaList Generate(SeparatedSyntaxList`1<TypeParameterSyntax> typeParameters, SeparatedSyntaxList`1<ParameterSyntax> parameters, bool canGenerateReturns, DocumentationCommentGeneratorSettings settings);
    internal static bool CanGenerateFromBase(SyntaxKind kind);
    internal static DocumentationCommentData GenerateFromBase(MemberDeclarationSyntax memberDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static DocumentationCommentData GenerateFromBase(MethodDeclarationSyntax methodDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static DocumentationCommentData GenerateFromBase(PropertyDeclarationSyntax propertyDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static DocumentationCommentData GenerateFromBase(IndexerDeclarationSyntax indexerDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static DocumentationCommentData GenerateFromBase(IPropertySymbol propertySymbol, CancellationToken cancellationToken);
    internal static DocumentationCommentData GenerateFromBase(EventDeclarationSyntax eventDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static DocumentationCommentData GenerateFromBase(EventFieldDeclarationSyntax eventFieldDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static DocumentationCommentData GenerateFromBase(IEventSymbol eventSymbol, CancellationToken cancellationToken);
    internal static DocumentationCommentData GenerateFromBase(ConstructorDeclarationSyntax constructorDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static string GenerateFromOverriddenMethods(IMethodSymbol methodSymbol, CancellationToken cancellationToken);
    private static string GenerateFromOverriddenProperties(IPropertySymbol propertySymbol, CancellationToken cancellationToken);
    private static string GenerateFromOverriddenEvents(IEventSymbol eventSymbol, CancellationToken cancellationToken);
    private static string GenerateFromInterfaceMember(ISymbol memberSymbol, CancellationToken cancellationToken);
    private static string GetDocumentationCommentXml(ISymbol symbol, CancellationToken cancellationToken);
    private static bool ContainingTypeHasBaseType(MemberDeclarationSyntax memberDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslynator.CSharp.Documentation.DocumentationCommentInserter : ValueType {
    [CompilerGeneratedAttribute]
private static DocumentationCommentInserter <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxTriviaList <LeadingTrivia>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indent>k__BackingField;
    public static DocumentationCommentInserter Default { get; }
    public SyntaxTriviaList LeadingTrivia { get; }
    public int Index { get; }
    public string Indent { get; }
    private DocumentationCommentInserter(SyntaxTriviaList leadingTrivia, int index, string indent);
    private static DocumentationCommentInserter();
    [CompilerGeneratedAttribute]
public static DocumentationCommentInserter get_Default();
    [CompilerGeneratedAttribute]
public SyntaxTriviaList get_LeadingTrivia();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public string get_Indent();
    public static DocumentationCommentInserter Create(MemberDeclarationSyntax memberDeclaration);
    public static DocumentationCommentInserter Create(SyntaxTriviaList leadingTrivia);
    public SyntaxTriviaList Insert(SyntaxTrivia comment, bool indent);
    public SyntaxTriviaList InsertRange(SyntaxTriviaList comment, bool indent);
    private SyntaxTriviaList IndentAndInsert(string commentText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal static class Roslynator.CSharp.Documentation.DocumentationCommentTriviaFactory : object {
    private static Regex _commentedEmptyLineRegex;
    private static DocumentationCommentTriviaFactory();
    public static SyntaxTrivia Parse(string xml, SemanticModel semanticModel, int position);
    private static DocumentationCommentTriviaSyntax RemoveFilterPriorityElement(DocumentationCommentTriviaSyntax commentTrivia);
    private static string AddSlashes(string innerXml);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.Documentation.DocumentationCommentTriviaRewriter : CSharpSyntaxRewriter {
    private SemanticModel _semanticModel;
    private int _position;
    public DocumentationCommentTriviaRewriter(int position, SemanticModel semanticModel);
    public virtual SyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node);
    private string GetMinimalDisplayString(string metadataName);
}
[ExtensionAttribute]
internal static class Roslynator.CSharp.EnumExtensions : object {
    [ExtensionAttribute]
public static bool Is(SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool Is(SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [ExtensionAttribute]
public static bool Is(SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [ExtensionAttribute]
public static bool Is(SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    [ExtensionAttribute]
public static bool HasAnyFlag(ModifierFilter modifierFilter, ModifierFilter value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.EnumMemberDeclarationNameComparer : object {
    public static EnumMemberDeclarationNameComparer Instance;
    private static EnumMemberDeclarationNameComparer();
    public sealed virtual int Compare(EnumMemberDeclarationSyntax x, EnumMemberDeclarationSyntax y);
    private static int CompareCore(EnumMemberDeclarationSyntax x, EnumMemberDeclarationSyntax y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.EnumMemberDeclarationValueComparer : object {
    private IComparer`1<object> _valueComparer;
    private SemanticModel _semanticModel;
    private CancellationToken _cancellationToken;
    public EnumMemberDeclarationValueComparer(IComparer`1<object> valueComparer, SemanticModel semanticModel, CancellationToken cancellationToken);
    public sealed virtual int Compare(EnumMemberDeclarationSyntax x, EnumMemberDeclarationSyntax y);
    [NullableContextAttribute("2")]
private static int Compare(IFieldSymbol fieldSymbol1, IFieldSymbol fieldSymbol2, IComparer`1<object> comparer);
    public static bool IsSorted(IEnumerable`1<EnumMemberDeclarationSyntax> enumMembers, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.ExpressionChain : ValueType {
    [CompilerGeneratedAttribute]
private BinaryExpressionSyntax <BinaryExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextSpan> <Span>k__BackingField;
    public BinaryExpressionSyntax BinaryExpression { get; }
    public Nullable`1<TextSpan> Span { get; }
    internal TextSpan ExpressionsSpan { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal ExpressionChain(BinaryExpressionSyntax binaryExpression, Nullable`1<TextSpan> span);
    [CompilerGeneratedAttribute]
public BinaryExpressionSyntax get_BinaryExpression();
    [CompilerGeneratedAttribute]
public Nullable`1<TextSpan> get_Span();
    internal TextSpan get_ExpressionsSpan();
    private string get_DebuggerDisplay();
    private static bool IsInSpan(TextSpan self, TextSpan span);
    public Reversed Reverse();
    internal ExpressionSyntax First();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ExpressionSyntax> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExpressionChain other);
    public virtual int GetHashCode();
    public static bool op_Equality(ExpressionChain& info1, ExpressionChain& info2);
    public static bool op_Inequality(ExpressionChain& info1, ExpressionChain& info2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.IfStatementCascade : ValueType {
    [CompilerGeneratedAttribute]
private IfStatementSyntax <IfStatement>k__BackingField;
    public IfStatementSyntax IfStatement { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal IfStatementCascade(IfStatementSyntax ifStatement);
    [CompilerGeneratedAttribute]
public IfStatementSyntax get_IfStatement();
    private string get_DebuggerDisplay();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<IfStatementOrElseClause> System.Collections.Generic.IEnumerable<Roslynator.CSharp.IfStatementOrElseClause>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IfStatementCascade other);
    public virtual int GetHashCode();
    public static bool op_Equality(IfStatementCascade& cascade1, IfStatementCascade& cascade2);
    public static bool op_Inequality(IfStatementCascade& cascade1, IfStatementCascade& cascade2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.IfStatementCascadeInfo : ValueType {
    [CompilerGeneratedAttribute]
private IfStatementSyntax <IfStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private IfStatementOrElseClause <Last>k__BackingField;
    public IfStatementSyntax IfStatement { get; }
    public int Count { get; }
    public IfStatementOrElseClause Last { get; }
    public bool EndsWithIf { get; }
    public bool EndsWithElse { get; }
    public bool IsSimpleIf { get; }
    public bool IsSimpleIfElse { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public IfStatementCascadeInfo(IfStatementSyntax ifStatement);
    [CompilerGeneratedAttribute]
public IfStatementSyntax get_IfStatement();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public IfStatementOrElseClause get_Last();
    public bool get_EndsWithIf();
    public bool get_EndsWithElse();
    public bool get_IsSimpleIf();
    public bool get_IsSimpleIfElse();
    private string get_DebuggerDisplay();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IfStatementCascadeInfo other);
    public virtual int GetHashCode();
    public static bool op_Equality(IfStatementCascadeInfo& info1, IfStatementCascadeInfo& info2);
    public static bool op_Inequality(IfStatementCascadeInfo& info1, IfStatementCascadeInfo& info2);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.IfStatementOrElseClause : ValueType {
    private IfStatementSyntax _ifStatement;
    private ElseClauseSyntax _elseClause;
    internal SyntaxNode Node { get; }
    public SyntaxKind Kind { get; }
    public bool IsIf { get; }
    public bool IsElse { get; }
    public StatementSyntax Statement { get; }
    public SyntaxNode Parent { get; }
    public TextSpan Span { get; }
    public TextSpan FullSpan { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    [NullableContextAttribute("1")]
internal IfStatementOrElseClause(SyntaxNode node);
    [NullableContextAttribute("1")]
public IfStatementOrElseClause(IfStatementSyntax ifStatement);
    [NullableContextAttribute("1")]
public IfStatementOrElseClause(ElseClauseSyntax elseClause);
    internal SyntaxNode get_Node();
    public SyntaxKind get_Kind();
    public bool get_IsIf();
    public bool get_IsElse();
    public StatementSyntax get_Statement();
    public SyntaxNode get_Parent();
    public TextSpan get_Span();
    public TextSpan get_FullSpan();
    [NullableContextAttribute("1")]
private string get_DebuggerDisplay();
    public IfStatementSyntax AsIf();
    public ElseClauseSyntax AsElse();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IfStatementOrElseClause other);
    public virtual int GetHashCode();
    public static bool op_Equality(IfStatementOrElseClause& left, IfStatementOrElseClause& right);
    public static bool op_Inequality(IfStatementOrElseClause& left, IfStatementOrElseClause& right);
    [NullableContextAttribute("1")]
public static IfStatementOrElseClause op_Implicit(IfStatementSyntax ifStatement);
    public static IfStatementSyntax op_Implicit(IfStatementOrElseClause& ifOrElse);
    [NullableContextAttribute("1")]
public static IfStatementOrElseClause op_Implicit(ElseClauseSyntax elseClause);
    public static ElseClauseSyntax op_Implicit(IfStatementOrElseClause& ifOrElse);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.CSharp.MemberDeclarationComparer : object {
    internal static int MaxRank;
    internal static int ConstRank;
    internal static int FieldRank;
    [CompilerGeneratedAttribute]
private static MemberDeclarationComparer <ByKind>k__BackingField;
    [CompilerGeneratedAttribute]
private static MemberDeclarationComparer <ByKindThenByName>k__BackingField;
    internal static MemberDeclarationComparer ByKind { get; }
    internal static MemberDeclarationComparer ByKindThenByName { get; }
    private static MemberDeclarationComparer();
    [CompilerGeneratedAttribute]
internal static MemberDeclarationComparer get_ByKind();
    [CompilerGeneratedAttribute]
internal static MemberDeclarationComparer get_ByKindThenByName();
    public abstract virtual int Compare(MemberDeclarationSyntax x, MemberDeclarationSyntax y);
    public virtual int GetRank(MemberDeclarationSyntax member);
    internal static bool CanBeSortedByName(SyntaxKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.CSharp.MemberDeclarationInserter : object {
    [CompilerGeneratedAttribute]
private static MemberDeclarationInserter <Default>k__BackingField;
    public static MemberDeclarationInserter Default { get; }
    private static MemberDeclarationInserter();
    [CompilerGeneratedAttribute]
public static MemberDeclarationInserter get_Default();
    public abstract virtual int GetInsertIndex(SyntaxList`1<MemberDeclarationSyntax> members, MemberDeclarationSyntax member);
    public abstract virtual int GetInsertIndex(SyntaxList`1<MemberDeclarationSyntax> members, SyntaxKind kind);
    public ClassDeclarationSyntax Insert(ClassDeclarationSyntax classDeclaration, MemberDeclarationSyntax member);
    public CompilationUnitSyntax Insert(CompilationUnitSyntax compilationUnit, MemberDeclarationSyntax member);
    public InterfaceDeclarationSyntax Insert(InterfaceDeclarationSyntax interfaceDeclaration, MemberDeclarationSyntax member);
    public NamespaceDeclarationSyntax Insert(NamespaceDeclarationSyntax namespaceDeclaration, MemberDeclarationSyntax member);
    public StructDeclarationSyntax Insert(StructDeclarationSyntax structDeclaration, MemberDeclarationSyntax member);
    public RecordDeclarationSyntax Insert(RecordDeclarationSyntax recordDeclaration, MemberDeclarationSyntax member);
    public TypeDeclarationSyntax Insert(TypeDeclarationSyntax typeDeclaration, MemberDeclarationSyntax member);
    internal SyntaxList`1<MemberDeclarationSyntax> Insert(SyntaxList`1<MemberDeclarationSyntax> members, MemberDeclarationSyntax member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.MemberDeclarationKindComparer : object {
    [CompilerGeneratedAttribute]
private static MemberDeclarationKindComparer <Default>k__BackingField;
    public static MemberDeclarationKindComparer Default { get; }
    private static MemberDeclarationKindComparer();
    [CompilerGeneratedAttribute]
public static MemberDeclarationKindComparer get_Default();
    public sealed virtual int Compare(SyntaxKind x, SyntaxKind y);
    public virtual int GetRank(SyntaxKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.MemberDeclarationListSelection : SyntaxListSelection`1<MemberDeclarationSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxNode <Parent>k__BackingField;
    public SyntaxNode Parent { get; }
    private MemberDeclarationListSelection(SyntaxNode parent, SyntaxList`1<MemberDeclarationSyntax> members, TextSpan span, SelectionResult& result);
    private MemberDeclarationListSelection(SyntaxNode parent, SyntaxList`1<MemberDeclarationSyntax> members, TextSpan span, int firstIndex, int lastIndex);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Parent();
    public static MemberDeclarationListSelection Create(CompilationUnitSyntax compilationUnit, TextSpan span);
    public static MemberDeclarationListSelection Create(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span);
    public static MemberDeclarationListSelection Create(TypeDeclarationSyntax typeDeclaration, TextSpan span);
    private static MemberDeclarationListSelection Create(SyntaxNode parent, SyntaxList`1<MemberDeclarationSyntax> members, TextSpan span);
    public static bool TryCreate(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span, MemberDeclarationListSelection& selectedMembers);
    internal static bool TryCreate(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span, int minCount, MemberDeclarationListSelection& selectedMembers);
    internal static bool TryCreate(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span, int minCount, int maxCount, MemberDeclarationListSelection& selectedMembers);
    public static bool TryCreate(TypeDeclarationSyntax typeDeclaration, TextSpan span, MemberDeclarationListSelection& selectedMembers);
    internal static bool TryCreate(TypeDeclarationSyntax typeDeclaration, TextSpan span, int minCount, MemberDeclarationListSelection& selectedMembers);
    internal static bool TryCreate(TypeDeclarationSyntax typeDeclaration, TextSpan span, int minCount, int maxCount, MemberDeclarationListSelection& selectedMembers);
    private static MemberDeclarationListSelection Create(NamespaceDeclarationSyntax declaration, TextSpan span, int minCount, int maxCount);
    private static MemberDeclarationListSelection Create(TypeDeclarationSyntax declaration, TextSpan span, int minCount, int maxCount);
    private static MemberDeclarationListSelection Create(MemberDeclarationSyntax declaration, SyntaxList`1<MemberDeclarationSyntax> members, TextSpan span, int minCount, int maxCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslynator.CSharp.MethodChain : ValueType {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression>k__BackingField;
    public ExpressionSyntax Expression { get; }
    public MethodChain(ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression();
    private sealed virtual override IEnumerator`1<SyntaxNode> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator GetEnumerator();
}
internal abstract class Roslynator.CSharp.ModifierComparer : object {
    internal static int MaxRank;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static ModifierComparer <Default>k__BackingField;
    [NullableAttribute("1")]
public static ModifierComparer Default { get; }
    private static ModifierComparer();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static ModifierComparer get_Default();
    public abstract virtual int Compare(SyntaxToken x, SyntaxToken y);
    public virtual int GetRank(SyntaxToken token);
}
[FlagsAttribute]
public enum Roslynator.CSharp.ModifierFilter : Enum {
    public int value__;
    public static ModifierFilter None;
    public static ModifierFilter New;
    public static ModifierFilter Public;
    public static ModifierFilter Private;
    public static ModifierFilter Protected;
    public static ModifierFilter Internal;
    public static ModifierFilter Accessibility;
    public static ModifierFilter Const;
    public static ModifierFilter Static;
    public static ModifierFilter Virtual;
    public static ModifierFilter Sealed;
    public static ModifierFilter Override;
    public static ModifierFilter Abstract;
    public static ModifierFilter AbstractVirtualOverride;
    public static ModifierFilter ReadOnly;
    public static ModifierFilter Extern;
    public static ModifierFilter Unsafe;
    public static ModifierFilter Volatile;
    public static ModifierFilter Async;
    public static ModifierFilter Partial;
    public static ModifierFilter Ref;
    public static ModifierFilter Out;
    public static ModifierFilter In;
    public static ModifierFilter Params;
    public static ModifierFilter This;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.ModifierKindComparer : object {
    [CompilerGeneratedAttribute]
private static ModifierKindComparer <Default>k__BackingField;
    public static ModifierKindComparer Default { get; }
    private static ModifierKindComparer();
    [CompilerGeneratedAttribute]
public static ModifierKindComparer get_Default();
    public sealed virtual int Compare(SyntaxKind x, SyntaxKind y);
    public virtual int GetRank(SyntaxKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Roslynator.CSharp.ModifierList : object {
    [NullableContextAttribute("2")]
public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxToken token, IComparer`1<SyntaxToken> comparer);
    [NullableContextAttribute("2")]
public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxKind kind, IComparer`1<SyntaxKind> comparer);
    internal static SyntaxNode Insert(SyntaxNode node, Accessibility accessibility, IComparer`1<SyntaxKind> comparer);
    public static TNode Insert(TNode node, SyntaxKind kind, IComparer`1<SyntaxKind> comparer);
    public static TNode Insert(TNode node, SyntaxToken modifier, IComparer`1<SyntaxToken> comparer);
    public static TNode Remove(TNode node, SyntaxKind kind);
    public static TNode Remove(TNode node, SyntaxToken modifier);
    public static TNode RemoveAt(TNode node, int index);
    public static TNode RemoveAll(TNode node, Func`2<SyntaxToken, bool> predicate);
    public static TNode RemoveAll(TNode node);
    [NullableContextAttribute("2")]
public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxKind kind, IComparer`1<SyntaxKind> comparer);
    [NullableContextAttribute("2")]
public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxToken modifier, IComparer`1<SyntaxToken> comparer);
    private static SyntaxTokenList InsertImpl(SyntaxTokenList modifiers, SyntaxToken modifier, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Roslynator.CSharp.ModifierList`1 : object {
    [CompilerGeneratedAttribute]
private static ModifierList`1<TNode> <Instance>k__BackingField;
    public static ModifierList`1<TNode> Instance { get; }
    private static ModifierList`1();
    internal abstract virtual SyntaxList`1<AttributeListSyntax> GetAttributeLists(TNode node);
    internal abstract virtual SyntaxTokenList GetModifiers(TNode node);
    internal abstract virtual TNode WithModifiers(TNode node, SyntaxTokenList modifiers);
    [CompilerGeneratedAttribute]
public static ModifierList`1<TNode> get_Instance();
    private static object GetInstance();
    public TNode Insert(TNode node, SyntaxKind kind, IComparer`1<SyntaxKind> comparer);
    public TNode Insert(TNode node, SyntaxToken modifier, IComparer`1<SyntaxToken> comparer);
    private TNode InsertModifier(TNode node, SyntaxTokenList modifiers, SyntaxToken modifier, int index);
    public TNode Remove(TNode node, SyntaxKind kind);
    public TNode Remove(TNode node, SyntaxToken modifier);
    public TNode RemoveAt(TNode node, int index);
    private TNode Remove(TNode node, SyntaxTokenList modifiers, SyntaxToken modifier, int index);
    private static SyntaxTriviaList AddIfNotEmptyOrWhitespace(SyntaxTriviaList trivia, SyntaxTriviaList triviaToAdd);
    private static SyntaxTriviaList AddIfNotEmptyOrWhitespace(SyntaxTriviaList trivia, SyntaxTriviaList triviaToAdd1, SyntaxTriviaList triviaToAdd2);
    public TNode RemoveAll(TNode node);
    public TNode RemoveAll(TNode node, Func`2<SyntaxToken, bool> predicate);
}
public static class Roslynator.CSharp.Modifiers : object {
    public static SyntaxTokenList Public();
    public static SyntaxTokenList Internal();
    public static SyntaxTokenList Protected();
    public static SyntaxTokenList Protected_Internal();
    public static SyntaxTokenList Private();
    public static SyntaxTokenList Private_Protected();
    public static SyntaxTokenList Virtual();
    public static SyntaxTokenList Public_Virtual();
    public static SyntaxTokenList Internal_Virtual();
    public static SyntaxTokenList Protected_Virtual();
    public static SyntaxTokenList Public_Abstract();
    public static SyntaxTokenList Internal_Abstract();
    public static SyntaxTokenList Protected_Abstract();
    public static SyntaxTokenList Public_Override();
    public static SyntaxTokenList Internal_Override();
    public static SyntaxTokenList Protected_Override();
    public static SyntaxTokenList Const();
    public static SyntaxTokenList Public_Const();
    public static SyntaxTokenList Internal_Const();
    public static SyntaxTokenList Protected_Const();
    public static SyntaxTokenList Private_Const();
    public static SyntaxTokenList Static();
    public static SyntaxTokenList Public_Static();
    public static SyntaxTokenList Internal_Static();
    public static SyntaxTokenList Protected_Static();
    public static SyntaxTokenList Private_Static();
    public static SyntaxTokenList Static_ReadOnly();
    public static SyntaxTokenList Public_Static_ReadOnly();
    public static SyntaxTokenList Internal_Static_ReadOnly();
    public static SyntaxTokenList Protected_Static_ReadOnly();
    public static SyntaxTokenList Private_Static_ReadOnly();
    public static SyntaxTokenList ReadOnly();
    public static SyntaxTokenList Public_ReadOnly();
    public static SyntaxTokenList Internal_ReadOnly();
    public static SyntaxTokenList Protected_ReadOnly();
    public static SyntaxTokenList Private_ReadOnly();
    public static SyntaxTokenList Partial();
    public static SyntaxTokenList Public_Partial();
    public static SyntaxTokenList Internal_Partial();
    public static SyntaxTokenList Private_Partial();
    public static SyntaxTokenList Public_Static_Partial();
    public static SyntaxTokenList Internal_Static_Partial();
    public static SyntaxTokenList Private_Static_Partial();
    public static SyntaxTokenList Ref_ReadOnly();
}
[FlagsAttribute]
public enum Roslynator.CSharp.NullCheckStyles : Enum {
    public int value__;
    public static NullCheckStyles None;
    public static NullCheckStyles EqualsToNull;
    public static NullCheckStyles NotEqualsToNull;
    public static NullCheckStyles ComparisonToNull;
    public static NullCheckStyles IsNull;
    public static NullCheckStyles NotIsNull;
    public static NullCheckStyles NotHasValue;
    public static NullCheckStyles CheckingNull;
    public static NullCheckStyles HasValue;
    public static NullCheckStyles HasValueProperty;
    public static NullCheckStyles IsNotNull;
    public static NullCheckStyles IsPattern;
    public static NullCheckStyles CheckingNotNull;
    public static NullCheckStyles All;
}
[FlagsAttribute]
public enum Roslynator.CSharp.PreprocessorDirectiveFilter : Enum {
    public int value__;
    public static PreprocessorDirectiveFilter None;
    public static PreprocessorDirectiveFilter If;
    public static PreprocessorDirectiveFilter Elif;
    public static PreprocessorDirectiveFilter Else;
    public static PreprocessorDirectiveFilter EndIf;
    public static PreprocessorDirectiveFilter Region;
    public static PreprocessorDirectiveFilter EndRegion;
    public static PreprocessorDirectiveFilter Define;
    public static PreprocessorDirectiveFilter Undef;
    public static PreprocessorDirectiveFilter Error;
    public static PreprocessorDirectiveFilter Warning;
    public static PreprocessorDirectiveFilter Line;
    public static PreprocessorDirectiveFilter PragmaWarning;
    public static PreprocessorDirectiveFilter PragmaChecksum;
    public static PreprocessorDirectiveFilter Pragma;
    public static PreprocessorDirectiveFilter Reference;
    public static PreprocessorDirectiveFilter Load;
    public static PreprocessorDirectiveFilter Bad;
    public static PreprocessorDirectiveFilter Shebang;
    public static PreprocessorDirectiveFilter Nullable;
    public static PreprocessorDirectiveFilter All;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.CSharp.StatementListSelection : SyntaxListSelection`1<StatementSyntax> {
    private StatementListSelection(SyntaxList`1<StatementSyntax> statements, TextSpan span, SelectionResult& result);
    private StatementListSelection(SyntaxList`1<StatementSyntax> statements, TextSpan span, int firstIndex, int lastIndex);
    public static StatementListSelection Create(BlockSyntax block, TextSpan span);
    public static StatementListSelection Create(SwitchSectionSyntax switchSection, TextSpan span);
    public static StatementListSelection Create(StatementListInfo& statementsInfo, TextSpan span);
    private static StatementListSelection CreateImpl(SyntaxList`1<StatementSyntax> statements, TextSpan span);
    public static bool TryCreate(BlockSyntax block, TextSpan span, StatementListSelection& selectedStatements);
    internal static bool TryCreate(BlockSyntax block, TextSpan span, int minCount, StatementListSelection& selectedStatements);
    internal static bool TryCreate(BlockSyntax block, TextSpan span, int minCount, int maxCount, StatementListSelection& selectedStatements);
    private static StatementListSelection Create(BlockSyntax block, TextSpan span, int minCount, int maxCount);
    public static bool TryCreate(SwitchSectionSyntax switchSection, TextSpan span, StatementListSelection& selectedStatements);
    internal static bool TryCreate(SwitchSectionSyntax switchSection, TextSpan span, int minCount, StatementListSelection& selectedStatements);
    internal static bool TryCreate(SwitchSectionSyntax switchSection, TextSpan span, int minCount, int maxCount, StatementListSelection& selectedStatements);
    private static StatementListSelection Create(SwitchSectionSyntax switchSection, TextSpan span, int minCount, int maxCount);
    [NullableContextAttribute("2")]
private static StatementListSelection Create(SyntaxList`1<StatementSyntax> statements, TextSpan span, int minCount, int maxCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CSharp.StringLiteralParser : object {
    private static string MissingEscapeSequenceMessage;
    private static string UnrecognizedEscapeSequenceMessage;
    public static bool TryParse(string text, bool isVerbatim, bool isInterpolatedText, String& result);
    public static bool TryParse(string text, int start, int length, bool isVerbatim, bool isInterpolatedText, String& result);
    public static string Parse(string text, bool isVerbatim, bool isInterpolatedText);
    public static string Parse(string text, int start, int length, bool isVerbatim, bool isInterpolatedText);
    private static StringLiteralParserResult ParseRegular(string text, int start, int length, bool throwOnError, bool isInterpolatedText);
    private static StringLiteralParserResult ParseVerbatim(string text, int start, int length, bool throwOnError, bool isInterpolatedText);
    internal static bool CanExtractSpan(string text, TextSpan span, bool isVerbatim, bool isInterpolatedText);
    internal static bool CanExtractSpan(string text, int start, int length, TextSpan span, bool isVerbatim, bool isInterpolatedText);
    private static bool CanExtractSpanFromRegular(string text, int start, int length, TextSpan span, bool isInterpolatedText);
    private static bool CanExtractSpanFromVerbatim(string text, int start, int length, TextSpan span, bool isInterpolatedText);
    private static bool IsOverlap(TextSpan span, int index);
    private static bool IsOverlap(TextSpan span, int start, int length);
    private static bool IsHexadecimalDigit(char ch);
    private static StringLiteralParserResult Fail(bool throwOnError, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.StringLiteralTextBuilder : object {
    [CompilerGeneratedAttribute]
private StringBuilder <StringBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVerbatim>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInterpolated>k__BackingField;
    public StringBuilder StringBuilder { get; }
    public bool IsVerbatim { get; }
    public bool IsInterpolated { get; }
    [NullableContextAttribute("2")]
public StringLiteralTextBuilder(StringBuilder stringBuilder, bool isVerbatim, bool isInterpolated);
    [CompilerGeneratedAttribute]
public StringBuilder get_StringBuilder();
    [CompilerGeneratedAttribute]
public bool get_IsVerbatim();
    [CompilerGeneratedAttribute]
public bool get_IsInterpolated();
    public void Append(InterpolatedStringExpressionSyntax interpolatedString);
    public void Append(LiteralExpressionSyntax stringLiteral);
    private void Append(string value);
    public void AppendStart();
    public void AppendEnd();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool <Append>g__IsSpecialChar|12_0(char ch);
    [CompilerGeneratedAttribute]
private void <Append>g__AppendSpecialChar|12_1(char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Roslynator.CSharp.SymbolExtensions : object {
    [ExtensionAttribute]
internal static string ToDisplayString(INamedTypeSymbol typeSymbol, SymbolDisplayFormat format, SymbolDisplayTypeDeclarationOptions typeDeclarationOptions);
    [ExtensionAttribute]
internal static ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(INamedTypeSymbol typeSymbol, SymbolDisplayFormat format, SymbolDisplayTypeDeclarationOptions typeDeclarationOptions);
    [ExtensionAttribute]
public static TypeSyntax ToTypeSyntax(INamespaceOrTypeSymbol namespaceOrTypeSymbol, SymbolDisplayFormat format);
    [ExtensionAttribute]
public static TypeSyntax ToMinimalTypeSyntax(INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    [ExtensionAttribute]
public static TypeSyntax ToTypeSyntax(INamespaceSymbol namespaceSymbol, SymbolDisplayFormat format);
    [ExtensionAttribute]
public static TypeSyntax ToMinimalTypeSyntax(INamespaceSymbol namespaceSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private static void ThrowIfExplicitDeclarationIsNotSupported(INamespaceSymbol namespaceSymbol);
    [ExtensionAttribute]
internal static ExpressionSyntax GetDefaultValueMinimalSyntax(IParameterSymbol parameterSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    [ExtensionAttribute]
public static TypeSyntax ToTypeSyntax(ITypeSymbol typeSymbol, SymbolDisplayFormat format);
    [ExtensionAttribute]
public static TypeSyntax ToMinimalTypeSyntax(ITypeSymbol typeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private static void ThrowIfExplicitDeclarationIsNotSupported(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool SupportsConstantValue(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
internal static bool SupportsPrefixOrPostfixUnaryOperator(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
internal static bool IsReadOnlyStruct(ITypeSymbol type);
    [CompilerGeneratedAttribute]
internal static void <ToDisplayParts>g__AddKeyword|1_0(SyntaxKind kind, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static void <ToDisplayParts>g__AddSpace|1_1(<>c__DisplayClass1_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static IFieldSymbol <GetDefaultValueMinimalSyntax>g__FindFieldWithConstantValue|7_0(<>c__DisplayClass7_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.AsExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private BinaryExpressionSyntax <AsExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeSyntax <Type>k__BackingField;
    public BinaryExpressionSyntax AsExpression { get; }
    public ExpressionSyntax Expression { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken OperatorToken { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private AsExpressionInfo(BinaryExpressionSyntax asExpression, ExpressionSyntax expression, TypeSyntax type);
    [CompilerGeneratedAttribute]
public BinaryExpressionSyntax get_AsExpression();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression();
    [CompilerGeneratedAttribute]
public TypeSyntax get_Type();
    public SyntaxToken get_OperatorToken();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static AsExpressionInfo Create(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    internal static AsExpressionInfo Create(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
private static AsExpressionInfo CreateImpl(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.AssignmentExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private AssignmentExpressionSyntax <AssignmentExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Right>k__BackingField;
    public AssignmentExpressionSyntax AssignmentExpression { get; }
    public ExpressionSyntax Left { get; }
    public ExpressionSyntax Right { get; }
    public SyntaxToken OperatorToken { get; }
    public SyntaxKind Kind { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private AssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, ExpressionSyntax left, ExpressionSyntax right);
    [CompilerGeneratedAttribute]
public AssignmentExpressionSyntax get_AssignmentExpression();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Left();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Right();
    public SyntaxToken get_OperatorToken();
    public SyntaxKind get_Kind();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static AssignmentExpressionInfo Create(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
internal static AssignmentExpressionInfo Create(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.BinaryExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private BinaryExpressionSyntax <BinaryExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Right>k__BackingField;
    public BinaryExpressionSyntax BinaryExpression { get; }
    public ExpressionSyntax Left { get; }
    public ExpressionSyntax Right { get; }
    public SyntaxToken OperatorToken { get; }
    public SyntaxKind Kind { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal BinaryExpressionInfo(BinaryExpressionSyntax binaryExpression, ExpressionSyntax left, ExpressionSyntax right);
    [CompilerGeneratedAttribute]
public BinaryExpressionSyntax get_BinaryExpression();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Left();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Right();
    public SyntaxToken get_OperatorToken();
    public SyntaxKind get_Kind();
    public bool get_Success();
    private string get_DebuggerDisplay();
    public ExpressionChain AsChain();
    internal static BinaryExpressionInfo Create(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    internal static BinaryExpressionInfo Create(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
private static BinaryExpressionInfo CreateImpl(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.ConditionalExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <WhenTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <WhenFalse>k__BackingField;
    public ConditionalExpressionSyntax ConditionalExpression { get; }
    public ExpressionSyntax Condition { get; }
    public ExpressionSyntax WhenTrue { get; }
    public ExpressionSyntax WhenFalse { get; }
    public SyntaxToken QuestionToken { get; }
    public SyntaxToken ColonToken { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private ConditionalExpressionInfo(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse);
    public ConditionalExpressionSyntax get_ConditionalExpression();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Condition();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_WhenTrue();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_WhenFalse();
    public SyntaxToken get_QuestionToken();
    public SyntaxToken get_ColonToken();
    public bool get_Success();
    private string get_DebuggerDisplay();
    [NullableContextAttribute("2")]
internal static ConditionalExpressionInfo Create(ConditionalExpressionSyntax conditionalExpression, bool walkDownParentheses, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.CSharp.Syntax.ConditionalStatementInfo : ValueType {
    [CompilerGeneratedAttribute]
private IfStatementSyntax <IfStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementSyntax <WhenTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementSyntax <WhenFalse>k__BackingField;
    public IfStatementSyntax IfStatement { get; }
    public ExpressionSyntax Condition { get; }
    public StatementSyntax WhenTrue { get; }
    public StatementSyntax WhenFalse { get; }
    public ElseClauseSyntax Else { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private ConditionalStatementInfo(IfStatementSyntax ifStatement, ExpressionSyntax condition, StatementSyntax whenTrue, StatementSyntax whenFalse);
    [CompilerGeneratedAttribute]
public IfStatementSyntax get_IfStatement();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Condition();
    [CompilerGeneratedAttribute]
public StatementSyntax get_WhenTrue();
    [CompilerGeneratedAttribute]
public StatementSyntax get_WhenFalse();
    public ElseClauseSyntax get_Else();
    public bool get_Success();
    private string get_DebuggerDisplay();
    [NullableContextAttribute("2")]
internal static ConditionalStatementInfo Create(IfStatementSyntax ifStatement, bool walkDownParentheses, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.GenericInfo : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxNode <Node>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TypeParameterListSyntax <TypeParameterList>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SyntaxList`1<TypeParameterConstraintClauseSyntax> <ConstraintClauses>k__BackingField;
    public SyntaxNode Node { get; }
    public SyntaxKind Kind { get; }
    [NullableAttribute("2")]
public TypeParameterListSyntax TypeParameterList { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SeparatedSyntaxList`1<TypeParameterSyntax> TypeParameters { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private GenericInfo(TypeDeclarationSyntax typeDeclaration);
    private GenericInfo(DelegateDeclarationSyntax delegateDeclaration);
    private GenericInfo(LocalFunctionStatementSyntax localFunctionStatement);
    private GenericInfo(MethodDeclarationSyntax methodDeclaration);
    private GenericInfo(SyntaxNode declaration, TypeParameterListSyntax typeParameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Node();
    public SyntaxKind get_Kind();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TypeParameterListSyntax get_TypeParameterList();
    public SeparatedSyntaxList`1<TypeParameterSyntax> get_TypeParameters();
    [CompilerGeneratedAttribute]
public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public TypeParameterSyntax FindTypeParameter(string name);
    public TypeParameterConstraintClauseSyntax FindConstraintClause(string typeParameterName);
    public bool get_Success();
    private string get_DebuggerDisplay();
    [NullableContextAttribute("2")]
internal static GenericInfo Create(SyntaxNode node);
    internal static GenericInfo Create(TypeParameterConstraintSyntax typeParameterConstraint);
    [NullableContextAttribute("2")]
internal static GenericInfo Create(TypeParameterConstraintClauseSyntax constraintClause);
    internal static GenericInfo Create(TypeParameterSyntax typeParameter);
    [NullableContextAttribute("2")]
internal static GenericInfo Create(TypeParameterListSyntax typeParameterList);
    internal static GenericInfo Create(TypeDeclarationSyntax typeDeclaration);
    internal static GenericInfo Create(DelegateDeclarationSyntax delegateDeclaration);
    internal static GenericInfo Create(LocalFunctionStatementSyntax localFunctionStatement);
    internal static GenericInfo Create(MethodDeclarationSyntax methodDeclaration);
    public GenericInfo WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public GenericInfo RemoveTypeParameter(TypeParameterSyntax typeParameter);
    public GenericInfo WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public GenericInfo RemoveConstraintClause(TypeParameterConstraintClauseSyntax constraintClause);
    public GenericInfo RemoveAllConstraintClauses();
    private void ThrowInvalidOperationIfNotInitialized();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static TypeParameterListSyntax <RemoveTypeParameter>g__RemoveTypeParameter|34_0(<>c__DisplayClass34_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.CSharp.Syntax.HexNumericLiteralExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private LiteralExpressionSyntax <LiteralExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <Token>k__BackingField;
    public LiteralExpressionSyntax LiteralExpression { get; }
    public SyntaxToken Token { get; }
    public string Text { get; }
    public string ValueText { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private HexNumericLiteralExpressionInfo(LiteralExpressionSyntax literalExpression, SyntaxToken token);
    [CompilerGeneratedAttribute]
public LiteralExpressionSyntax get_LiteralExpression();
    [CompilerGeneratedAttribute]
public SyntaxToken get_Token();
    public string get_Text();
    public string get_ValueText();
    [NullableContextAttribute("2")]
public object get_Value();
    public string GetSuffix();
    public HexNumericLiteralSuffixKind GetSuffixKind();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static HexNumericLiteralExpressionInfo Create(SyntaxNode node, bool walkDownParentheses);
    [NullableContextAttribute("2")]
internal static HexNumericLiteralExpressionInfo Create(LiteralExpressionSyntax literalExpression);
}
internal enum Roslynator.CSharp.Syntax.HexNumericLiteralSuffixKind : Enum {
    public int value__;
    public static HexNumericLiteralSuffixKind None;
    public static HexNumericLiteralSuffixKind UIntOrULong;
    public static HexNumericLiteralSuffixKind LongOrULong;
    public static HexNumericLiteralSuffixKind ULong;
    public static HexNumericLiteralSuffixKind Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.IsExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private BinaryExpressionSyntax <IsExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeSyntax <Type>k__BackingField;
    public BinaryExpressionSyntax IsExpression { get; }
    public ExpressionSyntax Expression { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken OperatorToken { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private IsExpressionInfo(BinaryExpressionSyntax isExpression, ExpressionSyntax expression, TypeSyntax type);
    [CompilerGeneratedAttribute]
public BinaryExpressionSyntax get_IsExpression();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression();
    [CompilerGeneratedAttribute]
public TypeSyntax get_Type();
    public SyntaxToken get_OperatorToken();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static IsExpressionInfo Create(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    internal static IsExpressionInfo Create(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
private static IsExpressionInfo CreateImpl(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.LocalDeclarationStatementInfo : ValueType {
    [CompilerGeneratedAttribute]
private LocalDeclarationStatementSyntax <Statement>k__BackingField;
    public LocalDeclarationStatementSyntax Statement { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    public VariableDeclarationSyntax Declaration { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SeparatedSyntaxList`1<VariableDeclaratorSyntax> Variables { get; }
    public SyntaxToken SemicolonToken { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private LocalDeclarationStatementInfo(LocalDeclarationStatementSyntax statement);
    [CompilerGeneratedAttribute]
public LocalDeclarationStatementSyntax get_Statement();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_Type();
    public VariableDeclarationSyntax get_Declaration();
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> get_Variables();
    public SyntaxToken get_SemicolonToken();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static LocalDeclarationStatementInfo Create(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing);
    internal static LocalDeclarationStatementInfo Create(ExpressionSyntax value, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.MemberDeclarationListInfo : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxNode <Parent>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SyntaxList`1<MemberDeclarationSyntax> <Members>k__BackingField;
    public SyntaxNode Parent { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public bool Success { get; }
    public int Count { get; }
    public Nullable`1<SyntaxToken> OpenBraceToken { get; }
    public Nullable`1<SyntaxToken> CloseBraceToken { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public MemberDeclarationSyntax Item { get; }
    internal MemberDeclarationListInfo(SyntaxNode parent, SyntaxList`1<MemberDeclarationSyntax> members);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Parent();
    [CompilerGeneratedAttribute]
public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public bool get_Success();
    public sealed virtual int get_Count();
    public Nullable`1<SyntaxToken> get_OpenBraceToken();
    public Nullable`1<SyntaxToken> get_CloseBraceToken();
    private string get_DebuggerDisplay();
    public sealed virtual MemberDeclarationSyntax get_Item(int index);
    private sealed virtual override IEnumerator`1<MemberDeclarationSyntax> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<MemberDeclarationSyntax> GetEnumerator();
    internal static MemberDeclarationListInfo Create(CompilationUnitSyntax compilationUnit);
    internal static MemberDeclarationListInfo Create(NamespaceDeclarationSyntax namespaceDeclaration);
    internal static MemberDeclarationListInfo Create(TypeDeclarationSyntax typeDeclaration);
    internal static MemberDeclarationListInfo Create(ClassDeclarationSyntax classDeclaration);
    internal static MemberDeclarationListInfo Create(StructDeclarationSyntax structDeclaration);
    internal static MemberDeclarationListInfo Create(InterfaceDeclarationSyntax interfaceDeclaration);
    internal static MemberDeclarationListInfo Create(SyntaxNode node);
    internal static MemberDeclarationListInfo Create(MemberDeclarationListSelection selectedMembers);
    public MemberDeclarationListInfo WithMembers(IEnumerable`1<MemberDeclarationSyntax> members);
    public MemberDeclarationListInfo WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public MemberDeclarationListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
    public MemberDeclarationListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode);
    public MemberDeclarationListInfo Add(MemberDeclarationSyntax member);
    public MemberDeclarationListInfo AddRange(IEnumerable`1<MemberDeclarationSyntax> members);
    public bool Any();
    public MemberDeclarationSyntax First();
    [NullableContextAttribute("2")]
public MemberDeclarationSyntax FirstOrDefault();
    public int IndexOf(Func`2<MemberDeclarationSyntax, bool> predicate);
    public int IndexOf(MemberDeclarationSyntax member);
    public MemberDeclarationListInfo Insert(int index, MemberDeclarationSyntax member);
    public MemberDeclarationListInfo InsertRange(int index, IEnumerable`1<MemberDeclarationSyntax> members);
    public MemberDeclarationSyntax Last();
    [NullableContextAttribute("2")]
public MemberDeclarationSyntax LastOrDefault();
    public int LastIndexOf(Func`2<MemberDeclarationSyntax, bool> predicate);
    public int LastIndexOf(MemberDeclarationSyntax member);
    public MemberDeclarationListInfo Remove(MemberDeclarationSyntax member);
    public MemberDeclarationListInfo RemoveAt(int index);
    public MemberDeclarationListInfo Replace(MemberDeclarationSyntax memberInList, MemberDeclarationSyntax newMember);
    public MemberDeclarationListInfo ReplaceAt(int index, MemberDeclarationSyntax newMember);
    public MemberDeclarationListInfo ReplaceRange(MemberDeclarationSyntax memberInList, IEnumerable`1<MemberDeclarationSyntax> newMembers);
    private void ThrowInvalidOperationIfNotInitialized();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.ModifierListInfo : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxTokenList <Modifiers>k__BackingField;
    public SyntaxNode Parent { get; }
    public SyntaxTokenList Modifiers { get; }
    public Accessibility ExplicitAccessibility { get; }
    public bool IsNew { get; }
    public bool IsConst { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsSealed { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsReadOnly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool IsAsync { get; }
    public bool IsPartial { get; }
    public bool IsRef { get; }
    public bool IsOut { get; }
    public bool IsIn { get; }
    public bool IsParams { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal ModifierListInfo(SyntaxNode parent, SyntaxTokenList modifiers);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Parent();
    [CompilerGeneratedAttribute]
public SyntaxTokenList get_Modifiers();
    public Accessibility get_ExplicitAccessibility();
    public bool get_IsNew();
    public bool get_IsConst();
    public bool get_IsStatic();
    public bool get_IsVirtual();
    public bool get_IsSealed();
    public bool get_IsOverride();
    public bool get_IsAbstract();
    public bool get_IsReadOnly();
    public bool get_IsExtern();
    public bool get_IsUnsafe();
    public bool get_IsVolatile();
    public bool get_IsAsync();
    public bool get_IsPartial();
    public bool get_IsRef();
    public bool get_IsOut();
    public bool get_IsIn();
    public bool get_IsParams();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static ModifierListInfo Create(SyntaxNode node);
    internal static ModifierListInfo Create(ClassDeclarationSyntax classDeclaration);
    internal static ModifierListInfo Create(ConstructorDeclarationSyntax constructorDeclaration);
    internal static ModifierListInfo Create(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration);
    internal static ModifierListInfo Create(DelegateDeclarationSyntax delegateDeclaration);
    internal static ModifierListInfo Create(DestructorDeclarationSyntax destructorDeclaration);
    internal static ModifierListInfo Create(EnumDeclarationSyntax enumDeclaration);
    internal static ModifierListInfo Create(EventDeclarationSyntax eventDeclaration);
    internal static ModifierListInfo Create(EventFieldDeclarationSyntax eventFieldDeclaration);
    internal static ModifierListInfo Create(FieldDeclarationSyntax fieldDeclaration);
    internal static ModifierListInfo Create(IndexerDeclarationSyntax indexerDeclaration);
    internal static ModifierListInfo Create(InterfaceDeclarationSyntax interfaceDeclaration);
    internal static ModifierListInfo Create(MethodDeclarationSyntax methodDeclaration);
    internal static ModifierListInfo Create(OperatorDeclarationSyntax operatorDeclaration);
    internal static ModifierListInfo Create(PropertyDeclarationSyntax propertyDeclaration);
    internal static ModifierListInfo Create(StructDeclarationSyntax structDeclaration);
    internal static ModifierListInfo Create(IncompleteMemberSyntax incompleteMember);
    internal static ModifierListInfo Create(AccessorDeclarationSyntax accessorDeclaration);
    internal static ModifierListInfo Create(LocalDeclarationStatementSyntax localDeclarationStatement);
    internal static ModifierListInfo Create(LocalFunctionStatementSyntax localFunctionStatement);
    internal static ModifierListInfo Create(ParameterSyntax parameter);
    public ModifierListInfo WithoutExplicitAccessibility();
    [NullableContextAttribute("2")]
public ModifierListInfo WithExplicitAccessibility(Accessibility newAccessibility, IComparer`1<SyntaxKind> comparer);
    [NullableContextAttribute("0")]
private ValueTuple`2<int, int> GetTokenIndexes();
    private int GetFirstTokenIndex();
    public ModifierListInfo WithModifiers(SyntaxTokenList modifiers);
    public ModifierFilter GetFilter();
    private void ThrowInvalidOperationIfNotInitialized();
    [CompilerGeneratedAttribute]
internal static SyntaxKind <WithExplicitAccessibility>g__GetTokenKind|69_0(<>c__DisplayClass69_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.NullCheckExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private ExpressionSyntax <NullCheckExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private NullCheckStyles <Style>k__BackingField;
    public ExpressionSyntax NullCheckExpression { get; }
    public ExpressionSyntax Expression { get; }
    public NullCheckStyles Style { get; }
    public bool IsCheckingNull { get; }
    public bool IsCheckingNotNull { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private NullCheckExpressionInfo(ExpressionSyntax nullCheckExpression, ExpressionSyntax expression, NullCheckStyles style);
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_NullCheckExpression();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Expression();
    [CompilerGeneratedAttribute]
public NullCheckStyles get_Style();
    public bool get_IsCheckingNull();
    public bool get_IsCheckingNotNull();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static NullCheckExpressionInfo Create(SyntaxNode node, NullCheckStyles allowedStyles, bool walkDownParentheses, bool allowMissing);
    internal static NullCheckExpressionInfo Create(SyntaxNode node, SemanticModel semanticModel, NullCheckStyles allowedStyles, bool walkDownParentheses, bool allowMissing, CancellationToken cancellationToken);
    private static NullCheckExpressionInfo CreateImpl(SyntaxNode node, SemanticModel semanticModel, NullCheckStyles allowedStyles, bool walkDownParentheses, bool allowMissing, CancellationToken cancellationToken);
    private static NullCheckExpressionInfo Create(BinaryExpressionSyntax binaryExpression, SyntaxKind binaryExpressionKind, ExpressionSyntax expression1, ExpressionSyntax expression2, NullCheckStyles allowedStyles, bool allowMissing, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static NullCheckExpressionInfo Create(BinaryExpressionSyntax binaryExpression, ExpressionSyntax expression, NullCheckStyles style, NullCheckStyles allowedStyles, bool allowMissing, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsPropertyOfNullableOfT(ExpressionSyntax expression, string name, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsNullOrDefault(ExpressionSyntax left, ExpressionSyntax right, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.CSharp.Syntax.ParameterInfo : ValueType {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TypeParameterListSyntax <TypeParameterList>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ParameterSyntax <Parameter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private BaseParameterListSyntax <ParameterList>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CSharpSyntaxNode <Body>k__BackingField;
    public SyntaxNode Node { get; }
    [NullableAttribute("2")]
public TypeParameterListSyntax TypeParameterList { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SeparatedSyntaxList`1<TypeParameterSyntax> TypeParameters { get; }
    [NullableAttribute("2")]
public ParameterSyntax Parameter { get; }
    [NullableAttribute("2")]
public BaseParameterListSyntax ParameterList { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SeparatedSyntaxList`1<ParameterSyntax> Parameters { get; }
    [NullableAttribute("2")]
public CSharpSyntaxNode Body { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public ParameterInfo(ParameterSyntax parameter, CSharpSyntaxNode body);
    public ParameterInfo(BaseParameterListSyntax parameterList, CSharpSyntaxNode body);
    [NullableContextAttribute("2")]
public ParameterInfo(BaseParameterListSyntax parameterList, TypeParameterListSyntax typeParameterList, CSharpSyntaxNode body);
    public SyntaxNode get_Node();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TypeParameterListSyntax get_TypeParameterList();
    public SeparatedSyntaxList`1<TypeParameterSyntax> get_TypeParameters();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ParameterSyntax get_Parameter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public BaseParameterListSyntax get_ParameterList();
    public SeparatedSyntaxList`1<ParameterSyntax> get_Parameters();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CSharpSyntaxNode get_Body();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static ParameterInfo Create(ConstructorDeclarationSyntax constructorDeclaration, bool allowMissing);
    internal static ParameterInfo Create(MethodDeclarationSyntax methodDeclaration, bool allowMissing);
    internal static ParameterInfo Create(OperatorDeclarationSyntax operatorDeclaration, bool allowMissing);
    internal static ParameterInfo Create(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration, bool allowMissing);
    internal static ParameterInfo Create(DelegateDeclarationSyntax delegateDeclaration, bool allowMissing);
    internal static ParameterInfo Create(LocalFunctionStatementSyntax localFunction, bool allowMissing);
    internal static ParameterInfo Create(IndexerDeclarationSyntax indexerDeclaration, bool allowMissing);
    internal static ParameterInfo Create(SimpleLambdaExpressionSyntax simpleLambda, bool allowMissing);
    internal static ParameterInfo Create(ParenthesizedLambdaExpressionSyntax parenthesizedLambda, bool allowMissing);
    internal static ParameterInfo Create(AnonymousMethodExpressionSyntax anonymousMethod, bool allowMissing);
    [NullableContextAttribute("2")]
private static bool CheckParameterList(BaseParameterListSyntax parameterList, bool allowMissing);
    private static bool CheckTypeParameters(SeparatedSyntaxList`1<TypeParameterSyntax> typeParameters, bool allowMissing);
    private static bool CheckParameters(SeparatedSyntaxList`1<ParameterSyntax> parameters, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.RegionInfo : ValueType {
    [CompilerGeneratedAttribute]
private RegionDirectiveTriviaSyntax <Directive>k__BackingField;
    [CompilerGeneratedAttribute]
private EndRegionDirectiveTriviaSyntax <EndDirective>k__BackingField;
    public RegionDirectiveTriviaSyntax Directive { get; }
    public EndRegionDirectiveTriviaSyntax EndDirective { get; }
    public bool Success { get; }
    public TextSpan Span { get; }
    public TextSpan FullSpan { get; }
    public bool IsEmpty { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private RegionInfo(RegionDirectiveTriviaSyntax directive, EndRegionDirectiveTriviaSyntax endDirective);
    [CompilerGeneratedAttribute]
public RegionDirectiveTriviaSyntax get_Directive();
    [CompilerGeneratedAttribute]
public EndRegionDirectiveTriviaSyntax get_EndDirective();
    public bool get_Success();
    public TextSpan get_Span();
    public TextSpan get_FullSpan();
    public bool get_IsEmpty();
    private string get_DebuggerDisplay();
    [NullableContextAttribute("2")]
private static EndRegionDirectiveTriviaSyntax FindEndRegionDirective(SyntaxTriviaList list, int index);
    internal static RegionInfo Create(SyntaxNode node);
    internal static RegionInfo Create(RegionDirectiveTriviaSyntax regionDirective);
    internal static RegionInfo Create(EndRegionDirectiveTriviaSyntax endRegionDirective);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.SimpleAssignmentExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private AssignmentExpressionSyntax <AssignmentExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Right>k__BackingField;
    public AssignmentExpressionSyntax AssignmentExpression { get; }
    public ExpressionSyntax Left { get; }
    public ExpressionSyntax Right { get; }
    public SyntaxToken OperatorToken { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private SimpleAssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, ExpressionSyntax left, ExpressionSyntax right);
    [CompilerGeneratedAttribute]
public AssignmentExpressionSyntax get_AssignmentExpression();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Left();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Right();
    public SyntaxToken get_OperatorToken();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static SimpleAssignmentExpressionInfo Create(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
internal static SimpleAssignmentExpressionInfo Create(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.SimpleAssignmentStatementInfo : ValueType {
    private SimpleAssignmentExpressionInfo _info;
    public AssignmentExpressionSyntax AssignmentExpression { get; }
    public ExpressionSyntax Left { get; }
    public ExpressionSyntax Right { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionStatementSyntax Statement { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private SimpleAssignmentStatementInfo(SimpleAssignmentExpressionInfo& info);
    public AssignmentExpressionSyntax get_AssignmentExpression();
    public ExpressionSyntax get_Left();
    public ExpressionSyntax get_Right();
    public SyntaxToken get_OperatorToken();
    public ExpressionStatementSyntax get_Statement();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static SimpleAssignmentStatementInfo Create(StatementSyntax statement, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
internal static SimpleAssignmentStatementInfo Create(ExpressionStatementSyntax expressionStatement, bool walkDownParentheses, bool allowMissing);
    internal static SimpleAssignmentStatementInfo Create(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
private static SimpleAssignmentStatementInfo CreateImpl(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.SimpleIfStatementInfo : ValueType {
    [CompilerGeneratedAttribute]
private IfStatementSyntax <IfStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionSyntax <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementSyntax <Statement>k__BackingField;
    public IfStatementSyntax IfStatement { get; }
    public ExpressionSyntax Condition { get; }
    public StatementSyntax Statement { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private SimpleIfStatementInfo(IfStatementSyntax ifStatement, ExpressionSyntax condition, StatementSyntax statement);
    [CompilerGeneratedAttribute]
public IfStatementSyntax get_IfStatement();
    [CompilerGeneratedAttribute]
public ExpressionSyntax get_Condition();
    [CompilerGeneratedAttribute]
public StatementSyntax get_Statement();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static SimpleIfStatementInfo Create(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
internal static SimpleIfStatementInfo Create(IfStatementSyntax ifStatement, bool walkDownParentheses, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.SimpleMemberInvocationExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <InvocationExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberAccessExpressionSyntax <MemberAccessExpression>k__BackingField;
    public InvocationExpressionSyntax InvocationExpression { get; }
    public MemberAccessExpressionSyntax MemberAccessExpression { get; }
    public ExpressionSyntax Expression { get; }
    public SimpleNameSyntax Name { get; }
    public ArgumentListSyntax ArgumentList { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    public SyntaxToken OperatorToken { get; }
    public string NameText { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private SimpleMemberInvocationExpressionInfo(InvocationExpressionSyntax invocationExpression, MemberAccessExpressionSyntax memberAccessExpression);
    [CompilerGeneratedAttribute]
public InvocationExpressionSyntax get_InvocationExpression();
    [CompilerGeneratedAttribute]
public MemberAccessExpressionSyntax get_MemberAccessExpression();
    public ExpressionSyntax get_Expression();
    public SimpleNameSyntax get_Name();
    public ArgumentListSyntax get_ArgumentList();
    public SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    public SyntaxToken get_OperatorToken();
    public string get_NameText();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static SimpleMemberInvocationExpressionInfo Create(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    internal static SimpleMemberInvocationExpressionInfo Create(InvocationExpressionSyntax invocationExpression, bool allowMissing);
    [NullableContextAttribute("2")]
private static SimpleMemberInvocationExpressionInfo CreateImpl(InvocationExpressionSyntax invocationExpression, bool allowMissing);
    internal SimpleMemberInvocationExpressionInfo WithName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.SimpleMemberInvocationStatementInfo : ValueType {
    private SimpleMemberInvocationExpressionInfo _info;
    public InvocationExpressionSyntax InvocationExpression { get; }
    public MemberAccessExpressionSyntax MemberAccessExpression { get; }
    public ExpressionSyntax Expression { get; }
    public SimpleNameSyntax Name { get; }
    public ArgumentListSyntax ArgumentList { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    public string NameText { get; }
    public ExpressionStatementSyntax Statement { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private SimpleMemberInvocationStatementInfo(SimpleMemberInvocationExpressionInfo& info);
    public InvocationExpressionSyntax get_InvocationExpression();
    public MemberAccessExpressionSyntax get_MemberAccessExpression();
    public ExpressionSyntax get_Expression();
    public SimpleNameSyntax get_Name();
    public ArgumentListSyntax get_ArgumentList();
    public SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    public string get_NameText();
    public ExpressionStatementSyntax get_Statement();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static SimpleMemberInvocationStatementInfo Create(SyntaxNode node, bool allowMissing);
    internal static SimpleMemberInvocationStatementInfo Create(ExpressionStatementSyntax expressionStatement, bool allowMissing);
    internal static SimpleMemberInvocationStatementInfo Create(InvocationExpressionSyntax invocationExpression, bool allowMissing);
    private static SimpleMemberInvocationStatementInfo CreateImpl(InvocationExpressionSyntax invocationExpression, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.SingleLocalDeclarationStatementInfo : ValueType {
    [CompilerGeneratedAttribute]
private LocalDeclarationStatementSyntax <Statement>k__BackingField;
    [CompilerGeneratedAttribute]
private VariableDeclaratorSyntax <Declarator>k__BackingField;
    public LocalDeclarationStatementSyntax Statement { get; }
    public SyntaxToken UsingKeyword { get; }
    public SyntaxToken AwaitKeyword { get; }
    public VariableDeclaratorSyntax Declarator { get; }
    public VariableDeclarationSyntax Declaration { get; }
    [NullableAttribute("2")]
public EqualsValueClauseSyntax Initializer { get; }
    [NullableAttribute("2")]
public ExpressionSyntax Value { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public string IdentifierText { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken SemicolonToken { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private SingleLocalDeclarationStatementInfo(LocalDeclarationStatementSyntax statement, VariableDeclaratorSyntax declarator);
    [CompilerGeneratedAttribute]
public LocalDeclarationStatementSyntax get_Statement();
    public SyntaxToken get_UsingKeyword();
    public SyntaxToken get_AwaitKeyword();
    [CompilerGeneratedAttribute]
public VariableDeclaratorSyntax get_Declarator();
    public VariableDeclarationSyntax get_Declaration();
    [NullableContextAttribute("2")]
public EqualsValueClauseSyntax get_Initializer();
    [NullableContextAttribute("2")]
public ExpressionSyntax get_Value();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public string get_IdentifierText();
    public SyntaxToken get_EqualsToken();
    public SyntaxToken get_SemicolonToken();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static SingleLocalDeclarationStatementInfo Create(StatementSyntax statement, bool allowMissing);
    internal static SingleLocalDeclarationStatementInfo Create(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing);
    internal static SingleLocalDeclarationStatementInfo Create(VariableDeclarationSyntax variableDeclaration, bool allowMissing);
    internal static SingleLocalDeclarationStatementInfo Create(ExpressionSyntax value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.SingleParameterLambdaExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private LambdaExpressionSyntax <LambdaExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterSyntax <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpSyntaxNode <Body>k__BackingField;
    public LambdaExpressionSyntax LambdaExpression { get; }
    public ParameterSyntax Parameter { get; }
    public CSharpSyntaxNode Body { get; }
    [NullableAttribute("2")]
public ParameterListSyntax ParameterList { get; }
    public bool IsSimpleLambda { get; }
    public bool IsParenthesizedLambda { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private SingleParameterLambdaExpressionInfo(LambdaExpressionSyntax lambdaExpression, ParameterSyntax parameter, CSharpSyntaxNode body);
    [CompilerGeneratedAttribute]
public LambdaExpressionSyntax get_LambdaExpression();
    [CompilerGeneratedAttribute]
public ParameterSyntax get_Parameter();
    [CompilerGeneratedAttribute]
public CSharpSyntaxNode get_Body();
    [NullableContextAttribute("2")]
public ParameterListSyntax get_ParameterList();
    public bool get_IsSimpleLambda();
    public bool get_IsParenthesizedLambda();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static SingleParameterLambdaExpressionInfo Create(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    internal static SingleParameterLambdaExpressionInfo Create(LambdaExpressionSyntax lambdaExpression, bool allowMissing);
    [NullableContextAttribute("2")]
private static SingleParameterLambdaExpressionInfo CreateImpl(LambdaExpressionSyntax lambdaExpression, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.StatementListInfo : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxNode <Parent>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SyntaxList`1<StatementSyntax> <Statements>k__BackingField;
    public SyntaxNode Parent { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SyntaxList`1<StatementSyntax> Statements { get; }
    public bool IsParentBlock { get; }
    public bool IsParentSwitchSection { get; }
    [NullableAttribute("2")]
public BlockSyntax ParentAsBlock { get; }
    [NullableAttribute("2")]
public SwitchSectionSyntax ParentAsSwitchSection { get; }
    public bool Success { get; }
    public int Count { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public StatementSyntax Item { get; }
    internal StatementListInfo(BlockSyntax block);
    internal StatementListInfo(SwitchSectionSyntax switchSection);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Parent();
    [CompilerGeneratedAttribute]
public SyntaxList`1<StatementSyntax> get_Statements();
    public bool get_IsParentBlock();
    public bool get_IsParentSwitchSection();
    [NullableContextAttribute("2")]
public BlockSyntax get_ParentAsBlock();
    [NullableContextAttribute("2")]
public SwitchSectionSyntax get_ParentAsSwitchSection();
    public bool get_Success();
    public sealed virtual int get_Count();
    private string get_DebuggerDisplay();
    public sealed virtual StatementSyntax get_Item(int index);
    private sealed virtual override IEnumerator`1<StatementSyntax> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<StatementSyntax> GetEnumerator();
    [NullableContextAttribute("2")]
internal static StatementListInfo Create(StatementSyntax statementInList);
    internal static StatementListInfo Create(StatementListSelection selectedStatements);
    public StatementListInfo WithStatements(IEnumerable`1<StatementSyntax> statements);
    public StatementListInfo WithStatements(SyntaxList`1<StatementSyntax> statements);
    public StatementListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
    public StatementListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode);
    public StatementListInfo Add(StatementSyntax statement);
    public StatementListInfo AddRange(IEnumerable`1<StatementSyntax> statements);
    public bool Any();
    public StatementSyntax First();
    [NullableContextAttribute("2")]
public StatementSyntax FirstOrDefault();
    public int IndexOf(Func`2<StatementSyntax, bool> predicate);
    public int IndexOf(StatementSyntax statement);
    public StatementListInfo Insert(int index, StatementSyntax statement);
    public StatementListInfo InsertRange(int index, IEnumerable`1<StatementSyntax> statements);
    public StatementSyntax Last();
    [NullableContextAttribute("2")]
public StatementSyntax LastOrDefault();
    public int LastIndexOf(Func`2<StatementSyntax, bool> predicate);
    public int LastIndexOf(StatementSyntax statement);
    public StatementListInfo Remove(StatementSyntax statement);
    public StatementListInfo RemoveAt(int index);
    public StatementListInfo Replace(StatementSyntax statementInList, StatementSyntax newStatement);
    public StatementListInfo ReplaceAt(int index, StatementSyntax newStatement);
    public StatementListInfo ReplaceRange(StatementSyntax statementInList, IEnumerable`1<StatementSyntax> newStatements);
    private void ThrowInvalidOperationIfNotInitialized();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Flags}")]
internal class Roslynator.CSharp.Syntax.StringConcatenationAnalysis : ValueType {
    [CompilerGeneratedAttribute]
private StringConcatenationFlags <Flags>k__BackingField;
    private StringConcatenationFlags Flags { get; }
    public bool ContainsNonStringLiteral { get; }
    public bool ContainsStringLiteral { get; }
    public bool ContainsInterpolatedString { get; }
    public bool ContainsNonVerbatimExpression { get; }
    private StringConcatenationAnalysis(StringConcatenationFlags flags);
    [CompilerGeneratedAttribute]
private StringConcatenationFlags get_Flags();
    public bool get_ContainsNonStringLiteral();
    public bool get_ContainsStringLiteral();
    public bool get_ContainsInterpolatedString();
    public bool get_ContainsNonVerbatimExpression();
    public static StringConcatenationAnalysis Create(StringConcatenationExpressionInfo& stringConcatenation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.StringConcatenationExpressionInfo : ValueType {
    private ExpressionChain _chain;
    public BinaryExpressionSyntax BinaryExpression { get; }
    internal Nullable`1<TextSpan> Span { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private StringConcatenationExpressionInfo(ExpressionChain& chain);
    public BinaryExpressionSyntax get_BinaryExpression();
    internal Nullable`1<TextSpan> get_Span();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal StringConcatenationAnalysis Analyze();
    internal static StringConcatenationExpressionInfo Create(SyntaxNode node, SemanticModel semanticModel, bool walkDownParentheses, CancellationToken cancellationToken);
    internal static StringConcatenationExpressionInfo Create(BinaryExpressionSyntax binaryExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal static StringConcatenationExpressionInfo Create(ExpressionChain& chain, SemanticModel semanticModel, CancellationToken cancellationToken);
    public ExpressionChain AsChain();
    internal InterpolatedStringExpressionSyntax ToInterpolatedStringExpression();
    internal LiteralExpressionSyntax ToStringLiteralExpression();
    internal LiteralExpressionSyntax ToMultiLineStringLiteralExpression();
    private void ThrowInvalidOperationIfNotInitialized();
    private static void ThrowIfContainsNonStringLiteralExpression(StringConcatenationAnalysis& analysis);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.StringLiteralExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private LiteralExpressionSyntax <Expression>k__BackingField;
    public LiteralExpressionSyntax Expression { get; }
    public SyntaxToken Token { get; }
    public string Text { get; }
    public string InnerText { get; }
    public string ValueText { get; }
    public bool IsRegular { get; }
    public bool IsVerbatim { get; }
    public bool ContainsLinefeed { get; }
    public bool ContainsEscapeSequence { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private StringLiteralExpressionInfo(LiteralExpressionSyntax expression);
    [CompilerGeneratedAttribute]
public LiteralExpressionSyntax get_Expression();
    public SyntaxToken get_Token();
    public string get_Text();
    public string get_InnerText();
    public string get_ValueText();
    public bool get_IsRegular();
    public bool get_IsVerbatim();
    public bool get_ContainsLinefeed();
    public bool get_ContainsEscapeSequence();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal static StringLiteralExpressionInfo Create(SyntaxNode node, bool walkDownParentheses);
    [NullableContextAttribute("2")]
internal static StringLiteralExpressionInfo Create(LiteralExpressionSyntax literalExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CSharp.Syntax.SyntaxInfoHelpers : object {
    public static ExpressionSyntax Walk(SyntaxNode node, bool walkDownParentheses);
    [NullableContextAttribute("2")]
public static ExpressionSyntax Walk(ExpressionSyntax expression, bool walkDownParentheses);
    public static ExpressionSyntax WalkAndCheck(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    public static ExpressionSyntax WalkAndCheck(ExpressionSyntax expression, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
private static ExpressionSyntax WalkAndCheck(ExpressionSyntax expression, bool allowMissing);
    [NullableContextAttribute("2")]
public static bool Check(SyntaxNode node, bool allowMissing);
    [NullableContextAttribute("0")]
public static string ToDebugString(bool success, TInfo info, SyntaxNode node, string text);
    public static string ToDebugString(bool success, SyntaxList`1<TNode> list);
    public static string ToDebugString(bool success, SeparatedSyntaxList`1<TNode> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.CSharp.Syntax.TypeParameterConstraintInfo : ValueType {
    [CompilerGeneratedAttribute]
private TypeParameterConstraintSyntax <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeParameterConstraintClauseSyntax <ConstraintClause>k__BackingField;
    public TypeParameterConstraintSyntax Constraint { get; }
    public TypeParameterConstraintClauseSyntax ConstraintClause { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SeparatedSyntaxList`1<TypeParameterConstraintSyntax> Constraints { get; }
    public IdentifierNameSyntax Name { get; }
    public string NameText { get; }
    public bool Success { get; }
    internal bool IsDuplicateConstraint { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private TypeParameterConstraintInfo(TypeParameterConstraintSyntax constraint, TypeParameterConstraintClauseSyntax constraintClause);
    [CompilerGeneratedAttribute]
public TypeParameterConstraintSyntax get_Constraint();
    [CompilerGeneratedAttribute]
public TypeParameterConstraintClauseSyntax get_ConstraintClause();
    public SeparatedSyntaxList`1<TypeParameterConstraintSyntax> get_Constraints();
    public IdentifierNameSyntax get_Name();
    public string get_NameText();
    public bool get_Success();
    internal bool get_IsDuplicateConstraint();
    private string get_DebuggerDisplay();
    internal static TypeParameterConstraintInfo Create(TypeParameterConstraintSyntax constraint, bool allowMissing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.UsingDirectiveListInfo : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxNode <Parent>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SyntaxList`1<UsingDirectiveSyntax> <Usings>k__BackingField;
    public SyntaxNode Parent { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SyntaxList`1<UsingDirectiveSyntax> Usings { get; }
    public bool Success { get; }
    public int Count { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public UsingDirectiveSyntax Item { get; }
    internal UsingDirectiveListInfo(SyntaxNode parent, SyntaxList`1<UsingDirectiveSyntax> usings);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Parent();
    [CompilerGeneratedAttribute]
public SyntaxList`1<UsingDirectiveSyntax> get_Usings();
    public bool get_Success();
    public sealed virtual int get_Count();
    private string get_DebuggerDisplay();
    public sealed virtual UsingDirectiveSyntax get_Item(int index);
    private sealed virtual override IEnumerator`1<UsingDirectiveSyntax> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<UsingDirectiveSyntax> GetEnumerator();
    internal static UsingDirectiveListInfo Create(NamespaceDeclarationSyntax namespaceDeclaration);
    internal static UsingDirectiveListInfo Create(CompilationUnitSyntax compilationUnit);
    internal static UsingDirectiveListInfo Create(SyntaxNode declaration);
    public UsingDirectiveListInfo WithUsings(IEnumerable`1<UsingDirectiveSyntax> usings);
    public UsingDirectiveListInfo WithUsings(SyntaxList`1<UsingDirectiveSyntax> usings);
    public UsingDirectiveListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
    public UsingDirectiveListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode);
    public UsingDirectiveListInfo Add(UsingDirectiveSyntax usingDirective);
    public UsingDirectiveListInfo AddRange(IEnumerable`1<UsingDirectiveSyntax> usings);
    public bool Any();
    public UsingDirectiveSyntax First();
    [NullableContextAttribute("2")]
public UsingDirectiveSyntax FirstOrDefault();
    public int IndexOf(Func`2<UsingDirectiveSyntax, bool> predicate);
    public int IndexOf(UsingDirectiveSyntax usingDirective);
    public UsingDirectiveListInfo Insert(int index, UsingDirectiveSyntax usingDirective);
    public UsingDirectiveListInfo InsertRange(int index, IEnumerable`1<UsingDirectiveSyntax> usings);
    public UsingDirectiveSyntax Last();
    [NullableContextAttribute("2")]
public UsingDirectiveSyntax LastOrDefault();
    public int LastIndexOf(Func`2<UsingDirectiveSyntax, bool> predicate);
    public int LastIndexOf(UsingDirectiveSyntax usingDirective);
    public UsingDirectiveListInfo Remove(UsingDirectiveSyntax usingDirective);
    public UsingDirectiveListInfo RemoveAt(int index);
    public UsingDirectiveListInfo Replace(UsingDirectiveSyntax usingInLine, UsingDirectiveSyntax newUsingDirective);
    public UsingDirectiveListInfo ReplaceAt(int index, UsingDirectiveSyntax newUsingDirective);
    public UsingDirectiveListInfo ReplaceRange(UsingDirectiveSyntax usingInLine, IEnumerable`1<UsingDirectiveSyntax> newUsingDirectives);
    private void ThrowInvalidOperationIfNotInitialized();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.CSharp.Syntax.XmlElementInfo : ValueType {
    [CompilerGeneratedAttribute]
private XmlNodeSyntax <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalName>k__BackingField;
    public XmlNodeSyntax Element { get; }
    public string LocalName { get; }
    public SyntaxKind Kind { get; }
    public bool IsEmptyElement { get; }
    public bool HasAttributes { get; }
    internal bool IsContentEmptyOrWhitespace { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private XmlElementInfo(XmlNodeSyntax element, string localName);
    [CompilerGeneratedAttribute]
public XmlNodeSyntax get_Element();
    [CompilerGeneratedAttribute]
public string get_LocalName();
    public SyntaxKind get_Kind();
    public bool get_IsEmptyElement();
    public bool get_HasAttributes();
    internal bool get_IsContentEmptyOrWhitespace();
    public bool get_Success();
    private string get_DebuggerDisplay();
    internal XmlTag GetTag();
    internal bool HasTag(XmlTag tag);
    internal static XmlElementInfo Create(XmlNodeSyntax node);
    internal bool HasLocalName(string localName, StringComparison comparison);
    internal bool HasLocalName(string localName1, string localName2, StringComparison comparison);
    [CompilerGeneratedAttribute]
internal static bool <get_IsContentEmptyOrWhitespace>g__IsWhitespaceOrNewLine|14_1(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Roslynator.CSharp.SyntaxAccessibility : object {
    public static Accessibility GetDefaultAccessibility(SyntaxNode declaration);
    public static Accessibility GetDefaultExplicitAccessibility(SyntaxNode declaration);
    public static Accessibility GetAccessibility(SyntaxNode declaration);
    public static Accessibility GetExplicitAccessibility(SyntaxNode declaration);
    public static Accessibility GetExplicitAccessibility(SyntaxTokenList modifiers);
    public static bool IsPubliclyVisible(MemberDeclarationSyntax declaration);
    public static TNode WithoutExplicitAccessibility(TNode node);
    public static TNode WithExplicitAccessibility(TNode node, Accessibility newAccessibility, IComparer`1<SyntaxKind> comparer);
    public static bool IsValidAccessibility(SyntaxNode node, Accessibility accessibility, bool ignoreOverride);
    [CompilerGeneratedAttribute]
internal static bool <IsValidAccessibility>g__CheckProtectedInStaticOrSealedClass|8_0(SyntaxNode declaration, <>c__DisplayClass8_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <IsValidAccessibility>g__CheckAccessorAccessibility|8_1(AccessorListSyntax accessorList, <>c__DisplayClass8_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.CSharp.SyntaxAccessibility`1 : object {
    [CompilerGeneratedAttribute]
private static SyntaxAccessibility`1<TNode> <Instance>k__BackingField;
    public static SyntaxAccessibility`1<TNode> Instance { get; }
    private static SyntaxAccessibility`1();
    [CompilerGeneratedAttribute]
public static SyntaxAccessibility`1<TNode> get_Instance();
    private static object GetInstance();
    public abstract virtual Accessibility GetAccessibility(TNode declaration);
    public abstract virtual Accessibility GetDefaultAccessibility(TNode declaration);
    public abstract virtual Accessibility GetExplicitAccessibility(TNode declaration);
    public abstract virtual Accessibility GetDefaultExplicitAccessibility(TNode declaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Roslynator.CSharp.SyntaxDebug : object {
    [ConditionalAttribute("DEBUG")]
internal static void Assert(bool condition, SyntaxNode node);
    [ConditionalAttribute("DEBUG")]
internal static void Assert(bool condition, SyntaxToken token);
    [ConditionalAttribute("DEBUG")]
internal static void Assert(bool condition, SyntaxTrivia trivia);
    [ConditionalAttribute("DEBUG")]
internal static void Fail(SyntaxNode node);
    [ConditionalAttribute("DEBUG")]
internal static void Fail(SyntaxToken token);
    [ConditionalAttribute("DEBUG")]
internal static void Fail(SyntaxTrivia trivia);
    [NullableContextAttribute("1")]
private static void Fail(string text, TextSpan span, SyntaxKind kind, SyntaxTree syntaxTree);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Roslynator.CSharp.SyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsAutoImplemented(AccessorDeclarationSyntax accessorDeclaration);
    [ExtensionAttribute]
public static CSharpSyntaxNode BodyOrExpressionBody(AccessorDeclarationSyntax accessorDeclaration);
    [ExtensionAttribute]
public static AccessorDeclarationSyntax Getter(AccessorListSyntax accessorList);
    [ExtensionAttribute]
public static AccessorDeclarationSyntax Setter(AccessorListSyntax accessorList);
    [ExtensionAttribute]
private static AccessorDeclarationSyntax Accessor(AccessorListSyntax accessorList, SyntaxKind kind);
    [ExtensionAttribute]
private static AccessorDeclarationSyntax Accessor(AccessorListSyntax accessorList, SyntaxKind kind1, SyntaxKind kind2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static StatementSyntax SingleNonBlockStatementOrDefault(BlockSyntax body, bool recursive);
    [ExtensionAttribute]
internal static bool ContainsYield(BlockSyntax block, bool yieldReturn, bool yieldBreak);
    [ExtensionAttribute]
internal static BaseArgumentListSyntax WithArguments(BaseArgumentListSyntax baseArgumentList, SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    [ExtensionAttribute]
public static ExpressionChain AsChain(BinaryExpressionSyntax binaryExpression, Nullable`1<TextSpan> span);
    [ExtensionAttribute]
public static TextSpan ParenthesesSpan(CastExpressionSyntax castExpression);
    [ExtensionAttribute]
public static ClassDeclarationSyntax WithMembers(ClassDeclarationSyntax classDeclaration, MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static ClassDeclarationSyntax WithMembers(ClassDeclarationSyntax classDeclaration, IEnumerable`1<MemberDeclarationSyntax> members);
    [ExtensionAttribute]
public static TextSpan BracesSpan(ClassDeclarationSyntax classDeclaration);
    [ExtensionAttribute]
public static TextSpan ParenthesesSpan(CommonForEachStatementSyntax forEachStatement);
    [ExtensionAttribute]
internal static StatementSyntax EmbeddedStatement(CommonForEachStatementSyntax forEachStatement);
    [ExtensionAttribute]
public static CompilationUnitSyntax WithMembers(CompilationUnitSyntax compilationUnit, MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static CompilationUnitSyntax WithMembers(CompilationUnitSyntax compilationUnit, IEnumerable`1<MemberDeclarationSyntax> members);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddUsings(CompilationUnitSyntax compilationUnit, bool keepSingleLineCommentsOnTop, UsingDirectiveSyntax[] usings);
    [ExtensionAttribute]
internal static ExpressionSyntax RemoveOperatorToken(ConditionalAccessExpressionSyntax conditionalAccessExpression);
    [ExtensionAttribute]
internal static TextSpan HeaderSpan(ConstructorDeclarationSyntax constructorDeclaration);
    [ExtensionAttribute]
public static CSharpSyntaxNode BodyOrExpressionBody(ConstructorDeclarationSyntax constructorDeclaration);
    [ExtensionAttribute]
public static CSharpSyntaxNode BodyOrExpressionBody(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration);
    [ExtensionAttribute]
internal static TextSpan HeaderSpan(ConversionOperatorDeclarationSyntax operatorDeclaration);
    [ExtensionAttribute]
internal static TextSpan ParenthesesSpan(DefaultExpressionSyntax defaultExpression);
    [ExtensionAttribute]
public static bool ReturnsVoid(DelegateDeclarationSyntax delegateDeclaration);
    [ExtensionAttribute]
public static CSharpSyntaxNode BodyOrExpressionBody(DestructorDeclarationSyntax destructorDeclaration);
    [ExtensionAttribute]
internal static TextSpan HeaderSpan(DestructorDeclarationSyntax destructorDeclaration);
    [ExtensionAttribute]
public static DirectiveTriviaSyntax GetNextRelatedDirective(DirectiveTriviaSyntax directiveTrivia);
    [ExtensionAttribute]
private static DirectiveTriviaSyntax GetNextPossiblyRelatedDirective(DirectiveTriviaSyntax directiveTrivia);
    [ExtensionAttribute]
internal static XmlElementSyntax SummaryElement(DocumentationCommentTriviaSyntax documentationComment);
    [ExtensionAttribute]
public static IEnumerable`1<XmlElementSyntax> Elements(DocumentationCommentTriviaSyntax documentationComment, string localName);
    [IteratorStateMachineAttribute("Roslynator.CSharp.SyntaxExtensions/<Elements>d__32")]
[ExtensionAttribute]
internal static IEnumerable`1<XmlElementSyntax> Elements(DocumentationCommentTriviaSyntax documentationComment, XmlTag tag);
    [ExtensionAttribute]
internal static bool IsPartOfMemberDeclaration(DocumentationCommentTriviaSyntax documentationComment);
    [ExtensionAttribute]
internal static StatementSyntax EmbeddedStatement(DoStatementSyntax doStatement);
    [ExtensionAttribute]
internal static StatementSyntax SingleNonBlockStatementOrDefault(ElseClauseSyntax elseClause);
    [ExtensionAttribute]
public static IfStatementSyntax GetTopmostIf(ElseClauseSyntax elseClause);
    [ExtensionAttribute]
internal static StatementSyntax EmbeddedStatement(ElseClauseSyntax elseClause, bool allowIfStatement);
    [ExtensionAttribute]
public static RegionDirectiveTriviaSyntax GetRegionDirective(EndRegionDirectiveTriviaSyntax endRegionDirective);
    [ExtensionAttribute]
public static SyntaxTrivia GetPreprocessingMessageTrivia(EndRegionDirectiveTriviaSyntax endRegionDirective);
    [ExtensionAttribute]
internal static bool HasPreprocessingMessageTrivia(EndRegionDirectiveTriviaSyntax endRegionDirective);
    [ExtensionAttribute]
public static TextSpan BracesSpan(EnumDeclarationSyntax enumDeclaration);
    [ExtensionAttribute]
internal static TextSpan HeaderSpan(EventDeclarationSyntax eventDeclaration);
    [ExtensionAttribute]
public static ExpressionSyntax WalkUpParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static ExpressionSyntax WalkDownParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
internal static ExpressionSyntax WalkDownParenthesesIf(ExpressionSyntax expression, bool condition);
    [ExtensionAttribute]
internal static bool IsNumericLiteralExpression(ExpressionSyntax expression, string valueText);
    [ExtensionAttribute]
internal static StatementSyntax EmbeddedStatement(FixedStatementSyntax fixedStatement);
    [ExtensionAttribute]
public static TextSpan ParenthesesSpan(ForStatementSyntax forStatement);
    [ExtensionAttribute]
internal static StatementSyntax EmbeddedStatement(ForStatementSyntax forStatement);
    [ExtensionAttribute]
internal static StatementSyntax SingleNonBlockStatementOrDefault(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
public static bool IsSimpleIf(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
public static IfStatementSyntax GetTopmostIf(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
public static bool IsTopmostIf(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
internal static IfStatementSyntax GetNextIf(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
internal static IfStatementSyntax GetPreviousIf(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
internal static StatementSyntax EmbeddedStatement(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
public static IfStatementCascade AsCascade(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
public static IfStatementCascadeInfo GetCascadeInfo(IfStatementSyntax ifStatement);
    [ExtensionAttribute]
public static SyntaxList`1<TNode> ToSyntaxList(IEnumerable`1<TNode> nodes);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> ToSeparatedSyntaxList(IEnumerable`1<TNode> nodes);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> ToSeparatedSyntaxList(IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens);
    [ExtensionAttribute]
public static SyntaxTokenList ToSyntaxTokenList(IEnumerable`1<SyntaxToken> tokens);
    [ExtensionAttribute]
internal static TextSpan HeaderSpan(IndexerDeclarationSyntax indexerDeclaration);
    [ExtensionAttribute]
public static AccessorDeclarationSyntax Getter(IndexerDeclarationSyntax indexerDeclaration);
    [ExtensionAttribute]
public static AccessorDeclarationSyntax Setter(IndexerDeclarationSyntax indexerDeclaration);
    [ExtensionAttribute]
public static TextSpan BracesSpan(InterfaceDeclarationSyntax interfaceDeclaration);
    [ExtensionAttribute]
public static InterfaceDeclarationSyntax WithMembers(InterfaceDeclarationSyntax interfaceDeclaration, MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static InterfaceDeclarationSyntax WithMembers(InterfaceDeclarationSyntax interfaceDeclaration, IEnumerable`1<MemberDeclarationSyntax> members);
    [ExtensionAttribute]
public static bool IsVerbatim(InterpolatedStringExpressionSyntax interpolatedString);
    [ExtensionAttribute]
internal static ExpressionSyntax WalkDownMethodChain(InvocationExpressionSyntax invocationExpression, bool walkInvocation, bool walkElementAccess);
    [ExtensionAttribute]
public static bool IsHexNumericLiteral(LiteralExpressionSyntax literalExpression);
    [ExtensionAttribute]
public static CSharpSyntaxNode BodyOrExpressionBody(LocalFunctionStatementSyntax localFunctionStatement);
    [ExtensionAttribute]
public static bool ReturnsVoid(LocalFunctionStatementSyntax localFunctionStatement);
    [ExtensionAttribute]
public static bool ContainsYield(LocalFunctionStatementSyntax localFunctionStatement);
    [ExtensionAttribute]
internal static TextSpan HeaderSpan(LocalFunctionStatementSyntax localFunction);
    [ExtensionAttribute]
internal static StatementSyntax EmbeddedStatement(LockStatementSyntax lockStatement);
    [ExtensionAttribute]
public static SyntaxTrivia GetSingleLineDocumentationCommentTrivia(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static SyntaxTrivia GetDocumentationCommentTrivia(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static DocumentationCommentTriviaSyntax GetSingleLineDocumentationComment(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static DocumentationCommentTriviaSyntax GetDocumentationComment(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static bool HasSingleLineDocumentationComment(MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static bool HasDocumentationComment(MemberDeclarationSyntax member);
    [ExtensionAttribute]
internal static TMember WithNewSingleLineDocumentationComment(TMember member, DocumentationCommentGeneratorSettings settings);
    [ExtensionAttribute]
internal static TMember WithBaseOrNewSingleLineDocumentationComment(TMember member, SemanticModel semanticModel, DocumentationCommentGeneratorSettings settings, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static TMember WithDocumentationComment(TMember member, SyntaxTrivia comment, bool indent);
    [ExtensionAttribute]
public static bool ContainsYield(MethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
public static bool ReturnsVoid(MethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
internal static TextSpan HeaderSpan(MethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
public static CSharpSyntaxNode BodyOrExpressionBody(MethodDeclarationSyntax methodDeclaration);
    [ExtensionAttribute]
public static NamespaceDeclarationSyntax WithMembers(NamespaceDeclarationSyntax namespaceDeclaration, MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static NamespaceDeclarationSyntax WithMembers(NamespaceDeclarationSyntax namespaceDeclaration, IEnumerable`1<MemberDeclarationSyntax> members);
    [ExtensionAttribute]
public static TextSpan BracesSpan(NamespaceDeclarationSyntax namespaceDeclaration);
    [ExtensionAttribute]
public static CSharpSyntaxNode BodyOrExpressionBody(OperatorDeclarationSyntax operatorDeclaration);
    [ExtensionAttribute]
internal static TextSpan HeaderSpan(OperatorDeclarationSyntax operatorDeclaration);
    [ExtensionAttribute]
public static bool IsParams(ParameterSyntax parameter);
    [ExtensionAttribute]
internal static TextSpan HeaderSpan(PropertyDeclarationSyntax propertyDeclaration);
    [ExtensionAttribute]
public static AccessorDeclarationSyntax Getter(PropertyDeclarationSyntax propertyDeclaration);
    [ExtensionAttribute]
public static AccessorDeclarationSyntax Setter(PropertyDeclarationSyntax propertyDeclaration);
    [ExtensionAttribute]
internal static PropertyDeclarationSyntax ReplaceAccessor(PropertyDeclarationSyntax propertyDeclaration, AccessorDeclarationSyntax accessor, AccessorDeclarationSyntax newAccessor);
    [ExtensionAttribute]
public static RecordDeclarationSyntax WithMembers(RecordDeclarationSyntax recordDeclaration, MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static RecordDeclarationSyntax WithMembers(RecordDeclarationSyntax recordDeclaration, IEnumerable`1<MemberDeclarationSyntax> members);
    [ExtensionAttribute]
public static TextSpan BracesSpan(RecordDeclarationSyntax recordDeclaration);
    [ExtensionAttribute]
public static EndRegionDirectiveTriviaSyntax GetEndRegionDirective(RegionDirectiveTriviaSyntax regionDirective);
    [ExtensionAttribute]
public static SyntaxTrivia GetPreprocessingMessageTrivia(RegionDirectiveTriviaSyntax regionDirective);
    [ExtensionAttribute]
internal static bool HasPreprocessingMessageTrivia(RegionDirectiveTriviaSyntax regionDirective);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int LastIndexOf(SeparatedSyntaxList`1<TNode> list, SyntaxKind kind);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool Contains(SeparatedSyntaxList`1<TNode> list, SyntaxKind kind);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TNode Find(SeparatedSyntaxList`1<TNode> list, SyntaxKind kind);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static bool IsSingleLine(SeparatedSyntaxList`1<TNode> list, bool includeExteriorTrivia, bool trim, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static bool IsMultiLine(SeparatedSyntaxList`1<TNode> list, bool includeExteriorTrivia, bool trim, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static TextSpan GetSpan(SeparatedSyntaxList`1<TNode> list, bool includeExteriorTrivia, bool trim);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> ReplaceRange(SeparatedSyntaxList`1<TNode> list, int index, int count, TNode newNode);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> ReplaceRange(SeparatedSyntaxList`1<TNode> list, int index, int count, IEnumerable`1<TNode> newNodes);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> RemoveRange(SeparatedSyntaxList`1<TNode> list, int index, int count);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> TrimTrivia(SeparatedSyntaxList`1<TNode> list);
    [ExtensionAttribute]
internal static int IndexOf(SeparatedSyntaxList`1<ParameterSyntax> parameters, string name);
    [ExtensionAttribute]
internal static int IndexOf(SeparatedSyntaxList`1<TypeParameterSyntax> typeParameters, string name);
    [ExtensionAttribute]
internal static SeparatedSyntaxList`1<TResult> ForEach(SeparatedSyntaxList`1<TSource> list, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static StatementSyntax PreviousStatement(StatementSyntax statement);
    [ExtensionAttribute]
public static StatementSyntax NextStatement(StatementSyntax statement);
    [ExtensionAttribute]
public static bool TryGetContainingList(StatementSyntax statement, SyntaxList`1& statements);
    [ExtensionAttribute]
internal static StatementSyntax SingleNonBlockStatementOrDefault(StatementSyntax statement, bool recursive);
    [ExtensionAttribute]
public static bool IsEmbedded(StatementSyntax statement, bool canBeBlock, bool canBeIfInsideElse, bool canBeUsingInsideUsing);
    [ExtensionAttribute]
public static StructDeclarationSyntax WithMembers(StructDeclarationSyntax structDeclaration, MemberDeclarationSyntax member);
    [ExtensionAttribute]
public static StructDeclarationSyntax WithMembers(StructDeclarationSyntax structDeclaration, IEnumerable`1<MemberDeclarationSyntax> members);
    [ExtensionAttribute]
public static TextSpan BracesSpan(StructDeclarationSyntax structDeclaration);
    [ExtensionAttribute]
public static bool ContainsDefaultLabel(SwitchSectionSyntax switchSection);
    [ExtensionAttribute]
internal static SyntaxList`1<StatementSyntax> GetStatements(SwitchSectionSyntax switchSection);
    [ExtensionAttribute]
public static SwitchSectionSyntax DefaultSection(SwitchStatementSyntax switchStatement);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int LastIndexOf(SyntaxList`1<TNode> list, SyntaxKind kind);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool Contains(SyntaxList`1<TNode> list, SyntaxKind kind);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static TNode Find(SyntaxList`1<TNode> list, SyntaxKind kind);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static bool IsSingleLine(SyntaxList`1<TNode> list, bool includeExteriorTrivia, bool trim, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static bool IsMultiLine(SyntaxList`1<TNode> list, bool includeExteriorTrivia, bool trim, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static TextSpan GetSpan(SyntaxList`1<TNode> list, bool includeExteriorTrivia, bool trim);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static StatementSyntax SingleOrDefault(SyntaxList`1<StatementSyntax> statements, bool ignoreLocalFunctions, bool shouldThrow);
    [ExtensionAttribute]
public static bool IsLast(SyntaxList`1<StatementSyntax> statements, StatementSyntax statement, bool ignoreLocalFunctions);
    [ExtensionAttribute]
public static SyntaxList`1<StatementSyntax> Add(SyntaxList`1<StatementSyntax> statements, StatementSyntax statement, bool ignoreLocalFunctions);
    [ExtensionAttribute]
public static SyntaxList`1<TNode> ReplaceRange(SyntaxList`1<TNode> list, int index, int count, TNode newNode);
    [ExtensionAttribute]
public static SyntaxList`1<TNode> ReplaceRange(SyntaxList`1<TNode> list, int index, int count, IEnumerable`1<TNode> newNodes);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxList`1<TNode> RemoveRange(SyntaxList`1<TNode> list, int index, int count);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static StatementSyntax LastOrDefault(SyntaxList`1<StatementSyntax> statements, bool ignoreLocalFunction);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxList`1<TNode> TrimTrivia(SyntaxList`1<TNode> list);
    [ExtensionAttribute]
internal static IEnumerable`1<DirectiveTriviaSyntax> DescendantPreprocessorDirectives(SyntaxNode node, Func`2<DirectiveTriviaSyntax, bool> predicate);
    [IteratorStateMachineAttribute("Roslynator.CSharp.SyntaxExtensions/<DescendantPreprocessorDirectives>d__145")]
[ExtensionAttribute]
internal static IEnumerable`1<DirectiveTriviaSyntax> DescendantPreprocessorDirectives(SyntaxNode node, TextSpan span, Func`2<DirectiveTriviaSyntax, bool> predicate);
    [ExtensionAttribute]
public static bool IsDescendantOf(SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    [ExtensionAttribute]
internal static bool IsSingleLine(SyntaxNode node, bool includeExteriorTrivia, bool trim, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsMultiLine(SyntaxNode node, bool includeExteriorTrivia, bool trim, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static TextSpan GetSpan(SyntaxNode node, bool includeExteriorTrivia, bool trim);
    private static int GetStartIndex(SyntaxNode node, bool includeExteriorTrivia, bool trim);
    private static int GetEndIndex(SyntaxNode node, bool includeExteriorTrivia, bool trim);
    [ExtensionAttribute]
public static TNode TrimLeadingTrivia(TNode node);
    [ExtensionAttribute]
public static TNode TrimTrailingTrivia(TNode node);
    [ExtensionAttribute]
public static TNode TrimTrivia(TNode node);
    [ExtensionAttribute]
internal static TextSpan TrimmedSpan(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode FirstAncestor(SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia);
    [ExtensionAttribute]
public static SyntaxNode FirstAncestor(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia);
    [ExtensionAttribute]
public static SyntaxNode FirstAncestor(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia);
    [ExtensionAttribute]
public static SyntaxNode FirstAncestor(SyntaxNode node, Func`2<SyntaxNode, bool> predicate, bool ascendOutOfTrivia);
    [ExtensionAttribute]
public static SyntaxNode FirstAncestorOrSelf(SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia);
    [ExtensionAttribute]
public static SyntaxNode FirstAncestorOrSelf(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia);
    [ExtensionAttribute]
public static SyntaxNode FirstAncestorOrSelf(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia);
    [ExtensionAttribute]
public static SyntaxNode FirstAncestorOrSelf(SyntaxNode node, Func`2<SyntaxNode, bool> predicate, bool ascendOutOfTrivia);
    [ExtensionAttribute]
internal static TRoot RemoveNode(TRoot root, SyntaxNode node);
    [ExtensionAttribute]
internal static TNode RemoveStatement(TNode node, StatementSyntax statement);
    [ExtensionAttribute]
internal static TNode RemoveModifier(TNode node, SyntaxKind modifierKind);
    [ExtensionAttribute]
internal static TNode RemoveModifiers(TNode node, SyntaxKind modifierKind1, SyntaxKind modifierKind2);
    [ExtensionAttribute]
internal static TNode RemoveModifier(TNode node, SyntaxToken modifier);
    [ExtensionAttribute]
internal static TNode InsertModifier(TNode node, SyntaxKind modifierKind, IComparer`1<SyntaxKind> comparer);
    [ExtensionAttribute]
public static TNode RemoveTrivia(TNode node, Nullable`1<TextSpan> span);
    [ExtensionAttribute]
public static TNode RemoveWhitespace(TNode node, Nullable`1<TextSpan> span);
    [ExtensionAttribute]
public static TNode ReplaceWhitespace(TNode node, SyntaxTrivia replacement, Nullable`1<TextSpan> span);
    [ExtensionAttribute]
internal static bool IsPartOfDocumentationComment(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInExpressionTree(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsUnbalancedIfElseDirectives(SyntaxNode node);
    [ExtensionAttribute]
public static bool ContainsUnbalancedIfElseDirectives(SyntaxNode node, TextSpan span);
    [ExtensionAttribute]
public static DirectiveTriviaSyntax GetFirstDirective(SyntaxNode node, TextSpan span, Func`2<DirectiveTriviaSyntax, bool> predicate);
    [ExtensionAttribute]
internal static DirectiveTriviaSyntax GetLastDirective(SyntaxNode node, TextSpan span, Func`2<DirectiveTriviaSyntax, bool> predicate);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    [ExtensionAttribute]
public static SyntaxToken TrimLeadingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken TrimTrailingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken TrimTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static bool Contains(SyntaxTokenList tokenList, SyntaxKind kind);
    [ExtensionAttribute]
public static bool ContainsAny(SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool ContainsAny(SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [ExtensionAttribute]
public static bool ContainsAny(SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [ExtensionAttribute]
public static bool ContainsAny(SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    [ExtensionAttribute]
internal static bool ContainsAny(SyntaxTokenList tokenList, int rawKind1, int rawKind2);
    [ExtensionAttribute]
internal static bool ContainsAny(SyntaxTokenList tokenList, int rawKind1, int rawKind2, int rawKind3);
    [ExtensionAttribute]
internal static bool ContainsAny(SyntaxTokenList tokenList, int rawKind1, int rawKind2, int rawKind3, int rawKind4);
    [ExtensionAttribute]
internal static bool ContainsAny(SyntaxTokenList tokenList, int rawKind1, int rawKind2, int rawKind3, int rawKind4, int rawKind5);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    [ExtensionAttribute]
public static SyntaxToken Find(SyntaxTokenList tokenList, SyntaxKind kind);
    [ExtensionAttribute]
internal static SyntaxTokenList Replace(SyntaxTokenList tokens, SyntaxKind kind, SyntaxKind newKind);
    [ExtensionAttribute]
public static SyntaxTokenList RemoveRange(SyntaxTokenList list, int index, int count);
    [ExtensionAttribute]
public static SyntaxTokenList ReplaceRange(SyntaxTokenList list, int index, int count, IEnumerable`1<SyntaxToken> newTokens);
    [ExtensionAttribute]
public static bool IsKind(SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool IsKind(SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [ExtensionAttribute]
public static bool IsKind(SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [ExtensionAttribute]
public static bool IsKind(SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    [ExtensionAttribute]
public static bool IsKind(SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    [ExtensionAttribute]
public static bool IsWhitespaceTrivia(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsEndOfLineTrivia(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsWhitespaceOrEndOfLineTrivia(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static bool IsDocumentationCommentTrivia(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static bool IsElasticMarker(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static int LastIndexOf(SyntaxTriviaList triviaList, SyntaxKind kind);
    [ExtensionAttribute]
public static bool Contains(SyntaxTriviaList triviaList, SyntaxKind kind);
    [ExtensionAttribute]
public static SyntaxTrivia Find(SyntaxTriviaList triviaList, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsEmptyOrWhitespace(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
internal static bool IsEmptyOrSingleWhitespaceTrivia(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
internal static SyntaxTriviaList EmptyIfWhitespace(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
internal static bool IsSingleElasticMarker(SyntaxTriviaList triviaList);
    [ExtensionAttribute]
public static SyntaxTriviaList RemoveRange(SyntaxTriviaList list, int index, int count);
    [ExtensionAttribute]
public static SyntaxTriviaList ReplaceRange(SyntaxTriviaList list, int index, int count, IEnumerable`1<SyntaxTrivia> newTrivia);
    [ExtensionAttribute]
internal static SyntaxTriviaList TrimStart(SyntaxTriviaList trivia);
    [ExtensionAttribute]
internal static SyntaxTriviaList TrimEnd(SyntaxTriviaList trivia);
    [ExtensionAttribute]
internal static TypeDeclarationSyntax WithMembers(TypeDeclarationSyntax typeDeclaration, SyntaxList`1<MemberDeclarationSyntax> newMembers);
    [ExtensionAttribute]
public static bool IsVoid(TypeSyntax type);
    [ExtensionAttribute]
internal static IdentifierNameSyntax GetRootNamespace(UsingDirectiveSyntax usingDirective);
    [ExtensionAttribute]
public static CSharpSyntaxNode DeclarationOrExpression(UsingStatementSyntax usingStatement);
    [ExtensionAttribute]
internal static StatementSyntax EmbeddedStatement(UsingStatementSyntax usingStatement, bool allowUsingStatement);
    [ExtensionAttribute]
internal static StatementSyntax EmbeddedStatement(WhileStatementSyntax whileStatement);
    [ExtensionAttribute]
internal static bool HasTag(XmlElementSyntax xmlElement, XmlTag tag);
    [ExtensionAttribute]
internal static XmlTag GetTag(XmlElementSyntax xmlElement);
    [ExtensionAttribute]
internal static bool IsLocalName(XmlElementSyntax xmlElement, string localName, StringComparison comparison);
    [ExtensionAttribute]
internal static string GetAttributeValueText(XmlElementSyntax element, string attributeName);
    [ExtensionAttribute]
internal static IdentifierNameSyntax GetAttributeValue(XmlElementSyntax element, string attributeName);
    [ExtensionAttribute]
internal static XmlElementSyntax UpdateName(XmlElementSyntax element, string newName);
    [ExtensionAttribute]
internal static string GetAttributeValueText(XmlEmptyElementSyntax element, string attributeName);
    [ExtensionAttribute]
internal static IdentifierNameSyntax GetAttributeValue(XmlEmptyElementSyntax element, string attributeName);
    [ExtensionAttribute]
internal static bool HasTag(XmlEmptyElementSyntax xmlElement, XmlTag tag);
    [ExtensionAttribute]
internal static XmlTag GetTag(XmlEmptyElementSyntax xmlElement);
    [ExtensionAttribute]
internal static bool IsLocalName(XmlEmptyElementSyntax xmlEmptyElement, string localName, StringComparison comparison);
    [ExtensionAttribute]
internal static bool IsLocalName(XmlNameSyntax xmlName, string localName, StringComparison comparison);
    [ExtensionAttribute]
public static bool IsYieldBreak(YieldStatementSyntax yieldStatement);
    [ExtensionAttribute]
public static bool IsYieldReturn(YieldStatementSyntax yieldStatement);
    [CompilerGeneratedAttribute]
internal static bool <IsInExpressionTree>g__IsMethodThatAcceptsExpressionAsFirstParameter|185_0(SymbolInfo info);
    [CompilerGeneratedAttribute]
internal static bool <IsInExpressionTree>g__IsMethodThatAcceptsExpressionAsFirstParameter2|185_1(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Roslynator.CSharp.SyntaxInfo : object {
    public static AsExpressionInfo AsExpressionInfo(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    public static AsExpressionInfo AsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses, bool allowMissing);
    public static AssignmentExpressionInfo AssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    public static AssignmentExpressionInfo AssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses, bool allowMissing);
    public static BinaryExpressionInfo BinaryExpressionInfo(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    public static BinaryExpressionInfo BinaryExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses, bool allowMissing);
    public static ConditionalExpressionInfo ConditionalExpressionInfo(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
public static ConditionalExpressionInfo ConditionalExpressionInfo(ConditionalExpressionSyntax conditionalExpression, bool walkDownParentheses, bool allowMissing);
    internal static ConditionalStatementInfo ConditionalStatementInfo(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    [NullableContextAttribute("2")]
internal static ConditionalStatementInfo ConditionalStatementInfo(IfStatementSyntax ifStatement, bool walkDownParentheses, bool allowMissing);
    public static GenericInfo GenericInfo(SyntaxNode node);
    public static GenericInfo GenericInfo(TypeParameterConstraintSyntax typeParameterConstraint);
    public static GenericInfo GenericInfo(TypeParameterConstraintClauseSyntax constraintClause);
    public static GenericInfo GenericInfo(TypeParameterSyntax typeParameter);
    public static GenericInfo GenericInfo(TypeParameterListSyntax typeParameterList);
    public static GenericInfo GenericInfo(TypeDeclarationSyntax typeDeclaration);
    public static GenericInfo GenericInfo(DelegateDeclarationSyntax delegateDeclaration);
    public static GenericInfo GenericInfo(LocalFunctionStatementSyntax localFunctionStatement);
    public static GenericInfo GenericInfo(MethodDeclarationSyntax methodDeclaration);
    internal static HexNumericLiteralExpressionInfo HexNumericLiteralExpressionInfo(SyntaxNode node, bool walkDownParentheses);
    internal static HexNumericLiteralExpressionInfo HexNumericLiteralExpressionInfo(LiteralExpressionSyntax literalExpression);
    public static IsExpressionInfo IsExpressionInfo(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    public static IsExpressionInfo IsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses, bool allowMissing);
    public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing);
    public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(ExpressionSyntax value, bool allowMissing);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(SyntaxNode node);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(CompilationUnitSyntax compilationUnit);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(NamespaceDeclarationSyntax declaration);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(TypeDeclarationSyntax declaration);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(ClassDeclarationSyntax declaration);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(StructDeclarationSyntax declaration);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(InterfaceDeclarationSyntax declaration);
    internal static MemberDeclarationListInfo MemberDeclarationListInfo(MemberDeclarationListSelection selectedMembers);
    public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing);
    public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(SyntaxNode node, bool allowMissing);
    public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(ExpressionStatementSyntax expressionStatement, bool allowMissing);
    public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing);
    public static ModifierListInfo ModifierListInfo(SyntaxNode node);
    public static ModifierListInfo ModifierListInfo(ClassDeclarationSyntax classDeclaration);
    public static ModifierListInfo ModifierListInfo(ConstructorDeclarationSyntax constructorDeclaration);
    public static ModifierListInfo ModifierListInfo(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration);
    public static ModifierListInfo ModifierListInfo(DelegateDeclarationSyntax delegateDeclaration);
    public static ModifierListInfo ModifierListInfo(DestructorDeclarationSyntax destructorDeclaration);
    public static ModifierListInfo ModifierListInfo(EnumDeclarationSyntax enumDeclaration);
    public static ModifierListInfo ModifierListInfo(EventDeclarationSyntax eventDeclaration);
    public static ModifierListInfo ModifierListInfo(EventFieldDeclarationSyntax eventFieldDeclaration);
    public static ModifierListInfo ModifierListInfo(FieldDeclarationSyntax fieldDeclaration);
    public static ModifierListInfo ModifierListInfo(IndexerDeclarationSyntax indexerDeclaration);
    public static ModifierListInfo ModifierListInfo(InterfaceDeclarationSyntax interfaceDeclaration);
    public static ModifierListInfo ModifierListInfo(MethodDeclarationSyntax methodDeclaration);
    public static ModifierListInfo ModifierListInfo(OperatorDeclarationSyntax operatorDeclaration);
    public static ModifierListInfo ModifierListInfo(PropertyDeclarationSyntax propertyDeclaration);
    public static ModifierListInfo ModifierListInfo(StructDeclarationSyntax structDeclaration);
    public static ModifierListInfo ModifierListInfo(IncompleteMemberSyntax incompleteMember);
    public static ModifierListInfo ModifierListInfo(AccessorDeclarationSyntax accessorDeclaration);
    public static ModifierListInfo ModifierListInfo(LocalDeclarationStatementSyntax localDeclarationStatement);
    public static ModifierListInfo ModifierListInfo(LocalFunctionStatementSyntax localFunctionStatement);
    public static ModifierListInfo ModifierListInfo(ParameterSyntax parameter);
    public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, NullCheckStyles allowedStyles, bool walkDownParentheses, bool allowMissing);
    public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, SemanticModel semanticModel, NullCheckStyles allowedStyles, bool walkDownParentheses, bool allowMissing, CancellationToken cancellationToken);
    internal static ParameterInfo ParameterInfo(ConstructorDeclarationSyntax constructorDeclaration, bool allowMissing);
    internal static ParameterInfo ParameterInfo(MethodDeclarationSyntax methodDeclaration, bool allowMissing);
    internal static ParameterInfo ParameterInfo(OperatorDeclarationSyntax operatorDeclaration, bool allowMissing);
    internal static ParameterInfo ParameterInfo(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration, bool allowMissing);
    internal static ParameterInfo ParameterInfo(DelegateDeclarationSyntax delegateDeclaration, bool allowMissing);
    internal static ParameterInfo ParameterInfo(LocalFunctionStatementSyntax localFunction, bool allowMissing);
    internal static ParameterInfo ParameterInfo(IndexerDeclarationSyntax indexerDeclaration, bool allowMissing);
    internal static ParameterInfo ParameterInfo(SimpleLambdaExpressionSyntax simpleLambda, bool allowMissing);
    internal static ParameterInfo ParameterInfo(ParenthesizedLambdaExpressionSyntax parenthesizedLambda, bool allowMissing);
    internal static ParameterInfo ParameterInfo(AnonymousMethodExpressionSyntax anonymousMethod, bool allowMissing);
    internal static RegionInfo RegionInfo(SyntaxNode node);
    public static RegionInfo RegionInfo(RegionDirectiveTriviaSyntax regionDirective);
    public static RegionInfo RegionInfo(EndRegionDirectiveTriviaSyntax endRegionDirective);
    public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses, bool allowMissing);
    public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(StatementSyntax statement, bool walkDownParentheses, bool allowMissing);
    public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses, bool allowMissing);
    public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(ExpressionStatementSyntax expressionStatement, bool walkDownParentheses, bool allowMissing);
    public static SimpleIfStatementInfo SimpleIfStatementInfo(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    public static SimpleIfStatementInfo SimpleIfStatementInfo(IfStatementSyntax ifStatement, bool walkDownParentheses, bool allowMissing);
    public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(StatementSyntax statement, bool allowMissing);
    public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing);
    public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(VariableDeclarationSyntax variableDeclaration, bool allowMissing);
    public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(ExpressionSyntax value);
    public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(SyntaxNode node, bool walkDownParentheses, bool allowMissing);
    public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(LambdaExpressionSyntax lambdaExpression, bool allowMissing);
    public static StatementListInfo StatementListInfo(StatementSyntax statementInList);
    internal static StatementListInfo StatementListInfo(StatementListSelection selectedStatements);
    public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(SyntaxNode node, SemanticModel semanticModel, bool walkDownParentheses, CancellationToken cancellationToken);
    public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(BinaryExpressionSyntax binaryExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(ExpressionChain& expressionChain, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static StringLiteralExpressionInfo StringLiteralExpressionInfo(SyntaxNode node, bool walkDownParentheses);
    public static StringLiteralExpressionInfo StringLiteralExpressionInfo(LiteralExpressionSyntax literalExpression);
    internal static TypeParameterConstraintInfo TypeParameterConstraintInfo(TypeParameterConstraintSyntax constraint, bool allowMissing);
    public static UsingDirectiveListInfo UsingDirectiveListInfo(SyntaxNode node);
    public static UsingDirectiveListInfo UsingDirectiveListInfo(CompilationUnitSyntax compilationUnit);
    public static UsingDirectiveListInfo UsingDirectiveListInfo(NamespaceDeclarationSyntax declaration);
    public static XmlElementInfo XmlElementInfo(XmlNodeSyntax xmlNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslynator.CSharp.SyntaxRefactorings : object {
    public static SyntaxRemoveOptions DefaultRemoveOptions { get; }
    public static SyntaxRemoveOptions get_DefaultRemoveOptions();
    public static T AddAttributeLists(T node, AttributeListSyntax[] attributeLists);
    public static T AddAttributeLists(T node, bool keepDocumentationCommentOnTop, AttributeListSyntax[] attributeLists);
    [ExtensionAttribute]
private static T AddAttributeLists(T node, bool keepDocumentationCommentOnTop, AttributeListSyntax[] attributeLists, Func`2<T, bool> hasAttributeLists, Func`3<T, SyntaxList`1<AttributeListSyntax>, T> withAttributeLists, Func`3<T, AttributeListSyntax[], T> addAttributeLists);
    public static TRoot RemoveNode(TRoot root, SyntaxNode node);
    public static SyntaxRemoveOptions GetRemoveOptions(SyntaxNode node);
    public static SyntaxRemoveOptions GetRemoveOptions(CSharpSyntaxNode node);
    internal static TMemberDeclaration RemoveSingleLineDocumentationComment(TMemberDeclaration declaration);
    internal static TNode RemoveSingleLineDocumentationComment(TNode node, DocumentationCommentTriviaSyntax documentationComment);
    public static TNode RemoveComments(TNode node, CommentFilter comments);
    public static TNode RemoveComments(TNode node, TextSpan span, CommentFilter comments);
    public static TNode RemoveTrivia(TNode node, Nullable`1<TextSpan> span);
    public static TNode RemoveWhitespace(TNode node, Nullable`1<TextSpan> span);
    public static ClassDeclarationSyntax RemoveMember(ClassDeclarationSyntax classDeclaration, MemberDeclarationSyntax member);
    public static CompilationUnitSyntax RemoveMember(CompilationUnitSyntax compilationUnit, MemberDeclarationSyntax member);
    public static InterfaceDeclarationSyntax RemoveMember(InterfaceDeclarationSyntax interfaceDeclaration, MemberDeclarationSyntax member);
    public static NamespaceDeclarationSyntax RemoveMember(NamespaceDeclarationSyntax namespaceDeclaration, MemberDeclarationSyntax member);
    public static StructDeclarationSyntax RemoveMember(StructDeclarationSyntax structDeclaration, MemberDeclarationSyntax member);
    public static RecordDeclarationSyntax RemoveMember(RecordDeclarationSyntax recordDeclaration, MemberDeclarationSyntax member);
    public static TypeDeclarationSyntax RemoveMember(TypeDeclarationSyntax typeDeclaration, MemberDeclarationSyntax member);
    public static EnumDeclarationSyntax RemoveMember(EnumDeclarationSyntax typeDeclaration, EnumMemberDeclarationSyntax member);
    private static T RemoveNode(T declaration, Func`2<T, SyntaxList`1<MemberDeclarationSyntax>> getMembers, int index, SyntaxRemoveOptions removeOptions);
    private static T RemoveNode(T declaration, Func`2<T, SeparatedSyntaxList`1<EnumMemberDeclarationSyntax>> getMembers, int index, SyntaxRemoveOptions removeOptions);
    public static BlockSyntax RemoveUnsafeContext(UnsafeStatementSyntax unsafeStatement);
    [IteratorStateMachineAttribute("Roslynator.CSharp.SyntaxRefactorings/<SplitAttributeList>d__25")]
public static IEnumerable`1<AttributeListSyntax> SplitAttributeList(AttributeListSyntax attributeList);
    public static AttributeListSyntax JoinAttributes(IList`1<AttributeListSyntax> lists);
    public static InvocationExpressionSyntax ChangeInvokedMethodName(InvocationExpressionSyntax invocationExpression, string newName);
    public static LiteralExpressionSyntax ReplaceStringLiteralWithCharacterLiteral(LiteralExpressionSyntax literalExpression);
    public static ForStatementSyntax ConvertWhileStatementToForStatement(WhileStatementSyntax whileStatement, VariableDeclarationSyntax declaration, SeparatedSyntaxList`1<ExpressionSyntax> initializers);
    public static BinaryExpressionSyntax SwapBinaryOperands(BinaryExpressionSyntax binaryExpression);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <RemoveComments>g__AddTrivia|11_1(SyntaxTrivia trivia, <>c__DisplayClass11_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <RemoveComments>g__RemoveMultiline|11_2(SyntaxTrivia trivia, <>c__DisplayClass11_0`1& );
    [CompilerGeneratedAttribute]
internal static SimpleNameSyntax <ChangeInvokedMethodName>g__ChangeName|27_0(SimpleNameSyntax simpleName, <>c__DisplayClass27_0& );
    [CompilerGeneratedAttribute]
internal static string <ReplaceStringLiteralWithCharacterLiteral>g__GetCharacterLiteralText|28_0(<>c__DisplayClass28_0& );
}
internal class Roslynator.CSharp.SyntaxRewriters.BinaryExpressionToMultiLineRewriter : CSharpSyntaxRewriter {
    private SyntaxTriviaList _leadingTrivia;
    [NullableAttribute("2")]
private BinaryExpressionSyntax _previous;
    public BinaryExpressionToMultiLineRewriter(SyntaxTriviaList leadingTrivia);
    [NullableContextAttribute("1")]
public virtual SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.SyntaxRewriters.RenameRewriter : CSharpSyntaxRewriter {
    private string _name;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public string NewName { get; }
    public ISymbol Symbol { get; }
    public SemanticModel SemanticModel { get; }
    public CancellationToken CancellationToken { get; }
    public RenameRewriter(ISymbol symbol, string newName, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    public virtual SyntaxNode VisitIdentifierName(IdentifierNameSyntax node);
    protected virtual SyntaxNode Rename(IdentifierNameSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.SyntaxRewriters.SkipFunctionRewriter : CSharpSyntaxRewriter {
    public virtual SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual SyntaxNode VisitLocalFunctionStatement(LocalFunctionStatementSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.SyntaxRewriters.TriviaRemover : CSharpSyntaxRewriter {
    [CompilerGeneratedAttribute]
private static TriviaRemover <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextSpan> <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <Replacement>k__BackingField;
    private static TriviaRemover Default { get; }
    public Nullable`1<TextSpan> Span { get; }
    public static SyntaxTrivia Replacement { get; }
    private TriviaRemover(Nullable`1<TextSpan> span);
    private static TriviaRemover();
    [CompilerGeneratedAttribute]
private static TriviaRemover get_Default();
    [CompilerGeneratedAttribute]
public Nullable`1<TextSpan> get_Span();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_Replacement();
    public static TriviaRemover GetInstance(Nullable`1<TextSpan> span);
    public virtual SyntaxTrivia VisitTrivia(SyntaxTrivia trivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.SyntaxRewriters.WhitespaceRemover : CSharpSyntaxRewriter {
    [CompilerGeneratedAttribute]
private static WhitespaceRemover <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextSpan> <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <Replacement>k__BackingField;
    private static WhitespaceRemover Default { get; }
    public Nullable`1<TextSpan> Span { get; }
    public static SyntaxTrivia Replacement { get; }
    private WhitespaceRemover(Nullable`1<TextSpan> span);
    private static WhitespaceRemover();
    [CompilerGeneratedAttribute]
private static WhitespaceRemover get_Default();
    [CompilerGeneratedAttribute]
public Nullable`1<TextSpan> get_Span();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_Replacement();
    public static WhitespaceRemover GetInstance(Nullable`1<TextSpan> span);
    public virtual SyntaxTrivia VisitTrivia(SyntaxTrivia trivia);
}
internal class Roslynator.CSharp.SyntaxRewriters.WhitespaceReplacer : CSharpSyntaxRewriter {
    [CompilerGeneratedAttribute]
private SyntaxTrivia <Replacement>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextSpan> <Span>k__BackingField;
    public SyntaxTrivia Replacement { get; }
    public Nullable`1<TextSpan> Span { get; }
    public WhitespaceReplacer(SyntaxTrivia replacement, Nullable`1<TextSpan> span);
    [CompilerGeneratedAttribute]
public SyntaxTrivia get_Replacement();
    [CompilerGeneratedAttribute]
public Nullable`1<TextSpan> get_Span();
    public virtual SyntaxTrivia VisitTrivia(SyntaxTrivia trivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.SyntaxWalkers.AssignedExpressionWalker : BaseCSharpSyntaxWalker {
    public virtual void VisitAssignedExpression(ExpressionSyntax expression);
    public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node);
    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node);
    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node);
    public virtual void VisitArgument(ArgumentSyntax node);
}
internal class Roslynator.CSharp.SyntaxWalkers.BaseCSharpSyntaxWalker : CSharpSyntaxWalker {
    protected bool ShouldVisit { get; }
    [NullableContextAttribute("1")]
public virtual void DefaultVisit(SyntaxNode node);
    protected virtual bool get_ShouldVisit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.SyntaxWalkers.ContainsCommentWalker : CSharpSyntaxWalker {
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static ContainsCommentWalker _cachedInstance;
    [CompilerGeneratedAttribute]
private bool <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    public bool Result { get; public set; }
    public TextSpan Span { get; public set; }
    public ContainsCommentWalker(TextSpan span);
    [CompilerGeneratedAttribute]
public bool get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(bool value);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public void set_Span(TextSpan value);
    public virtual void VisitTrivia(SyntaxTrivia trivia);
    private bool IsInSpan(TextSpan span);
    public static bool ContainsComment(SyntaxNode node);
    public static bool ContainsComment(SyntaxNode node, TextSpan span);
    public static ContainsCommentWalker GetInstance(TextSpan span);
    public static void Free(ContainsCommentWalker walker);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.SyntaxWalkers.ContainsLocalOrParameterReferenceWalker : LocalOrParameterReferenceWalker {
    [ThreadStaticAttribute]
private static ContainsLocalOrParameterReferenceWalker _cachedInstance;
    [CompilerGeneratedAttribute]
private bool <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public bool Result { get; public set; }
    public ISymbol Symbol { get; private set; }
    public SemanticModel SemanticModel { get; private set; }
    public CancellationToken CancellationToken { get; private set; }
    protected bool ShouldVisit { get; }
    [NullableContextAttribute("1")]
public ContainsLocalOrParameterReferenceWalker(ISymbol symbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public bool get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(bool value);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
private void set_Symbol(ISymbol value);
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
private void set_SemanticModel(SemanticModel value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
private void set_CancellationToken(CancellationToken value);
    protected virtual bool get_ShouldVisit();
    [NullableContextAttribute("1")]
public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    [NullableContextAttribute("0")]
public void VisitList(SyntaxList`1<TNode> statements);
    [NullableContextAttribute("0")]
public void VisitList(SyntaxList`1<TNode> statements, int startIndex);
    [NullableContextAttribute("0")]
public void VisitList(SyntaxList`1<TNode> statements, int startIndex, int count);
    [NullableContextAttribute("0")]
public void VisitList(SeparatedSyntaxList`1<TNode> statements);
    [NullableContextAttribute("0")]
public void VisitList(SeparatedSyntaxList`1<TNode> statements, int startIndex);
    [NullableContextAttribute("0")]
public void VisitList(SeparatedSyntaxList`1<TNode> statements, int startIndex, int count);
    [NullableContextAttribute("1")]
public static ContainsLocalOrParameterReferenceWalker GetInstance(ISymbol symbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static void Free(ContainsLocalOrParameterReferenceWalker walker);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.SyntaxWalkers.ContainsYieldWalker : StatementWalker {
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static ContainsYieldWalker _cachedInstance;
    [CompilerGeneratedAttribute]
private bool <SearchForYieldBreak>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SearchForYieldReturn>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private YieldStatementSyntax <YieldStatement>k__BackingField;
    public bool ShouldVisit { get; }
    public bool SearchForYieldBreak { get; private set; }
    public bool SearchForYieldReturn { get; private set; }
    [NullableAttribute("2")]
public YieldStatementSyntax YieldStatement { get; private set; }
    public ContainsYieldWalker(bool searchForYieldBreak, bool searchForYieldReturn);
    public virtual bool get_ShouldVisit();
    [CompilerGeneratedAttribute]
public bool get_SearchForYieldBreak();
    [CompilerGeneratedAttribute]
private void set_SearchForYieldBreak(bool value);
    [CompilerGeneratedAttribute]
public bool get_SearchForYieldReturn();
    [CompilerGeneratedAttribute]
private void set_SearchForYieldReturn(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public YieldStatementSyntax get_YieldStatement();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_YieldStatement(YieldStatementSyntax value);
    public static bool ContainsYield(StatementSyntax statement, bool searchForYieldReturn, bool searchForYieldBreak);
    public virtual void VisitYieldStatement(YieldStatementSyntax node);
    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node);
    public static ContainsYieldWalker GetInstance();
    public static void Free(ContainsYieldWalker walker);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.CSharp.SyntaxWalkers.LocalOrParameterReferenceWalker : BaseCSharpSyntaxWalker {
    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node);
    public virtual void VisitCrefParameter(CrefParameterSyntax node);
    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node);
    public virtual void VisitGenericName(GenericNameSyntax node);
    public virtual void VisitNullableType(NullableTypeSyntax node);
    public virtual void VisitPointerType(PointerTypeSyntax node);
    public virtual void VisitRefType(RefTypeSyntax node);
    public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node);
    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node);
    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    public virtual void VisitTupleElement(TupleElementSyntax node);
    public virtual void VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual void VisitTypeCref(TypeCrefSyntax node);
    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.SyntaxWalkers.MethodReferencedAsMethodGroupWalker : BaseCSharpSyntaxWalker {
    [ThreadStaticAttribute]
private static MethodReferencedAsMethodGroupWalker _cachedInstance;
    [CompilerGeneratedAttribute]
private bool <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public bool Result { get; public set; }
    public IMethodSymbol Symbol { get; public set; }
    public SemanticModel SemanticModel { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    protected bool ShouldVisit { get; }
    [CompilerGeneratedAttribute]
public bool get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(bool value);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_Symbol();
    [CompilerGeneratedAttribute]
public void set_Symbol(IMethodSymbol value);
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public void set_SemanticModel(SemanticModel value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    protected virtual bool get_ShouldVisit();
    [NullableContextAttribute("1")]
public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    [NullableContextAttribute("1")]
public static bool IsReferencedAsMethodGroup(MethodDeclarationSyntax methodDeclaration, IMethodSymbol methodSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static bool IsReferencedAsMethodGroup(LocalFunctionStatementSyntax localFunction, IMethodSymbol methodSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static bool IsReferencedAsMethodGroup(SyntaxNode node, IMethodSymbol methodSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static MethodReferencedAsMethodGroupWalker GetInstance();
    [NullableContextAttribute("1")]
private static void Free(MethodReferencedAsMethodGroupWalker walker);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <VisitIdentifierName>g__IsInvoked|19_0(IdentifierNameSyntax identifierName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CSharp.SyntaxWalkers.StatementWalker : CSharpSyntaxWalker {
    public bool ShouldVisit { get; }
    public virtual bool get_ShouldVisit();
    public virtual void VisitBlock(BlockSyntax node);
    public virtual void VisitBreakStatement(BreakStatementSyntax node);
    public virtual void VisitCheckedStatement(CheckedStatementSyntax node);
    public virtual void VisitContinueStatement(ContinueStatementSyntax node);
    public virtual void VisitDoStatement(DoStatementSyntax node);
    public virtual void VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual void VisitFixedStatement(FixedStatementSyntax node);
    public virtual void VisitForEachStatement(ForEachStatementSyntax node);
    public virtual void VisitForEachVariableStatement(ForEachVariableStatementSyntax node);
    public virtual void VisitForStatement(ForStatementSyntax node);
    public virtual void VisitGlobalStatement(GlobalStatementSyntax node);
    public virtual void VisitGotoStatement(GotoStatementSyntax node);
    public virtual void VisitIfStatement(IfStatementSyntax node);
    public virtual void VisitLabeledStatement(LabeledStatementSyntax node);
    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node);
    public virtual void VisitLockStatement(LockStatementSyntax node);
    public virtual void VisitReturnStatement(ReturnStatementSyntax node);
    public virtual void VisitSwitchStatement(SwitchStatementSyntax node);
    public virtual void VisitThrowStatement(ThrowStatementSyntax node);
    public virtual void VisitTryStatement(TryStatementSyntax node);
    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node);
    public virtual void VisitUsingStatement(UsingStatementSyntax node);
    public virtual void VisitWhileStatement(WhileStatementSyntax node);
    public virtual void VisitYieldStatement(YieldStatementSyntax node);
    [NullableContextAttribute("2")]
private void VisitBlockIfNotNull(BlockSyntax node);
    [NullableContextAttribute("2")]
private void VisitStatementIfNotNull(StatementSyntax node);
    public virtual void VisitStatement(StatementSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.CSharp.SyntaxWalkers.TypeSyntaxWalker : BaseCSharpSyntaxWalker {
    [NullableContextAttribute("2")]
protected abstract virtual void VisitType(TypeSyntax node);
    public virtual void VisitArrayType(ArrayTypeSyntax node);
    public virtual void VisitAttribute(AttributeSyntax node);
    public virtual void VisitCastExpression(CastExpressionSyntax node);
    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node);
    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node);
    public virtual void VisitCrefParameter(CrefParameterSyntax node);
    public virtual void VisitDeclarationExpression(DeclarationExpressionSyntax node);
    public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node);
    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node);
    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual void VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual void VisitForEachStatement(ForEachStatementSyntax node);
    public virtual void VisitFromClause(FromClauseSyntax node);
    public virtual void VisitFunctionPointerParameter(FunctionPointerParameterSyntax node);
    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node);
    public virtual void VisitJoinClause(JoinClauseSyntax node);
    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node);
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual void VisitNameMemberCref(NameMemberCrefSyntax node);
    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual void VisitNullableType(NullableTypeSyntax node);
    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual void VisitParameter(ParameterSyntax node);
    public virtual void VisitPointerType(PointerTypeSyntax node);
    public virtual void VisitPrimaryConstructorBaseType(PrimaryConstructorBaseTypeSyntax node);
    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node);
    public virtual void VisitQualifiedName(QualifiedNameSyntax node);
    public virtual void VisitRecursivePattern(RecursivePatternSyntax node);
    public virtual void VisitRefType(RefTypeSyntax node);
    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node);
    public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node);
    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node);
    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    public virtual void VisitTupleElement(TupleElementSyntax node);
    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual void VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual void VisitTypeCref(TypeCrefSyntax node);
    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual void VisitTypePattern(TypePatternSyntax node);
    public virtual void VisitUsingDirective(UsingDirectiveSyntax node);
    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
