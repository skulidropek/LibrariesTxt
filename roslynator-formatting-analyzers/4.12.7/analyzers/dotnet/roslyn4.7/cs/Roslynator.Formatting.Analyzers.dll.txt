[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public abstract class Roslynator.Formatting.BaseDiagnosticAnalyzer : DiagnosticAnalyzer {
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private string get_DebuggerDisplay();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AccessorListAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAccessorList(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddBlankLineAfterEmbeddedStatementAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeCommonForEachStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeForStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeUsingStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeWhileStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLockStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFixedStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeElseClause(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, StatementSyntax containingStatement, SyntaxToken token, StatementSyntax statement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddBlankLineAfterRegionDirectiveAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeRegionDirectiveTrivia(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeRegionDirectiveTrivia>g__IsFollowedWithEmptyLineOrEndRegionDirective|4_0(RegionDirectiveTriviaSyntax regionDirective);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddBlankLineAfterTopCommentAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddBlankLineAfterUsingDirectiveListAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void AnalyzeNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, UsingDirectiveSyntax usingDirective, SyntaxToken nextToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddBlankLineBeforeEndRegionDirectiveAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEndRegionDirectiveTrivia(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeEndRegionDirectiveTrivia>g__IsPrecededWithEmptyLineOrRegionDirective|4_0(EndRegionDirectiveTriviaSyntax endRegionDirective);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddBlankLineBeforeTopDeclarationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddBlankLineBeforeUsingDirectiveListAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddBlankLineBetweenClosingBraceAndNextStatementAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBlock(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTryStatement(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxToken closeBrace, StatementSyntax blockOrStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddBlankLineBetweenSwitchSectionsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSwitchStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddNewLineAfterSwitchLabelAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSwitchSection(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.AddOrRemoveNewLineBeforeWhileInDoStatementAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeDoStatement(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Roslynator.Formatting.CSharp.AnalyzerOptionIsObsoleteAnalyzer : AbstractAnalyzerOptionIsObsoleteAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void Validate(SyntaxTreeAnalysisContext& context, CompilationOptions compilationOptions, AnalyzerConfigOptions configOptions, Flags flag, Flags& flags, DiagnosticDescriptor analyzer, ConfigOptionDescriptor option, LegacyConfigOptionDescriptor legacyOption, string newValue);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.BlankLineAfterFileScopedNamespaceDeclarationAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeFileScopedNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    internal static SyntaxNode GetNodeAfterNamespaceDeclaration(FileScopedNamespaceDeclarationSyntax namespaceDeclaration);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.BlankLineBetweenAccessorsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAccessorList(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.BlankLineBetweenDeclarationsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void AnalyzeNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxList`1<MemberDeclarationSyntax> members);
    private static bool MemberKindEquals(MemberDeclarationSyntax member1, MemberDeclarationSyntax member2);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, TriviaBlock block);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.BlankLineBetweenSwitchSectionsAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSwitchStatement(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, TriviaBlock block, string messageArg);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.BlankLineBetweenUsingDirectivesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
    private static void AnalyzeNamespaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeUsings(SyntaxNodeAnalysisContext context, SyntaxList`1<UsingDirectiveSyntax> usings);
}
public static class Roslynator.Formatting.CSharp.DiagnosticIdentifiers : object {
    public static string AddBlankLineAfterEmbeddedStatement;
    public static string AddBlankLineAfterRegionDirective;
    public static string AddBlankLineAfterUsingDirectiveList;
    public static string AddBlankLineBeforeEndRegionDirective;
    public static string AddBlankLineBeforeUsingDirectiveList;
    public static string AddBlankLineBetweenAccessors;
    public static string AddBlankLineBetweenClosingBraceAndNextStatement;
    public static string AddBlankLineBetweenDeclarationAndDocumentationComment;
    public static string AddBlankLineBetweenDeclarations;
    public static string BlankLineBetweenSingleLineAccessors;
    public static string AddBlankLineBetweenSingleLineDeclarations;
    public static string AddBlankLineBetweenSingleLineDeclarationsOfDifferentKind;
    public static string AddBlankLineBetweenSwitchSections;
    public static string BlankLineBetweenUsingDirectives;
    public static string PutAttributeListOnItsOwnLine;
    public static string FormatAccessorBraces;
    public static string FormatBlockBraces;
    public static string AddNewLineAfterOpeningBraceOfEmptyBlock;
    public static string FormatTypeDeclarationBraces;
    public static string AddNewLineAfterSwitchLabel;
    public static string PutFullAccessorOnItsOwnLine;
    public static string PlaceNewLineAfterOrBeforeBinaryOperator;
    public static string PlaceNewLineAfterOrBeforeConditionalOperator;
    public static string PutConstructorInitializerOnItsOwnLine;
    public static string PutEmbeddedStatementOnItsOwnLine;
    public static string PutEnumMemberOnItsOwnLine;
    public static string PlaceNewLineAfterOrBeforeArrowToken;
    public static string PutStatementOnItsOwnLine;
    public static string PutTypeParameterConstraintOnItsOwnLine;
    public static string RemoveBlankLineBetweenSingleLineDeclarationsOfSameKind;
    public static string RemoveBlankLineBetweenUsingDirectivesWithSameRootNamespace;
    public static string RemoveNewLineBeforeBaseList;
    public static string RemoveNewLineBetweenIfKeywordAndElseKeyword;
    public static string PutAutoAccessorsOnSingleLine;
    public static string FormatAccessorBracesOnSingleLineWhenExpressionIsOnSingleLine;
    public static string UseCarriageReturnAndLinefeedAsNewLine;
    public static string UseLinefeedAsNewLine;
    public static string UseSpacesInsteadOfTab;
    public static string WrapAndIndentEachNodeInList;
    public static string PutInitializerOnSingleLine;
    public static string AddBlankLineAfterTopComment;
    public static string AddBlankLineBeforeTopDeclaration;
    public static string AddOrRemoveNewLineBeforeWhileInDoStatement;
    public static string PlaceNewLineAfterOrBeforeEqualsToken;
    public static string FixFormattingOfList;
    public static string FixFormattingOfCallChain;
    public static string FixFormattingOfBinaryExpressionChain;
    public static string LineIsTooLong;
    public static string NormalizeWhitespaceAtBeginningOfFile;
    public static string NormalizeWhitespaceAtEndOfFile;
    public static string PlaceNewLineAfterOrBeforeNullConditionalOperator;
    public static string BlankLineAfterFileScopedNamespaceDeclaration;
    public static string BlankLineBetweenSwitchSections;
}
public static class Roslynator.Formatting.CSharp.DiagnosticRules : object {
    public static DiagnosticDescriptor AddBlankLineAfterEmbeddedStatement;
    public static DiagnosticDescriptor AddBlankLineAfterRegionDirective;
    public static DiagnosticDescriptor AddBlankLineAfterUsingDirectiveList;
    public static DiagnosticDescriptor AddBlankLineBeforeEndRegionDirective;
    public static DiagnosticDescriptor AddBlankLineBeforeUsingDirectiveList;
    public static DiagnosticDescriptor AddBlankLineBetweenAccessors;
    public static DiagnosticDescriptor AddBlankLineBetweenClosingBraceAndNextStatement;
    public static DiagnosticDescriptor AddBlankLineBetweenDeclarationAndDocumentationComment;
    public static DiagnosticDescriptor AddBlankLineBetweenDeclarations;
    public static DiagnosticDescriptor BlankLineBetweenSingleLineAccessors;
    public static DiagnosticDescriptor AddBlankLineBetweenSingleLineDeclarations;
    public static DiagnosticDescriptor AddBlankLineBetweenSingleLineDeclarationsOfDifferentKind;
    public static DiagnosticDescriptor AddBlankLineBetweenSwitchSections;
    public static DiagnosticDescriptor BlankLineBetweenUsingDirectives;
    public static DiagnosticDescriptor PutAttributeListOnItsOwnLine;
    public static DiagnosticDescriptor FormatAccessorBraces;
    public static DiagnosticDescriptor FormatBlockBraces;
    public static DiagnosticDescriptor AddNewLineAfterOpeningBraceOfEmptyBlock;
    public static DiagnosticDescriptor FormatTypeDeclarationBraces;
    public static DiagnosticDescriptor AddNewLineAfterSwitchLabel;
    public static DiagnosticDescriptor PutFullAccessorOnItsOwnLine;
    public static DiagnosticDescriptor PlaceNewLineAfterOrBeforeBinaryOperator;
    public static DiagnosticDescriptor PlaceNewLineAfterOrBeforeConditionalOperator;
    public static DiagnosticDescriptor PutConstructorInitializerOnItsOwnLine;
    public static DiagnosticDescriptor PutEmbeddedStatementOnItsOwnLine;
    public static DiagnosticDescriptor PutEnumMemberOnItsOwnLine;
    public static DiagnosticDescriptor PlaceNewLineAfterOrBeforeArrowToken;
    public static DiagnosticDescriptor PutStatementOnItsOwnLine;
    public static DiagnosticDescriptor PutTypeParameterConstraintOnItsOwnLine;
    public static DiagnosticDescriptor RemoveBlankLineBetweenSingleLineDeclarationsOfSameKind;
    public static DiagnosticDescriptor RemoveBlankLineBetweenUsingDirectivesWithSameRootNamespace;
    public static DiagnosticDescriptor RemoveNewLineBeforeBaseList;
    public static DiagnosticDescriptor RemoveNewLineBetweenIfKeywordAndElseKeyword;
    public static DiagnosticDescriptor PutAutoAccessorsOnSingleLine;
    public static DiagnosticDescriptor FormatAccessorBracesOnSingleLineWhenExpressionIsOnSingleLine;
    public static DiagnosticDescriptor UseCarriageReturnAndLinefeedAsNewLine;
    public static DiagnosticDescriptor UseLinefeedAsNewLine;
    public static DiagnosticDescriptor UseSpacesInsteadOfTab;
    public static DiagnosticDescriptor WrapAndIndentEachNodeInList;
    public static DiagnosticDescriptor PutInitializerOnSingleLine;
    public static DiagnosticDescriptor AddBlankLineAfterTopComment;
    public static DiagnosticDescriptor AddBlankLineBeforeTopDeclaration;
    public static DiagnosticDescriptor AddOrRemoveNewLineBeforeWhileInDoStatement;
    public static DiagnosticDescriptor PlaceNewLineAfterOrBeforeEqualsToken;
    public static DiagnosticDescriptor FixFormattingOfList;
    public static DiagnosticDescriptor FixFormattingOfCallChain;
    public static DiagnosticDescriptor FixFormattingOfBinaryExpressionChain;
    public static DiagnosticDescriptor LineIsTooLong;
    public static DiagnosticDescriptor NormalizeWhitespaceAtBeginningOfFile;
    public static DiagnosticDescriptor NormalizeWhitespaceAtEndOfFile;
    public static DiagnosticDescriptor PlaceNewLineAfterOrBeforeNullConditionalOperator;
    public static DiagnosticDescriptor BlankLineAfterFileScopedNamespaceDeclaration;
    public static DiagnosticDescriptor BlankLineBetweenSwitchSections;
    private static DiagnosticRules();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.FixFormattingOfBinaryExpressionChainAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBinaryExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeBinaryExpression>g__Analyze|4_0(SyntaxNodeOrToken nodeOrToken, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static int <AnalyzeBinaryExpression>g__GetIndentationLength|4_1(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static void <AnalyzeBinaryExpression>g__ReportDiagnostic|4_2(<>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.FixFormattingOfCallChainAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeExpression>g__AnalyzeToken|4_0(SyntaxToken token, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static void <AnalyzeExpression>g__ReportDiagnostic|4_1(<>c__DisplayClass4_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.FixFormattingOfListAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeParameterList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeBracketedParameterList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTypeParameterList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeArgumentList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeBracketedArgumentList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAttributeArgumentList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTypeArgumentList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAttributeList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeBaseList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTupleType(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTupleExpression(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInitializerExpression(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxNodeOrToken openNodeOrToken, SeparatedSyntaxList`1<TNode> nodes);
    internal static BracesBlock GetBracesBlock(SyntaxNode node);
    internal static bool ShouldWrapAndIndent(SyntaxNode node, int index);
    [CompilerGeneratedAttribute]
internal static void <Analyze>g__ReportDiagnostic|16_0(<>c__DisplayClass16_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__ShouldFixIndentation|16_1(SyntaxTriviaList leading, int indentationLength);
    [CompilerGeneratedAttribute]
internal static string <Analyze>g__GetTitle|16_2(<>c__DisplayClass16_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__AnalyzeBlock|16_3(SeparatedSyntaxList`1<TNode> nodes, IndentationAnalysis indentationAnalysis, SyntaxKind kind1, SyntaxKind kind2, <>c__DisplayClass16_0`1& );
    [CompilerGeneratedAttribute]
internal static bool <GetBracesBlock>g__AnalyzeToken|17_0(SyntaxToken token, bool isOpen);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.FormatAccessorBracesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAccessorDeclaration(SyntaxNodeAnalysisContext context);
    private static bool CanBeMadeSingleLine(AccessorDeclarationSyntax accessor);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.FormatBlockBracesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBlock(SyntaxNodeAnalysisContext context);
    private static bool IsEmptyBlock(BlockSyntax block);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.FormatTypeDeclarationBracesAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTypeDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.NormalizeWhitespaceAtBeginningOfFileAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeCompilationUnit>g__ReportDiagnostic|4_0(SyntaxNodeAnalysisContext context, SyntaxToken token);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.NormalizeWhitespaceAtEndOfFileAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationUnit(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeCompilationUnit>g__ReportDiagnostic|4_0(SyntaxNodeAnalysisContext context, SyntaxToken eof);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PlaceNewLineAfterOrBeforeArrowTokenAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeArrowExpressionClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PlaceNewLineAfterOrBeforeBinaryOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBinaryExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PlaceNewLineAfterOrBeforeConditionalOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConditionalExpression(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeConditionalExpression>g__ReportDiagnostic|4_0(SyntaxNodeAnalysisContext context, TriviaBlock block);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PlaceNewLineAfterOrBeforeEqualsTokenAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNameEquals(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEqualsValueClause(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAssignmentExpression(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxToken token, ExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PlaceNewLineAfterOrBeforeNullConditionalOperatorAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConditionalAccess(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PutAttributeListOnItsOwnLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeClassDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeInterfaceDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeStructDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeRecordDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEventFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeFieldDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeConversionOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDestructorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEventDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeOperatorDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeIndexerDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAccessorList(SyntaxNodeAnalysisContext context, AccessorListSyntax accessorList);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxNodeOrToken nodeOrToken);
    private static void Analyze(SyntaxNodeAnalysisContext context, AttributeListSyntax attributeList, SyntaxNodeOrToken nodeOrToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PutConstructorInitializerOnItsOwnLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeConstructorInitializer(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PutEmbeddedStatementOnItsOwnLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    internal static void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    internal static void AnalyzeCommonForEachStatement(SyntaxNodeAnalysisContext context);
    internal static void AnalyzeForStatement(SyntaxNodeAnalysisContext context);
    internal static void AnalyzeUsingStatement(SyntaxNodeAnalysisContext context);
    internal static void AnalyzeWhileStatement(SyntaxNodeAnalysisContext context);
    internal static void AnalyzeDoStatement(SyntaxNodeAnalysisContext context);
    internal static void AnalyzeLockStatement(SyntaxNodeAnalysisContext context);
    internal static void AnalyzeFixedStatement(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxToken token, StatementSyntax statement);
    private static void AnalyzeElseClause(SyntaxNodeAnalysisContext context);
    private static void ReportDiagnostic(SyntaxNodeAnalysisContext context, TriviaBlock block);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PutEnumMemberOnItsOwnLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PutInitializerOnSingleLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInitializerExpression(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PutStatementOnItsOwnLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeBlock(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSwitchSection(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxList`1<StatementSyntax> statements);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.PutTypeParameterConstraintOnItsOwnLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeDelegateDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeLocalFunctionStatement(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SyntaxNodeOrToken previous, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.RemoveNewLineBeforeBaseListAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTypeDeclaration(SyntaxNodeAnalysisContext context);
    private static void AnalyzeEnumDeclaration(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, BaseListSyntax baseList, SyntaxToken previousToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.RemoveNewLineBetweenIfKeywordAndElseKeywordAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeElseClause(SyntaxNodeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Roslynator.Formatting.CSharp.RequiredConfigOptionNotSetAnalyzer : AbstractRequiredConfigOptionNotSetAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void Validate(SyntaxTreeAnalysisContext& context, CompilationOptions compilationOptions, AnalyzerConfigOptions configOptions, Flags flag, Flags& flags, DiagnosticDescriptor analyzer, ConfigOptionDescriptor option);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.UseSpacesInsteadOfTabAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.CSharp.WrapAndIndentEachNodeInListAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeTypeArgumentList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeArgumentList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeBracketedArgumentList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAttributeList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeAttributeArgumentList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeBaseList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeParameterList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeBracketedParameterList(SyntaxNodeAnalysisContext context);
    private static void AnalyzeTypeParameterList(SyntaxNodeAnalysisContext context);
    private static void Analyze(SyntaxNodeAnalysisContext context, SeparatedSyntaxList`1<TNode> nodes);
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__IsSingleLine|13_0(TextSpan span, <>c__DisplayClass13_0`1& );
    [CompilerGeneratedAttribute]
internal static void <Analyze>g__ReportDiagnostic|13_1(<>c__DisplayClass13_0`1& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.LineIsTooLongAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.UseCarriageReturnAndLinefeedAsNewLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void Analyze(SyntaxTreeAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.Formatting.UseLinefeedAsNewLineAnalyzer : BaseDiagnosticAnalyzer {
    private static ImmutableArray`1<DiagnosticDescriptor> _supportedDiagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
