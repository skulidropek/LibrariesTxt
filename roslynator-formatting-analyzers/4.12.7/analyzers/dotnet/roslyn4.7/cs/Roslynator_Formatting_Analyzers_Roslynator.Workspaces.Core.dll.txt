[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.AnalyzerAssembly : object {
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ImmutableArray`1<DiagnosticAnalyzer>> <AnalyzersByLanguage>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ImmutableArray`1<CodeFixProvider>> <FixersByLanguage>k__BackingField;
    public Assembly Assembly { get; }
    internal string FullName { get; }
    internal string Name { get; }
    public bool HasAnalyzers { get; }
    public bool HasFixers { get; }
    internal bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<string, ImmutableArray`1<DiagnosticAnalyzer>> AnalyzersByLanguage { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<string, ImmutableArray`1<CodeFixProvider>> FixersByLanguage { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private AnalyzerAssembly(Assembly assembly, ImmutableDictionary`2<string, ImmutableArray`1<DiagnosticAnalyzer>> analyzersByLanguage, ImmutableDictionary`2<string, ImmutableArray`1<CodeFixProvider>> fixersByLanguage);
    [CompilerGeneratedAttribute]
public Assembly get_Assembly();
    internal string get_FullName();
    internal string get_Name();
    public bool get_HasAnalyzers();
    public bool get_HasFixers();
    internal bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ImmutableArray`1<DiagnosticAnalyzer>> get_AnalyzersByLanguage();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ImmutableArray`1<CodeFixProvider>> get_FixersByLanguage();
    private string get_DebuggerDisplay();
    internal IEnumerable`1<DiagnosticAnalyzer> GetAnalyzers();
    internal IEnumerable`1<CodeFixProvider> GetFixers();
    public static AnalyzerAssembly Load(Assembly analyzerAssembly, bool loadAnalyzers, bool loadFixers, string language);
    [NullableContextAttribute("2")]
private static T CreateInstanceAndCatchIfThrows(TypeInfo typeInfo);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(AnalyzerAssembly other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.AnalyzerAssemblyEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private AnalyzerAssembly <AnalyzerAssembly>k__BackingField;
    public AnalyzerAssembly AnalyzerAssembly { get; }
    public AnalyzerAssemblyEventArgs(AnalyzerAssembly analyzerAssembly);
    [CompilerGeneratedAttribute]
public AnalyzerAssembly get_AnalyzerAssembly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.AnalyzerLoader : object {
    private Dictionary`2<string, AnalyzerAssembly> _cache;
    private Dictionary`2<string, AnalyzerAssembly> _defaultAssemblies;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ImmutableArray`1<DiagnosticAnalyzer>> _defaultAnalyzers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ImmutableArray`1<CodeFixProvider>> _defaultFixers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AnalyzerAssembly> <DefaultAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeAnalysisOptions <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<AnalyzerAssemblyEventArgs> AnalyzerAssemblyAdded;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<AnalyzerAssembly> DefaultAssemblies { get; }
    public CodeAnalysisOptions Options { get; }
    public AnalyzerLoader(IEnumerable`1<AnalyzerAssembly> defaultAssemblies, CodeAnalysisOptions options);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<AnalyzerAssembly> get_DefaultAssemblies();
    [CompilerGeneratedAttribute]
public CodeAnalysisOptions get_Options();
    [CompilerGeneratedAttribute]
public void add_AnalyzerAssemblyAdded(EventHandler`1<AnalyzerAssemblyEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AnalyzerAssemblyAdded(EventHandler`1<AnalyzerAssemblyEventArgs> value);
    protected virtual void OnAnalyzerAssemblyAdded(AnalyzerAssemblyEventArgs e);
    public ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzers(Project project);
    public ValueTuple`2<ImmutableArray`1<DiagnosticAnalyzer>, ImmutableArray`1<CodeFixProvider>> GetAnalyzersAndFixers(Project project);
    private ValueTuple`2<ImmutableArray`1<DiagnosticAnalyzer>, ImmutableArray`1<CodeFixProvider>> GetAnalyzersAndFixers(Project project, bool loadFixers);
    private void LoadAnalyzers(AnalyzerAssembly analyzerAssembly, string language, Builder& builder);
    private bool ShouldIncludeAnalyzer(DiagnosticAnalyzer analyzer);
    private void LoadFixers(AnalyzerAssembly analyzerAssembly, string language, Builder& builder);
    private bool ShouldIncludeFixer(CodeFixProvider fixer);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetAnalyzersAndFixers>b__17_1(Assembly f);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Roslynator.AssemblyFullNameComparer : EqualityComparer`1<Assembly> {
    [CompilerGeneratedAttribute]
private static AssemblyFullNameComparer <Instance>k__BackingField;
    public static AssemblyFullNameComparer Instance { get; }
    private static AssemblyFullNameComparer();
    [CompilerGeneratedAttribute]
public static AssemblyFullNameComparer get_Instance();
    public virtual bool Equals(Assembly x, Assembly y);
    public virtual int GetHashCode(Assembly obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslynator.AttributeInfo : ValueType {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<AttributeInfo> <AttributeClassComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeData <AttributeData>k__BackingField;
    internal static IEqualityComparer`1<AttributeInfo> AttributeClassComparer { get; }
    public ISymbol Target { get; }
    public AttributeData AttributeData { get; }
    [NullableAttribute("2")]
public INamedTypeSymbol AttributeClass { get; }
    public AttributeInfo(ISymbol target, AttributeData attributeData);
    private static AttributeInfo();
    [CompilerGeneratedAttribute]
internal static IEqualityComparer`1<AttributeInfo> get_AttributeClassComparer();
    [CompilerGeneratedAttribute]
public ISymbol get_Target();
    [CompilerGeneratedAttribute]
public AttributeData get_AttributeData();
    [NullableContextAttribute("2")]
public INamedTypeSymbol get_AttributeClass();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslynator.CodeActions.CodeActionData : ValueType {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <EquivalenceKey>k__BackingField;
    public string Title { get; }
    [NullableAttribute("2")]
public string EquivalenceKey { get; }
    public bool IsDefault { get; }
    public CodeActionData(string title, string equivalenceKey);
    [CompilerGeneratedAttribute]
public string get_Title();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_EquivalenceKey();
    public bool get_IsDefault();
    public CodeAction ToCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument);
    public CodeAction ToCodeAction(Func`2<CancellationToken, Task`1<Solution>> createChangedDocument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CodeActions.NavigationAnnotation : object {
    public static string Kind;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Annotation>k__BackingField;
    public static SyntaxAnnotation Annotation { get; }
    private static NavigationAnnotation();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Annotation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.CodeAnalysisOptions : object {
    [CompilerGeneratedAttribute]
private DiagnosticSeverity <SeverityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreAnalyzerReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConcurrentAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <SupportedDiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <IgnoredDiagnosticIds>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private FileSystemFilter <FileSystemFilter>k__BackingField;
    public DiagnosticSeverity SeverityLevel { get; }
    public bool IgnoreAnalyzerReferences { get; }
    public bool ConcurrentAnalysis { get; }
    public ImmutableHashSet`1<string> SupportedDiagnosticIds { get; }
    public ImmutableHashSet`1<string> IgnoredDiagnosticIds { get; }
    [NullableAttribute("2")]
public FileSystemFilter FileSystemFilter { get; }
    [NullableContextAttribute("2")]
internal CodeAnalysisOptions(FileSystemFilter fileSystemFilter, DiagnosticSeverity severityLevel, bool ignoreAnalyzerReferences, bool concurrentAnalysis, IEnumerable`1<string> supportedDiagnosticIds, IEnumerable`1<string> ignoredDiagnosticIds);
    [CompilerGeneratedAttribute]
public DiagnosticSeverity get_SeverityLevel();
    [CompilerGeneratedAttribute]
public bool get_IgnoreAnalyzerReferences();
    [CompilerGeneratedAttribute]
public bool get_ConcurrentAnalysis();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_SupportedDiagnosticIds();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_IgnoredDiagnosticIds();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public FileSystemFilter get_FileSystemFilter();
    internal bool IsSupportedDiagnosticId(string diagnosticId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslynator.CodeFixContextExtensions : object {
    [ExtensionAttribute]
public static Task`1<SyntaxNode> GetSyntaxRootAsync(CodeFixContext context);
    [ExtensionAttribute]
public static Task`1<SemanticModel> GetSemanticModelAsync(CodeFixContext context);
    [ExtensionAttribute]
public static Project Project(CodeFixContext context);
    [ExtensionAttribute]
public static Solution Solution(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CodeFixes.CodeFixer : object {
    private AnalyzerLoader _analyzerLoader;
    [CompilerGeneratedAttribute]
private Workspace <Workspace>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeFixerOptions <Options>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IFormatProvider <FormatProvider>k__BackingField;
    public Workspace Workspace { get; }
    public CodeFixerOptions Options { get; }
    [NullableAttribute("2")]
public IFormatProvider FormatProvider { get; }
    private Solution CurrentSolution { get; }
    public CodeFixer(Solution solution, AnalyzerLoader analyzerLoader, IFormatProvider formatProvider, CodeFixerOptions options);
    [CompilerGeneratedAttribute]
public Workspace get_Workspace();
    [CompilerGeneratedAttribute]
public CodeFixerOptions get_Options();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IFormatProvider get_FormatProvider();
    private Solution get_CurrentSolution();
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.CodeFixer/<FixSolutionAsync>d__13")]
public Task`1<ImmutableArray`1<ProjectFixResult>> FixSolutionAsync(Func`2<Project, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.CodeFixer/<FixProjectAsync>d__14")]
public Task`1<ProjectFixResult> FixProjectAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.CodeFixer/<FixProjectAsync>d__15")]
private Task`1<FixResult> FixProjectAsync(Project project, ImmutableArray`1<DiagnosticAnalyzer> analyzers, ImmutableArray`1<CodeFixProvider> fixers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.CodeFixer/<FixDiagnosticsAsync>d__16")]
private Task`1<DiagnosticFixResult> FixDiagnosticsAsync(DiagnosticDescriptor descriptor, ImmutableArray`1<DiagnosticAnalyzer> analyzers, ImmutableArray`1<CodeFixProvider> fixers, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.CodeFixer/<FixDiagnosticsAsync>d__17")]
private Task`1<DiagnosticFixKind> FixDiagnosticsAsync(ImmutableArray`1<Diagnostic> diagnostics, DiagnosticDescriptor descriptor, ImmutableArray`1<CodeFixProvider> fixers, Project project, CancellationToken cancellationToken);
    private bool VerifyCompilerDiagnostics(ImmutableArray`1<Diagnostic> diagnostics, Project project);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.CodeFixer/<GetDiagnosticsAsync>d__19")]
private Task`1<ImmutableArray`1<Diagnostic>> GetDiagnosticsAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, IEnumerable`1<Diagnostic> except, Compilation compilation, AnalyzerOptions analyzerOptions, Func`2<ValueTuple`2<string, DiagnosticAnalyzer>, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.CodeFixer/<AddFileBannerAsync>d__20")]
private Task`1<int> AddFileBannerAsync(Project project, ImmutableArray`1<string> banner, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.CodeFixer/<FormatProjectAsync>d__21")]
private Task`1<ImmutableArray`1<DocumentId>> FormatProjectAsync(Project project, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerDiagnosticsAsync(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerOptions analyzerOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CodeFixes.CodeFixerOptions : CodeAnalysisOptions {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<string> _fileBannerLines;
    [CompilerGeneratedAttribute]
private static CodeFixerOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCompilerErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <IgnoredCompilerDiagnosticIds>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <FileBanner>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <DiagnosticIdsFixableOneByOne>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ImmutableArray`1<string>> <DiagnosticFixMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, string> <DiagnosticFixerMap>k__BackingField;
    [CompilerGeneratedAttribute]
private FixAllScope <FixAllScope>k__BackingField;
    public static CodeFixerOptions Default { get; }
    public bool IgnoreCompilerErrors { get; }
    public HashSet`1<string> IgnoredCompilerDiagnosticIds { get; }
    [NullableAttribute("2")]
public string FileBanner { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FileBannerLines { get; }
    public int MaxIterations { get; }
    public int BatchSize { get; }
    public bool Format { get; }
    public ImmutableHashSet`1<string> DiagnosticIdsFixableOneByOne { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<string, ImmutableArray`1<string>> DiagnosticFixMap { get; }
    public ImmutableDictionary`2<string, string> DiagnosticFixerMap { get; }
    public FixAllScope FixAllScope { get; }
    [NullableContextAttribute("2")]
public CodeFixerOptions(FileSystemFilter fileSystemFilter, DiagnosticSeverity severityLevel, bool ignoreCompilerErrors, bool ignoreAnalyzerReferences, bool concurrentAnalysis, IEnumerable`1<string> supportedDiagnosticIds, IEnumerable`1<string> ignoredDiagnosticIds, IEnumerable`1<string> ignoredCompilerDiagnosticIds, IEnumerable`1<string> diagnosticIdsFixableOneByOne, IEnumerable`1<KeyValuePair`2<string, string>> diagnosticFixMap, IEnumerable`1<KeyValuePair`2<string, string>> diagnosticFixerMap, FixAllScope fixAllScope, string fileBanner, int maxIterations, int batchSize, bool format);
    private static CodeFixerOptions();
    [CompilerGeneratedAttribute]
public static CodeFixerOptions get_Default();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCompilerErrors();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_IgnoredCompilerDiagnosticIds();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_FileBanner();
    public ImmutableArray`1<string> get_FileBannerLines();
    [CompilerGeneratedAttribute]
public int get_MaxIterations();
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public bool get_Format();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_DiagnosticIdsFixableOneByOne();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ImmutableArray`1<string>> get_DiagnosticFixMap();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, string> get_DiagnosticFixerMap();
    [CompilerGeneratedAttribute]
public FixAllScope get_FixAllScope();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CodeFixes.DiagnosticDescriptorFixComparer : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<DiagnosticDescriptor, int> <DiagnosticCountByDescriptor>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, ImmutableArray`1<CodeFixProvider>> <FixersById>k__BackingField;
    private Dictionary`2<DiagnosticDescriptor, int> DiagnosticCountByDescriptor { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ImmutableArray`1<CodeFixProvider>> FixersById { get; }
    public DiagnosticDescriptorFixComparer(Dictionary`2<DiagnosticDescriptor, int> diagnosticCountByDescriptor, Dictionary`2<string, ImmutableArray`1<CodeFixProvider>> fixersById);
    [CompilerGeneratedAttribute]
private Dictionary`2<DiagnosticDescriptor, int> get_DiagnosticCountByDescriptor();
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ImmutableArray`1<CodeFixProvider>> get_FixersById();
    public sealed virtual int Compare(DiagnosticDescriptor x, DiagnosticDescriptor y);
    private bool HasFixAll(DiagnosticDescriptor descriptor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslynator.CodeFixes.DiagnosticFix : ValueType {
    [CompilerGeneratedAttribute]
private CodeAction <CodeAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeFixProvider <FixProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeFixProvider <FixProvider2>k__BackingField;
    public CodeAction CodeAction { get; }
    public Document Document { get; }
    public CodeFixProvider FixProvider { get; }
    public CodeFixProvider FixProvider2 { get; }
    public DiagnosticFix(CodeAction codeAction, Document document, CodeFixProvider fixProvider, CodeFixProvider fixProvider2);
    [CompilerGeneratedAttribute]
public CodeAction get_CodeAction();
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public CodeFixProvider get_FixProvider();
    [CompilerGeneratedAttribute]
public CodeFixProvider get_FixProvider2();
}
internal enum Roslynator.CodeFixes.DiagnosticFixKind : Enum {
    public int value__;
    public static DiagnosticFixKind Success;
    public static DiagnosticFixKind PartiallyFixed;
    public static DiagnosticFixKind NotFixed;
    public static DiagnosticFixKind MultipleFixers;
    public static DiagnosticFixKind CompilerError;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CodeFixes.DiagnosticFixProvider : object {
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.DiagnosticFixProvider/<GetFixAsync>d__0")]
public static Task`1<DiagnosticFix> GetFixAsync(ImmutableArray`1<Diagnostic> diagnostics, DiagnosticDescriptor descriptor, ImmutableArray`1<CodeFixProvider> fixers, Project project, CodeFixerOptions options, IFormatProvider formatProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.DiagnosticFixProvider/<GetFixAsync>d__1")]
private static Task`1<ValueTuple`2<CodeAction, Document>> GetFixAsync(ImmutableArray`1<Diagnostic> diagnostics, DiagnosticDescriptor descriptor, CodeFixProvider fixer, Project project, CodeFixerOptions options, IFormatProvider formatProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.DiagnosticFixProvider/<GetFixAsync>d__2")]
private static Task`1<ValueTuple`2<CodeAction, Document>> GetFixAsync(Diagnostic diagnostic, CodeFixProvider fixer, Project project, CodeFixerOptions options, IFormatProvider formatProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.DiagnosticFixProvider/<GetFixAsync>d__3")]
private static Task`1<CodeAction> GetFixAsync(Diagnostic diagnostic, CodeFixProvider fixer, Document document, HashSet`1<MultipleFixesInfo> multipleFixesInfos, ImmutableArray`1<string> equivalenceKeys, CancellationToken cancellationToken);
    private static void WriteMultipleActionsSummary(MultipleFixesInfo& info);
}
[IsReadOnlyAttribute]
internal class Roslynator.CodeFixes.DiagnosticFixResult : ValueType {
    [CompilerGeneratedAttribute]
private DiagnosticFixKind <Kind>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Diagnostic> <FixedDiagnostics>k__BackingField;
    public DiagnosticFixKind Kind { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Diagnostic> FixedDiagnostics { get; }
    public DiagnosticFixResult(DiagnosticFixKind kind, ImmutableArray`1<Diagnostic> fixedDiagnostics);
    [CompilerGeneratedAttribute]
public DiagnosticFixKind get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Diagnostic> get_FixedDiagnostics();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CodeFixes.FixAllDiagnosticProvider : DiagnosticProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Diagnostic> _diagnostics;
    public FixAllDiagnosticProvider(ImmutableArray`1<Diagnostic> diagnostics);
    public virtual Task`1<IEnumerable`1<Diagnostic>> GetAllDiagnosticsAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CodeFixes.FixAllDiagnosticProvider/<GetDocumentDiagnosticsAsync>d__3")]
public virtual Task`1<IEnumerable`1<Diagnostic>> GetDocumentDiagnosticsAsync(Document document, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<Diagnostic>> GetProjectDiagnosticsAsync(Project project, CancellationToken cancellationToken);
}
internal enum Roslynator.CodeFixes.ProjectFixKind : Enum {
    public int value__;
    public static ProjectFixKind Success;
    [ObsoleteAttribute]
public static ProjectFixKind NoAnalyzers;
    public static ProjectFixKind NoFixers;
    [ObsoleteAttribute]
public static ProjectFixKind NoFixableAnalyzers;
    public static ProjectFixKind CompilerError;
    public static ProjectFixKind Skipped;
    public static ProjectFixKind InfiniteLoop;
}
internal class Roslynator.CodeFixes.ProjectFixResult : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static ProjectFixResult <Skipped>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectFixKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticInfo> <FixedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticInfo> <UnfixedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticInfo> <UnfixableDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfFormattedDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfAddedFileBanners>k__BackingField;
    [NullableAttribute("1")]
internal static ProjectFixResult Skipped { get; }
    public ProjectFixKind Kind { get; }
    public ImmutableArray`1<DiagnosticInfo> FixedDiagnostics { get; }
    public ImmutableArray`1<DiagnosticInfo> UnfixedDiagnostics { get; }
    public ImmutableArray`1<DiagnosticInfo> UnfixableDiagnostics { get; }
    public int NumberOfFormattedDocuments { get; }
    public int NumberOfAddedFileBanners { get; }
    [NullableContextAttribute("2")]
internal ProjectFixResult(ProjectFixKind kind, IEnumerable`1<DiagnosticInfo> fixedDiagnostics, IEnumerable`1<DiagnosticInfo> unfixedDiagnostics, IEnumerable`1<DiagnosticInfo> unfixableDiagnostics, int numberOfFormattedDocuments, int numberOfAddedFileBanners);
    private static ProjectFixResult();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static ProjectFixResult get_Skipped();
    [CompilerGeneratedAttribute]
public ProjectFixKind get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticInfo> get_FixedDiagnostics();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticInfo> get_UnfixedDiagnostics();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticInfo> get_UnfixableDiagnostics();
    [CompilerGeneratedAttribute]
public int get_NumberOfFormattedDocuments();
    [CompilerGeneratedAttribute]
public int get_NumberOfAddedFileBanners();
}
[IsReadOnlyAttribute]
internal class Roslynator.CodeMetrics.CodeMetricsInfo : ValueType {
    [CompilerGeneratedAttribute]
private static CodeMetricsInfo <NotAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalLineCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeLineCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WhitespaceLineCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CommentLineCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PreprocessorDirectiveLineCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlockBoundaryLineCount>k__BackingField;
    internal static CodeMetricsInfo NotAvailable { get; }
    public int TotalLineCount { get; }
    public int CodeLineCount { get; }
    public int WhitespaceLineCount { get; }
    public int CommentLineCount { get; }
    public int PreprocessorDirectiveLineCount { get; }
    public int BlockBoundaryLineCount { get; }
    internal CodeMetricsInfo(int totalLineCount, int codeLineCount, int whitespaceLineCount, int commentLineCount, int preprocessorDirectiveLineCount, int blockBoundaryLineCount);
    private static CodeMetricsInfo();
    [CompilerGeneratedAttribute]
internal static CodeMetricsInfo get_NotAvailable();
    [CompilerGeneratedAttribute]
public int get_TotalLineCount();
    [CompilerGeneratedAttribute]
public int get_CodeLineCount();
    [CompilerGeneratedAttribute]
public int get_WhitespaceLineCount();
    [CompilerGeneratedAttribute]
public int get_CommentLineCount();
    [CompilerGeneratedAttribute]
public int get_PreprocessorDirectiveLineCount();
    [CompilerGeneratedAttribute]
public int get_BlockBoundaryLineCount();
    internal CodeMetricsInfo Add(CodeMetricsInfo& codeMetrics);
    [NullableContextAttribute("1")]
public static CodeMetricsInfo Create(IEnumerable`1<CodeMetricsInfo> metrics);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CodeMetricsInfo other);
    public virtual int GetHashCode();
    public static bool op_Equality(CodeMetricsInfo& metrics1, CodeMetricsInfo& metrics2);
    public static bool op_Inequality(CodeMetricsInfo& metrics1, CodeMetricsInfo& metrics2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.CodeMetrics.CodeMetricsOptions : object {
    [CompilerGeneratedAttribute]
private static CodeMetricsOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeGeneratedCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePreprocessorDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreBlockBoundary>k__BackingField;
    public static CodeMetricsOptions Default { get; }
    public bool IncludeGeneratedCode { get; }
    public bool IncludeWhitespace { get; }
    public bool IncludeComments { get; }
    public bool IncludePreprocessorDirectives { get; }
    public bool IgnoreBlockBoundary { get; }
    public CodeMetricsOptions(bool includeGenerated, bool includeWhitespace, bool includeComments, bool includePreprocessorDirectives, bool ignoreBlockBoundary);
    private static CodeMetricsOptions();
    [CompilerGeneratedAttribute]
public static CodeMetricsOptions get_Default();
    [CompilerGeneratedAttribute]
public bool get_IncludeGeneratedCode();
    [CompilerGeneratedAttribute]
public bool get_IncludeWhitespace();
    [CompilerGeneratedAttribute]
public bool get_IncludeComments();
    [CompilerGeneratedAttribute]
public bool get_IncludePreprocessorDirectives();
    [CompilerGeneratedAttribute]
public bool get_IgnoreBlockBoundary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.CodeMetrics.CodeMetricsService : object {
    public ISyntaxFactsService SyntaxFacts { get; }
    public abstract virtual ISyntaxFactsService get_SyntaxFacts();
    public abstract virtual CodeMetricsInfo CountPhysicalLines(SyntaxNode node, SourceText sourceText, CodeMetricsOptions options, CancellationToken cancellationToken);
    public abstract virtual CodeMetricsInfo CountLogicalLines(SyntaxNode node, SourceText sourceText, CodeMetricsOptions options, CancellationToken cancellationToken);
    private protected int CountWhitespaceLines(SyntaxNode root, SourceText sourceText);
}
[NullableContextAttribute("1")]
internal interface Roslynator.CodeMetrics.ICodeMetricsService {
    public ISyntaxFactsService SyntaxFacts { get; }
    public abstract virtual ISyntaxFactsService get_SyntaxFacts();
    public abstract virtual CodeMetricsInfo CountPhysicalLines(SyntaxNode node, SourceText sourceText, CodeMetricsOptions options, CancellationToken cancellationToken);
    public abstract virtual CodeMetricsInfo CountLogicalLines(SyntaxNode node, SourceText sourceText, CodeMetricsOptions options, CancellationToken cancellationToken);
}
internal enum Roslynator.CodeMetrics.LinesOfCodeKind : Enum {
    public int value__;
    public static LinesOfCodeKind Physical;
    public static LinesOfCodeKind Logical;
}
[ExtensionAttribute]
internal static class Roslynator.CollectionExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T SingleOrDefault(IReadOnlyCollection`1<T> values, bool shouldThrow);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T SingleOrDefault(IReadOnlyCollection`1<T> list, Func`2<T, bool> predicate, bool shouldThrow);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.ConsoleColors : ValueType {
    [CompilerGeneratedAttribute]
private static ConsoleColors <Cyan>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConsoleColors <DarkGray>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConsoleColors <Gray>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConsoleColors <Green>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConsoleColors <Magenta>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConsoleColors <Yellow>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsoleColor> <Foreground>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsoleColor> <Background>k__BackingField;
    public static ConsoleColors Cyan { get; }
    public static ConsoleColors DarkGray { get; }
    public static ConsoleColors Gray { get; }
    public static ConsoleColors Green { get; }
    public static ConsoleColors Magenta { get; }
    public static ConsoleColors Yellow { get; }
    public Nullable`1<ConsoleColor> Foreground { get; }
    public Nullable`1<ConsoleColor> Background { get; }
    public bool IsDefault { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public ConsoleColors(Nullable`1<ConsoleColor> foreground);
    public ConsoleColors(Nullable`1<ConsoleColor> foreground, Nullable`1<ConsoleColor> background);
    private static ConsoleColors();
    [CompilerGeneratedAttribute]
public static ConsoleColors get_Cyan();
    [CompilerGeneratedAttribute]
public static ConsoleColors get_DarkGray();
    [CompilerGeneratedAttribute]
public static ConsoleColors get_Gray();
    [CompilerGeneratedAttribute]
public static ConsoleColors get_Green();
    [CompilerGeneratedAttribute]
public static ConsoleColors get_Magenta();
    [CompilerGeneratedAttribute]
public static ConsoleColors get_Yellow();
    [CompilerGeneratedAttribute]
public Nullable`1<ConsoleColor> get_Foreground();
    [CompilerGeneratedAttribute]
public Nullable`1<ConsoleColor> get_Background();
    public bool get_IsDefault();
    private string get_DebuggerDisplay();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ConsoleColors other);
    public virtual int GetHashCode();
    public static bool op_Equality(ConsoleColors left, ConsoleColors right);
    public static bool op_Inequality(ConsoleColors left, ConsoleColors right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.ConsoleUtility : object {
    public static string ReadUserInput(string defaultValue, string prompt);
    public static string ReadUserInput(string defaultValue, string prompt, int position);
    [CompilerGeneratedAttribute]
internal static int <ReadUserInput>g__GetIndex|1_0(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static void <ReadUserInput>g__MoveCursorLeft|1_1(int count);
    [CompilerGeneratedAttribute]
internal static void <ReadUserInput>g__MoveCursorRight|1_2(int offset);
    [CompilerGeneratedAttribute]
internal static void <ReadUserInput>g__Reset|1_3(bool useDefaultValue, <>c__DisplayClass1_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.ConsoleWriter : TextWriterWithVerbosity {
    [CompilerGeneratedAttribute]
private static ConsoleWriter <Out>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConsoleWriter <Error>k__BackingField;
    public static ConsoleWriter Out { get; }
    public static ConsoleWriter Error { get; }
    public static ConsoleColors Colors { get; public set; }
    private ConsoleWriter(TextWriter writer, IFormatProvider formatProvider);
    private static ConsoleWriter();
    [CompilerGeneratedAttribute]
public static ConsoleWriter get_Out();
    [CompilerGeneratedAttribute]
public static ConsoleWriter get_Error();
    public static ConsoleColors get_Colors();
    public static void set_Colors(ConsoleColors value);
    public void Write(string value, ConsoleColors colors);
    public void Write(string value, ConsoleColors colors, Verbosity verbosity);
    public void WriteIf(bool condition, string value, ConsoleColors colors);
    public void WriteLine(string value, ConsoleColors colors);
    public void WriteLine(string value, ConsoleColors colors, Verbosity verbosity);
    public virtual void WriteLine(LogMessage message);
    public void WriteLineIf(bool condition, string value, ConsoleColors colors);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.DiagnosticFormatter : object {
    public static string FormatDiagnostic(Diagnostic diagnostic, string baseDirectoryPath, IFormatProvider formatProvider, bool omitSpan);
    private static void FormatLocation(Location location, string baseDirectoryPath, StringBuilder& sb, bool omitSpan);
    [NullableContextAttribute("2")]
public static string FormatSymbolDefinition(ISymbol symbol, string baseDirectoryPath, string indentation, SymbolDisplayFormat format);
    [CompilerGeneratedAttribute]
internal static string <FormatDiagnostic>g__GetSeverityText|0_0(DiagnosticSeverity severity);
    [CompilerGeneratedAttribute]
internal static string <FormatSymbolDefinition>g__GetSymbolTitle|2_0(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslynator.DiagnosticInfo : ValueType {
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private FileLinePositionSpan <LineSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticSeverity <Severity>k__BackingField;
    public DiagnosticDescriptor Descriptor { get; }
    public FileLinePositionSpan LineSpan { get; }
    public DiagnosticSeverity Severity { get; }
    public DiagnosticInfo(DiagnosticDescriptor descriptor, FileLinePositionSpan lineSpan, DiagnosticSeverity severity);
    [CompilerGeneratedAttribute]
public DiagnosticDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public FileLinePositionSpan get_LineSpan();
    [CompilerGeneratedAttribute]
public DiagnosticSeverity get_Severity();
    public static DiagnosticInfo Create(Diagnostic diagnostic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Diagnostics.CodeAnalyzer : object {
    private AnalyzerLoader _analyzerLoader;
    internal static TimeSpan MinimalExecutionTime;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IFormatProvider <FormatProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeAnalyzerOptions <Options>k__BackingField;
    [NullableAttribute("2")]
public IFormatProvider FormatProvider { get; }
    public CodeAnalyzerOptions Options { get; }
    [NullableContextAttribute("2")]
public CodeAnalyzer(AnalyzerLoader analyzerLoader, IFormatProvider formatProvider, CodeAnalyzerOptions options);
    private static CodeAnalyzer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IFormatProvider get_FormatProvider();
    [CompilerGeneratedAttribute]
public CodeAnalyzerOptions get_Options();
    [AsyncStateMachineAttribute("Roslynator.Diagnostics.CodeAnalyzer/<AnalyzeSolutionAsync>d__9")]
public Task`1<ImmutableArray`1<ProjectAnalysisResult>> AnalyzeSolutionAsync(Solution solution, Func`2<Project, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Diagnostics.CodeAnalyzer/<AnalyzeProjectAsync>d__10")]
public Task`1<ProjectAnalysisResult> AnalyzeProjectAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Diagnostics.CodeAnalyzer/<AnalyzeProjectCoreAsync>d__11")]
private Task`1<ProjectAnalysisResult> AnalyzeProjectCoreAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Diagnostics.CodeAnalyzer/<AnalyzeProjectCoreAsync>d__12")]
private Task`1<ProjectAnalysisResult> AnalyzeProjectCoreAsync(Project project, ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Roslynator.Diagnostics.CodeAnalyzer/<FilterDiagnostics>d__13")]
private IEnumerable`1<Diagnostic> FilterDiagnostics(IEnumerable`1<Diagnostic> diagnostics, Project project, CancellationToken cancellationToken);
    private void WriteProjectAnalysisResults(IList`1<ProjectAnalysisResult> results);
    [CompilerGeneratedAttribute]
internal static void <WriteProjectAnalysisResults>g__WriteExecutionTime|14_1(<>c__DisplayClass14_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Diagnostics.CodeAnalyzerOptions : CodeAnalysisOptions {
    [CompilerGeneratedAttribute]
private static CodeAnalyzerOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCompilerDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportNotConfigurable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportSuppressedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogAnalyzerExecutionTime>k__BackingField;
    public static CodeAnalyzerOptions Default { get; }
    public bool IgnoreCompilerDiagnostics { get; }
    public bool ReportNotConfigurable { get; }
    public bool ReportSuppressedDiagnostics { get; }
    public bool LogAnalyzerExecutionTime { get; }
    [NullableContextAttribute("2")]
public CodeAnalyzerOptions(FileSystemFilter fileSystemFilter, bool ignoreAnalyzerReferences, bool ignoreCompilerDiagnostics, bool reportNotConfigurable, bool reportSuppressedDiagnostics, bool logAnalyzerExecutionTime, bool concurrentAnalysis, DiagnosticSeverity severityLevel, IEnumerable`1<string> supportedDiagnosticIds, IEnumerable`1<string> ignoredDiagnosticIds);
    private static CodeAnalyzerOptions();
    [CompilerGeneratedAttribute]
public static CodeAnalyzerOptions get_Default();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCompilerDiagnostics();
    [CompilerGeneratedAttribute]
public bool get_ReportNotConfigurable();
    [CompilerGeneratedAttribute]
public bool get_ReportSuppressedDiagnostics();
    [CompilerGeneratedAttribute]
public bool get_LogAnalyzerExecutionTime();
}
internal class Roslynator.Diagnostics.ProjectAnalysisResult : object {
    [CompilerGeneratedAttribute]
private SimpleProjectInfo <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticInfo> <CompilerDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticInfo> <Diagnostics>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> <Telemetry>k__BackingField;
    public SimpleProjectInfo Project { get; }
    public ImmutableArray`1<DiagnosticInfo> CompilerDiagnostics { get; }
    public ImmutableArray`1<DiagnosticInfo> Diagnostics { get; }
    [NullableAttribute("1")]
public ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> Telemetry { get; }
    internal ProjectAnalysisResult(SimpleProjectInfo projectId);
    internal ProjectAnalysisResult(SimpleProjectInfo projectId, ImmutableArray`1<DiagnosticInfo> compilerDiagnostics, ImmutableArray`1<DiagnosticInfo> diagnostics, ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> telemetry);
    [CompilerGeneratedAttribute]
public SimpleProjectInfo get_Project();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticInfo> get_CompilerDiagnostics();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticInfo> get_Diagnostics();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> get_Telemetry();
    [NullableContextAttribute("1")]
internal static ProjectAnalysisResult Create(Project project);
    [NullableContextAttribute("1")]
internal static ProjectAnalysisResult Create(Project project, ImmutableArray`1<Diagnostic> compilerDiagnostics, ImmutableArray`1<Diagnostic> diagnostics, ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> telemetry);
}
internal enum Roslynator.DialogResult : Enum {
    public int value__;
    public static DialogResult None;
    public static DialogResult Yes;
    public static DialogResult YesToAll;
    public static DialogResult No;
    public static DialogResult NoToAll;
    public static DialogResult Cancel;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslynator.DocumentReferenceInfo : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <Root>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxNode> <References>k__BackingField;
    public Document Document { get; }
    public SyntaxNode Root { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SyntaxNode> References { get; }
    public DocumentReferenceInfo(Document document, SyntaxNode root, ImmutableArray`1<SyntaxNode> references);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public SyntaxNode get_Root();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxNode> get_References();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslynator.Extensions : object {
    [ExtensionAttribute]
public static bool IsMatch(Matcher matcher, ISymbol symbol, string rootDirectoryPath);
    [ExtensionAttribute]
public static SymbolGroupFilter ToSymbolGroupFilter(TypeKind typeKind);
    [ExtensionAttribute]
public static MemberDeclarationKind GetMemberDeclarationKind(ISymbol symbol);
    [ExtensionAttribute]
public static SymbolGroup GetSymbolGroup(ISymbol symbol);
    [ExtensionAttribute]
public static string GetText(SymbolGroup symbolGroup);
    [ExtensionAttribute]
public static string GetPluralText(SymbolGroup symbolGroup);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue GetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static bool StartsWith(string s, string value1, string value2, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool HasFixAllProvider(CodeFixProvider codeFixProvider, FixAllScope fixAllScope);
    [ExtensionAttribute]
public static void Add(AnalyzerTelemetryInfo telemetryInfo, AnalyzerTelemetryInfo telemetryInfoToAdd);
    [ExtensionAttribute]
public static ConsoleColor GetColor(DiagnosticSeverity diagnosticSeverity);
    [ExtensionAttribute]
public static ConsoleColors GetColors(DiagnosticSeverity diagnosticSeverity);
    [AsyncStateMachineAttribute("Roslynator.Extensions/<CountLinesAsync>d__12")]
[ExtensionAttribute]
public static Task`1<CodeMetricsInfo> CountLinesAsync(ICodeMetricsService service, Project project, LinesOfCodeKind kind, FileSystemFilter fileSystemFilter, CodeMetricsOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Extensions/<CountLinesAsync>d__13")]
[ExtensionAttribute]
public static Task`1<CodeMetricsInfo> CountLinesAsync(ICodeMetricsService service, Document document, LinesOfCodeKind kind, CodeMetricsOptions options, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static OperationCanceledException GetOperationCanceledException(AggregateException aggregateException);
    [ExtensionAttribute]
public static ConsoleColor GetColor(WorkspaceDiagnosticKind kind);
    [ExtensionAttribute]
public static ConsoleColors GetColors(WorkspaceDiagnosticKind kind);
    [ExtensionAttribute]
public static bool IsEffective(Diagnostic diagnostic, CodeAnalysisOptions codeAnalysisOptions, CompilationOptions compilationOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.FileSystemFilter : object {
    [CompilerGeneratedAttribute]
private Matcher <Matcher>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <RootDirectoryPath>k__BackingField;
    public Matcher Matcher { get; }
    [NullableAttribute("2")]
public string RootDirectoryPath { get; public set; }
    private FileSystemFilter(Matcher matcher);
    [CompilerGeneratedAttribute]
public Matcher get_Matcher();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_RootDirectoryPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_RootDirectoryPath(string value);
    public static FileSystemFilter CreateOrDefault(IEnumerable`1<string> include, IEnumerable`1<string> exclude);
    public bool IsMatch(ISymbol symbol);
    public bool IsMatch(string filePath);
}
internal abstract class Roslynator.FindSymbols.AttributeFilterRule : FilterRule`1<AttributeInfo> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal abstract class Roslynator.FindSymbols.FilterRule`1 : object {
    public SymbolFilterReason Reason { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public abstract virtual SymbolFilterReason get_Reason();
    private string get_DebuggerDisplay();
    public abstract virtual bool IsApplicable(T value);
    public abstract virtual bool IsMatch(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.FindSymbols.FindSymbolService : object {
    public ISyntaxFactsService SyntaxFacts { get; }
    public abstract virtual ISyntaxFactsService get_SyntaxFacts();
    public abstract virtual SyntaxNode FindDeclaration(SyntaxNode node);
    public abstract virtual bool CanBeRenamed(SyntaxToken token);
    public abstract virtual ImmutableArray`1<ISymbol> FindLocalSymbols(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Roslynator.FindSymbols.IFindSymbolService {
    public ISyntaxFactsService SyntaxFacts { get; }
    public abstract virtual ISyntaxFactsService get_SyntaxFacts();
    public abstract virtual SyntaxNode FindDeclaration(SyntaxNode node);
    public abstract virtual bool CanBeRenamed(SyntaxToken token);
    public abstract virtual ImmutableArray`1<ISymbol> FindLocalSymbols(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.FindSymbols.IgnoredAttributeNameFilterRule : AttributeFilterRule {
    [CompilerGeneratedAttribute]
private static IgnoredAttributeNameFilterRule <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataNameSet <AttributeNames>k__BackingField;
    public static IgnoredAttributeNameFilterRule Default { get; }
    public MetadataNameSet AttributeNames { get; }
    public SymbolFilterReason Reason { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public IgnoredAttributeNameFilterRule(IEnumerable`1<MetadataName> values);
    private static IgnoredAttributeNameFilterRule();
    [CompilerGeneratedAttribute]
public static IgnoredAttributeNameFilterRule get_Default();
    [CompilerGeneratedAttribute]
public MetadataNameSet get_AttributeNames();
    public virtual bool IsApplicable(AttributeInfo value);
    public virtual SymbolFilterReason get_Reason();
    private string get_DebuggerDisplay();
    public virtual bool IsMatch(AttributeInfo attributeInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.FindSymbols.IgnoredNameSymbolFilterRule : SymbolFilterRule {
    [CompilerGeneratedAttribute]
private MetadataNameSet <Names>k__BackingField;
    public SymbolFilterReason Reason { get; }
    public MetadataNameSet Names { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public IgnoredNameSymbolFilterRule(IEnumerable`1<MetadataName> values);
    public virtual SymbolFilterReason get_Reason();
    [CompilerGeneratedAttribute]
public MetadataNameSet get_Names();
    private string get_DebuggerDisplay();
    public virtual bool IsApplicable(ISymbol value);
    public virtual bool IsMatch(ISymbol value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.FindSymbols.PredicateSymbolFilterRule : SymbolFilterRule {
    private Func`2<ISymbol, bool> _isMatch;
    private Func`2<ISymbol, bool> _isApplicable;
    [CompilerGeneratedAttribute]
private SymbolFilterReason <Reason>k__BackingField;
    public SymbolFilterReason Reason { get; }
    public PredicateSymbolFilterRule(Func`2<ISymbol, bool> isMatch, Func`2<ISymbol, bool> isApplicable, SymbolFilterReason reason);
    public virtual bool IsApplicable(ISymbol value);
    public virtual bool IsMatch(ISymbol value);
    [CompilerGeneratedAttribute]
public virtual SymbolFilterReason get_Reason();
    public PredicateSymbolFilterRule Invert();
    [CompilerGeneratedAttribute]
private bool <Invert>b__8_0(ISymbol f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.FindSymbols.SymbolFilterOptions : object {
    [CompilerGeneratedAttribute]
private static SymbolFilterOptions <Default>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private FileSystemFilter <FileSystemFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private VisibilityFilter <Visibility>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolGroupFilter <SymbolGroups>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SymbolFilterRule> <Rules>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AttributeFilterRule> <AttributeRules>k__BackingField;
    public static SymbolFilterOptions Default { get; }
    [NullableAttribute("2")]
public FileSystemFilter FileSystemFilter { get; }
    public VisibilityFilter Visibility { get; }
    public SymbolGroupFilter SymbolGroups { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SymbolFilterRule> Rules { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<AttributeFilterRule> AttributeRules { get; }
    [NullableContextAttribute("2")]
internal SymbolFilterOptions(FileSystemFilter fileSystemFilter, VisibilityFilter visibility, SymbolGroupFilter symbolGroups, IEnumerable`1<SymbolFilterRule> rules, IEnumerable`1<AttributeFilterRule> attributeRules);
    private static SymbolFilterOptions();
    [CompilerGeneratedAttribute]
public static SymbolFilterOptions get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public FileSystemFilter get_FileSystemFilter();
    [CompilerGeneratedAttribute]
public VisibilityFilter get_Visibility();
    [CompilerGeneratedAttribute]
public SymbolGroupFilter get_SymbolGroups();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SymbolFilterRule> get_Rules();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<AttributeFilterRule> get_AttributeRules();
    public bool Includes(SymbolGroupFilter symbolGroupFilter);
    public bool IsMatch(ISymbol symbol);
    public bool IsMatch(INamespaceSymbol namespaceSymbol);
    public bool IsMatch(INamedTypeSymbol typeSymbol);
    public bool IsMatch(IEventSymbol symbol);
    public bool IsMatch(IFieldSymbol symbol);
    public bool IsMatch(IPropertySymbol symbol);
    public bool IsMatch(IMethodSymbol symbol);
    public bool IsMatch(ISymbol symbol, AttributeData attribute);
    public SymbolFilterReason GetReason(ISymbol symbol);
    public virtual SymbolFilterReason GetReason(INamespaceSymbol namespaceSymbol);
    public virtual SymbolFilterReason GetReason(INamedTypeSymbol typeSymbol);
    public virtual SymbolFilterReason GetReason(IEventSymbol symbol);
    public virtual SymbolFilterReason GetReason(IFieldSymbol symbol);
    public virtual SymbolFilterReason GetReason(IPropertySymbol symbol);
    public virtual SymbolFilterReason GetReason(IMethodSymbol symbol);
    private SymbolFilterReason GetRulesReason(ISymbol symbol);
    public virtual SymbolFilterReason GetReason(ISymbol symbol, AttributeData attribute);
}
internal enum Roslynator.FindSymbols.SymbolFilterReason : Enum {
    public int value__;
    public static SymbolFilterReason None;
    public static SymbolFilterReason Visibility;
    public static SymbolFilterReason SymbolGroup;
    public static SymbolFilterReason Ignored;
    public static SymbolFilterReason WithAttribute;
    public static SymbolFilterReason WithoutAttribute;
    public static SymbolFilterReason ImplicitlyDeclared;
    public static SymbolFilterReason Other;
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Roslynator.FindSymbols.SymbolFilterRule : FilterRule`1<ISymbol> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.Formatting.CodeFormatter : object {
    public static Task`1<Project> FormatProjectAsync(Project project, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Formatting.CodeFormatter/<FormatProjectAsync>d__1")]
public static Task`1<Project> FormatProjectAsync(Project project, ISyntaxFactsService syntaxFacts, CodeFormatterOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Formatting.CodeFormatter/<GetFormattedDocumentsAsync>d__2")]
internal static Task`1<ImmutableArray`1<DocumentId>> GetFormattedDocumentsAsync(Project project, Project newProject, ISyntaxFactsService syntaxFacts);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Roslynator.Formatting.CodeFormatterOptions : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static CodeFormatterOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemFilter <FileSystemFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeGeneratedCode>k__BackingField;
    [NullableAttribute("1")]
public static CodeFormatterOptions Default { get; }
    public FileSystemFilter FileSystemFilter { get; }
    public bool IncludeGeneratedCode { get; }
    public CodeFormatterOptions(FileSystemFilter fileSystemFilter, bool includeGeneratedCode);
    private static CodeFormatterOptions();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static CodeFormatterOptions get_Default();
    [CompilerGeneratedAttribute]
public FileSystemFilter get_FileSystemFilter();
    [CompilerGeneratedAttribute]
public bool get_IncludeGeneratedCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Roslynator.Host.Mef.LanguageMetadata : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    [NullableContextAttribute("1")]
public LanguageMetadata(IDictionary`2<string, object> data);
    [NullableContextAttribute("1")]
public LanguageMetadata(string language);
    [CompilerGeneratedAttribute]
public string get_Language();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Host.Mef.LanguageServiceMetadata : LanguageMetadata {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    [NullableAttribute("2")]
public string ServiceType { get; }
    public IReadOnlyDictionary`2<string, object> Data { get; }
    public LanguageServiceMetadata(IDictionary`2<string, object> data);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Host.Mef.MefHostServices : object {
    [NullableAttribute("2")]
private static MefHostServices _default;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<Assembly> _defaultAssemblies;
    private CompositionContext _compositionContext;
    public static MefHostServices Default { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<Assembly> DefaultAssemblies { get; }
    public MefHostServices(CompositionContext compositionContext);
    public static MefHostServices get_Default();
    public static ImmutableArray`1<Assembly> get_DefaultAssemblies();
    public static MefHostServices Create(CompositionContext compositionContext);
    public static MefHostServices Create(IEnumerable`1<Assembly> assemblies);
    private static ImmutableArray`1<Assembly> LoadDefaultAssemblies();
    private static Assembly TryLoadAssembly(string assemblyName);
    public IEnumerable`1<Lazy`1<TExtension>> GetExports();
    [NullableContextAttribute("2")]
public IEnumerable`1<Lazy`2<TExtension, TMetadata>> GetExports();
    [IteratorStateMachineAttribute("Roslynator.Host.Mef.MefHostServices/<<LoadDefaultAssemblies>g__GetAssemblyNames|10_2>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <LoadDefaultAssemblies>g__GetAssemblyNames|10_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Host.Mef.MefLanguageServices : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> _services;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<Type, Lazy`2<ILanguageService, LanguageServiceMetadata>> _serviceMap;
    [CompilerGeneratedAttribute]
private MefWorkspaceServices <WorkspaceServices>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public MefWorkspaceServices WorkspaceServices { get; }
    public string Language { get; }
    public bool HasServices { get; }
    public MefLanguageServices(MefWorkspaceServices workspaceServices, string language);
    [CompilerGeneratedAttribute]
public MefWorkspaceServices get_WorkspaceServices();
    [CompilerGeneratedAttribute]
public string get_Language();
    public bool get_HasServices();
    [NullableContextAttribute("2")]
public TLanguageService GetService();
    internal bool TryGetService(Type serviceType, Lazy`2& service);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Lazy`2<ILanguageService, LanguageServiceMetadata> <TryGetService>b__12_0(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Host.Mef.MefWorkspaceServices : object {
    [NullableAttribute("2")]
private static MefWorkspaceServices _default;
    private MefHostServices _mefServices;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<string> _languages;
    private ImmutableDictionary`2<string, MefLanguageServices> _languageServicesMap;
    public static MefWorkspaceServices Default { get; }
    public IEnumerable`1<string> SupportedLanguages { get; }
    public MefWorkspaceServices(MefHostServices mefServices);
    public static MefWorkspaceServices get_Default();
    public IEnumerable`1<string> get_SupportedLanguages();
    private IEnumerable`1<string> GetSupportedLanguages();
    public bool IsSupported(string languageName);
    public MefLanguageServices GetLanguageServices(string languageName);
    internal bool TryGetLanguageServices(string languageName, MefLanguageServices& languageServices);
    [NullableContextAttribute("2")]
internal TLanguageService GetService(string languageName);
    internal IEnumerable`1<Lazy`1<TExtension>> GetExports();
    [NullableContextAttribute("2")]
internal IEnumerable`1<Lazy`2<TExtension, TMetadata>> GetExports();
}
[NullableContextAttribute("1")]
internal interface Roslynator.ISyntaxFactsService {
    public string SingleLineCommentStart { get; }
    public abstract virtual string get_SingleLineCommentStart();
    public abstract virtual bool IsComment(SyntaxTrivia trivia);
    public abstract virtual bool IsSingleLineComment(SyntaxTrivia trivia);
    public abstract virtual bool IsEndOfLineTrivia(SyntaxTrivia trivia);
    public abstract virtual bool IsWhitespaceTrivia(SyntaxTrivia trivia);
    public abstract virtual SyntaxTriviaList ParseLeadingTrivia(string text, int offset);
    public abstract virtual SyntaxTriviaList ParseTrailingTrivia(string text, int offset);
    public abstract virtual bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree);
    public abstract virtual bool BeginsWithAutoGeneratedComment(SyntaxNode root);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetSymbolDeclaration(SyntaxToken identifier);
    public abstract virtual bool IsValidIdentifier(string name);
}
[NullableContextAttribute("1")]
internal interface Roslynator.IUserDialog {
    public abstract virtual DialogResult ShowDialog(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.Logger : object {
    [CompilerGeneratedAttribute]
private static ConsoleWriter <ConsoleOut>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConsoleWriter <ConsoleError>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static TextWriterWithVerbosity <Out>k__BackingField;
    public static ConsoleWriter ConsoleOut { get; }
    public static ConsoleWriter ConsoleError { get; }
    [NullableAttribute("2")]
public static TextWriterWithVerbosity Out { get; public set; }
    private static Logger();
    [CompilerGeneratedAttribute]
public static ConsoleWriter get_ConsoleOut();
    [CompilerGeneratedAttribute]
public static ConsoleWriter get_ConsoleError();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static TextWriterWithVerbosity get_Out();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_Out(TextWriterWithVerbosity value);
    public static void Write(char value);
    public static void Write(char value, int repeatCount);
    public static void Write(char value, int repeatCount, Verbosity verbosity);
    public static void Write(Char[] buffer);
    public static void Write(Char[] buffer, int index, int count);
    public static void Write(bool value);
    public static void Write(int value);
    public static void Write(UInt32 value);
    public static void Write(long value);
    public static void Write(ulong value);
    public static void Write(float value);
    public static void Write(double value);
    public static void Write(decimal value);
    [NullableContextAttribute("2")]
public static void Write(string value);
    [NullableContextAttribute("2")]
public static void Write(string value, Verbosity verbosity);
    public static void Write(string value, ConsoleColors colors);
    public static void Write(string value, ConsoleColors colors, Verbosity verbosity);
    public static void WriteIf(bool condition, string value);
    public static void WriteIf(bool condition, string value, ConsoleColors colors);
    public static void Write(object value);
    public static void WriteLine();
    public static void WriteLine(Verbosity verbosity);
    public static void WriteLineIf(bool condition);
    public static void WriteLine(char value);
    public static void WriteLine(Char[] buffer);
    public static void WriteLine(Char[] buffer, int index, int count);
    public static void WriteLine(bool value);
    public static void WriteLine(int value);
    public static void WriteLine(UInt32 value);
    public static void WriteLine(long value);
    public static void WriteLine(ulong value);
    public static void WriteLine(float value);
    public static void WriteLine(double value);
    public static void WriteLine(decimal value);
    public static void WriteLine(string value);
    public static void WriteLine(string value, Verbosity verbosity);
    public static void WriteLine(string value, ConsoleColors colors);
    public static void WriteLine(string value, ConsoleColors colors, Verbosity verbosity);
    public static void WriteLine(LogMessage message);
    public static void WriteLineIf(bool condition, string value);
    public static void WriteLineIf(bool condition, string value, ConsoleColors colors);
    public static void WriteLine(object value);
    public static void WriteCriticalError(Exception exception);
    public static void WriteError(Exception exception, ConsoleColor color, Verbosity verbosity);
    private static void WriteError(Exception exception, bool isCritical, ConsoleColor color, Verbosity verbosity);
    public static bool ShouldWrite(Verbosity verbosity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.LogHelpers : object {
    public static void WriteElapsedTime(string message, TimeSpan elapsedTime, Verbosity verbosity);
    [NullableContextAttribute("2")]
public static void WriteDiagnostic(Diagnostic diagnostic, string baseDirectoryPath, IFormatProvider formatProvider, string indentation, bool omitSpan, Verbosity verbosity);
    [NullableContextAttribute("2")]
public static void WriteDiagnostics(ImmutableArray`1<Diagnostic> diagnostics, string baseDirectoryPath, IFormatProvider formatProvider, string indentation, int maxCount, Verbosity verbosity);
    public static void WriteSpellingDiagnostic(SpellingDiagnostic diagnostic, SpellcheckOptions options, SourceText sourceText, string baseDirectoryPath, string indentation, Verbosity verbosity);
    public static void WriteLineSpan(TextSpan span, int context, SourceText sourceText, string indentation, Verbosity verbosity);
    public static void WriteAnalyzerExceptionDiagnostics(ImmutableArray`1<Diagnostic> diagnostics);
    public static void WriteFixSummary(IEnumerable`1<Diagnostic> fixedDiagnostics, IEnumerable`1<Diagnostic> unfixedDiagnostics, IEnumerable`1<Diagnostic> unfixableDiagnostics, string baseDirectoryPath, string indentation, bool addEmptyLine, IFormatProvider formatProvider, Verbosity verbosity);
    public static void WriteInfiniteLoopSummary(ImmutableArray`1<Diagnostic> diagnostics, ImmutableArray`1<Diagnostic> previousDiagnostics, Project project, IFormatProvider formatProvider);
    public static void WriteFormattedDocuments(ImmutableArray`1<DocumentId> documentIds, Project project, string solutionDirectory);
    public static void WriteUsedAnalyzers(ImmutableArray`1<DiagnosticAnalyzer> analyzers, Func`2<DiagnosticDescriptor, bool> predicate, CodeAnalysisOptions options, ConsoleColors colors, Verbosity verbosity);
    public static void WriteUsedFixers(ImmutableArray`1<CodeFixProvider> fixers, CodeAnalysisOptions options, ConsoleColors colors, Verbosity verbosity);
    public static void WriteMultipleFixersSummary(string diagnosticId, CodeFixProvider fixer1, CodeFixProvider fixer2);
    public static void WriteMultipleOperationsSummary(CodeAction fix);
    [NullableContextAttribute("2")]
public static int WriteCompilerErrors(ImmutableArray`1<Diagnostic> diagnostics, string baseDirectoryPath, HashSet`1<string> ignoredCompilerDiagnosticIds, IFormatProvider formatProvider, string indentation, int limit);
    [CompilerGeneratedAttribute]
internal static void <WriteSpellingDiagnostic>g__WriteTextLine|3_0(int i, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <WriteLineSpan>g__WriteTextLine|4_0(int i, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static void <WriteFixSummary>g__WriteDiagnosticRules|6_0(IEnumerable`1<Diagnostic> diagnostics, string title, <>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslynator.LogMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsoleColors> <Colors>k__BackingField;
    [CompilerGeneratedAttribute]
private Verbosity <Verbosity>k__BackingField;
    public string Text { get; }
    public Nullable`1<ConsoleColors> Colors { get; }
    public Verbosity Verbosity { get; }
    public LogMessage(string text);
    public LogMessage(string text, Nullable`1<ConsoleColors> colors);
    public LogMessage(string text, Verbosity verbosity);
    public LogMessage(string text, Nullable`1<ConsoleColors> colors, Verbosity verbosity);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public Nullable`1<ConsoleColors> get_Colors();
    [CompilerGeneratedAttribute]
public Verbosity get_Verbosity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.MemberNameGenerator : object {
    [AsyncStateMachineAttribute("Roslynator.MemberNameGenerator/<EnsureUniqueMemberNameAsync>d__0")]
public static Task`1<string> EnsureUniqueMemberNameAsync(string baseName, ISymbol memberSymbol, Solution solution, NameGenerator nameGenerator, bool isCaseSensitive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.MemberNameGenerator/<IsUniqueMemberNameAsync>d__1")]
public static Task`1<bool> IsUniqueMemberNameAsync(string name, ISymbol memberSymbol, Solution solution, bool isCaseSensitive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.MemberNameGenerator/<GetReservedNamesAsync>d__2")]
private static Task`1<HashSet`1<string>> GetReservedNamesAsync(ISymbol memberSymbol, Solution solution, bool isCaseSensitive, CancellationToken cancellationToken);
    private static HashSet`1<string> GetMemberNames(ISymbol memberSymbol, bool isCaseSensitive);
    private static HashSet`1<string> CreateHashSet(IEnumerable`1<string> names, bool isCaseSensitive);
    private static HashSet`1<string> CreateHashSet(bool isCaseSensitive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.MemberSymbolDefinitionComparer : object {
    [CompilerGeneratedAttribute]
private SymbolDefinitionComparer <SymbolComparer>k__BackingField;
    public SymbolDefinitionComparer SymbolComparer { get; }
    internal MemberSymbolDefinitionComparer(SymbolDefinitionComparer symbolComparer);
    [CompilerGeneratedAttribute]
public SymbolDefinitionComparer get_SymbolComparer();
    public sealed virtual int Compare(ISymbol x, ISymbol y);
    private int CompareMethods(IMethodSymbol methodSymbol1, IMethodSymbol methodSymbol2);
    private int CompareProperties(IPropertySymbol propertySymbol1, IPropertySymbol propertySymbol2);
    [NullableContextAttribute("0")]
private int CompareExplicitImplementations(ImmutableArray`1<TSymbol> x, ImmutableArray`1<TSymbol> y);
    private static int CompareParameters(ImmutableArray`1<IParameterSymbol> parameters1, ImmutableArray`1<IParameterSymbol> parameters2);
    private static int CompareParameter(IParameterSymbol x, IParameterSymbol y);
    private int CompareContainingNamespace(ISymbol x, ISymbol y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.NamedTypeSymbolDefinitionComparer : object {
    [CompilerGeneratedAttribute]
private SymbolDefinitionComparer <SymbolComparer>k__BackingField;
    public SymbolDefinitionComparer SymbolComparer { get; }
    internal NamedTypeSymbolDefinitionComparer(SymbolDefinitionComparer symbolComparer);
    [CompilerGeneratedAttribute]
public SymbolDefinitionComparer get_SymbolComparer();
    public sealed virtual int Compare(INamedTypeSymbol x, INamedTypeSymbol y);
    [CompilerGeneratedAttribute]
internal static int <Compare>g__CountContainingTypes|4_0(INamedTypeSymbol namedType);
    [CompilerGeneratedAttribute]
internal static INamedTypeSymbol <Compare>g__GetContainingType|4_1(INamedTypeSymbol namedType, int count);
    [CompilerGeneratedAttribute]
internal static int <Compare>g__GetRank|4_2(INamedTypeSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.NamespaceSymbolDefinitionComparer : object {
    [CompilerGeneratedAttribute]
private SymbolDefinitionComparer <SymbolComparer>k__BackingField;
    public SymbolDefinitionComparer SymbolComparer { get; }
    internal NamespaceSymbolDefinitionComparer(SymbolDefinitionComparer symbolComparer);
    [CompilerGeneratedAttribute]
public SymbolDefinitionComparer get_SymbolComparer();
    public sealed virtual int Compare(INamespaceSymbol x, INamespaceSymbol y);
    [CompilerGeneratedAttribute]
internal static int <Compare>g__CountContainingNamespaces|4_0(INamespaceSymbol namespaceSymbol);
    [CompilerGeneratedAttribute]
internal static INamespaceSymbol <Compare>g__GetNamespaceSymbol|4_1(INamespaceSymbol namespaceSymbol, int count);
}
internal static class Roslynator.PathUtilities : object {
    [NullableContextAttribute("1")]
internal static string TrimStart(string path, string basePath, bool trimLeadingDirectorySeparator);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslynator.ProjectOrSolution : ValueType {
    private Project _project;
    private Solution _solution;
    public bool IsProject { get; }
    public bool IsSolution { get; }
    public bool IsDefault { get; }
    public string FilePath { get; }
    public VersionStamp Version { get; }
    public Workspace Workspace { get; }
    [NullableContextAttribute("1")]
internal ProjectOrSolution(Project project);
    [NullableContextAttribute("1")]
internal ProjectOrSolution(Solution solution);
    public bool get_IsProject();
    public bool get_IsSolution();
    public bool get_IsDefault();
    public string get_FilePath();
    public VersionStamp get_Version();
    public Workspace get_Workspace();
    public Project AsProject();
    public Solution AsSolution();
    public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectOrSolution other);
    public virtual int GetHashCode();
    public static bool op_Equality(ProjectOrSolution& left, ProjectOrSolution& right);
    public static bool op_Inequality(ProjectOrSolution& left, ProjectOrSolution& right);
    [NullableContextAttribute("1")]
public static ProjectOrSolution op_Implicit(Project project);
    public static Project op_Implicit(ProjectOrSolution& projectOrSolution);
    [NullableContextAttribute("1")]
public static ProjectOrSolution op_Implicit(Solution solution);
    public static Solution op_Implicit(ProjectOrSolution& projectOrSolution);
}
public enum Roslynator.Rename.CompilationErrorResolution : Enum {
    public int value__;
    public static CompilationErrorResolution Ignore;
    public static CompilationErrorResolution Throw;
    public static CompilationErrorResolution Skip;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Rename.DiffSpan : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Diff>k__BackingField;
    public TextSpan Span { get; }
    public int Diff { get; }
    public int Start { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public DiffSpan(TextSpan span, int diff);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public int get_Diff();
    public int get_Start();
    private string get_DebuggerDisplay();
    public DiffSpan Offset(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Rename.DiffTracker : object {
    private Dictionary`2<DocumentId, List`1<DiffSpan>> _dic;
    public int Count { get; }
    public int get_Count();
    public bool TryGetValue(DocumentId documentId, List`1& spans);
    internal static TextSpan GetCurrentSpan(TextSpan span, DocumentId documentId, DiffTracker diffTracker);
    public TextSpan GetCurrentSpan(TextSpan span, DocumentId documentId);
    public bool SpanExists(TextSpan span, DocumentId documentId);
    public void AddLocations(IEnumerable`1<Location> locations, int diff, Solution solution);
    public void AddLocation(Location location, int diff, DocumentId documentId);
    public void AddSpan(TextSpan span, int diff, DocumentId documentId);
    private static void AddSpan(TextSpan span, int diff, List`1<DiffSpan> spans);
    public void Add(DiffTracker other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Rename.LocalSymbolComparer : object {
    [CompilerGeneratedAttribute]
private static LocalSymbolComparer <Instance>k__BackingField;
    public static LocalSymbolComparer Instance { get; }
    private static LocalSymbolComparer();
    [CompilerGeneratedAttribute]
public static LocalSymbolComparer get_Instance();
    public sealed virtual int Compare(ISymbol x, ISymbol y);
    [CompilerGeneratedAttribute]
internal static int <Compare>g__GetRank|3_0(ISymbol symbol);
}
internal enum Roslynator.Rename.RenameScope : Enum {
    public int value__;
    public static RenameScope Type;
    public static RenameScope Member;
    public static RenameScope Local;
}
[FlagsAttribute]
internal enum Roslynator.Rename.RenameScopeFilter : Enum {
    public int value__;
    public static RenameScopeFilter None;
    public static RenameScopeFilter Type;
    public static RenameScopeFilter Member;
    public static RenameScopeFilter Local;
    public static RenameScopeFilter All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Rename.SymbolData : ValueType {
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public ISymbol Symbol { get; }
    [NullableAttribute("2")]
public string Id { get; }
    public DocumentId DocumentId { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public SymbolData(ISymbol symbol, string id, DocumentId documentId);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.Rename.SymbolListHelpers : object {
    public static List`1<ISymbol> SortTypeSymbols(IEnumerable`1<ISymbol> symbols);
    public static List`1<ISymbol> SortAndFilterMemberSymbols(IEnumerable`1<ISymbol> symbols);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Roslynator.Rename.SymbolProvider : object {
    [CompilerGeneratedAttribute]
private bool <IncludeGeneratedCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Matcher <FileSystemMatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootDirectoryPath>k__BackingField;
    public bool IncludeGeneratedCode { get; public set; }
    public Matcher FileSystemMatcher { get; public set; }
    public string RootDirectoryPath { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IncludeGeneratedCode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeGeneratedCode(bool value);
    [CompilerGeneratedAttribute]
public Matcher get_FileSystemMatcher();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileSystemMatcher(Matcher value);
    [CompilerGeneratedAttribute]
public string get_RootDirectoryPath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RootDirectoryPath(string value);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Roslynator.Rename.SymbolProvider/<GetSymbolsAsync>d__12")]
public Task`1<IEnumerable`1<ISymbol>> GetSymbolsAsync(Project project, RenameScope scope, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.Rename.SymbolRenameProgress : ValueType {
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolRenameResult <Result>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public ISymbol Symbol { get; }
    public string NewName { get; }
    public SymbolRenameResult Result { get; }
    [NullableAttribute("2")]
public Exception Exception { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal SymbolRenameProgress(ISymbol symbol, string newName, SymbolRenameResult result, Exception exception);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public string get_NewName();
    [CompilerGeneratedAttribute]
public SymbolRenameResult get_Result();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_Exception();
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Roslynator.Rename.SymbolRenamer : object {
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenamer/<RenameSymbolsAsync>d__0")]
public static Task RenameSymbolsAsync(Solution solution, Func`2<ISymbol, bool> predicate, Func`2<ISymbol, string> getNewName, SymbolRenamerOptions options, IProgress`1<SymbolRenameProgress> progress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenamer/<RenameSymbolsAsync>d__1")]
public static Task RenameSymbolsAsync(IEnumerable`1<Project> projects, Func`2<ISymbol, bool> predicate, Func`2<ISymbol, string> getNewName, SymbolRenamerOptions options, IProgress`1<SymbolRenameProgress> progress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenamer/<RenameSymbolsAsync>d__2")]
public static Task RenameSymbolsAsync(Project project, Func`2<ISymbol, bool> predicate, Func`2<ISymbol, string> getNewName, SymbolRenamerOptions options, IProgress`1<SymbolRenameProgress> progress, CancellationToken cancellationToken);
}
public enum Roslynator.Rename.SymbolRenameResult : Enum {
    public int value__;
    public static SymbolRenameResult Success;
    public static SymbolRenameResult Error;
    public static SymbolRenameResult CompilationError;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Roslynator.Rename.SymbolRenamerOptions : object {
    [CompilerGeneratedAttribute]
private bool <SkipTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipLocals>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationErrorResolution <CompilationErrorResolution>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private HashSet`1<string> <IgnoredCompilerDiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeGeneratedCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DryRun>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameOverloads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameInStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameInComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Matcher <FileSystemMatcher>k__BackingField;
    public bool SkipTypes { get; public set; }
    public bool SkipMembers { get; public set; }
    public bool SkipLocals { get; public set; }
    public CompilationErrorResolution CompilationErrorResolution { get; public set; }
    [NullableAttribute("1")]
public HashSet`1<string> IgnoredCompilerDiagnosticIds { get; }
    public bool IncludeGeneratedCode { get; public set; }
    public bool DryRun { get; public set; }
    public bool RenameOverloads { get; public set; }
    public bool RenameInStrings { get; public set; }
    public bool RenameInComments { get; public set; }
    public bool RenameFile { get; public set; }
    internal Matcher FileSystemMatcher { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_SkipTypes();
    [CompilerGeneratedAttribute]
public void set_SkipTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipMembers();
    [CompilerGeneratedAttribute]
public void set_SkipMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipLocals();
    [CompilerGeneratedAttribute]
public void set_SkipLocals(bool value);
    [CompilerGeneratedAttribute]
public CompilationErrorResolution get_CompilationErrorResolution();
    [CompilerGeneratedAttribute]
public void set_CompilationErrorResolution(CompilationErrorResolution value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public HashSet`1<string> get_IgnoredCompilerDiagnosticIds();
    [CompilerGeneratedAttribute]
public bool get_IncludeGeneratedCode();
    [CompilerGeneratedAttribute]
public void set_IncludeGeneratedCode(bool value);
    [CompilerGeneratedAttribute]
public bool get_DryRun();
    [CompilerGeneratedAttribute]
public void set_DryRun(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameOverloads();
    [CompilerGeneratedAttribute]
public void set_RenameOverloads(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameInStrings();
    [CompilerGeneratedAttribute]
public void set_RenameInStrings(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameInComments();
    [CompilerGeneratedAttribute]
public void set_RenameInComments(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameFile();
    [CompilerGeneratedAttribute]
public void set_RenameFile(bool value);
    [CompilerGeneratedAttribute]
internal Matcher get_FileSystemMatcher();
    [CompilerGeneratedAttribute]
internal void set_FileSystemMatcher(Matcher value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Rename.SymbolRenameState : object {
    private DiffTracker _diffTracker;
    [CompilerGeneratedAttribute]
private Workspace <Workspace>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolRenamerOptions <Options>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IProgress`1<SymbolRenameProgress> <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ISymbol, string> <GetNewName>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ISymbol, bool> <Predicate>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CurrentDirectoryPath>k__BackingField;
    protected Workspace Workspace { get; }
    protected Solution CurrentSolution { get; }
    public SymbolRenamerOptions Options { get; }
    [NullableAttribute("2")]
protected IProgress`1<SymbolRenameProgress> Progress { get; }
    protected Func`2<ISymbol, string> GetNewName { get; }
    protected Func`2<ISymbol, bool> Predicate { get; }
    private bool DryRun { get; }
    [NullableAttribute("2")]
protected string CurrentDirectoryPath { get; protected set; }
    public SymbolRenameState(Solution solution, Func`2<ISymbol, bool> predicate, Func`2<ISymbol, string> getNewName, SymbolRenamerOptions options, IProgress`1<SymbolRenameProgress> progress);
    [CompilerGeneratedAttribute]
protected Workspace get_Workspace();
    protected Solution get_CurrentSolution();
    [CompilerGeneratedAttribute]
public SymbolRenamerOptions get_Options();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected IProgress`1<SymbolRenameProgress> get_Progress();
    [CompilerGeneratedAttribute]
protected Func`2<ISymbol, string> get_GetNewName();
    [CompilerGeneratedAttribute]
protected Func`2<ISymbol, bool> get_Predicate();
    private bool get_DryRun();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected string get_CurrentDirectoryPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected void set_CurrentDirectoryPath(string value);
    public Task RenameSymbolsAsync(CancellationToken cancellationToken);
    public Task RenameSymbolsAsync(IEnumerable`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenameState/<RenameSymbolsAsync>d__27")]
protected virtual Task RenameSymbolsAsync(ImmutableArray`1<ProjectId> projects, bool isSolution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenameState/<RenameSymbolsAsync>d__28")]
public virtual Task RenameSymbolsAsync(Project project, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Roslynator.Rename.SymbolRenameState/<GetRenameScopes>d__29")]
protected IEnumerable`1<RenameScope> GetRenameScopes();
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenameState/<AnalyzeProjectAsync>d__30")]
protected Task AnalyzeProjectAsync(Project project, RenameScope scope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenameState/<RenameSymbolsAsync>d__31")]
private Task`1<List`1<string>> RenameSymbolsAsync(IEnumerable`1<SymbolData> symbols, IFindSymbolService findSymbolService, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenameState/<RenameLocalSymbolsAsync>d__32")]
private Task RenameLocalSymbolsAsync(IEnumerable`1<ISymbol> symbols, IFindSymbolService findSymbolService, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenameState/<RenameLocalFunctionsAndItsParametersAsync>d__33")]
private Task RenameLocalFunctionsAndItsParametersAsync(SyntaxNode node, DocumentId documentId, HashSet`1<int> indexes, DiffTracker diffTracker, IFindSymbolService findSymbolService, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenameState/<RenameLocalsAndLambdaParametersAsync>d__34")]
private Task RenameLocalsAndLambdaParametersAsync(SyntaxNode node, DocumentId documentId, HashSet`1<int> indexes, DiffTracker diffTracker, IFindSymbolService findSymbolService, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenameState/<RenameSymbolAsync>d__35")]
private Task`1<bool> RenameSymbolAsync(SymbolData symbolData, TextSpan span, Document document, SemanticModel semanticModel, IFindSymbolService findSymbolService, DiffTracker diffTracker, List`1<string> ignoreIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Rename.SymbolRenameState/<RenameSymbolAsync>d__36")]
protected virtual Task`1<ValueTuple`2<string, Solution>> RenameSymbolAsync(ISymbol symbol, string symbolId, List`1<string> ignoreIds, IFindSymbolService findSymbolService, TextSpan span, Document document, CancellationToken cancellationToken);
    private void Report(ISymbol symbol, string newName, SymbolRenameResult result, Exception exception);
    private static string GetSymbolId(ISymbol symbol);
    private static void IgnoreSymbol(ISymbol symbol, List`1<string> ignoreIds);
    [NullableContextAttribute("2")]
private static void IgnoreSymbolId(string symbolId, List`1<string> ignoreIds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.SimpleProjectInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string Name { get; }
    [NullableAttribute("2")]
public string FilePath { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public SimpleProjectInfo(string name, string filePath);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_FilePath();
    private string get_DebuggerDisplay();
    public static SimpleProjectInfo Create(Project project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Spelling.FixList : object {
    [CompilerGeneratedAttribute]
private static FixList <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ImmutableHashSet`1<SpellingFix>> <Items>k__BackingField;
    public static FixList Empty { get; }
    public ImmutableDictionary`2<string, ImmutableHashSet`1<SpellingFix>> Items { get; }
    public int Count { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public FixList(ImmutableDictionary`2<string, ImmutableHashSet`1<SpellingFix>> values);
    private static FixList();
    [CompilerGeneratedAttribute]
public static FixList get_Empty();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ImmutableHashSet`1<SpellingFix>> get_Items();
    public int get_Count();
    private string get_DebuggerDisplay();
    public bool ContainsKey(string key);
    public bool TryGetValue(string key, ImmutableHashSet`1& value);
    public bool TryGetKey(string equalKey, String& actualKey);
    public FixList Add(string key, SpellingFix fix);
    public static FixList Load(IEnumerable`1<string> paths);
    public static FixList LoadFiles(IEnumerable`1<string> filePaths);
    public static FixList LoadFile(string path);
    private static void LoadFile(string path, Dictionary`2& dic);
    internal static FixList Create(Dictionary`2<string, HashSet`1<string>> dic);
    public void Save(string path);
    public static void Save(string path, IEnumerable`1<KeyValuePair`2<string, ImmutableHashSet`1<SpellingFix>>> values);
    public FixList SaveAndLoad(string path);
    internal static string GetItemText(string key, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.Spelling.Hash : object {
    private static int OffsetBasis;
    private static int Prime;
    public static int Combine(int value);
    public static int Combine(bool value);
    public static int Combine(T value);
    public static int Combine(int value, int hash);
    public static int Combine(bool value, int hash);
    public static int Combine(T value, int hash);
}
[NullableContextAttribute("1")]
internal interface Roslynator.Spelling.ISpellingService {
    public ISyntaxFactsService SyntaxFacts { get; }
    public abstract virtual ISyntaxFactsService get_SyntaxFacts();
    public abstract virtual DiagnosticAnalyzer CreateAnalyzer(SpellingData spellingData, SpellcheckOptions options);
    public abstract virtual ImmutableArray`1<Diagnostic> AnalyzeSpelling(SyntaxNode node, SpellingData spellingData, SpellcheckOptions options, CancellationToken cancellationToken);
    public abstract virtual SpellingDiagnostic CreateSpellingDiagnostic(Diagnostic diagnostic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Spelling.SpellcheckAnalyzer : object {
    public static DiagnosticDescriptor DiagnosticDescriptor;
    [CompilerGeneratedAttribute]
private Workspace <Workspace>k__BackingField;
    [CompilerGeneratedAttribute]
private SpellingData <SpellingData>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IFormatProvider <FormatProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private SpellcheckOptions <Options>k__BackingField;
    public Workspace Workspace { get; }
    public SpellingData SpellingData { get; private set; }
    [NullableAttribute("2")]
public IFormatProvider FormatProvider { get; }
    public SpellcheckOptions Options { get; }
    private Solution CurrentSolution { get; }
    public SpellcheckAnalyzer(Solution solution, SpellingData spellingData, IFormatProvider formatProvider, SpellcheckOptions options);
    private static SpellcheckAnalyzer();
    [CompilerGeneratedAttribute]
public Workspace get_Workspace();
    [CompilerGeneratedAttribute]
public SpellingData get_SpellingData();
    [CompilerGeneratedAttribute]
private void set_SpellingData(SpellingData value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IFormatProvider get_FormatProvider();
    [CompilerGeneratedAttribute]
public SpellcheckOptions get_Options();
    private Solution get_CurrentSolution();
    [AsyncStateMachineAttribute("Roslynator.Spelling.SpellcheckAnalyzer/<FixSolutionAsync>d__17")]
public Task`1<ImmutableArray`1<SpellingFixResult>> FixSolutionAsync(Func`2<Project, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Spelling.SpellcheckAnalyzer/<FixProjectAsync>d__18")]
public Task`1<ImmutableArray`1<SpellingFixResult>> FixProjectAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Spelling.SpellcheckAnalyzer/<FixCommentsAsync>d__19")]
private Task`1<List`1<SpellingFixResult>> FixCommentsAsync(Project project, List`1<SpellingDiagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.Spelling.SpellcheckAnalyzer/<FixSymbolsAsync>d__20")]
private Task`1<ValueTuple`2<List`1<SpellingFixResult>, bool>> FixSymbolsAsync(Project project, List`1<SpellingDiagnostic> spellingDiagnostics, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken);
    private SpellingFix GetFix(SpellingDiagnostic diagnostic);
    private static void WriteFix(SpellingDiagnostic diagnostic, SpellingFix fix, Nullable`1<ConsoleColors> colors);
    private void ProcessFix(SpellingDiagnostic diagnostic, SpellingFix spellingFix);
    private void AddIgnoredValue(SpellingDiagnostic diagnostic);
    private static string GetLocationText(Location location, Project project);
    [CompilerGeneratedAttribute]
internal static void <FixSymbolsAsync>g__AddResult|20_5(List`1<SpellingFixResult> results, SpellingDiagnostic diagnostic, SpellingFix fix, SourceText sourceText, String& sourceTextText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Spelling.Spellchecker : object {
    private static string _splitCasePattern;
    private static Regex _urlRegex;
    private Regex _splitRegex;
    [CompilerGeneratedAttribute]
private SpellingData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private SpellcheckerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <WordRegex>k__BackingField;
    private static Regex _splitIdentifierRegex;
    public SpellingData Data { get; }
    public SpellcheckerOptions Options { get; }
    internal static Regex WordRegex { get; }
    public Spellchecker(SpellingData data, SpellcheckerOptions options);
    private static Spellchecker();
    [CompilerGeneratedAttribute]
public SpellingData get_Data();
    [CompilerGeneratedAttribute]
public SpellcheckerOptions get_Options();
    [CompilerGeneratedAttribute]
internal static Regex get_WordRegex();
    [NullableContextAttribute("0")]
public ImmutableArray`1<SpellingMatch> AnalyzeText(string value);
    [NullableContextAttribute("0")]
public ImmutableArray`1<SpellingMatch> AnalyzeText(string value, int startIndex, int length);
    private void AnalyzeTextSegment(string value, int startIndex, int length, Builder& builder);
    private void AnalyzeWord(string input, string value, int index, Builder& builder);
    private void AnalyzeWordPart(string input, string value, int index, string parentValue, int parentIndex, Builder& builder);
    private bool IsMatch(string value);
    private bool IsAllowedLength(int value);
    private static bool IsAllowedNonsensicalWord(string value);
    [NullableContextAttribute("0")]
internal ImmutableArray`1<SpellingMatch> AnalyzeIdentifier(string value, int prefixLength);
    [NullableContextAttribute("2")]
private void AnalyzeIdentifierValue(string value, int valueIndex, string parentValue, Builder& builder);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeWordPart>g__IsContainedInNonWord|17_0(string input, string value, int index, WordList wordList);
    [CompilerGeneratedAttribute]
internal static bool <IsAllowedNonsensicalWord>g__IsAbcSequence|20_0(<>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsAllowedNonsensicalWord>g__IsAaaSequence|20_1(<>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsAllowedNonsensicalWord>g__IsAaaBbbCccSequence|20_2(<>c__DisplayClass20_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Spelling.SpellcheckerOptions : object {
    [CompilerGeneratedAttribute]
private static SpellcheckerOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private SplitMode <SplitMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinWordLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxWordLength>k__BackingField;
    public static SpellcheckerOptions Default { get; }
    public SplitMode SplitMode { get; }
    public int MinWordLength { get; }
    public int MaxWordLength { get; }
    public SpellcheckerOptions(SplitMode splitMode, int minWordLength, int maxWordLength);
    private static SpellcheckerOptions();
    [CompilerGeneratedAttribute]
public static SpellcheckerOptions get_Default();
    [CompilerGeneratedAttribute]
public SplitMode get_SplitMode();
    [CompilerGeneratedAttribute]
public int get_MinWordLength();
    [CompilerGeneratedAttribute]
public int get_MaxWordLength();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Roslynator.Spelling.SpellcheckOptions : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static SpellcheckOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private FileSystemFilter <FileSystemFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private SpellingScopeFilter <ScopeFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private VisibilityFilter <SymbolVisibility>k__BackingField;
    [CompilerGeneratedAttribute]
private SplitMode <SplitMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinWordLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxWordLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeGeneratedCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Autofix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Interactive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DryRun>k__BackingField;
    [NullableAttribute("1")]
public static SpellcheckOptions Default { get; }
    public FileSystemFilter FileSystemFilter { get; public set; }
    public SpellingScopeFilter ScopeFilter { get; public set; }
    public VisibilityFilter SymbolVisibility { get; public set; }
    public SplitMode SplitMode { get; public set; }
    public int MinWordLength { get; public set; }
    public int MaxWordLength { get; public set; }
    public int CodeContext { get; public set; }
    public bool IncludeGeneratedCode { get; public set; }
    public bool Autofix { get; public set; }
    public bool Interactive { get; public set; }
    public bool DryRun { get; public set; }
    private static SpellcheckOptions();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static SpellcheckOptions get_Default();
    [CompilerGeneratedAttribute]
public FileSystemFilter get_FileSystemFilter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileSystemFilter(FileSystemFilter value);
    [CompilerGeneratedAttribute]
public SpellingScopeFilter get_ScopeFilter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ScopeFilter(SpellingScopeFilter value);
    [CompilerGeneratedAttribute]
public VisibilityFilter get_SymbolVisibility();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SymbolVisibility(VisibilityFilter value);
    [CompilerGeneratedAttribute]
public SplitMode get_SplitMode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SplitMode(SplitMode value);
    [CompilerGeneratedAttribute]
public int get_MinWordLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MinWordLength(int value);
    [CompilerGeneratedAttribute]
public int get_MaxWordLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MaxWordLength(int value);
    [CompilerGeneratedAttribute]
public int get_CodeContext();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CodeContext(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeGeneratedCode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeGeneratedCode(bool value);
    [CompilerGeneratedAttribute]
public bool get_Autofix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Autofix(bool value);
    [CompilerGeneratedAttribute]
public bool get_Interactive();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Interactive(bool value);
    [CompilerGeneratedAttribute]
public bool get_DryRun();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DryRun(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Spelling.SpellingAnalysisContext : object {
    private Action`1<Diagnostic> _reportDiagnostic;
    private Spellchecker _spellchecker;
    [CompilerGeneratedAttribute]
private SpellingData <SpellingData>k__BackingField;
    [CompilerGeneratedAttribute]
private SpellcheckOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public SpellingData SpellingData { get; }
    public SpellcheckOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public SpellingAnalysisContext(Action`1<Diagnostic> reportDiagnostic, SpellingData spellingData, SpellcheckOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public SpellingData get_SpellingData();
    [CompilerGeneratedAttribute]
public SpellcheckOptions get_Options();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    public void AnalyzeText(string value, TextSpan textSpan, SyntaxTree syntaxTree);
    public void AnalyzeFileName(SyntaxTree syntaxTree);
    public void AnalyzeIdentifier(SyntaxToken identifier, int prefixLength);
    [NullableContextAttribute("0")]
private void ProcessMatches(ImmutableArray`1<SpellingMatch> matches, TextSpan span, SyntaxTree syntaxTree);
    [NullableContextAttribute("0")]
private void ProcessMatches(ImmutableArray`1<SpellingMatch> matches, SyntaxTree syntaxTree);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Spelling.SpellingCapture : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ContainingValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ContainingValueIndex>k__BackingField;
    public string Value { get; }
    public int Index { get; }
    public int Length { get; }
    [NullableAttribute("2")]
public string ContainingValue { get; }
    public int ContainingValueIndex { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public SpellingCapture(string value, int index, string containingValue, int containingValueIndex);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public int get_Index();
    public int get_Length();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ContainingValue();
    [CompilerGeneratedAttribute]
public int get_ContainingValueIndex();
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Spelling.SpellingData : object {
    [NullableAttribute("2")]
private WordCharMap _charIndexMap;
    [NullableAttribute("2")]
private WordCharMap _reversedCharIndexMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ImmutableHashSet`1<string>> _charMap;
    [CompilerGeneratedAttribute]
private WordList <WordList>k__BackingField;
    [CompilerGeneratedAttribute]
private WordList <CaseSensitiveWordList>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <IgnoredValues>k__BackingField;
    [CompilerGeneratedAttribute]
private FixList <Fixes>k__BackingField;
    public WordList WordList { get; }
    public WordList CaseSensitiveWordList { get; }
    public ImmutableHashSet`1<string> IgnoredValues { get; }
    public FixList Fixes { get; }
    public WordCharMap CharIndexMap { get; }
    public WordCharMap ReversedCharIndexMap { get; }
    public ImmutableDictionary`2<string, ImmutableHashSet`1<string>> CharMap { get; }
    public SpellingData(WordList words, WordList caseSensitiveWords, FixList fixes);
    private SpellingData(WordList wordList, WordList caseSensitiveWordList, FixList fixes, ImmutableHashSet`1<string> ignoredValues);
    [CompilerGeneratedAttribute]
public WordList get_WordList();
    [CompilerGeneratedAttribute]
public WordList get_CaseSensitiveWordList();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_IgnoredValues();
    [CompilerGeneratedAttribute]
public FixList get_Fixes();
    public WordCharMap get_CharIndexMap();
    public WordCharMap get_ReversedCharIndexMap();
    public ImmutableDictionary`2<string, ImmutableHashSet`1<string>> get_CharMap();
    public bool Contains(string value);
    public WordSequenceMatch GetSequenceMatch(string value, int startIndex, int length, Match match);
    private static WordSequenceMatch GetSequenceMatch(string value, int startIndex, int length, Match match, ImmutableArray`1<WordSequence> sequences, StringComparison comparison);
    public SpellingData AddWords(IEnumerable`1<string> values);
    public SpellingData AddWord(string value);
    public SpellingData AddFix(string error, SpellingFix fix);
    public SpellingData AddIgnoredValue(string value);
    public SpellingData AddIgnoredValues(IEnumerable`1<string> values);
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ImmutableHashSet`1<string>> <get_CharMap>g__Create|22_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <get_CharMap>b__22_4(IGrouping`2<string, ValueTuple`2<string, string>> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal abstract class Roslynator.Spelling.SpellingDiagnostic : object {
    [NullableAttribute("2")]
private string _valueLower;
    private Nullable`1<TextCasing> _casing;
    [CompilerGeneratedAttribute]
private Diagnostic <Diagnostic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <Identifier>k__BackingField;
    public Diagnostic Diagnostic { get; }
    public string Value { get; }
    public int Index { get; }
    public int Length { get; }
    public int EndIndex { get; }
    [NullableAttribute("2")]
public string Parent { get; }
    public int ParentIndex { get; }
    public int Offset { get; }
    public Location Location { get; }
    [NullableAttribute("2")]
public SyntaxTree SyntaxTree { get; }
    [NullableAttribute("2")]
public string FilePath { get; }
    public TextSpan Span { get; }
    public SyntaxToken Identifier { get; }
    public bool IsSymbol { get; }
    public string ValueLower { get; }
    public TextCasing Casing { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    protected SpellingDiagnostic(Diagnostic diagnostic, string value, int index, string parent, int parentIndex, SyntaxToken identifier);
    [CompilerGeneratedAttribute]
public Diagnostic get_Diagnostic();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public int get_Index();
    public int get_Length();
    public int get_EndIndex();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Parent();
    [CompilerGeneratedAttribute]
public int get_ParentIndex();
    public int get_Offset();
    public Location get_Location();
    [NullableContextAttribute("2")]
public SyntaxTree get_SyntaxTree();
    [NullableContextAttribute("2")]
public string get_FilePath();
    public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public SyntaxToken get_Identifier();
    public bool get_IsSymbol();
    public string get_ValueLower();
    public TextCasing get_Casing();
    private string get_DebuggerDisplay();
    public abstract virtual bool IsApplicableFix(string fix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Spelling.SpellingFix : ValueType {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private SpellingFixKind <Kind>k__BackingField;
    public string Value { get; }
    public SpellingFixKind Kind { get; }
    public bool IsDefault { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public SpellingFix(string value, SpellingFixKind kind);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public SpellingFixKind get_Kind();
    public bool get_IsDefault();
    private string get_DebuggerDisplay();
    public SpellingFix WithValue(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SpellingFix other);
    public virtual int GetHashCode();
    public static bool op_Equality(SpellingFix left, SpellingFix right);
    public static bool op_Inequality(SpellingFix left, SpellingFix right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.Spelling.SpellingFixComparer : object {
    [CompilerGeneratedAttribute]
private static SpellingFixComparer <InvariantCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpellingFixComparer <InvariantCultureIgnoreCase>k__BackingField;
    public static SpellingFixComparer InvariantCulture { get; }
    public static SpellingFixComparer InvariantCultureIgnoreCase { get; }
    private static SpellingFixComparer();
    [CompilerGeneratedAttribute]
public static SpellingFixComparer get_InvariantCulture();
    [CompilerGeneratedAttribute]
public static SpellingFixComparer get_InvariantCultureIgnoreCase();
    public abstract virtual int Compare(SpellingFix x, SpellingFix y);
    public abstract virtual bool Equals(SpellingFix x, SpellingFix y);
    public abstract virtual int GetHashCode(SpellingFix obj);
    public sealed virtual int Compare(object x, object y);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
internal enum Roslynator.Spelling.SpellingFixKind : Enum {
    public int value__;
    public static SpellingFixKind None;
    public static SpellingFixKind Predefined;
    public static SpellingFixKind User;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.Spelling.SpellingFixProvider : object {
    public static ImmutableArray`1<string> Fuzzy(string value, SpellingData spellingData, CancellationToken cancellationToken);
    private static bool TryAddMatches(ImmutableHashSet`1<string> values, int requiredLength, Builder& matches);
    private static bool TryAddMatches(ImmutableHashSet`1<string> values, int minRequiredLength, int maxRequiredLength, Builder& matches);
    public static ImmutableArray`1<string> SwapLetters(string value, SpellingData spellingData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Spelling.SpellingFixResult : object {
    private int _lineStartIndex;
    private int _lineEndIndex;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SourceText>k__BackingField;
    [CompilerGeneratedAttribute]
private SpellingCapture <Capture>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private SpellingFix <Fix>k__BackingField;
    [CompilerGeneratedAttribute]
private FileLinePositionSpan <LineSpan>k__BackingField;
    [NullableAttribute("2")]
public string SourceText { get; }
    public SpellingCapture Capture { get; }
    public string Value { get; }
    public int Index { get; }
    public int Length { get; }
    [NullableAttribute("2")]
public string ContainingValue { get; }
    public int ContainingValueIndex { get; }
    public TextSpan Span { get; }
    public SpellingFix Fix { get; }
    public string Replacement { get; }
    public SpellingFixKind Kind { get; }
    public bool HasFix { get; }
    public FileLinePositionSpan LineSpan { get; }
    public string FilePath { get; }
    public int LineNumber { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public int LineStartIndex { get; }
    public int LineEndIndex { get; }
    private SpellingFixResult(string sourceText, SpellingCapture capture, TextSpan span, SpellingFix fix, FileLinePositionSpan lineSpan);
    public static SpellingFixResult Create(string sourceText, SpellingDiagnostic diagnostic);
    public static SpellingFixResult Create(string sourceText, SpellingDiagnostic diagnostic, SpellingFix fix);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_SourceText();
    [CompilerGeneratedAttribute]
public SpellingCapture get_Capture();
    public string get_Value();
    public int get_Index();
    public int get_Length();
    [NullableContextAttribute("2")]
public string get_ContainingValue();
    public int get_ContainingValueIndex();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public SpellingFix get_Fix();
    public string get_Replacement();
    public SpellingFixKind get_Kind();
    public bool get_HasFix();
    [CompilerGeneratedAttribute]
public FileLinePositionSpan get_LineSpan();
    public string get_FilePath();
    public int get_LineNumber();
    private string get_DebuggerDisplay();
    public int get_LineStartIndex();
    public int get_LineEndIndex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.Spelling.SpellingFixResultEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static SpellingFixResultEqualityComparer <ValueAndReplacement>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpellingFixResultEqualityComparer <ValueAndLineSpan>k__BackingField;
    public static SpellingFixResultEqualityComparer ValueAndReplacement { get; }
    public static SpellingFixResultEqualityComparer ValueAndLineSpan { get; }
    private static SpellingFixResultEqualityComparer();
    [CompilerGeneratedAttribute]
public static SpellingFixResultEqualityComparer get_ValueAndReplacement();
    [CompilerGeneratedAttribute]
public static SpellingFixResultEqualityComparer get_ValueAndLineSpan();
    public abstract virtual bool Equals(SpellingFixResult x, SpellingFixResult y);
    public abstract virtual int GetHashCode(SpellingFixResult obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Spelling.SpellingMatch : ValueType {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParentIndex>k__BackingField;
    public string Value { get; }
    public int Index { get; }
    [NullableAttribute("2")]
public string Parent { get; }
    public int ParentIndex { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public SpellingMatch(string value, int index, string parent, int parentIndex);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public int get_Index();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Parent();
    [CompilerGeneratedAttribute]
public int get_ParentIndex();
    private string get_DebuggerDisplay();
}
[FlagsAttribute]
internal enum Roslynator.Spelling.SpellingScopeFilter : Enum {
    public int value__;
    public static SpellingScopeFilter None;
    public static SpellingScopeFilter DocumentationComment;
    public static SpellingScopeFilter NonDocumentationComment;
    public static SpellingScopeFilter Comment;
    public static SpellingScopeFilter Region;
    public static SpellingScopeFilter Namespace;
    public static SpellingScopeFilter Class;
    public static SpellingScopeFilter Struct;
    public static SpellingScopeFilter Delegate;
    public static SpellingScopeFilter Interface;
    public static SpellingScopeFilter Enum;
    public static SpellingScopeFilter Record;
    public static SpellingScopeFilter Type;
    public static SpellingScopeFilter Method;
    public static SpellingScopeFilter Property;
    public static SpellingScopeFilter Indexer;
    public static SpellingScopeFilter Field;
    public static SpellingScopeFilter Event;
    public static SpellingScopeFilter Constant;
    public static SpellingScopeFilter Member;
    public static SpellingScopeFilter LocalVariable;
    public static SpellingScopeFilter LocalFunction;
    public static SpellingScopeFilter Local;
    public static SpellingScopeFilter Parameter;
    public static SpellingScopeFilter TypeParameter;
    public static SpellingScopeFilter UsingAlias;
    public static SpellingScopeFilter ReturnType;
    public static SpellingScopeFilter Symbol;
    public static SpellingScopeFilter Literal;
    public static SpellingScopeFilter FileName;
    public static SpellingScopeFilter NonSymbol;
    public static SpellingScopeFilter All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.Spelling.SpellingService : object {
    public ISyntaxFactsService SyntaxFacts { get; }
    public abstract virtual ISyntaxFactsService get_SyntaxFacts();
    public abstract virtual DiagnosticAnalyzer CreateAnalyzer(SpellingData spellingData, SpellcheckOptions options);
    public abstract virtual ImmutableArray`1<Diagnostic> AnalyzeSpelling(SyntaxNode node, SpellingData spellingData, SpellcheckOptions options, CancellationToken cancellationToken);
    public abstract virtual SpellingDiagnostic CreateSpellingDiagnostic(Diagnostic diagnostic);
}
[FlagsAttribute]
internal enum Roslynator.Spelling.SplitMode : Enum {
    public int value__;
    public static SplitMode None;
    public static SplitMode Case;
    public static SplitMode Hyphen;
    public static SplitMode CaseAndHyphen;
}
internal enum Roslynator.Spelling.TextCasing : Enum {
    public int value__;
    public static TextCasing Undefined;
    public static TextCasing Lower;
    public static TextCasing Upper;
    public static TextCasing FirstUpper;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.Spelling.TextUtility : object {
    public static int GetLineStartIndex(string input, int index);
    public static int GetLineEndIndex(string input, int index);
    public static string ReplaceRange(string value, string replacement, int index, int length);
    public static string SetTextCasing(string s, TextCasing textCasing);
    public static TextCasing GetTextCasing(string s);
    public static bool TextCasingEquals(string value1, string value2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Spelling.WordChar : ValueType {
    [CompilerGeneratedAttribute]
private char <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public char Value { get; }
    public int Index { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public WordChar(char value, int index);
    [CompilerGeneratedAttribute]
public char get_Value();
    [CompilerGeneratedAttribute]
public int get_Index();
    private string get_DebuggerDisplay();
    public static WordChar Create(string value, int index);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(WordChar other);
    public virtual int GetHashCode();
    public static bool op_Equality(WordChar left, WordChar right);
    public static bool op_Inequality(WordChar left, WordChar right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslynator.Spelling.WordCharMap : object {
    [CompilerGeneratedAttribute]
private WordList <List>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<WordChar, ImmutableHashSet`1<string>> <Map>k__BackingField;
    public WordList List { get; }
    private ImmutableDictionary`2<WordChar, ImmutableHashSet`1<string>> Map { get; }
    public ImmutableHashSet`1<string> Item { get; }
    public ImmutableHashSet`1<string> Item { get; }
    private WordCharMap(WordList list, ImmutableDictionary`2<WordChar, ImmutableHashSet`1<string>> map);
    [CompilerGeneratedAttribute]
public WordList get_List();
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<WordChar, ImmutableHashSet`1<string>> get_Map();
    public ImmutableHashSet`1<string> get_Item(string value, int index);
    public ImmutableHashSet`1<string> get_Item(char ch, int index);
    public bool TryGetValue(WordChar wordChar, ImmutableHashSet`1& value);
    public bool TryGetValue(string word, int index, ImmutableHashSet`1& value);
    public bool TryGetValue(char ch, int index, ImmutableHashSet`1& value);
    public static WordCharMap CreateCharIndexMap(WordList wordList, bool reverse);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Spelling.WordList : object {
    [CompilerGeneratedAttribute]
private static StringComparison <DefaultComparison>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringComparer <DefaultComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static WordList <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <Words>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <NonWords>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ImmutableArray`1<WordSequence>> <Sequences>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparison <Comparison>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparer <Comparer>k__BackingField;
    public static StringComparison DefaultComparison { get; }
    public static StringComparer DefaultComparer { get; }
    public static WordList Default { get; }
    public ImmutableHashSet`1<string> Words { get; }
    public ImmutableHashSet`1<string> NonWords { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<string, ImmutableArray`1<WordSequence>> Sequences { get; }
    public StringComparison Comparison { get; }
    public StringComparer Comparer { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public WordList(IEnumerable`1<string> values, Nullable`1<StringComparison> comparison);
    [NullableContextAttribute("2")]
public WordList(IEnumerable`1<string> words, IEnumerable`1<string> nonWords, IEnumerable`1<WordSequence> sequences, Nullable`1<StringComparison> comparison);
    private static WordList();
    [CompilerGeneratedAttribute]
public static StringComparison get_DefaultComparison();
    [CompilerGeneratedAttribute]
public static StringComparer get_DefaultComparer();
    [CompilerGeneratedAttribute]
public static WordList get_Default();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_Words();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_NonWords();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ImmutableArray`1<WordSequence>> get_Sequences();
    [CompilerGeneratedAttribute]
public StringComparison get_Comparison();
    [CompilerGeneratedAttribute]
public StringComparer get_Comparer();
    private string get_DebuggerDisplay();
    public WordList Intersect(WordList wordList, WordList[] additionalWordLists);
    public WordList Except(WordList wordList, WordList[] additionalWordLists);
    public bool Contains(string value);
    public WordList AddValue(string value);
    public WordList AddValues(IEnumerable`1<string> values);
    public WordList AddValues(WordList wordList, WordList[] additionalWordLists);
    public WordList WithValues(IEnumerable`1<string> values);
    public static void Save(string path, WordList wordList);
    public static void Save(string path, IEnumerable`1<string> values, StringComparer comparer, bool merge);
    public void Save(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal static class Roslynator.Spelling.WordListLoader : object {
    private static Regex _splitRegex;
    private static WordListLoader();
    public static WordListLoaderResult Load(IEnumerable`1<string> paths, int minWordLength, int maxWordLength, WordListLoadOptions options, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Roslynator.Spelling.WordListLoader/<GetFiles>d__2")]
private static IEnumerable`1<string> GetFiles(IEnumerable`1<string> paths);
    public static List`1<string> LoadValues(string path, int minWordLength, int maxWordLength);
    private static void LoadFile(string path, int minWordLength, int maxWordLength, LoadState state);
    private static bool IsWord(string value);
    private static bool IsLower(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Spelling.WordListLoaderResult : object {
    [CompilerGeneratedAttribute]
private WordList <List>k__BackingField;
    [CompilerGeneratedAttribute]
private WordList <CaseSensitiveList>k__BackingField;
    [CompilerGeneratedAttribute]
private FixList <FixList>k__BackingField;
    public WordList List { get; }
    public WordList CaseSensitiveList { get; }
    public FixList FixList { get; }
    internal WordListLoaderResult(WordList list, WordList caseSensitiveList, FixList fixList);
    [CompilerGeneratedAttribute]
public WordList get_List();
    [CompilerGeneratedAttribute]
public WordList get_CaseSensitiveList();
    [CompilerGeneratedAttribute]
public FixList get_FixList();
}
[FlagsAttribute]
internal enum Roslynator.Spelling.WordListLoadOptions : Enum {
    public int value__;
    public static WordListLoadOptions None;
    public static WordListLoadOptions IgnoreCase;
    public static WordListLoadOptions DetectNonWords;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Spelling.WordSequence : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Words>k__BackingField;
    public string First { get; }
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Words { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public WordSequence(IEnumerable`1<string> words);
    public string get_First();
    public int get_Count();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Words();
    private string get_DebuggerDisplay();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Spelling.WordSequenceMatch : ValueType {
    [CompilerGeneratedAttribute]
private WordSequence <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public WordSequence Sequence { get; }
    public int Index { get; }
    public int Length { get; }
    internal int EndIndex { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public WordSequenceMatch(WordSequence sequence, int index, int length);
    [CompilerGeneratedAttribute]
public WordSequence get_Sequence();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public int get_Length();
    internal int get_EndIndex();
    private string get_DebuggerDisplay();
}
internal static class Roslynator.StringComparerUtility : object {
    [NullableContextAttribute("1")]
public static StringComparer FromComparison(StringComparison comparisonType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.SymbolDefinitionComparer : object {
    [CompilerGeneratedAttribute]
private static SymbolDefinitionComparer <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDefinitionComparer <SystemFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDefinitionComparer <OmitContainingNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDefinitionComparer <SystemFirstOmitContainingNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDefinitionSortOptions <Options>k__BackingField;
    public static SymbolDefinitionComparer Default { get; }
    public static SymbolDefinitionComparer SystemFirst { get; }
    public static SymbolDefinitionComparer OmitContainingNamespace { get; }
    public static SymbolDefinitionComparer SystemFirstOmitContainingNamespace { get; }
    public SymbolDefinitionSortOptions Options { get; }
    public IComparer`1<INamespaceSymbol> NamespaceComparer { get; }
    public IComparer`1<INamedTypeSymbol> TypeComparer { get; }
    public IComparer`1<ISymbol> MemberComparer { get; }
    internal SymbolDefinitionComparer(SymbolDefinitionSortOptions options);
    private static SymbolDefinitionComparer();
    [CompilerGeneratedAttribute]
public static SymbolDefinitionComparer get_Default();
    [CompilerGeneratedAttribute]
public static SymbolDefinitionComparer get_SystemFirst();
    [CompilerGeneratedAttribute]
public static SymbolDefinitionComparer get_OmitContainingNamespace();
    [CompilerGeneratedAttribute]
public static SymbolDefinitionComparer get_SystemFirstOmitContainingNamespace();
    [CompilerGeneratedAttribute]
public SymbolDefinitionSortOptions get_Options();
    public abstract virtual IComparer`1<INamespaceSymbol> get_NamespaceComparer();
    public abstract virtual IComparer`1<INamedTypeSymbol> get_TypeComparer();
    public abstract virtual IComparer`1<ISymbol> get_MemberComparer();
    public sealed virtual int Compare(ISymbol x, ISymbol y);
    private int CompareNamedTypeSymbol(INamedTypeSymbol typeSymbol1, INamedTypeSymbol typeSymbol2);
    private int CompareMemberSymbol(ISymbol symbol1, ISymbol symbol2);
    private int CompareSymbolAndNamespaceSymbol(ISymbol symbol, INamespaceSymbol namespaceSymbol);
    private int CompareSymbolAndNamedTypeSymbol(ISymbol symbol, INamedTypeSymbol typeSymbol);
    internal int CompareContainingNamespace(ISymbol x, ISymbol y);
    public static int CompareName(ISymbol symbol1, ISymbol symbol2);
}
[FlagsAttribute]
internal enum Roslynator.SymbolDefinitionSortOptions : Enum {
    public int value__;
    public static SymbolDefinitionSortOptions None;
    public static SymbolDefinitionSortOptions SystemFirst;
    public static SymbolDefinitionSortOptions OmitContainingNamespace;
    public static SymbolDefinitionSortOptions OmitContainingType;
}
internal enum Roslynator.SymbolGroup : Enum {
    public int value__;
    public static SymbolGroup None;
    public static SymbolGroup Namespace;
    public static SymbolGroup Module;
    public static SymbolGroup Class;
    public static SymbolGroup Struct;
    public static SymbolGroup Interface;
    public static SymbolGroup Enum;
    public static SymbolGroup Delegate;
    public static SymbolGroup Const;
    public static SymbolGroup Field;
    public static SymbolGroup Event;
    public static SymbolGroup Property;
    public static SymbolGroup Indexer;
    public static SymbolGroup Method;
}
[FlagsAttribute]
internal enum Roslynator.SymbolGroupFilter : Enum {
    public int value__;
    public static SymbolGroupFilter None;
    public static SymbolGroupFilter Module;
    public static SymbolGroupFilter Class;
    public static SymbolGroupFilter Delegate;
    public static SymbolGroupFilter Enum;
    public static SymbolGroupFilter Interface;
    public static SymbolGroupFilter Struct;
    public static SymbolGroupFilter Type;
    public static SymbolGroupFilter Event;
    public static SymbolGroupFilter Field;
    public static SymbolGroupFilter EnumField;
    public static SymbolGroupFilter Const;
    public static SymbolGroupFilter Method;
    public static SymbolGroupFilter Property;
    public static SymbolGroupFilter Indexer;
    public static SymbolGroupFilter Member;
    public static SymbolGroupFilter TypeOrMember;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslynator.SyntaxFactsServiceExtensions : object {
    [ExtensionAttribute]
public static bool IsWhitespaceOrEndOfLineTrivia(ISyntaxFactsService syntaxFacts, SyntaxTrivia& trivia);
    [ExtensionAttribute]
public static bool BeginsWithBanner(ISyntaxFactsService syntaxFacts, SyntaxNode root, ImmutableArray`1<string> lines);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.SyntaxFinder : object {
    public static Task`1<ImmutableArray`1<SyntaxNode>> FindReferencesAsync(ISymbol symbol, Solution solution, bool allowCandidate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.SyntaxFinder/<FindReferencesAsync>d__1")]
public static Task`1<ImmutableArray`1<SyntaxNode>> FindReferencesAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Document> documents, bool allowCandidate, CancellationToken cancellationToken);
    public static Task`1<ImmutableArray`1<DocumentReferenceInfo>> FindReferencesByDocumentAsync(ISymbol symbol, Solution solution, bool allowCandidate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.SyntaxFinder/<FindReferencesByDocumentAsync>d__3")]
public static Task`1<ImmutableArray`1<DocumentReferenceInfo>> FindReferencesByDocumentAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Document> documents, bool allowCandidate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.SyntaxFinder/<FindReferencesAsync>d__4")]
public static Task`1<ImmutableArray`1<SyntaxNode>> FindReferencesAsync(ISymbol symbol, Document document, bool allowCandidate, CancellationToken cancellationToken);
    private static void FindReferences(IEnumerable`1<ReferenceLocation> referenceLocations, SyntaxNode root, bool allowCandidate, List`1& nodes);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<T> ToImmutableArray(IEnumerable`1<T> nodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.TextWriterWithVerbosity : TextWriter {
    [CompilerGeneratedAttribute]
private Verbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    public Verbosity Verbosity { get; public set; }
    public Encoding Encoding { get; }
    protected TextWriter Writer { get; }
    public TextWriterWithVerbosity(TextWriter writer);
    public TextWriterWithVerbosity(TextWriter writer, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
public Verbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public void set_Verbosity(Verbosity value);
    public virtual Encoding get_Encoding();
    [CompilerGeneratedAttribute]
protected TextWriter get_Writer();
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public void Write(char value, Verbosity verbosity);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(decimal value);
    public virtual void Write(double value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(float value);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    [NullableContextAttribute("2")]
public void Write(string value, Verbosity verbosity);
    [NullableContextAttribute("2")]
public void WriteIf(bool condition, string value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void Write(UInt32 value);
    public virtual void Write(ulong value);
    public virtual void WriteLine();
    public void WriteLine(Verbosity verbosity);
    public void WriteLineIf(bool condition);
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(string value);
    public void WriteLine(string value, Verbosity verbosity);
    public virtual void WriteLine(LogMessage message);
    public void WriteLineIf(bool condition, string value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(ulong value);
    protected virtual void Dispose(bool disposing);
    public bool ShouldWrite(Verbosity verbosity);
}
internal enum Roslynator.Verbosity : Enum {
    public int value__;
    public static Verbosity None;
    public static Verbosity Quiet;
    public static Verbosity Minimal;
    public static Verbosity Normal;
    public static Verbosity Detailed;
    public static Verbosity Diagnostic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Roslynator.WorkspaceExtensions : object {
    [ExtensionAttribute]
internal static Task`1<Document> WithTextChangeAsync(Document document, TextSpan span, string newText, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Document> WithTextChangeAsync(Document document, TextChange textChange, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<WithTextChangesAsync>d__2")]
[ExtensionAttribute]
public static Task`1<Document> WithTextChangesAsync(Document document, TextChange[] textChanges, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<WithTextChangesAsync>d__3")]
[ExtensionAttribute]
public static Task`1<Document> WithTextChangesAsync(Document document, IEnumerable`1<TextChange> textChanges, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<ReplaceNodeAsync>d__4")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceNodeAsync(Document document, SyntaxNode oldNode, SyntaxNode newNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<ReplaceNodeAsync>d__5")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceNodeAsync(Document document, SyntaxNode oldNode, IEnumerable`1<SyntaxNode> newNodes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<ReplaceNodesAsync>d__6`1")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceNodesAsync(Document document, IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<ReplaceTokenAsync>d__7")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceTokenAsync(Document document, SyntaxToken oldToken, SyntaxToken newToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<ReplaceTokenAsync>d__8")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceTokenAsync(Document document, SyntaxToken oldToken, IEnumerable`1<SyntaxToken> newTokens, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<ReplaceTriviaAsync>d__9")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceTriviaAsync(Document document, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<ReplaceTriviaAsync>d__10")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceTriviaAsync(Document document, SyntaxTrivia oldTrivia, IEnumerable`1<SyntaxTrivia> newTrivia, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Document> InsertNodeBeforeAsync(Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<InsertNodesBeforeAsync>d__12")]
[ExtensionAttribute]
public static Task`1<Document> InsertNodesBeforeAsync(Document document, SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> newNodes, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<Document> InsertNodeAfterAsync(Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<InsertNodesAfterAsync>d__14")]
[ExtensionAttribute]
public static Task`1<Document> InsertNodesAfterAsync(Document document, SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> newNodes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<RemoveNodeAsync>d__15")]
[ExtensionAttribute]
public static Task`1<Document> RemoveNodeAsync(Document document, SyntaxNode node, SyntaxRemoveOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<RemoveNodesAsync>d__16")]
[ExtensionAttribute]
public static Task`1<Document> RemoveNodesAsync(Document document, IEnumerable`1<SyntaxNode> nodes, SyntaxRemoveOptions options, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Solution Solution(Document document);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<ReplaceNodeAsync>d__18`1")]
[ExtensionAttribute]
public static Task`1<Solution> ReplaceNodeAsync(Solution solution, TNode oldNode, TNode newNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.WorkspaceExtensions/<ReplaceNodesAsync>d__19`1")]
[ExtensionAttribute]
public static Task`1<Solution> ReplaceNodesAsync(Solution solution, IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNodes, CancellationToken cancellationToken);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
