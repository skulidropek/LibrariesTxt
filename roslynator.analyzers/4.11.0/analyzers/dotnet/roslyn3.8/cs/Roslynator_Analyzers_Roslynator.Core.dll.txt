[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[FlagsAttribute]
internal enum Roslynator.AccessibilityFilter : Enum {
    public int value__;
    public static AccessibilityFilter None;
    public static AccessibilityFilter Private;
    public static AccessibilityFilter ProtectedAndInternal;
    public static AccessibilityFilter Protected;
    public static AccessibilityFilter Internal;
    public static AccessibilityFilter ProtectedOrInternal;
    public static AccessibilityFilter Public;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.AsyncMethodNameGenerator : NameGenerator {
    public virtual string EnsureUniqueName(string baseName, IEnumerable`1<string> reservedNames, bool isCaseSensitive);
    public virtual string EnsureUniqueName(string baseName, ImmutableArray`1<ISymbol> symbols, bool isCaseSensitive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Collections.Enumerable`1 : object {
    private IEnumerator`1<T> _enumerator;
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Collections.Enumerator : object {
    public static IEnumerator Instance;
    public object Current { get; }
    private static Enumerator();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class Roslynator.Collections.Enumerator`1 : Enumerator {
    [NullableAttribute("1")]
public static IEnumerator`1<T> Instance;
    [NullableAttribute("1")]
public T Current { get; }
    private static Enumerator`1();
    [NullableContextAttribute("1")]
public sealed virtual T get_Current();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Roslynator.Collections.ReadOnlyCollection`1 : Enumerable`1<T> {
    public static ICollection`1<T> Instance;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private static ReadOnlyCollection`1();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
internal class Roslynator.Collections.ReadOnlyList`1 : ReadOnlyCollection`1<T> {
    public static ReadOnlyList`1<T> Instance;
    public T Item { get; public set; }
    private static ReadOnlyList`1();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CommonDiagnosticIdentifiers : object {
    public static string AnalyzerIsObsolete;
    public static string AnalyzerOptionIsObsolete;
    public static string RequiredConfigOptionNotSet;
    public static string PossibleMisspellingOrTypo;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.ConvertHelpers : object {
    public static object ConvertFromUInt64(ulong value, SpecialType numericType);
    public static bool CanConvertFromUInt64(ulong value, SpecialType specialType);
    public static ulong ConvertToUInt64(object value, SpecialType numericType);
    public static bool TryConvertToUInt64(object value, UInt64& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.CreateNameFromTypeSymbolHelper : object {
    public static string CreateName(ITypeSymbol typeSymbol);
    private static ITypeSymbol ExtractFromNullableType(ITypeSymbol typeSymbol);
    private static ITypeSymbol ExtractFromArrayOrGenericCollection(ITypeSymbol typeSymbol);
    private static bool UsePlural(ITypeSymbol typeSymbol);
    private static string GetName(ITypeSymbol typeSymbol);
    [CompilerGeneratedAttribute]
internal static bool <ExtractFromArrayOrGenericCollection>g__ValidateTypeArgumentName|2_0(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.DefaultNames : object {
    public static string DebuggerDisplayPropertyName;
    public static string EnumeratorVariable;
    public static string EnumMember;
    public static string EventArgsVariable;
    public static string EventHandlerVariable;
    public static string ForEachVariable;
    public static string ForVariable;
    public static string LambdaParameter;
    public static string Namespace;
    public static string SecondLambdaParameter;
    public static string StringBuilderVariable;
    public static string TypeParameter;
    public static string Variable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.DiagnosticComparer : object {
    [CompilerGeneratedAttribute]
private static DiagnosticComparer <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticComparer <SpanStart>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticComparer <IdThenFilePathThenSpanStart>k__BackingField;
    public static DiagnosticComparer Id { get; }
    public static DiagnosticComparer SpanStart { get; }
    public static DiagnosticComparer IdThenFilePathThenSpanStart { get; }
    private static DiagnosticComparer();
    [CompilerGeneratedAttribute]
public static DiagnosticComparer get_Id();
    [CompilerGeneratedAttribute]
public static DiagnosticComparer get_SpanStart();
    [CompilerGeneratedAttribute]
public static DiagnosticComparer get_IdThenFilePathThenSpanStart();
    public abstract virtual int Compare(Diagnostic x, Diagnostic y);
    public abstract virtual bool Equals(Diagnostic x, Diagnostic y);
    public abstract virtual int GetHashCode(Diagnostic obj);
    public sealed virtual int Compare(object x, object y);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.DiagnosticDeepEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static DiagnosticDeepEqualityComparer <Instance>k__BackingField;
    public static DiagnosticDeepEqualityComparer Instance { get; }
    private static DiagnosticDeepEqualityComparer();
    [CompilerGeneratedAttribute]
public static DiagnosticDeepEqualityComparer get_Instance();
    internal static bool Equals(ImmutableArray`1<Diagnostic> first, ImmutableArray`1<Diagnostic> second);
    public sealed virtual bool Equals(Diagnostic x, Diagnostic y);
    public sealed virtual int GetHashCode(Diagnostic obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslynator.DiagnosticDescriptorComparer : object {
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptorComparer <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptorComparer <IdPrefix>k__BackingField;
    public static DiagnosticDescriptorComparer Id { get; }
    public static DiagnosticDescriptorComparer IdPrefix { get; }
    private static DiagnosticDescriptorComparer();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptorComparer get_Id();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptorComparer get_IdPrefix();
    public abstract virtual int Compare(DiagnosticDescriptor x, DiagnosticDescriptor y);
    public abstract virtual bool Equals(DiagnosticDescriptor x, DiagnosticDescriptor y);
    public abstract virtual int GetHashCode(DiagnosticDescriptor obj);
    public sealed virtual int Compare(object x, object y);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.DiagnosticDescriptorUtility : object {
    private static string HelpLinkUriRoot;
    public static string GetHelpLinkUri(string analyzerId);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Roslynator.DiagnosticIdComparer : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static DiagnosticIdComparer <Prefix>k__BackingField;
    [NullableAttribute("1")]
public static DiagnosticIdComparer Prefix { get; }
    private static DiagnosticIdComparer();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static DiagnosticIdComparer get_Prefix();
    public abstract virtual int Compare(string x, string y);
    public abstract virtual bool Equals(string x, string y);
    public abstract virtual int GetHashCode(string obj);
    public sealed virtual int Compare(object x, object y);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.DiagnosticIdPrefix : object {
    public static string GetPrefix(string id);
    public static int GetPrefixLength(string id);
    [IteratorStateMachineAttribute("Roslynator.DiagnosticIdPrefix/<CountPrefixes>d__2")]
public static IEnumerable`1<ValueTuple`2<string, int>> CountPrefixes(IEnumerable`1<string> values);
    [CompilerGeneratedAttribute]
internal static bool <GetPrefix>g__HasPrefix|0_0(string value, <>c__DisplayClass0_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Roslynator.DiagnosticsExtensions : object {
    [ExtensionAttribute]
public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, Object[] messageArgs);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, Object[] messageArgs);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, Object[] messageArgs);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, Object[] messageArgs);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, Object[] messageArgs);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, Object[] messageArgs);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    [ExtensionAttribute]
public static void ReportDiagnostic(SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    [ExtensionAttribute]
internal static ReportDiagnostic ToReportDiagnostic(DiagnosticSeverity diagnosticSeverity);
    [ExtensionAttribute]
internal static DiagnosticSeverity ToDiagnosticSeverity(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
internal static bool IsAnalyzerExceptionDiagnostic(Diagnostic diagnostic);
    [ExtensionAttribute]
internal static bool IsAnalyzerExceptionDescriptor(DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static bool IsEffective(DiagnosticDescriptor descriptor, SymbolAnalysisContext context);
    [ExtensionAttribute]
internal static bool IsEffective(DiagnosticDescriptor descriptor, SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
internal static bool IsEffective(DiagnosticDescriptor descriptor, SyntaxTree syntaxTree, CompilationOptions compilationOptions, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ReportDiagnostic GetEffectiveSeverity(DiagnosticDescriptor descriptor, SyntaxTree syntaxTree, CompilationOptions compilationOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsEffective(DiagnosticDescriptor descriptor, Compilation compilation);
    [ExtensionAttribute]
internal static bool IsEffective(DiagnosticDescriptor descriptor, CompilationOptions compilationOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Documentation.DocumentationCommentData : ValueType {
    [CompilerGeneratedAttribute]
private string <RawXml>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentationCommentOrigin <Origin>k__BackingField;
    public string RawXml { get; }
    public DocumentationCommentOrigin Origin { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal DocumentationCommentData(string rawXml, DocumentationCommentOrigin origin);
    [CompilerGeneratedAttribute]
public string get_RawXml();
    [CompilerGeneratedAttribute]
public DocumentationCommentOrigin get_Origin();
    public bool get_Success();
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.Documentation.DocumentationCommentGeneratorSettings : object {
    [CompilerGeneratedAttribute]
private static DocumentationCommentGeneratorSettings <Default>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <IgnoredTags>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SingleLineSummary>k__BackingField;
    public static DocumentationCommentGeneratorSettings Default { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> IgnoredTags { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Summary { get; }
    public string Indentation { get; }
    public bool SingleLineSummary { get; }
    [NullableContextAttribute("2")]
public DocumentationCommentGeneratorSettings(IEnumerable`1<string> summary, IEnumerable`1<string> ignoredTags, string indentation, bool singleLineSummary);
    private static DocumentationCommentGeneratorSettings();
    [CompilerGeneratedAttribute]
public static DocumentationCommentGeneratorSettings get_Default();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_IgnoredTags();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Summary();
    [CompilerGeneratedAttribute]
public string get_Indentation();
    [CompilerGeneratedAttribute]
public bool get_SingleLineSummary();
    public bool IsTagIgnored(string tag);
    public DocumentationCommentGeneratorSettings WithIndentation(string indentation);
}
internal enum Roslynator.Documentation.DocumentationCommentOrigin : Enum {
    public int value__;
    public static DocumentationCommentOrigin BaseMember;
    public static DocumentationCommentOrigin InterfaceMember;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.Empty : object {
    public static IEnumerator`1<T> Enumerator();
    public static IEnumerable`1<T> Enumerable();
    public static ICollection`1<T> Collection();
    public static IList`1<T> List();
    public static IReadOnlyList`1<T> ReadOnlyList();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslynator.EnumerableExtensions : object {
    [ExtensionAttribute]
public static bool IsSorted(IEnumerable`1<T> enumerable, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> ModifyRange(IEnumerable`1<T> enumerable, int startIndex, int count, Func`2<T, T> selector);
}
[ExtensionAttribute]
public static class Roslynator.EnumExtensions : object {
    [ExtensionAttribute]
internal static bool Is(Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2);
    [ExtensionAttribute]
internal static bool Is(Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3);
    [ExtensionAttribute]
internal static bool Is(Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4);
    [ExtensionAttribute]
internal static bool Is(Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4, Accessibility accessibility5);
    [ExtensionAttribute]
public static bool IsMoreRestrictiveThan(Accessibility accessibility, Accessibility other);
    [ExtensionAttribute]
internal static bool IsSingleTokenAccessibility(Accessibility accessibility);
    [ExtensionAttribute]
internal static bool ContainsProtected(Accessibility accessibility);
    [ExtensionAttribute]
internal static AccessibilityFilter GetAccessibilityFilter(Accessibility accessibility);
    [ExtensionAttribute]
internal static bool Is(MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2);
    [ExtensionAttribute]
internal static bool Is(MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3);
    [ExtensionAttribute]
internal static bool Is(MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4);
    [ExtensionAttribute]
internal static bool Is(MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4, MethodKind methodKind5);
    [ExtensionAttribute]
internal static bool Is(SpecialType specialType, SpecialType specialType1, SpecialType specialType2);
    [ExtensionAttribute]
internal static bool Is(SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3);
    [ExtensionAttribute]
internal static bool Is(SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4);
    [ExtensionAttribute]
internal static bool Is(SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4, SpecialType specialType5);
    [ExtensionAttribute]
internal static bool Is(TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2);
    [ExtensionAttribute]
internal static bool Is(TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3);
    [ExtensionAttribute]
internal static bool Is(TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4);
    [ExtensionAttribute]
internal static bool Is(TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4, TypeKind typeKind5);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslynator.EnumFieldSymbolInfo : ValueType {
    [CompilerGeneratedAttribute]
private IFieldSymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Value>k__BackingField;
    public IFieldSymbol Symbol { get; }
    public ulong Value { get; }
    public bool HasValue { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public EnumFieldSymbolInfo(IFieldSymbol symbol, ulong value);
    [CompilerGeneratedAttribute]
public IFieldSymbol get_Symbol();
    [CompilerGeneratedAttribute]
public ulong get_Value();
    public bool get_HasValue();
    [NullableContextAttribute("2")]
public string get_Name();
    public static EnumFieldSymbolInfo Create(IFieldSymbol fieldSymbol);
    public static bool TryCreate(IFieldSymbol fieldSymbol, EnumFieldSymbolInfo& fieldInfo);
    public bool HasCompositeValue();
    public IEnumerable`1<ulong> GetFlags();
}
[IsReadOnlyAttribute]
internal class Roslynator.EnumSymbolInfo : ValueType {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<EnumFieldSymbolInfo> <Fields>k__BackingField;
    [NullableAttribute("2")]
public INamedTypeSymbol Symbol { get; }
    public ImmutableArray`1<EnumFieldSymbolInfo> Fields { get; }
    public bool IsDefault { get; }
    private EnumSymbolInfo(ImmutableArray`1<EnumFieldSymbolInfo> fields);
    [NullableContextAttribute("2")]
public INamedTypeSymbol get_Symbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<EnumFieldSymbolInfo> get_Fields();
    public bool get_IsDefault();
    public bool Contains(ulong value);
    [NullableContextAttribute("2")]
public List`1<EnumFieldSymbolInfo> Decompose(EnumFieldSymbolInfo& fieldInfo);
    [NullableContextAttribute("2")]
public List`1<EnumFieldSymbolInfo> Decompose(ulong value);
    [NullableContextAttribute("1")]
public static EnumSymbolInfo Create(INamedTypeSymbol symbol);
    [NullableContextAttribute("1")]
public static bool TryCreate(INamedTypeSymbol symbol, EnumSymbolInfo& enumInfo);
}
internal static class Roslynator.EnumUtility : object {
    [NullableContextAttribute("1")]
public static OneOrMany`1<EnumFieldSymbolInfo> GetConstituentFields(object value, INamedTypeSymbol enumType);
    public static OneOrMany`1<EnumFieldSymbolInfo> GetConstituentFields(ulong value, EnumSymbolInfo& enumInfo);
    public static ImmutableArray`1<EnumFieldSymbolInfo> GetMinimalConstituentFields(IFieldSymbol fieldSymbol, EnumSymbolInfo& enumInfo);
    public static ImmutableArray`1<EnumFieldSymbolInfo> GetMinimalConstituentFields(ulong value, EnumSymbolInfo& enumInfo);
    private static EnumFieldSymbolInfo FindField(EnumSymbolInfo& enumInfo, ulong value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.EnumValueComparer : object {
    public static IComparer`1<object> GetInstance(SpecialType enumSpecialType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.ExtensionMethodSymbolInfo : ValueType {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IMethodSymbol <ReducedSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <Symbol>k__BackingField;
    [NullableAttribute("2")]
public IMethodSymbol ReducedSymbol { get; }
    public IMethodSymbol Symbol { get; }
    public IMethodSymbol ReducedSymbolOrSymbol { get; }
    public bool IsReduced { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal ExtensionMethodSymbolInfo(IMethodSymbol symbol, IMethodSymbol reducedSymbol);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IMethodSymbol get_ReducedSymbol();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_Symbol();
    public IMethodSymbol get_ReducedSymbolOrSymbol();
    public bool get_IsReduced();
    private string get_DebuggerDisplay();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExtensionMethodSymbolInfo other);
    public virtual int GetHashCode();
    public static bool op_Equality(ExtensionMethodSymbolInfo& info1, ExtensionMethodSymbolInfo& info2);
    public static bool op_Inequality(ExtensionMethodSymbolInfo& info1, ExtensionMethodSymbolInfo& info2);
}
[ExtensionAttribute]
public static class Roslynator.FileLinePositionSpanExtensions : object {
    [ExtensionAttribute]
public static int StartLine(FileLinePositionSpan fileLinePositionSpan);
    [ExtensionAttribute]
public static int EndLine(FileLinePositionSpan fileLinePositionSpan);
    [ExtensionAttribute]
public static bool IsMultiLine(FileLinePositionSpan fileLinePositionSpan);
    [ExtensionAttribute]
public static bool IsSingleLine(FileLinePositionSpan fileLinePositionSpan);
    [ExtensionAttribute]
internal static int GetLineCount(FileLinePositionSpan fileLinePositionSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.FileSystemHelpers : object {
    [CompilerGeneratedAttribute]
private static bool <IsCaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringComparer <Comparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringComparison <Comparison>k__BackingField;
    public static bool IsCaseSensitive { get; }
    public static StringComparer Comparer { get; }
    public static StringComparison Comparison { get; }
    private static FileSystemHelpers();
    [CompilerGeneratedAttribute]
public static bool get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public static StringComparer get_Comparer();
    [CompilerGeneratedAttribute]
public static StringComparison get_Comparison();
    private static bool GetIsCaseSensitive();
    public static bool IsDirectorySeparator(char ch);
    public static bool TryGetNormalizedFullPath(string path, String& result);
    [NullableContextAttribute("2")]
public static bool TryGetNormalizedFullPath(string path, string basePath, String& result);
    public static string DetermineRelativePath(string baseDirectoryPath, string filePath);
    public static int LastIndexOfDirectorySeparator(string path);
    public static int GetExtensionIndex(string path);
}
internal abstract class Roslynator.FlagsUtility`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static FlagsUtility`1<T> <Instance>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FlagsUtility`1<T> Instance { get; }
    public int FlagCount { get; }
    public T MaxValue { get; }
    private static FlagsUtility`1();
    [CompilerGeneratedAttribute]
public static FlagsUtility`1<T> get_Instance();
    [NullableContextAttribute("1")]
private static object GetInstance();
    public abstract virtual int get_FlagCount();
    public abstract virtual T get_MaxValue();
    internal abstract virtual Optional`1<T> GetUniquePowerOfTwo(IEnumerable`1<T> reservedValues, bool startFromHighestExistingValue);
    public abstract virtual bool IsZeroOrPowerOfTwo(T value);
    public abstract virtual bool IsPowerOfTwo(T value);
    public abstract virtual bool IsComposite(T value);
    public abstract virtual IEnumerable`1<T> GetFlags(T value);
    public abstract virtual Optional`1<T> Combine(ImmutableArray`1<T> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.GeneratedCodeUtility : object {
    private static Char[] _separators;
    private static GeneratedCodeUtility();
    public static bool IsGeneratedCode(SyntaxTree tree, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static bool IsGeneratedCode(ISymbol symbol, INamedTypeSymbol generatedCodeAttribute, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static bool IsGeneratedCodeFile(string filePath);
    internal static bool BeginsWithAutoGeneratedComment(SyntaxTree tree, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
    internal static bool BeginsWithAutoGeneratedComment(SyntaxNode root, Func`2<SyntaxTrivia, bool> isComment);
    public static bool IsMarkedWithGeneratedCodeAttribute(ISymbol symbol, INamedTypeSymbol generatedCodeAttribute);
    [CompilerGeneratedAttribute]
internal static bool <IsGeneratedCodeFile>g__IsMatch|3_0(string value, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.Hash : object {
    public static int OffsetBasis;
    public static int Prime;
    public static int Create(int value);
    public static int Create(bool value);
    public static int Create(T value);
    public static int Combine(int value, int hash);
    public static int Combine(bool value, int hash);
    public static int Combine(T value, int hash);
    public static int CombineValues(IEnumerable`1<T> values, IEqualityComparer`1<T> comparer, int maxItemsToHash);
    public static int CombineValues(T[] values, IEqualityComparer`1<T> comparer, int maxItemsToHash);
    [NullableContextAttribute("2")]
public static int CombineValues(ImmutableArray`1<T> values, IEqualityComparer`1<T> comparer, int maxItemsToHash);
    public static int CombineValues(IEnumerable`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    public static int CombineValues(String[] values, StringComparer stringComparer, int maxItemsToHash);
    public static int CombineValues(ImmutableArray`1<string> values, StringComparer stringComparer, int maxItemsToHash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.Immutable : object {
    public static bool InterlockedInitialize(ImmutableArray`1& location, T item);
    public static bool InterlockedInitialize(ImmutableArray`1& location, T item1, T item2);
    public static bool InterlockedInitialize(ImmutableArray`1& location, T item1, T item2, T item3);
    public static bool InterlockedInitialize(ImmutableArray`1& location, T item1, T item2, T item3, T item4);
    public static bool InterlockedInitialize(ImmutableArray`1& location, T[] items);
}
[IsReadOnlyAttribute]
internal class Roslynator.Interval : ValueType {
    [CompilerGeneratedAttribute]
private int <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Max>k__BackingField;
    public int Min { get; }
    public int Max { get; }
    public Interval(int min, int max);
    [CompilerGeneratedAttribute]
public int get_Min();
    [CompilerGeneratedAttribute]
public int get_Max();
    public bool Contains(int value);
    [NullableContextAttribute("2")]
public bool Contains(ImmutableArray`1<T> items);
    public bool Contains(SyntaxList`1<T> items);
    public bool Contains(SeparatedSyntaxList`1<T> items);
    public bool Contains(Interval interval);
    public Interval ShiftLeft(int value);
    public Interval ShiftRight(int value);
    public static bool op_Equality(Interval left, Interval right);
    public static bool op_Inequality(Interval left, Interval right);
    public sealed virtual bool Equals(Interval other);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
public interface Roslynator.ISelection`1 {
    public int FirstIndex { get; }
    public int LastIndex { get; }
    public abstract virtual int get_FirstIndex();
    public abstract virtual int get_LastIndex();
    public abstract virtual T First();
    public abstract virtual T Last();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslynator.ListExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T SingleOrDefault(IReadOnlyList`1<T> list, bool shouldThrow);
    [ExtensionAttribute]
public static T SingleOrDefault(IReadOnlyList`1<T> list, Func`2<T, bool> predicate, bool shouldThrow);
    [ExtensionAttribute]
public static bool IsSorted(IReadOnlyList`1<T> values, IComparer`1<T> comparer);
}
internal enum Roslynator.MemberDeclarationKind : Enum {
    public int value__;
    public static MemberDeclarationKind None;
    public static MemberDeclarationKind Const;
    public static MemberDeclarationKind Field;
    public static MemberDeclarationKind StaticConstructor;
    public static MemberDeclarationKind Constructor;
    public static MemberDeclarationKind Destructor;
    public static MemberDeclarationKind Event;
    public static MemberDeclarationKind Property;
    public static MemberDeclarationKind Indexer;
    public static MemberDeclarationKind Method;
    public static MemberDeclarationKind ExplicitlyImplementedEvent;
    public static MemberDeclarationKind ExplicitlyImplementedProperty;
    public static MemberDeclarationKind ExplicitlyImplementedIndexer;
    public static MemberDeclarationKind ExplicitlyImplementedMethod;
    public static MemberDeclarationKind ConversionOperator;
    public static MemberDeclarationKind Operator;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.MetadataName : ValueType {
    internal static int PlusHashCode;
    internal static int DotHashCode;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ContainingNamespaces>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ContainingTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> ContainingNamespaces { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> ContainingTypes { get; }
    public string Name { get; }
    public bool IsDefault { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public MetadataName(IEnumerable`1<string> containingNamespaces, string name);
    public MetadataName(IEnumerable`1<string> containingNamespaces, IEnumerable`1<string> containingTypes, string name);
    public MetadataName(ImmutableArray`1<string> containingNamespaces, string name);
    public MetadataName(ImmutableArray`1<string> containingNamespaces, ImmutableArray`1<string> containingTypes, string name);
    private static MetadataName();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ContainingNamespaces();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ContainingTypes();
    [CompilerGeneratedAttribute]
public string get_Name();
    public bool get_IsDefault();
    private string get_DebuggerDisplay();
    public virtual string ToString();
    internal string ToString(SymbolDisplayTypeQualificationStyle typeQualificationStyle);
    public virtual bool Equals(object obj);
    internal bool Equals(ISymbol symbol);
    public sealed virtual bool Equals(MetadataName other);
    public virtual int GetHashCode();
    internal static int GetHashCode(string name);
    public static MetadataName Parse(string name);
    public static bool TryParse(string name, MetadataName& metadataName);
    private static MetadataName Parse(string name, bool shouldThrow);
    public static bool op_Equality(MetadataName& metadataName1, MetadataName& metadataName2);
    public static bool op_Inequality(MetadataName& metadataName1, MetadataName& metadataName2);
    [CompilerGeneratedAttribute]
internal static int <GetHashCode>g__Combine|24_0(string name, <>c__DisplayClass24_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Roslynator.MetadataNameEqualityComparer`1 : EqualityComparer`1<TSymbol> {
    [CompilerGeneratedAttribute]
private static MetadataNameEqualityComparer`1<TSymbol> <Instance>k__BackingField;
    public static MetadataNameEqualityComparer`1<TSymbol> Instance { get; }
    private static MetadataNameEqualityComparer`1();
    [CompilerGeneratedAttribute]
public static MetadataNameEqualityComparer`1<TSymbol> get_Instance();
    private static object GetInstance();
    public virtual bool Equals(TSymbol x, TSymbol y);
    public virtual int GetHashCode(TSymbol obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static int <GetHashCode>g__Combine|6_0(ISymbol symbol, <>c__DisplayClass6_0& );
}
internal static class Roslynator.MetadataNames : object {
    public static MetadataName Microsoft_CodeAnalysis_CSharp_CSharpSyntaxNode;
    public static MetadataName Microsoft_CodeAnalysis_CSharp_SyntaxKind;
    public static MetadataName Microsoft_CodeAnalysis_SyntaxNode;
    public static MetadataName System_ArgumentException;
    public static MetadataName System_ArgumentNullException;
    public static MetadataName System_Attribute;
    public static MetadataName System_AttributeUsageAttribute;
    public static MetadataName System_Collections_Generic;
    public static MetadataName System_Collections_IComparer;
    public static MetadataName System_Collections_IEqualityComparer;
    public static MetadataName System_Collections_Generic_IAsyncEnumerable_T;
    public static MetadataName System_Collections_Generic_IComparer_T;
    public static MetadataName System_Collections_Generic_IEqualityComparer_T;
    public static MetadataName System_Collections_Generic_IEnumerable_T;
    public static MetadataName System_Collections_Generic_List_T;
    public static MetadataName System_Collections_Generic_Dictionary_T2;
    public static MetadataName System_Collections_IDictionary;
    public static MetadataName System_Collections_Immutable_ImmutableArray_T;
    public static MetadataName System_ComponentModel_INotifyPropertyChanged;
    public static MetadataName System_Diagnostics;
    public static MetadataName System_Diagnostics_CodeAnalysis;
    public static MetadataName System_Diagnostics_Debug;
    public static MetadataName System_Diagnostics_DebuggerDisplayAttribute;
    public static MetadataName System_Dynamic_ExpandoObject;
    public static MetadataName System_Enum;
    public static MetadataName System_EventArgs;
    public static MetadataName System_EventHandler;
    public static MetadataName System_Exception;
    public static MetadataName System_FlagsAttribute;
    public static MetadataName System_FormattableString;
    public static MetadataName System_Func_T2;
    public static MetadataName System_Func_T3;
    public static MetadataName System_IAsyncDisposable;
    public static MetadataName System_IEquatable_T;
    public static MetadataName System_IComparable;
    public static MetadataName System_IComparable_T;
    public static MetadataName System_Linq_Enumerable;
    public static MetadataName System_Linq_Expressions_Expression_T;
    public static MetadataName System_Linq_ImmutableArrayExtensions;
    public static MetadataName System_Linq_IOrderedEnumerable_T;
    public static MetadataName System_Linq_IQueryable_T;
    public static MetadataName System_NonSerializedAttribute;
    public static MetadataName System_ObsoleteAttribute;
    public static MetadataName System_ReadOnlySpan_T;
    public static MetadataName System_Reflection;
    public static MetadataName System_Runtime_CompilerServices;
    public static MetadataName System_Runtime_CompilerServices_CollectionBuilderAttribute;
    public static MetadataName System_Runtime_CompilerServices_ConfiguredTaskAwaitable;
    public static MetadataName System_Runtime_CompilerServices_ConfiguredTaskAwaitable_T;
    public static MetadataName System_Runtime_InteropServices_LayoutKind;
    public static MetadataName System_Runtime_InteropServices_StructLayoutAttribute;
    public static MetadataName System_Runtime_Serialization_DataMemberAttribute;
    public static MetadataName System_Runtime_Serialization_SerializationInfo;
    public static MetadataName System_Runtime_Serialization_StreamingContext;
    public static MetadataName System_Span_T;
    public static MetadataName System_StringComparison;
    public static MetadataName System_Text_RegularExpressions_Regex;
    public static MetadataName System_Text_RegularExpressions_RegexOptions;
    public static MetadataName System_Text_StringBuilder;
    public static MetadataName System_Threading_CancellationToken;
    public static MetadataName System_Threading_Tasks;
    public static MetadataName System_Threading_Tasks_Task;
    public static MetadataName System_Threading_Tasks_Task_T;
    public static MetadataName System_Threading_Tasks_ValueTask;
    public static MetadataName System_Threading_Tasks_ValueTask_T;
    public static MetadataName System_TimeSpan;
    public static MetadataName System_ValueType;
    public static MetadataName System_Windows_DependencyPropertyChangedEventArgs;
    private static MetadataNames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.MetadataNameSet : object {
    [CompilerGeneratedAttribute]
private static MetadataNameSet <Empty>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<MetadataName> <Values>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ImmutableArray`1<MetadataName>> _valuesByName;
    public static MetadataNameSet Empty { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<MetadataName> Values { get; }
    public bool IsEmpty { get; }
    public MetadataNameSet(IEnumerable`1<string> values);
    public MetadataNameSet(IEnumerable`1<MetadataName> values);
    private static MetadataNameSet();
    [CompilerGeneratedAttribute]
public static MetadataNameSet get_Empty();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public ImmutableArray`1<MetadataName> get_Values();
    public bool get_IsEmpty();
    public bool Contains(ISymbol symbol);
    public bool ContainsAny(ImmutableArray`1<AttributeData> attributes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Roslynator.NameGenerator : object {
    [CompilerGeneratedAttribute]
private static StringComparer <OrdinalComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringComparer <OrdinalIgnoreCaseComparer>k__BackingField;
    internal static StringComparer OrdinalComparer { get; }
    internal static StringComparer OrdinalIgnoreCaseComparer { get; }
    public static NameGenerator Default { get; }
    private static NameGenerator();
    [CompilerGeneratedAttribute]
internal static StringComparer get_OrdinalComparer();
    [CompilerGeneratedAttribute]
internal static StringComparer get_OrdinalIgnoreCaseComparer();
    public static NameGenerator get_Default();
    public abstract virtual string EnsureUniqueName(string baseName, IEnumerable`1<string> reservedNames, bool isCaseSensitive);
    public abstract virtual string EnsureUniqueName(string baseName, ImmutableArray`1<ISymbol> symbols, bool isCaseSensitive);
    public string EnsureUniqueName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive);
    public string EnsureUniqueEnumMemberName(string baseName, INamedTypeSymbol enumType, bool isCaseSensitive);
    public string EnsureUniqueLocalName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive, CancellationToken cancellationToken);
    public ImmutableArray`1<string> EnsureUniqueLocalNames(string baseName, SemanticModel semanticModel, int position, int count, bool isCaseSensitive, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetSymbolsForUniqueLocalName(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public string EnsureUniqueParameterName(string baseName, ISymbol containingSymbol, SemanticModel semanticModel, bool isCaseSensitive, CancellationToken cancellationToken);
    public static bool IsUniqueName(string name, ImmutableArray`1<ISymbol> symbols, bool isCaseSensitive);
    public static bool IsUniqueName(string name, IEnumerable`1<string> reservedNames, bool isCaseSensitive);
    public static string CreateName(ITypeSymbol typeSymbol, bool firstCharToLower);
    internal string CreateUniqueLocalName(ITypeSymbol typeSymbol, SemanticModel semanticModel, int position, bool isCaseSensitive, CancellationToken cancellationToken);
    internal string CreateUniqueLocalName(ITypeSymbol typeSymbol, string oldName, SemanticModel semanticModel, int position, bool isCaseSensitive, CancellationToken cancellationToken);
    internal string CreateUniqueParameterName(string oldName, IParameterSymbol parameterSymbol, SemanticModel semanticModel, bool isCaseSensitive, CancellationToken cancellationToken);
    private static bool IsChangeOnlyInSuffix(string oldName, string newName, string uniqueName, bool isCaseSensitive);
    private static StringComparison GetStringComparison(bool isCaseSensitive);
    [CompilerGeneratedAttribute]
internal static bool <IsChangeOnlyInSuffix>g__AreDigits|22_0(string value, int start, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.NameGenerators : object {
    [CompilerGeneratedAttribute]
private static AsyncMethodNameGenerator <AsyncMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private static NumberSuffixNameGenerator <NumberSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private static UnderscoreSuffixNameGenerator <UnderscoreSuffix>k__BackingField;
    public static AsyncMethodNameGenerator AsyncMethod { get; }
    public static NumberSuffixNameGenerator NumberSuffix { get; }
    public static UnderscoreSuffixNameGenerator UnderscoreSuffix { get; }
    private static NameGenerators();
    [CompilerGeneratedAttribute]
public static AsyncMethodNameGenerator get_AsyncMethod();
    [CompilerGeneratedAttribute]
public static NumberSuffixNameGenerator get_NumberSuffix();
    [CompilerGeneratedAttribute]
public static UnderscoreSuffixNameGenerator get_UnderscoreSuffix();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.NumberSuffixNameGenerator : NameGenerator {
    public virtual string EnsureUniqueName(string baseName, IEnumerable`1<string> reservedNames, bool isCaseSensitive);
    public virtual string EnsureUniqueName(string baseName, ImmutableArray`1<ISymbol> symbols, bool isCaseSensitive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.OneOrMany : object {
    public static OneOrMany`1<T> Create(T value);
    public static OneOrMany`1<T> Create(IEnumerable`1<T> values);
    [NullableContextAttribute("2")]
public static OneOrMany`1<T> Create(ImmutableArray`1<T> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Roslynator.OneOrMany`1 : ValueType {
    [NullableAttribute("0")]
private State<T> _state;
    [NullableAttribute("2")]
private T _value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<T> _values;
    public T Item { get; }
    public int Count { get; }
    public bool IsDefault { get; }
    internal OneOrMany`1(T value);
    internal OneOrMany`1(ImmutableArray`1<T> values);
    public sealed virtual T get_Item(int index);
    public sealed virtual int get_Count();
    public bool get_IsDefault();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OneOrMany`1<T> other);
    public virtual int GetHashCode();
    public static bool op_Equality(OneOrMany`1& oneOrMany1, OneOrMany`1& oneOrMany2);
    public static bool op_Inequality(OneOrMany`1& oneOrMany1, OneOrMany`1& oneOrMany2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.OverriddenSymbolInfo : ValueType {
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <OverriddenSymbol>k__BackingField;
    public ISymbol Symbol { get; }
    public ISymbol OverriddenSymbol { get; }
    public bool Success { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public OverriddenSymbolInfo(ISymbol symbol, ISymbol overriddenSymbol);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public ISymbol get_OverriddenSymbol();
    public bool get_Success();
    private string get_DebuggerDisplay();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OverriddenSymbolInfo other);
    public virtual int GetHashCode();
    public static bool op_Equality(OverriddenSymbolInfo& info1, OverriddenSymbolInfo& info2);
    public static bool op_Inequality(OverriddenSymbolInfo& info1, OverriddenSymbolInfo& info2);
}
[IsReadOnlyAttribute]
internal class Roslynator.SelectionResult : ValueType {
    [CompilerGeneratedAttribute]
private static SelectionResult <Fail>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    public static SelectionResult Fail { get; }
    public int FirstIndex { get; }
    public int LastIndex { get; }
    public bool Success { get; }
    public SelectionResult(int firstIndex, int lastIndex);
    private static SelectionResult();
    public bool IsInRange(int minCount, int maxCount);
    [CompilerGeneratedAttribute]
public static SelectionResult get_Fail();
    [CompilerGeneratedAttribute]
public int get_FirstIndex();
    [CompilerGeneratedAttribute]
public int get_LastIndex();
    [CompilerGeneratedAttribute]
public bool get_Success();
    public static SelectionResult Create(SyntaxList`1<TNode> nodes, TextSpan span, int minCount, int maxCount);
    public static SelectionResult Create(SyntaxList`1<TNode> list, TextSpan span);
    public static SelectionResult Create(SeparatedSyntaxList`1<TNode> nodes, TextSpan span, int minCount, int maxCount);
    public static SelectionResult Create(SeparatedSyntaxList`1<TNode> list, TextSpan span);
    [NullableContextAttribute("1")]
public static SelectionResult Create(TextLineCollection lines, TextSpan span, int minCount, int maxCount);
    [NullableContextAttribute("1")]
public static SelectionResult Create(TextLineCollection lines, TextSpan span);
    private static void ThrowIfNotValidRange(int minCount, int maxCount);
    [CompilerGeneratedAttribute]
internal static int <Create>g__GetLastIndex|17_0(TNode node, int i, <>c__DisplayClass17_0`1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Roslynator.SemanticModelExtensions : object {
    [ExtensionAttribute]
internal static Diagnostic GetDiagnostic(SemanticModel semanticModel, string id, Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetEnclosingNamedType(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TSymbol GetEnclosingSymbol(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetSymbol(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol GetTypeSymbol(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetTypeByMetadataName(SemanticModel semanticModel, string fullyQualifiedMetadataName);
    [ExtensionAttribute]
internal static IMethodSymbol GetSpeculativeMethodSymbol(SemanticModel semanticModel, int position, SyntaxNode expression);
    [ExtensionAttribute]
internal static ImmutableArray`1<ISymbol> GetSymbolsDeclaredInEnclosingSymbol(SemanticModel semanticModel, int position, bool excludeAnonymousTypeProperty, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static SyntaxNode GetEnclosingSymbolSyntax(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static ImmutableArray`1<ISymbol> GetDeclaredSymbols(SemanticModel semanticModel, SyntaxNode container, bool excludeAnonymousTypeProperty, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.SeparatedSyntaxListSelection`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SeparatedSyntaxList`1<TNode> <UnderlyingList>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <OriginalSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastIndex>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SeparatedSyntaxList`1<TNode> UnderlyingList { get; }
    public TextSpan OriginalSpan { get; }
    public int FirstIndex { get; }
    public int LastIndex { get; }
    public int Count { get; }
    public TNode Item { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private SeparatedSyntaxListSelection`1(SeparatedSyntaxList`1<TNode> list, TextSpan span, SelectionResult& result);
    protected SeparatedSyntaxListSelection`1(SeparatedSyntaxList`1<TNode> list, TextSpan span, int firstIndex, int lastIndex);
    [CompilerGeneratedAttribute]
public SeparatedSyntaxList`1<TNode> get_UnderlyingList();
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalSpan();
    [CompilerGeneratedAttribute]
public sealed virtual int get_FirstIndex();
    [CompilerGeneratedAttribute]
public sealed virtual int get_LastIndex();
    public sealed virtual int get_Count();
    public sealed virtual TNode get_Item(int index);
    private string get_DebuggerDisplay();
    public sealed virtual TNode First();
    public sealed virtual TNode Last();
    public static SeparatedSyntaxListSelection`1<TNode> Create(SeparatedSyntaxList`1<TNode> list, TextSpan span);
    public static bool TryCreate(SeparatedSyntaxList`1<TNode> list, TextSpan span, SeparatedSyntaxListSelection`1& selection);
    internal static bool TryCreate(SeparatedSyntaxList`1<TNode> list, TextSpan span, int minCount, SeparatedSyntaxListSelection`1& selection);
    internal static bool TryCreate(SeparatedSyntaxList`1<TNode> list, TextSpan span, int minCount, int maxCount, SeparatedSyntaxListSelection`1& selection);
    private static SeparatedSyntaxListSelection`1<TNode> Create(SeparatedSyntaxList`1<TNode> list, TextSpan span, int minCount, int maxCount);
    [NullableContextAttribute("0")]
public Enumerator<TNode> GetEnumerator();
    private sealed virtual override IEnumerator`1<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.StringUtility : object {
    internal static bool IsNullOrEquals(string s, string value);
    internal static bool Equals(string s, string value1, string value2);
    internal static bool Equals(string s, string value);
    public static string FirstCharToLower(string value);
    public static string FirstCharToUpper(string value);
    public static bool IsEmptyOrWhitespace(string value);
    public static string GetLeadingWhitespaceExceptNewLine(string value);
    public static string DoubleBraces(string value);
    public static string EscapeQuote(string value);
    public static string ToCamelCase(string value, bool prefixWithUnderscore);
    public static bool HasPrefix(string value, string prefix, StringComparison comparison);
    public static bool HasSuffix(string value, string suffix, StringComparison comparison);
    private static bool IsBoundary(char ch1, char ch2);
    private static bool IsHyphenOrUnderscore(char ch);
    public static string RemovePrefix(string value, string prefix, StringComparison comparison);
    public static bool TryRemovePrefix(string value, string prefix, String& result);
    public static bool TryRemovePrefix(string value, string prefix, StringComparison comparison, String& result);
    public static string RemoveSuffix(string value, string suffix, StringComparison comparison);
    public static bool TryRemoveSuffix(string value, string suffix, String& result);
    public static bool TryRemoveSuffix(string value, string suffix, StringComparison comparison, String& result);
    public static bool IsOneOrManyUnderscores(string value);
    public static bool IsHexadecimalDigit(char ch);
    public static string ReplaceDoubleBracesWithSingleBrace(string s);
    [CompilerGeneratedAttribute]
internal static bool <ReplaceDoubleBracesWithSingleBrace>g__FindNextIndex|22_0(<>c__DisplayClass22_0& );
}
[ExtensionAttribute]
internal static class Roslynator.SymbolDisplayFormatExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SymbolDisplayFormat Update(SymbolDisplayFormat format, Nullable`1<SymbolDisplayGlobalNamespaceStyle> globalNamespaceStyle, Nullable`1<SymbolDisplayTypeQualificationStyle> typeQualificationStyle, Nullable`1<SymbolDisplayGenericsOptions> genericsOptions, Nullable`1<SymbolDisplayMemberOptions> memberOptions, Nullable`1<SymbolDisplayDelegateStyle> delegateStyle, Nullable`1<SymbolDisplayExtensionMethodStyle> extensionMethodStyle, Nullable`1<SymbolDisplayParameterOptions> parameterOptions, Nullable`1<SymbolDisplayPropertyStyle> propertyStyle, Nullable`1<SymbolDisplayLocalOptions> localOptions, Nullable`1<SymbolDisplayKindOptions> kindOptions, Nullable`1<SymbolDisplayMiscellaneousOptions> miscellaneousOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.SymbolDisplayFormats : object {
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <FullName_WithoutNullableReferenceTypeModifier>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <DisplayName_WithoutNullableReferenceTypeModifier>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <Test>k__BackingField;
    public static SymbolDisplayFormat FullName { get; }
    public static SymbolDisplayFormat FullName_WithoutNullableReferenceTypeModifier { get; }
    public static SymbolDisplayFormat DisplayName { get; }
    public static SymbolDisplayFormat DisplayName_WithoutNullableReferenceTypeModifier { get; }
    public static SymbolDisplayFormat Test { get; }
    private static SymbolDisplayFormats();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_FullName();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_FullName_WithoutNullableReferenceTypeModifier();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_DisplayName();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_DisplayName_WithoutNullableReferenceTypeModifier();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_Test();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.SymbolDisplayPartFactory : object {
    public static SymbolDisplayPart Text(string text);
    public static SymbolDisplayPart Keyword(string keyword);
    public static SymbolDisplayPart Punctuation(string value);
    public static SymbolDisplayPart Space(string text);
    public static SymbolDisplayPart Indentation(string indentChars);
    public static SymbolDisplayPart LineBreak();
    public static SymbolDisplayPart PropertyName(string name, ISymbol symbol);
    public static SymbolDisplayPart MethodName(string name, ISymbol symbol);
}
[FlagsAttribute]
internal enum Roslynator.SymbolDisplayTypeDeclarationOptions : Enum {
    public int value__;
    public static SymbolDisplayTypeDeclarationOptions None;
    public static SymbolDisplayTypeDeclarationOptions IncludeModifiers;
    public static SymbolDisplayTypeDeclarationOptions IncludeAccessibility;
    public static SymbolDisplayTypeDeclarationOptions BaseType;
    public static SymbolDisplayTypeDeclarationOptions Interfaces;
    public static SymbolDisplayTypeDeclarationOptions BaseList;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Roslynator.SymbolExtensions : object {
    [ExtensionAttribute]
internal static IEnumerable`1<ISymbol> FindImplementedInterfaceMembers(ISymbol symbol, bool allInterfaces);
    [ExtensionAttribute]
internal static ISymbol FindFirstImplementedInterfaceMember(ISymbol symbol, bool allInterfaces);
    [ExtensionAttribute]
internal static ISymbol FindImplementedInterfaceMember(ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static ISymbol FindFirstImplementedInterfaceMemberImpl(ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces);
    [ExtensionAttribute]
public static bool ImplementsInterfaceMember(ISymbol symbol, bool allInterfaces);
    [ExtensionAttribute]
public static bool ImplementsInterfaceMember(ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces);
    [ExtensionAttribute]
internal static TSymbol FindFirstImplementedInterfaceMember(ISymbol symbol, bool allInterfaces);
    [ExtensionAttribute]
internal static TSymbol FindFirstImplementedInterfaceMember(ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces);
    [ExtensionAttribute]
private static TSymbol FindFirstImplementedInterfaceMemberImpl(ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces);
    [ExtensionAttribute]
public static bool ImplementsInterfaceMember(ISymbol symbol, bool allInterfaces);
    [ExtensionAttribute]
public static bool ImplementsInterfaceMember(ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4, SymbolKind kind5);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsErrorType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAsyncMethod(ISymbol symbol);
    [ExtensionAttribute]
internal static bool IsPropertyOfAnonymousType(ISymbol symbol);
    [ExtensionAttribute]
internal static SyntaxNode GetSyntax(ISymbol symbol, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Task`1<SyntaxNode> GetSyntaxAsync(ISymbol symbol, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static SyntaxNode GetSyntaxOrDefault(ISymbol symbol, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static AttributeData GetAttribute(ISymbol symbol, INamedTypeSymbol attributeClass);
    [ExtensionAttribute]
public static AttributeData GetAttribute(ISymbol symbol, MetadataName& attributeName);
    [ExtensionAttribute]
public static bool HasAttribute(ISymbol symbol, INamedTypeSymbol attributeClass);
    [ExtensionAttribute]
public static bool HasAttribute(ITypeSymbol typeSymbol, INamedTypeSymbol attributeClass, bool includeBaseTypes);
    [ExtensionAttribute]
public static bool HasAttribute(ISymbol symbol, MetadataName& attributeName);
    [ExtensionAttribute]
public static bool HasAttribute(ITypeSymbol typeSymbol, MetadataName& attributeName, bool includeBaseTypes);
    [ExtensionAttribute]
internal static ImmutableArray`1<IParameterSymbol> ParametersOrDefault(ISymbol symbol);
    [ExtensionAttribute]
internal static ISymbol OverriddenSymbol(ISymbol symbol);
    [ExtensionAttribute]
internal static ISymbol BaseOverriddenSymbol(ISymbol symbol);
    [ExtensionAttribute]
internal static bool IsName(ISymbol symbol, string name);
    [ExtensionAttribute]
internal static bool IsName(ISymbol symbol, string name1, string name2);
    [ExtensionAttribute]
internal static bool IsContainingType(ISymbol symbol, SpecialType specialType);
    [ExtensionAttribute]
public static bool IsPubliclyVisible(ISymbol symbol);
    [ExtensionAttribute]
internal static bool IsPubliclyOrInternallyVisible(ISymbol symbol);
    [ExtensionAttribute]
internal static Visibility GetVisibility(ISymbol symbol);
    [ExtensionAttribute]
internal static bool IsVisible(ISymbol symbol, Visibility visibility);
    [ExtensionAttribute]
internal static bool IsVisible(ISymbol symbol, VisibilityFilter visibilityFilter);
    [ExtensionAttribute]
public static bool HasMetadataName(ISymbol symbol, MetadataName& metadataName);
    [ExtensionAttribute]
internal static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [ExtensionAttribute]
internal static INamespaceSymbol GetRootNamespace(ISymbol symbol);
    [ExtensionAttribute]
internal static ImmutableArray`1<INamedTypeSymbol> GetTypes(IAssemblySymbol assemblySymbol, Func`2<INamedTypeSymbol, bool> predicate);
    [ExtensionAttribute]
internal static ImmutableArray`1<INamespaceSymbol> GetNamespaces(IAssemblySymbol assemblySymbol, Func`2<INamespaceSymbol, bool> predicate);
    [ExtensionAttribute]
internal static IEventSymbol BaseOverriddenEvent(IEventSymbol eventSymbol);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, bool value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, char value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, sbyte value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, byte value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, short value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, ushort value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, int value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, UInt32 value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, long value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, ulong value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, decimal value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, float value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, double value);
    [ExtensionAttribute]
public static bool HasConstantValue(IFieldSymbol fieldSymbol, string value);
    [ExtensionAttribute]
internal static IMethodSymbol BaseOverriddenMethod(IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IMethodSymbol ReducedFromOrSelf(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsReducedExtensionMethod(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOrdinaryExtensionMethod(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
internal static bool IsReturnType(IMethodSymbol methodSymbol, SpecialType specialType);
    [ExtensionAttribute]
internal static bool HasSingleParameter(IMethodSymbol methodSymbol, SpecialType parameterType);
    [ExtensionAttribute]
internal static bool HasTwoParameters(IMethodSymbol methodSymbol, SpecialType firstParameterType, SpecialType secondParameterType);
    [ExtensionAttribute]
internal static bool IsSystemNamespace(INamespaceSymbol namespaceSymbol);
    [ExtensionAttribute]
public static bool IsParameterArrayOf(IParameterSymbol parameterSymbol, SpecialType elementType);
    [ExtensionAttribute]
public static bool IsParameterArrayOf(IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2);
    [ExtensionAttribute]
public static bool IsParameterArrayOf(IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2, SpecialType elementType3);
    [ExtensionAttribute]
public static bool IsRefOrOut(IParameterSymbol parameterSymbol);
    [ExtensionAttribute]
internal static IPropertySymbol BaseOverriddenProperty(IPropertySymbol propertySymbol);
    [ExtensionAttribute]
public static bool IsNullableOf(INamedTypeSymbol namedTypeSymbol, SpecialType specialType);
    [ExtensionAttribute]
public static bool IsNullableOf(INamedTypeSymbol namedTypeSymbol, ITypeSymbol typeArgument);
    [ExtensionAttribute]
public static TSymbol FindMember(INamedTypeSymbol typeSymbol, Func`2<TSymbol, bool> predicate, bool includeBaseTypes);
    [ExtensionAttribute]
public static TSymbol FindMember(INamedTypeSymbol typeSymbol, string name, Func`2<TSymbol, bool> predicate, bool includeBaseTypes);
    [ExtensionAttribute]
private static TSymbol FindMemberImpl(INamedTypeSymbol typeSymbol, string name, Func`2<TSymbol, bool> predicate, bool includeBaseTypes);
    [ExtensionAttribute]
public static INamedTypeSymbol FindTypeMember(INamedTypeSymbol typeSymbol, Func`2<INamedTypeSymbol, bool> predicate, bool includeBaseTypes);
    [ExtensionAttribute]
public static INamedTypeSymbol FindTypeMember(INamedTypeSymbol typeSymbol, string name, Func`2<INamedTypeSymbol, bool> predicate, bool includeBaseTypes);
    [ExtensionAttribute]
public static INamedTypeSymbol FindTypeMember(INamedTypeSymbol typeSymbol, string name, int arity, Func`2<INamedTypeSymbol, bool> predicate, bool includeBaseTypes);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static INamedTypeSymbol FindTypeMemberImpl(INamedTypeSymbol typeSymbol, string name, Nullable`1<int> arity, Func`2<INamedTypeSymbol, bool> predicate, bool includeBaseTypes);
    [ExtensionAttribute]
public static bool IsNullableOf(ITypeSymbol typeSymbol, SpecialType specialType);
    [ExtensionAttribute]
public static bool IsNullableOf(ITypeSymbol typeSymbol, ITypeSymbol typeArgument);
    [ExtensionAttribute]
public static bool IsVoid(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsString(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsObject(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> BaseTypes(ITypeSymbol type);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> BaseTypesAndSelf(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool Implements(ITypeSymbol typeSymbol, SpecialType interfaceType, bool allInterfaces);
    [ExtensionAttribute]
internal static bool IsOrImplements(ITypeSymbol typeSymbol, SpecialType interfaceType, bool allInterfaces);
    [ExtensionAttribute]
public static bool ImplementsAny(ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, bool allInterfaces);
    [ExtensionAttribute]
public static bool ImplementsAny(ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, SpecialType interfaceType3, bool allInterfaces);
    [ExtensionAttribute]
public static bool Implements(ITypeSymbol typeSymbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces);
    [ExtensionAttribute]
public static bool Implements(ITypeSymbol typeSymbol, MetadataName& interfaceName, bool allInterfaces);
    [ExtensionAttribute]
public static bool SupportsExplicitDeclaration(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool InheritsFrom(ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces);
    [ExtensionAttribute]
public static bool InheritsFrom(ITypeSymbol type, MetadataName& baseTypeName, bool includeInterfaces);
    [ExtensionAttribute]
public static bool EqualsOrInheritsFrom(ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces);
    [ExtensionAttribute]
public static bool EqualsOrInheritsFrom(ITypeSymbol type, MetadataName& baseTypeName, bool includeInterfaces);
    [ExtensionAttribute]
public static TSymbol FindMember(ITypeSymbol typeSymbol, Func`2<TSymbol, bool> predicate);
    [ExtensionAttribute]
public static TSymbol FindMember(ITypeSymbol typeSymbol, string name, Func`2<TSymbol, bool> predicate);
    [NullableContextAttribute("0")]
private static TSymbol FindMemberImpl(ImmutableArray`1<TMemberSymbol> members, Func`2<TSymbol, bool> predicate);
    [ExtensionAttribute]
internal static bool ContainsMember(ITypeSymbol typeSymbol, Func`2<TSymbol, bool> predicate);
    [ExtensionAttribute]
internal static bool ContainsMember(ITypeSymbol typeSymbol, string name, Func`2<TSymbol, bool> predicate);
    [ExtensionAttribute]
internal static bool EqualsOrInheritsFromTaskOfT(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsIEnumerableOfT(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsIEnumerableOrIEnumerableOfT(ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsReferenceTypeOrNullableType(ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullableType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
private static ImmutableArray`1<INamedTypeSymbol> GetInterfaces(ITypeSymbol typeSymbol, bool allInterfaces);
    [CompilerGeneratedAttribute]
internal static void <GetTypes>g__GetTypes|42_0(INamespaceOrTypeSymbol namespaceOrTypeSymbol, <>c__DisplayClass42_0& );
    [CompilerGeneratedAttribute]
internal static void <GetNamespaces>g__GetNamespaces|43_0(INamespaceSymbol namespaceSymbol, <>c__DisplayClass43_0& );
    [CompilerGeneratedAttribute]
internal static bool <SupportsExplicitDeclaration>g__SupportsExplicitDeclaration2|94_0(ImmutableArray`1<ITypeSymbol> typeSymbols);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.SymbolUtility : object {
    public static bool IsPublicStaticReadOnly(IFieldSymbol fieldSymbol, string name);
    public static bool IsPublicStaticNonGeneric(IMethodSymbol methodSymbol, string name);
    public static bool IsPublicInstanceNonGeneric(IMethodSymbol methodSymbol, string name);
    public static bool IsPublicInstance(IPropertySymbol propertySymbol, string name);
    [NullableContextAttribute("2")]
public static bool IsStringAdditionOperator(IMethodSymbol methodSymbol);
    public static bool IsEventHandlerMethod(IMethodSymbol methodSymbol, INamedTypeSymbol eventArgsSymbol);
    public static bool IsEventHandlerMethod(IMethodSymbol methodSymbol);
    public static bool HasAccessibleIndexer(ITypeSymbol typeSymbol, SemanticModel semanticModel, int position);
    public static string GetCountOrLengthPropertyName(ITypeSymbol typeSymbol, SemanticModel semanticModel, int position);
    public static bool IsFunc(ISymbol symbol, ITypeSymbol parameter1, ITypeSymbol parameter2);
    public static bool IsPredicateFunc(ISymbol symbol, ITypeSymbol parameter);
    public static bool IsPredicateFunc(ISymbol symbol, ITypeSymbol parameter1, ITypeSymbol parameter2);
    internal static bool IsPropertyOfNullableOfT(ISymbol symbol, string name);
    internal static bool IsLinqExtensionOfIEnumerableOfTWithoutParameters(IMethodSymbol methodSymbol, string name, bool allowImmutableArrayExtension);
    internal static bool IsLinqElementAt(IMethodSymbol methodSymbol, bool allowImmutableArrayExtension);
    internal static bool IsLinqWhere(IMethodSymbol methodSymbol, bool allowImmutableArrayExtension);
    internal static bool IsLinqWhereWithIndex(IMethodSymbol methodSymbol);
    internal static bool IsLinqSelect(IMethodSymbol methodSymbol, bool allowImmutableArrayExtension);
    internal static bool IsLinqCast(IMethodSymbol methodSymbol);
    internal static bool IsLinqOfType(IMethodSymbol methodSymbol);
    internal static bool IsLinqExtensionOfIEnumerableOfT(IMethodSymbol methodSymbol, string name, int parameterCount, bool allowImmutableArrayExtension);
    internal static bool IsLinqExtensionOfIEnumerableOfT(IMethodSymbol methodSymbol, string name, Interval interval, bool allowImmutableArrayExtension);
    internal static bool IsLinqExtensionOfIEnumerableOfTWithPredicate(IMethodSymbol methodSymbol, string name, bool allowImmutableArrayExtension);
    private static bool IsLinqExtensionOfIEnumerableOfTWithPredicate(IMethodSymbol methodSymbol, string name, int parameterCount, bool allowImmutableArrayExtension);
    public static bool IsImmutableArrayOfT(ITypeSymbol typeSymbol);
    public static bool SupportsSwitchExpression(ITypeSymbol typeSymbol);
    public static bool CanBeEntryPoint(IMethodSymbol methodSymbol);
    public static ulong GetEnumValueAsUInt64(object value, INamedTypeSymbol enumType);
    public static IMethodSymbol FindMethodThatRaisePropertyChanged(INamedTypeSymbol typeSymbol, int position, SemanticModel semanticModel);
    public static bool IsAwaitable(ITypeSymbol typeSymbol, bool shouldCheckWindowsRuntimeTypes);
    internal static INamedTypeSymbol GetPossiblyAwaitableType(ITypeSymbol typeSymbol);
    [CompilerGeneratedAttribute]
internal static Nullable`1<bool> <HasAccessibleIndexer>g__HasIndexer|7_0(SpecialType specialType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <GetCountOrLengthPropertyName>g__GetCountOrLengthPropertyName|8_0(SpecialType specialType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static IMethodSymbol <FindMethodThatRaisePropertyChanged>g__FindMethod|28_0(ImmutableArray`1<ISymbol> symbols, <>c__DisplayClass28_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Roslynator.SyntaxExtensions : object {
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> ReplaceAt(SeparatedSyntaxList`1<TNode> list, int index, TNode newNode);
    [ExtensionAttribute]
public static bool IsFirst(SeparatedSyntaxList`1<TNode> list, TNode node);
    [ExtensionAttribute]
public static bool IsLast(SeparatedSyntaxList`1<TNode> list, TNode node);
    [ExtensionAttribute]
public static bool Any(SeparatedSyntaxList`1<TNode> list, Func`2<TNode, bool> predicate);
    [ExtensionAttribute]
public static bool All(SeparatedSyntaxList`1<TNode> list, Func`2<TNode, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(SeparatedSyntaxList`1<TNode> list, TNode node);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static TNode SingleOrDefault(SeparatedSyntaxList`1<TNode> list, bool shouldThrow);
    [ExtensionAttribute]
internal static TNode SingleOrDefault(SeparatedSyntaxList`1<TNode> list, Func`2<TNode, bool> predicate, bool shouldThrow);
    [ExtensionAttribute]
internal static TNode LastButOne(SeparatedSyntaxList`1<TNode> list);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static TNode LastButOneOrDefault(SeparatedSyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> WithTriviaFrom(SeparatedSyntaxList`1<TNode> list, SyntaxNode node);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxToken GetTrailingSeparator(SeparatedSyntaxList`1<TNode> list);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool HasTrailingSeparator(SeparatedSyntaxList`1<TNode> list);
    [ExtensionAttribute]
internal static string ToString(SeparatedSyntaxList`1<TNode> list, TextSpan span);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static SyntaxTriviaList GetTrailingTrivia(SeparatedSyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static SyntaxList`1<TNode> ReplaceAt(SyntaxList`1<TNode> list, int index, TNode newNode);
    [ExtensionAttribute]
public static bool IsFirst(SyntaxList`1<TNode> list, TNode node);
    [ExtensionAttribute]
public static bool IsLast(SyntaxList`1<TNode> list, TNode node);
    [ExtensionAttribute]
public static bool Any(SyntaxList`1<TNode> list, Func`2<TNode, bool> predicate);
    [ExtensionAttribute]
public static bool All(SyntaxList`1<TNode> list, Func`2<TNode, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(SyntaxList`1<TNode> list, TNode node);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static TNode SingleOrDefault(SyntaxList`1<TNode> list, bool shouldThrow);
    [ExtensionAttribute]
internal static TNode SingleOrDefault(SyntaxList`1<TNode> list, Func`2<TNode, bool> predicate, bool shouldThrow);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static bool SpanContainsDirectives(SyntaxList`1<TNode> list);
    [ExtensionAttribute]
internal static TNode LastButOne(SyntaxList`1<TNode> list);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static TNode LastButOneOrDefault(SyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static SyntaxList`1<TNode> WithTriviaFrom(SyntaxList`1<TNode> list, SyntaxNode node);
    [IteratorStateMachineAttribute("Roslynator.SyntaxExtensions/<DescendantTrivia>d__27`1")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> DescendantTrivia(SyntaxList`1<TNode> list, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    [IteratorStateMachineAttribute("Roslynator.SyntaxExtensions/<DescendantTrivia>d__28`1")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> DescendantTrivia(SyntaxList`1<TNode> list, TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    [ExtensionAttribute]
internal static string ToString(SyntaxList`1<TNode> list, TextSpan span);
    [ExtensionAttribute]
public static SyntaxTriviaList GetLeadingAndTrailingTrivia(SyntaxNode node);
    [ExtensionAttribute]
public static TNode PrependToLeadingTrivia(TNode node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static TNode PrependToLeadingTrivia(TNode node, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static TNode PrependToTrailingTrivia(TNode node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static TNode PrependToTrailingTrivia(TNode node, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static TNode AppendToLeadingTrivia(TNode node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static TNode AppendToLeadingTrivia(TNode node, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static TNode AppendToTrailingTrivia(TNode node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static TNode AppendToTrailingTrivia(TNode node, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool SpanContainsDirectives(SyntaxNode node);
    [ExtensionAttribute]
internal static bool SpanOrLeadingTriviaContainsDirectives(SyntaxNode node);
    [ExtensionAttribute]
internal static bool SpanOrTrailingTriviaContainsDirectives(SyntaxNode node);
    [ExtensionAttribute]
public static bool ContainsDirectives(SyntaxNode node, TextSpan span);
    [ExtensionAttribute]
public static TNode WithTriviaFrom(TNode node, SyntaxToken token);
    [ExtensionAttribute]
internal static int GetSpanStartLine(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static int GetFullSpanStartLine(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static int GetSpanEndLine(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static int GetFullSpanEndLine(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TNode FirstAncestor(SyntaxNode node, Func`2<TNode, bool> predicate, bool ascendOutOfTrivia);
    [ExtensionAttribute]
internal static string ToString(SyntaxNode node, TextSpan span);
    [ExtensionAttribute]
internal static TextSpan LeadingTriviaSpan(SyntaxNode node);
    [ExtensionAttribute]
internal static TextSpan TrailingTriviaSpan(SyntaxNode node);
    [ExtensionAttribute]
public static TNode FirstDescendant(SyntaxNode node, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    [ExtensionAttribute]
public static TNode FirstDescendant(SyntaxNode node, TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    [ExtensionAttribute]
public static TNode FirstDescendantOrSelf(SyntaxNode node, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    [ExtensionAttribute]
public static TNode FirstDescendantOrSelf(SyntaxNode node, TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    [ExtensionAttribute]
internal static SyntaxNode GetParent(SyntaxNode node, bool ascendOutOfTrivia);
    [ExtensionAttribute]
internal static SyntaxNode WalkUp(SyntaxNode node, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static SyntaxNodeOrToken WithoutTrivia(SyntaxNodeOrToken nodeOrToken);
    [ExtensionAttribute]
public static SyntaxNodeOrToken WithoutLeadingTrivia(SyntaxNodeOrToken nodeOrToken);
    [ExtensionAttribute]
public static SyntaxNodeOrToken WithoutTrailingTrivia(SyntaxNodeOrToken nodeOrToken);
    [ExtensionAttribute]
public static SyntaxToken PrependToLeadingTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxToken PrependToLeadingTrivia(SyntaxToken token, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxToken PrependToTrailingTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxToken PrependToTrailingTrivia(SyntaxToken token, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxToken AppendToTrailingTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxToken AppendToTrailingTrivia(SyntaxToken token, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxToken AppendToLeadingTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxToken AppendToLeadingTrivia(SyntaxToken token, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxTriviaList LeadingAndTrailingTrivia(SyntaxToken token);
    [ExtensionAttribute]
internal static int GetSpanStartLine(SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static int GetFullSpanStartLine(SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static int GetSpanEndLine(SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static int GetFullSpanEndLine(SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxToken WithoutLeadingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken WithoutTrailingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken WithTriviaFrom(SyntaxToken token, SyntaxNode node);
    [ExtensionAttribute]
internal static TextSpan LeadingTriviaSpan(SyntaxToken token);
    [ExtensionAttribute]
internal static TextSpan TrailingTriviaSpan(SyntaxToken token);
    [ExtensionAttribute]
internal static string ToString(SyntaxToken token, TextSpan span);
    [ExtensionAttribute]
public static SyntaxTokenList ReplaceAt(SyntaxTokenList tokenList, int index, SyntaxToken newToken);
    [ExtensionAttribute]
public static bool Any(SyntaxTokenList list, Func`2<SyntaxToken, bool> predicate);
    [ExtensionAttribute]
public static bool All(SyntaxTokenList list, Func`2<SyntaxToken, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(SyntaxTokenList tokens, SyntaxToken token);
    [ExtensionAttribute]
public static int IndexOf(SyntaxTokenList tokens, Func`2<SyntaxToken, bool> predicate);
    [ExtensionAttribute]
internal static bool IsSorted(SyntaxTokenList modifiers, IComparer`1<SyntaxToken> comparer);
    [ExtensionAttribute]
internal static bool SpanContainsDirectives(SyntaxTokenList tokens);
    [ExtensionAttribute]
public static bool TryGetContainingList(SyntaxTrivia trivia, SyntaxTriviaList& triviaList, bool allowLeading, bool allowTrailing);
    [ExtensionAttribute]
internal static SyntaxTriviaList GetContainingList(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static TextSpan LeadingTriviaSpan(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static TextSpan TrailingTriviaSpan(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxTriviaList ReplaceAt(SyntaxTriviaList triviaList, int index, SyntaxTrivia newTrivia);
    [ExtensionAttribute]
public static bool Any(SyntaxTriviaList list, Func`2<SyntaxTrivia, bool> predicate);
    [ExtensionAttribute]
public static bool All(SyntaxTriviaList list, Func`2<SyntaxTrivia, bool> predicate);
    [ExtensionAttribute]
public static int IndexOf(SyntaxTriviaList triviaList, Func`2<SyntaxTrivia, bool> predicate);
    [ExtensionAttribute]
internal static bool ContainsDirective(SyntaxTriviaList triviaList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.SyntaxListSelection`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SyntaxList`1<TNode> <UnderlyingList>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <OriginalSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastIndex>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SyntaxList`1<TNode> UnderlyingList { get; }
    public TextSpan OriginalSpan { get; }
    public int FirstIndex { get; }
    public int LastIndex { get; }
    public int Count { get; }
    public TNode Item { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private SyntaxListSelection`1(SyntaxList`1<TNode> list, TextSpan span, SelectionResult& result);
    protected SyntaxListSelection`1(SyntaxList`1<TNode> list, TextSpan span, int firstIndex, int lastIndex);
    [CompilerGeneratedAttribute]
public SyntaxList`1<TNode> get_UnderlyingList();
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalSpan();
    [CompilerGeneratedAttribute]
public sealed virtual int get_FirstIndex();
    [CompilerGeneratedAttribute]
public sealed virtual int get_LastIndex();
    public sealed virtual int get_Count();
    public sealed virtual TNode get_Item(int index);
    private string get_DebuggerDisplay();
    public sealed virtual TNode First();
    public sealed virtual TNode Last();
    public static SyntaxListSelection`1<TNode> Create(SyntaxList`1<TNode> list, TextSpan span);
    public static bool TryCreate(SyntaxList`1<TNode> list, TextSpan span, SyntaxListSelection`1& selection);
    internal static bool TryCreate(SyntaxList`1<TNode> list, TextSpan span, int minCount, SyntaxListSelection`1& selection);
    internal static bool TryCreate(SyntaxList`1<TNode> list, TextSpan span, int minCount, int maxCount, SyntaxListSelection`1& selection);
    private static SyntaxListSelection`1<TNode> Create(SyntaxList`1<TNode> list, TextSpan span, int minCount, int maxCount);
    [NullableContextAttribute("0")]
public Enumerator<TNode> GetEnumerator();
    private sealed virtual override IEnumerator`1<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Roslynator.SyntaxTreeExtensions : object {
    [ExtensionAttribute]
public static int GetStartLine(SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static int GetEndLine(SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsMultiLineSpan(SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsSingleLineSpan(SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static int GetLineCount(SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.SyntaxUtility : object {
    public static bool CanConvertToCollectionExpression(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsPropertyOfNullableOfT(SyntaxNode node, string name, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static bool IsCompositeEnumValue(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Roslynator.Text.IndentationInfo : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    public SyntaxToken Token { get; }
    public TextSpan Span { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public IndentationInfo(SyntaxToken token, TextSpan span);
    [CompilerGeneratedAttribute]
public SyntaxToken get_Token();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    private string get_DebuggerDisplay();
    public virtual string ToString();
    public SyntaxTrivia GetTrivia();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IndentationInfo other);
    public virtual int GetHashCode();
    public static bool op_Equality(IndentationInfo left, IndentationInfo right);
    public static bool op_Inequality(IndentationInfo left, IndentationInfo right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.Text.StringBuilderCache : object {
    private static int MaxSize;
    private static int DefaultCapacity;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static StringBuilder _cachedInstance;
    public static StringBuilder GetInstance(int capacity);
    public static void Free(StringBuilder sb);
    public static string GetStringAndFree(StringBuilder sb);
}
[ExtensionAttribute]
internal static class Roslynator.Text.StringBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static StringBuilder Replace(StringBuilder sb, string oldValue, string newValue, int startIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.Text.SyntaxNodeTextBuilder : object {
    [CompilerGeneratedAttribute]
private SyntaxNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <StringBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <FullSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullString>k__BackingField;
    public SyntaxNode Node { get; }
    public StringBuilder StringBuilder { get; }
    public TextSpan FullSpan { get; }
    public string FullString { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public SyntaxNodeTextBuilder(SyntaxNode node);
    public SyntaxNodeTextBuilder(SyntaxNode node, StringBuilder stringBuilder);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Node();
    [CompilerGeneratedAttribute]
public StringBuilder get_StringBuilder();
    [CompilerGeneratedAttribute]
public TextSpan get_FullSpan();
    [CompilerGeneratedAttribute]
public string get_FullString();
    private string get_DebuggerDisplay();
    public virtual string ToString();
    public void AppendSpan();
    public void AppendSpan(SyntaxNode node);
    public void AppendSpan(SyntaxToken token);
    public void AppendSpan(SyntaxTrivia trivia);
    public void AppendFullSpan();
    public void AppendFullSpan(SyntaxNode node);
    public void AppendFullSpan(SyntaxToken token);
    public void AppendFullSpan(SyntaxTrivia trivia);
    public void AppendLeadingTrivia();
    public void AppendLeadingTrivia(SyntaxNode node);
    public void AppendLeadingTrivia(SyntaxToken token);
    public void AppendLeadingTrivia(SyntaxTrivia trivia);
    public void AppendLeadingTriviaAndSpan();
    public void AppendLeadingTriviaAndSpan(SyntaxNode node);
    public void AppendLeadingTriviaAndSpan(SyntaxToken token);
    public void AppendLeadingTriviaAndSpan(SyntaxTrivia trivia);
    public void AppendTrailingTrivia();
    public void AppendTrailingTrivia(SyntaxNode node);
    public void AppendTrailingTrivia(SyntaxToken token);
    public void AppendTrailingTrivia(SyntaxTrivia trivia);
    public void AppendSpanAndTrailingTrivia();
    public void AppendSpanAndTrailingTrivia(SyntaxNode node);
    public void AppendSpanAndTrailingTrivia(SyntaxToken token);
    public void AppendSpanAndTrailingTrivia(SyntaxTrivia trivia);
    public void Append(string value);
    public void Append(char value, int repeatCount);
    public void AppendLine();
    public void AppendLine(string value);
    public void Append(TextSpan span);
    private void AppendImpl(TextSpan span);
    private void ThrowIfInvalid(SyntaxNode node);
    private void ThrowIfInvalid(SyntaxToken token);
    private void ThrowIfInvalid(SyntaxTrivia trivia);
    private void ThrowIfInvalid(TextSpan span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Roslynator.Text.TextLineCollectionSelection : object {
    [CompilerGeneratedAttribute]
private TextLineCollection <UnderlyingLines>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <OriginalSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastIndex>k__BackingField;
    public TextLineCollection UnderlyingLines { get; }
    public TextSpan OriginalSpan { get; }
    public int FirstIndex { get; }
    public int LastIndex { get; }
    public int Count { get; }
    public TextLine Item { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private TextLineCollectionSelection(TextLineCollection lines, TextSpan span, SelectionResult& result);
    protected TextLineCollectionSelection(TextLineCollection lines, TextSpan span, int firstIndex, int lastIndex);
    [CompilerGeneratedAttribute]
public TextLineCollection get_UnderlyingLines();
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalSpan();
    [CompilerGeneratedAttribute]
public sealed virtual int get_FirstIndex();
    [CompilerGeneratedAttribute]
public sealed virtual int get_LastIndex();
    public sealed virtual int get_Count();
    public sealed virtual TextLine get_Item(int index);
    private string get_DebuggerDisplay();
    public sealed virtual TextLine First();
    public sealed virtual TextLine Last();
    public static TextLineCollectionSelection Create(TextLineCollection lines, TextSpan span);
    public static bool TryCreate(TextLineCollection lines, TextSpan span, TextLineCollectionSelection& selectedLines);
    internal static bool TryCreate(TextLineCollection lines, TextSpan span, int minCount, TextLineCollectionSelection& selectedLines);
    internal static bool TryCreate(TextLineCollection lines, TextSpan span, int minCount, int maxCount, TextLineCollectionSelection& selectedLines);
    private static TextLineCollectionSelection Create(TextLineCollection lines, TextSpan span, int minCount, int maxCount);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TextLine> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextLine>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslynator.TextExtensions : object {
    [ExtensionAttribute]
public static void Add(IList`1<TextChange> items, TextSpan span, string newText);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void Add(ImmutableArray`1<TextChange> items, TextSpan span, string newText);
    [ExtensionAttribute]
public static SourceText WithChange(SourceText sourceText, TextSpan span, string newText);
    [ExtensionAttribute]
public static int GetLineCount(TextLineCollection textLines, TextSpan span);
    [ExtensionAttribute]
public static bool IsEmptyOrWhiteSpace(TextLine textLine);
    [ExtensionAttribute]
public static bool IsEmptyOrWhiteSpace(TextLine textLine, TextSpan span);
    [ExtensionAttribute]
public static int GetLineCount(LinePositionSpan linePositionSpan);
}
[ExtensionAttribute]
internal static class Roslynator.TextSpanExtensions : object {
    [ExtensionAttribute]
public static TextSpan TrimFromStart(TextSpan span, int length);
    [ExtensionAttribute]
public static TextSpan Offset(TextSpan span, int value);
    [ExtensionAttribute]
public static TextSpan WithLength(TextSpan span, int length);
    [ExtensionAttribute]
public static bool IsContainedIn(TextSpan self, TextSpan span);
    [ExtensionAttribute]
public static bool IsContainedInSpan(TextSpan span, SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsBetweenSpans(TextSpan span, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsBetweenSpans(TextSpan span, SyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static bool IsBetweenSpans(TextSpan span, SeparatedSyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static bool IsBetweenSpans(TextSpan span, SyntaxToken token);
    [ExtensionAttribute]
private static bool IsBetweenSpans(TextSpan span, TextSpan innerSpan, TextSpan outerSpan);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsContainedInSpanOrBetweenSpans(TextSpan span, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsContainedInSpanOrBetweenSpans(TextSpan span, SyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static bool IsContainedInSpanOrBetweenSpans(TextSpan span, SeparatedSyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static bool IsContainedInSpanOrBetweenSpans(TextSpan span, SyntaxToken token);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsEmptyAndContainedInSpanOrBetweenSpans(TextSpan span, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsEmptyAndContainedInSpanOrBetweenSpans(TextSpan span, SyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static bool IsEmptyAndContainedInSpanOrBetweenSpans(TextSpan span, SeparatedSyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static bool IsEmptyAndContainedInSpanOrBetweenSpans(TextSpan span, SyntaxToken token);
    [ExtensionAttribute]
private static bool IsEmptyAndContainedInSpanOrBetweenSpans(TextSpan span, TextSpan innerSpan, TextSpan outerSpan);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsEmptyAndContainedInSpan(TextSpan span, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsEmptyAndContainedInSpan(TextSpan span, SyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static bool IsEmptyAndContainedInSpan(TextSpan span, SeparatedSyntaxList`1<TNode> list);
    [ExtensionAttribute]
public static bool IsEmptyAndContainedInSpan(TextSpan span, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsEmptyAndContainedInSpan(TextSpan span, SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsSingleLine(TextSpan span, SyntaxTree syntaxTree, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsMultiLine(TextSpan span, SyntaxTree syntaxTree, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Flags}")]
internal class Roslynator.TypeAnalysis : ValueType {
    [CompilerGeneratedAttribute]
private ITypeSymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeAnalysisFlags <Flags>k__BackingField;
    public bool IsImplicit { get; }
    public bool IsExplicit { get; }
    public bool SupportsImplicit { get; }
    public bool SupportsExplicit { get; }
    public bool IsTypeObvious { get; }
    public ITypeSymbol Symbol { get; }
    public TypeAnalysisFlags Flags { get; }
    internal TypeAnalysis(ITypeSymbol symbol, TypeAnalysisFlags flags);
    public bool get_IsImplicit();
    public bool get_IsExplicit();
    public bool get_SupportsImplicit();
    public bool get_SupportsExplicit();
    public bool get_IsTypeObvious();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_Symbol();
    [CompilerGeneratedAttribute]
public TypeAnalysisFlags get_Flags();
    public bool Any(TypeAnalysisFlags flags);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeAnalysis other);
    public virtual int GetHashCode();
    public static bool op_Equality(TypeAnalysis& analysis1, TypeAnalysis& analysis2);
    public static bool op_Inequality(TypeAnalysis& analysis1, TypeAnalysis& analysis2);
}
[FlagsAttribute]
internal enum Roslynator.TypeAnalysisFlags : Enum {
    public int value__;
    public static TypeAnalysisFlags None;
    public static TypeAnalysisFlags Implicit;
    public static TypeAnalysisFlags Explicit;
    public static TypeAnalysisFlags Dynamic;
    public static TypeAnalysisFlags SupportsImplicit;
    public static TypeAnalysisFlags SupportsExplicit;
    public static TypeAnalysisFlags TypeObvious;
}
internal enum Roslynator.TypeAppearance : Enum {
    public int value__;
    public static TypeAppearance None;
    public static TypeAppearance Obvious;
    public static TypeAppearance NotObvious;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslynator.UnderscoreSuffixNameGenerator : NameGenerator {
    public virtual string EnsureUniqueName(string baseName, IEnumerable`1<string> reservedNames, bool isCaseSensitive);
    public virtual string EnsureUniqueName(string baseName, ImmutableArray`1<ISymbol> symbols, bool isCaseSensitive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.UnityScriptMethods : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableHashSet`1<string> _methodNames;
    [CompilerGeneratedAttribute]
private static MetadataName <MonoBehaviourClassName>k__BackingField;
    public static MetadataName MonoBehaviourClassName { get; }
    public static ImmutableHashSet`1<string> MethodNames { get; }
    private static UnityScriptMethods();
    [CompilerGeneratedAttribute]
public static MetadataName get_MonoBehaviourClassName();
    public static ImmutableHashSet`1<string> get_MethodNames();
    private static ImmutableHashSet`1<string> LoadMethodNames();
}
public enum Roslynator.Visibility : Enum {
    public int value__;
    public static Visibility NotApplicable;
    public static Visibility Private;
    public static Visibility Internal;
    public static Visibility Public;
}
[FlagsAttribute]
internal enum Roslynator.VisibilityFilter : Enum {
    public int value__;
    public static VisibilityFilter None;
    public static VisibilityFilter Public;
    public static VisibilityFilter Internal;
    public static VisibilityFilter Private;
    public static VisibilityFilter All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.WellKnownDiagnosticIdPrefixes : object {
    public static string AD;
    public static string Async;
    public static string BC;
    public static string BL;
    public static string CA;
    public static string CC;
    public static string CS;
    public static string ENC;
    public static string IDE;
    public static string IL;
    public static string RCS;
    public static string ROS;
    public static string RECS;
    public static string REVB;
    public static string RS;
    public static string SA;
    public static string SX;
    public static string U2U;
    public static string VB;
    public static string VSSDK;
    public static string VSTHRD;
    public static string xUnit;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.WellKnownXmlTags : object {
    public static string C;
    public static string Code;
    public static string Content;
    public static string Example;
    public static string Exception;
    public static string Exclude;
    public static string Include;
    public static string InheritDoc;
    public static string List;
    public static string Para;
    public static string Param;
    public static string ParamRef;
    public static string Permission;
    public static string Remarks;
    public static string Returns;
    public static string See;
    public static string SeeAlso;
    public static string Summary;
    public static string TypeParam;
    public static string TypeParamRef;
    public static string Value;
}
internal enum Roslynator.XmlTag : Enum {
    public int value__;
    public static XmlTag None;
    public static XmlTag C;
    public static XmlTag Code;
    public static XmlTag Content;
    public static XmlTag Example;
    public static XmlTag Exception;
    public static XmlTag Exclude;
    public static XmlTag Include;
    public static XmlTag InheritDoc;
    public static XmlTag List;
    public static XmlTag Para;
    public static XmlTag Param;
    public static XmlTag ParamRef;
    public static XmlTag Permission;
    public static XmlTag Remarks;
    public static XmlTag Returns;
    public static XmlTag See;
    public static XmlTag SeeAlso;
    public static XmlTag Summary;
    public static XmlTag TypeParam;
    public static XmlTag TypeParamRef;
    public static XmlTag Value;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslynator.XmlTagMapper : object {
    private static ImmutableDictionary`2<string, XmlTag> _map;
    private static XmlTagMapper();
    private static ImmutableDictionary`2<string, XmlTag> CreateMap();
    [NullableContextAttribute("2")]
public static XmlTag GetTagOrDefault(string name);
    public static string GetName(XmlTag kind);
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
