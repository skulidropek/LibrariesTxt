[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public abstract class Roslynator.CodeFixes.AbstractCodeFixProvider : CodeFixProvider {
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private string get_DebuggerDisplay();
    public virtual FixAllProvider GetFixAllProvider();
    protected static string GetEquivalenceKey(Diagnostic diagnostic, string additionalKey1, string additionalKey2);
    protected static string GetEquivalenceKey(string key, string additionalKey1, string additionalKey2);
    protected static bool TryFindFirstAncestorOrSelf(SyntaxNode root, TextSpan span, TNode& node, bool findInsideTrivia, bool getInnermostNodeForTie, Func`2<TNode, bool> predicate, bool ascendOutOfTrivia);
    protected static bool TryFindFirstDescendantOrSelf(SyntaxNode root, TextSpan span, TNode& node, bool findInsideTrivia, bool getInnermostNodeForTie, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    protected static bool TryFindNode(SyntaxNode root, TextSpan span, TNode& node, bool findInsideTrivia, bool getInnermostNodeForTie, Func`2<TNode, bool> predicate);
    protected static bool TryFindToken(SyntaxNode root, int position, SyntaxToken& token, bool findInsideTrivia);
    protected static bool TryFindTrivia(SyntaxNode root, int position, SyntaxTrivia& trivia, bool findInsideTrivia);
}
[IsReadOnlyAttribute]
internal class Roslynator.CommonFixContext : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EquivalenceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public Document Document { get; }
    public string EquivalenceKey { get; }
    public SemanticModel SemanticModel { get; }
    public CancellationToken CancellationToken { get; }
    public CommonFixContext(Document document, string equivalenceKey, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public string get_EquivalenceKey();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
[ExtensionAttribute]
internal static class Roslynator.CommonWorkspaceExtensions : object {
    [ExtensionAttribute]
public static bool TryGetAnalyzerOptionValue(Document document, SyntaxNode node, string optionKey, String& value);
    [ExtensionAttribute]
public static bool TryGetAnalyzerOptionValue(Document document, SyntaxToken token, string optionKey, String& value);
    [ExtensionAttribute]
public static bool TryGetAnalyzerOptionValue(Document document, SyntaxTree syntaxTree, string optionKey, String& value);
    [ExtensionAttribute]
internal static AnalyzerConfigOptions GetConfigOptions(Document document, SyntaxTree syntaxTree);
    [ExtensionAttribute]
internal static IndentationAnalysis AnalyzeIndentation(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.CodeActionFactory : object {
    [AsyncStateMachineAttribute("Roslynator.CSharp.CodeActionFactory/<RegisterCodeActionForNewLineAroundTokenAsync>d__0")]
public static Task RegisterCodeActionForNewLineAroundTokenAsync(CodeFixContext context, Func`2<SyntaxToken, bool> tokenPredicate, string newLineReplacement);
    [AsyncStateMachineAttribute("Roslynator.CSharp.CodeActionFactory/<RegisterCodeActionForBlankLineAsync>d__1")]
public static Task RegisterCodeActionForBlankLineAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Roslynator.CSharp.CodeActionFactory/<RegisterCodeActionForNewLineAsync>d__2")]
public static Task RegisterCodeActionForNewLineAsync(CodeFixContext context, string title, string indentation, bool increaseIndentation);
    private static TextChange GetTextChangeForNewLine(SyntaxNode root, int position, AnalyzerConfigOptions configOptions, string indentation, bool increaseIndentation, CancellationToken cancellationToken);
    public static TextChange GetTextChangeForBlankLine(TriviaBlock block);
    public static TextChange GetTextChangeForNewLine(TriviaBlock block, AnalyzerConfigOptions configOptions, string indentation, string newLineReplacement, bool increaseIndentation, CancellationToken cancellationToken);
    public static TriviaBlock CreateBlock(SyntaxNode root, int position);
    private static string GetIncreasedIndentation(SyntaxNodeOrToken nodeOrToken, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    public static CodeAction Create(string title, Func`2<CancellationToken, Task`1<Solution>> createChangedSolution, RefactoringDescriptor descriptor, string additionalEquivalenceKey1, string additionalEquivalenceKey2);
    public static CodeAction Create(string title, Func`2<CancellationToken, Task`1<Document>> createChangedDocument, RefactoringDescriptor descriptor, string additionalEquivalenceKey1, string additionalEquivalenceKey2);
    public static CodeAction ChangeTypeToVar(Document document, TypeSyntax type, string title, string equivalenceKey);
    public static CodeAction ChangeTypeToVar(Document document, TupleExpressionSyntax tupleExpression, string title, string equivalenceKey);
    public static CodeAction UseExplicitType(Document document, TypeSyntax type, ITypeSymbol newTypeSymbol, SemanticModel semanticModel, string equivalenceKey);
    public static CodeAction ChangeType(Document document, TypeSyntax type, ITypeSymbol newTypeSymbol, SemanticModel semanticModel, string title, string equivalenceKey);
    private static SymbolDisplayFormat GetSymbolDisplayFormat(ExpressionSyntax expression, ITypeSymbol newTypeSymbol, SemanticModel semanticModel);
    public static CodeAction AddExplicitCast(Document document, ExpressionSyntax expression, ITypeSymbol destinationType, SemanticModel semanticModel, string title, string equivalenceKey);
    public static CodeAction RemoveMemberDeclaration(Document document, MemberDeclarationSyntax memberDeclaration, string title, string equivalenceKey);
    public static CodeAction RemoveStatement(Document document, StatementSyntax statement, string title, string equivalenceKey);
    public static CodeAction ReplaceNullWithDefaultValue(Document document, ExpressionSyntax expression, ITypeSymbol typeSymbol, string title, string equivalenceKey);
    public static CodeAction RemoveAsyncAwait(Document document, SyntaxToken asyncKeyword, string title, string equivalenceKey);
    public static CodeAction RemoveParentheses(Document document, ParenthesizedExpressionSyntax parenthesizedExpression, string title, string equivalenceKey);
}
internal static class Roslynator.CSharp.CodeFixes.ModifiersCodeFixRegistrator : object {
    public static void AddModifier(CodeFixContext context, Diagnostic diagnostic, SyntaxNode node, SyntaxKind modifierKind, string title, string additionalKey, IComparer`1<SyntaxKind> comparer);
    public static void AddModifier(CodeFixContext context, Document document, Diagnostic diagnostic, SyntaxNode node, SyntaxKind modifierKind, string title, string additionalKey, IComparer`1<SyntaxKind> comparer);
    private static Task`1<Document> AddModifierAsync(Document document, TNode node, SyntaxKind modifierKind, IComparer`1<SyntaxKind> comparer, CancellationToken cancellationToken);
    private static TNode AddModifier(TNode node, SyntaxKind modifierKind, IComparer`1<SyntaxKind> comparer);
    public static void AddModifier(CodeFixContext context, Diagnostic diagnostic, IEnumerable`1<TNode> nodes, SyntaxKind modifierKind, string title, string additionalKey, IComparer`1<SyntaxKind> comparer);
    public static void RemoveModifier(CodeFixContext context, Diagnostic diagnostic, SyntaxNode node, SyntaxKind modifierKind, string title, string additionalKey);
    public static void RemoveModifier(CodeFixContext context, Diagnostic diagnostic, SyntaxNode node, SyntaxToken modifier, string title, string additionalKey);
    private static Task`1<Document> RemoveModifierAsync(Document document, TNode node, SyntaxKind modifierKind, CancellationToken cancellationToken);
    private static Task`1<Document> RemoveModifierAsync(Document document, TNode node, SyntaxToken modifier, CancellationToken cancellationToken);
    public static void RemoveModifier(CodeFixContext context, Diagnostic diagnostic, IEnumerable`1<TNode> nodes, SyntaxKind modifierKind, string title, string additionalKey);
    public static void RemoveModifiers(CodeFixContext context, Diagnostic diagnostic, SyntaxNode node, Func`2<SyntaxToken, bool> predicate, string additionalKey);
    public static void RemoveModifiers(CodeFixContext context, Diagnostic diagnostic, SyntaxNode node, SyntaxTokenList modifiers, Func`2<SyntaxToken, bool> predicate, string additionalKey);
    public static void RemoveModifiers(CodeFixContext context, Diagnostic diagnostic, SyntaxNode node, string additionalKey);
    public static void RemoveAccessibility(CodeFixContext context, Diagnostic diagnostic, SyntaxNode node, string additionalKey);
    public static void MoveModifier(CodeFixContext context, Diagnostic diagnostic, SyntaxNode node, SyntaxToken modifier, string title, string additionalKey, IComparer`1<SyntaxKind> comparer);
    public static void ChangeAccessibility(CodeFixContext context, Diagnostic diagnostic, SyntaxNode node, IEnumerable`1<Accessibility> accessibilities);
    private static string GetEquivalenceKey(Diagnostic diagnostic, string additionalKey);
    private static string GetAddModifierTitle(SyntaxKind modifierKind);
    private static string GetAddModifierTitle(SyntaxKind modifierKind, SyntaxNode node);
    internal static string GetRemoveModifierTitle(SyntaxKind modifierKind);
    private static string GetRemoveModifiersTitle(IEnumerable`1<SyntaxToken> modifiers, Func`2<SyntaxToken, bool> predicate);
}
internal static class Roslynator.CSharp.DocumentRefactoringFactory : object {
    public static Func`2<CancellationToken, Task`1<Document>> ChangeTypeAndAddAwait(Document document, VariableDeclarationSyntax variableDeclaration, VariableDeclaratorSyntax variableDeclarator, ITypeSymbol newTypeSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.DocumentRefactorings : object {
    [AsyncStateMachineAttribute("Roslynator.CSharp.DocumentRefactorings/<ChangeTypeAsync>d__0")]
public static Task`1<Document> ChangeTypeAsync(Document document, TypeSyntax type, ITypeSymbol typeSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SymbolDisplayFormat GetSymbolDisplayFormat(SemanticModel semanticModel, int position);
    private static TypeSyntax ChangeType(TypeSyntax type, ITypeSymbol typeSymbol, SemanticModel semanticModel);
    private static TupleExpressionSyntax CreateTupleExpression(ITypeSymbol typeSymbol, ParenthesizedVariableDesignationSyntax designation, SymbolDisplayFormat format);
    public static Task`1<Document> ChangeTypeToVarAsync(Document document, TypeSyntax type, CancellationToken cancellationToken);
    public static Task`1<Document> ChangeTypeToVarAsync(Document document, TupleExpressionSyntax tupleExpression, CancellationToken cancellationToken);
    public static Task`1<Document> ChangeTypeAndAddAwaitAsync(Document document, VariableDeclarationSyntax variableDeclaration, VariableDeclaratorSyntax variableDeclarator, SyntaxNode containingDeclaration, ITypeSymbol newTypeSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static Task`1<Document> AddExplicitCastAsync(Document document, ExpressionSyntax expression, ITypeSymbol destinationType, CancellationToken cancellationToken);
    public static Task`1<Document> AddExplicitCastAsync(Document document, ExpressionSyntax expression, TypeSyntax destinationType, CancellationToken cancellationToken);
    public static Task`1<Document> RemoveAsyncAwaitAsync(Document document, SyntaxToken asyncKeyword, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CSharp.DocumentRefactorings/<AddNewDocumentationCommentsAsync>d__10")]
public static Task`1<Document> AddNewDocumentationCommentsAsync(Document document, DocumentationCommentGeneratorSettings settings, bool skipNamespaceDeclaration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CSharp.DocumentRefactorings/<AddBaseOrNewDocumentationCommentsAsync>d__11")]
public static Task`1<Document> AddBaseOrNewDocumentationCommentsAsync(Document document, SemanticModel semanticModel, DocumentationCommentGeneratorSettings settings, bool skipNamespaceDeclaration, CancellationToken cancellationToken);
    public static Task`1<Document> RemoveParenthesesAsync(Document document, ParenthesizedExpressionSyntax parenthesizedExpression, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <CreateTupleExpression>g__ConstructTupleExpression|3_0(StringBuilder sb, TupleTypeSyntax tupleType, ParenthesizedVariableDesignationSyntax designation);
}
internal static class Roslynator.CSharp.Refactorings.AddBracesToIfElseRefactoring : object {
    public static Task`1<Document> RefactorAsync(Document document, IfStatementSyntax ifStatement, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.AddBracesToSwitchSectionRefactoring : object {
    public static string Title;
    public static Task`1<Document> RefactorAsync(Document document, SwitchSectionSyntax switchSection, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.AddExceptionToDocumentationComment.AddExceptionElementToDocumentationCommentRefactoring : object {
    [IteratorStateMachineAttribute("Roslynator.CSharp.Refactorings.AddExceptionToDocumentationComment.AddExceptionElementToDocumentationCommentRefactoring/<GetOtherUndocumentedExceptions>d__0")]
private static IEnumerable`1<ThrowInfo> GetOtherUndocumentedExceptions(MemberDeclarationSyntax declaration, ISymbol declarationSymbol, Func`2<SyntaxNode, bool> predicate, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ThrowInfo GetUndocumentedExceptionInfo(SyntaxNode node, ExpressionSyntax expression, MemberDeclarationSyntax declaration, ISymbol declarationSymbol, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CanAddExceptionToComment(DocumentationCommentTriviaSyntax comment, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ContainsException(XmlElementSyntax xmlElement, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ContainsException(XmlEmptyElementSyntax xmlEmptyElement, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ContainsException(SyntaxList`1<XmlAttributeSyntax> attributes, INamedTypeSymbol exceptionSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static Task`1<Document> RefactorAsync(Document document, ThrowExpressionSyntax throwExpression, CancellationToken cancellationToken);
    public static Task`1<Document> RefactorAsync(Document document, ThrowStatementSyntax throwStatement, CancellationToken cancellationToken);
    private static bool InheritsFromException(ITypeSymbol typeSymbol, INamedTypeSymbol exceptionSymbol);
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.AddExceptionToDocumentationComment.AddExceptionElementToDocumentationCommentRefactoring/<RefactorAsync>d__9")]
private static Task`1<Document> RefactorAsync(Document document, SyntaxNode node, ExpressionSyntax expression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.AddExceptionToDocumentationComment.AddExceptionElementToDocumentationCommentRefactoring/<RefactorAsync>d__10")]
public static Task`1<Document> RefactorAsync(Document document, AddExceptionToDocumentationCommentAnalysisResult analysis, CancellationToken cancellationToken);
    private static Task`1<Document> RefactorAsync(Document document, SyntaxTrivia trivia, ThrowInfo throwInfo, MemberDeclarationSyntax memberDeclaration, ISymbol declarationSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static string GetIndent(SyntaxTriviaList leadingTrivia);
    private static void AppendExceptionDocumentation(SyntaxTrivia trivia, ITypeSymbol exceptionSymbol, IParameterSymbol parameterSymbol, SemanticModel semanticModel, StringBuilder& sb);
}
internal static class Roslynator.CSharp.Refactorings.AddParameterToInterfaceMemberRefactoring : object {
    public static CodeAction ComputeRefactoringForExplicitImplementation(CommonFixContext context, MemberDeclarationSyntax memberDeclaration);
    public static OneOrMany`1<CodeAction> ComputeRefactoringForImplicitImplementation(CommonFixContext context, MethodDeclarationSyntax methodDeclaration);
    public static OneOrMany`1<CodeAction> ComputeRefactoringForImplicitImplementation(CommonFixContext context, IndexerDeclarationSyntax indexerDeclaration);
    private static OneOrMany`1<CodeAction> ComputeRefactoringForImplicitImplementation(CommonFixContext context, MemberDeclarationSyntax memberDeclaration, SyntaxTokenList modifiers, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SeparatedSyntaxList`1<ParameterSyntax> parameters);
    public static CodeAction ComputeRefactoringForExplicitImplementation(CommonFixContext context, MemberDeclarationSyntax memberDeclaration, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SeparatedSyntaxList`1<ParameterSyntax> parameters);
    private static OneOrMany`1<CodeAction> ComputeRefactoringForImplicitImplementation(CommonFixContext context, MemberDeclarationSyntax memberDeclaration, SyntaxTokenList modifiers);
    private static ISymbol FindInterfaceMember(ISymbol memberSymbol, INamedTypeSymbol interfaceSymbol);
    private static ISymbol FindInterfaceMethod(IMethodSymbol methodSymbol, INamedTypeSymbol interfaceSymbol);
    private static ISymbol FindInterfaceIndexer(IPropertySymbol propertySymbol, INamedTypeSymbol interfaceSymbol);
    private static bool ParametersEqual(ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<IParameterSymbol> parameters2);
    private static CodeAction ComputeCodeAction(CommonFixContext context, MemberDeclarationSyntax memberDeclaration, ISymbol memberSymbol, ISymbol interfaceMemberSymbol);
    private static MemberDeclarationSyntax AddParameter(MemberDeclarationSyntax memberDeclaration, IParameterSymbol parameterSymbol);
    private static BaseListSyntax GetBaseList(SyntaxNode node);
    private static ParameterSyntax CreateParameter(IParameterSymbol parameterSymbol);
    [CompilerGeneratedAttribute]
internal static SyntaxTokenList <CreateParameter>g__GetModifiers|13_0(<>c__DisplayClass13_0& );
}
public static class Roslynator.CSharp.Refactorings.CallExtensionMethodAsInstanceMethodRefactoring : object {
    public static string Title;
    public static Task`1<Document> RefactorAsync(Document document, InvocationExpressionSyntax invocation, CancellationToken cancellationToken);
    private static InvocationExpressionSyntax GetNewInvocation(InvocationExpressionSyntax invocation);
    [CompilerGeneratedAttribute]
internal static MemberAccessExpressionSyntax <GetNewInvocation>g__CreateNewMemberAccessExpression|2_0(<>c__DisplayClass2_0& );
}
internal static class Roslynator.CSharp.Refactorings.ChangeAccessibilityRefactoring : object {
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<Accessibility> <AvailableAccessibilities>k__BackingField;
    public static ImmutableArray`1<Accessibility> AvailableAccessibilities { get; }
    private static ChangeAccessibilityRefactoring();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<Accessibility> get_AvailableAccessibilities();
    public static ISymbol GetBaseSymbolOrDefault(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static Task`1<Document> RefactorAsync(Document document, MemberDeclarationListSelection selectedMembers, Accessibility newAccessibility, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.ChangeAccessibilityRefactoring/<RefactorAsync>d__5")]
public static Task`1<Solution> RefactorAsync(Solution solution, MemberDeclarationListSelection selectedMembers, Accessibility newAccessibility, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static Task`1<Document> RefactorAsync(Document document, SyntaxNode node, Accessibility newAccessibility, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.ChangeAccessibilityRefactoring/<RefactorAsync>d__7")]
public static Task`1<Solution> RefactorAsync(Solution solution, ISymbol symbol, Accessibility newAccessibility, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.ChangeAccessibilityRefactoring/<FindOverridingMemberDeclarationsAsync>d__8")]
private static Task`1<IEnumerable`1<MemberDeclarationSyntax>> FindOverridingMemberDeclarationsAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Roslynator.CSharp.Refactorings.ChangeAccessibilityRefactoring/<GetMemberDeclarations>d__9")]
private static IEnumerable`1<MemberDeclarationSyntax> GetMemberDeclarations(ISymbol symbol, CancellationToken cancellationToken);
    public static Task`1<Solution> RefactorAsync(Solution solution, ImmutableArray`1<MemberDeclarationSyntax> memberDeclarations, Accessibility newAccessibility, CancellationToken cancellationToken);
    private static SyntaxNode WithAccessibility(MemberDeclarationSyntax node, Accessibility newAccessibility);
    [CompilerGeneratedAttribute]
internal static ISymbol <GetBaseSymbolOrDefault>g__GetDeclaredSymbol|3_0(<>c__DisplayClass3_0& );
}
internal static class Roslynator.CSharp.Refactorings.ConvertBlockBodyToExpressionBodyRefactoring : object {
    public static string Title;
    public static bool CanRefactor(SyntaxNode node);
    public static bool CanRefactor(PropertyDeclarationSyntax propertyDeclaration, Nullable`1<TextSpan> span);
    public static bool CanRefactor(MethodDeclarationSyntax methodDeclaration, Nullable`1<TextSpan> span);
    public static bool CanRefactor(OperatorDeclarationSyntax operatorDeclaration, Nullable`1<TextSpan> span);
    public static bool CanRefactor(ConversionOperatorDeclarationSyntax operatorDeclaration, Nullable`1<TextSpan> span);
    public static bool CanRefactor(LocalFunctionStatementSyntax localFunctionStatement, Nullable`1<TextSpan> span);
    public static bool CanRefactor(IndexerDeclarationSyntax indexerDeclaration, Nullable`1<TextSpan> span);
    public static bool CanRefactor(DestructorDeclarationSyntax destructorDeclaration, Nullable`1<TextSpan> span);
    public static bool CanRefactor(ConstructorDeclarationSyntax constructorDeclaration, Nullable`1<TextSpan> span);
    public static bool CanRefactor(AccessorDeclarationSyntax accessorDeclaration, Nullable`1<TextSpan> span);
    public static Task`1<Document> RefactorAsync(Document document, MemberDeclarationListSelection selectedMembers, CancellationToken cancellationToken);
    public static Task`1<Document> RefactorAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    private static SyntaxNode Refactor(SyntaxNode node, AnalyzerConfigOptions configOptions);
    private static ArrowExpressionClauseSyntax CreateExpressionBody(BlockExpressionAnalysis analysis, SyntaxNode declaration, AnalyzerConfigOptions configOptions);
    private static SyntaxToken CreateSemicolonToken(BlockSyntax block, BlockExpressionAnalysis analysis);
}
internal static class Roslynator.CSharp.Refactorings.ConvertCommentToDocumentationCommentRefactoring : object {
    public static string Title;
    private static Regex _leadingSlashesRegex;
    private static ConvertCommentToDocumentationCommentRefactoring();
    public static Task`1<Document> RefactorAsync(Document document, MemberDeclarationSyntax declaration, TextSpan span, CancellationToken cancellationToken);
    private static Task`1<Document> RefactorAsync(Document document, EnumDeclarationSyntax enumDeclaration, TextSpan span, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.ConvertConditionalExpressionToIfElseRefactoring : object {
    public static string Title;
    public static string RecursiveTitle;
    public static ValueTuple`2<CodeAction, CodeAction> ComputeRefactoring(Document document, ConditionalExpressionSyntax conditionalExpression, CodeActionData& data, CodeActionData& recursiveData, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static CodeAction CreateCodeAction(Document document, ConditionalExpressionSyntax conditionalExpression, StatementSyntax statement, CodeActionData& data, bool recursive);
    private static CodeAction CreateCodeAction(Document document, ConditionalExpressionSyntax conditionalExpression, LocalDeclarationStatementSyntax localDeclaration, SemanticModel semanticModel, CodeActionData& data, bool recursive);
    private static Task`1<Document> RefactorAsync(Document document, ConditionalExpressionSyntax conditionalExpression, StatementSyntax statement, bool recursive, CancellationToken cancellationToken);
    private static StatementSyntax CreateNewStatement(StatementSyntax statement, ExpressionSyntax expression);
    private static Task`1<Document> RefactorAsync(Document document, ConditionalExpressionSyntax conditionalExpression, LocalDeclarationStatementSyntax localDeclaration, SemanticModel semanticModel, bool recursive, CancellationToken cancellationToken);
    private static IfStatementSyntax ConvertConditionalExpressionToIfElse(ConditionalExpressionSyntax conditionalExpression, Func`2<ExpressionSyntax, StatementSyntax> createStatement, bool recursive);
    [CompilerGeneratedAttribute]
internal static bool <ComputeRefactoring>g__IsRecursive|2_0(<>c__DisplayClass2_0& );
}
internal static class Roslynator.CSharp.Refactorings.ConvertExpressionBodyToBlockBodyRefactoring : object {
    public static string Title;
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.ConvertExpressionBodyToBlockBodyRefactoring/<RefactorAsync>d__1")]
public static Task`1<Document> RefactorAsync(Document document, MemberDeclarationListSelection selectedMembers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.ConvertExpressionBodyToBlockBodyRefactoring/<RefactorAsync>d__2")]
public static Task`1<Document> RefactorAsync(Document document, ArrowExpressionClauseSyntax expressionBody, CancellationToken cancellationToken);
    public static SyntaxNode Refactor(ArrowExpressionClauseSyntax expressionBody, AnalyzerConfigOptions configOptions, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static BlockSyntax CreateBlock(SyntaxNode declaration, ExpressionSyntax expression, SyntaxToken semicolon, AnalyzerConfigOptions configOptions, int increaseCount);
    private static BlockSyntax CreateBlock(SyntaxNode declaration, ExpressionSyntax expression, SyntaxToken semicolon, TypeSyntax returnType, AnalyzerConfigOptions configOptions, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static AccessorListSyntax CreateAccessorList(SyntaxNode declaration, ExpressionSyntax expression, SyntaxToken semicolon, AnalyzerConfigOptions configOptions);
    private static BlockSyntax CreateBlockWithExpressionStatement(SyntaxNode declaration, ExpressionSyntax expression, SyntaxToken semicolon, AnalyzerConfigOptions configOptions, int increaseCount);
    private static BlockSyntax CreateBlockWithReturnStatement(SyntaxNode declaration, ExpressionSyntax expression, SyntaxToken semicolon, AnalyzerConfigOptions configOptions, int increaseCount);
    private static BlockSyntax CreateBlock(SyntaxNode declaration, ExpressionSyntax expression, SyntaxToken semicolon, AnalyzerConfigOptions configOptions, Func`3<ExpressionSyntax, SyntaxToken, StatementSyntax> createStatement, int increaseCount);
    [CompilerGeneratedAttribute]
internal static bool <CreateBlock>g__ShouldCreateExpressionStatement|5_0(TypeSyntax returnType, ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.ConvertForEachToForRefactoring : object {
    public static Task`1<Document> RefactorAsync(Document document, ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, bool reverseLoop, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Roslynator.CSharp.Refactorings.ConvertForEachToForRefactoring/<GetVariableReferences>d__1")]
private static IEnumerable`1<IdentifierNameSyntax> GetVariableReferences(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.ConvertHasFlagCallToBitwiseOperationRefactoring : object {
    public static string Title;
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.ConvertHasFlagCallToBitwiseOperationRefactoring/<RefactorAsync>d__1")]
public static Task`1<Document> RefactorAsync(Document document, InvocationExpressionSyntax invocation, CancellationToken cancellationToken);
    public static Task`1<Document> RefactorAsync(Document document, InvocationExpressionSyntax invocation, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.ConvertInterpolatedStringToStringBuilderMethodRefactoring : object {
    public static ValueTuple`3<SyntaxKind, string, ImmutableArray`1<ArgumentSyntax>> Refactor(InterpolatedStringContentSyntax content, bool isVerbatim);
}
internal static class Roslynator.CSharp.Refactorings.ConvertInterpolatedStringToStringLiteralRefactoring : object {
    public static Task`1<Document> RefactorAsync(Document document, InterpolatedStringExpressionSyntax interpolatedString, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.ConvertLambdaBlockBodyToExpressionBodyRefactoring : object {
    public static string Title;
    public static Task`1<Document> RefactorAsync(Document document, LambdaExpressionSyntax lambda, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <RefactorAsync>g__GetExpression|1_0(StatementSyntax statement);
    [CompilerGeneratedAttribute]
internal static LambdaExpressionSyntax <RefactorAsync>g__GetNewLambda|1_1(<>c__DisplayClass1_0& );
}
internal static class Roslynator.CSharp.Refactorings.ConvertMethodGroupToAnonymousFunctionRefactoring : object {
    public static LambdaExpressionSyntax ConvertMethodGroupToAnonymousFunction(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.CopyMemberDeclarationRefactoring : object {
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.CopyMemberDeclarationRefactoring/<RefactorAsync>d__0")]
public static Task`1<Document> RefactorAsync(Document document, MemberDeclarationSyntax member, bool copyAfter, CancellationToken cancellationToken);
    public static Task`1<Document> RefactorAsync(Document document, LocalFunctionStatementSyntax localFunction, bool copyAfter, CancellationToken cancellationToken);
    private static SyntaxToken GetIdentifier(SyntaxNode node);
    private static MemberDeclarationSyntax SetIdentifier(MemberDeclarationSyntax member, SyntaxToken identifier);
}
internal static class Roslynator.CSharp.Refactorings.ExpandCompoundAssignmentRefactoring : object {
    public static Task`1<Document> RefactorAsync(Document document, AssignmentExpressionSyntax assignmentExpression, CancellationToken cancellationToken);
    private static SyntaxKind GetBinaryExpressionKind(AssignmentExpressionSyntax assignmentExpression);
}
internal static class Roslynator.CSharp.Refactorings.ExtractTypeDeclarationToNewDocumentRefactoring : object {
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.ExtractTypeDeclarationToNewDocumentRefactoring/<RefactorAsync>d__0")]
public static Task`1<Solution> RefactorAsync(Document document, MemberDeclarationSyntax memberDeclaration, CancellationToken cancellationToken);
    private static SyntaxNode RemoveNode(MemberDeclarationSyntax member);
    private static SyntaxNode RemoveAllButMember(CompilationUnitSyntax compilationUnit, MemberDeclarationSyntax memberDeclaration);
    private static string GetDocumentName(MemberDeclarationSyntax memberDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static IEnumerable`1<MemberDeclarationSyntax> GetNonNestedTypeDeclarations(CompilationUnitSyntax compilationUnit);
    [IteratorStateMachineAttribute("Roslynator.CSharp.Refactorings.ExtractTypeDeclarationToNewDocumentRefactoring/<GetNonNestedTypeDeclarations>d__5")]
private static IEnumerable`1<MemberDeclarationSyntax> GetNonNestedTypeDeclarations(SyntaxList`1<MemberDeclarationSyntax> members);
    public static string GetTitle(string name);
    private static SyntaxNode RemoveEmptyNamespaces(SyntaxNode node, SyntaxRemoveOptions removeOptions);
}
internal static class Roslynator.CSharp.Refactorings.GenerateBaseConstructorsRefactoring : object {
    public static Task`1<Document> RefactorAsync(Document document, ClassDeclarationSyntax classDeclaration, IMethodSymbol[] constructorSymbols, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static Task`1<Document> RefactorAsync(Document document, RecordDeclarationSyntax recordDeclaration, IMethodSymbol[] constructorSymbols, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ConstructorDeclarationSyntax CreateConstructor(IMethodSymbol methodSymbol, string className, bool isSealedClass, SemanticModel semanticModel, int position);
    private static SyntaxTokenList CreateModifiers(IParameterSymbol parameterSymbol);
}
internal static class Roslynator.CSharp.Refactorings.IfRefactoring : object {
    public static Task`1<Document> RefactorAsync(Document document, IfAnalysis ifAnalysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfElseToAssignmentWithCoalesceExpressionAsync(Document document, IfElseToAssignmentWithCoalesceExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfElseToAssignmentWithConditionalExpressionAsync(Document document, IfElseToAssignmentWithConditionalExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> ToAssignmentWithConditionalExpressionAsync(Document document, ToAssignmentWithConditionalExpressionAnalysis analysis, StatementSyntax newStatement, CancellationToken cancellationToken);
    private static Task`1<Document> IfElseToAssignmentWithExpressionAsync(Document document, IfElseToAssignmentWithExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfElseToAssignmentWithConditionAsync(Document document, IfElseToAssignmentWithConditionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfToReturnWithCoalesceExpressionAsync(Document document, IfToReturnWithCoalesceExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfElseToReturnWithConditionalExpressionAsync(Document document, IfElseToReturnWithConditionalExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfElseToReturnWithBooleanExpressionAsync(Document document, IfToReturnWithBooleanExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfToReturnWithExpressionAsync(Document document, IfToReturnWithExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfElseToYieldReturnWithConditionalExpressionAsync(Document document, IfElseToYieldReturnWithConditionalExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfElseToYieldReturnWithBooleanExpressionAsync(Document document, IfToReturnWithBooleanExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfReturnToReturnWithConditionalExpressionAsync(Document document, IfReturnToReturnWithConditionalExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static Task`1<Document> IfReturnToReturnWithBooleanExpressionAsync(Document document, IfReturnToReturnWithBooleanExpressionAnalysis analysis, CancellationToken cancellationToken);
    private static ConditionalExpressionSyntax CreateConditionalExpression(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse);
    private static ExpressionSyntax GetBooleanExpression(ExpressionSyntax condition, ExpressionSyntax expression1, ExpressionSyntax expression2, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static BinaryExpressionSyntax CreateCoalesceExpression(ExpressionSyntax left, ExpressionSyntax right, ITypeSymbol targetType, int position, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
internal static ITypeSymbol <IfToReturnWithCoalesceExpressionAsync>g__GetTargetType|6_0(<>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static BinaryExpressionSyntax <GetBooleanExpression>g__LogicalAndExpression|15_0(ExpressionSyntax left, ExpressionSyntax right);
    [CompilerGeneratedAttribute]
internal static BinaryExpressionSyntax <GetBooleanExpression>g__LogicalOrExpression|15_1(ExpressionSyntax left, ExpressionSyntax right);
}
internal static class Roslynator.CSharp.Refactorings.InlineAliasExpression.InlineAliasExpressionRefactoring : object {
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.InlineAliasExpression.InlineAliasExpressionRefactoring/<RefactorAsync>d__0")]
public static Task`1<Document> RefactorAsync(Document document, UsingDirectiveSyntax usingDirective, CancellationToken cancellationToken);
    private static SyntaxNode RemoveUsingDirective(SyntaxNode node, int index);
}
internal static class Roslynator.CSharp.Refactorings.IntroduceFieldRefactoring : object {
    internal static Task`1<Document> RefactorAsync(Document document, ExpressionStatementSyntax expressionStatement, ITypeSymbol typeSymbol, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.IntroduceFieldToLockOnRefactoring : object {
    private static string LockObjectName;
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.IntroduceFieldToLockOnRefactoring/<RefactorAsync>d__1")]
public static Task`1<Document> RefactorAsync(Document document, LockStatementSyntax lockStatement, CancellationToken cancellationToken);
    private static FieldDeclarationSyntax CreateFieldDeclaration(string name, bool isStatic);
}
internal static class Roslynator.CSharp.Refactorings.IntroduceLocalVariableRefactoring : object {
    internal static string GetTitle(ExpressionSyntax expression);
    internal static Task`1<Document> RefactorAsync(Document document, ExpressionStatementSyntax expressionStatement, ITypeSymbol typeSymbol, bool addAwait, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.IntroduceLocalVariableRefactoring/<RefactorAsync>d__2")]
public static Task`1<Document> RefactorAsync(Document document, UsingStatementSyntax usingStatement, ExpressionSyntax expression, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.MarkTypeWithDebuggerDisplayAttributeRefactoring : object {
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.MarkTypeWithDebuggerDisplayAttributeRefactoring/<RefactorAsync>d__0")]
public static Task`1<Document> RefactorAsync(Document document, TypeDeclarationSyntax typeDeclaration, CancellationToken cancellationToken);
    public static PropertyDeclarationSyntax DebuggerDisplayPropertyDeclaration(string name, ExpressionSyntax returnExpression);
}
internal static class Roslynator.CSharp.Refactorings.ReduceIfNesting.ReduceIfNestingRefactoring : object {
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.ReduceIfNesting.ReduceIfNestingRefactoring/<RefactorAsync>d__0")]
public static Task`1<Document> RefactorAsync(Document document, IfStatementSyntax ifStatement, SyntaxKind jumpKind, bool recursive, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.RemoveAsyncAwait : object {
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.RemoveAsyncAwait/<RefactorAsync>d__0")]
public static Task`1<Document> RefactorAsync(Document document, SyntaxToken asyncKeyword, CancellationToken cancellationToken);
    private static SyntaxToken GetMissingAsyncKeyword(SyntaxToken asyncKeyword);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <RefactorAsync>g__GetNewNode|0_0(<>c__DisplayClass0_0& );
}
internal static class Roslynator.CSharp.Refactorings.RemoveBracesFromIfElseElseRefactoring : object {
    public static Task`1<Document> RefactorAsync(Document document, IfStatementSyntax ifStatement, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.ReplaceAsExpressionWithExplicitCastRefactoring : object {
    public static string Title;
    public static Task`1<Document> RefactorAsync(Document document, BinaryExpressionSyntax binaryExpression, CancellationToken cancellationToken);
    public static Task`1<Document> RefactorAsync(Document document, BinaryExpressionSyntax binaryExpression, ExpressionSyntax left, TypeSyntax right, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.SplitVariableDeclarationRefactoring : object {
    public static string GetTitle(VariableDeclarationSyntax variableDeclaration);
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.SplitVariableDeclarationRefactoring/<RefactorAsync>d__1")]
public static Task`1<Document> RefactorAsync(Document document, VariableDeclarationSyntax variableDeclaration, CancellationToken cancellationToken);
    private static Task`1<Document> SplitLocalDeclarationAsync(Document document, LocalDeclarationStatementSyntax statement, CancellationToken cancellationToken);
    private static Task`1<Document> SplitFieldDeclarationAsync(Document document, FieldDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static Task`1<Document> SplitEventFieldDeclarationAsync(Document document, EventFieldDeclarationSyntax declaration, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Roslynator.CSharp.Refactorings.SplitVariableDeclarationRefactoring/<SplitLocalDeclaration>d__5")]
private static IEnumerable`1<LocalDeclarationStatementSyntax> SplitLocalDeclaration(LocalDeclarationStatementSyntax statement);
    [IteratorStateMachineAttribute("Roslynator.CSharp.Refactorings.SplitVariableDeclarationRefactoring/<SplitFieldDeclaration>d__6")]
private static IEnumerable`1<FieldDeclarationSyntax> SplitFieldDeclaration(FieldDeclarationSyntax declaration);
    [IteratorStateMachineAttribute("Roslynator.CSharp.Refactorings.SplitVariableDeclarationRefactoring/<SplitEventFieldDeclaration>d__7")]
private static IEnumerable`1<EventFieldDeclarationSyntax> SplitEventFieldDeclaration(EventFieldDeclarationSyntax fieldDeclaration);
    [CompilerGeneratedAttribute]
internal static string <GetTitle>g__GetName|0_0(<>c__DisplayClass0_0& );
}
internal static class Roslynator.CSharp.Refactorings.UseConstantInsteadOfReadOnlyFieldRefactoring : object {
    public static Task`1<Document> RefactorAsync(Document document, FieldDeclarationSyntax fieldDeclaration, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.UseElementAccessInsteadOfEnumerableMethodRefactoring : object {
    public static Task`1<Document> UseElementAccessInsteadOfElementAtAsync(Document document, InvocationExpressionSyntax invocation, CancellationToken cancellationToken);
    public static Task`1<Document> UseElementAccessInsteadOfFirstAsync(Document document, InvocationExpressionSyntax invocation, CancellationToken cancellationToken);
    public static Task`1<Document> UseElementAccessInsteadOfLastAsync(Document document, InvocationExpressionSyntax invocation, string propertyName, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.UseLambdaInsteadOfAnonymousMethodRefactoring : object {
    public static Task`1<Document> RefactorAsync(Document document, AnonymousMethodExpressionSyntax anonymousMethod, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.Refactorings.UseMethodChainingRefactoring : object {
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.UseMethodChainingRefactoring/<RefactorAsync>d__0")]
public static Task`1<Document> RefactorAsync(Document document, UseMethodChainingAnalysis analysis, ExpressionStatementSyntax expressionStatement, CancellationToken cancellationToken);
    private static string GetTextToAppend(ExpressionStatementSyntax expressionStatement);
    private static InvocationExpressionSyntax GetInvocationExpression(ExpressionStatementSyntax expressionStatement);
}
internal static class Roslynator.CSharp.Refactorings.UseReadOnlyFieldInsteadOfConstantRefactoring : object {
    public static string Title;
    [AsyncStateMachineAttribute("Roslynator.CSharp.Refactorings.UseReadOnlyFieldInsteadOfConstantRefactoring/<RefactorAsync>d__1")]
public static Task`1<Document> RefactorAsync(Document document, FieldDeclarationSyntax field, CancellationToken cancellationToken);
}
internal static class Roslynator.CSharp.SyntaxFormatter : object {
    public static Task`1<Document> UnwrapExpressionAsync(Document document, TNode node, CancellationToken cancellationToken);
    public static Task`1<Document> ToSingleLineAsync(Document document, TNode node, TextSpan span, CancellationToken cancellationToken);
    public static Task`1<Document> ToSingleLineAsync(Document document, InitializerExpressionSyntax initializer, bool removeTrailingComma, CancellationToken cancellationToken);
    public static Task`1<Document> WrapConditionalExpressionAsync(Document document, ConditionalExpressionSyntax conditionalExpression, CancellationToken cancellationToken);
    public static ConditionalExpressionSyntax ToMultiLine(ConditionalExpressionSyntax conditionalExpression, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    public static Task`1<Document> WrapParametersAsync(Document document, ParameterListSyntax parameterList, CancellationToken cancellationToken);
    public static ParameterListSyntax WrapParameters(ParameterListSyntax parameterList, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    public static Task`1<Document> WrapParametersAsync(Document document, BracketedParameterListSyntax parameterList, CancellationToken cancellationToken);
    public static BracketedParameterListSyntax WrapParameters(BracketedParameterListSyntax parameterList, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    public static Task`1<Document> ToMultiLineAsync(Document document, InitializerExpressionSyntax initializer, CancellationToken cancellationToken);
    public static InitializerExpressionSyntax ToMultiLine(InitializerExpressionSyntax initializer, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    public static Task`1<Document> WrapArgumentsAsync(Document document, ArgumentListSyntax argumentList, CancellationToken cancellationToken);
    public static ArgumentListSyntax ToMultiLine(ArgumentListSyntax argumentList, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslynator.CSharp.SyntaxFormatter/<WrapCallChainAsync>d__13")]
public static Task`1<Document> WrapCallChainAsync(Document document, ExpressionSyntax expression, CancellationToken cancellationToken);
    public static Task`1<Document> WrapCallChainAsync(Document document, ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static Task`1<Document> WrapArgumentsAsync(Document document, AttributeArgumentListSyntax argumentList, CancellationToken cancellationToken);
    private static AttributeArgumentListSyntax ToMultiLine(AttributeArgumentListSyntax argumentList, AnalyzerConfigOptions configOptions, CancellationToken cancellationToken);
    public static Task`1<Document> WrapBinaryExpressionAsync(Document document, BinaryExpressionSyntax condition, CancellationToken cancellationToken);
    public static Task`1<Document> ToMultiLineAsync(Document document, AccessorDeclarationSyntax accessor, CancellationToken cancellationToken);
    private static AccessorDeclarationSyntax ToMultiLine(AccessorDeclarationSyntax accessor);
    [CompilerGeneratedAttribute]
internal static void <WrapCallChainAsync>g__AddTextChange|14_0(SyntaxToken operatorToken, <>c__DisplayClass14_0& );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
