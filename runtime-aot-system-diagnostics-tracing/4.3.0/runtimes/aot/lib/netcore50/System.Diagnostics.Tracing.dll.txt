internal class __DynamicallyInvokableAttribute : Attribute {
}
internal static class FxResources.System.Diagnostics.Tracing.SR : object {
}
internal static class Interop : object {
}
[FlagsAttribute]
public enum Microsoft.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static BindingFlags Public;
    public static BindingFlags NonPublic;
}
[ExtensionAttribute]
internal static class Microsoft.Reflection.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static MethodInfo[] GetMethods(Type type, BindingFlags flags);
    [ExtensionAttribute]
public static FieldInfo[] GetFields(Type type, BindingFlags flags);
    [ExtensionAttribute]
public static Type GetNestedType(Type type, string nestedTypeName);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static object GetRawConstantValue(FieldInfo fi);
    [ExtensionAttribute]
public static bool ReflectionOnly(Assembly assm);
}
public enum Microsoft.Reflection.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
internal class System.Diagnostics.Tracing.ActivityTracker : object {
    private AsyncLocal`1<ActivityInfo> m_current;
    private static ActivityTracker s_activityTrackerInstance;
    private static long m_nextId;
    private static ushort MAX_ACTIVITY_DEPTH;
    public static ActivityTracker Instance { get; }
    private Guid CurrentActivityId { get; }
    private static ActivityTracker();
    public void OnStart(string providerName, string activityName, int task, Guid& activityId, Guid& relatedActivityId, EventActivityOptions options);
    public void OnStop(string providerName, string activityName, int task, Guid& activityId);
    [SecuritySafeCriticalAttribute]
public void Enable();
    public static ActivityTracker get_Instance();
    private Guid get_CurrentActivityId();
    private ActivityInfo FindActiveActivity(string name, ActivityInfo startLocation);
    private string NormalizeActivityName(string providerName, string activityName, int task);
    private void ActivityChanging(AsyncLocalValueChangedArgs`1<ActivityInfo> args);
}
internal class System.Diagnostics.Tracing.ArrayTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public ArrayTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ConcurrentSet`2 : ValueType {
    private ItemType[] items;
    public ItemType TryGet(KeyType key);
    public ItemType GetOrAdd(ItemType newItem);
}
internal abstract class System.Diagnostics.Tracing.ConcurrentSetItem`2 : object {
    public abstract virtual int Compare(ItemType other);
    public abstract virtual int Compare(KeyType key);
}
internal enum System.Diagnostics.Tracing.ControllerCommand : Enum {
    public int value__;
    public static ControllerCommand Update;
    public static ControllerCommand SendManifest;
    public static ControllerCommand Enable;
    public static ControllerCommand Disable;
}
[SecurityCriticalAttribute]
internal class System.Diagnostics.Tracing.DataCollector : ValueType {
    [ThreadStaticAttribute]
internal static DataCollector ThreadInstance;
    private Byte* scratchEnd;
    private EventData* datasEnd;
    private GCHandle* pinsEnd;
    private EventData* datasStart;
    private Byte* scratch;
    private EventData* datas;
    private GCHandle* pins;
    private Byte[] buffer;
    private int bufferPos;
    private int bufferNesting;
    private bool writingScalars;
    internal void Enable(Byte* scratch, int scratchSize, EventData* datas, int dataCount, GCHandle* pins, int pinCount);
    internal void Disable();
    internal EventData* Finish();
    internal void AddScalar(Void* value, int size);
    internal void AddBinary(string value, int size);
    internal void AddBinary(Array value, int size);
    internal void AddArray(Array value, int length, int itemSize);
    internal int BeginBufferedArray();
    internal void EndBufferedArray(int bookmark, int count);
    internal void BeginBuffered();
    internal void EndBuffered();
    private void EnsureBuffer();
    private void EnsureBuffer(int additionalSize);
    private void GrowBuffer(int required);
    private void PinArray(object value, int size);
    private void ScalarsBegin();
    private void ScalarsEnd();
}
internal class System.Diagnostics.Tracing.DateTimeOffsetTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.DateTimeTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.DecimalTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.EmptyStruct : ValueType {
}
internal class System.Diagnostics.Tracing.EnumerableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public EnumerableTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
[FlagsAttribute]
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventActivityOptions : Enum {
    public int value__;
    [__DynamicallyInvokableAttribute]
public static EventActivityOptions None;
    [__DynamicallyInvokableAttribute]
public static EventActivityOptions Disable;
    [__DynamicallyInvokableAttribute]
public static EventActivityOptions Recursive;
    [__DynamicallyInvokableAttribute]
public static EventActivityOptions Detachable;
}
[AttributeUsageAttribute("64")]
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.EventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private EventActivityOptions <ActivityOptions>k__BackingField;
    private EventOpcode m_opcode;
    private bool m_opcodeSet;
    [__DynamicallyInvokableAttribute]
public int EventId { get; private set; }
    [__DynamicallyInvokableAttribute]
public EventLevel Level { get; public set; }
    [__DynamicallyInvokableAttribute]
public EventKeywords Keywords { get; public set; }
    [__DynamicallyInvokableAttribute]
public EventOpcode Opcode { get; public set; }
    public bool IsOpcodeSet { get; }
    [__DynamicallyInvokableAttribute]
public EventTask Task { get; public set; }
    [__DynamicallyInvokableAttribute]
public byte Version { get; public set; }
    [__DynamicallyInvokableAttribute]
public string Message { get; public set; }
    [__DynamicallyInvokableAttribute]
public EventTags Tags { get; public set; }
    [__DynamicallyInvokableAttribute]
public EventActivityOptions ActivityOptions { get; public set; }
    [__DynamicallyInvokableAttribute]
public EventAttribute(int eventId);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Level(EventLevel value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Keywords(EventKeywords value);
    [__DynamicallyInvokableAttribute]
public EventOpcode get_Opcode();
    [__DynamicallyInvokableAttribute]
public void set_Opcode(EventOpcode value);
    public bool get_IsOpcodeSet();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public EventTask get_Task();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Task(EventTask value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Version(byte value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public EventTags get_Tags();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Tags(EventTags value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public EventActivityOptions get_ActivityOptions();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_ActivityOptions(EventActivityOptions value);
}
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventChannel : Enum {
    public byte value__;
    [__DynamicallyInvokableAttribute]
public static EventChannel None;
    [__DynamicallyInvokableAttribute]
public static EventChannel Admin;
    [__DynamicallyInvokableAttribute]
public static EventChannel Operational;
    [__DynamicallyInvokableAttribute]
public static EventChannel Analytic;
    [__DynamicallyInvokableAttribute]
public static EventChannel Debug;
}
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    [__DynamicallyInvokableAttribute]
public static EventCommand Update;
    [__DynamicallyInvokableAttribute]
public static EventCommand SendManifest;
    [__DynamicallyInvokableAttribute]
public static EventCommand Enable;
    [__DynamicallyInvokableAttribute]
public static EventCommand Disable;
}
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Arguments>k__BackingField;
    internal EventSource eventSource;
    internal EventDispatcher dispatcher;
    internal EventListener listener;
    internal int perEventSourceSessionId;
    internal int etwSessionId;
    internal bool enable;
    internal EventLevel level;
    internal EventKeywords matchAnyKeyword;
    internal EventCommandEventArgs nextCommand;
    [__DynamicallyInvokableAttribute]
public EventCommand Command { get; internal set; }
    [__DynamicallyInvokableAttribute]
public IDictionary`2<string, string> Arguments { get; internal set; }
    internal EventCommandEventArgs(EventCommand command, IDictionary`2<string, string> arguments, EventSource eventSource, EventListener listener, int perEventSourceSessionId, int etwSessionId, bool enable, EventLevel level, EventKeywords matchAnyKeyword);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public EventCommand get_Command();
    [CompilerGeneratedAttribute]
internal void set_Command(EventCommand value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public IDictionary`2<string, string> get_Arguments();
    [CompilerGeneratedAttribute]
internal void set_Arguments(IDictionary`2<string, string> value);
    [__DynamicallyInvokableAttribute]
public bool EnableEvent(int eventId);
    [__DynamicallyInvokableAttribute]
public bool DisableEvent(int eventId);
}
[AttributeUsageAttribute("12")]
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.EventDataAttribute : Attribute {
    private EventLevel level;
    private EventOpcode opcode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    [__DynamicallyInvokableAttribute]
public string Name { get; public set; }
    internal EventLevel Level { get; internal set; }
    internal EventOpcode Opcode { get; internal set; }
    internal EventKeywords Keywords { get; internal set; }
    internal EventTags Tags { get; internal set; }
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Name(string value);
    internal EventLevel get_Level();
    internal void set_Level(EventLevel value);
    internal EventOpcode get_Opcode();
    internal void set_Opcode(EventOpcode value);
    [CompilerGeneratedAttribute]
internal EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
internal void set_Keywords(EventKeywords value);
    [CompilerGeneratedAttribute]
internal EventTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventTags value);
}
public class System.Diagnostics.Tracing.EventDescriptor : ValueType {
    private int m_traceloggingId;
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public EventDescriptor(int traceloggingId, byte level, byte opcode, long keywords);
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EventDescriptor other);
    public static bool op_Equality(EventDescriptor event1, EventDescriptor event2);
    public static bool op_Inequality(EventDescriptor event1, EventDescriptor event2);
}
internal class System.Diagnostics.Tracing.EventDispatcher : object {
    internal EventListener m_Listener;
    internal Boolean[] m_EventEnabled;
    internal EventDispatcher m_Next;
    internal EventDispatcher(EventDispatcher next, Boolean[] eventEnabled, EventListener listener);
}
[AttributeUsageAttribute("128")]
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.EventFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventFieldFormat <Format>k__BackingField;
    [__DynamicallyInvokableAttribute]
public EventFieldTags Tags { get; public set; }
    internal string Name { get; internal set; }
    [__DynamicallyInvokableAttribute]
public EventFieldFormat Format { get; public set; }
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Tags(EventFieldTags value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public EventFieldFormat get_Format();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Format(EventFieldFormat value);
}
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventFieldFormat : Enum {
    public int value__;
    [__DynamicallyInvokableAttribute]
public static EventFieldFormat Default;
    [__DynamicallyInvokableAttribute]
public static EventFieldFormat String;
    [__DynamicallyInvokableAttribute]
public static EventFieldFormat Boolean;
    [__DynamicallyInvokableAttribute]
public static EventFieldFormat Hexadecimal;
    [__DynamicallyInvokableAttribute]
public static EventFieldFormat Xml;
    [__DynamicallyInvokableAttribute]
public static EventFieldFormat Json;
    [__DynamicallyInvokableAttribute]
public static EventFieldFormat HResult;
}
[FlagsAttribute]
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventFieldTags : Enum {
    public int value__;
    [__DynamicallyInvokableAttribute]
public static EventFieldTags None;
}
[AttributeUsageAttribute("128")]
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.EventIgnoreAttribute : Attribute {
}
[FlagsAttribute]
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    [__DynamicallyInvokableAttribute]
public static EventKeywords None;
    [__DynamicallyInvokableAttribute]
public static EventKeywords All;
    [__DynamicallyInvokableAttribute]
public static EventKeywords WdiContext;
    [__DynamicallyInvokableAttribute]
public static EventKeywords WdiDiagnostic;
    [__DynamicallyInvokableAttribute]
public static EventKeywords Sqm;
    [__DynamicallyInvokableAttribute]
public static EventKeywords AuditFailure;
    [__DynamicallyInvokableAttribute]
public static EventKeywords AuditSuccess;
    [__DynamicallyInvokableAttribute]
public static EventKeywords CorrelationHint;
    [__DynamicallyInvokableAttribute]
public static EventKeywords EventLogClassic;
}
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    [__DynamicallyInvokableAttribute]
public static EventLevel LogAlways;
    [__DynamicallyInvokableAttribute]
public static EventLevel Critical;
    [__DynamicallyInvokableAttribute]
public static EventLevel Error;
    [__DynamicallyInvokableAttribute]
public static EventLevel Warning;
    [__DynamicallyInvokableAttribute]
public static EventLevel Informational;
    [__DynamicallyInvokableAttribute]
public static EventLevel Verbose;
}
[__DynamicallyInvokableAttribute]
public abstract class System.Diagnostics.Tracing.EventListener : object {
    internal EventListener modreq(System.Runtime.CompilerServices.IsVolatile) m_Next;
    internal static EventListener s_Listeners;
    internal static List`1<WeakReference> s_EventSources;
    private static bool s_CreatingListener;
    private static bool s_EventSourceShutdownRegistered;
    internal static object EventListenersLock { get; }
    private static EventListener();
    [__DynamicallyInvokableAttribute]
public virtual void Dispose();
    [__DynamicallyInvokableAttribute]
public void EnableEvents(EventSource eventSource, EventLevel level);
    [__DynamicallyInvokableAttribute]
public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    [__DynamicallyInvokableAttribute]
public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    [__DynamicallyInvokableAttribute]
public void DisableEvents(EventSource eventSource);
    [__DynamicallyInvokableAttribute]
protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    [__DynamicallyInvokableAttribute]
protected internal abstract virtual void OnEventWritten(EventWrittenEventArgs eventData);
    [__DynamicallyInvokableAttribute]
protected static int EventSourceIndex(EventSource eventSource);
    internal static void AddEventSource(EventSource newEventSource);
    private static void DisposeOnShutdown(object sender, EventArgs e);
    private static void RemoveReferencesToListenerInEventSources(EventListener listenerToRemove);
    [ConditionalAttribute("DEBUG")]
internal static void Validate();
    internal static object get_EventListenersLock();
}
[FlagsAttribute]
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventManifestOptions : Enum {
    public int value__;
    [__DynamicallyInvokableAttribute]
public static EventManifestOptions None;
    [__DynamicallyInvokableAttribute]
public static EventManifestOptions Strict;
    [__DynamicallyInvokableAttribute]
public static EventManifestOptions AllCultures;
    [__DynamicallyInvokableAttribute]
public static EventManifestOptions OnlyIfNeededForRegistration;
    [__DynamicallyInvokableAttribute]
public static EventManifestOptions AllowEventSourceOverride;
}
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    [__DynamicallyInvokableAttribute]
public static EventOpcode Info;
    [__DynamicallyInvokableAttribute]
public static EventOpcode Start;
    [__DynamicallyInvokableAttribute]
public static EventOpcode Stop;
    [__DynamicallyInvokableAttribute]
public static EventOpcode DataCollectionStart;
    [__DynamicallyInvokableAttribute]
public static EventOpcode DataCollectionStop;
    [__DynamicallyInvokableAttribute]
public static EventOpcode Extension;
    [__DynamicallyInvokableAttribute]
public static EventOpcode Reply;
    [__DynamicallyInvokableAttribute]
public static EventOpcode Resume;
    [__DynamicallyInvokableAttribute]
public static EventOpcode Suspend;
    [__DynamicallyInvokableAttribute]
public static EventOpcode Send;
    [__DynamicallyInvokableAttribute]
public static EventOpcode Receive;
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.EventPayload : object {
    private List`1<string> m_names;
    private List`1<object> m_values;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal EventPayload(List`1<string> payloadNames, List`1<object> payloadValues);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> payloadEntry);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> entry);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] payloadEntries, int count);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> entry);
    public sealed virtual bool TryGetValue(string key, Object& value);
}
internal class System.Diagnostics.Tracing.EventProvider : object {
    private static bool m_setInformationMissing;
    [SecurityCriticalAttribute]
private EtwEnableCallback m_etwCallback;
    private ulong m_regHandle;
    private byte m_level;
    private ulong m_anyKeywordMask;
    private ulong m_allKeywordMask;
    private bool m_enabled;
    private Guid m_providerId;
    internal bool m_disposed;
    [ThreadStaticAttribute]
private static WriteEventErrorCode s_returnCode;
    private static int s_basicTypeAllocationBufferSize;
    private static int s_etwMaxNumberArguments;
    private static int s_etwAPIMaxRefObjCount;
    private static int s_maxEventDataDescriptors;
    private static int s_traceEventMaximumSize;
    private static int s_traceEventMaximumStringSize;
    private static Int32[] nibblebits;
    protected EventLevel Level { get; protected set; }
    protected EventKeywords MatchAnyKeyword { get; protected set; }
    protected EventKeywords MatchAllKeyword { get; protected set; }
    private static EventProvider();
    [SecurityCriticalAttribute]
internal void Register(Guid providerGuid);
    [SecurityCriticalAttribute]
internal int SetInformation(EVENT_INFO_CLASS eventInfoClass, IntPtr data, UInt32 dataSize);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public virtual void Close();
    protected virtual override void Finalize();
    [SecurityCriticalAttribute]
private void Deregister();
    [SecurityCriticalAttribute]
private void EtwEnableCallBack(Guid& sourceId, int controlCode, byte setLevel, ulong anyKeyword, ulong allKeyword, EVENT_FILTER_DESCRIPTOR* filterData, IntPtr callbackContext);
    protected virtual void OnControllerCommand(ControllerCommand command, IDictionary`2<string, string> arguments, int sessionId, int etwSessionId);
    protected EventLevel get_Level();
    protected void set_Level(EventLevel value);
    protected EventKeywords get_MatchAnyKeyword();
    protected void set_MatchAnyKeyword(EventKeywords value);
    protected EventKeywords get_MatchAllKeyword();
    protected void set_MatchAllKeyword(EventKeywords value);
    private static int FindNull(Byte[] buffer, int idx);
    [SecurityCriticalAttribute]
private bool GetDataFromController(int etwSessionId, EVENT_FILTER_DESCRIPTOR* filterData, ControllerCommand& command, Byte[]& data, Int32& dataStart);
    public bool IsEnabled();
    public bool IsEnabled(byte level, ulong keywords);
    public static WriteEventErrorCode GetLastWriteEventError();
    private static void SetLastError(int error);
    [SecurityCriticalAttribute]
private static object EncodeObject(Object& data, EventData*& dataDescriptor, Byte*& dataBuffer, UInt32& totalEventSize);
    [SecurityCriticalAttribute]
internal bool WriteEvent(EventDescriptor& eventDescriptor, Guid* activityID, Guid* childActivityID, Object[] eventPayload);
    [SecurityCriticalAttribute]
protected internal bool WriteEvent(EventDescriptor& eventDescriptor, Guid* activityID, Guid* childActivityID, int dataCount, IntPtr data);
    [SecurityCriticalAttribute]
internal bool WriteEventRaw(EventDescriptor& eventDescriptor, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    [SecurityCriticalAttribute]
private UInt32 EventRegister(Guid& providerId, EtwEnableCallback enableCallback);
    [SecurityCriticalAttribute]
private UInt32 EventUnregister();
    private static int bitcount(UInt32 n);
    private static int bitindex(UInt32 n);
}
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.EventSource : object {
    private string m_name;
    internal int m_id;
    private Guid m_guid;
    internal EventMetadata[] modreq(System.Runtime.CompilerServices.IsVolatile) m_eventData;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) m_rawManifest;
    private EventSourceSettings m_config;
    private bool m_eventSourceEnabled;
    internal EventLevel m_level;
    internal EventKeywords m_matchAnyKeyword;
    internal EventDispatcher modreq(System.Runtime.CompilerServices.IsVolatile) m_Dispatchers;
    private OverideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_provider;
    private bool m_completelyInited;
    private Exception m_constructionException;
    private byte m_outOfBandMessageCount;
    private EventCommandEventArgs m_deferredCommands;
    private String[] m_traits;
    internal static UInt32 s_currentPid;
    [ThreadStaticAttribute]
private static byte m_EventSourceExceptionRecurenceCount;
    [ThreadStaticAttribute]
private static bool m_EventSourcePreventRecursion;
    private ActivityTracker m_activityTracker;
    internal static string s_ActivityStartSuffix;
    internal static string s_ActivityStopSuffix;
    private static Byte[] namespaceBytes;
    private Byte[] providerMetadata;
    [__DynamicallyInvokableAttribute]
public string Name { get; }
    [__DynamicallyInvokableAttribute]
public Guid Guid { get; }
    [__DynamicallyInvokableAttribute]
public EventSourceSettings Settings { get; }
    [__DynamicallyInvokableAttribute]
public static Guid CurrentThreadActivityId { get; }
    internal static Guid InternalCurrentThreadActivityId { get; }
    internal static Guid FallbackActivityId { get; }
    [__DynamicallyInvokableAttribute]
public Exception ConstructionException { get; }
    private bool IsDisposed { get; }
    private bool ThrowOnEventWriteErrors { get; private set; }
    private bool SelfDescribingEvents { get; private set; }
    [__DynamicallyInvokableAttribute]
protected EventSource(bool throwOnEventWriteErrors);
    [__DynamicallyInvokableAttribute]
protected EventSource(EventSourceSettings settings);
    [__DynamicallyInvokableAttribute]
protected EventSource(EventSourceSettings settings, String[] traits);
    internal EventSource(Guid eventSourceGuid, string eventSourceName);
    internal EventSource(Guid eventSourceGuid, string eventSourceName, EventSourceSettings settings, String[] traits);
    [__DynamicallyInvokableAttribute]
public EventSource(string eventSourceName);
    [__DynamicallyInvokableAttribute]
public EventSource(string eventSourceName, EventSourceSettings config);
    [__DynamicallyInvokableAttribute]
public EventSource(string eventSourceName, EventSourceSettings config, String[] traits);
    private static EventSource();
    [__DynamicallyInvokableAttribute]
public string get_Name();
    [__DynamicallyInvokableAttribute]
public Guid get_Guid();
    [__DynamicallyInvokableAttribute]
public bool IsEnabled();
    [__DynamicallyInvokableAttribute]
public bool IsEnabled(EventLevel level, EventKeywords keywords);
    [__DynamicallyInvokableAttribute]
public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
    [__DynamicallyInvokableAttribute]
public EventSourceSettings get_Settings();
    [__DynamicallyInvokableAttribute]
public static Guid GetGuid(Type eventSourceType);
    [__DynamicallyInvokableAttribute]
public static string GetName(Type eventSourceType);
    [__DynamicallyInvokableAttribute]
public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    [__DynamicallyInvokableAttribute]
public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
    [__DynamicallyInvokableAttribute]
public static IEnumerable`1<EventSource> GetSources();
    [__DynamicallyInvokableAttribute]
public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public static void SetCurrentThreadActivityId(Guid activityId);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public static void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue);
    [SecurityCriticalAttribute]
[__DynamicallyInvokableAttribute]
public static Guid get_CurrentThreadActivityId();
    [SecurityCriticalAttribute]
internal static Guid get_InternalCurrentThreadActivityId();
    [SecurityCriticalAttribute]
internal static Guid get_FallbackActivityId();
    [__DynamicallyInvokableAttribute]
public Exception get_ConstructionException();
    [__DynamicallyInvokableAttribute]
public string GetTrait(string key);
    [__DynamicallyInvokableAttribute]
public virtual string ToString();
    protected virtual void GetMetadata(Guid& eventSourceGuid, String& eventSourceName, EventMetadata[]& eventData, Byte[]& manifestBytes);
    [__DynamicallyInvokableAttribute]
protected virtual void OnEventCommand(EventCommandEventArgs command);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, int arg1);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, int arg1, int arg2);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, long arg1);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, long arg1, long arg2);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, string arg1);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, string arg1, string arg2);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, string arg1, int arg2);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, string arg1, long arg2);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, long arg1, string arg2);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, int arg1, string arg2);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, Byte[] arg1);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, long arg1, Byte[] arg2);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEvent(int eventId, Object[] args);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args);
    [__DynamicallyInvokableAttribute]
public sealed virtual void Dispose();
    [__DynamicallyInvokableAttribute]
protected virtual void Dispose(bool disposing);
    [__DynamicallyInvokableAttribute]
protected virtual override void Finalize();
    internal static int EventWriteTransferWrapper(ulong registrationHandle, EventDescriptor& eventDescriptor, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    [SecurityCriticalAttribute]
private void WriteEventRaw(EventDescriptor& eventDescriptor, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    [SecuritySafeCriticalAttribute]
private void Initialize(Guid eventSourceGuid, string eventSourceName, String[] traits);
    private static string GetName(Type eventSourceType, EventManifestOptions flags);
    private static Guid GenerateGuidFromName(string name);
    private Type EventTypeToType(EventParameterType type);
    [SecurityCriticalAttribute]
private object DecodeObject(int eventId, int parameterId, EventData*& data);
    private EventDispatcher GetDispatcher(EventListener listener);
    [SecurityCriticalAttribute]
private void WriteEventVarargs(int eventId, Guid* childActivityID, Object[] args);
    [SecurityCriticalAttribute]
private Object[] SerializeEventArgs(int eventId, Object[] args);
    [SecurityCriticalAttribute]
private void WriteToAllListeners(int eventId, Guid* childActivityID, int eventDataCount, EventData* data);
    [SecurityCriticalAttribute]
private void WriteToAllListeners(int eventId, Guid* childActivityID, Object[] args);
    [SecurityCriticalAttribute]
private void DisptachToAllListeners(int eventId, Guid* childActivityID, EventWrittenEventArgs eventCallbackArgs);
    [SecuritySafeCriticalAttribute]
private void WriteEventString(EventLevel level, long keywords, string msgString);
    private void WriteStringToAllListeners(string eventName, string msg);
    private bool IsEnabledByDefault(int eventNum, bool enable, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword);
    private bool IsEnabledCommon(bool enabled, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword, EventLevel eventLevel, EventKeywords eventKeywords, EventChannel eventChannel);
    private void ThrowEventSourceException(Exception innerEx);
    private void ValidateEventOpcodeForTransfer(EventMetadata& eventData);
    internal static EventOpcode GetOpcodeWithDefault(EventOpcode opcode, string eventName);
    internal void SendCommand(EventListener listener, int perEventSourceSessionId, int etwSessionId, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> commandArguments);
    internal void DoCommand(EventCommandEventArgs commandArgs);
    internal bool EnableEventForDispatcher(EventDispatcher dispatcher, int eventId, bool value);
    private bool AnyEventEnabled();
    private bool get_IsDisposed();
    [SecuritySafeCriticalAttribute]
private void EnsureDescriptorsInitialized();
    [SecuritySafeCriticalAttribute]
private bool SendManifest(Byte[] rawManifest);
    internal static Attribute GetCustomAttributeHelper(Type type, Type attributeType, EventManifestOptions flags);
    internal static Attribute GetCustomAttributeHelper(MemberInfo member, Type attributeType, EventManifestOptions flags);
    private static bool AttributeTypeNamesMatch(Type attributeType, Type reflectedAttributeType);
    private static Type GetEventSourceBaseType(Type eventSourceType, bool allowEventSourceOverride, bool reflectionOnly);
    private static Byte[] CreateManifestAndDescriptors(Type eventSourceType, string eventSourceDllName, EventSource source, EventManifestOptions flags);
    private static void RemoveFirstArgIfRelatedActivityId(ParameterInfo[]& args);
    private static void AddProviderEnumKind(ManifestBuilder manifest, FieldInfo staticField, string providerEnumKind);
    private static void AddEventDescriptor(EventMetadata[]& eventData, string eventName, EventAttribute eventAttribute, ParameterInfo[] eventParameters);
    private static void TrimEventDescriptors(EventMetadata[]& eventData);
    internal void AddListener(EventListener listener);
    private static void DebugCheckEvent(Dictionary`2& eventsByName, EventMetadata[] eventData, MethodInfo method, EventAttribute eventAttribute, ManifestBuilder manifest);
    [SecuritySafeCriticalAttribute]
private static int GetHelperCallFirstArg(MethodInfo method);
    internal void ReportOutOfBandMessage(string msg, bool flush);
    private EventSourceSettings ValidateSettings(EventSourceSettings settings);
    private bool get_ThrowOnEventWriteErrors();
    private void set_ThrowOnEventWriteErrors(bool value);
    private bool get_SelfDescribingEvents();
    private void set_SelfDescribingEvents(bool value);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public void Write(string eventName);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public void Write(string eventName, EventSourceOptions options);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public void Write(string eventName, T data);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public void Write(string eventName, EventSourceOptions options, T data);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public void Write(string eventName, EventSourceOptions& options, T& data);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data);
    [SecuritySafeCriticalAttribute]
private void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    [SecuritySafeCriticalAttribute]
private void WriteMultiMergeInner(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    [SecuritySafeCriticalAttribute]
internal void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, EventData* data);
    [SecuritySafeCriticalAttribute]
private void WriteImpl(string eventName, EventSourceOptions& options, object data, Guid* pActivityId, Guid* pRelatedActivityId, TraceLoggingEventTypes eventTypes);
    [SecurityCriticalAttribute]
private void WriteToAllListeners(string eventName, EventDescriptor& eventDescriptor, EventTags tags, Guid* pActivityId, EventPayload payload);
    [SecurityCriticalAttribute]
[NonEventAttribute]
private void WriteCleanup(GCHandle* pPins, int cPins);
    private void InitializeProviderMetadata();
    private static int AddValueToMetaData(List`1<byte> metaData, string value);
    private static int HexDigit(char c);
    private NameInfo UpdateDescriptor(string name, TraceLoggingEventTypes eventInfo, EventSourceOptions& options, EventDescriptor& descriptor);
}
internal class System.Diagnostics.Tracing.EventSourceActivity : object {
    private EventSource eventSource;
    private EventSourceOptions startStopOptions;
    internal Guid activityId;
    private State state;
    private string eventName;
    internal static Guid s_empty;
    public EventSource EventSource { get; }
    public Guid Id { get; }
    private bool StartEventWasFired { get; }
    public EventSourceActivity(EventSource eventSource);
    public static EventSourceActivity op_Implicit(EventSource eventSource);
    public EventSource get_EventSource();
    public Guid get_Id();
    public EventSourceActivity Start(string eventName, EventSourceOptions options, T data);
    public EventSourceActivity Start(string eventName);
    public EventSourceActivity Start(string eventName, EventSourceOptions options);
    public EventSourceActivity Start(string eventName, T data);
    public void Stop(T data);
    public void Stop(string eventName);
    public void Stop(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options, T data);
    public void Write(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options);
    public void Write(string eventName);
    public void Write(EventSource source, string eventName, EventSourceOptions options, T data);
    public sealed virtual void Dispose();
    private EventSourceActivity Start(string eventName, EventSourceOptions& options, T& data);
    private void Write(EventSource eventSource, string eventName, EventSourceOptions& options, T& data);
    private void Stop(string eventName, T& data);
    private bool get_StartEventWasFired();
}
[AttributeUsageAttribute("4")]
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizationResources>k__BackingField;
    [__DynamicallyInvokableAttribute]
public string Name { get; public set; }
    [__DynamicallyInvokableAttribute]
public string Guid { get; public set; }
    [__DynamicallyInvokableAttribute]
public string LocalizationResources { get; public set; }
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public string get_LocalizationResources();
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public void set_LocalizationResources(string value);
}
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.EventSourceException : Exception {
    [__DynamicallyInvokableAttribute]
public EventSourceException(string message);
    [__DynamicallyInvokableAttribute]
public EventSourceException(string message, Exception innerException);
    internal EventSourceException(Exception innerException);
}
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.EventSourceOptions : ValueType {
    internal EventKeywords keywords;
    internal EventTags tags;
    internal EventActivityOptions activityOptions;
    internal byte level;
    internal byte opcode;
    internal byte valuesSet;
    internal static byte keywordsSet;
    internal static byte tagsSet;
    internal static byte levelSet;
    internal static byte opcodeSet;
    internal static byte activityOptionsSet;
    [__DynamicallyInvokableAttribute]
public EventLevel Level { get; public set; }
    [__DynamicallyInvokableAttribute]
public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    [__DynamicallyInvokableAttribute]
public EventKeywords Keywords { get; public set; }
    [__DynamicallyInvokableAttribute]
public EventTags Tags { get; public set; }
    [__DynamicallyInvokableAttribute]
public EventActivityOptions ActivityOptions { get; public set; }
    [__DynamicallyInvokableAttribute]
public EventLevel get_Level();
    [__DynamicallyInvokableAttribute]
public void set_Level(EventLevel value);
    [__DynamicallyInvokableAttribute]
public EventOpcode get_Opcode();
    [__DynamicallyInvokableAttribute]
public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    [__DynamicallyInvokableAttribute]
public EventKeywords get_Keywords();
    [__DynamicallyInvokableAttribute]
public void set_Keywords(EventKeywords value);
    [__DynamicallyInvokableAttribute]
public EventTags get_Tags();
    [__DynamicallyInvokableAttribute]
public void set_Tags(EventTags value);
    [__DynamicallyInvokableAttribute]
public EventActivityOptions get_ActivityOptions();
    [__DynamicallyInvokableAttribute]
public void set_ActivityOptions(EventActivityOptions value);
}
[FlagsAttribute]
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventSourceSettings : Enum {
    public int value__;
    [__DynamicallyInvokableAttribute]
public static EventSourceSettings Default;
    [__DynamicallyInvokableAttribute]
public static EventSourceSettings ThrowOnEventWriteErrors;
    [__DynamicallyInvokableAttribute]
public static EventSourceSettings EtwManifestEventFormat;
    [__DynamicallyInvokableAttribute]
public static EventSourceSettings EtwSelfDescribingEventFormat;
}
[FlagsAttribute]
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventTags : Enum {
    public int value__;
    [__DynamicallyInvokableAttribute]
public static EventTags None;
}
[__DynamicallyInvokableAttribute]
public enum System.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    [__DynamicallyInvokableAttribute]
public static EventTask None;
}
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RelatedActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<object> <Payload>k__BackingField;
    private string m_message;
    private string m_eventName;
    private EventSource m_eventSource;
    private ReadOnlyCollection`1<string> m_payloadNames;
    internal EventTags m_tags;
    internal EventOpcode m_opcode;
    internal EventKeywords m_keywords;
    [__DynamicallyInvokableAttribute]
public string EventName { get; internal set; }
    [__DynamicallyInvokableAttribute]
public int EventId { get; internal set; }
    [__DynamicallyInvokableAttribute]
public Guid ActivityId { get; }
    [__DynamicallyInvokableAttribute]
public Guid RelatedActivityId { get; internal set; }
    [__DynamicallyInvokableAttribute]
public ReadOnlyCollection`1<object> Payload { get; internal set; }
    [__DynamicallyInvokableAttribute]
public ReadOnlyCollection`1<string> PayloadNames { get; internal set; }
    [__DynamicallyInvokableAttribute]
public EventSource EventSource { get; }
    [__DynamicallyInvokableAttribute]
public EventKeywords Keywords { get; }
    [__DynamicallyInvokableAttribute]
public EventOpcode Opcode { get; }
    [__DynamicallyInvokableAttribute]
public EventTask Task { get; }
    [__DynamicallyInvokableAttribute]
public EventTags Tags { get; }
    [__DynamicallyInvokableAttribute]
public string Message { get; internal set; }
    [__DynamicallyInvokableAttribute]
public byte Version { get; }
    [__DynamicallyInvokableAttribute]
public EventLevel Level { get; }
    internal EventWrittenEventArgs(EventSource eventSource);
    [__DynamicallyInvokableAttribute]
public string get_EventName();
    internal void set_EventName(string value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
internal void set_EventId(int value);
    [SecurityCriticalAttribute]
[__DynamicallyInvokableAttribute]
public Guid get_ActivityId();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
[__DynamicallyInvokableAttribute]
public Guid get_RelatedActivityId();
    [CompilerGeneratedAttribute]
internal void set_RelatedActivityId(Guid value);
    [CompilerGeneratedAttribute]
[__DynamicallyInvokableAttribute]
public ReadOnlyCollection`1<object> get_Payload();
    [CompilerGeneratedAttribute]
internal void set_Payload(ReadOnlyCollection`1<object> value);
    [__DynamicallyInvokableAttribute]
public ReadOnlyCollection`1<string> get_PayloadNames();
    internal void set_PayloadNames(ReadOnlyCollection`1<string> value);
    [__DynamicallyInvokableAttribute]
public EventSource get_EventSource();
    [__DynamicallyInvokableAttribute]
public EventKeywords get_Keywords();
    [__DynamicallyInvokableAttribute]
public EventOpcode get_Opcode();
    [__DynamicallyInvokableAttribute]
public EventTask get_Task();
    [__DynamicallyInvokableAttribute]
public EventTags get_Tags();
    [__DynamicallyInvokableAttribute]
public string get_Message();
    internal void set_Message(string value);
    [__DynamicallyInvokableAttribute]
public byte get_Version();
    [__DynamicallyInvokableAttribute]
public EventLevel get_Level();
}
internal class System.Diagnostics.Tracing.FieldMetadata : object {
    private string name;
    private int nameSize;
    private EventFieldTags tags;
    private Byte[] custom;
    private ushort fixedCount;
    private byte inType;
    private byte outType;
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, bool variableCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, ushort fixedCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, Byte[] custom);
    private FieldMetadata(string name, TraceLoggingDataType dataType, EventFieldTags tags, byte countFlags, ushort fixedCount, Byte[] custom);
    public void IncrementStructFieldCount();
    public void Encode(Int32& pos, Byte[] metadata);
}
internal static class System.Diagnostics.Tracing.Internal.Environment : object {
    public static string NewLine;
    private static ResourceManager rm;
    public static int TickCount { get; }
    private static Environment();
    public static int get_TickCount();
    public static string GetResourceString(string key, Object[] args);
    public static string GetRuntimeResourceString(string key, Object[] args);
}
internal class System.Diagnostics.Tracing.InvokeTypeInfo : TraceLoggingTypeInfo {
    private PropertyAnalysis[] properties;
    public InvokeTypeInfo(Type type, TypeAnalysis typeAnalysis);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ManifestBuilder : object {
    private Dictionary`2<int, string> opcodeTab;
    private Dictionary`2<int, string> taskTab;
    private Dictionary`2<ulong, string> keywordTab;
    private Dictionary`2<string, Type> mapsTab;
    private Dictionary`2<string, string> stringTab;
    private StringBuilder sb;
    private StringBuilder events;
    private StringBuilder templates;
    private ResourceManager resources;
    private EventManifestOptions flags;
    private IList`1<string> errors;
    private Dictionary`2<string, List`1<int>> perEventByteArrayArgIndices;
    private string eventName;
    private int numParams;
    private List`1<int> byteArrArgIndices;
    public IList`1<string> Errors { get; }
    public ManifestBuilder(string providerName, Guid providerGuid, string dllName, ResourceManager resources, EventManifestOptions flags);
    public void AddOpcode(string name, int value);
    public void AddTask(string name, int value);
    public void AddKeyword(string name, ulong value);
    public void StartEvent(string eventName, EventAttribute eventAttribute);
    public void AddEventParameter(Type type, string name);
    public void EndEvent();
    public Byte[] CreateManifest();
    public IList`1<string> get_Errors();
    public void ManifestError(string msg, bool runtimeCritical);
    private string CreateManifestString();
    private void WriteNameAndMessageAttribs(StringBuilder stringBuilder, string elementName, string name);
    private void WriteMessageAttrib(StringBuilder stringBuilder, string elementName, string name, string value);
    internal string GetLocalizedMessage(string key, CultureInfo ci, bool etwFormat);
    private static List`1<CultureInfo> GetSupportedCultures(ResourceManager resources);
    private static string GetLevelName(EventLevel level);
    private string GetTaskName(EventTask task, string eventName);
    private string GetOpcodeName(EventOpcode opcode, string eventName);
    private string GetKeywords(ulong keywords, string eventName);
    private string GetTypeName(Type type);
    private static void UpdateStringBuilder(StringBuilder& stringBuilder, string eventMessage, int startIndex, int count);
    private string TranslateToManifestConvention(string eventMessage, string evtName);
    private int TranslateIndexToManifestConvention(int idx, string evtName);
}
internal class System.Diagnostics.Tracing.ManifestEnvelope : ValueType {
    public static int MaxChunkSize;
    public ManifestFormats Format;
    public byte MajorVersion;
    public byte MinorVersion;
    public byte Magic;
    public ushort TotalChunks;
    public ushort ChunkNumber;
}
internal class System.Diagnostics.Tracing.NameInfo : ConcurrentSetItem`2<KeyValuePair`2<string, EventTags>, NameInfo> {
    private static int lastIdentity;
    internal string name;
    internal EventTags tags;
    internal int identity;
    internal Byte[] nameMetadata;
    public NameInfo(string name, EventTags tags, int typeMetadataSize);
    private static NameInfo();
    internal static void ReserveEventIDsBelow(int eventId);
    public virtual int Compare(NameInfo other);
    public virtual int Compare(KeyValuePair`2<string, EventTags> key);
    private int Compare(string otherName, EventTags otherTags);
}
[AttributeUsageAttribute("64")]
[__DynamicallyInvokableAttribute]
public class System.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
internal class System.Diagnostics.Tracing.NullableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo valueInfo;
    private Func`2<PropertyValue, PropertyValue> hasValueGetter;
    private Func`2<PropertyValue, PropertyValue> valueGetter;
    public NullableTypeInfo(Type type, List`1<Type> recursionCheck);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.NullTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.PropertyAnalysis : object {
    internal string name;
    internal PropertyInfo propertyInfo;
    internal Func`2<PropertyValue, PropertyValue> getter;
    internal TraceLoggingTypeInfo typeInfo;
    internal EventFieldAttribute fieldAttribute;
    public PropertyAnalysis(string name, PropertyInfo propertyInfo, TraceLoggingTypeInfo typeInfo, EventFieldAttribute fieldAttribute);
}
internal class System.Diagnostics.Tracing.PropertyValue : ValueType {
    private object _reference;
    private Scalar _scalar;
    private int _scalarLength;
    public object ReferenceValue { get; }
    public Scalar ScalarValue { get; }
    public int ScalarLength { get; }
    private PropertyValue(object value);
    private PropertyValue(Scalar scalar, int scalarLength);
    private PropertyValue(bool value);
    private PropertyValue(byte value);
    private PropertyValue(sbyte value);
    private PropertyValue(char value);
    private PropertyValue(short value);
    private PropertyValue(ushort value);
    private PropertyValue(int value);
    private PropertyValue(UInt32 value);
    private PropertyValue(long value);
    private PropertyValue(ulong value);
    private PropertyValue(IntPtr value);
    private PropertyValue(UIntPtr value);
    private PropertyValue(float value);
    private PropertyValue(double value);
    private PropertyValue(Guid value);
    private PropertyValue(DateTime value);
    private PropertyValue(DateTimeOffset value);
    private PropertyValue(TimeSpan value);
    private PropertyValue(decimal value);
    public static Func`2<object, PropertyValue> GetFactory(Type type);
    public object get_ReferenceValue();
    public Scalar get_ScalarValue();
    public int get_ScalarLength();
    public static Func`2<PropertyValue, PropertyValue> GetPropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetBoxedValueTypePropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetReferenceTypePropertyGetter(PropertyInfo property);
}
internal class System.Diagnostics.Tracing.ScalarArrayTypeInfo : TraceLoggingTypeInfo {
    private Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc;
    private TraceLoggingDataType nativeFormat;
    private int elementSize;
    private ScalarArrayTypeInfo(Type type, Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc, TraceLoggingDataType nativeFormat, int elementSize);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
internal class System.Diagnostics.Tracing.ScalarTypeInfo : TraceLoggingTypeInfo {
    private Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc;
    private TraceLoggingDataType nativeFormat;
    private ScalarTypeInfo(Type type, Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc, TraceLoggingDataType nativeFormat);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.SessionMask : ValueType {
    private UInt32 m_mask;
    internal static int SHIFT_SESSION_TO_KEYWORD;
    internal static UInt32 MASK;
    internal static UInt32 MAX;
    public static SessionMask All { get; }
    public bool Item { get; public set; }
    public SessionMask(SessionMask m);
    public SessionMask(UInt32 mask);
    public bool IsEqualOrSupersetOf(SessionMask m);
    public static SessionMask get_All();
    public static SessionMask FromId(int perEventSourceSessionId);
    public long ToEventKeywords();
    public static SessionMask FromEventKeywords(ulong m);
    public bool get_Item(int perEventSourceSessionId);
    public void set_Item(int perEventSourceSessionId, bool value);
    public static SessionMask op_BitwiseOr(SessionMask m1, SessionMask m2);
    public static SessionMask op_BitwiseAnd(SessionMask m1, SessionMask m2);
    public static SessionMask op_ExclusiveOr(SessionMask m1, SessionMask m2);
    public static SessionMask op_OnesComplement(SessionMask m);
    public static ulong op_Explicit(SessionMask m);
    public static UInt32 op_Explicit(SessionMask m);
}
internal static class System.Diagnostics.Tracing.SimpleEventTypes`1 : object {
    private static TraceLoggingEventTypes instance;
    public static TraceLoggingEventTypes Instance { get; }
    public static TraceLoggingEventTypes get_Instance();
    private static TraceLoggingEventTypes InitInstance();
}
internal static class System.Diagnostics.Tracing.Statics : object {
    public static byte DefaultLevel;
    public static byte TraceLoggingChannel;
    public static byte InTypeMask;
    public static byte InTypeFixedCountFlag;
    public static byte InTypeVariableCountFlag;
    public static byte InTypeCustomCountFlag;
    public static byte InTypeCountMask;
    public static byte InTypeChainFlag;
    public static byte OutTypeMask;
    public static byte OutTypeChainFlag;
    public static EventTags EventTagsMask;
    public static TraceLoggingDataType IntPtrType;
    public static TraceLoggingDataType UIntPtrType;
    public static TraceLoggingDataType HexIntPtrType;
    private static Statics();
    public static Byte[] MetadataForString(string name, int prefixSize, int suffixSize, int additionalSize);
    public static void EncodeTags(int tags, Int32& pos, Byte[] metadata);
    public static byte Combine(int settingValue, byte defaultValue);
    public static byte Combine(int settingValue1, int settingValue2, byte defaultValue);
    public static int Combine(int settingValue1, int settingValue2);
    public static void CheckName(string name);
    public static bool ShouldOverrideFieldName(string fieldName);
    public static TraceLoggingDataType MakeDataType(TraceLoggingDataType baseType, EventFieldFormat format);
    public static TraceLoggingDataType Format8(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format16(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format32(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format64(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType FormatPtr(EventFieldFormat format, TraceLoggingDataType native);
    public static object CreateInstance(Type type, Object[] parameters);
    public static bool IsValueType(Type type);
    public static bool IsEnum(Type type);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static MethodInfo GetGetMethod(PropertyInfo propInfo);
    public static MethodInfo GetDeclaredStaticMethod(Type declaringType, string name);
    public static bool HasCustomAttribute(PropertyInfo propInfo, Type attributeType);
    public static AttributeType GetCustomAttribute(PropertyInfo propInfo);
    public static AttributeType GetCustomAttribute(Type type);
    public static Type[] GetGenericArguments(Type type);
    public static Type FindEnumerableElementType(Type type);
    public static bool IsGenericMatch(Type type, object openType);
    public static Delegate CreateDelegate(Type delegateType, MethodInfo methodInfo);
    public static TraceLoggingTypeInfo CreateDefaultTypeInfo(Type dataType, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.StringTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.TimeSpanTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
[SecuritySafeCriticalAttribute]
internal class System.Diagnostics.Tracing.TraceLoggingDataCollector : object {
    internal static TraceLoggingDataCollector Instance;
    private static TraceLoggingDataCollector();
    public int BeginBufferedArray();
    public void EndBufferedArray(int bookmark, int count);
    public TraceLoggingDataCollector AddGroup();
    public void AddScalar(PropertyValue value);
    public void AddScalar(long value);
    public void AddScalar(double value);
    public void AddBinary(string value);
    public void AddArray(PropertyValue value, int elementSize);
}
internal enum System.Diagnostics.Tracing.TraceLoggingDataType : Enum {
    public int value__;
    public static TraceLoggingDataType Nil;
    public static TraceLoggingDataType Utf16String;
    public static TraceLoggingDataType MbcsString;
    public static TraceLoggingDataType Int8;
    public static TraceLoggingDataType UInt8;
    public static TraceLoggingDataType Int16;
    public static TraceLoggingDataType UInt16;
    public static TraceLoggingDataType Int32;
    public static TraceLoggingDataType UInt32;
    public static TraceLoggingDataType Int64;
    public static TraceLoggingDataType UInt64;
    public static TraceLoggingDataType Float;
    public static TraceLoggingDataType Double;
    public static TraceLoggingDataType Boolean32;
    public static TraceLoggingDataType Binary;
    public static TraceLoggingDataType Guid;
    public static TraceLoggingDataType FileTime;
    public static TraceLoggingDataType SystemTime;
    public static TraceLoggingDataType HexInt32;
    public static TraceLoggingDataType HexInt64;
    public static TraceLoggingDataType CountedUtf16String;
    public static TraceLoggingDataType CountedMbcsString;
    public static TraceLoggingDataType Struct;
    public static TraceLoggingDataType Char16;
    public static TraceLoggingDataType Char8;
    public static TraceLoggingDataType Boolean8;
    public static TraceLoggingDataType HexInt8;
    public static TraceLoggingDataType HexInt16;
    public static TraceLoggingDataType Utf16Xml;
    public static TraceLoggingDataType MbcsXml;
    public static TraceLoggingDataType CountedUtf16Xml;
    public static TraceLoggingDataType CountedMbcsXml;
    public static TraceLoggingDataType Utf16Json;
    public static TraceLoggingDataType MbcsJson;
    public static TraceLoggingDataType CountedUtf16Json;
    public static TraceLoggingDataType CountedMbcsJson;
    public static TraceLoggingDataType HResult;
}
public class System.Diagnostics.Tracing.TraceLoggingEventTypes : object {
    internal TraceLoggingTypeInfo[] typeInfos;
    internal string name;
    internal EventTags tags;
    internal byte level;
    internal byte opcode;
    internal EventKeywords keywords;
    internal Byte[] typeMetadata;
    internal int scratchSize;
    internal int dataCount;
    internal int pinCount;
    private ConcurrentSet`2<KeyValuePair`2<string, EventTags>, NameInfo> nameInfos;
    internal string Name { get; }
    internal EventLevel Level { get; }
    internal EventOpcode Opcode { get; }
    internal EventKeywords Keywords { get; }
    internal EventTags Tags { get; }
    internal TraceLoggingEventTypes(string name, EventTags tags, Type[] types);
    internal TraceLoggingEventTypes(string name, EventTags tags, TraceLoggingTypeInfo[] typeInfos);
    internal TraceLoggingEventTypes(string name, EventTags tags, ParameterInfo[] paramInfos);
    private TraceLoggingEventTypes(EventTags tags, string defaultName, TraceLoggingTypeInfo[] typeInfos);
    internal string get_Name();
    internal EventLevel get_Level();
    internal EventOpcode get_Opcode();
    internal EventKeywords get_Keywords();
    internal EventTags get_Tags();
    internal NameInfo GetNameInfo(string name, EventTags tags);
    private TraceLoggingTypeInfo[] MakeArray(ParameterInfo[] paramInfos);
    private static TraceLoggingTypeInfo[] MakeArray(Type[] types);
    private static TraceLoggingTypeInfo[] MakeArray(TraceLoggingTypeInfo[] typeInfos);
}
internal class System.Diagnostics.Tracing.TraceLoggingMetadataCollector : object {
    private Impl impl;
    private FieldMetadata currentGroup;
    private int bufferedArrayFieldCount;
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    internal EventFieldTags Tags { get; internal set; }
    internal int ScratchSize { get; }
    internal int DataCount { get; }
    internal int PinCount { get; }
    private bool BeginningBufferedArray { get; }
    private TraceLoggingMetadataCollector(TraceLoggingMetadataCollector other, FieldMetadata group);
    [CompilerGeneratedAttribute]
internal EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventFieldTags value);
    internal int get_ScratchSize();
    internal int get_DataCount();
    internal int get_PinCount();
    private bool get_BeginningBufferedArray();
    public TraceLoggingMetadataCollector AddGroup(string name);
    public void AddScalar(string name, TraceLoggingDataType type);
    public void AddBinary(string name, TraceLoggingDataType type);
    public void AddArray(string name, TraceLoggingDataType type);
    public void BeginBufferedArray();
    public void EndBufferedArray();
    public void AddCustom(string name, TraceLoggingDataType type, Byte[] metadata);
    internal Byte[] GetMetadata();
    private void AddField(FieldMetadata fieldMetadata);
}
internal abstract class System.Diagnostics.Tracing.TraceLoggingTypeInfo : object {
    private string name;
    private EventKeywords keywords;
    private EventLevel level;
    private EventOpcode opcode;
    private EventTags tags;
    private Type dataType;
    private Func`2<object, PropertyValue> propertyValueFactory;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, TraceLoggingTypeInfo> threadCache;
    public string Name { get; }
    public EventLevel Level { get; }
    public EventOpcode Opcode { get; }
    public EventKeywords Keywords { get; }
    public EventTags Tags { get; }
    internal Type DataType { get; }
    internal Func`2<object, PropertyValue> PropertyValueFactory { get; }
    internal TraceLoggingTypeInfo(Type dataType);
    internal TraceLoggingTypeInfo(Type dataType, string name, EventLevel level, EventOpcode opcode, EventKeywords keywords, EventTags tags);
    public string get_Name();
    public EventLevel get_Level();
    public EventOpcode get_Opcode();
    public EventKeywords get_Keywords();
    public EventTags get_Tags();
    internal Type get_DataType();
    internal Func`2<object, PropertyValue> get_PropertyValueFactory();
    public abstract virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public abstract virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
    public static TraceLoggingTypeInfo GetInstance(Type type, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.TypeAnalysis : object {
    internal PropertyAnalysis[] properties;
    internal string name;
    internal EventKeywords keywords;
    internal EventLevel level;
    internal EventOpcode opcode;
    internal EventTags tags;
    public TypeAnalysis(Type dataType, EventDataAttribute eventAttrib, List`1<Type> recursionCheck);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string UnknownError_Num { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_MaxArgExceeded { get; }
    internal static string ArgumentOutOfRange_MaxStringsExceeded { get; }
    internal static string ArgumentOutOfRange_NeedValidId { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string EventSource_ListenerNotFound { get; }
    internal static string EventSource_ToString { get; }
    internal static string EventSource_ImplementGetMetadata { get; }
    internal static string EventSource_NeedGuid { get; }
    internal static string EventSource_NeedName { get; }
    internal static string EventSource_NeedDescriptors { get; }
    internal static string EventSource_NeedManifest { get; }
    internal static string EventSource_EventSourceGuidInUse { get; }
    internal static string EventSource_ListenerWriteFailure { get; }
    internal static string EventSource_NoManifest { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_UnknownError_Num();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_MaxArgExceeded();
    internal static string get_ArgumentOutOfRange_MaxStringsExceeded();
    internal static string get_ArgumentOutOfRange_NeedValidId();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_EventSource_ListenerNotFound();
    internal static string get_EventSource_ToString();
    internal static string get_EventSource_ImplementGetMetadata();
    internal static string get_EventSource_NeedGuid();
    internal static string get_EventSource_NeedName();
    internal static string get_EventSource_NeedDescriptors();
    internal static string get_EventSource_NeedManifest();
    internal static string get_EventSource_EventSourceGuidInUse();
    internal static string get_EventSource_ListenerWriteFailure();
    internal static string get_EventSource_NoManifest();
    internal static Type get_ResourceType();
}
