internal static class FxResources.System.Linq.Expressions.SR : object {
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ArrayBuilder`1 : ValueType {
    private T[] _array;
    private int _count;
    public ArrayBuilder`1(int capacity);
    public T[] ToArray();
    public void UncheckedAdd(T item);
}
internal class System.Collections.Generic.ReferenceEqualityComparer`1 : object {
    internal static ReferenceEqualityComparer`1<T> Instance;
    private static ReferenceEqualityComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
public abstract class System.Dynamic.BinaryOperationBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private ExpressionType <Operation>k__BackingField;
    public Type ReturnType { get; }
    public ExpressionType Operation { get; }
    internal bool IsStandardBinder { get; }
    protected BinaryOperationBinder(ExpressionType operation);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public ExpressionType get_Operation();
    public DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg);
    public abstract virtual DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    internal static bool OperationIsValid(ExpressionType operation);
}
[DebuggerDisplayAttribute("{DebugView}")]
[DebuggerTypeProxyAttribute("System.Dynamic.BindingRestrictions/BindingRestrictionsProxy")]
public abstract class System.Dynamic.BindingRestrictions : object {
    public static BindingRestrictions Empty;
    private string DebugView { get; }
    private static BindingRestrictions();
    internal abstract virtual Expression GetExpression();
    public BindingRestrictions Merge(BindingRestrictions restrictions);
    public static BindingRestrictions GetTypeRestriction(Expression expression, Type type);
    internal static BindingRestrictions GetTypeRestriction(DynamicMetaObject obj);
    public static BindingRestrictions GetInstanceRestriction(Expression expression, object instance);
    public static BindingRestrictions GetExpressionRestriction(Expression expression);
    public static BindingRestrictions Combine(IList`1<DynamicMetaObject> contributingObjects);
    public Expression ToExpression();
    private string get_DebugView();
}
public class System.Dynamic.CallInfo : object {
    [CompilerGeneratedAttribute]
private int <ArgumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <ArgumentNames>k__BackingField;
    public int ArgumentCount { get; }
    public ReadOnlyCollection`1<string> ArgumentNames { get; }
    public CallInfo(int argCount, String[] argNames);
    public CallInfo(int argCount, IEnumerable`1<string> argNames);
    [CompilerGeneratedAttribute]
public int get_ArgumentCount();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_ArgumentNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class System.Dynamic.ConvertBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Explicit>k__BackingField;
    public Type Type { get; }
    public bool Explicit { get; }
    internal bool IsStandardBinder { get; }
    public Type ReturnType { get; }
    protected ConvertBinder(Type type, bool explicit);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public bool get_Explicit();
    public DynamicMetaObject FallbackConvert(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public sealed virtual Type get_ReturnType();
}
public abstract class System.Dynamic.CreateInstanceBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected CreateInstanceBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public abstract class System.Dynamic.DeleteIndexBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected DeleteIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.DeleteMemberBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    public string Name { get; }
    public bool IgnoreCase { get; }
    public Type ReturnType { get; }
    internal bool IsStandardBinder { get; }
    protected DeleteMemberBinder(string name, bool ignoreCase);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    public sealed virtual Type get_ReturnType();
    public DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public class System.Dynamic.DynamicMetaObject : object {
    public static DynamicMetaObject[] EmptyMetaObjects;
    private static object s_noValueSentinel;
    private object _value;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingRestrictions <Restrictions>k__BackingField;
    public Expression Expression { get; }
    public BindingRestrictions Restrictions { get; }
    public object Value { get; }
    public bool HasValue { get; }
    public Type RuntimeType { get; }
    public Type LimitType { get; }
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions);
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions, object value);
    private static DynamicMetaObject();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public BindingRestrictions get_Restrictions();
    public object get_Value();
    public bool get_HasValue();
    public Type get_RuntimeType();
    public Type get_LimitType();
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    internal static Expression[] GetExpressions(DynamicMetaObject[] objects);
    public static DynamicMetaObject Create(object value, Expression expression);
}
public abstract class System.Dynamic.DynamicMetaObjectBinder : CallSiteBinder {
    public Type ReturnType { get; }
    internal bool IsStandardBinder { get; }
    public virtual Type get_ReturnType();
    public sealed virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    private static DynamicMetaObject[] CreateArgumentMetaObjects(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters);
    public abstract virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public Expression GetUpdateExpression(Type type);
    public DynamicMetaObject Defer(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject Defer(DynamicMetaObject[] args);
    private DynamicMetaObject MakeDeferred(BindingRestrictions rs, DynamicMetaObject[] args);
    internal virtual bool get_IsStandardBinder();
}
public class System.Dynamic.DynamicObject : object {
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryDeleteMember(DeleteMemberBinder binder);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryUnaryOperation(UnaryOperationBinder binder, Object& result);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TryDeleteIndex(DeleteIndexBinder binder, Object[] indexes);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
internal class System.Dynamic.ExpandoClass : object {
    private String[] _keys;
    private int _hashCode;
    private Dictionary`2<int, List`1<WeakReference>> _transitions;
    internal static ExpandoClass Empty;
    internal String[] Keys { get; }
    internal ExpandoClass(String[] keys, int hashCode);
    private static ExpandoClass();
    internal ExpandoClass FindNewClass(string newKey);
    private List`1<WeakReference> GetTransitionList(int hashCode);
    internal int GetValueIndex(string name, bool caseInsensitive, ExpandoObject obj);
    internal int GetValueIndexCaseSensitive(string name);
    private int GetValueIndexCaseInsensitive(string name, ExpandoObject obj);
    internal String[] get_Keys();
}
public class System.Dynamic.ExpandoObject : object {
    private static MethodInfo s_expandoTryGetValue;
    private static MethodInfo s_expandoTrySetValue;
    private static MethodInfo s_expandoTryDeleteValue;
    private static MethodInfo s_expandoPromoteClass;
    private static MethodInfo s_expandoCheckVersion;
    internal object LockObject;
    private ExpandoData _data;
    private int _count;
    internal static object Uninitialized;
    private PropertyChangedEventHandler _propertyChanged;
    internal ExpandoClass Class { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    private static ExpandoObject();
    internal bool TryGetValue(object indexClass, int index, string name, bool ignoreCase, Object& value);
    internal void TrySetValue(object indexClass, int index, object value, string name, bool ignoreCase, bool add);
    internal bool TryDeleteValue(object indexClass, int index, string name, bool ignoreCase, object deleteValue);
    internal bool IsDeletedMember(int index);
    internal ExpandoClass get_Class();
    private ExpandoData PromoteClassCore(ExpandoClass oldClass, ExpandoClass newClass);
    internal void PromoteClass(object oldClass, object newClass);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private void TryAddMember(string key, object value);
    private bool TryGetValueForKey(string key, Object& value);
    private bool ExpandoContainsKey(string key);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Dynamic.ExpandoObject/<GetExpandoEnumerator>d__51")]
private IEnumerator`1<KeyValuePair`2<string, object>> GetExpandoEnumerator(ExpandoData data, int version);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
}
public abstract class System.Dynamic.GetIndexBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected GetIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.GetMemberBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    internal bool IsStandardBinder { get; }
    protected GetMemberBinder(string name, bool ignoreCase);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    public DynamicMetaObject FallbackGetMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public interface System.Dynamic.IDynamicMetaObjectProvider {
    public abstract virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
public interface System.Dynamic.IInvokeOnGetBinder {
    public bool InvokeOnGet { get; }
    public abstract virtual bool get_InvokeOnGet();
}
public abstract class System.Dynamic.InvokeBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected InvokeBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
}
public abstract class System.Dynamic.InvokeMemberBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected InvokeMemberBinder(string name, bool ignoreCase, CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.SetIndexBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CallInfo <CallInfo>k__BackingField;
    public Type ReturnType { get; }
    public CallInfo CallInfo { get; }
    internal bool IsStandardBinder { get; }
    protected SetIndexBinder(CallInfo callInfo);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public CallInfo get_CallInfo();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.SetMemberBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    public Type ReturnType { get; }
    public string Name { get; }
    public bool IgnoreCase { get; }
    internal bool IsStandardBinder { get; }
    protected SetMemberBinder(string name, bool ignoreCase);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    public DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
public abstract class System.Dynamic.UnaryOperationBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private ExpressionType <Operation>k__BackingField;
    public Type ReturnType { get; }
    public ExpressionType Operation { get; }
    internal bool IsStandardBinder { get; }
    protected UnaryOperationBinder(ExpressionType operation);
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public ExpressionType get_Operation();
    public DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal sealed virtual bool get_IsStandardBinder();
    internal static bool OperationIsValid(ExpressionType operation);
}
internal static class System.Dynamic.UpdateDelegates : object {
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute1(CallSite site, T0 arg0);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch1(CallSite site, T0 arg0);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute2(CallSite site, T0 arg0, T1 arg1);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch2(CallSite site, T0 arg0, T1 arg1);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute3(CallSite site, T0 arg0, T1 arg1, T2 arg2);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch3(CallSite site, T0 arg0, T1 arg1, T2 arg2);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet UpdateAndExecute10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static TRet NoMatch10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid1(CallSite site, T0 arg0);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid1(CallSite site, T0 arg0);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid2(CallSite site, T0 arg0, T1 arg1);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid2(CallSite site, T0 arg0, T1 arg1);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid3(CallSite site, T0 arg0, T1 arg1, T2 arg2);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid3(CallSite site, T0 arg0, T1 arg1, T2 arg2);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid4(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid5(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid6(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid7(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid8(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid9(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void UpdateAndExecuteVoid10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [ObsoleteAttribute("pregenerated CallSite<T>.Update delegate", "True")]
internal static void NoMatchVoid10(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
}
[DefaultMemberAttribute("Item")]
internal class System.Dynamic.Utils.CacheDict`2 : object {
    private int _mask;
    private Entry[] _entries;
    unknown TValue Item {internal set; }
    internal CacheDict`2(int size);
    private static int AlignSize(int size);
    internal bool TryGetValue(TKey key, TValue& value);
    internal void Add(TKey key, TValue value);
    internal void set_Item(TKey key, TValue value);
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.CollectionExtensions : object {
    [ExtensionAttribute]
public static TrueReadOnlyCollection`1<T> AddFirst(ReadOnlyCollection`1<T> list, T item);
    [ExtensionAttribute]
public static T[] AddFirst(T[] array, T item);
    [ExtensionAttribute]
public static T[] AddLast(T[] array, T item);
    [ExtensionAttribute]
public static T[] RemoveFirst(T[] array);
    [ExtensionAttribute]
public static T[] RemoveLast(T[] array);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnly(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static int ListHashCode(ReadOnlyCollection`1<T> list);
    [ExtensionAttribute]
public static bool ListEquals(ReadOnlyCollection`1<T> first, ReadOnlyCollection`1<T> second);
}
internal static class System.Dynamic.Utils.ContractUtils : object {
    [ExcludeFromCodeCoverageAttribute]
public static Exception Unreachable { get; }
    public static Exception get_Unreachable();
    public static void Requires(bool precondition, string paramName);
    public static void RequiresNotNull(object value, string paramName);
    public static void RequiresNotNull(object value, string paramName, int index);
    public static void RequiresNotEmpty(ICollection`1<T> collection, string paramName);
    public static void RequiresNotNullItems(IList`1<T> array, string arrayName);
    private static string GetParamName(string paramName, int index);
    public static void RequiresArrayRange(IList`1<T> array, int offset, int count, string offsetName, string countName);
}
internal static class System.Dynamic.Utils.DelegateHelpers : object {
    private static MethodInfo s_FuncInvoke;
    private static MethodInfo s_ArrayEmpty;
    private static DelegateHelpers();
    internal static Delegate CreateObjectArrayDelegate(Type delegateType, Func`2<Object[], object> handler);
    private static Delegate CreateObjectArrayDelegateRefEmit(Type delegateType, Func`2<Object[], object> handler);
    private static Type ConvertToBoxableType(Type t);
}
internal static class System.Dynamic.Utils.EmptyReadOnlyCollection`1 : object {
    public static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.ExpressionUtils : object {
    public static ReadOnlyCollection`1<ParameterExpression> ReturnReadOnly(IParameterProvider provider, Object& collection);
    public static ReadOnlyCollection`1<T> ReturnReadOnly(IReadOnlyList`1& collection);
    public static ReadOnlyCollection`1<Expression> ReturnReadOnly(IArgumentProvider provider, Object& collection);
    public static T ReturnObject(object collectionOrT);
    public static void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ReadOnlyCollection`1& arguments, string methodParamName);
    public static void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis);
    public static Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arguments, ParameterInfo pi, string methodParamName, string argumentParamName, int index);
    public static void RequiresCanRead(Expression expression, string paramName);
    public static void RequiresCanRead(Expression expression, string paramName, int idx);
    public static bool TryQuote(Type parameterType, Expression& argument);
    internal static ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind);
    internal static bool SameElements(ICollection`1<T> replacement, IReadOnlyList`1<T> current);
    internal static bool SameElements(IEnumerable`1& replacement, IReadOnlyList`1<T> current);
    private static bool SameElementsInCollection(ICollection`1<T> replacement, IReadOnlyList`1<T> current);
    [ExtensionAttribute]
public static void ValidateArgumentCount(LambdaExpression lambda);
}
internal static class System.Dynamic.Utils.ExpressionVisitorUtils : object {
    public static Expression[] VisitBlockExpressions(ExpressionVisitor visitor, BlockExpression block);
    public static ParameterExpression[] VisitParameters(ExpressionVisitor visitor, IParameterProvider nodes, string callerName);
    public static Expression[] VisitArguments(ExpressionVisitor visitor, IArgumentProvider nodes);
}
internal static class System.Dynamic.Utils.Helpers : object {
    internal static T CommonNode(T first, T second, Func`2<T, T> parent);
    internal static void IncrementCount(T key, Dictionary`2<T, int> dict);
}
internal class System.Dynamic.Utils.ListArgumentProvider : ListProvider`1<Expression> {
    private IArgumentProvider _provider;
    private Expression _arg0;
    protected Expression First { get; }
    protected int ElementCount { get; }
    internal ListArgumentProvider(IArgumentProvider provider, Expression arg0);
    protected virtual Expression get_First();
    protected virtual int get_ElementCount();
    protected virtual Expression GetElement(int index);
}
internal class System.Dynamic.Utils.ListParameterProvider : ListProvider`1<ParameterExpression> {
    private IParameterProvider _provider;
    private ParameterExpression _arg0;
    protected ParameterExpression First { get; }
    protected int ElementCount { get; }
    internal ListParameterProvider(IParameterProvider provider, ParameterExpression arg0);
    protected virtual ParameterExpression get_First();
    protected virtual int get_ElementCount();
    protected virtual ParameterExpression GetElement(int index);
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Dynamic.Utils.ListProvider`1 : object {
    protected T First { get; }
    protected int ElementCount { get; }
    public T Item { get; public set; }
    public int Count { get; }
    [ExcludeFromCodeCoverageAttribute]
public bool IsReadOnly { get; }
    protected abstract virtual T get_First();
    protected abstract virtual int get_ElementCount();
    protected abstract virtual T GetElement(int index);
    public sealed virtual int IndexOf(T item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Insert(int index, T item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void set_Item(int index, T value);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Add(T item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("System.Dynamic.Utils.ListProvider`1/<GetEnumerator>d__20")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.TypeExtensions : object {
    private static CacheDict`2<MethodBase, ParameterInfo[]> s_paramInfoCache;
    private static TypeExtensions();
    [ExtensionAttribute]
public static MethodInfo GetAnyStaticMethodValidated(Type type, string name, Type[] types);
    [ExtensionAttribute]
private static bool MatchesArgumentTypes(MethodInfo mi, Type[] argTypes);
    [ExtensionAttribute]
public static Type GetReturnType(MethodBase mi);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
internal static ParameterInfo[] GetParametersCached(MethodBase method);
    [ExtensionAttribute]
internal static bool IsByRefParameter(ParameterInfo pi);
}
[ExtensionAttribute]
internal static class System.Dynamic.Utils.TypeUtils : object {
    private static Type[] s_arrayAssignableInterfaces;
    private static TypeUtils();
    [ExtensionAttribute]
public static Type GetNonNullableType(Type type);
    [ExtensionAttribute]
public static Type GetNullableType(Type type);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static bool IsNullableOrReferenceType(Type type);
    [ExtensionAttribute]
public static bool IsBool(Type type);
    [ExtensionAttribute]
public static bool IsNumeric(Type type);
    [ExtensionAttribute]
public static bool IsInteger(Type type);
    [ExtensionAttribute]
public static bool IsInteger64(Type type);
    [ExtensionAttribute]
public static bool IsArithmetic(Type type);
    [ExtensionAttribute]
public static bool IsUnsignedInt(Type type);
    [ExtensionAttribute]
public static bool IsIntegerOrBool(Type type);
    [ExtensionAttribute]
public static bool IsNumericOrBool(Type type);
    public static bool IsValidInstanceType(MemberInfo member, Type instanceType);
    [ExtensionAttribute]
public static bool HasIdentityPrimitiveOrNullableConversionTo(Type source, Type dest);
    [ExtensionAttribute]
public static bool HasReferenceConversionTo(Type source, Type dest);
    [ExtensionAttribute]
private static bool StrictHasReferenceConversionTo(Type source, Type dest, bool skipNonArray);
    private static bool HasArrayToInterfaceConversion(Type source, Type dest);
    private static bool HasInterfaceToArrayConversion(Type source, Type dest);
    private static bool IsCovariant(Type t);
    private static bool IsContravariant(Type t);
    private static bool IsInvariant(Type t);
    private static bool IsDelegate(Type t);
    public static bool IsLegalExplicitVariantDelegateConversion(Type source, Type dest);
    [ExtensionAttribute]
public static bool IsConvertible(Type type);
    public static bool HasReferenceEquality(Type left, Type right);
    public static bool HasBuiltInEqualityOperator(Type left, Type right);
    [ExtensionAttribute]
public static bool IsImplicitlyConvertibleTo(Type source, Type destination);
    public static MethodInfo GetUserDefinedCoercionMethod(Type convertFrom, Type convertToType);
    private static MethodInfo FindConversionOperator(MethodInfo[] methods, Type typeFrom, Type typeTo);
    private static bool IsImplicitNumericConversion(Type source, Type destination);
    private static bool IsImplicitReferenceConversion(Type source, Type destination);
    private static bool IsImplicitBoxingConversion(Type source, Type destination);
    private static bool IsImplicitNullableConversion(Type source, Type destination);
    public static Type FindGenericType(Type definition, Type type);
    public static MethodInfo GetBooleanOperator(Type type, string name);
    [ExtensionAttribute]
public static Type GetNonRefType(Type type);
    public static bool AreEquivalent(Type t1, Type t2);
    public static bool AreReferenceAssignable(Type dest, Type src);
    public static bool IsSameOrSubclass(Type type, Type subType);
    public static void ValidateType(Type type, string paramName);
    public static void ValidateType(Type type, string paramName, bool allowByRef, bool allowPointer);
    public static bool ValidateType(Type type, string paramName, int index);
    [ExtensionAttribute]
public static MethodInfo GetInvokeMethod(Type delegateType);
    [ExtensionAttribute]
internal static bool IsUnsigned(Type type);
    [ExtensionAttribute]
internal static bool IsUnsigned(TypeCode typeCode);
    [ExtensionAttribute]
internal static bool IsFloatingPoint(Type type);
    [ExtensionAttribute]
internal static bool IsFloatingPoint(TypeCode typeCode);
}
internal enum System.Linq.Expressions.AnalyzeTypeIsResult : Enum {
    public int value__;
    public static AnalyzeTypeIsResult KnownFalse;
    public static AnalyzeTypeIsResult KnownTrue;
    public static AnalyzeTypeIsResult KnownAssignable;
    public static AnalyzeTypeIsResult Unknown;
}
[ExtensionAttribute]
internal static class System.Linq.Expressions.ArrayBuilderExtensions : object {
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnly(ArrayBuilder`1<T> builder);
}
internal class System.Linq.Expressions.AssignBinaryExpression : BinaryExpression {
    internal bool IsByRef { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal AssignBinaryExpression(Expression left, Expression right);
    public static AssignBinaryExpression Make(Expression left, Expression right, bool byRef);
    internal virtual bool get_IsByRef();
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/BinaryExpressionProxy")]
public class System.Linq.Expressions.BinaryExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Left>k__BackingField;
    public bool CanReduce { get; }
    public Expression Right { get; }
    public Expression Left { get; }
    public MethodInfo Method { get; }
    public LambdaExpression Conversion { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    internal bool IsLiftedLogical { get; }
    internal bool IsReferenceComparison { get; }
    internal BinaryExpression(Expression left, Expression right);
    public virtual bool get_CanReduce();
    private static bool IsOpAssignment(ExpressionType op);
    [CompilerGeneratedAttribute]
public Expression get_Right();
    [CompilerGeneratedAttribute]
public Expression get_Left();
    public MethodInfo get_Method();
    internal virtual MethodInfo GetMethod();
    public BinaryExpression Update(Expression left, LambdaExpression conversion, Expression right);
    public virtual Expression Reduce();
    private static ExpressionType GetBinaryOpFromAssignmentOp(ExpressionType op);
    private Expression ReduceVariable();
    private Expression ReduceMember();
    private Expression ReduceIndex();
    public LambdaExpression get_Conversion();
    internal virtual LambdaExpression GetConversion();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal static BinaryExpression Create(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method, LambdaExpression conversion);
    internal bool get_IsLiftedLogical();
    internal bool get_IsReferenceComparison();
    internal Expression ReduceUserdefinedLifted();
}
internal class System.Linq.Expressions.Block2 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    internal int ExpressionCount { get; }
    internal Block2(Expression arg0, Expression arg1);
    internal virtual Expression GetExpression(int index);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Block3 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    internal int ExpressionCount { get; }
    internal Block3(Expression arg0, Expression arg1, Expression arg2);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Block4 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    internal int ExpressionCount { get; }
    internal Block4(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Block5 : BlockExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private Expression _arg4;
    internal int ExpressionCount { get; }
    internal Block5(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    internal virtual Expression GetExpression(int index);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/BlockExpressionProxy")]
public class System.Linq.Expressions.BlockExpression : Expression {
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public Expression Result { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    [ExcludeFromCodeCoverageAttribute]
internal int ExpressionCount { get; }
    public ReadOnlyCollection`1<Expression> get_Expressions();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    public Expression get_Result();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public BlockExpression Update(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    internal virtual bool SameVariables(ICollection`1<ParameterExpression> variables);
    [ExcludeFromCodeCoverageAttribute]
internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    [ExcludeFromCodeCoverageAttribute]
internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    [ExcludeFromCodeCoverageAttribute]
internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeVariables();
    [ExcludeFromCodeCoverageAttribute]
internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
    internal static ReadOnlyCollection`1<Expression> ReturnReadOnlyExpressions(BlockExpression provider, Object& collection);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Expressions.BlockExpressionList : object {
    private BlockExpression _block;
    private Expression _arg0;
    public Expression Item { get; public set; }
    public int Count { get; }
    [ExcludeFromCodeCoverageAttribute]
public bool IsReadOnly { get; }
    internal BlockExpressionList(BlockExpression provider, Expression arg0);
    public sealed virtual int IndexOf(Expression item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Insert(int index, Expression item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void RemoveAt(int index);
    public sealed virtual Expression get_Item(int index);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void set_Item(int index, Expression value);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Add(Expression item);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual void Clear();
    public sealed virtual bool Contains(Expression item);
    public sealed virtual void CopyTo(Expression[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual bool Remove(Expression item);
    [IteratorStateMachineAttribute("System.Linq.Expressions.BlockExpressionList/<GetEnumerator>d__18")]
public sealed virtual IEnumerator`1<Expression> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Expressions.BlockN : BlockExpression {
    private IReadOnlyList`1<Expression> _expressions;
    internal int ExpressionCount { get; }
    internal BlockN(IReadOnlyList`1<Expression> expressions);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.ByRefAssignBinaryExpression : AssignBinaryExpression {
    internal bool IsByRef { get; }
    internal ByRefAssignBinaryExpression(Expression left, Expression right);
    internal virtual bool get_IsByRef();
}
internal class System.Linq.Expressions.ByRefParameterExpression : TypedParameterExpression {
    internal ByRefParameterExpression(Type type, string name);
    internal virtual bool GetIsByRef();
}
internal static class System.Linq.Expressions.CachedReflectionInfo : object {
    private static ConstructorInfo s_Nullable_Boolean_Ctor;
    private static ConstructorInfo s_Decimal_Ctor_Int32;
    private static ConstructorInfo s_Decimal_Ctor_UInt32;
    private static ConstructorInfo s_Decimal_Ctor_Int64;
    private static ConstructorInfo s_Decimal_Ctor_UInt64;
    private static ConstructorInfo s_Decimal_Ctor_Int32_Int32_Int32_Bool_Byte;
    private static FieldInfo s_Decimal_One;
    private static FieldInfo s_Decimal_MinusOne;
    private static FieldInfo s_Decimal_MinValue;
    private static FieldInfo s_Decimal_MaxValue;
    private static FieldInfo s_Decimal_Zero;
    private static FieldInfo s_DateTime_MinValue;
    private static MethodInfo s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle;
    private static MethodInfo s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle;
    private static MethodInfo s_MethodInfo_CreateDelegate_Type_Object;
    private static MethodInfo s_String_op_Equality_String_String;
    private static MethodInfo s_String_Equals_String_String;
    private static MethodInfo s_DictionaryOfStringInt32_Add_String_Int32;
    private static ConstructorInfo s_DictionaryOfStringInt32_Ctor_Int32;
    private static MethodInfo s_Type_GetTypeFromHandle;
    private static MethodInfo s_Object_GetType;
    private static MethodInfo s_Decimal_op_Implicit_Byte;
    private static MethodInfo s_Decimal_op_Implicit_SByte;
    private static MethodInfo s_Decimal_op_Implicit_Int16;
    private static MethodInfo s_Decimal_op_Implicit_UInt16;
    private static MethodInfo s_Decimal_op_Implicit_Int32;
    private static MethodInfo s_Decimal_op_Implicit_UInt32;
    private static MethodInfo s_Decimal_op_Implicit_Int64;
    private static MethodInfo s_Decimal_op_Implicit_UInt64;
    private static MethodInfo s_Decimal_op_Implicit_Char;
    private static MethodInfo s_Math_Pow_Double_Double;
    private static ConstructorInfo s_Closure_ObjectArray_ObjectArray;
    private static FieldInfo s_Closure_Constants;
    private static FieldInfo s_Closure_Locals;
    private static MethodInfo s_RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array;
    private static MethodInfo s_RuntimeOps_CreateRuntimeVariables;
    private static MethodInfo s_RuntimeOps_MergeRuntimeVariables;
    private static MethodInfo s_RuntimeOps_Quote;
    private static MethodInfo s_String_Format_String_ObjectArray;
    private static ConstructorInfo s_InvalidCastException_Ctor_String;
    private static MethodInfo s_CallSiteOps_SetNotMatched;
    private static MethodInfo s_CallSiteOps_CreateMatchmaker;
    private static MethodInfo s_CallSiteOps_GetMatch;
    private static MethodInfo s_CallSiteOps_ClearMatch;
    private static MethodInfo s_CallSiteOps_UpdateRules;
    private static MethodInfo s_CallSiteOps_GetRules;
    private static MethodInfo s_CallSiteOps_GetRuleCache;
    private static MethodInfo s_CallSiteOps_GetCachedRules;
    private static MethodInfo s_CallSiteOps_AddRule;
    private static MethodInfo s_CallSiteOps_MoveRule;
    private static MethodInfo s_CallSiteOps_Bind;
    private static MethodInfo s_DynamicObject_TryGetMember;
    private static MethodInfo s_DynamicObject_TrySetMember;
    private static MethodInfo s_DynamicObject_TryDeleteMember;
    private static MethodInfo s_DynamicObject_TryGetIndex;
    private static MethodInfo s_DynamicObject_TrySetIndex;
    private static MethodInfo s_DynamicObject_TryDeleteIndex;
    private static MethodInfo s_DynamicObject_TryConvert;
    private static MethodInfo s_DynamicObject_TryInvoke;
    private static MethodInfo s_DynamicObject_TryInvokeMember;
    private static MethodInfo s_DynamicObject_TryBinaryOperation;
    private static MethodInfo s_DynamicObject_TryUnaryOperation;
    private static MethodInfo s_DynamicObject_TryCreateInstance;
    public static ConstructorInfo Nullable_Boolean_Ctor { get; }
    public static ConstructorInfo Decimal_Ctor_Int32 { get; }
    public static ConstructorInfo Decimal_Ctor_UInt32 { get; }
    public static ConstructorInfo Decimal_Ctor_Int64 { get; }
    public static ConstructorInfo Decimal_Ctor_UInt64 { get; }
    public static ConstructorInfo Decimal_Ctor_Int32_Int32_Int32_Bool_Byte { get; }
    public static FieldInfo Decimal_One { get; }
    public static FieldInfo Decimal_MinusOne { get; }
    public static FieldInfo Decimal_MinValue { get; }
    public static FieldInfo Decimal_MaxValue { get; }
    public static FieldInfo Decimal_Zero { get; }
    public static FieldInfo DateTime_MinValue { get; }
    public static MethodInfo MethodBase_GetMethodFromHandle_RuntimeMethodHandle { get; }
    public static MethodInfo MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle { get; }
    public static MethodInfo MethodInfo_CreateDelegate_Type_Object { get; }
    public static MethodInfo String_op_Equality_String_String { get; }
    public static MethodInfo String_Equals_String_String { get; }
    public static MethodInfo DictionaryOfStringInt32_Add_String_Int32 { get; }
    public static ConstructorInfo DictionaryOfStringInt32_Ctor_Int32 { get; }
    public static MethodInfo Type_GetTypeFromHandle { get; }
    public static MethodInfo Object_GetType { get; }
    public static MethodInfo Decimal_op_Implicit_Byte { get; }
    public static MethodInfo Decimal_op_Implicit_SByte { get; }
    public static MethodInfo Decimal_op_Implicit_Int16 { get; }
    public static MethodInfo Decimal_op_Implicit_UInt16 { get; }
    public static MethodInfo Decimal_op_Implicit_Int32 { get; }
    public static MethodInfo Decimal_op_Implicit_UInt32 { get; }
    public static MethodInfo Decimal_op_Implicit_Int64 { get; }
    public static MethodInfo Decimal_op_Implicit_UInt64 { get; }
    public static MethodInfo Decimal_op_Implicit_Char { get; }
    public static MethodInfo Math_Pow_Double_Double { get; }
    public static ConstructorInfo Closure_ObjectArray_ObjectArray { get; }
    public static FieldInfo Closure_Constants { get; }
    public static FieldInfo Closure_Locals { get; }
    public static MethodInfo RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array { get; }
    public static MethodInfo RuntimeOps_CreateRuntimeVariables { get; }
    public static MethodInfo RuntimeOps_MergeRuntimeVariables { get; }
    public static MethodInfo RuntimeOps_Quote { get; }
    public static MethodInfo String_Format_String_ObjectArray { get; }
    public static ConstructorInfo InvalidCastException_Ctor_String { get; }
    public static MethodInfo CallSiteOps_SetNotMatched { get; }
    public static MethodInfo CallSiteOps_CreateMatchmaker { get; }
    public static MethodInfo CallSiteOps_GetMatch { get; }
    public static MethodInfo CallSiteOps_ClearMatch { get; }
    public static MethodInfo CallSiteOps_UpdateRules { get; }
    public static MethodInfo CallSiteOps_GetRules { get; }
    public static MethodInfo CallSiteOps_GetRuleCache { get; }
    public static MethodInfo CallSiteOps_GetCachedRules { get; }
    public static MethodInfo CallSiteOps_AddRule { get; }
    public static MethodInfo CallSiteOps_MoveRule { get; }
    public static MethodInfo CallSiteOps_Bind { get; }
    public static MethodInfo DynamicObject_TryGetMember { get; }
    public static MethodInfo DynamicObject_TrySetMember { get; }
    public static MethodInfo DynamicObject_TryDeleteMember { get; }
    public static MethodInfo DynamicObject_TryGetIndex { get; }
    public static MethodInfo DynamicObject_TrySetIndex { get; }
    public static MethodInfo DynamicObject_TryDeleteIndex { get; }
    public static MethodInfo DynamicObject_TryConvert { get; }
    public static MethodInfo DynamicObject_TryInvoke { get; }
    public static MethodInfo DynamicObject_TryInvokeMember { get; }
    public static MethodInfo DynamicObject_TryBinaryOperation { get; }
    public static MethodInfo DynamicObject_TryUnaryOperation { get; }
    public static MethodInfo DynamicObject_TryCreateInstance { get; }
    public static ConstructorInfo get_Nullable_Boolean_Ctor();
    public static ConstructorInfo get_Decimal_Ctor_Int32();
    public static ConstructorInfo get_Decimal_Ctor_UInt32();
    public static ConstructorInfo get_Decimal_Ctor_Int64();
    public static ConstructorInfo get_Decimal_Ctor_UInt64();
    public static ConstructorInfo get_Decimal_Ctor_Int32_Int32_Int32_Bool_Byte();
    public static FieldInfo get_Decimal_One();
    public static FieldInfo get_Decimal_MinusOne();
    public static FieldInfo get_Decimal_MinValue();
    public static FieldInfo get_Decimal_MaxValue();
    public static FieldInfo get_Decimal_Zero();
    public static FieldInfo get_DateTime_MinValue();
    public static MethodInfo get_MethodBase_GetMethodFromHandle_RuntimeMethodHandle();
    public static MethodInfo get_MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle();
    public static MethodInfo get_MethodInfo_CreateDelegate_Type_Object();
    public static MethodInfo get_String_op_Equality_String_String();
    public static MethodInfo get_String_Equals_String_String();
    public static MethodInfo get_DictionaryOfStringInt32_Add_String_Int32();
    public static ConstructorInfo get_DictionaryOfStringInt32_Ctor_Int32();
    public static MethodInfo get_Type_GetTypeFromHandle();
    public static MethodInfo get_Object_GetType();
    public static MethodInfo get_Decimal_op_Implicit_Byte();
    public static MethodInfo get_Decimal_op_Implicit_SByte();
    public static MethodInfo get_Decimal_op_Implicit_Int16();
    public static MethodInfo get_Decimal_op_Implicit_UInt16();
    public static MethodInfo get_Decimal_op_Implicit_Int32();
    public static MethodInfo get_Decimal_op_Implicit_UInt32();
    public static MethodInfo get_Decimal_op_Implicit_Int64();
    public static MethodInfo get_Decimal_op_Implicit_UInt64();
    public static MethodInfo get_Decimal_op_Implicit_Char();
    public static MethodInfo get_Math_Pow_Double_Double();
    public static ConstructorInfo get_Closure_ObjectArray_ObjectArray();
    public static FieldInfo get_Closure_Constants();
    public static FieldInfo get_Closure_Locals();
    public static MethodInfo get_RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array();
    public static MethodInfo get_RuntimeOps_CreateRuntimeVariables();
    public static MethodInfo get_RuntimeOps_MergeRuntimeVariables();
    public static MethodInfo get_RuntimeOps_Quote();
    public static MethodInfo get_String_Format_String_ObjectArray();
    public static ConstructorInfo get_InvalidCastException_Ctor_String();
    public static MethodInfo get_CallSiteOps_SetNotMatched();
    public static MethodInfo get_CallSiteOps_CreateMatchmaker();
    public static MethodInfo get_CallSiteOps_GetMatch();
    public static MethodInfo get_CallSiteOps_ClearMatch();
    public static MethodInfo get_CallSiteOps_UpdateRules();
    public static MethodInfo get_CallSiteOps_GetRules();
    public static MethodInfo get_CallSiteOps_GetRuleCache();
    public static MethodInfo get_CallSiteOps_GetCachedRules();
    public static MethodInfo get_CallSiteOps_AddRule();
    public static MethodInfo get_CallSiteOps_MoveRule();
    public static MethodInfo get_CallSiteOps_Bind();
    public static MethodInfo get_DynamicObject_TryGetMember();
    public static MethodInfo get_DynamicObject_TrySetMember();
    public static MethodInfo get_DynamicObject_TryDeleteMember();
    public static MethodInfo get_DynamicObject_TryGetIndex();
    public static MethodInfo get_DynamicObject_TrySetIndex();
    public static MethodInfo get_DynamicObject_TryDeleteIndex();
    public static MethodInfo get_DynamicObject_TryConvert();
    public static MethodInfo get_DynamicObject_TryInvoke();
    public static MethodInfo get_DynamicObject_TryInvokeMember();
    public static MethodInfo get_DynamicObject_TryBinaryOperation();
    public static MethodInfo get_DynamicObject_TryUnaryOperation();
    public static MethodInfo get_DynamicObject_TryCreateInstance();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/CatchBlockProxy")]
public class System.Linq.Expressions.CatchBlock : object {
    [CompilerGeneratedAttribute]
private ParameterExpression <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Filter>k__BackingField;
    public ParameterExpression Variable { get; }
    public Type Test { get; }
    public Expression Body { get; }
    public Expression Filter { get; }
    internal CatchBlock(Type test, ParameterExpression variable, Expression body, Expression filter);
    [CompilerGeneratedAttribute]
public ParameterExpression get_Variable();
    [CompilerGeneratedAttribute]
public Type get_Test();
    [CompilerGeneratedAttribute]
public Expression get_Body();
    [CompilerGeneratedAttribute]
public Expression get_Filter();
    public virtual string ToString();
    public CatchBlock Update(ParameterExpression variable, Expression filter, Expression body);
}
internal class System.Linq.Expressions.ClearDebugInfoExpression : DebugInfoExpression {
    public bool IsClear { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    internal ClearDebugInfoExpression(SymbolDocumentInfo document);
    public virtual bool get_IsClear();
    public virtual int get_StartLine();
    public virtual int get_StartColumn();
    public virtual int get_EndLine();
    public virtual int get_EndColumn();
}
internal class System.Linq.Expressions.CoalesceConversionBinaryExpression : BinaryExpression {
    private LambdaExpression _conversion;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal CoalesceConversionBinaryExpression(Expression left, Expression right, LambdaExpression conversion);
    internal virtual LambdaExpression GetConversion();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.Compiler.AnalyzedTree : object {
    internal Dictionary`2<object, CompilerScope> Scopes;
    internal Dictionary`2<LambdaExpression, BoundConstants> Constants;
}
internal class System.Linq.Expressions.Compiler.AssemblyGen : object {
    private static AssemblyGen s_assembly;
    private ModuleBuilder _myModule;
    private int _index;
    private static AssemblyGen Assembly { get; }
    private static AssemblyGen get_Assembly();
    private TypeBuilder DefineType(string name, Type parent, TypeAttributes attr);
    internal static TypeBuilder DefineDelegateType(string name);
}
internal class System.Linq.Expressions.Compiler.BoundConstants : object {
    private List`1<object> _values;
    private Dictionary`2<object, int> _indexes;
    private Dictionary`2<TypedConstant, int> _references;
    private Dictionary`2<TypedConstant, LocalBuilder> _cache;
    internal int Count { get; }
    internal int get_Count();
    internal Object[] ToArray();
    internal void AddReference(object value, Type type);
    internal void EmitConstant(LambdaCompiler lc, object value, Type type);
    internal void EmitCacheConstants(LambdaCompiler lc);
    private static bool ShouldCache(int refCount);
    private static void EmitConstantsArray(LambdaCompiler lc);
    private void EmitConstantFromArray(LambdaCompiler lc, object value, Type type);
}
internal class System.Linq.Expressions.Compiler.CompilerScope : object {
    private CompilerScope _parent;
    internal object Node;
    internal bool IsMethod;
    internal bool NeedsClosure;
    internal Dictionary`2<ParameterExpression, VariableStorageKind> Definitions;
    internal Dictionary`2<ParameterExpression, int> ReferenceCount;
    internal HashSet`1<BlockExpression> MergedScopes;
    private HoistedLocals _hoistedLocals;
    private HoistedLocals _closureHoistedLocals;
    private Dictionary`2<ParameterExpression, Storage> _locals;
    internal HoistedLocals NearestHoistedLocals { get; }
    private string CurrentLambdaName { get; }
    internal CompilerScope(object node, bool isMethod);
    internal HoistedLocals get_NearestHoistedLocals();
    internal CompilerScope Enter(LambdaCompiler lc, CompilerScope parent);
    internal CompilerScope Exit();
    internal void EmitVariableAccess(LambdaCompiler lc, ReadOnlyCollection`1<ParameterExpression> vars);
    internal void AddLocal(LambdaCompiler gen, ParameterExpression variable);
    internal void EmitGet(ParameterExpression variable);
    internal void EmitSet(ParameterExpression variable);
    internal void EmitAddressOf(ParameterExpression variable);
    private Storage ResolveVariable(ParameterExpression variable);
    private Storage ResolveVariable(ParameterExpression variable, HoistedLocals hoistedLocals);
    private void SetParent(LambdaCompiler lc, CompilerScope parent);
    private void EmitNewHoistedLocals(LambdaCompiler lc);
    private void EmitCachedVariables();
    private bool ShouldCache(ParameterExpression v, int refCount);
    private bool ShouldCache(ParameterExpression v);
    private void CacheBoxToLocal(LambdaCompiler lc, ParameterExpression v);
    private void EmitClosureAccess(LambdaCompiler lc, HoistedLocals locals);
    private void EmitClosureToVariable(LambdaCompiler lc, HoistedLocals locals);
    private void AllocateLocals(LambdaCompiler lc);
    private IEnumerable`1<ParameterExpression> GetVariables();
    [IteratorStateMachineAttribute("System.Linq.Expressions.Compiler.CompilerScope/<GetVariablesIncludingMerged>d__32")]
private IEnumerable`1<ParameterExpression> GetVariablesIncludingMerged();
    private static IReadOnlyList`1<ParameterExpression> GetVariables(object scope);
    private string get_CurrentLambdaName();
    [CompilerGeneratedAttribute]
private bool <SetParent>b__22_0(ParameterExpression p);
}
internal static class System.Linq.Expressions.Compiler.DelegateHelpers : object {
    private static Type[] s_delegateCtorSignature;
    private static TypeInfo _DelegateCache;
    private static DelegateHelpers();
    internal static Type MakeCallSiteDelegate(ReadOnlyCollection`1<Expression> types, Type returnType);
    internal static Type MakeDeferredSiteDelegate(DynamicMetaObject[] args, Type returnType);
    private static bool IsByRef(DynamicMetaObject mo);
    private static Type MakeNewCustomDelegate(Type[] types);
    internal static Type MakeDelegateType(Type[] types);
    internal static TypeInfo NextTypeInfo(Type initialArg);
    internal static TypeInfo GetNextTypeInfo(Type initialArg, TypeInfo curTypeInfo);
    private static TypeInfo NextTypeInfo(Type initialArg, TypeInfo curTypeInfo);
    internal static Type MakeNewDelegate(Type[] types);
    internal static Type GetFuncType(Type[] types);
    internal static Type GetActionType(Type[] types);
}
internal class System.Linq.Expressions.Compiler.HoistedLocals : object {
    internal HoistedLocals Parent;
    internal ReadOnlyDictionary`2<Expression, int> Indexes;
    internal ReadOnlyCollection`1<ParameterExpression> Variables;
    internal ParameterExpression SelfVariable;
    internal ParameterExpression ParentVariable { get; }
    internal HoistedLocals(HoistedLocals parent, ReadOnlyCollection`1<ParameterExpression> vars);
    internal ParameterExpression get_ParentVariable();
    internal static Object[] GetParent(Object[] locals);
}
[ExtensionAttribute]
internal static class System.Linq.Expressions.Compiler.ILGen : object {
    [ExtensionAttribute]
internal static void Emit(ILGenerator il, OpCode opcode, MethodBase methodBase);
    [ExtensionAttribute]
internal static void EmitLoadArg(ILGenerator il, int index);
    [ExtensionAttribute]
internal static void EmitLoadArgAddress(ILGenerator il, int index);
    [ExtensionAttribute]
internal static void EmitStoreArg(ILGenerator il, int index);
    [ExtensionAttribute]
internal static void EmitLoadValueIndirect(ILGenerator il, Type type);
    [ExtensionAttribute]
internal static void EmitStoreValueIndirect(ILGenerator il, Type type);
    [ExtensionAttribute]
internal static void EmitLoadElement(ILGenerator il, Type type);
    [ExtensionAttribute]
internal static void EmitStoreElement(ILGenerator il, Type type);
    [ExtensionAttribute]
internal static void EmitType(ILGenerator il, Type type);
    [ExtensionAttribute]
internal static void EmitFieldAddress(ILGenerator il, FieldInfo fi);
    [ExtensionAttribute]
internal static void EmitFieldGet(ILGenerator il, FieldInfo fi);
    [ExtensionAttribute]
internal static void EmitFieldSet(ILGenerator il, FieldInfo fi);
    [ExtensionAttribute]
internal static void EmitNew(ILGenerator il, ConstructorInfo ci);
    [ExtensionAttribute]
internal static void EmitNull(ILGenerator il);
    [ExtensionAttribute]
internal static void EmitString(ILGenerator il, string value);
    [ExtensionAttribute]
internal static void EmitPrimitive(ILGenerator il, bool value);
    [ExtensionAttribute]
internal static void EmitPrimitive(ILGenerator il, int value);
    [ExtensionAttribute]
private static void EmitPrimitive(ILGenerator il, UInt32 value);
    [ExtensionAttribute]
private static void EmitPrimitive(ILGenerator il, long value);
    [ExtensionAttribute]
private static void EmitPrimitive(ILGenerator il, ulong value);
    [ExtensionAttribute]
private static void EmitPrimitive(ILGenerator il, double value);
    [ExtensionAttribute]
private static void EmitPrimitive(ILGenerator il, float value);
    internal static bool CanEmitConstant(object value, Type type);
    private static bool CanEmitILConstant(Type type);
    [ExtensionAttribute]
internal static bool TryEmitConstant(ILGenerator il, object value, Type type, ILocalCache locals);
    private static bool ShouldLdtoken(Type t);
    internal static bool ShouldLdtoken(MethodBase mb);
    [ExtensionAttribute]
private static bool TryEmitILConstant(ILGenerator il, object value, Type type);
    [ExtensionAttribute]
internal static void EmitConvertToType(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
private static void EmitCastToType(ILGenerator il, Type typeFrom, Type typeTo);
    [ExtensionAttribute]
private static void EmitNumericConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked);
    [ExtensionAttribute]
private static void EmitNullableToNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
private static void EmitNonNullableToNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
private static void EmitNullableToNonNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
private static void EmitNullableToNonNullableStructConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
private static void EmitNullableToReferenceConversion(ILGenerator il, Type typeFrom);
    [ExtensionAttribute]
private static void EmitNullableConversion(ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals);
    [ExtensionAttribute]
internal static void EmitHasValue(ILGenerator il, Type nullableType);
    [ExtensionAttribute]
internal static void EmitGetValue(ILGenerator il, Type nullableType);
    [ExtensionAttribute]
internal static void EmitGetValueOrDefault(ILGenerator il, Type nullableType);
    [ExtensionAttribute]
internal static void EmitArray(ILGenerator il, Type elementType, int count);
    [ExtensionAttribute]
internal static void EmitArray(ILGenerator il, Type arrayType);
    [ExtensionAttribute]
private static void EmitDecimal(ILGenerator il, decimal value);
    [ExtensionAttribute]
internal static void EmitDefault(ILGenerator il, Type type, ILocalCache locals);
}
internal interface System.Linq.Expressions.Compiler.ILocalCache {
    public abstract virtual LocalBuilder GetLocal(Type type);
    public abstract virtual void FreeLocal(LocalBuilder local);
}
internal class System.Linq.Expressions.Compiler.KeyedStack`2 : object {
    private Dictionary`2<TKey, Stack`1<TValue>> _data;
    internal void Push(TKey key, TValue value);
    internal TValue TryPop(TKey key);
}
internal class System.Linq.Expressions.Compiler.LabelInfo : object {
    private LabelTarget _node;
    private Label _label;
    private bool _labelDefined;
    private LocalBuilder _value;
    private HashSet`1<LabelScopeInfo> _definitions;
    private List`1<LabelScopeInfo> _references;
    private bool _canReturn;
    private bool _acrossBlockJump;
    private OpCode _opCode;
    private ILGenerator _ilg;
    internal Label Label { get; }
    internal bool CanReturn { get; }
    internal bool CanBranch { get; }
    internal LabelInfo(ILGenerator il, LabelTarget node, bool canReturn);
    internal Label get_Label();
    internal bool get_CanReturn();
    internal bool get_CanBranch();
    internal void Reference(LabelScopeInfo block);
    internal void Define(LabelScopeInfo block);
    private void ValidateJump(LabelScopeInfo reference);
    internal void ValidateFinish();
    internal void EmitJump();
    private void StoreValue();
    internal void Mark();
    internal void MarkWithEmptyStack();
    private void EnsureLabelAndValue();
}
internal class System.Linq.Expressions.Compiler.LabelScopeInfo : object {
    private Dictionary`2<LabelTarget, LabelInfo> _labels;
    internal LabelScopeKind Kind;
    internal LabelScopeInfo Parent;
    internal bool CanJumpInto { get; }
    internal LabelScopeInfo(LabelScopeInfo parent, LabelScopeKind kind);
    internal bool get_CanJumpInto();
    internal bool ContainsTarget(LabelTarget target);
    internal bool TryGetLabelInfo(LabelTarget target, LabelInfo& info);
    internal void AddLabelInfo(LabelTarget target, LabelInfo info);
}
internal enum System.Linq.Expressions.Compiler.LabelScopeKind : Enum {
    public int value__;
    public static LabelScopeKind Statement;
    public static LabelScopeKind Block;
    public static LabelScopeKind Switch;
    public static LabelScopeKind Lambda;
    public static LabelScopeKind Try;
    public static LabelScopeKind Catch;
    public static LabelScopeKind Finally;
    public static LabelScopeKind Filter;
    public static LabelScopeKind Expression;
}
internal class System.Linq.Expressions.Compiler.LambdaCompiler : object {
    private AnalyzedTree _tree;
    private ILGenerator _ilg;
    private MethodInfo _method;
    private LabelScopeInfo _labelBlock;
    private Dictionary`2<LabelTarget, LabelInfo> _labelInfo;
    private CompilerScope _scope;
    private LambdaExpression _lambda;
    private bool _hasClosureArgument;
    private BoundConstants _boundConstants;
    private KeyedStack`2<Type, LocalBuilder> _freeLocals;
    private StackGuard _guard;
    internal ILGenerator IL { get; }
    internal IParameterProvider Parameters { get; }
    private LambdaCompiler(AnalyzedTree tree, LambdaExpression lambda);
    private LambdaCompiler(LambdaCompiler parent, LambdaExpression lambda, InvocationExpression invocation);
    private void EmitAddress(Expression node, Type type);
    private void EmitAddress(Expression node, Type type, CompilationFlags flags);
    private void AddressOf(BinaryExpression node, Type type);
    private void AddressOf(ParameterExpression node, Type type);
    private void AddressOf(MemberExpression node, Type type);
    private void EmitMemberAddress(MemberInfo member, Type objectType);
    private void AddressOf(MethodCallExpression node, Type type);
    private void AddressOf(IndexExpression node, Type type);
    private void AddressOf(UnaryExpression node, Type type);
    private void EmitExpressionAddress(Expression node, Type type);
    private WriteBack EmitAddressWriteBack(Expression node, Type type);
    private WriteBack AddressOfWriteBack(MemberExpression node);
    private WriteBack AddressOfWriteBackCore(MemberExpression node);
    private WriteBack AddressOfWriteBack(IndexExpression node);
    private WriteBack AddressOfWriteBackCore(IndexExpression node);
    private LocalBuilder GetInstanceLocal(Type type);
    private void EmitBinaryExpression(Expression expr);
    private void EmitBinaryExpression(Expression expr, CompilationFlags flags);
    private void EmitNullEquality(ExpressionType op, Expression e, bool isLiftedToNull);
    private void EmitBinaryMethod(BinaryExpression b, CompilationFlags flags);
    private void EmitBinaryOperator(ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull);
    private void EmitUnliftedBinaryOp(ExpressionType op, Type leftType, Type rightType);
    private void EmitShiftMask(Type leftType);
    private void EmitConvertArithmeticResult(ExpressionType op, Type resultType);
    private void EmitLiftedBinaryOp(ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull);
    private void EmitLiftedRelational(ExpressionType op, Type type);
    private void EmitLiftedToNullRelational(ExpressionType op, Type type);
    private void EmitLiftedBinaryArithmetic(ExpressionType op, Type leftType, Type rightType, Type resultType);
    private void EmitLiftedBooleanAnd();
    private void EmitLiftedBooleanOr();
    private LabelInfo EnsureLabel(LabelTarget node);
    private LabelInfo ReferenceLabel(LabelTarget node);
    private LabelInfo DefineLabel(LabelTarget node);
    private void PushLabelBlock(LabelScopeKind type);
    private void PopLabelBlock(LabelScopeKind kind);
    private void EmitLabelExpression(Expression expr, CompilationFlags flags);
    private void EmitGotoExpression(Expression expr, CompilationFlags flags);
    private void EmitUnreachable(Expression node, CompilationFlags flags);
    private bool TryPushLabelBlock(Expression node);
    private void DefineBlockLabels(Expression node);
    private void AddReturnLabel(LambdaExpression lambda);
    private void InitializeMethod();
    internal ILGenerator get_IL();
    internal IParameterProvider get_Parameters();
    internal static Delegate Compile(LambdaExpression lambda);
    private static AnalyzedTree AnalyzeLambda(LambdaExpression& lambda);
    public sealed virtual LocalBuilder GetLocal(Type type);
    public sealed virtual void FreeLocal(LocalBuilder local);
    internal int GetLambdaArgument(int index);
    internal void EmitLambdaArgument(int index);
    internal void EmitClosureArgument();
    private Delegate CreateDelegate();
    private MemberExpression CreateLazyInitializedField(string name);
    private static CompilationFlags UpdateEmitAsTailCallFlag(CompilationFlags flags, CompilationFlags newValue);
    private static CompilationFlags UpdateEmitExpressionStartFlag(CompilationFlags flags, CompilationFlags newValue);
    private static CompilationFlags UpdateEmitAsTypeFlag(CompilationFlags flags, CompilationFlags newValue);
    internal void EmitExpression(Expression node);
    private void EmitExpressionAsVoid(Expression node);
    private void EmitExpressionAsVoid(Expression node, CompilationFlags flags);
    private void EmitExpressionAsType(Expression node, Type type, CompilationFlags flags);
    private CompilationFlags EmitExpressionStart(Expression node);
    private void EmitExpressionEnd(CompilationFlags flags);
    private void EmitInvocationExpression(Expression expr, CompilationFlags flags);
    private void EmitInlinedInvoke(InvocationExpression invoke, CompilationFlags flags);
    private void EmitIndexExpression(Expression expr);
    private void EmitIndexAssignment(AssignBinaryExpression node, CompilationFlags flags);
    private void EmitGetIndexCall(IndexExpression node, Type objectType);
    private void EmitGetArrayElement(Type arrayType);
    private void EmitSetIndexCall(IndexExpression node, Type objectType);
    private void EmitSetArrayElement(Type arrayType);
    private void EmitMethodCallExpression(Expression expr, CompilationFlags flags);
    private void EmitMethodCallExpression(Expression expr);
    private void EmitMethodCall(Expression obj, MethodInfo method, IArgumentProvider methodCallExpr);
    private void EmitMethodCall(Expression obj, MethodInfo method, IArgumentProvider methodCallExpr, CompilationFlags flags);
    private void EmitMethodCall(MethodInfo mi, IArgumentProvider args, Type objectType);
    private void EmitMethodCall(MethodInfo mi, IArgumentProvider args, Type objectType, CompilationFlags flags);
    private static bool MethodHasByRefParameter(MethodInfo mi);
    private void EmitCall(Type objectType, MethodInfo method);
    private static bool UseVirtual(MethodInfo mi);
    private List`1<WriteBack> EmitArguments(MethodBase method, IArgumentProvider args);
    private List`1<WriteBack> EmitArguments(MethodBase method, IArgumentProvider args, int skipParameters);
    private void EmitWriteBack(List`1<WriteBack> writeBacks);
    private void EmitConstantExpression(Expression expr);
    private void EmitConstant(object value);
    private void EmitConstant(object value, Type type);
    private void EmitDynamicExpression(Expression expr);
    private void EmitNewExpression(Expression expr);
    private void EmitTypeBinaryExpression(Expression expr);
    private void EmitVariableAssignment(AssignBinaryExpression node, CompilationFlags flags);
    private void EmitAssignBinaryExpression(Expression expr);
    private void EmitAssign(AssignBinaryExpression node, CompilationFlags emitAs);
    private void EmitParameterExpression(Expression expr);
    private void EmitLambdaExpression(Expression expr);
    private void EmitRuntimeVariablesExpression(Expression expr);
    private void EmitMemberAssignment(AssignBinaryExpression node, CompilationFlags flags);
    private void EmitMemberExpression(Expression expr);
    private void EmitMemberGet(MemberInfo member, Type objectType);
    private void EmitInstance(Expression instance, Type& type);
    private void EmitNewArrayExpression(Expression expr);
    private void EmitDebugInfoExpression(Expression expr);
    private void EmitListInitExpression(Expression expr);
    private void EmitMemberInitExpression(Expression expr);
    private void EmitBinding(MemberBinding binding, Type objectType);
    private void EmitMemberAssignment(MemberAssignment binding, Type objectType);
    private void EmitMemberMemberBinding(MemberMemberBinding binding);
    private void EmitMemberListBinding(MemberListBinding binding);
    private void EmitMemberInit(MemberInitExpression init);
    private void EmitMemberInit(ReadOnlyCollection`1<MemberBinding> bindings, bool keepOnStack, Type objectType);
    private void EmitListInit(ListInitExpression init);
    private void EmitListInit(ReadOnlyCollection`1<ElementInit> initializers, bool keepOnStack, Type objectType);
    private static Type GetMemberType(MemberInfo member);
    private void EmitLift(ExpressionType nodeType, Type resultType, MethodCallExpression mc, ParameterExpression[] paramList, Expression[] argList);
    private void EmitExpression(Expression node, CompilationFlags flags);
    private static bool IsChecked(ExpressionType op);
    internal void EmitConstantArray(T[] array);
    private void EmitClosureCreation(LambdaCompiler inner);
    private void EmitDelegateConstruction(LambdaCompiler inner);
    private void EmitDelegateConstruction(LambdaExpression lambda);
    private static Type[] GetParameterTypes(LambdaExpression lambda, Type firstType);
    private void EmitLambdaBody();
    private void EmitLambdaBody(CompilerScope parent, bool inlined, CompilationFlags flags);
    private void EmitConditionalExpression(Expression expr, CompilationFlags flags);
    private static bool NotEmpty(Expression node);
    private static bool Significant(Expression node);
    private void EmitCoalesceBinaryExpression(Expression expr);
    private void EmitNullableCoalesce(BinaryExpression b);
    private void EmitLambdaReferenceCoalesce(BinaryExpression b);
    private void EmitReferenceCoalesceWithoutConversion(BinaryExpression b);
    private void EmitLiftedAndAlso(BinaryExpression b);
    private void EmitMethodAndAlso(BinaryExpression b, CompilationFlags flags);
    private void EmitUnliftedAndAlso(BinaryExpression b);
    private void EmitAndAlsoBinaryExpression(Expression expr, CompilationFlags flags);
    private void EmitLiftedOrElse(BinaryExpression b);
    private void EmitUnliftedOrElse(BinaryExpression b);
    private void EmitMethodOrElse(BinaryExpression b, CompilationFlags flags);
    private void EmitOrElseBinaryExpression(Expression expr, CompilationFlags flags);
    private void EmitExpressionAndBranch(bool branchValue, Expression node, Label label);
    private void EmitBranchOp(bool branch, Label label);
    private void EmitBranchNot(bool branch, UnaryExpression node, Label label);
    private void EmitBranchComparison(bool branch, BinaryExpression node, Label label);
    private static Expression GetEqualityOperand(Expression expression);
    private void EmitBranchLogical(bool branch, BinaryExpression node, Label label);
    private void EmitBranchAnd(bool branch, BinaryExpression node, Label label);
    private void EmitBranchOr(bool branch, BinaryExpression node, Label label);
    private void EmitBranchBlock(bool branch, BlockExpression node, Label label);
    private void EmitBlockExpression(Expression expr, CompilationFlags flags);
    private void Emit(BlockExpression node, CompilationFlags flags);
    private void EnterScope(object node);
    private static bool HasVariables(object node);
    private void ExitScope(object node);
    private void EmitDefaultExpression(Expression expr);
    private void EmitLoopExpression(Expression expr);
    private void EmitSwitchExpression(Expression expr, CompilationFlags flags);
    private static Type GetTestValueType(SwitchExpression node);
    private static bool FitsInBucket(List`1<SwitchLabel> buckets, decimal key, int count);
    private static void MergeBuckets(List`1<List`1<SwitchLabel>> buckets);
    private static void AddToBuckets(List`1<List`1<SwitchLabel>> buckets, SwitchLabel key);
    private static bool CanOptimizeSwitchType(Type valueType);
    private bool TryEmitSwitchInstruction(SwitchExpression node, CompilationFlags flags);
    private static decimal ConvertSwitchValue(object value);
    private void DefineSwitchCaseLabel(SwitchCase case, Label& label, Boolean& isGoto);
    private void EmitSwitchCases(SwitchExpression node, Label[] labels, Boolean[] isGoto, Label default, Label end, CompilationFlags flags);
    private void EmitSwitchBuckets(SwitchInfo info, List`1<List`1<SwitchLabel>> buckets, int first, int last);
    private void EmitSwitchBucket(SwitchInfo info, List`1<SwitchLabel> bucket);
    private bool TryEmitHashtableSwitch(SwitchExpression node, CompilationFlags flags);
    private void CheckRethrow();
    private void CheckTry();
    private void EmitSaveExceptionOrPop(CatchBlock cb);
    private void EmitTryExpression(Expression expr);
    private void EmitCatchStart(CatchBlock cb);
    private void EmitQuoteUnaryExpression(Expression expr);
    private void EmitQuote(UnaryExpression quote);
    private void EmitThrowUnaryExpression(Expression expr);
    private void EmitThrow(UnaryExpression expr, CompilationFlags flags);
    private void EmitUnaryExpression(Expression expr, CompilationFlags flags);
    private void EmitUnary(UnaryExpression node, CompilationFlags flags);
    private void EmitUnaryOperator(ExpressionType op, Type operandType, Type resultType);
    private void EmitConstantOne(Type type);
    private void EmitUnboxUnaryExpression(Expression expr);
    private void EmitConvertUnaryExpression(Expression expr, CompilationFlags flags);
    private void EmitConvert(UnaryExpression node, CompilationFlags flags);
    private void EmitUnaryMethod(UnaryExpression node, CompilationFlags flags);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Expressions.Compiler.ParameterList : object {
    private IParameterProvider _provider;
    public ParameterExpression Item { get; }
    public int Count { get; }
    public ParameterList(IParameterProvider provider);
    public sealed virtual ParameterExpression get_Item(int index);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("System.Linq.Expressions.Compiler.ParameterList/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<ParameterExpression> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class System.Linq.Expressions.Compiler.ParameterProviderExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(IParameterProvider provider, ParameterExpression parameter);
    [ExtensionAttribute]
public static bool Contains(IParameterProvider provider, ParameterExpression parameter);
}
internal class System.Linq.Expressions.Compiler.SpilledExpressionBlock : BlockN {
    internal SpilledExpressionBlock(IReadOnlyList`1<Expression> expressions);
    [ExcludeFromCodeCoverageAttribute]
internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.Compiler.StackSpiller : object {
    private Stack _startingStack;
    private RewriteAction _lambdaRewrite;
    private StackGuard _guard;
    private TempMaker _tm;
    private StackSpiller(Stack stack);
    internal static LambdaExpression AnalyzeLambda(LambdaExpression lambda);
    internal Expression`1<T> Rewrite(Expression`1<T> lambda);
    private Result RewriteExpressionFreeTemps(Expression expression, Stack stack);
    private Result RewriteDynamicExpression(Expression expr);
    private Result RewriteIndexAssignment(BinaryExpression node, Stack stack);
    private Result RewriteLogicalBinaryExpression(Expression expr, Stack stack);
    private Result RewriteReducibleExpression(Expression expr, Stack stack);
    private Result RewriteBinaryExpression(Expression expr, Stack stack);
    private Result RewriteVariableAssignment(BinaryExpression node, Stack stack);
    private Result RewriteAssignBinaryExpression(Expression expr, Stack stack);
    private Result RewriteExtensionAssignment(BinaryExpression node, Stack stack);
    private static Result RewriteLambdaExpression(Expression expr);
    private Result RewriteConditionalExpression(Expression expr, Stack stack);
    private Result RewriteMemberAssignment(BinaryExpression node, Stack stack);
    private Result RewriteMemberExpression(Expression expr, Stack stack);
    private Result RewriteIndexExpression(Expression expr, Stack stack);
    private Result RewriteMethodCallExpression(Expression expr, Stack stack);
    private Result RewriteNewArrayExpression(Expression expr, Stack stack);
    private Result RewriteInvocationExpression(Expression expr, Stack stack);
    private Result RewriteNewExpression(Expression expr, Stack stack);
    private Result RewriteTypeBinaryExpression(Expression expr, Stack stack);
    private Result RewriteThrowUnaryExpression(Expression expr, Stack stack);
    private Result RewriteUnaryExpression(Expression expr, Stack stack);
    private Result RewriteListInitExpression(Expression expr, Stack stack);
    private Result RewriteMemberInitExpression(Expression expr, Stack stack);
    private Result RewriteBlockExpression(Expression expr, Stack stack);
    private Result RewriteLabelExpression(Expression expr, Stack stack);
    private Result RewriteLoopExpression(Expression expr, Stack stack);
    private Result RewriteGotoExpression(Expression expr, Stack stack);
    private Result RewriteSwitchExpression(Expression expr, Stack stack);
    private Result RewriteTryExpression(Expression expr, Stack stack);
    private Result RewriteExtensionExpression(Expression expr, Stack stack);
    private static T[] Clone(ReadOnlyCollection`1<T> original, int max);
    private static void RequireNoRefArgs(MethodBase method);
    private static void RequireNotRefInstance(Expression instance);
    private static bool IsRefInstance(Expression instance);
    private Result RewriteExpression(Expression node, Stack stack);
    private static Expression MakeBlock(ArrayBuilder`1<Expression> expressions);
    private static Expression MakeBlock(Expression[] expressions);
    private static Expression MakeBlock(IReadOnlyList`1<Expression> expressions);
    private ParameterExpression MakeTemp(Type type);
    private int Mark();
    private void Free(int mark);
    private ParameterExpression ToTemp(Expression expression, Expression& save, bool byRef);
}
[ExtensionAttribute]
internal static class System.Linq.Expressions.Compiler.TypeInfoExtensions : object {
    [ExtensionAttribute]
public static Type MakeDelegateType(TypeInfo info, Type retType, Expression[] args);
    [ExtensionAttribute]
public static Type MakeDelegateType(TypeInfo info, Type retType, IList`1<Expression> args);
}
internal class System.Linq.Expressions.Compiler.VariableBinder : ExpressionVisitor {
    private AnalyzedTree _tree;
    private Stack`1<CompilerScope> _scopes;
    private Stack`1<BoundConstants> _constants;
    private StackGuard _guard;
    private bool _inQuote;
    private string CurrentLambdaName { get; }
    internal static AnalyzedTree Bind(LambdaExpression lambda);
    public virtual Expression Visit(Expression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    private ReadOnlyCollection`1<Expression> MergeScopes(Expression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    private void Reference(ParameterExpression node, VariableStorageKind storage);
    private string get_CurrentLambdaName();
}
internal enum System.Linq.Expressions.Compiler.VariableStorageKind : Enum {
    public int value__;
    public static VariableStorageKind Local;
    public static VariableStorageKind Hoisted;
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ConditionalExpressionProxy")]
public class System.Linq.Expressions.ConditionalExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <IfTrue>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression Test { get; }
    public Expression IfTrue { get; }
    public Expression IfFalse { get; }
    internal ConditionalExpression(Expression test, Expression ifTrue);
    internal static ConditionalExpression Make(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public Expression get_Test();
    [CompilerGeneratedAttribute]
public Expression get_IfTrue();
    public Expression get_IfFalse();
    internal virtual Expression GetFalse();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public ConditionalExpression Update(Expression test, Expression ifTrue, Expression ifFalse);
}
internal static class System.Linq.Expressions.ConstantCheck : object {
    internal static bool IsNull(Expression e);
    internal static AnalyzeTypeIsResult AnalyzeTypeIs(TypeBinaryExpression typeIs);
    private static AnalyzeTypeIsResult AnalyzeTypeIs(Expression operand, Type testType);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ConstantExpressionProxy")]
public class System.Linq.Expressions.ConstantExpression : Expression {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public object Value { get; }
    internal ConstantExpression(object value);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public object get_Value();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/DebugInfoExpressionProxy")]
public class System.Linq.Expressions.DebugInfoExpression : Expression {
    [CompilerGeneratedAttribute]
private SymbolDocumentInfo <Document>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    [ExcludeFromCodeCoverageAttribute]
public int StartLine { get; }
    [ExcludeFromCodeCoverageAttribute]
public int StartColumn { get; }
    [ExcludeFromCodeCoverageAttribute]
public int EndLine { get; }
    [ExcludeFromCodeCoverageAttribute]
public int EndColumn { get; }
    public SymbolDocumentInfo Document { get; }
    [ExcludeFromCodeCoverageAttribute]
public bool IsClear { get; }
    internal DebugInfoExpression(SymbolDocumentInfo document);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    public virtual int get_StartLine();
    public virtual int get_StartColumn();
    public virtual int get_EndLine();
    public virtual int get_EndColumn();
    [CompilerGeneratedAttribute]
public SymbolDocumentInfo get_Document();
    public virtual bool get_IsClear();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
internal class System.Linq.Expressions.DebugViewWriter : ExpressionVisitor {
    private TextWriter _out;
    private int _column;
    private Stack`1<int> _stack;
    private int _delta;
    private Flow _flow;
    private Queue`1<LambdaExpression> _lambdas;
    private Dictionary`2<LambdaExpression, int> _lambdaIds;
    private Dictionary`2<ParameterExpression, int> _paramIds;
    private Dictionary`2<LabelTarget, int> _labelIds;
    private int Base { get; }
    private int Delta { get; }
    private int Depth { get; }
    private DebugViewWriter(TextWriter file);
    private int get_Base();
    private int get_Delta();
    private int get_Depth();
    private void Indent();
    private void Dedent();
    private void NewLine();
    private static int GetId(T e, Dictionary`2& ids);
    private int GetLambdaId(LambdaExpression le);
    private int GetParamId(ParameterExpression p);
    private int GetLabelTargetId(LabelTarget target);
    internal static void WriteTo(Expression node, TextWriter writer);
    private void WriteTo(Expression node);
    private void Out(string s);
    private void Out(Flow before, string s);
    private void Out(string s, Flow after);
    private void Out(Flow before, string s, Flow after);
    private void WriteLine();
    private void Write(string s);
    private Flow GetFlow(Flow flow);
    private Flow CheckBreak(Flow flow);
    private void VisitExpressions(char open, IReadOnlyList`1<T> expressions);
    private void VisitExpressions(char open, char separator, IReadOnlyList`1<T> expressions);
    private void VisitDeclarations(IReadOnlyList`1<ParameterExpression> expressions);
    private void VisitExpressions(char open, char separator, IReadOnlyList`1<T> expressions, Action`1<T> visit);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    private static bool IsSimpleExpression(Expression node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    private static string GetConstantValueSuffix(Type type);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    private void OutMember(Expression node, Expression instance, MemberInfo member);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    private static bool NeedsParentheses(Expression parent, Expression child);
    private static int GetOperatorPrecedence(Expression node);
    private void ParenthesizedVisit(Expression parent, Expression nodeToVisit);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitExtension(Expression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    private void DumpLabel(LabelTarget target);
    private string GetLabelTargetName(LabelTarget target);
    private void WriteLambda(LambdaExpression lambda);
    private string GetLambdaName(LambdaExpression lambda);
    private static bool ContainsWhiteSpace(string name);
    private static string QuoteName(string name);
    private static string GetDisplayName(string name);
    [CompilerGeneratedAttribute]
private void <VisitExpressions>b__37_0(T e);
    [CompilerGeneratedAttribute]
private void <VisitDeclarations>b__38_0(ParameterExpression variable);
    [CompilerGeneratedAttribute]
private void <VisitListInit>b__58_0(ElementInit e);
    [CompilerGeneratedAttribute]
private void <VisitMemberListBinding>b__60_0(ElementInit e);
    [CompilerGeneratedAttribute]
private void <VisitMemberMemberBinding>b__61_0(MemberBinding e);
    [CompilerGeneratedAttribute]
private void <VisitMemberInit>b__62_0(MemberBinding e);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/DefaultExpressionProxy")]
public class System.Linq.Expressions.DefaultExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal DefaultExpression(Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
public class System.Linq.Expressions.DynamicExpression : Expression {
    [CompilerGeneratedAttribute]
private CallSiteBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DelegateType>k__BackingField;
    public bool CanReduce { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public CallSiteBinder Binder { get; }
    public Type DelegateType { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    [ExcludeFromCodeCoverageAttribute]
private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression(Type delegateType, CallSiteBinder binder);
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, ReadOnlyCollection`1<Expression> arguments);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public CallSiteBinder get_Binder();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DelegateType();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    [ExcludeFromCodeCoverageAttribute]
internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    [ExcludeFromCodeCoverageAttribute]
internal virtual DynamicExpression Rewrite(Expression[] args);
    public DynamicExpression Update(IEnumerable`1<Expression> arguments);
    [ExcludeFromCodeCoverageAttribute]
internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    private sealed virtual override Expression System.Linq.Expressions.IDynamicExpression.Rewrite(Expression[] args);
    private sealed virtual override object System.Linq.Expressions.IDynamicExpression.CreateCallSite();
}
internal class System.Linq.Expressions.DynamicExpression1 : DynamicExpression {
    private object _arg0;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression1(Type delegateType, CallSiteBinder binder, Expression arg0);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpression2 : DynamicExpression {
    private object _arg0;
    private Expression _arg1;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression2(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpression3 : DynamicExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression3(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpression4 : DynamicExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpression4(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
internal class System.Linq.Expressions.DynamicExpressionN : DynamicExpression {
    private IReadOnlyList`1<Expression> _arguments;
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    internal DynamicExpressionN(Type delegateType, CallSiteBinder binder, IReadOnlyList`1<Expression> arguments);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual DynamicExpression Rewrite(Expression[] args);
}
public class System.Linq.Expressions.DynamicExpressionVisitor : ExpressionVisitor {
    protected internal virtual Expression VisitDynamic(DynamicExpression node);
}
public class System.Linq.Expressions.ElementInit : object {
    [CompilerGeneratedAttribute]
private MethodInfo <AddMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Expression> <Arguments>k__BackingField;
    public MethodInfo AddMethod { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal ElementInit(MethodInfo addMethod, ReadOnlyCollection`1<Expression> arguments);
    [CompilerGeneratedAttribute]
public MethodInfo get_AddMethod();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Expression> get_Arguments();
    public sealed virtual Expression GetArgument(int index);
    public sealed virtual int get_ArgumentCount();
    public virtual string ToString();
    public ElementInit Update(IEnumerable`1<Expression> arguments);
}
internal static class System.Linq.Expressions.Error : object {
    internal static Exception ReducibleMustOverrideReduce();
    internal static Exception ArgCntMustBeGreaterThanNameCnt();
    internal static Exception InvalidMetaObjectCreated(object p0);
    internal static Exception AmbiguousMatchInExpandoObject(object p0);
    internal static Exception SameKeyExistsInExpando(object key);
    internal static Exception KeyDoesNotExistInExpando(object p0);
    internal static Exception CollectionModifiedWhileEnumerating();
    internal static Exception CollectionReadOnly();
    internal static Exception MustReduceToDifferent();
    internal static Exception BinderNotCompatibleWithCallSite(object p0, object p1, object p2);
    internal static Exception DynamicBindingNeedsRestrictions(object p0, object p1);
    internal static Exception DynamicObjectResultNotAssignable(object p0, object p1, object p2, object p3);
    internal static Exception DynamicBinderResultNotAssignable(object p0, object p1, object p2);
    internal static Exception BindingCannotBeNull();
    internal static Exception ReducedNotCompatible();
    internal static Exception SetterHasNoParams(string paramName);
    internal static Exception PropertyCannotHaveRefType(string paramName);
    internal static Exception IndexesOfSetGetMustMatch(string paramName);
    internal static Exception TypeParameterIsNotDelegate(object p0);
    internal static Exception FirstArgumentMustBeCallSite();
    internal static Exception AccessorsCannotHaveVarArgs(string paramName);
    private static Exception AccessorsCannotHaveByRefArgs(string paramName);
    internal static Exception AccessorsCannotHaveByRefArgs(string paramName, int index);
    internal static Exception TypeMustBeDerivedFromSystemDelegate();
    internal static Exception NoOrInvalidRuleProduced();
    internal static Exception BoundsCannotBeLessThanOne(string paramName);
    internal static Exception TypeMustNotBeByRef(string paramName);
    internal static Exception TypeMustNotBePointer(string paramName);
    internal static Exception SetterMustBeVoid(string paramName);
    internal static Exception PropertyTypeMustMatchGetter(string paramName);
    internal static Exception PropertyTypeMustMatchSetter(string paramName);
    internal static Exception BothAccessorsMustBeStatic(string paramName);
    internal static Exception OnlyStaticFieldsHaveNullInstance(string paramName);
    internal static Exception OnlyStaticPropertiesHaveNullInstance(string paramName);
    internal static Exception OnlyStaticMethodsHaveNullInstance();
    internal static Exception PropertyTypeCannotBeVoid(string paramName);
    internal static Exception InvalidUnboxType(string paramName);
    internal static Exception ExpressionMustBeWriteable(string paramName);
    internal static Exception ArgumentMustNotHaveValueType(string paramName);
    internal static Exception MustBeReducible();
    internal static Exception AllTestValuesMustHaveSameType(string paramName);
    internal static Exception AllCaseBodiesMustHaveSameType(string paramName);
    internal static Exception DefaultBodyMustBeSupplied(string paramName);
    internal static Exception LabelMustBeVoidOrHaveExpression(string paramName);
    internal static Exception LabelTypeMustBeVoid(string paramName);
    internal static Exception QuotedExpressionMustBeLambda(string paramName);
    internal static Exception VariableMustNotBeByRef(object p0, object p1, string paramName);
    internal static Exception VariableMustNotBeByRef(object p0, object p1, string paramName, int index);
    private static Exception DuplicateVariable(object p0, string paramName);
    internal static Exception DuplicateVariable(object p0, string paramName, int index);
    internal static Exception StartEndMustBeOrdered();
    internal static Exception FaultCannotHaveCatchOrFinally(string paramName);
    internal static Exception TryMustHaveCatchFinallyOrFault();
    internal static Exception BodyOfCatchMustHaveSameTypeAsBodyOfTry();
    internal static Exception ExtensionNodeMustOverrideProperty(object p0);
    internal static Exception UserDefinedOperatorMustBeStatic(object p0, string paramName);
    internal static Exception UserDefinedOperatorMustNotBeVoid(object p0, string paramName);
    internal static Exception CoercionOperatorNotDefined(object p0, object p1);
    internal static Exception UnaryOperatorNotDefined(object p0, object p1);
    internal static Exception BinaryOperatorNotDefined(object p0, object p1, object p2);
    internal static Exception ReferenceEqualityNotDefined(object p0, object p1);
    internal static Exception OperandTypesDoNotMatchParameters(object p0, object p1);
    internal static Exception OverloadOperatorTypeDoesNotMatchConversionType(object p0, object p1);
    internal static Exception ConversionIsNotSupportedForArithmeticTypes();
    internal static Exception ArgumentTypeCannotBeVoid();
    internal static Exception ArgumentMustBeArray(string paramName);
    internal static Exception ArgumentMustBeBoolean(string paramName);
    internal static Exception EqualityMustReturnBoolean(object p0, string paramName);
    internal static Exception ArgumentMustBeFieldInfoOrPropertyInfo(string paramName);
    private static Exception ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(string paramName);
    internal static Exception ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(string paramName, int index);
    private static Exception ArgumentMustBeInstanceMember(string paramName);
    internal static Exception ArgumentMustBeInstanceMember(string paramName, int index);
    private static Exception ArgumentMustBeInteger(string paramName);
    internal static Exception ArgumentMustBeInteger(string paramName, int index);
    internal static Exception ArgumentMustBeArrayIndexType(string paramName);
    internal static Exception ArgumentMustBeArrayIndexType(string paramName, int index);
    internal static Exception ArgumentMustBeSingleDimensionalArrayType(string paramName);
    internal static Exception ArgumentTypesMustMatch();
    internal static Exception ArgumentTypesMustMatch(string paramName);
    internal static Exception CannotAutoInitializeValueTypeElementThroughProperty(object p0);
    internal static Exception CannotAutoInitializeValueTypeMemberThroughProperty(object p0);
    internal static Exception IncorrectTypeForTypeAs(object p0, string paramName);
    internal static Exception CoalesceUsedOnNonNullType();
    internal static Exception ExpressionTypeCannotInitializeArrayType(object p0, object p1);
    private static Exception ArgumentTypeDoesNotMatchMember(object p0, object p1, string paramName);
    internal static Exception ArgumentTypeDoesNotMatchMember(object p0, object p1, string paramName, int index);
    private static Exception ArgumentMemberNotDeclOnType(object p0, object p1, string paramName);
    internal static Exception ArgumentMemberNotDeclOnType(object p0, object p1, string paramName, int index);
    internal static Exception ExpressionTypeDoesNotMatchReturn(object p0, object p1);
    internal static Exception ExpressionTypeDoesNotMatchAssignment(object p0, object p1);
    internal static Exception ExpressionTypeDoesNotMatchLabel(object p0, object p1);
    internal static Exception ExpressionTypeNotInvocable(object p0, string paramName);
    internal static Exception FieldNotDefinedForType(object p0, object p1);
    internal static Exception InstanceFieldNotDefinedForType(object p0, object p1);
    internal static Exception FieldInfoNotDefinedForType(object p0, object p1, object p2);
    internal static Exception IncorrectNumberOfIndexes();
    internal static Exception IncorrectNumberOfLambdaDeclarationParameters();
    internal static Exception IncorrectNumberOfMembersForGivenConstructor();
    internal static Exception IncorrectNumberOfArgumentsForMembers();
    internal static Exception LambdaTypeMustBeDerivedFromSystemDelegate(string paramName);
    internal static Exception MemberNotFieldOrProperty(object p0, string paramName);
    internal static Exception MethodContainsGenericParameters(object p0, string paramName);
    internal static Exception MethodIsGeneric(object p0, string paramName);
    private static Exception MethodNotPropertyAccessor(object p0, object p1, string paramName);
    internal static Exception MethodNotPropertyAccessor(object p0, object p1, string paramName, int index);
    internal static Exception PropertyDoesNotHaveGetter(object p0, string paramName);
    internal static Exception PropertyDoesNotHaveGetter(object p0, string paramName, int index);
    internal static Exception PropertyDoesNotHaveSetter(object p0, string paramName);
    internal static Exception PropertyDoesNotHaveAccessor(object p0, string paramName);
    internal static Exception NotAMemberOfType(object p0, object p1, string paramName);
    internal static Exception NotAMemberOfType(object p0, object p1, string paramName, int index);
    internal static Exception NotAMemberOfAnyType(object p0, string paramName);
    internal static Exception ParameterExpressionNotValidAsDelegate(object p0, object p1);
    internal static Exception PropertyNotDefinedForType(object p0, object p1, string paramName);
    internal static Exception InstancePropertyNotDefinedForType(object p0, object p1, string paramName);
    internal static Exception InstancePropertyWithoutParameterNotDefinedForType(object p0, object p1);
    internal static Exception InstancePropertyWithSpecifiedParametersNotDefinedForType(object p0, object p1, object p2, string paramName);
    internal static Exception InstanceAndMethodTypeMismatch(object p0, object p1, object p2);
    internal static Exception TypeMissingDefaultConstructor(object p0, string paramName);
    internal static Exception ElementInitializerMethodNotAdd(string paramName);
    internal static Exception ElementInitializerMethodNoRefOutParam(object p0, object p1, string paramName);
    internal static Exception ElementInitializerMethodWithZeroArgs(string paramName);
    internal static Exception ElementInitializerMethodStatic(string paramName);
    internal static Exception TypeNotIEnumerable(object p0, string paramName);
    internal static Exception UnhandledBinary(object p0, string paramName);
    internal static Exception UnhandledBinding();
    internal static Exception UnhandledBindingType(object p0);
    internal static Exception UnhandledUnary(object p0, string paramName);
    internal static Exception UnknownBindingType(int index);
    internal static Exception UserDefinedOpMustHaveConsistentTypes(object p0, object p1);
    internal static Exception UserDefinedOpMustHaveValidReturnType(object p0, object p1);
    internal static Exception LogicalOperatorMustHaveBooleanOperators(object p0, object p1);
    internal static Exception MethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static Exception GenericMethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static Exception MethodWithMoreThanOneMatch(object p0, object p1);
    internal static Exception PropertyWithMoreThanOneMatch(object p0, object p1);
    internal static Exception IncorrectNumberOfTypeArgsForFunc(string paramName);
    internal static Exception IncorrectNumberOfTypeArgsForAction(string paramName);
    internal static Exception ArgumentCannotBeOfTypeVoid(string paramName);
    internal static Exception OutOfRange(string paramName, object p1);
    internal static Exception LabelTargetAlreadyDefined(object p0);
    internal static Exception LabelTargetUndefined(object p0);
    internal static Exception ControlCannotLeaveFinally();
    internal static Exception ControlCannotLeaveFilterTest();
    internal static Exception AmbiguousJump(object p0);
    internal static Exception ControlCannotEnterTry();
    internal static Exception ControlCannotEnterExpression();
    internal static Exception NonLocalJumpWithValue(object p0);
    internal static Exception InvalidLvalue(ExpressionType p0);
    internal static Exception UndefinedVariable(object p0, object p1, object p2);
    internal static Exception CannotCloseOverByRef(object p0, object p1);
    internal static Exception UnexpectedVarArgsCall(object p0);
    internal static Exception RethrowRequiresCatch();
    internal static Exception TryNotAllowedInFilter();
    internal static Exception MustRewriteToSameNode(object p0, object p1, object p2);
    internal static Exception MustRewriteChildToSameType(object p0, object p1, object p2);
    internal static Exception MustRewriteWithoutMethod(object p0, object p1);
    internal static Exception TryNotSupportedForMethodsWithRefArgs(object p0);
    internal static Exception TryNotSupportedForValueTypeInstances(object p0);
    internal static Exception TestValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static Exception SwitchValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static Exception ArgumentOutOfRange(string paramName);
    internal static Exception NotSupported();
    internal static Exception NonStaticConstructorRequired(string paramName);
    internal static Exception NonAbstractConstructorRequired();
    internal static Exception InvalidProgram();
    internal static Exception EnumerationIsDone();
    private static Exception TypeContainsGenericParameters(object p0, string paramName);
    internal static Exception TypeContainsGenericParameters(object p0, string paramName, int index);
    internal static Exception TypeIsGeneric(object p0, string paramName);
    internal static Exception TypeIsGeneric(object p0, string paramName, int index);
    internal static Exception IncorrectNumberOfConstructorArguments();
    internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2, string paramName, int index);
    internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1, string paramName, int index);
    internal static Exception IncorrectNumberOfLambdaArguments();
    internal static Exception IncorrectNumberOfMethodCallArguments(object p0, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1, string paramName);
    internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1, string paramName, int index);
    internal static Exception ExpressionMustBeReadable(string paramName);
    internal static Exception ExpressionMustBeReadable(string paramName, int index);
    internal static Exception InvalidArgumentValue(string paramName);
    internal static Exception NonEmptyCollectionRequired(string paramName);
    internal static Exception InvalidNullValue(Type type, string paramName);
    internal static Exception InvalidTypeException(object value, Type type, string paramName);
    private static string GetParamName(string paramName, int index);
}
public abstract class System.Linq.Expressions.Expression : object {
    private static CacheDict`2<Type, MethodInfo> s_lambdaDelegateCache;
    private static CacheDict`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_lambdaFactories;
    private static ConditionalWeakTable`2<Expression, ExtensionInfo> s_legacyCtorSupportTable;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool CanReduce { get; }
    private string DebugView { get; }
    [ObsoleteAttribute("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")]
protected Expression(ExpressionType nodeType, Type type);
    private static Expression();
    public static BinaryExpression Assign(Expression left, Expression right);
    private static BinaryExpression GetUserDefinedBinaryOperator(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull);
    private static BinaryExpression GetMethodBasedBinaryOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, bool liftToNull);
    private static BinaryExpression GetMethodBasedAssignOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, LambdaExpression conversion, bool liftToNull);
    private static BinaryExpression GetUserDefinedBinaryOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull);
    private static BinaryExpression GetUserDefinedAssignOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, LambdaExpression conversion, bool liftToNull);
    private static MethodInfo GetUserDefinedBinaryOperator(ExpressionType binaryType, Type leftType, Type rightType, string name);
    private static bool IsLiftingConditionalLogicalOperator(Type left, Type right, MethodInfo method, ExpressionType binaryType);
    internal static bool ParameterIsAssignable(ParameterInfo pi, Type argType);
    private static void ValidateParamswithOperandsOrThrow(Type paramType, Type operandType, ExpressionType exprType, string name);
    private static void ValidateOperator(MethodInfo method);
    private static void ValidateMethodInfo(MethodInfo method, string paramName);
    private static bool IsNullComparison(Expression left, Expression right);
    private static bool IsNullConstant(Expression e);
    private static void ValidateUserDefinedConditionalLogicOperator(ExpressionType nodeType, Type left, Type right, MethodInfo method);
    private static void VerifyOpTrueFalse(ExpressionType nodeType, Type left, MethodInfo opTrue, string paramName);
    private static bool IsValidLiftedConditionalLogicalOperator(Type left, Type right, ParameterInfo[] pms);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Equal(Expression left, Expression right);
    public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ReferenceEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ReferenceNotEqual(Expression left, Expression right);
    private static BinaryExpression GetEqualityComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull);
    public static BinaryExpression GreaterThan(Expression left, Expression right);
    public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThan(Expression left, Expression right);
    public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    private static BinaryExpression GetComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull);
    public static BinaryExpression AndAlso(Expression left, Expression right);
    public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrElse(Expression left, Expression right);
    public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Coalesce(Expression left, Expression right);
    public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion);
    private static Type ValidateCoalesceArgTypes(Type left, Type right);
    public static BinaryExpression Add(Expression left, Expression right);
    public static BinaryExpression Add(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    private static void ValidateOpAssignConversionLambda(LambdaExpression conversion, Expression left, MethodInfo method, ExpressionType nodeType);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddChecked(Expression left, Expression right);
    public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Subtract(Expression left, Expression right);
    public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractChecked(Expression left, Expression right);
    public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression Divide(Expression left, Expression right);
    public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Modulo(Expression left, Expression right);
    public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Multiply(Expression left, Expression right);
    public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method);
    private static bool IsSimpleShift(Type left, Type right);
    private static Type GetResultTypeOfShift(Type left, Type right);
    public static BinaryExpression LeftShift(Expression left, Expression right);
    public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression RightShift(Expression left, Expression right);
    public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression And(Expression left, Expression right);
    public static BinaryExpression And(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Or(Expression left, Expression right);
    public static BinaryExpression Or(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Power(Expression left, Expression right);
    public static BinaryExpression Power(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression ArrayIndex(Expression array, Expression index);
    public static BlockExpression Block(Expression arg0, Expression arg1);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static BlockExpression Block(Expression[] expressions);
    public static BlockExpression Block(IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    private static BlockExpression BlockCore(Type type, ReadOnlyCollection`1<ParameterExpression> variables, ReadOnlyCollection`1<Expression> expressions);
    internal static void ValidateVariables(ReadOnlyCollection`1<ParameterExpression> varList, string collectionName);
    private static BlockExpression GetOptimizedBlockExpression(IReadOnlyList`1<Expression> expressions);
    public static CatchBlock Catch(Type type, Expression body);
    public static CatchBlock Catch(ParameterExpression variable, Expression body);
    public static CatchBlock Catch(Type type, Expression body, Expression filter);
    public static CatchBlock Catch(ParameterExpression variable, Expression body, Expression filter);
    public static CatchBlock MakeCatchBlock(Type type, ParameterExpression variable, Expression body, Expression filter);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public static ConditionalExpression IfThen(Expression test, Expression ifTrue);
    public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConstantExpression Constant(object value);
    public static ConstantExpression Constant(object value, Type type);
    public static DebugInfoExpression DebugInfo(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public static DebugInfoExpression ClearDebugInfo(SymbolDocumentInfo document);
    private static void ValidateSpan(int startLine, int startColumn, int endLine, int endColumn);
    public static DefaultExpression Empty();
    public static DefaultExpression Default(Type type);
    public static ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable`1<Expression> arguments);
    private static void ValidateElementInitAddMethodInfo(MethodInfo addMethod, string paramName);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    protected internal virtual Expression VisitChildren(ExpressionVisitor visitor);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public Expression ReduceAndCheck();
    public Expression ReduceExtensions();
    public virtual string ToString();
    private string get_DebugView();
    private static void RequiresCanRead(IReadOnlyList`1<Expression> items, string paramName);
    private static void RequiresCanWrite(Expression expression, string paramName);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static GotoExpression Break(LabelTarget target);
    public static GotoExpression Break(LabelTarget target, Expression value);
    public static GotoExpression Break(LabelTarget target, Type type);
    public static GotoExpression Break(LabelTarget target, Expression value, Type type);
    public static GotoExpression Continue(LabelTarget target);
    public static GotoExpression Continue(LabelTarget target, Type type);
    public static GotoExpression Return(LabelTarget target);
    public static GotoExpression Return(LabelTarget target, Type type);
    public static GotoExpression Return(LabelTarget target, Expression value);
    public static GotoExpression Return(LabelTarget target, Expression value, Type type);
    public static GotoExpression Goto(LabelTarget target);
    public static GotoExpression Goto(LabelTarget target, Type type);
    public static GotoExpression Goto(LabelTarget target, Expression value);
    public static GotoExpression Goto(LabelTarget target, Expression value, Type type);
    public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    private static void ValidateGoto(LabelTarget target, Expression& value, string targetParameter, string valueParameter, Type type);
    private static void ValidateGotoType(Type expectedType, Expression& value, string paramName);
    public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static IndexExpression ArrayAccess(Expression array, Expression[] indexes);
    public static IndexExpression ArrayAccess(Expression array, IEnumerable`1<Expression> indexes);
    public static IndexExpression Property(Expression instance, string propertyName, Expression[] arguments);
    private static PropertyInfo FindInstanceProperty(Type type, string propertyName, Expression[] arguments);
    private static string GetArgTypesString(Expression[] arguments);
    private static PropertyInfo FindProperty(Type type, string propertyName, Expression[] arguments, BindingFlags flags);
    private static bool IsCompatible(PropertyInfo pi, Expression[] args);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, Expression[] arguments);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    private static IndexExpression MakeIndexProperty(Expression instance, PropertyInfo indexer, string paramName, ReadOnlyCollection`1<Expression> argList);
    private static void ValidateIndexedProperty(Expression instance, PropertyInfo indexer, string paramName, ReadOnlyCollection`1& argList);
    private static void ValidateAccessor(Expression instance, MethodInfo method, ParameterInfo[] indexes, ReadOnlyCollection`1& arguments, string paramName);
    private static void ValidateAccessorArgumentTypes(MethodInfo method, ParameterInfo[] indexes, ReadOnlyCollection`1& arguments, string paramName);
    internal static InvocationExpression Invoke(Expression expression);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static InvocationExpression Invoke(Expression expression, Expression[] arguments);
    public static InvocationExpression Invoke(Expression expression, IEnumerable`1<Expression> arguments);
    internal static MethodInfo GetInvokeMethod(Expression expression);
    public static LabelExpression Label(LabelTarget target);
    public static LabelExpression Label(LabelTarget target, Expression defaultValue);
    public static LabelTarget Label();
    public static LabelTarget Label(string name);
    public static LabelTarget Label(Type type);
    public static LabelTarget Label(Type type, string name);
    internal static LambdaExpression CreateLambda(Type delegateType, Expression body, string name, bool tailCall, ReadOnlyCollection`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    private static void ValidateLambdaArgs(Type delegateType, Expression& body, ReadOnlyCollection`1<ParameterExpression> parameters, string paramName);
    private static TryGetFuncActionArgsResult ValidateTryGetFuncActionArgs(Type[] typeArgs);
    public static Type GetFuncType(Type[] typeArgs);
    public static bool TryGetFuncType(Type[] typeArgs, Type& funcType);
    public static Type GetActionType(Type[] typeArgs);
    public static bool TryGetActionType(Type[] typeArgs, Type& actionType);
    public static Type GetDelegateType(Type[] typeArgs);
    public static ListInitExpression ListInit(NewExpression newExpression, Expression[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, Expression[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
    public static LoopExpression Loop(Expression body);
    public static LoopExpression Loop(Expression body, LabelTarget break);
    public static LoopExpression Loop(Expression body, LabelTarget break, LabelTarget continue);
    public static MemberAssignment Bind(MemberInfo member, Expression expression);
    public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression);
    private static void ValidateSettableFieldOrPropertyMember(MemberInfo member, Type& memberType);
    public static MemberExpression Field(Expression expression, FieldInfo field);
    public static MemberExpression Field(Expression expression, string fieldName);
    public static MemberExpression Field(Expression expression, Type type, string fieldName);
    public static MemberExpression Property(Expression expression, string propertyName);
    public static MemberExpression Property(Expression expression, Type type, string propertyName);
    public static MemberExpression Property(Expression expression, PropertyInfo property);
    public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor);
    private static PropertyInfo GetProperty(MethodInfo mi, string paramName, int index);
    private static bool CheckMethod(MethodInfo method, MethodInfo propertyMethod);
    public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName);
    public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member);
    public static MemberInitExpression MemberInit(NewExpression newExpression, MemberBinding[] bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
    public static MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers);
    public static MemberListBinding ListBind(MemberInfo member, IEnumerable`1<ElementInit> initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, ElementInit[] initializers);
    public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable`1<ElementInit> initializers);
    private static void ValidateListInitArgs(Type listType, ReadOnlyCollection`1<ElementInit> initializers, string listTypeParamName);
    public static MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable`1<MemberBinding> bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, MemberBinding[] bindings);
    public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable`1<MemberBinding> bindings);
    private static void ValidateGettableFieldOrPropertyMember(MemberInfo member, Type& memberType);
    private static void ValidateMemberInitArgs(Type type, ReadOnlyCollection`1<MemberBinding> bindings);
    internal static MethodCallExpression Call(MethodInfo method);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static MethodCallExpression Call(MethodInfo method, Expression[] arguments);
    public static MethodCallExpression Call(MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments);
    internal static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments);
    private static ParameterInfo[] ValidateMethodAndGetParameters(Expression instance, MethodInfo method);
    private static void ValidateStaticOrInstanceMethod(Expression instance, MethodInfo method);
    private static void ValidateCallInstanceType(Type instanceType, MethodInfo method);
    private static void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ReadOnlyCollection`1& arguments, string methodParamName);
    private static ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind);
    private static void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis);
    private static Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arg, ParameterInfo pi, string methodParamName, string argumentParamName);
    private static bool TryQuote(Type parameterType, Expression& argument);
    private static MethodInfo FindMethod(Type type, string methodName, Type[] typeArgs, Expression[] args, BindingFlags flags);
    private static bool IsCompatible(MethodBase m, Expression[] arguments);
    private static MethodInfo ApplyTypeArgs(MethodInfo m, Type[] typeArgs);
    public static MethodCallExpression ArrayIndex(Expression array, Expression[] indexes);
    public static MethodCallExpression ArrayIndex(Expression array, IEnumerable`1<Expression> indexes);
    public static NewArrayExpression NewArrayInit(Type type, Expression[] initializers);
    public static NewArrayExpression NewArrayInit(Type type, IEnumerable`1<Expression> initializers);
    public static NewArrayExpression NewArrayBounds(Type type, Expression[] bounds);
    public static NewArrayExpression NewArrayBounds(Type type, IEnumerable`1<Expression> bounds);
    public static NewExpression New(ConstructorInfo constructor);
    public static NewExpression New(ConstructorInfo constructor, Expression[] arguments);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, IEnumerable`1<MemberInfo> members);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, MemberInfo[] members);
    public static NewExpression New(Type type);
    private static void ValidateNewArgs(ConstructorInfo constructor, ReadOnlyCollection`1& arguments, ReadOnlyCollection`1& members);
    private static void ValidateAnonymousTypeMember(MemberInfo& member, Type& memberType, string paramName, int index);
    private static void ValidateConstructor(ConstructorInfo constructor, string paramName);
    public static ParameterExpression Parameter(Type type);
    public static ParameterExpression Variable(Type type);
    public static ParameterExpression Parameter(Type type, string name);
    public static ParameterExpression Variable(Type type, string name);
    private static void Validate(Type type, bool allowByRef);
    public static RuntimeVariablesExpression RuntimeVariables(ParameterExpression[] variables);
    public static RuntimeVariablesExpression RuntimeVariables(IEnumerable`1<ParameterExpression> variables);
    public static SwitchCase SwitchCase(Expression body, Expression[] testValues);
    public static SwitchCase SwitchCase(Expression body, IEnumerable`1<Expression> testValues);
    public static SwitchExpression Switch(Expression switchValue, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    private static void ValidateSwitchCaseType(Expression case, bool customType, Type resultType, string parameterName);
    public static SymbolDocumentInfo SymbolDocument(string fileName);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor, Guid documentType);
    public static TryExpression TryFault(Expression body, Expression fault);
    public static TryExpression TryFinally(Expression body, Expression finally);
    public static TryExpression TryCatch(Expression body, CatchBlock[] handlers);
    public static TryExpression TryCatchFinally(Expression body, Expression finally, CatchBlock[] handlers);
    public static TryExpression MakeTry(Type type, Expression body, Expression finally, Expression fault, IEnumerable`1<CatchBlock> handlers);
    private static void ValidateTryAndCatchHaveSameType(Type type, Expression tryBody, ReadOnlyCollection`1<CatchBlock> handlers);
    public static TypeBinaryExpression TypeIs(Expression expression, Type type);
    public static TypeBinaryExpression TypeEqual(Expression expression, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method);
    private static UnaryExpression GetUserDefinedUnaryOperatorOrThrow(ExpressionType unaryType, string name, Expression operand);
    private static UnaryExpression GetUserDefinedUnaryOperator(ExpressionType unaryType, string name, Expression operand);
    private static UnaryExpression GetMethodBasedUnaryOperator(ExpressionType unaryType, Expression operand, MethodInfo method);
    private static UnaryExpression GetUserDefinedCoercionOrThrow(ExpressionType coercionType, Expression expression, Type convertToType);
    private static UnaryExpression GetUserDefinedCoercion(ExpressionType coercionType, Expression expression, Type convertToType);
    private static UnaryExpression GetMethodBasedCoercionOperator(ExpressionType unaryType, Expression operand, Type convertToType, MethodInfo method);
    public static UnaryExpression Negate(Expression expression);
    public static UnaryExpression Negate(Expression expression, MethodInfo method);
    public static UnaryExpression UnaryPlus(Expression expression);
    public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method);
    public static UnaryExpression NegateChecked(Expression expression);
    public static UnaryExpression NegateChecked(Expression expression, MethodInfo method);
    public static UnaryExpression Not(Expression expression);
    public static UnaryExpression Not(Expression expression, MethodInfo method);
    public static UnaryExpression IsFalse(Expression expression);
    public static UnaryExpression IsFalse(Expression expression, MethodInfo method);
    public static UnaryExpression IsTrue(Expression expression);
    public static UnaryExpression IsTrue(Expression expression, MethodInfo method);
    public static UnaryExpression OnesComplement(Expression expression);
    public static UnaryExpression OnesComplement(Expression expression, MethodInfo method);
    public static UnaryExpression TypeAs(Expression expression, Type type);
    public static UnaryExpression Unbox(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ConvertChecked(Expression expression, Type type);
    public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ArrayLength(Expression array);
    public static UnaryExpression Quote(Expression expression);
    public static UnaryExpression Rethrow();
    public static UnaryExpression Rethrow(Type type);
    public static UnaryExpression Throw(Expression value);
    public static UnaryExpression Throw(Expression value, Type type);
    public static UnaryExpression Increment(Expression expression);
    public static UnaryExpression Increment(Expression expression, MethodInfo method);
    public static UnaryExpression Decrement(Expression expression);
    public static UnaryExpression Decrement(Expression expression, MethodInfo method);
    public static UnaryExpression PreIncrementAssign(Expression expression);
    public static UnaryExpression PreIncrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PreDecrementAssign(Expression expression);
    public static UnaryExpression PreDecrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostIncrementAssign(Expression expression);
    public static UnaryExpression PostIncrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostDecrementAssign(Expression expression);
    public static UnaryExpression PostDecrementAssign(Expression expression, MethodInfo method);
    private static UnaryExpression MakeOpAssignUnary(ExpressionType kind, Expression expression, MethodInfo method);
}
public class System.Linq.Expressions.Expression`1 : LambdaExpression {
    internal Type TypeCore { get; }
    internal Type PublicType { get; }
    internal Expression`1(Expression body);
    internal sealed virtual Type get_TypeCore();
    internal virtual Type get_PublicType();
    public TDelegate Compile();
    public TDelegate Compile(bool preferInterpretation);
    public Expression`1<TDelegate> Update(Expression body, IEnumerable`1<ParameterExpression> parameters);
    [ExcludeFromCodeCoverageAttribute]
internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    [ExcludeFromCodeCoverageAttribute]
internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal virtual LambdaExpression Accept(StackSpiller spiller);
    internal static Expression`1<TDelegate> Create(Expression body, string name, bool tailCall, IReadOnlyList`1<ParameterExpression> parameters);
    public TDelegate Compile(DebugInfoGenerator debugInfoGenerator);
}
internal class System.Linq.Expressions.Expression0`1 : Expression`1<TDelegate> {
    internal int ParameterCount { get; }
    public Expression0`1(Expression body);
    internal virtual int get_ParameterCount();
    internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    internal virtual ParameterExpression GetParameter(int index);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
}
internal class System.Linq.Expressions.Expression1`1 : Expression`1<TDelegate> {
    private object _par0;
    internal int ParameterCount { get; }
    public Expression1`1(Expression body, ParameterExpression par0);
    internal virtual int get_ParameterCount();
    internal virtual ParameterExpression GetParameter(int index);
    internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
}
internal class System.Linq.Expressions.Expression2`1 : Expression`1<TDelegate> {
    private object _par0;
    private ParameterExpression _par1;
    internal int ParameterCount { get; }
    public Expression2`1(Expression body, ParameterExpression par0, ParameterExpression par1);
    internal virtual int get_ParameterCount();
    internal virtual ParameterExpression GetParameter(int index);
    internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
}
internal class System.Linq.Expressions.Expression3`1 : Expression`1<TDelegate> {
    private object _par0;
    private ParameterExpression _par1;
    private ParameterExpression _par2;
    internal int ParameterCount { get; }
    public Expression3`1(Expression body, ParameterExpression par0, ParameterExpression par1, ParameterExpression par2);
    internal virtual int get_ParameterCount();
    internal virtual ParameterExpression GetParameter(int index);
    internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
}
internal static class System.Linq.Expressions.ExpressionExtension : object {
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    private static MethodInfo GetValidMethodForDynamic(Type delegateType);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    private static DynamicExpression MakeDynamic(CallSiteBinder binder, Type returnType, ReadOnlyCollection`1<Expression> arguments);
    private static void ValidateDynamicArgument(Expression arg, string paramName);
    private static void ValidateDynamicArgument(Expression arg, string paramName, int index);
}
internal class System.Linq.Expressions.ExpressionN`1 : Expression`1<TDelegate> {
    private IReadOnlyList`1<ParameterExpression> _parameters;
    internal int ParameterCount { get; }
    public ExpressionN`1(Expression body, IReadOnlyList`1<ParameterExpression> parameters);
    internal virtual int get_ParameterCount();
    internal virtual ParameterExpression GetParameter(int index);
    internal virtual bool SameParameters(ICollection`1<ParameterExpression> parameters);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    internal virtual Expression`1<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters);
}
internal class System.Linq.Expressions.ExpressionStringBuilder : ExpressionVisitor {
    private StringBuilder _out;
    private Dictionary`2<object, int> _ids;
    public virtual string ToString();
    private int GetLabelId(LabelTarget label);
    private int GetParamId(ParameterExpression p);
    private int GetId(object o);
    private void Out(string s);
    private void Out(char c);
    internal static string ExpressionToString(Expression node);
    internal static string CatchBlockToString(CatchBlock node);
    internal static string SwitchCaseToString(SwitchCase node);
    internal static string MemberBindingToString(MemberBinding node);
    internal static string ElementInitBindingToString(ElementInit node);
    private void VisitExpressions(char open, ReadOnlyCollection`1<T> expressions, char close);
    private void VisitExpressions(char open, ReadOnlyCollection`1<T> expressions, char close, string seperator);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    private void OutMember(Expression instance, MemberInfo member);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding);
    protected virtual ElementInit VisitElementInit(ElementInit initializer);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitExtension(Expression node);
    private void DumpLabel(LabelTarget target);
    private static bool IsBool(Expression node);
}
public enum System.Linq.Expressions.ExpressionType : Enum {
    public int value__;
    public static ExpressionType Add;
    public static ExpressionType AddChecked;
    public static ExpressionType And;
    public static ExpressionType AndAlso;
    public static ExpressionType ArrayLength;
    public static ExpressionType ArrayIndex;
    public static ExpressionType Call;
    public static ExpressionType Coalesce;
    public static ExpressionType Conditional;
    public static ExpressionType Constant;
    public static ExpressionType Convert;
    public static ExpressionType ConvertChecked;
    public static ExpressionType Divide;
    public static ExpressionType Equal;
    public static ExpressionType ExclusiveOr;
    public static ExpressionType GreaterThan;
    public static ExpressionType GreaterThanOrEqual;
    public static ExpressionType Invoke;
    public static ExpressionType Lambda;
    public static ExpressionType LeftShift;
    public static ExpressionType LessThan;
    public static ExpressionType LessThanOrEqual;
    public static ExpressionType ListInit;
    public static ExpressionType MemberAccess;
    public static ExpressionType MemberInit;
    public static ExpressionType Modulo;
    public static ExpressionType Multiply;
    public static ExpressionType MultiplyChecked;
    public static ExpressionType Negate;
    public static ExpressionType UnaryPlus;
    public static ExpressionType NegateChecked;
    public static ExpressionType New;
    public static ExpressionType NewArrayInit;
    public static ExpressionType NewArrayBounds;
    public static ExpressionType Not;
    public static ExpressionType NotEqual;
    public static ExpressionType Or;
    public static ExpressionType OrElse;
    public static ExpressionType Parameter;
    public static ExpressionType Power;
    public static ExpressionType Quote;
    public static ExpressionType RightShift;
    public static ExpressionType Subtract;
    public static ExpressionType SubtractChecked;
    public static ExpressionType TypeAs;
    public static ExpressionType TypeIs;
    public static ExpressionType Assign;
    public static ExpressionType Block;
    public static ExpressionType DebugInfo;
    public static ExpressionType Decrement;
    public static ExpressionType Dynamic;
    public static ExpressionType Default;
    public static ExpressionType Extension;
    public static ExpressionType Goto;
    public static ExpressionType Increment;
    public static ExpressionType Index;
    public static ExpressionType Label;
    public static ExpressionType RuntimeVariables;
    public static ExpressionType Loop;
    public static ExpressionType Switch;
    public static ExpressionType Throw;
    public static ExpressionType Try;
    public static ExpressionType Unbox;
    public static ExpressionType AddAssign;
    public static ExpressionType AndAssign;
    public static ExpressionType DivideAssign;
    public static ExpressionType ExclusiveOrAssign;
    public static ExpressionType LeftShiftAssign;
    public static ExpressionType ModuloAssign;
    public static ExpressionType MultiplyAssign;
    public static ExpressionType OrAssign;
    public static ExpressionType PowerAssign;
    public static ExpressionType RightShiftAssign;
    public static ExpressionType SubtractAssign;
    public static ExpressionType AddAssignChecked;
    public static ExpressionType MultiplyAssignChecked;
    public static ExpressionType SubtractAssignChecked;
    public static ExpressionType PreIncrementAssign;
    public static ExpressionType PreDecrementAssign;
    public static ExpressionType PostIncrementAssign;
    public static ExpressionType PostDecrementAssign;
    public static ExpressionType TypeEqual;
    public static ExpressionType OnesComplement;
    public static ExpressionType IsTrue;
    public static ExpressionType IsFalse;
}
public abstract class System.Linq.Expressions.ExpressionVisitor : object {
    public virtual Expression Visit(Expression node);
    public ReadOnlyCollection`1<Expression> Visit(ReadOnlyCollection`1<Expression> nodes);
    private Expression[] VisitArguments(IArgumentProvider nodes);
    private ParameterExpression[] VisitParameters(IParameterProvider nodes, string callerName);
    public static ReadOnlyCollection`1<T> Visit(ReadOnlyCollection`1<T> nodes, Func`2<T, T> elementVisitor);
    public T VisitAndConvert(T node, string callerName);
    public ReadOnlyCollection`1<T> VisitAndConvert(ReadOnlyCollection`1<T> nodes, string callerName);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitExtension(Expression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
    private static UnaryExpression ValidateUnary(UnaryExpression before, UnaryExpression after);
    private static BinaryExpression ValidateBinary(BinaryExpression before, BinaryExpression after);
    private static SwitchExpression ValidateSwitch(SwitchExpression before, SwitchExpression after);
    private static void ValidateChildType(Type before, Type after, string methodName);
    protected internal virtual Expression VisitDynamic(DynamicExpression node);
}
internal class System.Linq.Expressions.FieldExpression : MemberExpression {
    private FieldInfo _field;
    public Type Type { get; }
    public FieldExpression(Expression expression, FieldInfo member);
    internal virtual MemberInfo GetMember();
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.FullConditionalExpression : ConditionalExpression {
    private Expression _false;
    internal FullConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse);
    internal virtual Expression GetFalse();
}
internal class System.Linq.Expressions.FullConditionalExpressionWithType : FullConditionalExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal FullConditionalExpressionWithType(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.FullExpression`1 : ExpressionN`1<TDelegate> {
    [CompilerGeneratedAttribute]
private string <NameCore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TailCallCore>k__BackingField;
    internal string NameCore { get; }
    internal bool TailCallCore { get; }
    public FullExpression`1(Expression body, string name, bool tailCall, IReadOnlyList`1<ParameterExpression> parameters);
    [CompilerGeneratedAttribute]
internal virtual string get_NameCore();
    [CompilerGeneratedAttribute]
internal virtual bool get_TailCallCore();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/GotoExpressionProxy")]
public class System.Linq.Expressions.GotoExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private GotoExpressionKind <Kind>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Value { get; }
    public LabelTarget Target { get; }
    public GotoExpressionKind Kind { get; }
    internal GotoExpression(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Value();
    [CompilerGeneratedAttribute]
public LabelTarget get_Target();
    [CompilerGeneratedAttribute]
public GotoExpressionKind get_Kind();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public GotoExpression Update(LabelTarget target, Expression value);
}
public enum System.Linq.Expressions.GotoExpressionKind : Enum {
    public int value__;
    public static GotoExpressionKind Goto;
    public static GotoExpressionKind Return;
    public static GotoExpressionKind Break;
    public static GotoExpressionKind Continue;
}
public interface System.Linq.Expressions.IArgumentProvider {
    public int ArgumentCount { get; }
    public abstract virtual Expression GetArgument(int index);
    public abstract virtual int get_ArgumentCount();
}
public interface System.Linq.Expressions.IDynamicExpression {
    public Type DelegateType { get; }
    public abstract virtual Type get_DelegateType();
    public abstract virtual Expression Rewrite(Expression[] args);
    public abstract virtual object CreateCallSite();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/IndexExpressionProxy")]
public class System.Linq.Expressions.IndexExpression : Expression {
    private IReadOnlyList`1<Expression> _arguments;
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <Indexer>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression Object { get; }
    public PropertyInfo Indexer { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    internal IndexExpression(Expression instance, PropertyInfo indexer, IReadOnlyList`1<Expression> arguments);
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public Expression get_Object();
    [CompilerGeneratedAttribute]
public PropertyInfo get_Indexer();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public IndexExpression Update(Expression object, IEnumerable`1<Expression> arguments);
    public sealed virtual Expression GetArgument(int index);
    public sealed virtual int get_ArgumentCount();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal Expression Rewrite(Expression instance, Expression[] arguments);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression : MethodCallExpression {
    private Expression _instance;
    public InstanceMethodCallExpression(MethodInfo method, Expression instance);
    internal virtual Expression GetInstance();
}
internal class System.Linq.Expressions.InstanceMethodCallExpression0 : InstanceMethodCallExpression {
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression0(MethodInfo method, Expression instance);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression1 : InstanceMethodCallExpression {
    private object _arg0;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression1(MethodInfo method, Expression instance, Expression arg0);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression2 : InstanceMethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression2(MethodInfo method, Expression instance, Expression arg0, Expression arg1);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpression3 : InstanceMethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpression3(MethodInfo method, Expression instance, Expression arg0, Expression arg1, Expression arg2);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.InstanceMethodCallExpressionN : InstanceMethodCallExpression {
    private IReadOnlyList`1<Expression> _arguments;
    public int ArgumentCount { get; }
    public InstanceMethodCallExpressionN(MethodInfo method, Expression instance, IReadOnlyList`1<Expression> args);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal abstract class System.Linq.Expressions.Interpreter.AddInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.AddOvfInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.AndInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Boolean;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.ArrayByRefUpdater : ByRefUpdater {
    private LocalDefinition _array;
    private LocalDefinition _index;
    public ArrayByRefUpdater(LocalDefinition array, LocalDefinition index, int argumentIndex);
    public virtual void Update(InterpretedFrame frame, object value);
    public virtual void UndefineTemps(InstructionList instructions, LocalVariables locals);
}
internal class System.Linq.Expressions.Interpreter.ArrayLengthInstruction : Instruction {
    public static ArrayLengthInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static ArrayLengthInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.AssignLocalBoxedInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal AssignLocalBoxedInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.AssignLocalInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal AssignLocalInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class System.Linq.Expressions.Interpreter.AssignLocalToClosureInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal AssignLocalToClosureInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.BranchFalseInstruction : OffsetInstruction {
    private static Instruction[] s_cache;
    public Instruction[] Cache { get; }
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public virtual Instruction[] get_Cache();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.BranchInstruction : OffsetInstruction {
    private static Instruction[][][] s_caches;
    internal bool _hasResult;
    internal bool _hasValue;
    public Instruction[] Cache { get; }
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public BranchInstruction(bool hasResult, bool hasValue);
    public virtual Instruction[] get_Cache();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.BranchLabel : object {
    private int _targetIndex;
    private int _stackDepth;
    private int _continuationStackDepth;
    private List`1<int> _forwardBranchFixups;
    [CompilerGeneratedAttribute]
private int <LabelIndex>k__BackingField;
    internal int LabelIndex { get; internal set; }
    internal bool HasRuntimeLabel { get; }
    internal int TargetIndex { get; }
    [CompilerGeneratedAttribute]
internal int get_LabelIndex();
    [CompilerGeneratedAttribute]
internal void set_LabelIndex(int value);
    internal bool get_HasRuntimeLabel();
    internal int get_TargetIndex();
    internal RuntimeLabel ToRuntimeLabel();
    internal void Mark(InstructionList instructions);
    internal void AddBranch(InstructionList instructions, int branchIndex);
    internal void FixupBranch(InstructionList instructions, int branchIndex);
}
internal class System.Linq.Expressions.Interpreter.BranchTrueInstruction : OffsetInstruction {
    private static Instruction[] s_cache;
    public Instruction[] Cache { get; }
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public virtual Instruction[] get_Cache();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.ByRefMethodInfoCallInstruction : MethodInfoCallInstruction {
    private ByRefUpdater[] _byrefArgs;
    public int ProducedStack { get; }
    internal ByRefMethodInfoCallInstruction(MethodInfo target, int argumentCount, ByRefUpdater[] byrefArgs);
    public virtual int get_ProducedStack();
    public sealed virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.ByRefNewInstruction : NewInstruction {
    private ByRefUpdater[] _byrefArgs;
    public string InstructionName { get; }
    internal ByRefNewInstruction(ConstructorInfo target, int argumentCount, ByRefUpdater[] byrefArgs);
    public virtual string get_InstructionName();
    public sealed virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.ByRefUpdater : object {
    public int ArgumentIndex;
    public ByRefUpdater(int argumentIndex);
    public abstract virtual void Update(InterpretedFrame frame, object value);
    public virtual void UndefineTemps(InstructionList instructions, LocalVariables locals);
}
internal abstract class System.Linq.Expressions.Interpreter.CallInstruction : Instruction {
    public int ArgumentCount { get; }
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public abstract virtual int get_ArgumentCount();
    public virtual string get_InstructionName();
    public static CallInstruction Create(MethodInfo info);
    public static CallInstruction Create(MethodInfo info, ParameterInfo[] parameters);
    private static CallInstruction GetArrayAccessor(MethodInfo info, int argumentCount);
    public static void ArrayItemSetter1(Array array, int index0, object value);
    public static void ArrayItemSetter2(Array array, int index0, int index1, object value);
    public static void ArrayItemSetter3(Array array, int index0, int index1, int index2, object value);
    public virtual int get_ConsumedStack();
    protected static bool TryGetLightLambdaTarget(object instance, LightLambda& lightLambda);
    protected object InterpretLambdaInvoke(LightLambda targetLambda, Object[] args);
}
internal abstract class System.Linq.Expressions.Interpreter.CastInstruction : Instruction {
    private static CastInstruction s_Boolean;
    private static CastInstruction s_Byte;
    private static CastInstruction s_Char;
    private static CastInstruction s_DateTime;
    private static CastInstruction s_Decimal;
    private static CastInstruction s_Double;
    private static CastInstruction s_Int16;
    private static CastInstruction s_Int32;
    private static CastInstruction s_Int64;
    private static CastInstruction s_SByte;
    private static CastInstruction s_Single;
    private static CastInstruction s_String;
    private static CastInstruction s_UInt16;
    private static CastInstruction s_UInt32;
    private static CastInstruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type t);
}
internal class System.Linq.Expressions.Interpreter.CastReferenceToEnumInstruction : CastInstruction {
    private Type _t;
    public CastReferenceToEnumInstruction(Type t);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.CastToEnumInstruction : CastInstruction {
    private Type _t;
    public CastToEnumInstruction(Type t);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.CoalescingBranchInstruction : OffsetInstruction {
    private static Instruction[] s_cache;
    public Instruction[] Cache { get; }
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual Instruction[] get_Cache();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal static class System.Linq.Expressions.Interpreter.ConvertHelper : object {
    public static int ToInt32NoNull(object val);
}
internal class System.Linq.Expressions.Interpreter.CreateDelegateInstruction : Instruction {
    private LightDelegateCreator _creator;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal CreateDelegateInstruction(LightDelegateCreator delegateCreator);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.DebugInfo : object {
    public int StartLine;
    public int EndLine;
    public int Index;
    public string FileName;
    public bool IsClear;
    private static DebugInfoComparer s_debugComparer;
    private static DebugInfo();
    public static DebugInfo GetMatchingDebugInfo(DebugInfo[] debugInfos, int index);
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.DecrementInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.DefaultValueInstruction : Instruction {
    private Type _type;
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal DefaultValueInstruction(Type type);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.DivInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.DupInstruction : Instruction {
    internal static DupInstruction Instance;
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static DupInstruction();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.EnterExceptionFilterInstruction : Instruction {
    internal static EnterExceptionFilterInstruction Instance;
    public string InstructionName { get; }
    public int ProducedStack { get; }
    private static EnterExceptionFilterInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ProducedStack();
    [ExcludeFromCodeCoverageAttribute]
public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.EnterExceptionHandlerInstruction : Instruction {
    internal static EnterExceptionHandlerInstruction Void;
    internal static EnterExceptionHandlerInstruction NonVoid;
    private bool _hasValue;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private EnterExceptionHandlerInstruction(bool hasValue);
    private static EnterExceptionHandlerInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    [ExcludeFromCodeCoverageAttribute]
public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.EnterFaultInstruction : IndexedBranchInstruction {
    private static EnterFaultInstruction[] s_cache;
    public string InstructionName { get; }
    public int ProducedStack { get; }
    private EnterFaultInstruction(int labelIndex);
    private static EnterFaultInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ProducedStack();
    internal static EnterFaultInstruction Create(int labelIndex);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.EnterFinallyInstruction : IndexedBranchInstruction {
    private static EnterFinallyInstruction[] s_cache;
    public string InstructionName { get; }
    public int ProducedStack { get; }
    public int ConsumedContinuations { get; }
    private EnterFinallyInstruction(int labelIndex);
    private static EnterFinallyInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedContinuations();
    internal static EnterFinallyInstruction Create(int labelIndex);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.EnterTryCatchFinallyInstruction : IndexedBranchInstruction {
    private bool _hasFinally;
    private TryCatchFinallyHandler _tryHandler;
    internal TryCatchFinallyHandler Handler { get; }
    public int ProducedContinuations { get; }
    public string InstructionName { get; }
    private EnterTryCatchFinallyInstruction(int targetIndex, bool hasFinally);
    internal void SetTryHandler(TryCatchFinallyHandler tryHandler);
    internal TryCatchFinallyHandler get_Handler();
    public virtual int get_ProducedContinuations();
    internal static EnterTryCatchFinallyInstruction CreateTryFinally(int labelIndex);
    internal static EnterTryCatchFinallyInstruction CreateTryCatch();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.EnterTryFaultInstruction : IndexedBranchInstruction {
    private TryFaultHandler _tryHandler;
    public string InstructionName { get; }
    public int ProducedContinuations { get; }
    internal TryFaultHandler Handler { get; }
    internal EnterTryFaultInstruction(int targetIndex);
    public virtual string get_InstructionName();
    public virtual int get_ProducedContinuations();
    internal TryFaultHandler get_Handler();
    internal void SetTryHandler(TryFaultHandler tryHandler);
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.EqualInstruction : Instruction {
    private static Instruction s_reference;
    private static Instruction s_Boolean;
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Char;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    private static Instruction s_BooleanLiftedToNull;
    private static Instruction s_SByteLiftedToNull;
    private static Instruction s_Int16LiftedToNull;
    private static Instruction s_CharLiftedToNull;
    private static Instruction s_Int32LiftedToNull;
    private static Instruction s_Int64LiftedToNull;
    private static Instruction s_ByteLiftedToNull;
    private static Instruction s_UInt16LiftedToNull;
    private static Instruction s_UInt32LiftedToNull;
    private static Instruction s_UInt64LiftedToNull;
    private static Instruction s_SingleLiftedToNull;
    private static Instruction s_DoubleLiftedToNull;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
}
internal class System.Linq.Expressions.Interpreter.ExceptionFilter : object {
    public int LabelIndex;
    public int StartIndex;
    public int EndIndex;
    internal ExceptionFilter(int labelIndex, int start, int end);
}
internal class System.Linq.Expressions.Interpreter.ExceptionHandler : object {
    private Type _exceptionType;
    public int LabelIndex;
    public int HandlerStartIndex;
    public int HandlerEndIndex;
    public ExceptionFilter Filter;
    internal ExceptionHandler(int labelIndex, int handlerStartIndex, int handlerEndIndex, Type exceptionType, ExceptionFilter filter);
    public bool Matches(Type exceptionType);
    public virtual string ToString();
}
internal static class System.Linq.Expressions.Interpreter.ExceptionHelpers : object {
    public static void UnwrapAndRethrow(TargetInvocationException exception);
}
internal abstract class System.Linq.Expressions.Interpreter.ExclusiveOrInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Boolean;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.FieldByRefUpdater : ByRefUpdater {
    private Nullable`1<LocalDefinition> _object;
    private FieldInfo _field;
    public FieldByRefUpdater(Nullable`1<LocalDefinition> obj, FieldInfo field, int argumentIndex);
    public virtual void Update(InterpretedFrame frame, object value);
    public virtual void UndefineTemps(InstructionList instructions, LocalVariables locals);
}
internal abstract class System.Linq.Expressions.Interpreter.FieldInstruction : Instruction {
    protected FieldInfo _field;
    public FieldInstruction(FieldInfo field);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.GetArrayItemInstruction : Instruction {
    internal static GetArrayItemInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static GetArrayItemInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.GotoInstruction : IndexedBranchInstruction {
    private static GotoInstruction[] s_cache;
    private bool _hasResult;
    private bool _hasValue;
    private bool _labelTargetGetsValue;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private GotoInstruction(int targetIndex, bool hasResult, bool hasValue, bool labelTargetGetsValue);
    private static GotoInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    internal static GotoInstruction Create(int labelIndex, bool hasResult, bool hasValue, bool labelTargetGetsValue);
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.GreaterThanInstruction : Instruction {
    private object _nullValue;
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Char;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    private static Instruction s_liftedToNullSByte;
    private static Instruction s_liftedToNullInt16;
    private static Instruction s_liftedToNullChar;
    private static Instruction s_liftedToNullInt32;
    private static Instruction s_liftedToNullInt64;
    private static Instruction s_liftedToNullByte;
    private static Instruction s_liftedToNullUInt16;
    private static Instruction s_liftedToNullUInt32;
    private static Instruction s_liftedToNullUInt64;
    private static Instruction s_liftedToNullSingle;
    private static Instruction s_liftedToNullDouble;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private GreaterThanInstruction(object nullValue);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
}
internal abstract class System.Linq.Expressions.Interpreter.GreaterThanOrEqualInstruction : Instruction {
    private object _nullValue;
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Char;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    private static Instruction s_liftedToNullSByte;
    private static Instruction s_liftedToNullInt16;
    private static Instruction s_liftedToNullChar;
    private static Instruction s_liftedToNullInt32;
    private static Instruction s_liftedToNullInt64;
    private static Instruction s_liftedToNullByte;
    private static Instruction s_liftedToNullUInt16;
    private static Instruction s_liftedToNullUInt32;
    private static Instruction s_liftedToNullUInt64;
    private static Instruction s_liftedToNullSingle;
    private static Instruction s_liftedToNullDouble;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private GreaterThanOrEqualInstruction(object nullValue);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Expressions.Interpreter.HybridReferenceDictionary`2 : object {
    private KeyValuePair`2[] _keysAndValues;
    private Dictionary`2<TKey, TValue> _dict;
    public TValue Item { get; public set; }
    public bool TryGetValue(TKey key, TValue& value);
    public void Remove(TKey key);
    public bool ContainsKey(TKey key);
    public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    [IteratorStateMachineAttribute("System.Linq.Expressions.Interpreter.HybridReferenceDictionary`2/<GetEnumeratorWorker>d__7")]
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumeratorWorker();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
}
internal interface System.Linq.Expressions.Interpreter.IBoxableInstruction {
    public abstract virtual Instruction BoxIfIndexMatches(int index);
}
internal abstract class System.Linq.Expressions.Interpreter.IncrementInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.IndexedBranchInstruction : Instruction {
    internal int _labelIndex;
    public IndexedBranchInstruction(int labelIndex);
    public RuntimeLabel GetLabel(InterpretedFrame frame);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IReadOnlyList`1<object> objects);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.IndexMethodByRefUpdater : ByRefUpdater {
    private MethodInfo _indexer;
    private Nullable`1<LocalDefinition> _obj;
    private LocalDefinition[] _args;
    public IndexMethodByRefUpdater(Nullable`1<LocalDefinition> obj, LocalDefinition[] args, MethodInfo indexer, int argumentIndex);
    public virtual void Update(InterpretedFrame frame, object value);
    public virtual void UndefineTemps(InstructionList instructions, LocalVariables locals);
}
internal abstract class System.Linq.Expressions.Interpreter.InitializeLocalInstruction : LocalAccessInstruction {
    internal InitializeLocalInstruction(int index);
}
internal abstract class System.Linq.Expressions.Interpreter.Instruction : object {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public int ConsumedContinuations { get; }
    public int ProducedContinuations { get; }
    public int StackBalance { get; }
    public int ContinuationsBalance { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedContinuations();
    public virtual int get_ProducedContinuations();
    public int get_StackBalance();
    public int get_ContinuationsBalance();
    public abstract virtual int Run(InterpretedFrame frame);
    public abstract virtual string get_InstructionName();
    public virtual string ToString();
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IReadOnlyList`1<object> objects);
    protected static void NullCheck(object o);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Interpreter.InstructionArray/DebugView")]
[IsReadOnlyAttribute]
internal class System.Linq.Expressions.Interpreter.InstructionArray : ValueType {
    internal int MaxStackDepth;
    internal int MaxContinuationDepth;
    internal Instruction[] Instructions;
    internal Object[] Objects;
    internal RuntimeLabel[] Labels;
    internal List`1<KeyValuePair`2<int, object>> DebugCookies;
    internal InstructionArray(int maxStackDepth, int maxContinuationDepth, Instruction[] instructions, Object[] objects, RuntimeLabel[] labels, List`1<KeyValuePair`2<int, object>> debugCookies);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Interpreter.InstructionList/DebugView")]
internal class System.Linq.Expressions.Interpreter.InstructionList : object {
    private List`1<Instruction> _instructions;
    private List`1<object> _objects;
    private int _currentStackDepth;
    private int _maxStackDepth;
    private int _currentContinuationsDepth;
    private int _maxContinuationDepth;
    private int _runtimeLabelCount;
    private List`1<BranchLabel> _labels;
    private List`1<KeyValuePair`2<int, object>> _debugCookies;
    private static Instruction s_null;
    private static Instruction s_true;
    private static Instruction s_false;
    private static Instruction[] s_Ints;
    private static Instruction[] s_loadObjectCached;
    private static Instruction[] s_loadLocal;
    private static Instruction[] s_loadLocalBoxed;
    private static Instruction[] s_loadLocalFromClosure;
    private static Instruction[] s_loadLocalFromClosureBoxed;
    private static Instruction[] s_assignLocal;
    private static Instruction[] s_storeLocal;
    private static Instruction[] s_assignLocalBoxed;
    private static Instruction[] s_storeLocalBoxed;
    private static Instruction[] s_assignLocalToClosure;
    private static Dictionary`2<FieldInfo, Instruction> s_loadFields;
    private static RuntimeLabel[] s_emptyRuntimeLabels;
    public int Count { get; }
    public int CurrentStackDepth { get; }
    public int CurrentContinuationsDepth { get; }
    private static InstructionList();
    public void Emit(Instruction instruction);
    private void UpdateStackDepth(Instruction instruction);
    public void UnEmit();
    public int get_Count();
    public int get_CurrentStackDepth();
    public int get_CurrentContinuationsDepth();
    internal Instruction GetInstruction(int index);
    public InstructionArray ToArray();
    public void EmitLoad(object value);
    public void EmitLoad(bool value);
    public void EmitLoad(object value, Type type);
    public void EmitDup();
    public void EmitPop();
    internal void SwitchToBoxed(int index, int instructionIndex);
    public void EmitLoadLocal(int index);
    public void EmitLoadLocalBoxed(int index);
    internal static Instruction LoadLocalBoxed(int index);
    public void EmitLoadLocalFromClosure(int index);
    public void EmitLoadLocalFromClosureBoxed(int index);
    public void EmitAssignLocal(int index);
    public void EmitStoreLocal(int index);
    public void EmitAssignLocalBoxed(int index);
    internal static Instruction AssignLocalBoxed(int index);
    public void EmitStoreLocalBoxed(int index);
    internal static Instruction StoreLocalBoxed(int index);
    public void EmitAssignLocalToClosure(int index);
    public void EmitStoreLocalToClosure(int index);
    public void EmitInitializeLocal(int index, Type type);
    internal void EmitInitializeParameter(int index);
    internal static Instruction Parameter(int index);
    internal static Instruction ParameterBox(int index);
    internal static Instruction InitReference(int index);
    internal static Instruction InitImmutableRefBox(int index);
    public void EmitNewRuntimeVariables(int count);
    public void EmitGetArrayItem();
    public void EmitSetArrayItem();
    public void EmitNewArray(Type elementType);
    public void EmitNewArrayBounds(Type elementType, int rank);
    public void EmitNewArrayInit(Type elementType, int elementCount);
    public void EmitAdd(Type type, bool checked);
    public void EmitSub(Type type, bool checked);
    public void EmitMul(Type type, bool checked);
    public void EmitDiv(Type type);
    public void EmitModulo(Type type);
    public void EmitExclusiveOr(Type type);
    public void EmitAnd(Type type);
    public void EmitOr(Type type);
    public void EmitLeftShift(Type type);
    public void EmitRightShift(Type type);
    public void EmitEqual(Type type, bool liftedToNull);
    public void EmitNotEqual(Type type, bool liftedToNull);
    public void EmitLessThan(Type type, bool liftedToNull);
    public void EmitLessThanOrEqual(Type type, bool liftedToNull);
    public void EmitGreaterThan(Type type, bool liftedToNull);
    public void EmitGreaterThanOrEqual(Type type, bool liftedToNull);
    public void EmitNumericConvertChecked(TypeCode from, TypeCode to, bool isLiftedToNull);
    public void EmitNumericConvertUnchecked(TypeCode from, TypeCode to, bool isLiftedToNull);
    public void EmitConvertToUnderlying(TypeCode to, bool isLiftedToNull);
    public void EmitCast(Type toType);
    public void EmitCastToEnum(Type toType);
    public void EmitCastReferenceToEnum(Type toType);
    public void EmitNot(Type type);
    public void EmitDefaultValue(Type type);
    public void EmitNew(ConstructorInfo constructorInfo, ParameterInfo[] parameters);
    public void EmitByRefNew(ConstructorInfo constructorInfo, ParameterInfo[] parameters, ByRefUpdater[] updaters);
    internal void EmitCreateDelegate(LightDelegateCreator creator);
    public void EmitTypeEquals();
    public void EmitArrayLength();
    public void EmitNegate(Type type);
    public void EmitNegateChecked(Type type);
    public void EmitIncrement(Type type);
    public void EmitDecrement(Type type);
    public void EmitTypeIs(Type type);
    public void EmitTypeAs(Type type);
    public void EmitLoadField(FieldInfo field);
    private Instruction GetLoadField(FieldInfo field);
    public void EmitStoreField(FieldInfo field);
    public void EmitCall(MethodInfo method);
    public void EmitCall(MethodInfo method, ParameterInfo[] parameters);
    public void EmitByRefCall(MethodInfo method, ParameterInfo[] parameters, ByRefUpdater[] byrefArgs);
    public void EmitNullableCall(MethodInfo method, ParameterInfo[] parameters);
    private RuntimeLabel[] BuildRuntimeLabels();
    public BranchLabel MakeLabel();
    internal void FixupBranch(int branchIndex, int offset);
    private int EnsureLabelIndex(BranchLabel label);
    public int MarkRuntimeLabel();
    public void MarkLabel(BranchLabel label);
    public void EmitGoto(BranchLabel label, bool hasResult, bool hasValue, bool labelTargetGetsValue);
    private void EmitBranch(OffsetInstruction instruction, BranchLabel label);
    public void EmitBranch(BranchLabel label);
    public void EmitBranch(BranchLabel label, bool hasResult, bool hasValue);
    public void EmitCoalescingBranch(BranchLabel leftNotNull);
    public void EmitBranchTrue(BranchLabel elseLabel);
    public void EmitBranchFalse(BranchLabel elseLabel);
    public void EmitThrow();
    public void EmitThrowVoid();
    public void EmitRethrow();
    public void EmitRethrowVoid();
    public void EmitEnterTryFinally(BranchLabel finallyStartLabel);
    public void EmitEnterTryCatch();
    public EnterTryFaultInstruction EmitEnterTryFault(BranchLabel tryEnd);
    public void EmitEnterFinally(BranchLabel finallyStartLabel);
    public void EmitLeaveFinally();
    public void EmitEnterFault(BranchLabel faultStartLabel);
    public void EmitLeaveFault();
    public void EmitEnterExceptionFilter();
    public void EmitLeaveExceptionFilter();
    public void EmitEnterExceptionHandlerNonVoid();
    public void EmitEnterExceptionHandlerVoid();
    public void EmitLeaveExceptionHandler(bool hasValue, BranchLabel tryExpressionEndLabel);
    public void EmitIntSwitch(Dictionary`2<T, int> cases);
    public void EmitStringSwitch(Dictionary`2<string, int> cases, StrongBox`1<int> nullCase);
}
internal class System.Linq.Expressions.Interpreter.InterpretedFrame : object {
    [ThreadStaticAttribute]
private static InterpretedFrame s_currentFrame;
    internal Interpreter Interpreter;
    internal InterpretedFrame _parent;
    private Int32[] _continuations;
    private int _continuationIndex;
    private int _pendingContinuation;
    private object _pendingValue;
    public Object[] Data;
    public IStrongBox[] Closure;
    public int StackIndex;
    public int InstructionIndex;
    public string Name { get; }
    public InterpretedFrame Parent { get; }
    internal InterpretedFrame(Interpreter interpreter, IStrongBox[] closure);
    public DebugInfo GetDebugInfo(int instructionIndex);
    public string get_Name();
    public void Push(object value);
    public void Push(bool value);
    public void Push(int value);
    public void Push(byte value);
    public void Push(sbyte value);
    public void Push(short value);
    public void Push(ushort value);
    public object Pop();
    internal void SetStackDepth(int depth);
    public object Peek();
    public void Dup();
    public InterpretedFrame get_Parent();
    [IteratorStateMachineAttribute("System.Linq.Expressions.Interpreter.InterpretedFrame/<GetStackTraceDebugInfo>d__29")]
public IEnumerable`1<InterpretedFrameInfo> GetStackTraceDebugInfo();
    internal void SaveTraceToException(Exception exception);
    internal InterpretedFrame Enter();
    internal void Leave(InterpretedFrame prevFrame);
    internal bool IsJumpHappened();
    public void RemoveContinuation();
    public void PushContinuation(int continuation);
    public int YieldToCurrentContinuation();
    public int YieldToPendingContinuation();
    internal void PushPendingContinuation();
    internal void PopPendingContinuation();
    public int Goto(int labelIndex, object value, bool gotoExceptionHandler);
}
[IsReadOnlyAttribute]
internal class System.Linq.Expressions.Interpreter.InterpretedFrameInfo : ValueType {
    private string _methodName;
    private DebugInfo _debugInfo;
    public InterpretedFrameInfo(string methodName, DebugInfo info);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.Interpreter : object {
    internal static object NoValue;
    private InstructionArray _instructions;
    internal Object[] _objects;
    internal RuntimeLabel[] _labels;
    internal DebugInfo[] _debugInfos;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ParameterExpression, LocalVariable> <ClosureVariables>k__BackingField;
    internal string Name { get; }
    internal int LocalCount { get; }
    internal int ClosureSize { get; }
    internal InstructionArray Instructions { get; }
    internal Dictionary`2<ParameterExpression, LocalVariable> ClosureVariables { get; }
    internal Interpreter(string name, LocalVariables locals, InstructionArray instructions, DebugInfo[] debugInfos);
    private static Interpreter();
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal int get_LocalCount();
    internal int get_ClosureSize();
    internal InstructionArray get_Instructions();
    [CompilerGeneratedAttribute]
internal Dictionary`2<ParameterExpression, LocalVariable> get_ClosureVariables();
    public void Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.IntSwitchInstruction`1 : Instruction {
    private Dictionary`2<T, int> _cases;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    internal IntSwitchInstruction`1(Dictionary`2<T, int> cases);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LabelInfo : object {
    private LabelTarget _node;
    private BranchLabel _label;
    private object _definitions;
    private List`1<LabelScopeInfo> _references;
    private bool _acrossBlockJump;
    private bool HasDefinitions { get; }
    private bool HasMultipleDefinitions { get; }
    internal LabelInfo(LabelTarget node);
    internal BranchLabel GetLabel(LightCompiler compiler);
    internal void Reference(LabelScopeInfo block);
    internal void Define(LabelScopeInfo block);
    private void ValidateJump(LabelScopeInfo reference);
    internal void ValidateFinish();
    private void EnsureLabel(LightCompiler compiler);
    private bool DefinedIn(LabelScopeInfo scope);
    private bool get_HasDefinitions();
    private LabelScopeInfo FirstDefinition();
    private void AddDefinition(LabelScopeInfo scope);
    private bool get_HasMultipleDefinitions();
    internal static T CommonNode(T first, T second, Func`2<T, T> parent);
}
internal class System.Linq.Expressions.Interpreter.LabelScopeInfo : object {
    private HybridReferenceDictionary`2<LabelTarget, LabelInfo> _labels;
    internal LabelScopeKind Kind;
    internal LabelScopeInfo Parent;
    internal bool CanJumpInto { get; }
    internal LabelScopeInfo(LabelScopeInfo parent, LabelScopeKind kind);
    internal bool get_CanJumpInto();
    internal bool ContainsTarget(LabelTarget target);
    internal bool TryGetLabelInfo(LabelTarget target, LabelInfo& info);
    internal void AddLabelInfo(LabelTarget target, LabelInfo info);
}
internal enum System.Linq.Expressions.Interpreter.LabelScopeKind : Enum {
    public int value__;
    public static LabelScopeKind Statement;
    public static LabelScopeKind Block;
    public static LabelScopeKind Switch;
    public static LabelScopeKind Lambda;
    public static LabelScopeKind Try;
    public static LabelScopeKind Catch;
    public static LabelScopeKind Finally;
    public static LabelScopeKind Filter;
    public static LabelScopeKind Expression;
}
internal class System.Linq.Expressions.Interpreter.LeaveExceptionFilterInstruction : Instruction {
    internal static LeaveExceptionFilterInstruction Instance;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    private static LeaveExceptionFilterInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    [ExcludeFromCodeCoverageAttribute]
public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LeaveExceptionHandlerInstruction : IndexedBranchInstruction {
    private static LeaveExceptionHandlerInstruction[] s_cache;
    private bool _hasValue;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private LeaveExceptionHandlerInstruction(int labelIndex, bool hasValue);
    private static LeaveExceptionHandlerInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    internal static LeaveExceptionHandlerInstruction Create(int labelIndex, bool hasValue);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LeaveFaultInstruction : Instruction {
    internal static Instruction Instance;
    public int ConsumedStack { get; }
    public int ConsumedContinuations { get; }
    public string InstructionName { get; }
    private static LeaveFaultInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ConsumedContinuations();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LeaveFinallyInstruction : Instruction {
    internal static Instruction Instance;
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    private static LeaveFinallyInstruction();
    public virtual int get_ConsumedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.LeftShiftInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.LessThanInstruction : Instruction {
    private object _nullValue;
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Char;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    private static Instruction s_liftedToNullSByte;
    private static Instruction s_liftedToNullInt16;
    private static Instruction s_liftedToNullChar;
    private static Instruction s_liftedToNullInt32;
    private static Instruction s_liftedToNullInt64;
    private static Instruction s_liftedToNullByte;
    private static Instruction s_liftedToNullUInt16;
    private static Instruction s_liftedToNullUInt32;
    private static Instruction s_liftedToNullUInt64;
    private static Instruction s_liftedToNullSingle;
    private static Instruction s_liftedToNullDouble;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private LessThanInstruction(object nullValue);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
}
internal abstract class System.Linq.Expressions.Interpreter.LessThanOrEqualInstruction : Instruction {
    private object _nullValue;
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Char;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    private static Instruction s_liftedToNullSByte;
    private static Instruction s_liftedToNullInt16;
    private static Instruction s_liftedToNullChar;
    private static Instruction s_liftedToNullInt32;
    private static Instruction s_liftedToNullInt64;
    private static Instruction s_liftedToNullByte;
    private static Instruction s_liftedToNullUInt16;
    private static Instruction s_liftedToNullUInt32;
    private static Instruction s_liftedToNullUInt64;
    private static Instruction s_liftedToNullSingle;
    private static Instruction s_liftedToNullDouble;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private LessThanOrEqualInstruction(object nullValue);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
}
internal class System.Linq.Expressions.Interpreter.LightCompiler : object {
    private InstructionList _instructions;
    private LocalVariables _locals;
    private List`1<DebugInfo> _debugInfos;
    private HybridReferenceDictionary`2<LabelTarget, LabelInfo> _treeLabels;
    private LabelScopeInfo _labelBlock;
    private Stack`1<ParameterExpression> _exceptionForRethrowStack;
    private LightCompiler _parent;
    private StackGuard _guard;
    private static LocalDefinition[] s_emptyLocals;
    public InstructionList Instructions { get; }
    private LightCompiler(LightCompiler parent);
    private static LightCompiler();
    public InstructionList get_Instructions();
    public LightDelegateCreator CompileTop(LambdaExpression node);
    private Interpreter MakeInterpreter(string lambdaName);
    private void CompileConstantExpression(Expression expr);
    private void CompileDefaultExpression(Expression expr);
    private void CompileDefaultExpression(Type type);
    private LocalVariable EnsureAvailableForClosure(ParameterExpression expr);
    private LocalVariable ResolveLocal(ParameterExpression variable);
    private void CompileGetVariable(ParameterExpression variable);
    private void EmitCopyValueType(Type valueType);
    private void LoadLocalNoValueTypeCopy(ParameterExpression variable);
    private bool MaybeMutableValueType(Type type);
    private void CompileGetBoxedVariable(ParameterExpression variable);
    private void CompileSetVariable(ParameterExpression variable, bool isVoid);
    private void CompileParameterExpression(Expression expr);
    private void CompileBlockExpression(Expression expr, bool asVoid);
    private LocalDefinition[] CompileBlockStart(BlockExpression node);
    private void CompileBlockEnd(LocalDefinition[] locals);
    private void CompileIndexExpression(Expression expr);
    private void EmitIndexGet(IndexExpression index);
    private void CompileIndexAssignment(BinaryExpression node, bool asVoid);
    private void CompileMemberAssignment(BinaryExpression node, bool asVoid);
    private void CompileMemberAssignment(bool asVoid, MemberInfo refMember, Expression value, bool forBinding);
    private void CompileVariableAssignment(BinaryExpression node, bool asVoid);
    private void CompileAssignBinaryExpression(Expression expr, bool asVoid);
    private void CompileBinaryExpression(Expression expr);
    private void CompileEqual(Expression left, Expression right, bool liftedToNull);
    private void CompileNotEqual(Expression left, Expression right, bool liftedToNull);
    private void CompileComparison(BinaryExpression node);
    private void CompileArithmetic(ExpressionType nodeType, Expression left, Expression right);
    private void CompileConvertUnaryExpression(Expression expr);
    private void CompileConvertToType(Type typeFrom, Type typeTo, bool isChecked, bool isLiftedToNull);
    private void CompileNotExpression(UnaryExpression node);
    private void CompileUnaryExpression(Expression expr);
    private void EmitUnaryMethodCall(UnaryExpression node);
    private void EmitUnaryBoolCheck(UnaryExpression node);
    private void CompileAndAlsoBinaryExpression(Expression expr);
    private void CompileOrElseBinaryExpression(Expression expr);
    private void CompileLogicalBinaryExpression(BinaryExpression b, bool andAlso);
    private void CompileMethodLogicalBinaryExpression(BinaryExpression expr, bool andAlso);
    private void CompileLiftedLogicalBinaryExpression(BinaryExpression node, bool andAlso);
    private void CompileUnliftedLogicalBinaryExpression(BinaryExpression expr, bool andAlso);
    private void CompileConditionalExpression(Expression expr, bool asVoid);
    private void CompileLoopExpression(Expression expr);
    private void CompileSwitchExpression(Expression expr);
    private void CompileIntSwitchExpression(SwitchExpression node);
    private void CompileStringSwitchExpression(SwitchExpression node);
    private void CompileLabelExpression(Expression expr);
    private void CompileGotoExpression(Expression expr);
    private void PushLabelBlock(LabelScopeKind type);
    private void PopLabelBlock(LabelScopeKind kind);
    private LabelInfo EnsureLabel(LabelTarget node);
    private LabelInfo ReferenceLabel(LabelTarget node);
    private LabelInfo DefineLabel(LabelTarget node);
    private bool TryPushLabelBlock(Expression node);
    private void DefineBlockLabels(Expression node);
    private void CheckRethrow();
    private void CompileThrowUnaryExpression(Expression expr, bool asVoid);
    private void CompileTryExpression(Expression expr);
    private void CompileTryFaultExpression(TryExpression expr);
    private void CompileMethodCallExpression(Expression expr);
    private void CompileMethodCallExpression(Expression object, MethodInfo method, IArgumentProvider arguments);
    private ByRefUpdater CompileArrayIndexAddress(Expression array, Expression index, int argumentIndex);
    private void EmitThisForMethodCall(Expression node);
    private static bool ShouldWritebackNode(Expression node);
    private ByRefUpdater CompileAddress(Expression node, int index);
    private ByRefUpdater CompileMultiDimArrayAccess(Expression array, IArgumentProvider arguments, int index);
    private void CompileNewExpression(Expression expr);
    private void CompileMemberExpression(Expression expr);
    private void CompileMember(Expression from, MemberInfo member, bool forBinding);
    private void CompileNewArrayExpression(Expression expr);
    private void CompileDebugInfoExpression(Expression expr);
    private void CompileRuntimeVariablesExpression(Expression expr);
    private void CompileLambdaExpression(Expression expr);
    private void CompileCoalesceBinaryExpression(Expression expr);
    private void CompileInvocationExpression(Expression expr);
    private void CompileListInitExpression(Expression expr);
    private void CompileListInit(ReadOnlyCollection`1<ElementInit> initializers);
    private void CompileMemberInitExpression(Expression expr);
    private void CompileMemberInit(ReadOnlyCollection`1<MemberBinding> bindings);
    private static Type GetMemberType(MemberInfo member);
    private void CompileQuoteUnaryExpression(Expression expr);
    private void CompileUnboxUnaryExpression(Expression expr);
    private void CompileTypeEqualExpression(Expression expr);
    private void CompileTypeAsExpression(UnaryExpression node);
    private void CompileTypeIsExpression(Expression expr);
    private void Compile(Expression expr, bool asVoid);
    private void CompileAsVoid(Expression expr);
    private void CompileNoLabelPush(Expression expr);
    private void Compile(Expression expr);
}
internal class System.Linq.Expressions.Interpreter.LightDelegateCreator : object {
    private LambdaExpression _lambda;
    [CompilerGeneratedAttribute]
private Interpreter <Interpreter>k__BackingField;
    internal Interpreter Interpreter { get; }
    internal LightDelegateCreator(Interpreter interpreter, LambdaExpression lambda);
    [CompilerGeneratedAttribute]
internal Interpreter get_Interpreter();
    public Delegate CreateDelegate();
    internal Delegate CreateDelegate(IStrongBox[] closure);
}
public class System.Linq.Expressions.Interpreter.LightLambda : object {
    private IStrongBox[] _closure;
    private Interpreter _interpreter;
    private LightDelegateCreator _delegateCreator;
    internal string DebugView { get; }
    internal LightLambda(LightDelegateCreator delegateCreator, IStrongBox[] closure);
    internal string get_DebugView();
    internal Delegate MakeDelegate(Type delegateType);
    private InterpretedFrame MakeFrame();
    public object Run(Object[] arguments);
    public object RunVoid(Object[] arguments);
}
internal class System.Linq.Expressions.Interpreter.LoadCachedObjectInstruction : Instruction {
    private UInt32 _index;
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadCachedObjectInstruction(UInt32 index);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IReadOnlyList`1<object> objects);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.LoadFieldInstruction : FieldInstruction {
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public LoadFieldInstruction(FieldInfo field);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LoadLocalBoxedInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadLocalBoxedInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LoadLocalFromClosureBoxedInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadLocalFromClosureBoxedInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LoadLocalFromClosureInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadLocalFromClosureInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.LoadLocalInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadLocalInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class System.Linq.Expressions.Interpreter.LoadObjectInstruction : Instruction {
    private object _value;
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal LoadObjectInstruction(object value);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.LoadStaticFieldInstruction : FieldInstruction {
    public string InstructionName { get; }
    public int ProducedStack { get; }
    public LoadStaticFieldInstruction(FieldInfo field);
    public virtual string get_InstructionName();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.LocalAccessInstruction : Instruction {
    internal int _index;
    protected LocalAccessInstruction(int index);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IReadOnlyList`1<object> objects);
}
[IsReadOnlyAttribute]
internal class System.Linq.Expressions.Interpreter.LocalDefinition : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Parameter>k__BackingField;
    public int Index { get; }
    public ParameterExpression Parameter { get; }
    internal LocalDefinition(int localIndex, ParameterExpression parameter);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public ParameterExpression get_Parameter();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Linq.Expressions.Interpreter.LocalVariable : object {
    public int Index;
    private int _flags;
    public bool IsBoxed { get; public set; }
    public bool InClosure { get; }
    internal LocalVariable(int index, bool closure);
    public bool get_IsBoxed();
    public void set_IsBoxed(bool value);
    public bool get_InClosure();
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.LocalVariables : object {
    private HybridReferenceDictionary`2<ParameterExpression, VariableScope> _variables;
    private Dictionary`2<ParameterExpression, LocalVariable> _closureVariables;
    private int _localCount;
    private int _maxLocalCount;
    public int LocalCount { get; }
    internal Dictionary`2<ParameterExpression, LocalVariable> ClosureVariables { get; }
    public LocalDefinition DefineLocal(ParameterExpression variable, int start);
    public void UndefineLocal(LocalDefinition definition, int end);
    internal void Box(ParameterExpression variable, InstructionList instructions);
    public int get_LocalCount();
    public bool TryGetLocalOrClosure(ParameterExpression var, LocalVariable& local);
    internal Dictionary`2<ParameterExpression, LocalVariable> get_ClosureVariables();
    internal LocalVariable AddClosureVariable(ParameterExpression variable);
}
internal class System.Linq.Expressions.Interpreter.MethodInfoCallInstruction : CallInstruction {
    protected MethodInfo _target;
    protected int _argumentCount;
    public int ArgumentCount { get; }
    public int ProducedStack { get; }
    internal MethodInfoCallInstruction(MethodInfo target, int argumentCount);
    public virtual int get_ArgumentCount();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    protected Object[] GetArgs(InterpretedFrame frame, int first, int skip);
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.ModuloInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.MulInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.MulOvfInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.NegateCheckedInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.NegateInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.NewArrayBoundsInstruction : Instruction {
    private Type _elementType;
    private int _rank;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal NewArrayBoundsInstruction(Type elementType, int rank);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.NewArrayInitInstruction : Instruction {
    private Type _elementType;
    private int _elementCount;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal NewArrayInitInstruction(Type elementType, int elementCount);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.NewArrayInstruction : Instruction {
    private Type _elementType;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal NewArrayInstruction(Type elementType);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.NewInstruction : Instruction {
    protected ConstructorInfo _constructor;
    protected int _argumentCount;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public NewInstruction(ConstructorInfo constructor, int argumentCount);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    protected Object[] GetArgs(InterpretedFrame frame, int first);
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.NotEqualInstruction : Instruction {
    private static Instruction s_reference;
    private static Instruction s_Boolean;
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Char;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    private static Instruction s_SByteLiftedToNull;
    private static Instruction s_Int16LiftedToNull;
    private static Instruction s_CharLiftedToNull;
    private static Instruction s_Int32LiftedToNull;
    private static Instruction s_Int64LiftedToNull;
    private static Instruction s_ByteLiftedToNull;
    private static Instruction s_UInt16LiftedToNull;
    private static Instruction s_UInt32LiftedToNull;
    private static Instruction s_UInt64LiftedToNull;
    private static Instruction s_SingleLiftedToNull;
    private static Instruction s_DoubleLiftedToNull;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type, bool liftedToNull);
}
internal abstract class System.Linq.Expressions.Interpreter.NotInstruction : Instruction {
    public static Instruction s_Boolean;
    public static Instruction s_Int64;
    public static Instruction s_Int32;
    public static Instruction s_Int16;
    public static Instruction s_UInt64;
    public static Instruction s_UInt32;
    public static Instruction s_UInt16;
    public static Instruction s_Byte;
    public static Instruction s_SByte;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.NullableMethodCallInstruction : Instruction {
    private static NullableMethodCallInstruction s_hasValue;
    private static NullableMethodCallInstruction s_value;
    private static NullableMethodCallInstruction s_equals;
    private static NullableMethodCallInstruction s_getHashCode;
    private static NullableMethodCallInstruction s_getValueOrDefault1;
    private static NullableMethodCallInstruction s_toString;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(string method, int argCount, MethodInfo mi);
    public static Instruction CreateGetValue();
}
internal class System.Linq.Expressions.Interpreter.NullCheckInstruction : Instruction {
    public static Instruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static NullCheckInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.NumericConvertInstruction : Instruction {
    internal TypeCode _from;
    internal TypeCode _to;
    private bool _isLiftedToNull;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    protected NumericConvertInstruction(TypeCode from, TypeCode to, bool isLiftedToNull);
    public sealed virtual int Run(InterpretedFrame frame);
    protected abstract virtual object Convert(object obj);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.OffsetInstruction : Instruction {
    protected int _offset;
    public Instruction[] Cache { get; }
    public abstract virtual Instruction[] get_Cache();
    public Instruction Fixup(int offset);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IReadOnlyList`1<object> objects);
    public virtual string ToString();
}
internal abstract class System.Linq.Expressions.Interpreter.OrInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Boolean;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.ParameterByRefUpdater : ByRefUpdater {
    private LocalVariable _parameter;
    public ParameterByRefUpdater(LocalVariable parameter, int argumentIndex);
    public virtual void Update(InterpretedFrame frame, object value);
}
internal class System.Linq.Expressions.Interpreter.PopInstruction : Instruction {
    internal static PopInstruction Instance;
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    private static PopInstruction();
    public virtual int get_ConsumedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.PropertyByRefUpdater : ByRefUpdater {
    private Nullable`1<LocalDefinition> _object;
    private PropertyInfo _property;
    public PropertyByRefUpdater(Nullable`1<LocalDefinition> obj, PropertyInfo property, int argumentIndex);
    public virtual void Update(InterpretedFrame frame, object value);
    public virtual void UndefineTemps(InstructionList instructions, LocalVariables locals);
}
internal class System.Linq.Expressions.Interpreter.QuoteInstruction : Instruction {
    private Expression _operand;
    private Dictionary`2<ParameterExpression, LocalVariable> _hoistedVariables;
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public QuoteInstruction(Expression operand, Dictionary`2<ParameterExpression, LocalVariable> hoistedVariables);
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.RethrowException : Exception {
}
internal abstract class System.Linq.Expressions.Interpreter.RightShiftInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_Byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
[IsReadOnlyAttribute]
internal class System.Linq.Expressions.Interpreter.RuntimeLabel : ValueType {
    public int Index;
    public int StackDepth;
    public int ContinuationStackDepth;
    public RuntimeLabel(int index, int continuationStackDepth, int stackDepth);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.RuntimeVariables : object {
    private IStrongBox[] _boxes;
    private int System.Runtime.CompilerServices.IRuntimeVariables.Count { get; }
    private object System.Runtime.CompilerServices.IRuntimeVariables.Item { get; private set; }
    private RuntimeVariables(IStrongBox[] boxes);
    private sealed virtual override int System.Runtime.CompilerServices.IRuntimeVariables.get_Count();
    private sealed virtual override object System.Runtime.CompilerServices.IRuntimeVariables.get_Item(int index);
    private sealed virtual override void System.Runtime.CompilerServices.IRuntimeVariables.set_Item(int index, object value);
    internal static IRuntimeVariables Create(IStrongBox[] boxes);
}
internal class System.Linq.Expressions.Interpreter.RuntimeVariablesInstruction : Instruction {
    private int _count;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    public RuntimeVariablesInstruction(int count);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal static class System.Linq.Expressions.Interpreter.ScriptingRuntimeHelpers : object {
    public static object Int32ToObject(int i);
    internal static object GetPrimitiveDefaultValue(Type type);
}
internal class System.Linq.Expressions.Interpreter.SetArrayItemInstruction : Instruction {
    internal static SetArrayItemInstruction Instance;
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    private static SetArrayItemInstruction();
    public virtual int get_ConsumedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.StoreFieldInstruction : FieldInstruction {
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public StoreFieldInstruction(FieldInfo field);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.StoreLocalBoxedInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    internal StoreLocalBoxedInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.StoreLocalInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    internal StoreLocalInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class System.Linq.Expressions.Interpreter.StoreStaticFieldInstruction : FieldInstruction {
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    public StoreStaticFieldInstruction(FieldInfo field);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.StringSwitchInstruction : Instruction {
    private Dictionary`2<string, int> _cases;
    private StrongBox`1<int> _nullCase;
    public string InstructionName { get; }
    public int ConsumedStack { get; }
    internal StringSwitchInstruction(Dictionary`2<string, int> cases, StrongBox`1<int> nullCase);
    public virtual string get_InstructionName();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Linq.Expressions.Interpreter.SubInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_Single;
    private static Instruction s_Double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal abstract class System.Linq.Expressions.Interpreter.SubOvfInstruction : Instruction {
    private static Instruction s_Int16;
    private static Instruction s_Int32;
    private static Instruction s_Int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public static Instruction Create(Type type);
}
internal class System.Linq.Expressions.Interpreter.ThrowInstruction : Instruction {
    internal static ThrowInstruction Throw;
    internal static ThrowInstruction VoidThrow;
    internal static ThrowInstruction Rethrow;
    internal static ThrowInstruction VoidRethrow;
    private bool _hasResult;
    private bool _rethrow;
    public string InstructionName { get; }
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private ThrowInstruction(bool hasResult, bool isRethrow);
    private static ThrowInstruction();
    public virtual string get_InstructionName();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    private static Exception WrapThrownObject(object thrown);
}
internal class System.Linq.Expressions.Interpreter.TryCatchFinallyHandler : object {
    internal int TryStartIndex;
    internal int TryEndIndex;
    internal int FinallyStartIndex;
    internal int FinallyEndIndex;
    internal int GotoEndTargetIndex;
    private ExceptionHandler[] _handlers;
    internal bool IsFinallyBlockExist { get; }
    internal ExceptionHandler[] Handlers { get; }
    internal bool IsCatchBlockExist { get; }
    internal TryCatchFinallyHandler(int tryStart, int tryEnd, int gotoEndTargetIndex, ExceptionHandler[] handlers);
    internal TryCatchFinallyHandler(int tryStart, int tryEnd, int gotoEndLabelIndex, int finallyStart, int finallyEnd, ExceptionHandler[] handlers);
    internal bool get_IsFinallyBlockExist();
    internal ExceptionHandler[] get_Handlers();
    internal bool get_IsCatchBlockExist();
    internal bool HasHandler(InterpretedFrame frame, Exception exception, ExceptionHandler& handler, Object& unwrappedException);
    private static bool FilterPasses(InterpretedFrame frame, Object& exception, ExceptionFilter filter);
}
internal class System.Linq.Expressions.Interpreter.TryFaultHandler : object {
    internal int TryStartIndex;
    internal int TryEndIndex;
    internal int FinallyStartIndex;
    internal int FinallyEndIndex;
    internal TryFaultHandler(int tryStart, int tryEnd, int finallyStart, int finallyEnd);
}
internal class System.Linq.Expressions.Interpreter.TypeAsInstruction : Instruction {
    private Type _type;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal TypeAsInstruction(Type type);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.TypeEqualsInstruction : Instruction {
    public static TypeEqualsInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static TypeEqualsInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Linq.Expressions.Interpreter.TypeIsInstruction : Instruction {
    private Type _type;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    internal TypeIsInstruction(Type type);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Linq.Expressions.Interpreter.ValueTypeCopyInstruction : Instruction {
    public static ValueTypeCopyInstruction Instruction;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static ValueTypeCopyInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string get_InstructionName();
    public virtual int Run(InterpretedFrame frame);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/InvocationExpressionProxy")]
public class System.Linq.Expressions.InvocationExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Expression { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    [ExcludeFromCodeCoverageAttribute]
public int ArgumentCount { get; }
    internal LambdaExpression LambdaOperand { get; }
    internal InvocationExpression(Expression expression, Type returnType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public InvocationExpression Update(Expression expression, IEnumerable`1<Expression> arguments);
    [ExcludeFromCodeCoverageAttribute]
internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    [ExcludeFromCodeCoverageAttribute]
public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    [ExcludeFromCodeCoverageAttribute]
internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
    internal LambdaExpression get_LambdaOperand();
}
internal class System.Linq.Expressions.InvocationExpression0 : InvocationExpression {
    public int ArgumentCount { get; }
    public InvocationExpression0(Expression lambda, Type returnType);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression1 : InvocationExpression {
    private object _arg0;
    public int ArgumentCount { get; }
    public InvocationExpression1(Expression lambda, Type returnType, Expression arg0);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression2 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    public int ArgumentCount { get; }
    public InvocationExpression2(Expression lambda, Type returnType, Expression arg0, Expression arg1);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression3 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    public int ArgumentCount { get; }
    public InvocationExpression3(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression4 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    public int ArgumentCount { get; }
    public InvocationExpression4(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpression5 : InvocationExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private Expression _arg4;
    public int ArgumentCount { get; }
    public InvocationExpression5(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal class System.Linq.Expressions.InvocationExpressionN : InvocationExpression {
    private IReadOnlyList`1<Expression> _arguments;
    public int ArgumentCount { get; }
    public InvocationExpressionN(Expression lambda, IReadOnlyList`1<Expression> arguments, Type returnType);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments);
}
internal interface System.Linq.Expressions.IParameterProvider {
    public int ParameterCount { get; }
    public abstract virtual ParameterExpression GetParameter(int index);
    public abstract virtual int get_ParameterCount();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LabelExpressionProxy")]
public class System.Linq.Expressions.LabelExpression : Expression {
    [CompilerGeneratedAttribute]
private LabelTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <DefaultValue>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public LabelTarget Target { get; }
    public Expression DefaultValue { get; }
    internal LabelExpression(LabelTarget label, Expression defaultValue);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public LabelTarget get_Target();
    [CompilerGeneratedAttribute]
public Expression get_DefaultValue();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LabelExpression Update(LabelTarget target, Expression defaultValue);
}
public class System.Linq.Expressions.LabelTarget : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Name { get; }
    public Type Type { get; }
    internal LabelTarget(Type type, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Type get_Type();
    public virtual string ToString();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LambdaExpressionProxy")]
public abstract class System.Linq.Expressions.LambdaExpression : Expression {
    private Expression _body;
    public Type Type { get; }
    internal Type TypeCore { get; }
    internal Type PublicType { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Parameters { get; }
    public string Name { get; }
    internal string NameCore { get; }
    public Expression Body { get; }
    public Type ReturnType { get; }
    public bool TailCall { get; }
    internal bool TailCallCore { get; }
    [ExcludeFromCodeCoverageAttribute]
private int System.Linq.Expressions.IParameterProvider.ParameterCount { get; }
    [ExcludeFromCodeCoverageAttribute]
internal int ParameterCount { get; }
    internal LambdaExpression(Expression body);
    public sealed virtual Type get_Type();
    internal abstract virtual Type get_TypeCore();
    internal abstract virtual Type get_PublicType();
    public sealed virtual ExpressionType get_NodeType();
    public ReadOnlyCollection`1<ParameterExpression> get_Parameters();
    public string get_Name();
    internal virtual string get_NameCore();
    public Expression get_Body();
    public Type get_ReturnType();
    public bool get_TailCall();
    internal virtual bool get_TailCallCore();
    [ExcludeFromCodeCoverageAttribute]
internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeParameters();
    [ExcludeFromCodeCoverageAttribute]
private sealed virtual override ParameterExpression System.Linq.Expressions.IParameterProvider.GetParameter(int index);
    [ExcludeFromCodeCoverageAttribute]
internal virtual ParameterExpression GetParameter(int index);
    private sealed virtual override int System.Linq.Expressions.IParameterProvider.get_ParameterCount();
    internal virtual int get_ParameterCount();
    public Delegate Compile();
    public Delegate Compile(bool preferInterpretation);
    internal abstract virtual LambdaExpression Accept(StackSpiller spiller);
    public Delegate Compile(DebugInfoGenerator debugInfoGenerator);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ListInitExpressionProxy")]
public class System.Linq.Expressions.ListInitExpression : Expression {
    [CompilerGeneratedAttribute]
private NewExpression <NewExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ElementInit> <Initializers>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool CanReduce { get; }
    public NewExpression NewExpression { get; }
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    internal ListInitExpression(NewExpression newExpression, ReadOnlyCollection`1<ElementInit> initializers);
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public virtual bool get_CanReduce();
    [CompilerGeneratedAttribute]
public NewExpression get_NewExpression();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ElementInit> get_Initializers();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public ListInitExpression Update(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
}
internal class System.Linq.Expressions.LogicalBinaryExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal LogicalBinaryExpression(ExpressionType nodeType, Expression left, Expression right);
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/LoopExpressionProxy")]
public class System.Linq.Expressions.LoopExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelTarget <BreakLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelTarget <ContinueLabel>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Body { get; }
    public LabelTarget BreakLabel { get; }
    public LabelTarget ContinueLabel { get; }
    internal LoopExpression(Expression body, LabelTarget break, LabelTarget continue);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Body();
    [CompilerGeneratedAttribute]
public LabelTarget get_BreakLabel();
    [CompilerGeneratedAttribute]
public LabelTarget get_ContinueLabel();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LoopExpression Update(LabelTarget breakLabel, LabelTarget continueLabel, Expression body);
}
public class System.Linq.Expressions.MemberAssignment : MemberBinding {
    private Expression _expression;
    public Expression Expression { get; }
    internal MemberAssignment(MemberInfo member, Expression expression);
    public Expression get_Expression();
    public MemberAssignment Update(Expression expression);
    internal virtual void ValidateAsDefinedHere(int index);
}
public abstract class System.Linq.Expressions.MemberBinding : object {
    [CompilerGeneratedAttribute]
private MemberBindingType <BindingType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    public MemberBindingType BindingType { get; }
    public MemberInfo Member { get; }
    [ObsoleteAttribute("Do not use this constructor. It will be removed in future releases.")]
protected MemberBinding(MemberBindingType type, MemberInfo member);
    [CompilerGeneratedAttribute]
public MemberBindingType get_BindingType();
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    public virtual string ToString();
    internal virtual void ValidateAsDefinedHere(int index);
}
public enum System.Linq.Expressions.MemberBindingType : Enum {
    public int value__;
    public static MemberBindingType Assignment;
    public static MemberBindingType MemberBinding;
    public static MemberBindingType ListBinding;
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MemberExpressionProxy")]
public class System.Linq.Expressions.MemberExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public MemberInfo Member { get; }
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    internal MemberExpression(Expression expression);
    public MemberInfo get_Member();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    internal static PropertyExpression Make(Expression expression, PropertyInfo property);
    internal static FieldExpression Make(Expression expression, FieldInfo field);
    internal static MemberExpression Make(Expression expression, MemberInfo member);
    public sealed virtual ExpressionType get_NodeType();
    [ExcludeFromCodeCoverageAttribute]
internal virtual MemberInfo GetMember();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public MemberExpression Update(Expression expression);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MemberInitExpressionProxy")]
public class System.Linq.Expressions.MemberInitExpression : Expression {
    [CompilerGeneratedAttribute]
private NewExpression <NewExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<MemberBinding> <Bindings>k__BackingField;
    public Type Type { get; }
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public NewExpression NewExpression { get; }
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    internal MemberInitExpression(NewExpression newExpression, ReadOnlyCollection`1<MemberBinding> bindings);
    public sealed virtual Type get_Type();
    public virtual bool get_CanReduce();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public NewExpression get_NewExpression();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    private static Expression ReduceMemberInit(Expression objExpression, ReadOnlyCollection`1<MemberBinding> bindings, bool keepOnStack);
    internal static Expression ReduceListInit(Expression listExpression, ReadOnlyCollection`1<ElementInit> initializers, bool keepOnStack);
    internal static Expression ReduceMemberBinding(ParameterExpression objVar, MemberBinding binding);
    public MemberInitExpression Update(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
}
public class System.Linq.Expressions.MemberListBinding : MemberBinding {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ElementInit> <Initializers>k__BackingField;
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    internal MemberListBinding(MemberInfo member, ReadOnlyCollection`1<ElementInit> initializers);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ElementInit> get_Initializers();
    public MemberListBinding Update(IEnumerable`1<ElementInit> initializers);
    internal virtual void ValidateAsDefinedHere(int index);
}
public class System.Linq.Expressions.MemberMemberBinding : MemberBinding {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<MemberBinding> <Bindings>k__BackingField;
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    internal MemberMemberBinding(MemberInfo member, ReadOnlyCollection`1<MemberBinding> bindings);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    public MemberMemberBinding Update(IEnumerable`1<MemberBinding> bindings);
    internal virtual void ValidateAsDefinedHere(int index);
}
internal class System.Linq.Expressions.MethodBinaryExpression : SimpleBinaryExpression {
    private MethodInfo _method;
    internal MethodBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method);
    internal virtual MethodInfo GetMethod();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/MethodCallExpressionProxy")]
public class System.Linq.Expressions.MethodCallExpression : Expression {
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public MethodInfo Method { get; }
    public Expression Object { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    [ExcludeFromCodeCoverageAttribute]
public int ArgumentCount { get; }
    internal MethodCallExpression(MethodInfo method);
    internal virtual Expression GetInstance();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    public Expression get_Object();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public MethodCallExpression Update(Expression object, IEnumerable`1<Expression> arguments);
    [ExcludeFromCodeCoverageAttribute]
internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    [ExcludeFromCodeCoverageAttribute]
internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    [ExcludeFromCodeCoverageAttribute]
internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
    [ExcludeFromCodeCoverageAttribute]
public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
}
internal class System.Linq.Expressions.MethodCallExpression0 : MethodCallExpression {
    public int ArgumentCount { get; }
    public MethodCallExpression0(MethodInfo method);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression1 : MethodCallExpression {
    private object _arg0;
    public int ArgumentCount { get; }
    public MethodCallExpression1(MethodInfo method, Expression arg0);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression2 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    public int ArgumentCount { get; }
    public MethodCallExpression2(MethodInfo method, Expression arg0, Expression arg1);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression3 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    public int ArgumentCount { get; }
    public MethodCallExpression3(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression4 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    public int ArgumentCount { get; }
    public MethodCallExpression4(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpression5 : MethodCallExpression {
    private object _arg0;
    private Expression _arg1;
    private Expression _arg2;
    private Expression _arg3;
    private Expression _arg4;
    public int ArgumentCount { get; }
    public MethodCallExpression5(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.MethodCallExpressionN : MethodCallExpression {
    private IReadOnlyList`1<Expression> _arguments;
    public int ArgumentCount { get; }
    public MethodCallExpressionN(MethodInfo method, IReadOnlyList`1<Expression> args);
    public virtual Expression GetArgument(int index);
    public virtual int get_ArgumentCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeArguments();
    internal virtual bool SameArguments(ICollection`1<Expression> arguments);
    internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList`1<Expression> args);
}
internal class System.Linq.Expressions.NewArrayBoundsExpression : NewArrayExpression {
    public ExpressionType NodeType { get; }
    internal NewArrayBoundsExpression(Type type, ReadOnlyCollection`1<Expression> expressions);
    public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/NewArrayExpressionProxy")]
public class System.Linq.Expressions.NewArrayExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Expression> <Expressions>k__BackingField;
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    internal NewArrayExpression(Type type, ReadOnlyCollection`1<Expression> expressions);
    internal static NewArrayExpression Make(ExpressionType nodeType, Type type, ReadOnlyCollection`1<Expression> expressions);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Expression> get_Expressions();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewArrayExpression Update(IEnumerable`1<Expression> expressions);
}
internal class System.Linq.Expressions.NewArrayInitExpression : NewArrayExpression {
    public ExpressionType NodeType { get; }
    internal NewArrayInitExpression(Type type, ReadOnlyCollection`1<Expression> expressions);
    public sealed virtual ExpressionType get_NodeType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/NewExpressionProxy")]
public class System.Linq.Expressions.NewExpression : Expression {
    private IReadOnlyList`1<Expression> _arguments;
    [CompilerGeneratedAttribute]
private ConstructorInfo <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<MemberInfo> <Members>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public ConstructorInfo Constructor { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public int ArgumentCount { get; }
    public ReadOnlyCollection`1<MemberInfo> Members { get; }
    internal NewExpression(ConstructorInfo constructor, IReadOnlyList`1<Expression> arguments, ReadOnlyCollection`1<MemberInfo> members);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Constructor();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public sealed virtual Expression GetArgument(int index);
    public sealed virtual int get_ArgumentCount();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<MemberInfo> get_Members();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewExpression Update(IEnumerable`1<Expression> arguments);
}
internal class System.Linq.Expressions.NewValueTypeExpression : NewExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal NewValueTypeExpression(Type type, ReadOnlyCollection`1<Expression> arguments, ReadOnlyCollection`1<MemberInfo> members);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.OpAssignMethodConversionBinaryExpression : MethodBinaryExpression {
    private LambdaExpression _conversion;
    internal OpAssignMethodConversionBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method, LambdaExpression conversion);
    internal virtual LambdaExpression GetConversion();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/ParameterExpressionProxy")]
public class System.Linq.Expressions.ParameterExpression : Expression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public string Name { get; }
    public bool IsByRef { get; }
    internal ParameterExpression(string name);
    internal static ParameterExpression Make(Type type, string name, bool isByRef);
    public virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public string get_Name();
    public bool get_IsByRef();
    internal virtual bool GetIsByRef();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
internal class System.Linq.Expressions.PrimitiveParameterExpression`1 : ParameterExpression {
    public Type Type { get; }
    internal PrimitiveParameterExpression`1(string name);
    public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.PropertyExpression : MemberExpression {
    private PropertyInfo _property;
    public Type Type { get; }
    public PropertyExpression(Expression expression, PropertyInfo member);
    internal virtual MemberInfo GetMember();
    public sealed virtual Type get_Type();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/RuntimeVariablesExpressionProxy")]
public class System.Linq.Expressions.RuntimeVariablesExpression : Expression {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ParameterExpression> <Variables>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    internal RuntimeVariablesExpression(ReadOnlyCollection`1<ParameterExpression> variables);
    public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public RuntimeVariablesExpression Update(IEnumerable`1<ParameterExpression> variables);
}
internal class System.Linq.Expressions.Scope1 : ScopeExpression {
    private object _body;
    internal int ExpressionCount { get; }
    internal Scope1(IReadOnlyList`1<ParameterExpression> variables, Expression body);
    private Scope1(IReadOnlyList`1<ParameterExpression> variables, object body);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.ScopeExpression : BlockExpression {
    private IReadOnlyList`1<ParameterExpression> _variables;
    protected IReadOnlyList`1<ParameterExpression> VariablesList { get; }
    internal ScopeExpression(IReadOnlyList`1<ParameterExpression> variables);
    internal virtual bool SameVariables(ICollection`1<ParameterExpression> variables);
    internal virtual ReadOnlyCollection`1<ParameterExpression> GetOrMakeVariables();
    protected IReadOnlyList`1<ParameterExpression> get_VariablesList();
    internal IReadOnlyList`1<ParameterExpression> ReuseOrValidateVariables(ReadOnlyCollection`1<ParameterExpression> variables);
}
internal class System.Linq.Expressions.ScopeN : ScopeExpression {
    private IReadOnlyList`1<Expression> _body;
    protected IReadOnlyList`1<Expression> Body { get; }
    internal int ExpressionCount { get; }
    internal ScopeN(IReadOnlyList`1<ParameterExpression> variables, IReadOnlyList`1<Expression> body);
    internal virtual bool SameExpressions(ICollection`1<Expression> expressions);
    protected IReadOnlyList`1<Expression> get_Body();
    internal virtual Expression GetExpression(int index);
    internal virtual int get_ExpressionCount();
    internal virtual ReadOnlyCollection`1<Expression> GetOrMakeExpressions();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.ScopeWithType : ScopeN {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal ScopeWithType(IReadOnlyList`1<ParameterExpression> variables, IReadOnlyList`1<Expression> expressions, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    internal virtual BlockExpression Rewrite(ReadOnlyCollection`1<ParameterExpression> variables, Expression[] args);
}
internal class System.Linq.Expressions.SimpleBinaryExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    internal SimpleBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.SpanDebugInfoExpression : DebugInfoExpression {
    private int _startLine;
    private int _startColumn;
    private int _endLine;
    private int _endColumn;
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public bool IsClear { get; }
    internal SpanDebugInfoExpression(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual int get_StartLine();
    public virtual int get_StartColumn();
    public virtual int get_EndLine();
    public virtual int get_EndColumn();
    public virtual bool get_IsClear();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
internal class System.Linq.Expressions.StackGuard : object {
    private int _executionStackCount;
    public bool TryEnterOnCurrentStack();
    public void RunOnEmptyStack(Action`2<T1, T2> action, T1 arg1, T2 arg2);
    public void RunOnEmptyStack(Action`3<T1, T2, T3> action, T1 arg1, T2 arg2, T3 arg3);
    public R RunOnEmptyStack(Func`3<T1, T2, R> action, T1 arg1, T2 arg2);
    public R RunOnEmptyStack(Func`4<T1, T2, T3, R> action, T1 arg1, T2 arg2, T3 arg3);
    private R RunOnEmptyStackCore(Func`2<object, R> action, object state);
}
internal static class System.Linq.Expressions.Strings : object {
    internal static string ReducibleMustOverrideReduce { get; }
    internal static string MustReduceToDifferent { get; }
    internal static string ReducedNotCompatible { get; }
    internal static string SetterHasNoParams { get; }
    internal static string PropertyCannotHaveRefType { get; }
    internal static string IndexesOfSetGetMustMatch { get; }
    internal static string AccessorsCannotHaveVarArgs { get; }
    internal static string AccessorsCannotHaveByRefArgs { get; }
    internal static string BoundsCannotBeLessThanOne { get; }
    internal static string TypeMustNotBeByRef { get; }
    internal static string TypeMustNotBePointer { get; }
    internal static string SetterMustBeVoid { get; }
    internal static string PropertyTypeMustMatchGetter { get; }
    internal static string PropertyTypeMustMatchSetter { get; }
    internal static string BothAccessorsMustBeStatic { get; }
    internal static string OnlyStaticFieldsHaveNullInstance { get; }
    internal static string OnlyStaticPropertiesHaveNullInstance { get; }
    internal static string OnlyStaticMethodsHaveNullInstance { get; }
    internal static string PropertyTypeCannotBeVoid { get; }
    internal static string InvalidUnboxType { get; }
    internal static string ExpressionMustBeWriteable { get; }
    internal static string ArgumentMustNotHaveValueType { get; }
    internal static string MustBeReducible { get; }
    internal static string AllTestValuesMustHaveSameType { get; }
    internal static string AllCaseBodiesMustHaveSameType { get; }
    internal static string DefaultBodyMustBeSupplied { get; }
    internal static string LabelMustBeVoidOrHaveExpression { get; }
    internal static string LabelTypeMustBeVoid { get; }
    internal static string QuotedExpressionMustBeLambda { get; }
    internal static string CollectionModifiedWhileEnumerating { get; }
    internal static string CollectionReadOnly { get; }
    internal static string ArgCntMustBeGreaterThanNameCnt { get; }
    internal static string BindingCannotBeNull { get; }
    internal static string ArgumentTypeCannotBeVoid { get; }
    internal static string NoOrInvalidRuleProduced { get; }
    internal static string TypeMustBeDerivedFromSystemDelegate { get; }
    internal static string FirstArgumentMustBeCallSite { get; }
    internal static string StartEndMustBeOrdered { get; }
    internal static string FaultCannotHaveCatchOrFinally { get; }
    internal static string TryMustHaveCatchFinallyOrFault { get; }
    internal static string BodyOfCatchMustHaveSameTypeAsBodyOfTry { get; }
    internal static string ConversionIsNotSupportedForArithmeticTypes { get; }
    internal static string ArgumentMustBeArray { get; }
    internal static string ArgumentMustBeBoolean { get; }
    internal static string ArgumentMustBeFieldInfoOrPropertyInfo { get; }
    internal static string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod { get; }
    internal static string ArgumentMustBeInstanceMember { get; }
    internal static string ArgumentMustBeInteger { get; }
    internal static string ArgumentMustBeArrayIndexType { get; }
    internal static string ArgumentMustBeSingleDimensionalArrayType { get; }
    internal static string ArgumentTypesMustMatch { get; }
    internal static string CoalesceUsedOnNonNullType { get; }
    internal static string IncorrectNumberOfIndexes { get; }
    internal static string IncorrectNumberOfLambdaDeclarationParameters { get; }
    internal static string IncorrectNumberOfMembersForGivenConstructor { get; }
    internal static string IncorrectNumberOfArgumentsForMembers { get; }
    internal static string LambdaTypeMustBeDerivedFromSystemDelegate { get; }
    internal static string ElementInitializerMethodNotAdd { get; }
    internal static string ElementInitializerMethodWithZeroArgs { get; }
    internal static string ElementInitializerMethodStatic { get; }
    internal static string UnhandledBinding { get; }
    internal static string UnknownBindingType { get; }
    internal static string IncorrectNumberOfTypeArgsForFunc { get; }
    internal static string IncorrectNumberOfTypeArgsForAction { get; }
    internal static string ArgumentCannotBeOfTypeVoid { get; }
    internal static string ControlCannotLeaveFinally { get; }
    internal static string ControlCannotLeaveFilterTest { get; }
    internal static string ControlCannotEnterTry { get; }
    internal static string ControlCannotEnterExpression { get; }
    internal static string RethrowRequiresCatch { get; }
    internal static string TryNotAllowedInFilter { get; }
    internal static string NonStaticConstructorRequired { get; }
    internal static string NonAbstractConstructorRequired { get; }
    internal static string ExpressionMustBeReadable { get; }
    internal static string EnumerationIsDone { get; }
    internal static string InvalidArgumentValue { get; }
    internal static string NonEmptyCollectionRequired { get; }
    internal static string IncorrectNumberOfLambdaArguments { get; }
    internal static string IncorrectNumberOfConstructorArguments { get; }
    internal static string get_ReducibleMustOverrideReduce();
    internal static string get_MustReduceToDifferent();
    internal static string get_ReducedNotCompatible();
    internal static string get_SetterHasNoParams();
    internal static string get_PropertyCannotHaveRefType();
    internal static string get_IndexesOfSetGetMustMatch();
    internal static string get_AccessorsCannotHaveVarArgs();
    internal static string get_AccessorsCannotHaveByRefArgs();
    internal static string get_BoundsCannotBeLessThanOne();
    internal static string get_TypeMustNotBeByRef();
    internal static string get_TypeMustNotBePointer();
    internal static string get_SetterMustBeVoid();
    internal static string get_PropertyTypeMustMatchGetter();
    internal static string get_PropertyTypeMustMatchSetter();
    internal static string get_BothAccessorsMustBeStatic();
    internal static string get_OnlyStaticFieldsHaveNullInstance();
    internal static string get_OnlyStaticPropertiesHaveNullInstance();
    internal static string get_OnlyStaticMethodsHaveNullInstance();
    internal static string get_PropertyTypeCannotBeVoid();
    internal static string get_InvalidUnboxType();
    internal static string get_ExpressionMustBeWriteable();
    internal static string get_ArgumentMustNotHaveValueType();
    internal static string get_MustBeReducible();
    internal static string get_AllTestValuesMustHaveSameType();
    internal static string get_AllCaseBodiesMustHaveSameType();
    internal static string get_DefaultBodyMustBeSupplied();
    internal static string get_LabelMustBeVoidOrHaveExpression();
    internal static string get_LabelTypeMustBeVoid();
    internal static string get_QuotedExpressionMustBeLambda();
    internal static string get_CollectionModifiedWhileEnumerating();
    internal static string VariableMustNotBeByRef(object p0, object p1);
    internal static string get_CollectionReadOnly();
    internal static string AmbiguousMatchInExpandoObject(object p0);
    internal static string SameKeyExistsInExpando(object p0);
    internal static string KeyDoesNotExistInExpando(object p0);
    internal static string get_ArgCntMustBeGreaterThanNameCnt();
    internal static string InvalidMetaObjectCreated(object p0);
    internal static string BinderNotCompatibleWithCallSite(object p0, object p1, object p2);
    internal static string DynamicBindingNeedsRestrictions(object p0, object p1);
    internal static string DynamicObjectResultNotAssignable(object p0, object p1, object p2, object p3);
    internal static string DynamicBinderResultNotAssignable(object p0, object p1, object p2);
    internal static string get_BindingCannotBeNull();
    internal static string DuplicateVariable(object p0);
    internal static string get_ArgumentTypeCannotBeVoid();
    internal static string TypeParameterIsNotDelegate(object p0);
    internal static string get_NoOrInvalidRuleProduced();
    internal static string get_TypeMustBeDerivedFromSystemDelegate();
    internal static string get_FirstArgumentMustBeCallSite();
    internal static string get_StartEndMustBeOrdered();
    internal static string get_FaultCannotHaveCatchOrFinally();
    internal static string get_TryMustHaveCatchFinallyOrFault();
    internal static string get_BodyOfCatchMustHaveSameTypeAsBodyOfTry();
    internal static string ExtensionNodeMustOverrideProperty(object p0);
    internal static string UserDefinedOperatorMustBeStatic(object p0);
    internal static string UserDefinedOperatorMustNotBeVoid(object p0);
    internal static string CoercionOperatorNotDefined(object p0, object p1);
    internal static string UnaryOperatorNotDefined(object p0, object p1);
    internal static string BinaryOperatorNotDefined(object p0, object p1, object p2);
    internal static string ReferenceEqualityNotDefined(object p0, object p1);
    internal static string OperandTypesDoNotMatchParameters(object p0, object p1);
    internal static string OverloadOperatorTypeDoesNotMatchConversionType(object p0, object p1);
    internal static string get_ConversionIsNotSupportedForArithmeticTypes();
    internal static string get_ArgumentMustBeArray();
    internal static string get_ArgumentMustBeBoolean();
    internal static string EqualityMustReturnBoolean(object p0);
    internal static string get_ArgumentMustBeFieldInfoOrPropertyInfo();
    internal static string get_ArgumentMustBeFieldInfoOrPropertyInfoOrMethod();
    internal static string get_ArgumentMustBeInstanceMember();
    internal static string get_ArgumentMustBeInteger();
    internal static string get_ArgumentMustBeArrayIndexType();
    internal static string get_ArgumentMustBeSingleDimensionalArrayType();
    internal static string get_ArgumentTypesMustMatch();
    internal static string CannotAutoInitializeValueTypeElementThroughProperty(object p0);
    internal static string CannotAutoInitializeValueTypeMemberThroughProperty(object p0);
    internal static string IncorrectTypeForTypeAs(object p0);
    internal static string get_CoalesceUsedOnNonNullType();
    internal static string ExpressionTypeCannotInitializeArrayType(object p0, object p1);
    internal static string ArgumentTypeDoesNotMatchMember(object p0, object p1);
    internal static string ArgumentMemberNotDeclOnType(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchReturn(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchAssignment(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchLabel(object p0, object p1);
    internal static string ExpressionTypeNotInvocable(object p0);
    internal static string FieldNotDefinedForType(object p0, object p1);
    internal static string InstanceFieldNotDefinedForType(object p0, object p1);
    internal static string FieldInfoNotDefinedForType(object p0, object p1, object p2);
    internal static string get_IncorrectNumberOfIndexes();
    internal static string get_IncorrectNumberOfLambdaDeclarationParameters();
    internal static string get_IncorrectNumberOfMembersForGivenConstructor();
    internal static string get_IncorrectNumberOfArgumentsForMembers();
    internal static string get_LambdaTypeMustBeDerivedFromSystemDelegate();
    internal static string MemberNotFieldOrProperty(object p0);
    internal static string MethodContainsGenericParameters(object p0);
    internal static string MethodIsGeneric(object p0);
    internal static string MethodNotPropertyAccessor(object p0, object p1);
    internal static string PropertyDoesNotHaveGetter(object p0);
    internal static string PropertyDoesNotHaveSetter(object p0);
    internal static string PropertyDoesNotHaveAccessor(object p0);
    internal static string NotAMemberOfType(object p0, object p1);
    internal static string NotAMemberOfAnyType(object p0);
    internal static string ParameterExpressionNotValidAsDelegate(object p0, object p1);
    internal static string PropertyNotDefinedForType(object p0, object p1);
    internal static string InstancePropertyNotDefinedForType(object p0, object p1);
    internal static string InstancePropertyWithoutParameterNotDefinedForType(object p0, object p1);
    internal static string InstancePropertyWithSpecifiedParametersNotDefinedForType(object p0, object p1, object p2);
    internal static string InstanceAndMethodTypeMismatch(object p0, object p1, object p2);
    internal static string TypeMissingDefaultConstructor(object p0);
    internal static string get_ElementInitializerMethodNotAdd();
    internal static string ElementInitializerMethodNoRefOutParam(object p0, object p1);
    internal static string get_ElementInitializerMethodWithZeroArgs();
    internal static string get_ElementInitializerMethodStatic();
    internal static string TypeNotIEnumerable(object p0);
    internal static string UnhandledBinary(object p0);
    internal static string get_UnhandledBinding();
    internal static string UnhandledBindingType(object p0);
    internal static string UnhandledUnary(object p0);
    internal static string get_UnknownBindingType();
    internal static string UserDefinedOpMustHaveConsistentTypes(object p0, object p1);
    internal static string UserDefinedOpMustHaveValidReturnType(object p0, object p1);
    internal static string LogicalOperatorMustHaveBooleanOperators(object p0, object p1);
    internal static string MethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static string GenericMethodWithArgsDoesNotExistOnType(object p0, object p1);
    internal static string MethodWithMoreThanOneMatch(object p0, object p1);
    internal static string PropertyWithMoreThanOneMatch(object p0, object p1);
    internal static string get_IncorrectNumberOfTypeArgsForFunc();
    internal static string get_IncorrectNumberOfTypeArgsForAction();
    internal static string get_ArgumentCannotBeOfTypeVoid();
    internal static string OutOfRange(object p0, object p1);
    internal static string LabelTargetAlreadyDefined(object p0);
    internal static string LabelTargetUndefined(object p0);
    internal static string get_ControlCannotLeaveFinally();
    internal static string get_ControlCannotLeaveFilterTest();
    internal static string AmbiguousJump(object p0);
    internal static string get_ControlCannotEnterTry();
    internal static string get_ControlCannotEnterExpression();
    internal static string NonLocalJumpWithValue(object p0);
    internal static string InvalidLvalue(object p0);
    internal static string UndefinedVariable(object p0, object p1, object p2);
    internal static string CannotCloseOverByRef(object p0, object p1);
    internal static string UnexpectedVarArgsCall(object p0);
    internal static string get_RethrowRequiresCatch();
    internal static string get_TryNotAllowedInFilter();
    internal static string MustRewriteToSameNode(object p0, object p1, object p2);
    internal static string MustRewriteChildToSameType(object p0, object p1, object p2);
    internal static string MustRewriteWithoutMethod(object p0, object p1);
    internal static string TryNotSupportedForMethodsWithRefArgs(object p0);
    internal static string TryNotSupportedForValueTypeInstances(object p0);
    internal static string TestValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static string SwitchValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1);
    internal static string get_NonStaticConstructorRequired();
    internal static string get_NonAbstractConstructorRequired();
    internal static string get_ExpressionMustBeReadable();
    internal static string ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1);
    internal static string get_EnumerationIsDone();
    internal static string TypeContainsGenericParameters(object p0);
    internal static string TypeIsGeneric(object p0);
    internal static string get_InvalidArgumentValue();
    internal static string get_NonEmptyCollectionRequired();
    internal static string InvalidNullValue(object p0);
    internal static string InvalidObjectType(object p0, object p1);
    internal static string ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2);
    internal static string ExpressionTypeDoesNotMatchParameter(object p0, object p1);
    internal static string IncorrectNumberOfMethodCallArguments(object p0);
    internal static string get_IncorrectNumberOfLambdaArguments();
    internal static string get_IncorrectNumberOfConstructorArguments();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/SwitchCaseProxy")]
public class System.Linq.Expressions.SwitchCase : object {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Expression> <TestValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    public ReadOnlyCollection`1<Expression> TestValues { get; }
    public Expression Body { get; }
    internal SwitchCase(Expression body, ReadOnlyCollection`1<Expression> testValues);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Expression> get_TestValues();
    [CompilerGeneratedAttribute]
public Expression get_Body();
    public virtual string ToString();
    public SwitchCase Update(IEnumerable`1<Expression> testValues, Expression body);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/SwitchExpressionProxy")]
public class System.Linq.Expressions.SwitchExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <SwitchValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<SwitchCase> <Cases>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <DefaultBody>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Comparison>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression SwitchValue { get; }
    public ReadOnlyCollection`1<SwitchCase> Cases { get; }
    public Expression DefaultBody { get; }
    public MethodInfo Comparison { get; }
    internal bool IsLifted { get; }
    internal SwitchExpression(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, ReadOnlyCollection`1<SwitchCase> cases);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_SwitchValue();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<SwitchCase> get_Cases();
    [CompilerGeneratedAttribute]
public Expression get_DefaultBody();
    [CompilerGeneratedAttribute]
public MethodInfo get_Comparison();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    internal bool get_IsLifted();
    public SwitchExpression Update(Expression switchValue, IEnumerable`1<SwitchCase> cases, Expression defaultBody);
}
public class System.Linq.Expressions.SymbolDocumentInfo : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    internal static Guid DocumentType_Text;
    public string FileName { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid DocumentType { get; }
    internal SymbolDocumentInfo(string fileName);
    private static SymbolDocumentInfo();
    [CompilerGeneratedAttribute]
public string get_FileName();
    public virtual Guid get_Language();
    public virtual Guid get_LanguageVendor();
    public virtual Guid get_DocumentType();
}
internal class System.Linq.Expressions.SymbolDocumentWithGuids : SymbolDocumentInfo {
    [CompilerGeneratedAttribute]
private Guid <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <LanguageVendor>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <DocumentType>k__BackingField;
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid DocumentType { get; }
    internal SymbolDocumentWithGuids(string fileName, Guid& language);
    internal SymbolDocumentWithGuids(string fileName, Guid& language, Guid& vendor);
    internal SymbolDocumentWithGuids(string fileName, Guid& language, Guid& vendor, Guid& documentType);
    [CompilerGeneratedAttribute]
public virtual Guid get_Language();
    [CompilerGeneratedAttribute]
public virtual Guid get_LanguageVendor();
    [CompilerGeneratedAttribute]
public virtual Guid get_DocumentType();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/TryExpressionProxy")]
public class System.Linq.Expressions.TryExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<CatchBlock> <Handlers>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Finally>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Fault>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Body { get; }
    public ReadOnlyCollection`1<CatchBlock> Handlers { get; }
    public Expression Finally { get; }
    public Expression Fault { get; }
    internal TryExpression(Type type, Expression body, Expression finally, Expression fault, ReadOnlyCollection`1<CatchBlock> handlers);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Body();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<CatchBlock> get_Handlers();
    [CompilerGeneratedAttribute]
public Expression get_Finally();
    [CompilerGeneratedAttribute]
public Expression get_Fault();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TryExpression Update(Expression body, IEnumerable`1<CatchBlock> handlers, Expression finally, Expression fault);
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/TypeBinaryExpressionProxy")]
public class System.Linq.Expressions.TypeBinaryExpression : Expression {
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeOperand>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Expression { get; }
    public Type TypeOperand { get; }
    internal TypeBinaryExpression(Expression expression, Type typeOperand, ExpressionType nodeType);
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public Type get_TypeOperand();
    internal Expression ReduceTypeEqual();
    private Expression ByValParameterTypeEqual(ParameterExpression value);
    private Expression ReduceConstantTypeEqual();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TypeBinaryExpression Update(Expression expression);
}
internal class System.Linq.Expressions.TypedConstantExpression : ConstantExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedConstantExpression(object value, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression1 : DynamicExpression1 {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedDynamicExpression1(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression2 : DynamicExpression2 {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedDynamicExpression2(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression3 : DynamicExpression3 {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedDynamicExpression3(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpression4 : DynamicExpression4 {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedDynamicExpression4(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedDynamicExpressionN : DynamicExpressionN {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedDynamicExpressionN(Type returnType, Type delegateType, CallSiteBinder binder, IReadOnlyList`1<Expression> arguments);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
internal class System.Linq.Expressions.TypedParameterExpression : ParameterExpression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    internal TypedParameterExpression(Type type, string name);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
}
[DebuggerTypeProxyAttribute("System.Linq.Expressions.Expression/UnaryExpressionProxy")]
public class System.Linq.Expressions.UnaryExpression : Expression {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Operand>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public Expression Operand { get; }
    public MethodInfo Method { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    public bool CanReduce { get; }
    private bool IsPrefix { get; }
    internal UnaryExpression(ExpressionType nodeType, Expression expression, Type type, MethodInfo method);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ExpressionType get_NodeType();
    [CompilerGeneratedAttribute]
public Expression get_Operand();
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual bool get_CanReduce();
    public virtual Expression Reduce();
    private bool get_IsPrefix();
    private UnaryExpression FunctionalOp(Expression operand);
    private Expression ReduceVariable();
    private Expression ReduceMember();
    private Expression ReduceIndex();
    public UnaryExpression Update(Expression operand);
}
internal static class System.Linq.Expressions.Utils : object {
    public static object BoxedFalse;
    public static object BoxedTrue;
    public static object BoxedIntM1;
    public static object BoxedInt0;
    public static object BoxedInt1;
    public static object BoxedInt2;
    public static object BoxedInt3;
    public static object BoxedDefaultSByte;
    public static object BoxedDefaultChar;
    public static object BoxedDefaultInt16;
    public static object BoxedDefaultInt64;
    public static object BoxedDefaultByte;
    public static object BoxedDefaultUInt16;
    public static object BoxedDefaultUInt32;
    public static object BoxedDefaultUInt64;
    public static object BoxedDefaultSingle;
    public static object BoxedDefaultDouble;
    public static object BoxedDefaultDecimal;
    public static object BoxedDefaultDateTime;
    private static ConstantExpression s_true;
    private static ConstantExpression s_false;
    private static ConstantExpression s_m1;
    private static ConstantExpression s_0;
    private static ConstantExpression s_1;
    private static ConstantExpression s_2;
    private static ConstantExpression s_3;
    public static DefaultExpression Empty;
    public static ConstantExpression Null;
    private static Utils();
    public static ConstantExpression Constant(bool value);
    public static ConstantExpression Constant(int value);
}
public interface System.Linq.IOrderedQueryable {
}
public interface System.Linq.IOrderedQueryable`1 {
}
public interface System.Linq.IQueryable {
    public Expression Expression { get; }
    public Type ElementType { get; }
    public IQueryProvider Provider { get; }
    public abstract virtual Expression get_Expression();
    public abstract virtual Type get_ElementType();
    public abstract virtual IQueryProvider get_Provider();
}
public interface System.Linq.IQueryable`1 {
}
public interface System.Linq.IQueryProvider {
    public abstract virtual IQueryable CreateQuery(Expression expression);
    public abstract virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public abstract virtual object Execute(Expression expression);
    public abstract virtual TResult Execute(Expression expression);
}
public class System.Runtime.CompilerServices.CallSite : object {
    private static CacheDict`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_siteCtors;
    internal CallSiteBinder _binder;
    internal bool _match;
    public CallSiteBinder Binder { get; }
    internal CallSite(CallSiteBinder binder);
    public CallSiteBinder get_Binder();
    public static CallSite Create(Type delegateType, CallSiteBinder binder);
}
public class System.Runtime.CompilerServices.CallSite`1 : CallSite {
    public T Target;
    internal T[] Rules;
    internal CallSite _cachedMatchmaker;
    private static T s_cachedUpdate;
    private static T modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedNoMatch;
    public T Update { get; }
    private CallSite`1(CallSiteBinder binder);
    public T get_Update();
    internal CallSite`1<T> CreateMatchMaker();
    internal CallSite GetMatchmaker();
    internal void ReleaseMatchmaker(CallSite matchMaker);
    public static CallSite`1<T> Create(CallSiteBinder binder);
    private T GetUpdateDelegate();
    private T GetUpdateDelegate(T& addr);
    private void ClearRuleCache();
    internal void AddRule(T newRule);
    internal void MoveRule(int i);
    internal T MakeUpdateDelegate();
    private static bool IsSimpleSignature(MethodInfo invoke, Type[]& sig);
    private T CreateCustomUpdateDelegate(MethodInfo invoke);
    private T CreateCustomNoMatchDelegate(MethodInfo invoke);
    private static Expression Convert(Expression arg, Type type);
}
public abstract class System.Runtime.CompilerServices.CallSiteBinder : object {
    internal Dictionary`2<Type, object> Cache;
    [CompilerGeneratedAttribute]
private static LabelTarget <UpdateLabel>k__BackingField;
    public static LabelTarget UpdateLabel { get; }
    private static CallSiteBinder();
    [CompilerGeneratedAttribute]
public static LabelTarget get_UpdateLabel();
    public abstract virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    public virtual T BindDelegate(CallSite`1<T> site, Object[] args);
    internal T BindCore(CallSite`1<T> site, Object[] args);
    protected void CacheTarget(T target);
    private static Expression`1<T> Stitch(Expression binding, LambdaSignature`1<T> signature);
    internal RuleCache`1<T> GetRuleCache();
}
public static class System.Runtime.CompilerServices.CallSiteHelpers : object {
    private static Type s_knownNonDynamicMethodType;
    private static CallSiteHelpers();
    public static bool IsInternalFrame(MethodBase mb);
}
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Runtime.CompilerServices.CallSiteOps : object {
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static CallSite`1<T> CreateMatchmaker(CallSite`1<T> site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool SetNotMatched(CallSite site);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static bool GetMatch(CallSite site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void ClearMatch(CallSite site);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static void AddRule(CallSite`1<T> site, T rule);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void UpdateRules(CallSite`1<T> this, int matched);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static T[] GetRules(CallSite`1<T> site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static RuleCache`1<T> GetRuleCache(CallSite`1<T> site);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void MoveRule(RuleCache`1<T> cache, T rule, int i);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static T[] GetCachedRules(RuleCache`1<T> cache);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static T Bind(CallSiteBinder binder, CallSite`1<T> site, Object[] args);
}
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public class System.Runtime.CompilerServices.Closure : object {
    public Object[] Constants;
    public Object[] Locals;
    public Closure(Object[] constants, Object[] locals);
}
public abstract class System.Runtime.CompilerServices.DebugInfoGenerator : object {
    public static DebugInfoGenerator CreatePdbGenerator();
    public abstract virtual void MarkSequencePoint(LambdaExpression method, int ilOffset, DebugInfoExpression sequencePoint);
}
[AttributeUsageAttribute("10636")]
public class System.Runtime.CompilerServices.DynamicAttribute : Attribute {
    private Boolean[] _transformFlags;
    public IList`1<bool> TransformFlags { get; }
    public DynamicAttribute(Boolean[] transformFlags);
    public IList`1<bool> get_TransformFlags();
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.IRuntimeVariables {
    public int Count { get; }
    public object Item { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
}
[DefaultMemberAttribute("Item")]
public class System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1 : object {
    private T[] _items;
    private int _size;
    private int _version;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ReadOnlyCollectionBuilder`1(int capacity);
    public ReadOnlyCollectionBuilder`1(IEnumerable`1<T> collection);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Reverse();
    public void Reverse(int index, int count);
    public T[] ToArray();
    public ReadOnlyCollection`1<T> ToReadOnlyCollection();
    private void EnsureCapacity(int min);
    private static bool IsCompatibleObject(object value);
    private static void ValidateNullValue(object value, string argument);
}
[EditorBrowsableAttribute("1")]
[DebuggerStepThroughAttribute]
public class System.Runtime.CompilerServices.RuleCache`1 : object {
    private T[] _rules;
    private object _cacheLock;
    internal T[] GetRules();
    internal void MoveRule(T rule, int i);
    internal void AddRule(T newRule);
    internal void ReplaceRule(T oldRule, T newRule);
    private static T[] AddOrInsert(T[] rules, T item);
}
[DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Runtime.CompilerServices.RuntimeOps : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static bool ExpandoTryGetValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase, Object& value);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static object ExpandoTrySetValue(ExpandoObject expando, object indexClass, int index, object value, string name, bool ignoreCase);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool ExpandoTryDeleteValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static bool ExpandoCheckVersion(ExpandoObject expando, object version);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static void ExpandoPromoteClass(ExpandoObject expando, object oldClass, object newClass);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static Expression Quote(Expression expression, object hoistedLocals, Object[] locals);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static IRuntimeVariables MergeRuntimeVariables(IRuntimeVariables first, IRuntimeVariables second, Int32[] indexes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("do not use this method", "True")]
public static IRuntimeVariables CreateRuntimeVariables(Object[] data, Int64[] indexes);
    [ObsoleteAttribute("do not use this method", "True")]
[EditorBrowsableAttribute("1")]
public static IRuntimeVariables CreateRuntimeVariables();
}
internal class System.Runtime.CompilerServices.TrueReadOnlyCollection`1 : ReadOnlyCollection`1<T> {
    public TrueReadOnlyCollection`1(T[] list);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string ReducibleMustOverrideReduce { get; }
    internal static string MustReduceToDifferent { get; }
    internal static string ReducedNotCompatible { get; }
    internal static string SetterHasNoParams { get; }
    internal static string PropertyCannotHaveRefType { get; }
    internal static string IndexesOfSetGetMustMatch { get; }
    internal static string AccessorsCannotHaveVarArgs { get; }
    internal static string AccessorsCannotHaveByRefArgs { get; }
    internal static string BoundsCannotBeLessThanOne { get; }
    internal static string TypeMustNotBeByRef { get; }
    internal static string TypeMustNotBePointer { get; }
    internal static string SetterMustBeVoid { get; }
    internal static string PropertyTypeMustMatchGetter { get; }
    internal static string PropertyTypeMustMatchSetter { get; }
    internal static string BothAccessorsMustBeStatic { get; }
    internal static string OnlyStaticFieldsHaveNullInstance { get; }
    internal static string OnlyStaticPropertiesHaveNullInstance { get; }
    internal static string OnlyStaticMethodsHaveNullInstance { get; }
    internal static string PropertyTypeCannotBeVoid { get; }
    internal static string InvalidUnboxType { get; }
    internal static string ExpressionMustBeWriteable { get; }
    internal static string ArgumentMustNotHaveValueType { get; }
    internal static string MustBeReducible { get; }
    internal static string AllTestValuesMustHaveSameType { get; }
    internal static string AllCaseBodiesMustHaveSameType { get; }
    internal static string DefaultBodyMustBeSupplied { get; }
    internal static string LabelMustBeVoidOrHaveExpression { get; }
    internal static string LabelTypeMustBeVoid { get; }
    internal static string QuotedExpressionMustBeLambda { get; }
    internal static string VariableMustNotBeByRef { get; }
    internal static string DuplicateVariable { get; }
    internal static string StartEndMustBeOrdered { get; }
    internal static string FaultCannotHaveCatchOrFinally { get; }
    internal static string TryMustHaveCatchFinallyOrFault { get; }
    internal static string BodyOfCatchMustHaveSameTypeAsBodyOfTry { get; }
    internal static string ExtensionNodeMustOverrideProperty { get; }
    internal static string UserDefinedOperatorMustBeStatic { get; }
    internal static string UserDefinedOperatorMustNotBeVoid { get; }
    internal static string CoercionOperatorNotDefined { get; }
    internal static string UnaryOperatorNotDefined { get; }
    internal static string BinaryOperatorNotDefined { get; }
    internal static string ReferenceEqualityNotDefined { get; }
    internal static string OperandTypesDoNotMatchParameters { get; }
    internal static string OverloadOperatorTypeDoesNotMatchConversionType { get; }
    internal static string ConversionIsNotSupportedForArithmeticTypes { get; }
    internal static string ArgumentMustBeArray { get; }
    internal static string ArgumentMustBeBoolean { get; }
    internal static string EqualityMustReturnBoolean { get; }
    internal static string ArgumentMustBeFieldInfoOrPropertyInfo { get; }
    internal static string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod { get; }
    internal static string ArgumentMustBeInstanceMember { get; }
    internal static string ArgumentMustBeInteger { get; }
    internal static string ArgumentMustBeArrayIndexType { get; }
    internal static string ArgumentMustBeSingleDimensionalArrayType { get; }
    internal static string ArgumentTypesMustMatch { get; }
    internal static string CannotAutoInitializeValueTypeElementThroughProperty { get; }
    internal static string CannotAutoInitializeValueTypeMemberThroughProperty { get; }
    internal static string IncorrectTypeForTypeAs { get; }
    internal static string CoalesceUsedOnNonNullType { get; }
    internal static string ExpressionTypeCannotInitializeArrayType { get; }
    internal static string ArgumentTypeDoesNotMatchMember { get; }
    internal static string ArgumentMemberNotDeclOnType { get; }
    internal static string ExpressionTypeDoesNotMatchReturn { get; }
    internal static string ExpressionTypeDoesNotMatchAssignment { get; }
    internal static string ExpressionTypeDoesNotMatchLabel { get; }
    internal static string ExpressionTypeNotInvocable { get; }
    internal static string FieldNotDefinedForType { get; }
    internal static string InstanceFieldNotDefinedForType { get; }
    internal static string FieldInfoNotDefinedForType { get; }
    internal static string IncorrectNumberOfIndexes { get; }
    internal static string IncorrectNumberOfLambdaDeclarationParameters { get; }
    internal static string IncorrectNumberOfMembersForGivenConstructor { get; }
    internal static string IncorrectNumberOfArgumentsForMembers { get; }
    internal static string LambdaTypeMustBeDerivedFromSystemDelegate { get; }
    internal static string MemberNotFieldOrProperty { get; }
    internal static string MethodContainsGenericParameters { get; }
    internal static string MethodIsGeneric { get; }
    internal static string MethodNotPropertyAccessor { get; }
    internal static string PropertyDoesNotHaveGetter { get; }
    internal static string PropertyDoesNotHaveSetter { get; }
    internal static string PropertyDoesNotHaveAccessor { get; }
    internal static string NotAMemberOfType { get; }
    internal static string NotAMemberOfAnyType { get; }
    internal static string UnsupportedExpressionType { get; }
    internal static string ParameterExpressionNotValidAsDelegate { get; }
    internal static string PropertyNotDefinedForType { get; }
    internal static string InstancePropertyNotDefinedForType { get; }
    internal static string InstancePropertyWithoutParameterNotDefinedForType { get; }
    internal static string InstancePropertyWithSpecifiedParametersNotDefinedForType { get; }
    internal static string InstanceAndMethodTypeMismatch { get; }
    internal static string TypeContainsGenericParameters { get; }
    internal static string TypeIsGeneric { get; }
    internal static string TypeMissingDefaultConstructor { get; }
    internal static string ElementInitializerMethodNotAdd { get; }
    internal static string ElementInitializerMethodNoRefOutParam { get; }
    internal static string ElementInitializerMethodWithZeroArgs { get; }
    internal static string ElementInitializerMethodStatic { get; }
    internal static string TypeNotIEnumerable { get; }
    internal static string UnhandledBinary { get; }
    internal static string UnhandledBinding { get; }
    internal static string UnhandledBindingType { get; }
    internal static string UnhandledUnary { get; }
    internal static string UnknownBindingType { get; }
    internal static string UserDefinedOpMustHaveConsistentTypes { get; }
    internal static string UserDefinedOpMustHaveValidReturnType { get; }
    internal static string LogicalOperatorMustHaveBooleanOperators { get; }
    internal static string MethodWithArgsDoesNotExistOnType { get; }
    internal static string GenericMethodWithArgsDoesNotExistOnType { get; }
    internal static string MethodWithMoreThanOneMatch { get; }
    internal static string PropertyWithMoreThanOneMatch { get; }
    internal static string IncorrectNumberOfTypeArgsForFunc { get; }
    internal static string IncorrectNumberOfTypeArgsForAction { get; }
    internal static string ArgumentCannotBeOfTypeVoid { get; }
    internal static string OutOfRange { get; }
    internal static string LabelTargetAlreadyDefined { get; }
    internal static string LabelTargetUndefined { get; }
    internal static string ControlCannotLeaveFinally { get; }
    internal static string ControlCannotLeaveFilterTest { get; }
    internal static string AmbiguousJump { get; }
    internal static string ControlCannotEnterTry { get; }
    internal static string ControlCannotEnterExpression { get; }
    internal static string NonLocalJumpWithValue { get; }
    internal static string InvalidLvalue { get; }
    internal static string UndefinedVariable { get; }
    internal static string CannotCloseOverByRef { get; }
    internal static string UnexpectedVarArgsCall { get; }
    internal static string RethrowRequiresCatch { get; }
    internal static string TryNotAllowedInFilter { get; }
    internal static string MustRewriteToSameNode { get; }
    internal static string MustRewriteChildToSameType { get; }
    internal static string MustRewriteWithoutMethod { get; }
    internal static string InvalidNullValue { get; }
    internal static string InvalidObjectType { get; }
    internal static string TryNotSupportedForMethodsWithRefArgs { get; }
    internal static string TryNotSupportedForValueTypeInstances { get; }
    internal static string EnumerationIsDone { get; }
    internal static string TestValueTypeDoesNotMatchComparisonMethodParameter { get; }
    internal static string SwitchValueTypeDoesNotMatchComparisonMethodParameter { get; }
    internal static string InvalidArgumentValue { get; }
    internal static string NonEmptyCollectionRequired { get; }
    internal static string CollectionModifiedWhileEnumerating { get; }
    internal static string ExpressionMustBeReadable { get; }
    internal static string ExpressionTypeDoesNotMatchMethodParameter { get; }
    internal static string ExpressionTypeDoesNotMatchParameter { get; }
    internal static string ExpressionTypeDoesNotMatchConstructorParameter { get; }
    internal static string IncorrectNumberOfMethodCallArguments { get; }
    internal static string IncorrectNumberOfLambdaArguments { get; }
    internal static string IncorrectNumberOfConstructorArguments { get; }
    internal static string NonStaticConstructorRequired { get; }
    internal static string NonAbstractConstructorRequired { get; }
    internal static string FirstArgumentMustBeCallSite { get; }
    internal static string NoOrInvalidRuleProduced { get; }
    internal static string TypeMustBeDerivedFromSystemDelegate { get; }
    internal static string TypeParameterIsNotDelegate { get; }
    internal static string ArgumentTypeCannotBeVoid { get; }
    internal static string ArgCntMustBeGreaterThanNameCnt { get; }
    internal static string BinderNotCompatibleWithCallSite { get; }
    internal static string BindingCannotBeNull { get; }
    internal static string DynamicBinderResultNotAssignable { get; }
    internal static string DynamicBindingNeedsRestrictions { get; }
    internal static string DynamicObjectResultNotAssignable { get; }
    internal static string InvalidMetaObjectCreated { get; }
    internal static string AmbiguousMatchInExpandoObject { get; }
    internal static string CollectionReadOnly { get; }
    internal static string KeyDoesNotExistInExpando { get; }
    internal static string SameKeyExistsInExpando { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_ReducibleMustOverrideReduce();
    internal static string get_MustReduceToDifferent();
    internal static string get_ReducedNotCompatible();
    internal static string get_SetterHasNoParams();
    internal static string get_PropertyCannotHaveRefType();
    internal static string get_IndexesOfSetGetMustMatch();
    internal static string get_AccessorsCannotHaveVarArgs();
    internal static string get_AccessorsCannotHaveByRefArgs();
    internal static string get_BoundsCannotBeLessThanOne();
    internal static string get_TypeMustNotBeByRef();
    internal static string get_TypeMustNotBePointer();
    internal static string get_SetterMustBeVoid();
    internal static string get_PropertyTypeMustMatchGetter();
    internal static string get_PropertyTypeMustMatchSetter();
    internal static string get_BothAccessorsMustBeStatic();
    internal static string get_OnlyStaticFieldsHaveNullInstance();
    internal static string get_OnlyStaticPropertiesHaveNullInstance();
    internal static string get_OnlyStaticMethodsHaveNullInstance();
    internal static string get_PropertyTypeCannotBeVoid();
    internal static string get_InvalidUnboxType();
    internal static string get_ExpressionMustBeWriteable();
    internal static string get_ArgumentMustNotHaveValueType();
    internal static string get_MustBeReducible();
    internal static string get_AllTestValuesMustHaveSameType();
    internal static string get_AllCaseBodiesMustHaveSameType();
    internal static string get_DefaultBodyMustBeSupplied();
    internal static string get_LabelMustBeVoidOrHaveExpression();
    internal static string get_LabelTypeMustBeVoid();
    internal static string get_QuotedExpressionMustBeLambda();
    internal static string get_VariableMustNotBeByRef();
    internal static string get_DuplicateVariable();
    internal static string get_StartEndMustBeOrdered();
    internal static string get_FaultCannotHaveCatchOrFinally();
    internal static string get_TryMustHaveCatchFinallyOrFault();
    internal static string get_BodyOfCatchMustHaveSameTypeAsBodyOfTry();
    internal static string get_ExtensionNodeMustOverrideProperty();
    internal static string get_UserDefinedOperatorMustBeStatic();
    internal static string get_UserDefinedOperatorMustNotBeVoid();
    internal static string get_CoercionOperatorNotDefined();
    internal static string get_UnaryOperatorNotDefined();
    internal static string get_BinaryOperatorNotDefined();
    internal static string get_ReferenceEqualityNotDefined();
    internal static string get_OperandTypesDoNotMatchParameters();
    internal static string get_OverloadOperatorTypeDoesNotMatchConversionType();
    internal static string get_ConversionIsNotSupportedForArithmeticTypes();
    internal static string get_ArgumentMustBeArray();
    internal static string get_ArgumentMustBeBoolean();
    internal static string get_EqualityMustReturnBoolean();
    internal static string get_ArgumentMustBeFieldInfoOrPropertyInfo();
    internal static string get_ArgumentMustBeFieldInfoOrPropertyInfoOrMethod();
    internal static string get_ArgumentMustBeInstanceMember();
    internal static string get_ArgumentMustBeInteger();
    internal static string get_ArgumentMustBeArrayIndexType();
    internal static string get_ArgumentMustBeSingleDimensionalArrayType();
    internal static string get_ArgumentTypesMustMatch();
    internal static string get_CannotAutoInitializeValueTypeElementThroughProperty();
    internal static string get_CannotAutoInitializeValueTypeMemberThroughProperty();
    internal static string get_IncorrectTypeForTypeAs();
    internal static string get_CoalesceUsedOnNonNullType();
    internal static string get_ExpressionTypeCannotInitializeArrayType();
    internal static string get_ArgumentTypeDoesNotMatchMember();
    internal static string get_ArgumentMemberNotDeclOnType();
    internal static string get_ExpressionTypeDoesNotMatchReturn();
    internal static string get_ExpressionTypeDoesNotMatchAssignment();
    internal static string get_ExpressionTypeDoesNotMatchLabel();
    internal static string get_ExpressionTypeNotInvocable();
    internal static string get_FieldNotDefinedForType();
    internal static string get_InstanceFieldNotDefinedForType();
    internal static string get_FieldInfoNotDefinedForType();
    internal static string get_IncorrectNumberOfIndexes();
    internal static string get_IncorrectNumberOfLambdaDeclarationParameters();
    internal static string get_IncorrectNumberOfMembersForGivenConstructor();
    internal static string get_IncorrectNumberOfArgumentsForMembers();
    internal static string get_LambdaTypeMustBeDerivedFromSystemDelegate();
    internal static string get_MemberNotFieldOrProperty();
    internal static string get_MethodContainsGenericParameters();
    internal static string get_MethodIsGeneric();
    internal static string get_MethodNotPropertyAccessor();
    internal static string get_PropertyDoesNotHaveGetter();
    internal static string get_PropertyDoesNotHaveSetter();
    internal static string get_PropertyDoesNotHaveAccessor();
    internal static string get_NotAMemberOfType();
    internal static string get_NotAMemberOfAnyType();
    internal static string get_UnsupportedExpressionType();
    internal static string get_ParameterExpressionNotValidAsDelegate();
    internal static string get_PropertyNotDefinedForType();
    internal static string get_InstancePropertyNotDefinedForType();
    internal static string get_InstancePropertyWithoutParameterNotDefinedForType();
    internal static string get_InstancePropertyWithSpecifiedParametersNotDefinedForType();
    internal static string get_InstanceAndMethodTypeMismatch();
    internal static string get_TypeContainsGenericParameters();
    internal static string get_TypeIsGeneric();
    internal static string get_TypeMissingDefaultConstructor();
    internal static string get_ElementInitializerMethodNotAdd();
    internal static string get_ElementInitializerMethodNoRefOutParam();
    internal static string get_ElementInitializerMethodWithZeroArgs();
    internal static string get_ElementInitializerMethodStatic();
    internal static string get_TypeNotIEnumerable();
    internal static string get_UnhandledBinary();
    internal static string get_UnhandledBinding();
    internal static string get_UnhandledBindingType();
    internal static string get_UnhandledUnary();
    internal static string get_UnknownBindingType();
    internal static string get_UserDefinedOpMustHaveConsistentTypes();
    internal static string get_UserDefinedOpMustHaveValidReturnType();
    internal static string get_LogicalOperatorMustHaveBooleanOperators();
    internal static string get_MethodWithArgsDoesNotExistOnType();
    internal static string get_GenericMethodWithArgsDoesNotExistOnType();
    internal static string get_MethodWithMoreThanOneMatch();
    internal static string get_PropertyWithMoreThanOneMatch();
    internal static string get_IncorrectNumberOfTypeArgsForFunc();
    internal static string get_IncorrectNumberOfTypeArgsForAction();
    internal static string get_ArgumentCannotBeOfTypeVoid();
    internal static string get_OutOfRange();
    internal static string get_LabelTargetAlreadyDefined();
    internal static string get_LabelTargetUndefined();
    internal static string get_ControlCannotLeaveFinally();
    internal static string get_ControlCannotLeaveFilterTest();
    internal static string get_AmbiguousJump();
    internal static string get_ControlCannotEnterTry();
    internal static string get_ControlCannotEnterExpression();
    internal static string get_NonLocalJumpWithValue();
    internal static string get_InvalidLvalue();
    internal static string get_UndefinedVariable();
    internal static string get_CannotCloseOverByRef();
    internal static string get_UnexpectedVarArgsCall();
    internal static string get_RethrowRequiresCatch();
    internal static string get_TryNotAllowedInFilter();
    internal static string get_MustRewriteToSameNode();
    internal static string get_MustRewriteChildToSameType();
    internal static string get_MustRewriteWithoutMethod();
    internal static string get_InvalidNullValue();
    internal static string get_InvalidObjectType();
    internal static string get_TryNotSupportedForMethodsWithRefArgs();
    internal static string get_TryNotSupportedForValueTypeInstances();
    internal static string get_EnumerationIsDone();
    internal static string get_TestValueTypeDoesNotMatchComparisonMethodParameter();
    internal static string get_SwitchValueTypeDoesNotMatchComparisonMethodParameter();
    internal static string get_InvalidArgumentValue();
    internal static string get_NonEmptyCollectionRequired();
    internal static string get_CollectionModifiedWhileEnumerating();
    internal static string get_ExpressionMustBeReadable();
    internal static string get_ExpressionTypeDoesNotMatchMethodParameter();
    internal static string get_ExpressionTypeDoesNotMatchParameter();
    internal static string get_ExpressionTypeDoesNotMatchConstructorParameter();
    internal static string get_IncorrectNumberOfMethodCallArguments();
    internal static string get_IncorrectNumberOfLambdaArguments();
    internal static string get_IncorrectNumberOfConstructorArguments();
    internal static string get_NonStaticConstructorRequired();
    internal static string get_NonAbstractConstructorRequired();
    internal static string get_FirstArgumentMustBeCallSite();
    internal static string get_NoOrInvalidRuleProduced();
    internal static string get_TypeMustBeDerivedFromSystemDelegate();
    internal static string get_TypeParameterIsNotDelegate();
    internal static string get_ArgumentTypeCannotBeVoid();
    internal static string get_ArgCntMustBeGreaterThanNameCnt();
    internal static string get_BinderNotCompatibleWithCallSite();
    internal static string get_BindingCannotBeNull();
    internal static string get_DynamicBinderResultNotAssignable();
    internal static string get_DynamicBindingNeedsRestrictions();
    internal static string get_DynamicObjectResultNotAssignable();
    internal static string get_InvalidMetaObjectCreated();
    internal static string get_AmbiguousMatchInExpandoObject();
    internal static string get_CollectionReadOnly();
    internal static string get_KeyDoesNotExistInExpando();
    internal static string get_SameKeyExistsInExpando();
    internal static string get_Arg_KeyNotFoundWithKey();
}
