internal static class FxResources.System.Net.Security.SR : object {
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeCFArrayHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeCFDataHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeCFDataHandle(IntPtr handle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeCFDateHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeCFStringHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeCreateHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeGssContextHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeGssCredHandle : SafeHandle {
    public bool IsInvalid { get; }
    public static SafeGssCredHandle Create(string username, string password, bool isNtlmOnly);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeGssNameHandle : SafeHandle {
    public bool IsInvalid { get; }
    public static SafeGssNameHandle CreateUser(string name);
    public static SafeGssNameHandle CreatePrincipal(string name);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Net.AsyncProtocolCallback : MulticastDelegate {
    public AsyncProtocolCallback(object object, IntPtr method);
    public virtual void Invoke(AsyncProtocolRequest asyncRequest);
    public virtual IAsyncResult BeginInvoke(AsyncProtocolRequest asyncRequest, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Net.AsyncProtocolRequest : object {
    private AsyncProtocolCallback _callback;
    private int _completionStatus;
    public LazyAsyncResult UserAsyncResult;
    public int Result;
    public object AsyncState;
    public Byte[] Buffer;
    public int Offset;
    public int Count;
    internal object AsyncObject { get; }
    public bool MustCompleteSynchronously { get; }
    internal bool IsUserCompleted { get; }
    public AsyncProtocolRequest(LazyAsyncResult userAsyncResult);
    public void SetNextRequest(Byte[] buffer, int offset, int count, AsyncProtocolCallback callback);
    internal object get_AsyncObject();
    internal void CompleteRequest(int result);
    public bool get_MustCompleteSynchronously();
    internal void CompleteUserWithError(Exception e);
    internal void CompleteUser();
    internal void CompleteUser(int userResult);
    internal bool get_IsUserCompleted();
}
internal class System.Net.BufferAsyncResult : LazyAsyncResult {
    public static object ResultSentinal;
    private int _countOrResult;
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public Byte[] Buffer { get; }
    public int Offset { get; }
    public int Count { get; }
    public int Int32Result { get; public set; }
    public BufferAsyncResult(object asyncObject, Byte[] buffer, int offset, int count, object asyncState, AsyncCallback asyncCallback);
    private static BufferAsyncResult();
    [CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
public int get_Offset();
    public int get_Count();
    public int get_Int32Result();
    public void set_Int32Result(int value);
}
internal static class System.Net.CertificateValidationPal : object {
    private static object s_syncObject;
    private static X509Store modreq(System.Runtime.CompilerServices.IsVolatile) s_myCertStoreEx;
    private static X509Store modreq(System.Runtime.CompilerServices.IsVolatile) s_myMachineCertStoreEx;
    private static CertificateValidationPal();
    internal static X509Store EnsureStoreOpened(bool isMachineStore);
    internal static SslPolicyErrors VerifyCertificateProperties(SafeDeleteContext securityContext, X509Chain chain, X509Certificate2 remoteCertificate, bool checkCertName, bool isServer, string hostName);
    internal static X509Certificate2 GetRemoteCertificate(SafeDeleteContext securityContext);
    internal static X509Certificate2 GetRemoteCertificate(SafeDeleteContext securityContext, X509Certificate2Collection& remoteCertificateStore);
    private static X509Certificate2 GetRemoteCertificate(SafeDeleteContext securityContext, X509Certificate2Collection remoteCertificateStore);
    internal static String[] GetRequestCertificateAuthorities(SafeDeleteContext securityContext);
    private static X509Store OpenStore(StoreLocation storeLocation);
}
internal static class System.Net.ContextFlagsAdapterPal : object {
    private static ContextFlagMapping[] s_contextFlagMapping;
    private static ContextFlagsAdapterPal();
    internal static ContextFlagsPal GetContextFlagsPalFromInterop(GssFlags gssFlags, bool isServer);
    internal static GssFlags GetInteropFromContextFlagsPal(ContextFlagsPal flags, bool isServer);
}
[FlagsAttribute]
internal enum System.Net.ContextFlagsPal : Enum {
    public int value__;
    public static ContextFlagsPal None;
    public static ContextFlagsPal Delegate;
    public static ContextFlagsPal MutualAuth;
    public static ContextFlagsPal ReplayDetect;
    public static ContextFlagsPal SequenceDetect;
    public static ContextFlagsPal Confidentiality;
    public static ContextFlagsPal UseSessionKey;
    public static ContextFlagsPal AllocateMemory;
    public static ContextFlagsPal Connection;
    public static ContextFlagsPal InitExtendedError;
    public static ContextFlagsPal AcceptExtendedError;
    public static ContextFlagsPal InitStream;
    public static ContextFlagsPal AcceptStream;
    public static ContextFlagsPal InitIntegrity;
    public static ContextFlagsPal AcceptIntegrity;
    public static ContextFlagsPal InitManualCredValidation;
    public static ContextFlagsPal InitUseSuppliedCreds;
    public static ContextFlagsPal InitIdentify;
    public static ContextFlagsPal AcceptIdentify;
    public static ContextFlagsPal ProxyBindings;
    public static ContextFlagsPal AllowMissingBindings;
    public static ContextFlagsPal UnverifiedTargetName;
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal static class System.Net.FixedSizeReader : object {
    public static int ReadPacket(Stream transport, Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Net.FixedSizeReader/<ReadPacketAsync>d__1")]
public static void ReadPacketAsync(Stream transport, AsyncProtocolRequest request);
}
internal class System.Net.FrameHeader : object {
    private int _MessageId;
    private int _MajorV;
    private int _MinorV;
    private int _PayloadSize;
    public int Size { get; }
    public int MaxMessageSize { get; }
    public int MessageId { get; public set; }
    public int MajorV { get; }
    public int MinorV { get; }
    public int PayloadSize { get; public set; }
    public FrameHeader(int messageId, int majorV, int minorV);
    public int get_Size();
    public int get_MaxMessageSize();
    public int get_MessageId();
    public void set_MessageId(int value);
    public int get_MajorV();
    public int get_MinorV();
    public int get_PayloadSize();
    public void set_PayloadSize(int value);
    public void CopyTo(Byte[] dest, int start);
    public void CopyFrom(Byte[] bytes, int start, FrameHeader verifier);
}
[ExtensionAttribute]
internal static class System.Net.Http.TLSCertificateExtensions : object {
    private static Oid s_clientCertOidInst;
    private static TLSCertificateExtensions();
    internal static X509Chain BuildNewChain(X509Certificate2 certificate, bool includeClientApplicationPolicy);
}
internal class System.Net.InternalException : Exception {
}
internal class System.Net.LazyAsyncResult : object {
    [ThreadStaticAttribute]
private static ThreadContext t_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _intCompleted;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal void set_Result(object value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    private static int SecureChannelCtorId;
    private static int LocatingPrivateKeyId;
    private static int CertIsType2Id;
    private static int FoundCertInStoreId;
    private static int NotFoundCertInStoreId;
    private static int RemoteCertificateId;
    private static int CertificateFromDelegateId;
    private static int NoDelegateNoClientCertId;
    private static int NoDelegateButClientCertId;
    private static int AttemptingRestartUsingCertId;
    private static int NoIssuersTryAllCertsId;
    private static int LookForMatchingCertsId;
    private static int SelectedCertId;
    private static int CertsAfterFilteringId;
    private static int FindingMatchingCertsId;
    private static int UsingCachedCredentialId;
    private static int SspiSelectedCipherSuitId;
    private static int RemoteCertificateErrorId;
    private static int RemoteVertificateValidId;
    private static int RemoteCertificateSuccesId;
    private static int RemoteCertificateInvalidId;
    public static NetEventSource Log;
    private static string MissingMember;
    private static string NullInstance;
    private static string StaticMethodObject;
    private static string NoParameters;
    private static int MaxDumpSize;
    private static int EnterEventId;
    private static int ExitEventId;
    private static int AssociateEventId;
    private static int InfoEventId;
    private static int ErrorEventId;
    private static int CriticalFailureEventId;
    private static int DumpArrayEventId;
    private static int EnumerateSecurityPackagesId;
    private static int SspiPackageNotFoundId;
    private static int AcquireDefaultCredentialId;
    private static int AcquireCredentialsHandleId;
    private static int InitializeSecurityContextId;
    private static int SecurityContextInputBufferId;
    private static int SecurityContextInputBuffersId;
    private static int AcceptSecuritContextId;
    private static int OperationReturnedSomethingId;
    private static int NextAvailableEventId;
    public static bool IsEnabled { get; }
    private static NetEventSource();
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, ReadOnlyMemory`1<byte> buffer, string memberName);
    [EventAttribute("8")]
public void EnumerateSecurityPackages(string securityPackage);
    [EventAttribute("9")]
public void SspiPackageNotFound(string packageName);
    [NonEventAttribute]
public void SecureChannelCtor(SecureChannel secureChannel, string hostname, X509CertificateCollection clientCertificates, EncryptionPolicy encryptionPolicy);
    [EventAttribute("17")]
private void SecureChannelCtor(string hostname, int secureChannelHash, int clientCertificatesCount, EncryptionPolicy encryptionPolicy);
    [NonEventAttribute]
public void LocatingPrivateKey(X509Certificate x509Certificate, SecureChannel secureChannel);
    [EventAttribute("18")]
private void LocatingPrivateKey(string x509Certificate, int secureChannelHash);
    [NonEventAttribute]
public void CertIsType2(SecureChannel secureChannel);
    [EventAttribute("19")]
private void CertIsType2(int secureChannelHash);
    [NonEventAttribute]
public void FoundCertInStore(bool serverMode, SecureChannel secureChannel);
    [EventAttribute("20")]
private void FoundCertInStore(string store, int secureChannelHash);
    [NonEventAttribute]
public void NotFoundCertInStore(SecureChannel secureChannel);
    [EventAttribute("21")]
private void NotFoundCertInStore(int secureChannelHash);
    [NonEventAttribute]
public void RemoteCertificate(X509Certificate remoteCertificate);
    [EventAttribute("22")]
private void RemoteCertificate(string remoteCertificate);
    [NonEventAttribute]
public void CertificateFromDelegate(SecureChannel secureChannel);
    [EventAttribute("23")]
private void CertificateFromDelegate(int secureChannelHash);
    [NonEventAttribute]
public void NoDelegateNoClientCert(SecureChannel secureChannel);
    [EventAttribute("24")]
private void NoDelegateNoClientCert(int secureChannelHash);
    [NonEventAttribute]
public void NoDelegateButClientCert(SecureChannel secureChannel);
    [EventAttribute("25")]
private void NoDelegateButClientCert(int secureChannelHash);
    [NonEventAttribute]
public void AttemptingRestartUsingCert(X509Certificate clientCertificate, SecureChannel secureChannel);
    [EventAttribute("26")]
private void AttemptingRestartUsingCert(string clientCertificate, int secureChannelHash);
    [NonEventAttribute]
public void NoIssuersTryAllCerts(SecureChannel secureChannel);
    [EventAttribute("27")]
private void NoIssuersTryAllCerts(int secureChannelHash);
    [NonEventAttribute]
public void LookForMatchingCerts(int issuersCount, SecureChannel secureChannel);
    [EventAttribute("28")]
private void LookForMatchingCerts(int issuersCount, int secureChannelHash);
    [NonEventAttribute]
public void SelectedCert(X509Certificate clientCertificate, SecureChannel secureChannel);
    [EventAttribute("29")]
private void SelectedCert(string clientCertificate, int secureChannelHash);
    [NonEventAttribute]
public void CertsAfterFiltering(int filteredCertsCount, SecureChannel secureChannel);
    [EventAttribute("30")]
private void CertsAfterFiltering(int filteredCertsCount, int secureChannelHash);
    [NonEventAttribute]
public void FindingMatchingCerts(SecureChannel secureChannel);
    [EventAttribute("31")]
private void FindingMatchingCerts(int secureChannelHash);
    [NonEventAttribute]
public void UsingCachedCredential(SecureChannel secureChannel);
    [EventAttribute("32")]
private void UsingCachedCredential(int secureChannelHash);
    [EventAttribute("33")]
public void SspiSelectedCipherSuite(string process, SslProtocols sslProtocol, CipherAlgorithmType cipherAlgorithm, int cipherStrength, HashAlgorithmType hashAlgorithm, int hashStrength, ExchangeAlgorithmType keyExchangeAlgorithm, int keyExchangeStrength);
    [NonEventAttribute]
public void RemoteCertificateError(SecureChannel secureChannel, string message);
    [EventAttribute("34")]
private void RemoteCertificateError(int secureChannelHash, string message);
    [NonEventAttribute]
public void RemoteCertDeclaredValid(SecureChannel secureChannel);
    [EventAttribute("35")]
private void RemoteCertDeclaredValid(int secureChannelHash);
    [NonEventAttribute]
public void RemoteCertHasNoErrors(SecureChannel secureChannel);
    [EventAttribute("36")]
private void RemoteCertHasNoErrors(int secureChannelHash);
    [NonEventAttribute]
public void RemoteCertUserDeclaredInvalid(SecureChannel secureChannel);
    [EventAttribute("37")]
private void RemoteCertUserDeclaredInvalid(int secureChannelHash);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, object arg2, string memberName);
    [EventAttribute("1")]
private void Enter(string thisOrContextObject, string memberName, string parameters);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, object arg1, string memberName);
    [EventAttribute("2")]
private void Exit(string thisOrContextObject, string memberName, string result);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("4")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("5")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, object message, string memberName);
    [EventAttribute("6")]
private void CriticalFailure(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, IntPtr bufferPtr, int count, string memberName);
    [EventAttribute("7")]
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(object arg);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(FormattableString arg);
    public static bool get_IsEnabled();
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static object Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    private static void AdditionalCustomizedToString(T value, String& result);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, string arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4);
}
internal class System.Net.NTAuthentication : object {
    private static ContextCallback s_InitializeCallback;
    private bool _isServer;
    private SafeFreeCredentials _credentialsHandle;
    private SafeDeleteContext _securityContext;
    private string _spn;
    private int _tokenSize;
    private ContextFlagsPal _requestedContextFlags;
    private ContextFlagsPal _contextFlags;
    private bool _isCompleted;
    private string _package;
    private string _lastProtocolName;
    private string _protocolName;
    private string _clientSpecifiedSpn;
    private ChannelBinding _channelBinding;
    internal bool IsConfidentialityFlag { get; }
    internal bool IsIntegrityFlag { get; }
    internal bool IsMutualAuthFlag { get; }
    internal bool IsDelegationFlag { get; }
    internal bool IsIdentifyFlag { get; }
    internal string Spn { get; }
    internal bool IsNTLM { get; }
    internal bool IsCompleted { get; }
    internal bool IsValidContext { get; }
    internal bool IsServer { get; }
    internal string ClientSpecifiedSpn { get; }
    internal string ProtocolName { get; }
    internal bool IsKerberos { get; }
    internal NTAuthentication(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    private static NTAuthentication();
    internal bool get_IsConfidentialityFlag();
    internal bool get_IsIntegrityFlag();
    internal bool get_IsMutualAuthFlag();
    internal bool get_IsDelegationFlag();
    internal bool get_IsIdentifyFlag();
    internal string get_Spn();
    internal bool get_IsNTLM();
    private static void InitializeCallback(object state);
    internal int Encrypt(Byte[] buffer, int offset, int count, Byte[]& output, UInt32 sequenceNumber);
    internal int Decrypt(Byte[] payload, int offset, int count, Int32& newOffset, UInt32 expectedSeqNumber);
    internal bool get_IsCompleted();
    internal bool get_IsValidContext();
    internal bool get_IsServer();
    internal string get_ClientSpecifiedSpn();
    internal string get_ProtocolName();
    internal bool get_IsKerberos();
    private void Initialize(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    internal void CloseContext();
    internal int VerifySignature(Byte[] buffer, int offset, int count);
    internal int MakeSignature(Byte[] buffer, int offset, int count, Byte[]& output);
    internal string GetOutgoingBlob(string incomingBlob);
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool thrownOnError);
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool throwOnError, SecurityStatusPal& statusCode);
    private string GetClientSpecifiedSpn();
}
internal class System.Net.SafeDeleteSslContext : SafeDeleteContext {
    private SafeSslHandle _sslContext;
    private SSLReadFunc _readCallback;
    private SSLWriteFunc _writeCallback;
    private Queue`1<byte> _fromConnection;
    private Queue`1<byte> _toConnection;
    private static SslProtocols[] s_orderedSslProtocols;
    public SafeSslHandle SslContext { get; }
    public bool IsInvalid { get; }
    internal int BytesReadyForConnection { get; }
    public SafeDeleteSslContext(SafeFreeSslCredentials credential, SslAuthenticationOptions sslAuthenticationOptions);
    private static SafeDeleteSslContext();
    public SafeSslHandle get_SslContext();
    private static SafeSslHandle CreateSslContext(SafeFreeSslCredentials credential, bool isServer);
    public virtual bool get_IsInvalid();
    protected virtual void Dispose(bool disposing);
    private int WriteToConnection(Void* connection, Byte* data, Void** dataLength);
    private int ReadFromConnection(Void* connection, Byte* data, Void** dataLength);
    internal void Write(Byte[] buf, int offset, int count);
    internal int get_BytesReadyForConnection();
    internal Byte[] ReadPendingWrites();
    internal int ReadPendingWrites(Byte[] buf, int offset, int count);
    private static void SetProtocols(SafeSslHandle sslContext, SslProtocols protocols);
    private static void SetCertificate(SafeSslHandle sslContext, X509Certificate2 certificate);
}
internal class System.Net.SafeFreeSslCredentials : SafeFreeCredentials {
    [CompilerGeneratedAttribute]
private EncryptionPolicy <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    public EncryptionPolicy Policy { get; }
    public SslProtocols Protocols { get; }
    public X509Certificate2 Certificate { get; }
    public bool IsInvalid { get; }
    public SafeFreeSslCredentials(X509Certificate certificate, SslProtocols protocols, EncryptionPolicy policy);
    [CompilerGeneratedAttribute]
public EncryptionPolicy get_Policy();
    [CompilerGeneratedAttribute]
public SslProtocols get_Protocols();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Net.SafeSslHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
public abstract class System.Net.Security.AuthenticatedStream : Stream {
    private Stream _innerStream;
    private bool _leaveStreamOpen;
    public bool LeaveInnerStreamOpen { get; }
    protected Stream InnerStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    protected AuthenticatedStream(Stream innerStream, bool leaveInnerStreamOpen);
    public bool get_LeaveInnerStreamOpen();
    protected Stream get_InnerStream();
    protected virtual void Dispose(bool disposing);
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsMutuallyAuthenticated();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsSigned();
    public abstract virtual bool get_IsServer();
}
public enum System.Net.Security.EncryptionPolicy : Enum {
    public int value__;
    public static EncryptionPolicy RequireEncryption;
    public static EncryptionPolicy AllowNoEncryption;
    public static EncryptionPolicy NoEncryption;
}
internal static class System.Net.Security.EndpointChannelBindingToken : object {
    internal static ChannelBinding Build(SafeDeleteContext securityContext);
    private static HashAlgorithm GetHashForChannelBinding(X509Certificate2 cert);
}
public class System.Net.Security.LocalCertificateSelectionCallback : MulticastDelegate {
    public LocalCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.LocalCertSelectionCallback : MulticastDelegate {
    public LocalCertSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate2 remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate2 remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.NegoState : object {
    private static Byte[] s_emptyMessage;
    private static AsyncCallback s_readCallback;
    private static AsyncCallback s_writeCallback;
    private Stream _innerStream;
    private bool _leaveStreamOpen;
    private Exception _exception;
    private StreamFramer _framer;
    private NTAuthentication _context;
    private int _nestedAuth;
    private bool _canRetryAuthentication;
    private ProtectionLevel _expectedProtectionLevel;
    private TokenImpersonationLevel _expectedImpersonationLevel;
    private UInt32 _writeSequenceNumber;
    private UInt32 _readSequenceNumber;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private bool _remoteOk;
    internal static string DefaultPackage { get; }
    internal bool IsAuthenticated { get; }
    internal bool IsMutuallyAuthenticated { get; }
    internal bool IsEncrypted { get; }
    internal bool IsSigned { get; }
    internal bool IsServer { get; }
    internal bool CanGetSecureStream { get; }
    internal TokenImpersonationLevel AllowedImpersonation { get; }
    private TokenImpersonationLevel PrivateImpersonationLevel { get; }
    private bool HandshakeComplete { get; }
    internal NegoState(Stream innerStream, bool leaveStreamOpen);
    private static NegoState();
    internal static string get_DefaultPackage();
    internal IIdentity GetIdentity();
    internal void ValidateCreateContext(string package, NetworkCredential credential, string servicePrincipalName, ExtendedProtectionPolicy policy, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel);
    internal void ValidateCreateContext(string package, bool isServer, NetworkCredential credential, string servicePrincipalName, ChannelBinding channelBinding, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel);
    private Exception SetException(Exception e);
    internal bool get_IsAuthenticated();
    internal bool get_IsMutuallyAuthenticated();
    internal bool get_IsEncrypted();
    internal bool get_IsSigned();
    internal bool get_IsServer();
    internal bool get_CanGetSecureStream();
    internal TokenImpersonationLevel get_AllowedImpersonation();
    private TokenImpersonationLevel get_PrivateImpersonationLevel();
    private bool get_HandshakeComplete();
    internal void CheckThrow(bool authSucessCheck);
    internal void Close();
    internal void ProcessAuthentication(LazyAsyncResult lazyResult);
    internal void EndProcessAuthentication(IAsyncResult result);
    private bool CheckSpn();
    private void StartSendBlob(Byte[] message, LazyAsyncResult lazyResult);
    private void CheckCompletionBeforeNextReceive(LazyAsyncResult lazyResult);
    private void StartReceiveBlob(LazyAsyncResult lazyResult);
    private void ProcessReceivedBlob(Byte[] message, LazyAsyncResult lazyResult);
    private void CheckCompletionBeforeNextSend(Byte[] message, LazyAsyncResult lazyResult);
    private void StartSendAuthResetSignal(LazyAsyncResult lazyResult, Byte[] message, Exception exception);
    private static void WriteCallback(IAsyncResult transportResult);
    private static void ReadCallback(IAsyncResult transportResult);
    internal static bool IsError(SecurityStatusPal status);
    private Byte[] GetOutgoingBlob(Byte[] incomingBlob, Exception& e);
    internal int EncryptData(Byte[] buffer, int offset, int count, Byte[]& outBuffer);
    internal int DecryptData(Byte[] buffer, int offset, int count, Int32& newOffset);
    internal static void ThrowCredentialException(long error);
    internal static bool IsLogonDeniedException(Exception exception);
}
public class System.Net.Security.NegotiateStream : AuthenticatedStream {
    private NegoState _negoState;
    private string _package;
    private IIdentity _remoteIdentity;
    private static AsyncCallback s_writeCallback;
    private static AsyncProtocolCallback s_readCallback;
    private int _NestedWrite;
    private int _NestedRead;
    private Byte[] _ReadHeader;
    private Byte[] _InternalBuffer;
    private int _InternalOffset;
    private int _InternalBufferCount;
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    public IIdentity RemoteIdentity { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    private Byte[] InternalBuffer { get; }
    private int InternalOffset { get; }
    private int InternalBufferCount { get; }
    public NegotiateStream(Stream innerStream);
    public NegotiateStream(Stream innerStream, bool leaveInnerStreamOpen);
    private static NegotiateStream();
    public virtual IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual void AuthenticateAsServer();
    public virtual void AuthenticateAsServer(ExtendedProtectionPolicy policy);
    public virtual void AuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual void AuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual IAsyncResult BeginAuthenticateAsServer(AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    public virtual void AuthenticateAsClient();
    public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName);
    public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync();
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync();
    public virtual Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual TokenImpersonationLevel get_ImpersonationLevel();
    public virtual IIdentity get_RemoteIdentity();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private void InitializeStreamPart();
    private Byte[] get_InternalBuffer();
    private int get_InternalOffset();
    private int get_InternalBufferCount();
    private void DecrementInternalBufferCount(int decrCount);
    private void EnsureInternalBufferSize(int bytes);
    private void AdjustInternalBufferOffsetSize(int bytes, int offset);
    private void ValidateParameters(Byte[] buffer, int offset, int count);
    private void ProcessWrite(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private void StartWriting(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int ProcessRead(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartReading(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartFrameHeader(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartFrameBody(int readBytes, Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int ProcessFrameBody(int readBytes, Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private static void WriteCallback(IAsyncResult transportResult);
    private static void ReadCallback(AsyncProtocolRequest asyncRequest);
}
internal static class System.Net.Security.NegotiateStreamPal : object {
    internal static string QueryContextClientSpecifiedSpn(SafeDeleteContext securityContext);
    internal static string QueryContextAuthenticationPackage(SafeDeleteContext securityContext);
    private static Byte[] GssWrap(SafeGssContextHandle context, bool encrypt, Byte[] buffer, int offset, int count);
    private static int GssUnwrap(SafeGssContextHandle context, Byte[] buffer, int offset, int count);
    private static bool GssInitSecurityContext(SafeGssContextHandle& context, SafeGssCredHandle credential, bool isNtlm, SafeGssNameHandle targetName, GssFlags inFlags, Byte[] buffer, Byte[]& outputBuffer, UInt32& outFlags, Int32& isNtlmUsed);
    private static SecurityStatusPal EstablishSecurityContext(SafeFreeNegoCredentials credential, SafeDeleteContext& context, string targetName, ContextFlagsPal inFlags, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlagsPal& outFlags);
    internal static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, string spn, ContextFlagsPal requestedContextFlags, SecurityBuffer[] inSecurityBufferArray, SecurityBuffer outSecurityBuffer, ContextFlagsPal& contextFlags);
    internal static SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, ContextFlagsPal requestedContextFlags, SecurityBuffer[] inSecurityBufferArray, SecurityBuffer outSecurityBuffer, ContextFlagsPal& contextFlags);
    internal static Win32Exception CreateExceptionFromError(SecurityStatusPal statusCode);
    internal static int QueryMaxTokenSize(string package);
    internal static SafeFreeCredentials AcquireDefaultCredential(string package, bool isServer);
    internal static SafeFreeCredentials AcquireCredentialsHandle(string package, bool isServer, NetworkCredential credential);
    internal static SecurityStatusPal CompleteAuthToken(SafeDeleteContext& securityContext, SecurityBuffer[] inSecurityBufferArray);
    internal static int Encrypt(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, bool isConfidential, bool isNtlm, Byte[]& output, UInt32 sequenceNumber);
    internal static int Decrypt(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, bool isConfidential, bool isNtlm, Int32& newOffset, UInt32 sequenceNumber);
    internal static int VerifySignature(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count);
    internal static int MakeSignature(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, Byte[]& output);
    internal static IIdentity GetIdentity(NTAuthentication context);
    internal static void ValidateImpersonationLevel(TokenImpersonationLevel impersonationLevel);
}
public enum System.Net.Security.ProtectionLevel : Enum {
    public int value__;
    public static ProtectionLevel None;
    public static ProtectionLevel Sign;
    public static ProtectionLevel EncryptAndSign;
}
internal class System.Net.Security.ProtocolToken : object {
    internal SecurityStatusPal Status;
    internal Byte[] Payload;
    internal int Size;
    internal bool Failed { get; }
    internal bool Done { get; }
    internal bool Renegotiate { get; }
    internal bool CloseConnection { get; }
    internal ProtocolToken(Byte[] data, SecurityStatusPal status);
    internal bool get_Failed();
    internal bool get_Done();
    internal bool get_Renegotiate();
    internal bool get_CloseConnection();
    internal Exception GetException();
}
public class System.Net.Security.RemoteCertificateValidationCallback : MulticastDelegate {
    public RemoteCertificateValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.RemoteCertValidationCallback : MulticastDelegate {
    public RemoteCertValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(string host, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(string host, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.SafeChannelBindingHandle : ChannelBinding {
    private static Byte[] s_tlsServerEndPointByteArray;
    private static Byte[] s_tlsUniqueByteArray;
    private static int s_secChannelBindingSize;
    private int _cbtPrefixByteArraySize;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <CertHashPtr>k__BackingField;
    internal int Length { get; private set; }
    internal IntPtr CertHashPtr { get; }
    public int Size { get; }
    public bool IsInvalid { get; }
    internal SafeChannelBindingHandle(ChannelBindingKind kind);
    private static SafeChannelBindingHandle();
    [CompilerGeneratedAttribute]
internal int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [CompilerGeneratedAttribute]
internal IntPtr get_CertHashPtr();
    public virtual int get_Size();
    internal void SetCertHash(Byte[] certHashBytes);
    private Byte[] GetPrefixBytes(ChannelBindingKind kind);
    internal void SetCertHashLength(int certHashLength);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeCredentialReference : CriticalHandleMinusOneIsInvalid {
    internal SafeFreeCredentials Target;
    private SafeCredentialReference(SafeFreeCredentials target);
    internal static SafeCredentialReference CreateReference(SafeFreeCredentials target);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeDeleteContext : SafeHandle {
    private SafeFreeCredentials _credential;
    public bool IsInvalid { get; }
    protected SafeDeleteContext(SafeFreeCredentials credential);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeDeleteNegoContext : SafeDeleteContext {
    private SafeGssNameHandle _targetName;
    private SafeGssContextHandle _context;
    private bool _isNtlmUsed;
    public SafeGssNameHandle TargetName { get; }
    public bool IsNtlmUsed { get; }
    public SafeGssContextHandle GssContext { get; }
    public SafeDeleteNegoContext(SafeFreeNegoCredentials credential, string targetName);
    public SafeGssNameHandle get_TargetName();
    public bool get_IsNtlmUsed();
    public SafeGssContextHandle get_GssContext();
    public void SetGssContext(SafeGssContextHandle context);
    public void SetAuthenticationPackage(bool isNtlmUsed);
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.Net.Security.SafeFreeCredentials : SafeHandle {
    protected SafeFreeCredentials(IntPtr handle, bool ownsHandle);
}
internal class System.Net.Security.SafeFreeNegoCredentials : SafeFreeCredentials {
    private SafeGssCredHandle _credential;
    private bool _isNtlmOnly;
    private string _userName;
    private bool _isDefault;
    public SafeGssCredHandle GssCredential { get; }
    public bool IsNtlmOnly { get; }
    public string UserName { get; }
    public bool IsDefault { get; }
    public bool IsInvalid { get; }
    public SafeFreeNegoCredentials(bool isNtlmOnly, string username, string password, string domain);
    public SafeGssCredHandle get_GssCredential();
    public bool get_IsNtlmOnly();
    public string get_UserName();
    public bool get_IsDefault();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SecureChannel : object {
    private SafeFreeCredentials _credentialsHandle;
    private SafeDeleteContext _securityContext;
    private SslConnectionInfo _connectionInfo;
    private X509Certificate _selectedClientCertificate;
    private bool _isRemoteCertificateAvailable;
    private int _headerSize;
    private int _trailerSize;
    private int _maxDataSize;
    private bool _refreshCredentialNeeded;
    private SslAuthenticationOptions _sslAuthenticationOptions;
    private SslApplicationProtocol _negotiatedApplicationProtocol;
    private Oid _serverAuthOid;
    private Oid _clientAuthOid;
    internal X509Certificate LocalServerCertificate { get; }
    internal X509Certificate LocalClientCertificate { get; }
    internal bool IsRemoteCertificateAvailable { get; }
    internal X509RevocationMode CheckCertRevocationStatus { get; }
    internal int MaxDataSize { get; }
    internal SslConnectionInfo ConnectionInfo { get; }
    internal bool IsValidContext { get; }
    internal bool IsServer { get; }
    internal bool RemoteCertRequired { get; }
    internal SslApplicationProtocol NegotiatedApplicationProtocol { get; }
    internal SecureChannel(SslAuthenticationOptions sslAuthenticationOptions);
    internal X509Certificate get_LocalServerCertificate();
    internal X509Certificate get_LocalClientCertificate();
    internal bool get_IsRemoteCertificateAvailable();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    internal X509RevocationMode get_CheckCertRevocationStatus();
    internal int get_MaxDataSize();
    internal SslConnectionInfo get_ConnectionInfo();
    internal bool get_IsValidContext();
    internal bool get_IsServer();
    internal bool get_RemoteCertRequired();
    internal SslApplicationProtocol get_NegotiatedApplicationProtocol();
    internal void SetRefreshCredentialNeeded();
    internal void Close();
    private X509Certificate2 EnsurePrivateKey(X509Certificate certificate);
    private static X509Certificate2 MakeEx(X509Certificate certificate);
    private String[] GetRequestCertificateAuthorities();
    private bool AcquireClientCredentials(Byte[]& thumbPrint);
    private bool AcquireServerCredentials(Byte[]& thumbPrint, Byte[] clientHello);
    internal ProtocolToken NextMessage(Byte[] incoming, int offset, int count);
    private SecurityStatusPal GenerateToken(Byte[] input, int offset, int count, Byte[]& output);
    internal void ProcessHandshakeSuccess();
    internal SecurityStatusPal Encrypt(ReadOnlyMemory`1<byte> buffer, Byte[]& output, Int32& resultSize);
    internal SecurityStatusPal Decrypt(Byte[] payload, Int32& offset, Int32& count);
    internal bool VerifyRemoteCertificate(RemoteCertValidationCallback remoteCertValidationCallback, ProtocolToken& alertToken);
    public ProtocolToken CreateFatalHandshakeAlertToken(SslPolicyErrors sslPolicyErrors, X509Chain chain);
    public ProtocolToken CreateShutdownToken();
    private ProtocolToken GenerateAlertToken();
    private static TlsAlertMessage GetAlertMessageFromChain(X509Chain chain);
    private void LogCertificateValidation(RemoteCertValidationCallback remoteCertValidationCallback, SslPolicyErrors sslPolicyErrors, bool success, X509Chain chain);
}
internal class System.Net.Security.SecurityBuffer : object {
    public int size;
    public SecurityBufferType type;
    public Byte[] token;
    public SafeHandle unmanagedToken;
    public int offset;
    public SecurityBuffer(Byte[] data, int offset, int size, SecurityBufferType tokentype);
    public SecurityBuffer(Byte[] data, SecurityBufferType tokentype);
    public SecurityBuffer(int size, SecurityBufferType tokentype);
    public SecurityBuffer(ChannelBinding binding);
}
internal enum System.Net.Security.SecurityBufferType : Enum {
    public int value__;
    public static SecurityBufferType SECBUFFER_EMPTY;
    public static SecurityBufferType SECBUFFER_DATA;
    public static SecurityBufferType SECBUFFER_TOKEN;
    public static SecurityBufferType SECBUFFER_PKG_PARAMS;
    public static SecurityBufferType SECBUFFER_MISSING;
    public static SecurityBufferType SECBUFFER_EXTRA;
    public static SecurityBufferType SECBUFFER_STREAM_TRAILER;
    public static SecurityBufferType SECBUFFER_STREAM_HEADER;
    public static SecurityBufferType SECBUFFER_PADDING;
    public static SecurityBufferType SECBUFFER_STREAM;
    public static SecurityBufferType SECBUFFER_CHANNEL_BINDINGS;
    public static SecurityBufferType SECBUFFER_TARGET_HOST;
    public static SecurityBufferType SECBUFFER_ALERT;
    public static SecurityBufferType SECBUFFER_APPLICATION_PROTOCOLS;
    public static SecurityBufferType SECBUFFER_READONLY;
    public static SecurityBufferType SECBUFFER_READONLY_WITH_CHECKSUM;
}
public class System.Net.Security.ServerCertificateSelectionCallback : MulticastDelegate {
    public ServerCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string hostName);
    public virtual IAsyncResult BeginInvoke(object sender, string hostName, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.ServerCertSelectionCallback : MulticastDelegate {
    public ServerCertSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(string hostName);
    public virtual IAsyncResult BeginInvoke(string hostName, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.SniHelper : object {
    private static IdnMapping s_idnMapping;
    private static Encoding s_encoding;
    private static SniHelper();
    public static string GetServerName(Byte[] clientHello);
    private static string GetSniFromSslPlainText(ReadOnlySpan`1<byte> sslPlainText);
    private static string GetSniFromSslHandshake(ReadOnlySpan`1<byte> sslHandshake);
    private static string GetSniFromClientHello(ReadOnlySpan`1<byte> clientHello);
    private static string GetSniFromExtension(ReadOnlySpan`1<byte> extension, ReadOnlySpan`1& remainingBytes, Boolean& invalid);
    private static string GetSniFromServerNameList(ReadOnlySpan`1<byte> serverNameListExtension, ReadOnlySpan`1& remainingBytes, Boolean& invalid);
    private static string GetSniFromServerName(ReadOnlySpan`1<byte> serverName, Boolean& invalid);
    private static string GetSniFromHostNameStruct(ReadOnlySpan`1<byte> hostNameStruct, Boolean& invalid);
    private static string DecodeString(ReadOnlySpan`1<byte> bytes);
    private static int ReadUInt24BigEndian(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> SkipBytes(ReadOnlySpan`1<byte> bytes, int numberOfBytesToSkip);
    private static ReadOnlySpan`1<byte> SkipOpaqueType1(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> SkipOpaqueType2(ReadOnlySpan`1<byte> bytes, Boolean& invalid);
    private static IdnMapping CreateIdnMapping();
    private static Encoding CreateEncoding();
}
[IsReadOnlyAttribute]
public class System.Net.Security.SslApplicationProtocol : ValueType {
    private ReadOnlyMemory`1<byte> _readOnlyProtocol;
    private static Encoding s_utf8;
    public static SslApplicationProtocol Http2;
    public static SslApplicationProtocol Http11;
    public ReadOnlyMemory`1<byte> Protocol { get; }
    internal SslApplicationProtocol(Byte[] protocol, bool copy);
    public SslApplicationProtocol(Byte[] protocol);
    public SslApplicationProtocol(string protocol);
    private static SslApplicationProtocol();
    public ReadOnlyMemory`1<byte> get_Protocol();
    public sealed virtual bool Equals(SslApplicationProtocol other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(SslApplicationProtocol left, SslApplicationProtocol right);
    public static bool op_Inequality(SslApplicationProtocol left, SslApplicationProtocol right);
    [CompilerGeneratedAttribute]
internal static char <ToString>g__GetHexValue|12_0(int i);
}
internal class System.Net.Security.SslAuthenticationOptions : object {
    [CompilerGeneratedAttribute]
private bool <AllowRenegotiation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetHost>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServer>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalCertificateSelectionCallback <LocalCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <ServerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <EnabledSslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private X509RevocationMode <CertificateRevocationCheckMode>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionPolicy <EncryptionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoteCertRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCertName>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertValidationCallback <CertValidationDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalCertSelectionCallback <CertSelectionDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerCertSelectionCallback <ServerCertSelectionDelegate>k__BackingField;
    internal bool AllowRenegotiation { get; internal set; }
    internal string TargetHost { get; internal set; }
    internal X509CertificateCollection ClientCertificates { get; internal set; }
    internal bool IsServer { get; internal set; }
    unknown RemoteCertificateValidationCallback RemoteCertificateValidationCallback {internal set; }
    unknown LocalCertificateSelectionCallback LocalCertificateSelectionCallback {internal set; }
    internal X509Certificate ServerCertificate { get; internal set; }
    internal SslProtocols EnabledSslProtocols { get; internal set; }
    internal X509RevocationMode CertificateRevocationCheckMode { get; internal set; }
    internal EncryptionPolicy EncryptionPolicy { get; internal set; }
    internal bool RemoteCertRequired { get; internal set; }
    internal bool CheckCertName { get; internal set; }
    internal RemoteCertValidationCallback CertValidationDelegate { get; internal set; }
    internal LocalCertSelectionCallback CertSelectionDelegate { get; internal set; }
    internal ServerCertSelectionCallback ServerCertSelectionDelegate { get; internal set; }
    internal SslAuthenticationOptions(SslClientAuthenticationOptions sslClientAuthenticationOptions, RemoteCertValidationCallback remoteCallback, LocalCertSelectionCallback localCallback);
    internal SslAuthenticationOptions(SslServerAuthenticationOptions sslServerAuthenticationOptions);
    [CompilerGeneratedAttribute]
internal bool get_AllowRenegotiation();
    [CompilerGeneratedAttribute]
internal void set_AllowRenegotiation(bool value);
    [CompilerGeneratedAttribute]
internal string get_TargetHost();
    [CompilerGeneratedAttribute]
internal void set_TargetHost(string value);
    [CompilerGeneratedAttribute]
internal X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
internal void set_ClientCertificates(X509CertificateCollection value);
    [CompilerGeneratedAttribute]
internal bool get_IsServer();
    [CompilerGeneratedAttribute]
internal void set_IsServer(bool value);
    [CompilerGeneratedAttribute]
internal void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
internal void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
internal X509Certificate get_ServerCertificate();
    [CompilerGeneratedAttribute]
internal void set_ServerCertificate(X509Certificate value);
    [CompilerGeneratedAttribute]
internal SslProtocols get_EnabledSslProtocols();
    [CompilerGeneratedAttribute]
internal void set_EnabledSslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
internal X509RevocationMode get_CertificateRevocationCheckMode();
    [CompilerGeneratedAttribute]
internal void set_CertificateRevocationCheckMode(X509RevocationMode value);
    [CompilerGeneratedAttribute]
internal EncryptionPolicy get_EncryptionPolicy();
    [CompilerGeneratedAttribute]
internal void set_EncryptionPolicy(EncryptionPolicy value);
    [CompilerGeneratedAttribute]
internal bool get_RemoteCertRequired();
    [CompilerGeneratedAttribute]
internal void set_RemoteCertRequired(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CheckCertName();
    [CompilerGeneratedAttribute]
internal void set_CheckCertName(bool value);
    [CompilerGeneratedAttribute]
internal RemoteCertValidationCallback get_CertValidationDelegate();
    [CompilerGeneratedAttribute]
internal void set_CertValidationDelegate(RemoteCertValidationCallback value);
    [CompilerGeneratedAttribute]
internal LocalCertSelectionCallback get_CertSelectionDelegate();
    [CompilerGeneratedAttribute]
internal void set_CertSelectionDelegate(LocalCertSelectionCallback value);
    [CompilerGeneratedAttribute]
internal ServerCertSelectionCallback get_ServerCertSelectionDelegate();
    [CompilerGeneratedAttribute]
internal void set_ServerCertSelectionDelegate(ServerCertSelectionCallback value);
}
public class System.Net.Security.SslClientAuthenticationOptions : object {
    private EncryptionPolicy _encryptionPolicy;
    private X509RevocationMode _checkCertificateRevocation;
    private SslProtocols _enabledSslProtocols;
    private bool _allowRenegotiation;
    [CompilerGeneratedAttribute]
private LocalCertificateSelectionCallback <LocalCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetHost>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    public bool AllowRenegotiation { get; public set; }
    public LocalCertificateSelectionCallback LocalCertificateSelectionCallback { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public string TargetHost { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public bool get_AllowRenegotiation();
    public void set_AllowRenegotiation(bool value);
    [CompilerGeneratedAttribute]
public LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback();
    [CompilerGeneratedAttribute]
public void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    [CompilerGeneratedAttribute]
public string get_TargetHost();
    [CompilerGeneratedAttribute]
public void set_TargetHost(string value);
    [CompilerGeneratedAttribute]
public X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
public void set_ClientCertificates(X509CertificateCollection value);
    public X509RevocationMode get_CertificateRevocationCheckMode();
    public void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
}
internal class System.Net.Security.SslConnectionInfo : object {
    [CompilerGeneratedAttribute]
private int <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataCipherAlg>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataHashAlg>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataHashKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyExchangeAlg>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyExchKeySize>k__BackingField;
    private static Dictionary`2<TlsCipherSuite, TlsMapping> s_tlsLookup;
    public int Protocol { get; private set; }
    public int DataCipherAlg { get; private set; }
    public int DataKeySize { get; private set; }
    public int DataHashAlg { get; private set; }
    public int DataHashKeySize { get; private set; }
    public int KeyExchangeAlg { get; private set; }
    public int KeyExchKeySize { get; private set; }
    public SslConnectionInfo(SafeSslHandle sslContext);
    private static SslConnectionInfo();
    [CompilerGeneratedAttribute]
public int get_Protocol();
    [CompilerGeneratedAttribute]
private void set_Protocol(int value);
    [CompilerGeneratedAttribute]
public int get_DataCipherAlg();
    [CompilerGeneratedAttribute]
private void set_DataCipherAlg(int value);
    [CompilerGeneratedAttribute]
public int get_DataKeySize();
    [CompilerGeneratedAttribute]
private void set_DataKeySize(int value);
    [CompilerGeneratedAttribute]
public int get_DataHashAlg();
    [CompilerGeneratedAttribute]
private void set_DataHashAlg(int value);
    [CompilerGeneratedAttribute]
public int get_DataHashKeySize();
    [CompilerGeneratedAttribute]
private void set_DataHashKeySize(int value);
    [CompilerGeneratedAttribute]
public int get_KeyExchangeAlg();
    [CompilerGeneratedAttribute]
private void set_KeyExchangeAlg(int value);
    [CompilerGeneratedAttribute]
public int get_KeyExchKeySize();
    [CompilerGeneratedAttribute]
private void set_KeyExchKeySize(int value);
    private void MapCipherSuite(TlsCipherSuite cipherSuite);
}
public class System.Net.Security.SslServerAuthenticationOptions : object {
    private X509RevocationMode _checkCertificateRevocation;
    private SslProtocols _enabledSslProtocols;
    private EncryptionPolicy _encryptionPolicy;
    private bool _allowRenegotiation;
    [CompilerGeneratedAttribute]
private bool <ClientCertificateRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerCertificateSelectionCallback <ServerCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <ServerCertificate>k__BackingField;
    public bool AllowRenegotiation { get; public set; }
    public bool ClientCertificateRequired { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public ServerCertificateSelectionCallback ServerCertificateSelectionCallback { get; public set; }
    public X509Certificate ServerCertificate { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public bool get_AllowRenegotiation();
    public void set_AllowRenegotiation(bool value);
    [CompilerGeneratedAttribute]
public bool get_ClientCertificateRequired();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateRequired(bool value);
    [CompilerGeneratedAttribute]
public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public ServerCertificateSelectionCallback get_ServerCertificateSelectionCallback();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateSelectionCallback(ServerCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public X509Certificate get_ServerCertificate();
    [CompilerGeneratedAttribute]
public void set_ServerCertificate(X509Certificate value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
    public X509RevocationMode get_CertificateRevocationCheckMode();
    public void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
}
internal static class System.Net.Security.SslSessionsCache : object {
    private static ConcurrentDictionary`2<SslCredKey, SafeCredentialReference> s_cachedCreds;
    private static SslSessionsCache();
    internal static SafeFreeCredentials TryCachedCredential(Byte[] thumbPrint, SslProtocols sslProtocols, bool isServer, EncryptionPolicy encryptionPolicy);
    internal static void CacheCredential(SafeFreeCredentials creds, Byte[] thumbPrint, SslProtocols sslProtocols, bool isServer, EncryptionPolicy encryptionPolicy);
}
internal class System.Net.Security.SslState : object {
    private static int s_uniqueNameInteger;
    private static AsyncProtocolCallback s_partialFrameCallback;
    private static AsyncProtocolCallback s_readFrameCallback;
    private static AsyncCallback s_writeCallback;
    internal SslAuthenticationOptions _sslAuthenticationOptions;
    private Stream _innerStream;
    private SslStreamInternal _secureStream;
    private int _nestedAuth;
    private SecureChannel _context;
    private bool _handshakeCompleted;
    private bool _shutdown;
    private SecurityStatusPal _securityStatus;
    private ExceptionDispatchInfo _exception;
    private CachedSessionStatus _CachedSession;
    private Byte[] _queuedReadData;
    private int _queuedReadCount;
    private bool _pendingReHandshake;
    private int _lockWriteState;
    private object _queuedWriteStateRequest;
    private int _lockReadState;
    private object _queuedReadStateRequest;
    private static ExceptionDispatchInfo s_disposedSentinel;
    private Framing _Framing;
    internal SslApplicationProtocol NegotiatedApplicationProtocol { get; }
    internal bool IsAuthenticated { get; }
    internal bool IsMutuallyAuthenticated { get; }
    internal bool RemoteCertRequired { get; }
    internal bool IsServer { get; }
    internal X509Certificate LocalCertificate { get; }
    private X509Certificate InternalLocalCertificate { get; }
    internal bool CheckCertRevocationStatus { get; }
    internal bool IsShutdown { get; }
    internal CipherAlgorithmType CipherAlgorithm { get; }
    internal int CipherStrength { get; }
    internal HashAlgorithmType HashAlgorithm { get; }
    internal int HashStrength { get; }
    internal ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    internal int KeyExchangeStrength { get; }
    internal SslProtocols SslProtocol { get; }
    internal Stream InnerStream { get; }
    internal SslStreamInternal SecureStream { get; }
    internal int MaxDataSize { get; }
    private bool HandshakeCompleted { get; }
    private SecureChannel Context { get; }
    internal SslState(Stream innerStream);
    private static SslState();
    private void ThrowIfExceptional();
    internal void ValidateCreateContext(SslClientAuthenticationOptions sslClientAuthenticationOptions, RemoteCertValidationCallback remoteCallback, LocalCertSelectionCallback localCallback);
    internal void ValidateCreateContext(SslAuthenticationOptions sslAuthenticationOptions);
    internal SslApplicationProtocol get_NegotiatedApplicationProtocol();
    internal bool get_IsAuthenticated();
    internal bool get_IsMutuallyAuthenticated();
    internal bool get_RemoteCertRequired();
    internal bool get_IsServer();
    internal X509Certificate get_LocalCertificate();
    private X509Certificate get_InternalLocalCertificate();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    internal bool get_CheckCertRevocationStatus();
    internal bool get_IsShutdown();
    internal CipherAlgorithmType get_CipherAlgorithm();
    internal int get_CipherStrength();
    internal HashAlgorithmType get_HashAlgorithm();
    internal int get_HashStrength();
    internal ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    internal int get_KeyExchangeStrength();
    internal SslProtocols get_SslProtocol();
    internal Stream get_InnerStream();
    internal SslStreamInternal get_SecureStream();
    internal int get_MaxDataSize();
    private void SetException(Exception e);
    private bool get_HandshakeCompleted();
    private SecureChannel get_Context();
    internal void CheckThrow(bool authSuccessCheck, bool shutdownCheck);
    internal void Flush();
    internal Task FlushAsync(CancellationToken cancellationToken);
    internal void Close();
    internal SecurityStatusPal EncryptData(ReadOnlyMemory`1<byte> buffer, Byte[]& outBuffer, Int32& outSize);
    internal SecurityStatusPal DecryptData(Byte[] buffer, Int32& offset, Int32& count);
    private SecurityStatusPal PrivateDecryptData(Byte[] buffer, Int32& offset, Int32& count);
    private Exception EnqueueOldKeyDecryptedData(Byte[] buffer, int offset, int count);
    internal int CheckOldKeyDecryptedData(Memory`1<byte> buffer);
    internal void ProcessAuthentication(LazyAsyncResult lazyResult);
    internal void ReplyOnReAuthentication(Byte[] buffer);
    private void ForceAuthentication(bool receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest);
    internal void EndProcessAuthentication(IAsyncResult result);
    internal void InternalEndProcessAuthentication(LazyAsyncResult lazyResult);
    private void StartSendBlob(Byte[] incoming, int count, AsyncProtocolRequest asyncRequest);
    private void CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest);
    private void StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest);
    private void StartReadFrame(Byte[] buffer, int readBytes, AsyncProtocolRequest asyncRequest);
    private void ProcessReceivedBlob(Byte[] buffer, int count, AsyncProtocolRequest asyncRequest);
    private void StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception);
    private bool CompleteHandshake(ProtocolToken& alertToken);
    private static void WriteCallback(IAsyncResult transportResult);
    private static void PartialFrameCallback(AsyncProtocolRequest asyncRequest);
    private static void ReadFrameCallback(AsyncProtocolRequest asyncRequest);
    private bool CheckEnqueueHandshakeRead(Byte[]& buffer, AsyncProtocolRequest request);
    private void FinishHandshakeRead(int newState);
    internal int CheckEnqueueRead(Memory`1<byte> buffer);
    internal ValueTask`1<int> CheckEnqueueReadAsync(Memory`1<byte> buffer);
    internal void FinishRead(Byte[] renegotiateBuffer);
    internal Task CheckEnqueueWriteAsync();
    internal void CheckEnqueueWrite();
    internal void FinishWrite();
    private void HandleQueuedCallback(Object& queuedStateRequest);
    private bool CheckEnqueueHandshake(Byte[] buffer, AsyncProtocolRequest asyncRequest);
    private void FinishHandshake(Exception e, AsyncProtocolRequest asyncRequest);
    private static Byte[] EnsureBufferSize(Byte[] buffer, int copyCount, int size);
    private Framing DetectFraming(Byte[] bytes, int length);
    internal int GetRemainingFrameSize(Byte[] buffer, int offset, int dataSize);
    private void AsyncResumeHandshake(object state);
    private void AsyncResumeHandshakeRead(AsyncProtocolRequest asyncRequest);
    private void RehandshakeCompleteCallback(IAsyncResult result);
    internal IAsyncResult BeginShutdown(AsyncCallback asyncCallback, object asyncState);
    internal void EndShutdown(IAsyncResult result);
}
public class System.Net.Security.SslStream : AuthenticatedStream {
    private SslState _sslState;
    private object _remoteCertificateOrBytes;
    internal RemoteCertificateValidationCallback _userCertificateValidationCallback;
    internal LocalCertificateSelectionCallback _userCertificateSelectionCallback;
    internal ServerCertificateSelectionCallback _userServerCertificateSelectionCallback;
    internal RemoteCertValidationCallback _certValidationDelegate;
    internal LocalCertSelectionCallback _certSelectionDelegate;
    internal EncryptionPolicy _encryptionPolicy;
    public SslApplicationProtocol NegotiatedApplicationProtocol { get; }
    public TransportContext TransportContext { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public SslProtocols SslProtocol { get; }
    public bool CheckCertRevocationStatus { get; }
    public X509Certificate LocalCertificate { get; }
    public X509Certificate RemoteCertificate { get; }
    public CipherAlgorithmType CipherAlgorithm { get; }
    public int CipherStrength { get; }
    public HashAlgorithmType HashAlgorithm { get; }
    public int HashStrength { get; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    public int KeyExchangeStrength { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public SslStream(Stream innerStream);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback, EncryptionPolicy encryptionPolicy);
    public SslApplicationProtocol get_NegotiatedApplicationProtocol();
    private void SetAndVerifyValidationCallback(RemoteCertificateValidationCallback callback);
    private void SetAndVerifySelectionCallback(LocalCertificateSelectionCallback callback);
    private bool UserCertValidationCallbackWrapper(string hostName, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    private X509Certificate UserCertSelectionCallbackWrapper(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    private X509Certificate ServerCertSelectionCallbackWrapper(string targetHost);
    private SslAuthenticationOptions CreateAuthenticationOptions(SslServerAuthenticationOptions sslServerAuthenticationOptions);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    internal virtual IAsyncResult BeginAuthenticateAsClient(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    private IAsyncResult BeginAuthenticateAsServer(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    internal virtual IAsyncResult BeginShutdown(AsyncCallback asyncCallback, object asyncState);
    internal virtual void EndShutdown(IAsyncResult asyncResult);
    public TransportContext get_TransportContext();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    public virtual void AuthenticateAsClient(string targetHost);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    private void AuthenticateAsClient(SslClientAuthenticationOptions sslClientAuthenticationOptions);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    private void AuthenticateAsServer(SslServerAuthenticationOptions sslServerAuthenticationOptions);
    public virtual Task AuthenticateAsClientAsync(string targetHost);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsClientAsync(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsServerAsync(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken);
    public virtual Task ShutdownAsync();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual SslProtocols get_SslProtocol();
    public virtual bool get_CheckCertRevocationStatus();
    public virtual X509Certificate get_LocalCertificate();
    public virtual X509Certificate get_RemoteCertificate();
    public virtual CipherAlgorithmType get_CipherAlgorithm();
    public virtual int get_CipherStrength();
    public virtual HashAlgorithmType get_HashAlgorithm();
    public virtual int get_HashStrength();
    public virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    public virtual int get_KeyExchangeStrength();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
}
internal class System.Net.Security.SslStreamInternal : object {
    private SslState _sslState;
    private int _nestedWrite;
    private int _nestedRead;
    private Byte[] _internalBuffer;
    private int _internalOffset;
    private int _internalBufferCount;
    private int _decryptedBytesOffset;
    private int _decryptedBytesCount;
    internal SslStreamInternal(SslState sslState);
    private void ReturnReadBufferIfEmpty();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal int ReadByte();
    internal int Read(Byte[] buffer, int offset, int count);
    internal void Write(Byte[] buffer, int offset, int count);
    internal IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    internal Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    internal ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    internal int EndRead(IAsyncResult asyncResult);
    internal IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    internal void EndWrite(IAsyncResult asyncResult);
    internal ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    internal Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private void ResetReadBuffer();
    private void ValidateParameters(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Net.Security.SslStreamInternal/<ReadAsyncInternal>d__34`1")]
private ValueTask`1<int> ReadAsyncInternal(TReadAdapter adapter, Memory`1<byte> buffer);
    private ValueTask WriteAsyncInternal(TWriteAdapter writeAdapter, ReadOnlyMemory`1<byte> buffer);
    private ValueTask WriteSingleChunk(TWriteAdapter writeAdapter, ReadOnlyMemory`1<byte> buffer);
    [AsyncStateMachineAttribute("System.Net.Security.SslStreamInternal/<WriteAsyncChunked>d__37`1")]
private Task WriteAsyncChunked(TWriteAdapter writeAdapter, ReadOnlyMemory`1<byte> buffer);
    private ValueTask`1<int> FillBufferAsync(TReadAdapter adapter, int minSize);
    private void ConsumeBufferedBytes(int byteCount);
    private int CopyDecryptedData(Memory`1<byte> buffer);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("System.Net.Security.SslStreamInternal/<<WriteAsyncInternal>g__ExitWriteAsync|35_0>d`1")]
private Task <WriteAsyncInternal>g__ExitWriteAsync|35_0(ValueTask task);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("System.Net.Security.SslStreamInternal/<<WriteSingleChunk>g__WaitForWriteIOSlot|36_0>d`1")]
private Task <WriteSingleChunk>g__WaitForWriteIOSlot|36_0(TWriteAdapter wAdapter, Task lockTask, ReadOnlyMemory`1<byte> buff);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("System.Net.Security.SslStreamInternal/<<WriteSingleChunk>g__CompleteAsync|36_1>d`1")]
private Task <WriteSingleChunk>g__CompleteAsync|36_1(ValueTask writeTask, Byte[] bufferToReturn);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("System.Net.Security.SslStreamInternal/<<FillBufferAsync>g__InternalFillBufferAsync|38_0>d`1")]
private Task`1<int> <FillBufferAsync>g__InternalFillBufferAsync|38_0(TReadAdapter adap, ValueTask`1<int> task, int min, int initial);
}
internal static class System.Net.Security.SslStreamPal : object {
    public static Exception GetException(SecurityStatusPal status);
    public static void VerifyPackageInfo();
    public static SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, SslAuthenticationOptions sslAuthenticationOptions);
    public static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, SslAuthenticationOptions sslAuthenticationOptions);
    public static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, SslAuthenticationOptions sslAuthenticationOptions);
    public static SecurityBuffer[] GetIncomingSecurityBuffers(SslAuthenticationOptions options, SecurityBuffer& incomingSecurity);
    public static SafeFreeCredentials AcquireCredentialsHandle(X509Certificate certificate, SslProtocols protocols, EncryptionPolicy policy, bool isServer);
    internal static Byte[] GetNegotiatedApplicationProtocol(SafeDeleteContext context);
    public static SecurityStatusPal EncryptMessage(SafeDeleteContext securityContext, ReadOnlyMemory`1<byte> input, int headerSize, int trailerSize, Byte[]& output, Int32& resultSize);
    public static SecurityStatusPal DecryptMessage(SafeDeleteContext securityContext, Byte[] buffer, Int32& offset, Int32& count);
    public static ChannelBinding QueryContextChannelBinding(SafeDeleteContext securityContext, ChannelBindingKind attribute);
    public static void QueryContextStreamSizes(SafeDeleteContext securityContext, StreamSizes& streamSizes);
    public static void QueryContextConnectionInfo(SafeDeleteContext securityContext, SslConnectionInfo& connectionInfo);
    private static SecurityStatusPal HandshakeInternal(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, SslAuthenticationOptions sslAuthenticationOptions);
    private static SecurityStatusPal PerformHandshake(SafeSslHandle sslHandle);
    public static SecurityStatusPal ApplyAlertToken(SafeFreeCredentials& credentialsHandle, SafeDeleteContext securityContext, TlsAlertType alertType, TlsAlertMessage alertMessage);
    public static SecurityStatusPal ApplyShutdownToken(SafeFreeCredentials& credentialsHandle, SafeDeleteContext securityContext);
}
internal static class System.Net.Security.SSPIHandleCache : object {
    private static SafeCredentialReference[] s_cacheSlots;
    private static int s_current;
    private static SSPIHandleCache();
    internal static void CacheCredential(SafeFreeCredentials newHandle);
}
internal enum System.Net.Security.TlsAlertMessage : Enum {
    public int value__;
    public static TlsAlertMessage CloseNotify;
    public static TlsAlertMessage UnexpectedMessage;
    public static TlsAlertMessage BadRecordMac;
    public static TlsAlertMessage DecryptionFailed;
    public static TlsAlertMessage RecordOverflow;
    public static TlsAlertMessage DecompressionFail;
    public static TlsAlertMessage HandshakeFailure;
    public static TlsAlertMessage BadCertificate;
    public static TlsAlertMessage UnsupportedCert;
    public static TlsAlertMessage CertificateRevoked;
    public static TlsAlertMessage CertificateExpired;
    public static TlsAlertMessage CertificateUnknown;
    public static TlsAlertMessage IllegalParameter;
    public static TlsAlertMessage UnknownCA;
    public static TlsAlertMessage AccessDenied;
    public static TlsAlertMessage DecodeError;
    public static TlsAlertMessage DecryptError;
    public static TlsAlertMessage ExportRestriction;
    public static TlsAlertMessage ProtocolVersion;
    public static TlsAlertMessage InsuffientSecurity;
    public static TlsAlertMessage InternalError;
    public static TlsAlertMessage UserCanceled;
    public static TlsAlertMessage NoRenegotiation;
    public static TlsAlertMessage UnsupportedExt;
}
internal enum System.Net.Security.TlsAlertType : Enum {
    public int value__;
    public static TlsAlertType Warning;
    public static TlsAlertType Fatal;
}
[IsReadOnlyAttribute]
internal class System.Net.SecurityStatusPal : ValueType {
    public SecurityStatusPalErrorCode ErrorCode;
    public Exception Exception;
    public SecurityStatusPal(SecurityStatusPalErrorCode errorCode, Exception exception);
    public virtual string ToString();
}
internal enum System.Net.SecurityStatusPalErrorCode : Enum {
    public int value__;
    public static SecurityStatusPalErrorCode NotSet;
    public static SecurityStatusPalErrorCode OK;
    public static SecurityStatusPalErrorCode ContinueNeeded;
    public static SecurityStatusPalErrorCode CompleteNeeded;
    public static SecurityStatusPalErrorCode CompAndContinue;
    public static SecurityStatusPalErrorCode ContextExpired;
    public static SecurityStatusPalErrorCode CredentialsNeeded;
    public static SecurityStatusPalErrorCode Renegotiate;
    public static SecurityStatusPalErrorCode OutOfMemory;
    public static SecurityStatusPalErrorCode InvalidHandle;
    public static SecurityStatusPalErrorCode Unsupported;
    public static SecurityStatusPalErrorCode TargetUnknown;
    public static SecurityStatusPalErrorCode InternalError;
    public static SecurityStatusPalErrorCode PackageNotFound;
    public static SecurityStatusPalErrorCode NotOwner;
    public static SecurityStatusPalErrorCode CannotInstall;
    public static SecurityStatusPalErrorCode InvalidToken;
    public static SecurityStatusPalErrorCode CannotPack;
    public static SecurityStatusPalErrorCode QopNotSupported;
    public static SecurityStatusPalErrorCode NoImpersonation;
    public static SecurityStatusPalErrorCode LogonDenied;
    public static SecurityStatusPalErrorCode UnknownCredentials;
    public static SecurityStatusPalErrorCode NoCredentials;
    public static SecurityStatusPalErrorCode MessageAltered;
    public static SecurityStatusPalErrorCode OutOfSequence;
    public static SecurityStatusPalErrorCode NoAuthenticatingAuthority;
    public static SecurityStatusPalErrorCode IncompleteMessage;
    public static SecurityStatusPalErrorCode IncompleteCredentials;
    public static SecurityStatusPalErrorCode BufferNotEnough;
    public static SecurityStatusPalErrorCode WrongPrincipal;
    public static SecurityStatusPalErrorCode TimeSkew;
    public static SecurityStatusPalErrorCode UntrustedRoot;
    public static SecurityStatusPalErrorCode IllegalMessage;
    public static SecurityStatusPalErrorCode CertUnknown;
    public static SecurityStatusPalErrorCode CertExpired;
    public static SecurityStatusPalErrorCode AlgorithmMismatch;
    public static SecurityStatusPalErrorCode SecurityQosFailed;
    public static SecurityStatusPalErrorCode SmartcardLogonRequired;
    public static SecurityStatusPalErrorCode UnsupportedPreauth;
    public static SecurityStatusPalErrorCode BadBinding;
    public static SecurityStatusPalErrorCode DowngradeDetected;
    public static SecurityStatusPalErrorCode ApplicationProtocolMismatch;
}
internal class System.Net.SslStreamContext : TransportContext {
    private SslStream _sslStream;
    internal SslStreamContext(SslStream sslStream);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal class System.Net.StreamFramer : object {
    private Stream _transport;
    private bool _eof;
    private FrameHeader _writeHeader;
    private FrameHeader _curReadHeader;
    private FrameHeader _readVerifier;
    private Byte[] _readHeaderBuffer;
    private Byte[] _writeHeaderBuffer;
    private AsyncCallback _readFrameCallback;
    private AsyncCallback _beginWriteCallback;
    public FrameHeader ReadHeader { get; }
    public FrameHeader WriteHeader { get; }
    public Stream Transport { get; }
    public StreamFramer(Stream Transport);
    public FrameHeader get_ReadHeader();
    public FrameHeader get_WriteHeader();
    public Stream get_Transport();
    public Byte[] ReadMessage();
    public IAsyncResult BeginReadMessage(AsyncCallback asyncCallback, object stateObject);
    private void ReadFrameCallback(IAsyncResult transportResult);
    private void ReadFrameComplete(IAsyncResult transportResult);
    public Byte[] EndReadMessage(IAsyncResult asyncResult);
    public void WriteMessage(Byte[] message);
    public IAsyncResult BeginWriteMessage(Byte[] message, AsyncCallback asyncCallback, object stateObject);
    private void BeginWriteCallback(IAsyncResult transportResult);
    private void BeginWriteComplete(IAsyncResult transportResult);
    public void EndWriteMessage(IAsyncResult asyncResult);
}
internal class System.Net.StreamSizes : ValueType {
    [CompilerGeneratedAttribute]
private int <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Trailer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumMessage>k__BackingField;
    public int Header { get; }
    public int Trailer { get; }
    public int MaximumMessage { get; private set; }
    public static StreamSizes Default { get; }
    [CompilerGeneratedAttribute]
public int get_Header();
    [CompilerGeneratedAttribute]
public int get_Trailer();
    [CompilerGeneratedAttribute]
public int get_MaximumMessage();
    [CompilerGeneratedAttribute]
private void set_MaximumMessage(int value);
    public static StreamSizes get_Default();
}
internal class System.Net.WorkerAsyncResult : LazyAsyncResult {
    public Byte[] Buffer;
    public int Offset;
    public int End;
    public bool HeaderDone;
    public WorkerAsyncResult(object asyncObject, object asyncState, AsyncCallback savedAsyncCallback, Byte[] buffer, int offset, int end);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Authentication.AuthenticationException : SystemException {
    public AuthenticationException(string message);
    public AuthenticationException(string message, Exception innerException);
    protected AuthenticationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy : object {
    private ServiceNameCollection _customServiceNames;
    private PolicyEnforcement _policyEnforcement;
    private ProtectionScenario _protectionScenario;
    private ChannelBinding _customChannelBinding;
    public ServiceNameCollection CustomServiceNames { get; }
    public PolicyEnforcement PolicyEnforcement { get; }
    public ProtectionScenario ProtectionScenario { get; }
    public ChannelBinding CustomChannelBinding { get; }
    public static bool OSSupportsExtendedProtection { get; }
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ServiceNameCollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ICollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ChannelBinding customChannelBinding);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement);
    protected ExtendedProtectionPolicy(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public ServiceNameCollection get_CustomServiceNames();
    public PolicyEnforcement get_PolicyEnforcement();
    public ProtectionScenario get_ProtectionScenario();
    public ChannelBinding get_CustomChannelBinding();
    public virtual string ToString();
    public static bool get_OSSupportsExtendedProtection();
}
public enum System.Security.Authentication.ExtendedProtection.PolicyEnforcement : Enum {
    public int value__;
    public static PolicyEnforcement Never;
    public static PolicyEnforcement WhenSupported;
    public static PolicyEnforcement Always;
}
public enum System.Security.Authentication.ExtendedProtection.ProtectionScenario : Enum {
    public int value__;
    public static ProtectionScenario TransportSelected;
    public static ProtectionScenario TrustedProxy;
}
public class System.Security.Authentication.ExtendedProtection.ServiceNameCollection : ReadOnlyCollectionBase {
    public ServiceNameCollection(ICollection items);
    private ServiceNameCollection(IList list, string serviceName);
    private ServiceNameCollection(IList list, IEnumerable serviceNames);
    private ServiceNameCollection(IList list, int additionalCapacity);
    public bool Contains(string searchServiceName);
    public ServiceNameCollection Merge(string serviceName);
    public ServiceNameCollection Merge(IEnumerable serviceNames);
    private void AddIfNew(IEnumerable serviceNames, bool expectStrings);
    private void AddIfNew(List`1<string> serviceNames);
    private void AddIfNew(IList serviceNames);
    private void AddIfNew(string serviceName);
    private static int GetCountOrOne(IEnumerable collection);
    private static string NormalizeServiceName(string inputServiceName);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Authentication.InvalidCredentialException : AuthenticationException {
    public InvalidCredentialException(string message);
    public InvalidCredentialException(string message, Exception innerException);
    protected InvalidCredentialException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string net_noseek { get; }
    internal static string net_securityprotocolnotsupported { get; }
    internal static string net_io_readfailure { get; }
    internal static string net_io_connectionclosed { get; }
    internal static string net_io_invalidnestedcall { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_io_must_be_rw_stream { get; }
    internal static string net_io_header_id { get; }
    internal static string net_io_encrypt { get; }
    internal static string net_io_decrypt { get; }
    internal static string net_io_read { get; }
    internal static string net_io_write { get; }
    internal static string net_io_eof { get; }
    internal static string net_io_async_result { get; }
    internal static string net_ssl_io_frame { get; }
    internal static string net_ssl_io_renego { get; }
    internal static string net_ssl_io_cert_validation { get; }
    internal static string net_ssl_io_no_server_cert { get; }
    internal static string net_ssl_io_already_shutdown { get; }
    internal static string net_auth_bad_client_creds { get; }
    internal static string net_auth_bad_client_creds_or_target_mismatch { get; }
    internal static string net_auth_context_expectation { get; }
    internal static string net_auth_context_expectation_remote { get; }
    internal static string net_auth_supported_impl_levels { get; }
    internal static string net_auth_reauth { get; }
    internal static string net_auth_noauth { get; }
    internal static string net_auth_client_server { get; }
    internal static string net_auth_SSPI { get; }
    internal static string net_auth_eof { get; }
    internal static string net_auth_alert { get; }
    internal static string net_auth_ignored_reauth { get; }
    internal static string net_auth_must_specify_extended_protection_scheme { get; }
    internal static string net_frame_size { get; }
    internal static string net_frame_read_io { get; }
    internal static string net_frame_read_size { get; }
    internal static string net_frame_max_size { get; }
    internal static string net_offset_plus_count { get; }
    internal static string net_invalid_enum { get; }
    internal static string net_log_open_store_failed { get; }
    internal static string net_log_remote_cert_has_errors { get; }
    internal static string net_log_remote_cert_not_available { get; }
    internal static string net_log_remote_cert_name_mismatch { get; }
    internal static string security_ExtendedProtectionPolicy_UseDifferentConstructorForNever { get; }
    internal static string security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection { get; }
    internal static string security_ServiceNameCollection_EmptyServiceName { get; }
    internal static string net_gssapi_operation_failed_detailed { get; }
    internal static string net_gssapi_operation_failed { get; }
    internal static string net_context_buffer_too_small { get; }
    internal static string net_nego_channel_binding_not_supported { get; }
    internal static string net_ntlm_not_possible_default_cred { get; }
    internal static string net_nego_server_not_supported { get; }
    internal static string net_nego_protection_level_not_supported { get; }
    internal static string net_nego_not_supported_empty_target_with_defaultcreds { get; }
    internal static string net_security_sslprotocol_contiguous { get; }
    internal static string net_encryptionpolicy_notsupported { get; }
    internal static string net_ssl_app_protocol_invalid { get; }
    internal static string net_conflicting_options { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_net_noseek();
    internal static string get_net_securityprotocolnotsupported();
    internal static string get_net_io_readfailure();
    internal static string get_net_io_connectionclosed();
    internal static string get_net_io_invalidnestedcall();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_io_must_be_rw_stream();
    internal static string get_net_io_header_id();
    internal static string get_net_io_encrypt();
    internal static string get_net_io_decrypt();
    internal static string get_net_io_read();
    internal static string get_net_io_write();
    internal static string get_net_io_eof();
    internal static string get_net_io_async_result();
    internal static string get_net_ssl_io_frame();
    internal static string get_net_ssl_io_renego();
    internal static string get_net_ssl_io_cert_validation();
    internal static string get_net_ssl_io_no_server_cert();
    internal static string get_net_ssl_io_already_shutdown();
    internal static string get_net_auth_bad_client_creds();
    internal static string get_net_auth_bad_client_creds_or_target_mismatch();
    internal static string get_net_auth_context_expectation();
    internal static string get_net_auth_context_expectation_remote();
    internal static string get_net_auth_supported_impl_levels();
    internal static string get_net_auth_reauth();
    internal static string get_net_auth_noauth();
    internal static string get_net_auth_client_server();
    internal static string get_net_auth_SSPI();
    internal static string get_net_auth_eof();
    internal static string get_net_auth_alert();
    internal static string get_net_auth_ignored_reauth();
    internal static string get_net_auth_must_specify_extended_protection_scheme();
    internal static string get_net_frame_size();
    internal static string get_net_frame_read_io();
    internal static string get_net_frame_read_size();
    internal static string get_net_frame_max_size();
    internal static string get_net_offset_plus_count();
    internal static string get_net_invalid_enum();
    internal static string get_net_log_open_store_failed();
    internal static string get_net_log_remote_cert_has_errors();
    internal static string get_net_log_remote_cert_not_available();
    internal static string get_net_log_remote_cert_name_mismatch();
    internal static string get_security_ExtendedProtectionPolicy_UseDifferentConstructorForNever();
    internal static string get_security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection();
    internal static string get_security_ServiceNameCollection_EmptyServiceName();
    internal static string get_net_gssapi_operation_failed_detailed();
    internal static string get_net_gssapi_operation_failed();
    internal static string get_net_context_buffer_too_small();
    internal static string get_net_nego_channel_binding_not_supported();
    internal static string get_net_ntlm_not_possible_default_cred();
    internal static string get_net_nego_server_not_supported();
    internal static string get_net_nego_protection_level_not_supported();
    internal static string get_net_nego_not_supported_empty_target_with_defaultcreds();
    internal static string get_net_security_sslprotocol_contiguous();
    internal static string get_net_encryptionpolicy_notsupported();
    internal static string get_net_ssl_app_protocol_invalid();
    internal static string get_net_conflicting_options();
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
