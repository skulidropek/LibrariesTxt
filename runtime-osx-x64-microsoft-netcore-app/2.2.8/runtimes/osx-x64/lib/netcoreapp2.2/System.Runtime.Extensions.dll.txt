internal static class FxResources.System.Runtime.Extensions.SR : object {
}
internal static class Interop : object {
    private static void ThrowExceptionForIoErrno(ErrorInfo errorInfo, string path, bool isDirectory, Func`2<ErrorInfo, ErrorInfo> errorRewriter);
    internal static long CheckIo(long result, string path, bool isDirectory, Func`2<ErrorInfo, ErrorInfo> errorRewriter);
    internal static int CheckIo(int result, string path, bool isDirectory, Func`2<ErrorInfo, ErrorInfo> errorRewriter);
    internal static Exception GetExceptionForIoErrno(ErrorInfo errorInfo, string path, bool isDirectory);
    internal static Exception GetIOException(ErrorInfo errorInfo);
}
public class System.AppDomain : MarshalByRefObject {
    private static AppDomain s_domain;
    private object _forLock;
    private IPrincipal _defaultPrincipal;
    [CompilerGeneratedAttribute]
private EventHandler DomainUnload;
    [CompilerGeneratedAttribute]
private ResolveEventHandler ReflectionOnlyAssemblyResolve;
    public static AppDomain CurrentDomain { get; }
    public string BaseDirectory { get; }
    public string RelativeSearchPath { get; }
    public string DynamicDirectory { get; }
    public string FriendlyName { get; }
    public int Id { get; }
    public bool IsFullyTrusted { get; }
    public bool IsHomogenous { get; }
    public static bool MonitoringIsEnabled { get; public set; }
    public long MonitoringSurvivedMemorySize { get; }
    public static long MonitoringSurvivedProcessMemorySize { get; }
    public long MonitoringTotalAllocatedMemorySize { get; }
    public TimeSpan MonitoringTotalProcessorTime { get; }
    public bool ShadowCopyFiles { get; }
    private static AppDomain();
    public static AppDomain get_CurrentDomain();
    public string get_BaseDirectory();
    public string get_RelativeSearchPath();
    public void add_UnhandledException(UnhandledExceptionEventHandler value);
    public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public string get_DynamicDirectory();
    [ObsoleteAttribute("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetDynamicBase(string path);
    public string get_FriendlyName();
    public int get_Id();
    public bool get_IsFullyTrusted();
    public bool get_IsHomogenous();
    [CompilerGeneratedAttribute]
public void add_DomainUnload(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DomainUnload(EventHandler value);
    public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void add_ProcessExit(EventHandler value);
    public void remove_ProcessExit(EventHandler value);
    public string ApplyPolicy(string assemblyName);
    public static AppDomain CreateDomain(string friendlyName);
    public int ExecuteAssembly(string assemblyFile);
    public int ExecuteAssembly(string assemblyFile, String[] args);
    public int ExecuteAssembly(string assemblyFile, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    private int ExecuteAssembly(Assembly assembly, String[] args);
    public int ExecuteAssemblyByName(AssemblyName assemblyName, String[] args);
    public int ExecuteAssemblyByName(string assemblyName);
    public int ExecuteAssemblyByName(string assemblyName, String[] args);
    public object GetData(string name);
    public void SetData(string name, object data);
    public Nullable`1<bool> IsCompatibilitySwitchSet(string value);
    public bool IsDefaultAppDomain();
    public bool IsFinalizingForUnload();
    public virtual string ToString();
    public static void Unload(AppDomain domain);
    public Assembly Load(Byte[] rawAssembly);
    public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public Assembly Load(AssemblyName assemblyRef);
    public Assembly Load(string assemblyString);
    public Assembly[] ReflectionOnlyGetAssemblies();
    public static bool get_MonitoringIsEnabled();
    public static void set_MonitoringIsEnabled(bool value);
    public long get_MonitoringSurvivedMemorySize();
    public static long get_MonitoringSurvivedProcessMemorySize();
    public long get_MonitoringTotalAllocatedMemorySize();
    public TimeSpan get_MonitoringTotalProcessorTime();
    private static Exception CreateResMonNotAvailException();
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public static int GetCurrentThreadId();
    public bool get_ShadowCopyFiles();
    [ObsoleteAttribute("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void AppendPrivatePath(string path);
    [ObsoleteAttribute("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void ClearPrivatePath();
    [ObsoleteAttribute("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void ClearShadowCopyPath();
    [ObsoleteAttribute("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetCachePath(string path);
    [ObsoleteAttribute("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetShadowCopyFiles();
    [ObsoleteAttribute("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetShadowCopyPath(string path);
    public Assembly[] GetAssemblies();
    public void add_AssemblyLoad(AssemblyLoadEventHandler value);
    public void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    public void add_AssemblyResolve(ResolveEventHandler value);
    public void remove_AssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    public void add_TypeResolve(ResolveEventHandler value);
    public void remove_TypeResolve(ResolveEventHandler value);
    public void add_ResourceResolve(ResolveEventHandler value);
    public void remove_ResourceResolve(ResolveEventHandler value);
    public void SetPrincipalPolicy(PrincipalPolicy policy);
    public void SetThreadPrincipal(IPrincipal principal);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.AppDomainUnloadedException : SystemException {
    public AppDomainUnloadedException(string message);
    public AppDomainUnloadedException(string message, Exception innerException);
    protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
}
public class System.ApplicationId : object {
    private Byte[] _publicKeyToken;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessorArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Culture { get; }
    public string Name { get; }
    public string ProcessorArchitecture { get; }
    public Version Version { get; }
    public Byte[] PublicKeyToken { get; }
    public ApplicationId(Byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture);
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_ProcessorArchitecture();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public Byte[] get_PublicKeyToken();
    public ApplicationId Copy();
    public virtual string ToString();
    private static char HexDigit(int num);
    private static string EncodeHexString(Byte[] sArray);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.CannotUnloadAppDomainException : SystemException {
    public CannotUnloadAppDomainException(string message);
    public CannotUnloadAppDomainException(string message, Exception innerException);
    protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
}
public class System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
    private TextWriter _writer;
    private string _tabString;
    private int _indentLevel;
    private bool _tabsPending;
    public static string DefaultTabString;
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    public int Indent { get; public set; }
    public TextWriter InnerWriter { get; }
    public IndentedTextWriter(TextWriter writer);
    public IndentedTextWriter(TextWriter writer, string tabString);
    public virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public int get_Indent();
    public void set_Indent(int value);
    public TextWriter get_InnerWriter();
    public virtual void Close();
    public virtual void Flush();
    protected virtual void OutputTabs();
    public virtual void Write(string s);
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(float value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, Object[] arg);
    public void WriteLineNoTabs(string s);
    public virtual void WriteLine(string s);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.ArrayList/ArrayListDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ArrayList : object {
    private Object[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    internal ArrayList(bool trash);
    public ArrayList(int capacity);
    public ArrayList(ICollection c);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
    public static ArrayList Adapter(IList list);
    public virtual int Add(object value);
    public virtual void AddRange(ICollection c);
    public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
    public virtual int BinarySearch(object value);
    public virtual int BinarySearch(object value, IComparer comparer);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object item);
    public virtual void CopyTo(Array array);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
    private void EnsureCapacity(int min);
    public static IList FixedSize(IList list);
    public static ArrayList FixedSize(ArrayList list);
    public virtual IEnumerator GetEnumerator();
    public virtual IEnumerator GetEnumerator(int index, int count);
    public virtual int IndexOf(object value);
    public virtual int IndexOf(object value, int startIndex);
    public virtual int IndexOf(object value, int startIndex, int count);
    public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    public virtual int LastIndexOf(object value);
    public virtual int LastIndexOf(object value, int startIndex);
    public virtual int LastIndexOf(object value, int startIndex, int count);
    public static IList ReadOnly(IList list);
    public static ArrayList ReadOnly(ArrayList list);
    public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public static ArrayList Repeat(object value, int count);
    public virtual void Reverse();
    public virtual void Reverse(int index, int count);
    public virtual void SetRange(int index, ICollection c);
    public virtual ArrayList GetRange(int index, int count);
    public virtual void Sort();
    public virtual void Sort(IComparer comparer);
    public virtual void Sort(int index, int count, IComparer comparer);
    public static IList Synchronized(IList list);
    public static ArrayList Synchronized(ArrayList list);
    public virtual Object[] ToArray();
    public virtual Array ToArray(Type type);
    public virtual void TrimToSize();
}
internal class System.Collections.CompatibleComparer : object {
    private IHashCodeProvider _hcp;
    private IComparer _comparer;
    internal IHashCodeProvider HashCodeProvider { get; }
    internal IComparer Comparer { get; }
    internal CompatibleComparer(IHashCodeProvider hashCodeProvider, IComparer comparer);
    internal IHashCodeProvider get_HashCodeProvider();
    internal IComparer get_Comparer();
    public sealed virtual bool Equals(object a, object b);
    public int Compare(object a, object b);
    public sealed virtual int GetHashCode(object obj);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.LowLevelDictionary`2 : object {
    private Entry[] _buckets;
    private int _numEntries;
    private int _version;
    private IEqualityComparer`1<TKey> _comparer;
    unknown TValue Item {public set; }
    public LowLevelDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Clear(int capacity);
    private Entry<TKey, TValue> Find(TKey key);
    private Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
    private void ExpandBuckets();
    private int GetBucket(TKey key, int numBuckets);
}
internal static class System.Collections.HashHelpers : object {
    public static Int32[] primes;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[DebuggerTypeProxyAttribute("System.Collections.Hashtable/HashtableDebugView")]
public class System.Collections.Hashtable : object {
    private bucket[] _buckets;
    private int _count;
    private int _occupancy;
    private int _loadsize;
    private float _loadFactor;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _version;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isWriterInProgress;
    private ICollection _keys;
    private ICollection _values;
    private IEqualityComparer _keycomparer;
    private object _syncRoot;
    private static ConditionalWeakTable`2<object, SerializationInfo> s_serializationInfoTable;
    private static ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable { get; }
    [ObsoleteAttribute("Please use EqualityComparer property.")]
protected IHashCodeProvider hcp { get; protected set; }
    [ObsoleteAttribute("Please use KeyComparer properties.")]
protected IComparer comparer { get; protected set; }
    protected IEqualityComparer EqualityComparer { get; }
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    internal Hashtable(bool trash);
    public Hashtable(int capacity);
    public Hashtable(int capacity, float loadFactor);
    public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IEqualityComparer) instead.")]
public Hashtable(IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, IEqualityComparer) instead.")]
public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity, IEqualityComparer equalityComparer);
    public Hashtable(IDictionary d);
    public Hashtable(IDictionary d, float loadFactor);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, float, IEqualityComparer) instead.")]
public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
    protected Hashtable(SerializationInfo info, StreamingContext context);
    private static ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable();
    protected IHashCodeProvider get_hcp();
    protected void set_hcp(IHashCodeProvider value);
    protected IComparer get_comparer();
    protected void set_comparer(IComparer value);
    protected IEqualityComparer get_EqualityComparer();
    private UInt32 InitHash(object key, int hashsize, UInt32& seed, UInt32& incr);
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    private void CopyKeys(Array array, int arrayIndex);
    private void CopyEntries(Array array, int arrayIndex);
    public virtual void CopyTo(Array array, int arrayIndex);
    internal virtual KeyValuePairs[] ToKeyValuePairsArray();
    private void CopyValues(Array array, int arrayIndex);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    private void expand();
    private void rehash();
    private void UpdateVersion();
    private void rehash(int newsize);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    protected virtual int GetHash(object key);
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    protected virtual bool KeyEquals(object item, object key);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    private void Insert(object key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, object key, object nvalue, int hashcode);
    public virtual void Remove(object key);
    public virtual object get_SyncRoot();
    public virtual int get_Count();
    public static Hashtable Synchronized(Hashtable table);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[ObsoleteAttribute("Please use IEqualityComparer instead.")]
public interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
[DebuggerDisplayAttribute("{_value}")]
internal class System.Collections.KeyValuePairs : object {
    [DebuggerBrowsableAttribute("0")]
private object _key;
    [DebuggerBrowsableAttribute("0")]
private object _value;
    public KeyValuePairs(object key, object value);
}
public abstract class System.ContextBoundObject : MarshalByRefObject {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ContextMarshalException : SystemException {
    public ContextMarshalException(string message);
    public ContextMarshalException(string message, Exception inner);
    protected ContextMarshalException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("256")]
public class System.ContextStaticAttribute : Attribute {
}
public class System.Diagnostics.Stopwatch : object {
    private long _elapsed;
    private long _startTimeStamp;
    private bool _isRunning;
    public static long Frequency;
    public static bool IsHighResolution;
    private static double s_tickFrequency;
    public bool IsRunning { get; }
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    private static Stopwatch();
    public void Start();
    public static Stopwatch StartNew();
    public void Stop();
    public void Reset();
    public void Restart();
    public bool get_IsRunning();
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    public static long GetTimestamp();
    private long GetRawElapsedTicks();
    private long GetElapsedDateTimeTicks();
    private static bool QueryPerformanceFrequency(Int64& value);
    private static bool QueryPerformanceCounter(Int64& value);
}
[ExtensionAttribute]
public static class System.Environment : object {
    internal static bool IsMac;
    private static Func`2<string, IEnumerable`1<string>> s_fileReadLines;
    private static Func`2<string, object> s_directoryCreateDirectory;
    private static Lazy`1<OperatingSystem> s_osVersion;
    public static string CommandLine { get; }
    public static string CurrentDirectory { get; public set; }
    public static int CurrentManagedThreadId { get; }
    public static bool HasShutdownStarted { get; }
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static OperatingSystem OSVersion { get; }
    public static int ProcessorCount { get; }
    public static string StackTrace { get; }
    public static int TickCount { get; }
    public static bool UserInteractive { get; }
    public static Version Version { get; }
    public static long WorkingSet { get; }
    private static string CurrentDirectoryCore { get; private set; }
    public static int ExitCode { get; public set; }
    private static bool Is64BitOperatingSystemWhen32BitProcess { get; }
    public static string MachineName { get; }
    public static string NewLine { get; }
    public static string SystemDirectory { get; }
    public static int SystemPageSize { get; }
    public static string UserName { get; }
    public static string UserDomainName { get; }
    private static Environment();
    public static string GetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IDictionary GetEnvironmentVariables();
    public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    [ExtensionAttribute]
private static Hashtable ToHashtable(IEnumerable`1<KeyValuePair`2<string, string>> pairs);
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    public static string get_CommandLine();
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    public static int get_CurrentManagedThreadId();
    public static void Exit(int exitCode);
    public static void FailFast(string message);
    public static void FailFast(string message, Exception exception);
    public static string ExpandEnvironmentVariables(string name);
    public static String[] GetCommandLineArgs();
    public static string GetFolderPath(SpecialFolder folder);
    public static string GetFolderPath(SpecialFolder folder, SpecialFolderOption option);
    public static bool get_HasShutdownStarted();
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
    public static OperatingSystem get_OSVersion();
    public static int get_ProcessorCount();
    public static string get_StackTrace();
    public static int get_TickCount();
    public static bool get_UserInteractive();
    public static Version get_Version();
    public static long get_WorkingSet();
    private static string get_CurrentDirectoryCore();
    private static void set_CurrentDirectoryCore(string value);
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    private static string ExpandEnvironmentVariablesCore(string name);
    private static string GetFolderPathCore(SpecialFolder folder, SpecialFolderOption option);
    private static string GetFolderPathCoreWithoutValidation(SpecialFolder folder);
    private static string GetXdgConfig(string home);
    private static string ReadXdgDirectory(string homeDir, string key, string fallback);
    private static void SkipWhitespace(string line, Int32& pos);
    public static String[] GetLogicalDrives();
    private static bool get_Is64BitOperatingSystemWhen32BitProcess();
    public static string get_MachineName();
    public static string get_NewLine();
    private static OperatingSystem GetOperatingSystem(string release);
    private static int FindAndParseNextNumber(string text, Int32& pos);
    public static string get_SystemDirectory();
    public static int get_SystemPageSize();
    public static string get_UserName();
    private static bool TryGetUserNameFromPasswd(Byte* buf, int bufLen, String& path);
    public static string get_UserDomainName();
    private static int CheckedSysConf(SysConfName name);
}
public class System.IO.BufferedStream : Stream {
    private Stream _stream;
    private Byte[] _buffer;
    private int _bufferSize;
    private int _readPos;
    private int _readLen;
    private int _writePos;
    private Task`1<int> _lastSyncCompletedReadTask;
    private SemaphoreSlim _asyncActiveSemaphore;
    public Stream UnderlyingStream { get; }
    public int BufferSize { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedStream(Stream stream);
    public BufferedStream(Stream stream, int bufferSize);
    internal SemaphoreSlim LazyEnsureAsyncActiveSemaphoreInitialized();
    private void EnsureNotClosed();
    private void EnsureCanSeek();
    private void EnsureCanRead();
    private void EnsureCanWrite();
    private void EnsureShadowBufferAllocated();
    private void EnsureBufferAllocated();
    public Stream get_UnderlyingStream();
    public int get_BufferSize();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<FlushAsyncInternal>d__37")]
private Task FlushAsyncInternal(CancellationToken cancellationToken);
    private void FlushRead();
    private void ClearReadBufferBeforeWrite();
    private void FlushWrite();
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<FlushWriteAsync>d__41")]
private Task FlushWriteAsync(CancellationToken cancellationToken);
    private int ReadFromBuffer(Byte[] array, int offset, int count);
    private int ReadFromBuffer(Span`1<byte> destination);
    private int ReadFromBuffer(Byte[] array, int offset, int count, Exception& error);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int Read(Span`1<byte> destination);
    private Task`1<int> LastSyncCompletedReadTask(int val);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<ReadFromUnderlyingStreamAsync>d__50")]
private ValueTask`1<int> ReadFromUnderlyingStreamAsync(Memory`1<byte> buffer, CancellationToken cancellationToken, int bytesAlreadySatisfied, Task semaphoreLockTask);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int ReadByte();
    private int ReadByteSlow();
    private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count);
    private int WriteToBuffer(ReadOnlySpan`1<byte> buffer);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<WriteToUnderlyingStreamAsync>d__62")]
private Task WriteToUnderlyingStreamAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken, Task semaphoreLockTask);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<CopyToAsyncCore>d__70")]
private Task CopyToAsyncCore(Stream destination, int bufferSize, CancellationToken cancellationToken);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.InvalidDataException : SystemException {
    public InvalidDataException(string message);
    public InvalidDataException(string message, Exception innerException);
    private InvalidDataException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.PersistedFiles : object {
    internal static string GetHomeDirectory();
    private static bool TryGetHomeDirectoryFromPasswd(Byte* buf, int bufLen, String& path);
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize);
}
internal static class System.IO.StringBuilderCache : object {
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
public class System.IO.StringReader : TextReader {
    private string _s;
    private int _pos;
    private int _length;
    public StringReader(string s);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    public virtual int ReadBlock(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
}
public class System.IO.StringWriter : TextWriter {
    private static UnicodeEncoding modreq(System.Runtime.CompilerServices.IsVolatile) s_encoding;
    private StringBuilder _sb;
    private bool _isOpen;
    public Encoding Encoding { get; }
    public StringWriter(IFormatProvider formatProvider);
    public StringWriter(StringBuilder sb);
    public StringWriter(StringBuilder sb, IFormatProvider formatProvider);
    private static StringWriter();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_Encoding();
    public virtual StringBuilder GetStringBuilder();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(string value);
    public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task FlushAsync();
    public virtual string ToString();
}
public enum System.LoaderOptimization : Enum {
    public int value__;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DisallowBindings;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DomainMask;
    public static LoaderOptimization MultiDomain;
    public static LoaderOptimization MultiDomainHost;
    public static LoaderOptimization NotSpecified;
    public static LoaderOptimization SingleDomain;
}
[AttributeUsageAttribute("64")]
public class System.LoaderOptimizationAttribute : Attribute {
    private byte _val;
    public LoaderOptimization Value { get; }
    public LoaderOptimizationAttribute(byte value);
    public LoaderOptimizationAttribute(LoaderOptimization value);
    public LoaderOptimization get_Value();
}
public static class System.Net.WebUtility : object {
    private static Char[] s_htmlEntityEndingChars;
    private static WebUtility();
    public static string HtmlEncode(string value);
    public static void HtmlEncode(string value, TextWriter output);
    private static void HtmlEncode(string value, int index, StringBuilder output);
    public static string HtmlDecode(string value);
    public static void HtmlDecode(string value, TextWriter output);
    private static void HtmlDecode(string value, StringBuilder output);
    private static int IndexOfHtmlEncodingChars(string s, int startPos);
    private static void GetEncodedBytes(Byte[] originalBytes, int offset, int count, Byte[] expandedBytes);
    public static string UrlEncode(string value);
    public static Byte[] UrlEncodeToBytes(Byte[] value, int offset, int count);
    private static string UrlDecodeInternal(string value, Encoding encoding);
    private static Byte[] UrlDecodeInternal(Byte[] bytes, int offset, int count);
    public static string UrlDecode(string encodedValue);
    public static Byte[] UrlDecodeToBytes(Byte[] encodedValue, int offset, int count);
    private static void ConvertSmpToUtf16(UInt32 smpChar, Char& leadingSurrogate, Char& trailingSurrogate);
    private static int GetNextUnicodeScalarValueFromUtf16Surrogate(Char*& pch, Int32& charsRemaining);
    private static int HexToInt(char h);
    private static char IntToHex(int n);
    private static bool IsUrlSafeChar(char ch);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
    private static bool StringRequiresHtmlDecoding(string s);
}
public class System.OperatingSystem : object {
    private Version _version;
    private PlatformID _platform;
    private string _servicePack;
    private string _versionString;
    public PlatformID Platform { get; }
    public string ServicePack { get; }
    public Version Version { get; }
    public string VersionString { get; }
    public OperatingSystem(PlatformID platform, Version version);
    internal OperatingSystem(PlatformID platform, Version version, string servicePack);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public PlatformID get_Platform();
    public string get_ServicePack();
    public Version get_Version();
    public sealed virtual object Clone();
    public virtual string ToString();
    public string get_VersionString();
}
internal static class System.PasteArguments : object {
    internal static void AppendArgument(StringBuilder stringBuilder, string argument);
    private static bool ContainsNoWhitespaceOrQuotes(string s);
    internal static string Paste(IEnumerable`1<string> arguments, bool pasteFirstArgumentUsingArgV0Rules);
}
public enum System.PlatformID : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32S;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32Windows;
    public static PlatformID Win32NT;
    [EditorBrowsableAttribute("1")]
public static PlatformID WinCE;
    public static PlatformID Unix;
    [EditorBrowsableAttribute("1")]
public static PlatformID Xbox;
    [EditorBrowsableAttribute("1")]
public static PlatformID MacOSX;
}
public class System.Reflection.AssemblyNameProxy : MarshalByRefObject {
    public AssemblyName GetAssemblyName(string assemblyFile);
}
[AttributeUsageAttribute("5887")]
public class System.Runtime.Versioning.ComponentGuaranteesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ComponentGuaranteesOptions <Guarantees>k__BackingField;
    public ComponentGuaranteesOptions Guarantees { get; }
    public ComponentGuaranteesAttribute(ComponentGuaranteesOptions guarantees);
    [CompilerGeneratedAttribute]
public ComponentGuaranteesOptions get_Guarantees();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ComponentGuaranteesOptions : Enum {
    public int value__;
    public static ComponentGuaranteesOptions None;
    public static ComponentGuaranteesOptions Exchange;
    public static ComponentGuaranteesOptions Stable;
    public static ComponentGuaranteesOptions SideBySide;
}
public class System.Runtime.Versioning.FrameworkName : object {
    private string _identifier;
    private Version _version;
    private string _profile;
    private string _fullName;
    private static Char[] s_componentSplitSeparator;
    public string Identifier { get; }
    public Version Version { get; }
    public string Profile { get; }
    public string FullName { get; }
    public FrameworkName(string identifier, Version version);
    public FrameworkName(string identifier, Version version, string profile);
    public FrameworkName(string frameworkName);
    private static FrameworkName();
    public string get_Identifier();
    public Version get_Version();
    public string get_Profile();
    public string get_FullName();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FrameworkName other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(FrameworkName left, FrameworkName right);
    public static bool op_Inequality(FrameworkName left, FrameworkName right);
}
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
[AttributeUsageAttribute("224")]
public class System.Runtime.Versioning.ResourceConsumptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ResourceScope <ResourceScope>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceScope <ConsumptionScope>k__BackingField;
    public ResourceScope ResourceScope { get; }
    public ResourceScope ConsumptionScope { get; }
    public ResourceConsumptionAttribute(ResourceScope resourceScope);
    public ResourceConsumptionAttribute(ResourceScope resourceScope, ResourceScope consumptionScope);
    [CompilerGeneratedAttribute]
public ResourceScope get_ResourceScope();
    [CompilerGeneratedAttribute]
public ResourceScope get_ConsumptionScope();
}
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
[AttributeUsageAttribute("480")]
public class System.Runtime.Versioning.ResourceExposureAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ResourceScope <ResourceExposureLevel>k__BackingField;
    public ResourceScope ResourceExposureLevel { get; }
    public ResourceExposureAttribute(ResourceScope exposureLevel);
    [CompilerGeneratedAttribute]
public ResourceScope get_ResourceExposureLevel();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ResourceScope : Enum {
    public int value__;
    public static ResourceScope None;
    public static ResourceScope Machine;
    public static ResourceScope Process;
    public static ResourceScope AppDomain;
    public static ResourceScope Library;
    public static ResourceScope Private;
    public static ResourceScope Assembly;
}
[FlagsAttribute]
internal enum System.Runtime.Versioning.SxSRequirements : Enum {
    public int value__;
    public static SxSRequirements None;
    public static SxSRequirements AppDomainID;
    public static SxSRequirements ProcessID;
    public static SxSRequirements CLRInstanceID;
    public static SxSRequirements AssemblyName;
    public static SxSRequirements TypeName;
}
public static class System.Runtime.Versioning.VersioningHelper : object {
    public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to);
    public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type);
    private static string GetCLRInstanceString();
    private static SxSRequirements GetRequirements(ResourceScope consumeAsScope, ResourceScope calleeScope);
    private static int GetCurrentProcessId();
}
public interface System.Security.IPermission {
    public abstract virtual IPermission Copy();
    public abstract virtual void Demand();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public abstract virtual IPermission Union(IPermission target);
}
internal interface System.Security.ISecurityElementFactory {
    public abstract virtual SecurityElement CreateSecurityElement();
}
public interface System.Security.ISecurityEncodable {
    public abstract virtual void FromXml(SecurityElement e);
    public abstract virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.CodeAccessSecurityAttribute : SecurityAttribute {
    protected CodeAccessSecurityAttribute(SecurityAction action);
}
public enum System.Security.Permissions.SecurityAction : Enum {
    public int value__;
    public static SecurityAction Assert;
    public static SecurityAction Demand;
    [ObsoleteAttribute("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction Deny;
    public static SecurityAction InheritanceDemand;
    public static SecurityAction LinkDemand;
    public static SecurityAction PermitOnly;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestMinimum;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestOptional;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestRefuse;
}
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.SecurityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SecurityAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Unrestricted>k__BackingField;
    public SecurityAction Action { get; public set; }
    public bool Unrestricted { get; public set; }
    protected SecurityAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public SecurityAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(SecurityAction value);
    [CompilerGeneratedAttribute]
public bool get_Unrestricted();
    [CompilerGeneratedAttribute]
public void set_Unrestricted(bool value);
    public abstract virtual IPermission CreatePermission();
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.SecurityPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private bool <Assertion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BindingRedirects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlAppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlDomainPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlEvidence>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlPrincipal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlThread>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Execution>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityPermissionFlag <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Infrastructure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemotingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializationFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipVerification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnmanagedCode>k__BackingField;
    public bool Assertion { get; public set; }
    public bool BindingRedirects { get; public set; }
    public bool ControlAppDomain { get; public set; }
    public bool ControlDomainPolicy { get; public set; }
    public bool ControlEvidence { get; public set; }
    public bool ControlPolicy { get; public set; }
    public bool ControlPrincipal { get; public set; }
    public bool ControlThread { get; public set; }
    public bool Execution { get; public set; }
    public SecurityPermissionFlag Flags { get; public set; }
    public bool Infrastructure { get; public set; }
    public bool RemotingConfiguration { get; public set; }
    public bool SerializationFormatter { get; public set; }
    public bool SkipVerification { get; public set; }
    public bool UnmanagedCode { get; public set; }
    public SecurityPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_Assertion();
    [CompilerGeneratedAttribute]
public void set_Assertion(bool value);
    [CompilerGeneratedAttribute]
public bool get_BindingRedirects();
    [CompilerGeneratedAttribute]
public void set_BindingRedirects(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlAppDomain();
    [CompilerGeneratedAttribute]
public void set_ControlAppDomain(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlDomainPolicy();
    [CompilerGeneratedAttribute]
public void set_ControlDomainPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlEvidence();
    [CompilerGeneratedAttribute]
public void set_ControlEvidence(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlPolicy();
    [CompilerGeneratedAttribute]
public void set_ControlPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlPrincipal();
    [CompilerGeneratedAttribute]
public void set_ControlPrincipal(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlThread();
    [CompilerGeneratedAttribute]
public void set_ControlThread(bool value);
    [CompilerGeneratedAttribute]
public bool get_Execution();
    [CompilerGeneratedAttribute]
public void set_Execution(bool value);
    [CompilerGeneratedAttribute]
public SecurityPermissionFlag get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(SecurityPermissionFlag value);
    [CompilerGeneratedAttribute]
public bool get_Infrastructure();
    [CompilerGeneratedAttribute]
public void set_Infrastructure(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemotingConfiguration();
    [CompilerGeneratedAttribute]
public void set_RemotingConfiguration(bool value);
    [CompilerGeneratedAttribute]
public bool get_SerializationFormatter();
    [CompilerGeneratedAttribute]
public void set_SerializationFormatter(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipVerification();
    [CompilerGeneratedAttribute]
public void set_SkipVerification(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnmanagedCode();
    [CompilerGeneratedAttribute]
public void set_UnmanagedCode(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.SecurityPermissionFlag : Enum {
    public int value__;
    public static SecurityPermissionFlag AllFlags;
    public static SecurityPermissionFlag Assertion;
    public static SecurityPermissionFlag BindingRedirects;
    public static SecurityPermissionFlag ControlAppDomain;
    public static SecurityPermissionFlag ControlDomainPolicy;
    public static SecurityPermissionFlag ControlEvidence;
    public static SecurityPermissionFlag ControlPolicy;
    public static SecurityPermissionFlag ControlPrincipal;
    public static SecurityPermissionFlag ControlThread;
    public static SecurityPermissionFlag Execution;
    public static SecurityPermissionFlag Infrastructure;
    public static SecurityPermissionFlag NoFlags;
    public static SecurityPermissionFlag RemotingConfiguration;
    public static SecurityPermissionFlag SerializationFormatter;
    public static SecurityPermissionFlag SkipVerification;
    public static SecurityPermissionFlag UnmanagedCode;
}
public class System.Security.SecurityElement : object {
    internal string _tag;
    internal string _text;
    private ArrayList _children;
    internal ArrayList _attributes;
    private static Char[] s_tagIllegalCharacters;
    private static Char[] s_textIllegalCharacters;
    private static Char[] s_valueIllegalCharacters;
    private static Char[] s_escapeChars;
    private static String[] s_escapeStringPairs;
    public string Tag { get; public set; }
    public Hashtable Attributes { get; public set; }
    public string Text { get; public set; }
    public ArrayList Children { get; public set; }
    public SecurityElement(string tag);
    public SecurityElement(string tag, string text);
    private static SecurityElement();
    public string get_Tag();
    public void set_Tag(string value);
    public Hashtable get_Attributes();
    public void set_Attributes(Hashtable value);
    public string get_Text();
    public void set_Text(string value);
    public ArrayList get_Children();
    public void set_Children(ArrayList value);
    internal void ConvertSecurityElementFactories();
    internal void AddAttributeSafe(string name, string value);
    public void AddAttribute(string name, string value);
    public void AddChild(SecurityElement child);
    public bool Equal(SecurityElement other);
    public SecurityElement Copy();
    public static bool IsValidTag(string tag);
    public static bool IsValidText(string text);
    public static bool IsValidAttributeName(string name);
    public static bool IsValidAttributeValue(string value);
    private static string GetEscapeSequence(char c);
    public static string Escape(string str);
    private static string GetUnescapeSequence(string str, int index, Int32& newIndex);
    private static string Unescape(string str);
    public virtual string ToString();
    private void ToString(string indent, object obj, Action`2<object, string> write);
    public string Attribute(string name);
    public SecurityElement SearchForChildByTag(string tag);
    public string SearchForTextOfTag(string tag);
    public static SecurityElement FromString(string xml);
    private sealed virtual override SecurityElement System.Security.ISecurityElementFactory.CreateSecurityElement();
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string Argument_EmptyApplicationName { get; }
    internal static string Argument_FrameworkNameMissingVersion { get; }
    internal static string Argument_FrameworkNameInvalid { get; }
    internal static string Argument_FrameworkNameInvalidVersion { get; }
    internal static string Argument_FrameworkNameTooShort { get; }
    internal static string net_emptystringcall { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_FileLengthTooBig { get; }
    internal static string Argument_PathEmpty { get; }
    internal static string ArgumentOutOfRange_MustBePositive { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_FileNotFound { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Argument_BadResourceScopeTypeBits { get; }
    internal static string Argument_BadResourceScopeVisibilityBits { get; }
    internal static string ArgumentNull_TypeRequiredByResourceScope { get; }
    internal static string Argument_ResourceScopeWrongDirection { get; }
    internal static string AppDomain_Name { get; }
    internal static string AppDomain_NoContextPolicies { get; }
    internal static string Arg_MustBeTrue { get; }
    internal static string Arg_CannotUnloadAppDomainException { get; }
    internal static string Arg_AppDomainUnloadedException { get; }
    internal static string ZeroLengthString { get; }
    internal static string EntryPointNotFound { get; }
    internal static string NotSupported { get; }
    internal static string Arg_ContextMarshalException { get; }
    internal static string AppDomain_Policy_PrincipalTwice { get; }
    internal static string ArgumentNull_Array { get; }
    internal static string ArgumentNull_Collection { get; }
    internal static string ArgumentNull_Dictionary { get; }
    internal static string ArgumentNull_Key { get; }
    internal static string ArgumentOutOfRange_ArrayListInsert { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_HashtableLoadFactor { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegNum { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string Argument_AddingDuplicate__ { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Arg_CannotMixComparisonInfrastructure { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_HashInsertFailed { get; }
    internal static string InvalidOperation_UnderlyingArrayListChanged { get; }
    internal static string NotSupported_FixedSizeCollection { get; }
    internal static string NotSupported_RangeCollection { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string Serialization_InvalidOnDeser { get; }
    internal static string Serialization_KeyValueDifferentSizes { get; }
    internal static string Serialization_MissingKeys { get; }
    internal static string Serialization_MissingValues { get; }
    internal static string Serialization_NullKey { get; }
    internal static string Argument_ImplementIComparable { get; }
    internal static string GenericInvalidData { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string NotSupported_CannotWriteToBufferedStreamIfReadBufferCannotBeFlushed { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string ObjectDisposed_WriterClosed { get; }
    internal static string ObjectDisposed_ReaderClosed { get; }
    internal static string ArgumentNull_Child { get; }
    internal static string Argument_AttributeNamesMustBeUnique { get; }
    internal static string Argument_InvalidElementName { get; }
    internal static string Argument_InvalidElementTag { get; }
    internal static string Argument_InvalidElementText { get; }
    internal static string Argument_InvalidElementValue { get; }
    internal static string PlatformNotSupported_AppDomains { get; }
    internal static string PlatformNotSupported_CAS { get; }
    internal static string PlatformNotSupported_AppDomain_ResMon { get; }
    internal static string IO_PathTooLong_Path { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_Argument_EmptyApplicationName();
    internal static string get_Argument_FrameworkNameMissingVersion();
    internal static string get_Argument_FrameworkNameInvalid();
    internal static string get_Argument_FrameworkNameInvalidVersion();
    internal static string get_Argument_FrameworkNameTooShort();
    internal static string get_net_emptystringcall();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_FileLengthTooBig();
    internal static string get_Argument_PathEmpty();
    internal static string get_ArgumentOutOfRange_MustBePositive();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_FileNotFound();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_FileExists_Name();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Argument_BadResourceScopeTypeBits();
    internal static string get_Argument_BadResourceScopeVisibilityBits();
    internal static string get_ArgumentNull_TypeRequiredByResourceScope();
    internal static string get_Argument_ResourceScopeWrongDirection();
    internal static string get_AppDomain_Name();
    internal static string get_AppDomain_NoContextPolicies();
    internal static string get_Arg_MustBeTrue();
    internal static string get_Arg_CannotUnloadAppDomainException();
    internal static string get_Arg_AppDomainUnloadedException();
    internal static string get_ZeroLengthString();
    internal static string get_EntryPointNotFound();
    internal static string get_NotSupported();
    internal static string get_Arg_ContextMarshalException();
    internal static string get_AppDomain_Policy_PrincipalTwice();
    internal static string get_ArgumentNull_Array();
    internal static string get_ArgumentNull_Collection();
    internal static string get_ArgumentNull_Dictionary();
    internal static string get_ArgumentNull_Key();
    internal static string get_ArgumentOutOfRange_ArrayListInsert();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_HashtableLoadFactor();
    internal static string get_ArgumentOutOfRange_MustBeNonNegNum();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_Argument_AddingDuplicate__();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Arg_CannotMixComparisonInfrastructure();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_HashInsertFailed();
    internal static string get_InvalidOperation_UnderlyingArrayListChanged();
    internal static string get_NotSupported_FixedSizeCollection();
    internal static string get_NotSupported_RangeCollection();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_Serialization_InvalidOnDeser();
    internal static string get_Serialization_KeyValueDifferentSizes();
    internal static string get_Serialization_MissingKeys();
    internal static string get_Serialization_MissingValues();
    internal static string get_Serialization_NullKey();
    internal static string get_Argument_ImplementIComparable();
    internal static string get_GenericInvalidData();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_NotSupported_CannotWriteToBufferedStreamIfReadBufferCannotBeFlushed();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_ObjectDisposed_WriterClosed();
    internal static string get_ObjectDisposed_ReaderClosed();
    internal static string get_ArgumentNull_Child();
    internal static string get_Argument_AttributeNamesMustBeUnique();
    internal static string get_Argument_InvalidElementName();
    internal static string get_Argument_InvalidElementTag();
    internal static string get_Argument_InvalidElementText();
    internal static string get_Argument_InvalidElementValue();
    internal static string get_PlatformNotSupported_AppDomains();
    internal static string get_PlatformNotSupported_CAS();
    internal static string get_PlatformNotSupported_AppDomain_ResMon();
    internal static string get_IO_PathTooLong_Path();
}
[ExtensionAttribute]
public static class System.StringNormalizationExtensions : object {
    [ExtensionAttribute]
public static bool IsNormalized(string strInput);
    [ExtensionAttribute]
public static bool IsNormalized(string strInput, NormalizationForm normalizationForm);
    [ExtensionAttribute]
public static string Normalize(string strInput);
    [ExtensionAttribute]
public static string Normalize(string strInput, NormalizationForm normalizationForm);
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
