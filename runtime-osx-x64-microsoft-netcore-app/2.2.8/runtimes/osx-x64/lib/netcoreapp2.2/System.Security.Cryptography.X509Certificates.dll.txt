internal static class FxResources.System.Security.Cryptography.X509Certificates.SR : object {
}
internal static class Internal.Cryptography.AsymmetricAlgorithmHelpers : object {
    public static Byte[] ConvertIeee1363ToDer(ReadOnlySpan`1<byte> input);
    public static Byte[] ConvertDerToIeee1363(Byte[] input, int inputOffset, int inputCount, int fieldSizeBits);
    public static int BitsToBytes(int bitLength);
    private static void CopySignatureField(Byte[] signatureField, Byte[] response, int offset, int fieldLength);
    public static Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public static Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    private static HashAlgorithm GetHashAlgorithm(HashAlgorithmName hashAlgorithmName);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.EncodingHelpers : object {
    [ExtensionAttribute]
internal static Byte[][] WrapAsSegmentedForSequence(Byte[] derData);
    internal static void ValidateSignatureAlgorithm(Byte[] signatureAlgorithm);
    [ExtensionAttribute]
internal static Byte[][] SegmentedEncodeSubjectPublicKeyInfo(PublicKey publicKey);
    [ExtensionAttribute]
internal static Byte[][] SegmentedEncodedX509Extension(X509Extension extension);
    [ExtensionAttribute]
internal static Byte[][] SegmentedEncodeAttributeSet(IEnumerable`1<X501Attribute> attributes);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    [ExtensionAttribute]
public static Char[] ToHexArrayUpper(Byte[] bytes);
    [ExtensionAttribute]
public static string ToHexStringUpper(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] DecodeHexString(string s);
    private static byte HexToByte(char val);
    private static char NibbleToHex(byte b);
    [ExtensionAttribute]
public static bool ContentsEqual(Byte[] a1, Byte[] a2);
    [ExtensionAttribute]
internal static void AddRange(ICollection`1<T> coll, IEnumerable`1<T> newData);
    [ExtensionAttribute]
public static bool IsValidDay(Calendar calendar, int year, int month, int day, int era);
    [ExtensionAttribute]
private static bool IsValidMonth(Calendar calendar, int year, int month, int era);
    [ExtensionAttribute]
private static bool IsValidYear(Calendar calendar, int year, int era);
}
internal interface Internal.Cryptography.ICertificatePal {
    public bool HasPrivateKey { get; }
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    public abstract virtual bool get_HasPrivateKey();
    public abstract virtual IntPtr get_Handle();
    public abstract virtual string get_Issuer();
    public abstract virtual string get_Subject();
    public abstract virtual Byte[] get_Thumbprint();
    public abstract virtual string get_KeyAlgorithm();
    public abstract virtual Byte[] get_KeyAlgorithmParameters();
    public abstract virtual Byte[] get_PublicKeyValue();
    public abstract virtual Byte[] get_SerialNumber();
    public abstract virtual string get_SignatureAlgorithm();
    public abstract virtual DateTime get_NotAfter();
    public abstract virtual DateTime get_NotBefore();
    public abstract virtual Byte[] get_RawData();
    public abstract virtual int get_Version();
    public abstract virtual bool get_Archived();
    public abstract virtual void set_Archived(bool value);
    public abstract virtual string get_FriendlyName();
    public abstract virtual void set_FriendlyName(string value);
    public abstract virtual X500DistinguishedName get_SubjectName();
    public abstract virtual X500DistinguishedName get_IssuerName();
    public abstract virtual IEnumerable`1<X509Extension> get_Extensions();
    public abstract virtual RSA GetRSAPrivateKey();
    public abstract virtual DSA GetDSAPrivateKey();
    public abstract virtual ECDsa GetECDsaPrivateKey();
    public abstract virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public abstract virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public abstract virtual ICertificatePal CopyWithPrivateKey(DSA privateKey);
    public abstract virtual ICertificatePal CopyWithPrivateKey(ECDsa privateKey);
    public abstract virtual ICertificatePal CopyWithPrivateKey(RSA privateKey);
}
internal class Internal.Cryptography.Pal.AppleCertificatePal : object {
    private SafeSecIdentityHandle _identityHandle;
    private SafeSecCertificateHandle _certHandle;
    private CertificateData _certData;
    private bool _readCertData;
    internal SafeSecCertificateHandle CertificateHandle { get; }
    internal SafeSecIdentityHandle IdentityHandle { get; }
    public bool HasPrivateKey { get; }
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public string FriendlyName { get; public set; }
    public int Version { get; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    public Byte[] RawData { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] Thumbprint { get; }
    public bool Archived { get; public set; }
    public Byte[] SubjectPublicKeyInfo { get; }
    internal AppleCertificatePal(SafeSecCertificateHandle certHandle);
    internal AppleCertificatePal(SafeSecIdentityHandle identityHandle);
    public sealed virtual void Dispose();
    internal SafeSecCertificateHandle get_CertificateHandle();
    internal SafeSecIdentityHandle get_IdentityHandle();
    public sealed virtual bool get_HasPrivateKey();
    public sealed virtual IntPtr get_Handle();
    public sealed virtual string get_Issuer();
    public sealed virtual string get_Subject();
    public sealed virtual string get_KeyAlgorithm();
    public sealed virtual Byte[] get_KeyAlgorithmParameters();
    public sealed virtual Byte[] get_PublicKeyValue();
    public sealed virtual Byte[] get_SerialNumber();
    public sealed virtual string get_SignatureAlgorithm();
    public sealed virtual string get_FriendlyName();
    public sealed virtual void set_FriendlyName(string value);
    public sealed virtual int get_Version();
    public sealed virtual X500DistinguishedName get_SubjectName();
    public sealed virtual X500DistinguishedName get_IssuerName();
    public sealed virtual IEnumerable`1<X509Extension> get_Extensions();
    public sealed virtual Byte[] get_RawData();
    public sealed virtual DateTime get_NotAfter();
    public sealed virtual DateTime get_NotBefore();
    public sealed virtual Byte[] get_Thumbprint();
    public sealed virtual bool get_Archived();
    public sealed virtual void set_Archived(bool value);
    public Byte[] get_SubjectPublicKeyInfo();
    public sealed virtual RSA GetRSAPrivateKey();
    public sealed virtual DSA GetDSAPrivateKey();
    public sealed virtual ECDsa GetECDsaPrivateKey();
    public sealed virtual ICertificatePal CopyWithPrivateKey(DSA privateKey);
    public sealed virtual ICertificatePal CopyWithPrivateKey(ECDsa privateKey);
    public sealed virtual ICertificatePal CopyWithPrivateKey(RSA privateKey);
    private ICertificatePal CopyWithPrivateKey(SecKeyPair keyPair);
    public sealed virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    private static string GetSimpleNameInfo(X500DistinguishedName name);
    private static string FindAltNameMatch(Byte[] extensionBytes, GeneralNameType matchType, string otherOid);
    public sealed virtual void AppendPrivateKeyInfo(StringBuilder sb);
    private void EnsureCertData();
    [IteratorStateMachineAttribute("Internal.Cryptography.Pal.AppleCertificatePal/<ReadReverseRdns>d__65")]
private static IEnumerable`1<KeyValuePair`2<string, string>> ReadReverseRdns(X500DistinguishedName name);
}
internal class Internal.Cryptography.Pal.CertificateData : ValueType {
    internal Byte[] RawData;
    internal Byte[] SubjectPublicKeyInfo;
    internal int Version;
    internal Byte[] SerialNumber;
    internal AlgorithmIdentifier TbsSignature;
    internal X500DistinguishedName Issuer;
    internal DateTime NotBefore;
    internal DateTime NotAfter;
    internal X500DistinguishedName Subject;
    internal AlgorithmIdentifier PublicKeyAlgorithm;
    internal Byte[] PublicKey;
    internal Byte[] IssuerUniqueId;
    internal Byte[] SubjectUniqueId;
    internal List`1<X509Extension> Extensions;
    internal AlgorithmIdentifier SignatureAlgorithm;
    internal Byte[] SignatureValue;
    internal CertificateData(Byte[] rawData);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.CertificateExtensionsCommon : object {
    [ExtensionAttribute]
public static T GetPublicKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    [ExtensionAttribute]
public static T GetPrivateKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    private static string GetExpectedOidValue();
}
internal class Internal.Cryptography.Pal.CertificatePal : object {
    public static ICertificatePal FromHandle(IntPtr handle);
    internal static ICertificatePal FromHandle(IntPtr handle, bool throwOnFail);
    public static ICertificatePal FromOtherCert(X509Certificate cert);
    public static ICertificatePal FromBlob(Byte[] rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public static ICertificatePal FromFile(string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
}
internal class Internal.Cryptography.Pal.CertificatePolicy : object {
    [CompilerGeneratedAttribute]
private bool <ImplicitAnyCertificatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpecifiedAnyCertificatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <DeclaredCertificatePolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImplicitAnyApplicationPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpecifiedAnyApplicationPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <DeclaredApplicationPolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <InhibitAnyDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CertificatePolicyMapping> <PolicyMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <InhibitMappingDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RequireExplicitPolicyDepth>k__BackingField;
    public bool ImplicitAnyCertificatePolicy { get; public set; }
    public bool SpecifiedAnyCertificatePolicy { get; public set; }
    public ISet`1<string> DeclaredCertificatePolicies { get; public set; }
    public bool ImplicitAnyApplicationPolicy { get; public set; }
    public bool SpecifiedAnyApplicationPolicy { get; public set; }
    public ISet`1<string> DeclaredApplicationPolicies { get; public set; }
    public Nullable`1<int> InhibitAnyDepth { get; public set; }
    public List`1<CertificatePolicyMapping> PolicyMapping { get; public set; }
    public Nullable`1<int> InhibitMappingDepth { get; public set; }
    public Nullable`1<int> RequireExplicitPolicyDepth { get; public set; }
    public bool AllowsAnyCertificatePolicy { get; }
    public bool AllowsAnyApplicationPolicy { get; }
    [CompilerGeneratedAttribute]
public bool get_ImplicitAnyCertificatePolicy();
    [CompilerGeneratedAttribute]
public void set_ImplicitAnyCertificatePolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpecifiedAnyCertificatePolicy();
    [CompilerGeneratedAttribute]
public void set_SpecifiedAnyCertificatePolicy(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_DeclaredCertificatePolicies();
    [CompilerGeneratedAttribute]
public void set_DeclaredCertificatePolicies(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ImplicitAnyApplicationPolicy();
    [CompilerGeneratedAttribute]
public void set_ImplicitAnyApplicationPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpecifiedAnyApplicationPolicy();
    [CompilerGeneratedAttribute]
public void set_SpecifiedAnyApplicationPolicy(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_DeclaredApplicationPolicies();
    [CompilerGeneratedAttribute]
public void set_DeclaredApplicationPolicies(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_InhibitAnyDepth();
    [CompilerGeneratedAttribute]
public void set_InhibitAnyDepth(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<CertificatePolicyMapping> get_PolicyMapping();
    [CompilerGeneratedAttribute]
public void set_PolicyMapping(List`1<CertificatePolicyMapping> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_InhibitMappingDepth();
    [CompilerGeneratedAttribute]
public void set_InhibitMappingDepth(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RequireExplicitPolicyDepth();
    [CompilerGeneratedAttribute]
public void set_RequireExplicitPolicyDepth(Nullable`1<int> value);
    public bool get_AllowsAnyCertificatePolicy();
    public bool get_AllowsAnyApplicationPolicy();
}
internal class Internal.Cryptography.Pal.CertificatePolicyChain : object {
    private CertificatePolicy[] _policies;
    private bool _failAllCertificatePolicies;
    public CertificatePolicyChain(List`1<X509Certificate2> chain);
    internal bool MatchesCertificatePolicies(OidCollection policyOids);
    internal bool MatchesCertificatePolicies(Oid policyOid);
    internal bool MatchesApplicationPolicies(OidCollection policyOids);
    internal bool MatchesApplicationPolicies(Oid policyOid);
    private void ReadPolicies(List`1<X509Certificate2> chain);
    private static void ApplyRestriction(Int32& restriction, Nullable`1<int> policyRestriction);
    private static CertificatePolicy ReadPolicy(X509Certificate2 cert);
    private static bool CheckExplicitAnyPolicy(ISet`1<string> declaredPolicies);
    private static int ReadInhibitAnyPolicyExtension(X509Extension extension);
    private static void ReadCertPolicyConstraintsExtension(X509Extension extension, CertificatePolicy policy);
    private static ISet`1<string> ReadExtendedKeyUsageExtension(X509Extension extension);
    internal static ISet`1<string> ReadCertPolicyExtension(X509Extension extension);
    private static List`1<CertificatePolicyMapping> ReadCertPolicyMappingsExtension(X509Extension extension);
}
internal class Internal.Cryptography.Pal.CertificatePolicyMapping : ValueType {
    public string IssuerDomainPolicy;
    public string SubjectDomainPolicy;
}
internal class Internal.Cryptography.Pal.ChainPal : object {
    public static IChainPal FromHandle(IntPtr chainContext);
    public static bool ReleaseSafeX509ChainHandle(IntPtr handle);
    public static IChainPal BuildChain(bool useMachineContext, ICertificatePal cert, X509Certificate2Collection extraStore, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, DateTime verificationTime, TimeSpan timeout);
}
internal static class Internal.Cryptography.Pal.ChainVerifier : object {
    public static bool Verify(X509ChainElement[] chainElements, X509VerificationFlags flags);
    private static bool HasUnsuppressedError(X509VerificationFlags flags, X509ChainElement element, bool isEndEntity);
    private static bool IsSelfSigned(X509Certificate2 cert);
    private static Nullable`1<X509VerificationFlags> GetSuppressionFlag(X509ChainStatusFlags status);
}
internal class Internal.Cryptography.Pal.FindPal : object {
    private static Dictionary`2<string, X509KeyUsageFlags> s_keyUsages;
    private static FindPal();
    public static X509Certificate2Collection FindFromCollection(X509Certificate2Collection coll, X509FindType findType, object findValue, bool validOnly);
    private static T ConfirmedCast(object findValue);
    private static string ConfirmedOidValue(IFindPal findPal, object findValue, OidGroup oidGroup);
    private static X509KeyUsageFlags ConfirmedX509KeyUsage(object findValue);
    internal static void ValidateOidValue(string keyValue);
    internal static BigInteger PositiveBigIntegerFromByteArray(Byte[] bytes);
    private static BigInteger LaxParseDecimalBigInteger(string decimalString);
    internal static IFindPal OpenPal(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
}
internal enum Internal.Cryptography.Pal.GeneralNameType : Enum {
    public int value__;
    public static GeneralNameType OtherName;
    public static GeneralNameType Rfc822Name;
    public static GeneralNameType Email;
    public static GeneralNameType DnsName;
    public static GeneralNameType X400Address;
    public static GeneralNameType DirectoryName;
    public static GeneralNameType EdiPartyName;
    public static GeneralNameType UniformResourceIdentifier;
    public static GeneralNameType IPAddress;
    public static GeneralNameType RegisteredId;
}
internal interface Internal.Cryptography.Pal.IChainPal {
    public X509ChainElement[] ChainElements { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public abstract virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    public abstract virtual X509ChainElement[] get_ChainElements();
    public abstract virtual X509ChainStatus[] get_ChainStatus();
    public abstract virtual SafeX509ChainHandle get_SafeHandle();
}
internal interface Internal.Cryptography.Pal.IExportPal {
    public abstract virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
}
internal interface Internal.Cryptography.Pal.IFindPal {
    public abstract virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public abstract virtual void FindByThumbprint(Byte[] thumbprint);
    public abstract virtual void FindBySubjectName(string subjectName);
    public abstract virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public abstract virtual void FindByIssuerName(string issuerName);
    public abstract virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public abstract virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    public abstract virtual void FindByTimeValid(DateTime dateTime);
    public abstract virtual void FindByTimeNotYetValid(DateTime dateTime);
    public abstract virtual void FindByTimeExpired(DateTime dateTime);
    public abstract virtual void FindByTemplateName(string templateName);
    public abstract virtual void FindByApplicationPolicy(string oidValue);
    public abstract virtual void FindByCertificatePolicy(string oidValue);
    public abstract virtual void FindByExtension(string oidValue);
    public abstract virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    public abstract virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
}
internal interface Internal.Cryptography.Pal.ILoaderPal {
    public abstract virtual void MoveTo(X509Certificate2Collection collection);
}
internal interface Internal.Cryptography.Pal.IStorePal {
    public SafeHandle SafeHandle { get; }
    public abstract virtual void CloneTo(X509Certificate2Collection collection);
    public abstract virtual void Add(ICertificatePal cert);
    public abstract virtual void Remove(ICertificatePal cert);
    public abstract virtual SafeHandle get_SafeHandle();
}
internal interface Internal.Cryptography.Pal.IX509Pal {
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    public abstract virtual AsymmetricAlgorithm DecodePublicKey(Oid oid, Byte[] encodedKeyValue, Byte[] encodedParameters, ICertificatePal certificatePal);
    public abstract virtual string X500DistinguishedNameDecode(Byte[] encodedDistinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual Byte[] X500DistinguishedNameEncode(string distinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual string X500DistinguishedNameFormat(Byte[] encodedDistinguishedName, bool multiLine);
    public abstract virtual X509ContentType GetCertContentType(Byte[] rawData);
    public abstract virtual X509ContentType GetCertContentType(string fileName);
    public abstract virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public abstract virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public abstract virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public abstract virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public abstract virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public abstract virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier);
    public abstract virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    public abstract virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
}
internal abstract class Internal.Cryptography.Pal.ManagedCertificateFinder : object {
    private X509Certificate2Collection _findFrom;
    private X509Certificate2Collection _copyTo;
    private bool _validOnly;
    internal ManagedCertificateFinder(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
    public sealed virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public sealed virtual void FindByThumbprint(Byte[] thumbprint);
    public sealed virtual void FindBySubjectName(string subjectName);
    public sealed virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public sealed virtual void FindByIssuerName(string issuerName);
    public sealed virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public sealed virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    private static DateTime NormalizeDateTime(DateTime dateTime);
    public sealed virtual void FindByTimeValid(DateTime dateTime);
    public sealed virtual void FindByTimeNotYetValid(DateTime dateTime);
    public sealed virtual void FindByTimeExpired(DateTime dateTime);
    private string DerStringToManagedString(Byte[] anyString);
    public sealed virtual void FindByTemplateName(string templateName);
    public sealed virtual void FindByApplicationPolicy(string oidValue);
    public sealed virtual void FindByCertificatePolicy(string oidValue);
    public sealed virtual void FindByExtension(string oidValue);
    public sealed virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    protected abstract virtual Byte[] GetSubjectPublicKeyInfo(X509Certificate2 cert);
    public sealed virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static X509Extension FindExtension(X509Certificate2 cert, string extensionOid);
    protected abstract virtual X509Certificate2 CloneCertificate(X509Certificate2 cert);
    private void FindCore(Predicate`1<X509Certificate2> predicate);
    private static bool IsCertValid(X509Certificate2 cert);
}
internal class Internal.Cryptography.Pal.ManagedX509ExtensionProcessor : object {
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    public virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier);
    public virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    internal static Byte[] DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded);
    public virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
    private static Byte[] ConcatenateArrays(Byte[][] segments);
}
internal class Internal.Cryptography.Pal.SecTrustChainPal : object {
    private Stack`1<SafeHandle> _extraHandles;
    private SafeX509ChainHandle _chainHandle;
    [CompilerGeneratedAttribute]
private X509ChainElement[] <ChainElements>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainStatus[] <ChainStatus>k__BackingField;
    private DateTime _verificationTime;
    private X509RevocationMode _revocationMode;
    public X509ChainElement[] ChainElements { get; private set; }
    public X509ChainStatus[] ChainStatus { get; private set; }
    public SafeX509ChainHandle SafeHandle { get; }
    [CompilerGeneratedAttribute]
public sealed virtual X509ChainElement[] get_ChainElements();
    [CompilerGeneratedAttribute]
private void set_ChainElements(X509ChainElement[] value);
    [CompilerGeneratedAttribute]
public sealed virtual X509ChainStatus[] get_ChainStatus();
    [CompilerGeneratedAttribute]
private void set_ChainStatus(X509ChainStatus[] value);
    public sealed virtual SafeX509ChainHandle get_SafeHandle();
    internal void OpenTrustHandle(ICertificatePal leafCert, X509Certificate2Collection extraStore, X509RevocationMode revocationMode);
    public sealed virtual void Dispose();
    public sealed virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    private SafeCreateHandle PreparePoliciesArray(bool checkRevocation);
    private SafeCreateHandle PrepareCertsArray(ICertificatePal cert, X509Certificate2Collection extraStore);
    internal void Execute(DateTime verificationTime, bool allowNetwork, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationFlag revocationFlag);
    private static Tuple`2[] ParseResults(SafeX509ChainHandle chainHandle, X509RevocationMode revocationMode);
    private bool IsPolicyMatch(Tuple`2[] elements, OidCollection applicationPolicy, OidCollection certificatePolicy);
    private void BuildAndSetProperties(Tuple`2[] elementTuples);
    private static void FixupRevocationStatus(Tuple`2[] elements, X509RevocationFlag revocationFlag);
    private static void FixupStatus(X509Certificate2 cert, X509RevocationMode revocationMode, Int32& dwStatus);
    private static X509ChainStatusFlags FindUntrustedRootReason(X509Certificate2 cert);
    private X509ChainElement BuildElement(X509Certificate2 cert, int dwStatus);
}
internal class Internal.Cryptography.Pal.StorePal : object {
    public static IStorePal FromHandle(IntPtr storeHandle);
    public static ILoaderPal FromBlob(Byte[] rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public static ILoaderPal FromFile(string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public static IExportPal FromCertificate(ICertificatePal cert);
    public static IExportPal LinkFromCertificateCollection(X509Certificate2Collection certificates);
    public static IStorePal FromSystemStore(string storeName, StoreLocation storeLocation, OpenFlags openFlags);
    private static void ReadCollection(SafeCFArrayHandle matches, HashSet`1<X509Certificate2> collection);
}
internal static class Internal.Cryptography.Pal.X500NameEncoder : object {
    private static Char[] s_quoteNeedingChars;
    private static List`1<char> s_useSemicolonSeparators;
    private static List`1<char> s_useCommaSeparators;
    private static List`1<char> s_useNewlineSeparators;
    private static List`1<char> s_defaultSeparators;
    private static X500NameEncoder();
    internal static string X500DistinguishedNameDecode(Byte[] encodedName, bool printOid, X500DistinguishedNameFlags flags, bool addTrailingDelimiter);
    internal static Byte[] X500DistinguishedNameEncode(string stringForm, X500DistinguishedNameFlags flags);
    private static bool NeedsQuoting(string rdnValue);
    private static bool IsQuotableWhitespace(char c);
    private static void AppendOid(StringBuilder decodedName, string oidValue);
    private static List`1<Byte[][]> ParseDistinguishedName(string stringForm, List`1<char> dnSeparators, bool noQuotes);
    private static Oid ParseOid(string stringForm, int tagStart, int tagEnd);
    private static Byte[][] ParseRdn(Oid tagOid, Char[] chars, int valueStart, int valueEnd, bool hadEscapedQuote);
    private static Byte[][] ParseRdn(Byte[][] encodedOid, Char[] chars, int valueStart, int valueEnd, bool ia5String);
    private static Byte[][] ParseRdn(Byte[][] encodedOid, Char[] value, bool ia5String);
    private static Char[] ExtractValue(Char[] chars, int valueStart, int valueEnd);
    private static string X500DistinguishedNameDecode(Byte[] encodedName, bool printOid, bool reverse, bool quoteIfNeeded, string dnSeparator, string multiValueSeparator, bool addTrailingDelimiter);
    private static string ReadString(DerSequenceReader tavReader);
}
internal class Internal.Cryptography.Pal.X509Pal : object {
    public static IX509Pal Instance;
    private static X509Pal();
}
internal class Internal.Cryptography.PinAndClear : ValueType {
    private Byte[] _data;
    private GCHandle _gcHandle;
    internal static PinAndClear Track(Byte[] data);
    public sealed virtual void Dispose();
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeCFArrayHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeCFDataHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeCFDateHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeCFErrorHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeCFStringHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeCreateHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
internal class Microsoft.Win32.SafeHandles.SafePasswordHandle : SafeHandle {
    public bool IsInvalid { get; }
    public static SafePasswordHandle InvalidHandle { get; }
    public SafePasswordHandle(string password);
    public SafePasswordHandle(SecureString password);
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_IsInvalid();
    public static SafePasswordHandle get_InvalidHandle();
    private IntPtr CreateHandle(string password);
    private IntPtr CreateHandle(SecureString password);
    private void FreeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeX509ChainHandle InvalidHandle { get; }
    internal static SafeX509ChainHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
}
internal class System.Security.Cryptography.Apple.SafeKeychainHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeKeychainHandle(IntPtr handle);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class System.Security.Cryptography.Apple.SafeKeychainItemHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class System.Security.Cryptography.Apple.SafeSecKeyRefHandle : SafeKeychainItemHandle {
}
internal class System.Security.Cryptography.Apple.SafeTemporaryKeychainHandle : SafeKeychainHandle {
    private static Dictionary`2<IntPtr, SafeTemporaryKeychainHandle> s_lookup;
    public static SafeTemporaryKeychainHandle InvalidHandle { get; }
    private static SafeTemporaryKeychainHandle();
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
    public static SafeTemporaryKeychainHandle get_InvalidHandle();
    internal static void TrackKeychain(SafeTemporaryKeychainHandle toTrack);
    internal static void TrackItem(SafeKeychainItemHandle keychainItem);
    internal static void UntrackItem(IntPtr keychainItem);
}
internal static class System.Security.Cryptography.DerEncoder : object {
    private static Byte[][] s_nullTlv;
    private static DerEncoder();
    private static Byte[] EncodeLength(int length);
    internal static Byte[][] SegmentedEncodeBoolean(bool value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(UInt32 value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(ReadOnlySpan`1<byte> bigEndianBytes);
    internal static Byte[][] SegmentedEncodeBitString(Byte[][][] childSegments);
    internal static Byte[][] SegmentedEncodeBitString(Byte[] data);
    internal static Byte[][] SegmentedEncodeBitString(int unusedBits, Byte[] data);
    internal static Byte[][] SegmentedEncodeNamedBitList(Byte[] bigEndianBytes, int namedBitsCount);
    internal static Byte[][] SegmentedEncodeOctetString(Byte[] data);
    internal static Byte[][] SegmentedEncodeNull();
    internal static Byte[] EncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeOid(Oid oid);
    internal static Byte[][] SegmentedEncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars, int offset, int count);
    internal static Byte[][] ConstructSegmentedSequence(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSequence(IEnumerable`1<Byte[][]> items);
    internal static Byte[][] ConstructSegmentedContextSpecificValue(int contextId, Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSet(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedPresortedSet(Byte[][][] items);
    internal static bool IsValidPrintableString(Char[] chars);
    internal static bool IsValidPrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeUtcTime(DateTime utcTime);
    internal static Byte[][] SegmentedEncodeGeneralizedTime(DateTime utcTime);
    internal static Byte[] ConstructSequence(Byte[][][] items);
    internal static Byte[] ConstructSequence(IEnumerable`1<Byte[][]> items);
    private static BigInteger ParseOidRid(string oidValue, Int32& startIndex);
    private static int AtoI(char c);
    private static void EncodeRid(List`1<byte> encodedData, BigInteger& rid);
    private static bool IsPrintableStringCharacter(char c);
    private static Byte[] ConcatenateArrays(Byte[][][] segments);
    private static Byte[] ConcatenateArrays(IEnumerable`1<Byte[][]> segments);
}
internal class System.Security.Cryptography.DerSequenceReader : object {
    internal static DateTimeFormatInfo s_validityDateTimeFormatInfo;
    private static Encoding s_utf8EncodingWithExceptionFallback;
    private static Encoding s_latin1Encoding;
    private Byte[] _data;
    private int _end;
    private int _position;
    [CompilerGeneratedAttribute]
private int <ContentLength>k__BackingField;
    unknown int ContentLength {private set; }
    internal bool HasData { get; }
    private DerSequenceReader(bool startAtPayload, Byte[] data, int offset, int length);
    internal DerSequenceReader(Byte[] data);
    internal DerSequenceReader(Byte[] data, int offset, int length);
    private DerSequenceReader(DerTag tagToEat, Byte[] data, int offset, int length);
    [CompilerGeneratedAttribute]
private void set_ContentLength(int value);
    internal static DerSequenceReader CreateForPayload(Byte[] payload);
    internal bool get_HasData();
    internal byte PeekTag();
    internal void SkipValue();
    internal void ValidateAndSkipDerValue();
    internal Byte[] ReadNextEncodedValue();
    internal bool ReadBoolean();
    internal int ReadInteger();
    internal Byte[] ReadIntegerBytes();
    internal Byte[] ReadBitString();
    internal Byte[] ReadOctetString();
    internal string ReadOidAsString();
    internal Oid ReadOid();
    internal string ReadUtf8String();
    private DerSequenceReader ReadCollectionWithTag(DerTag expected);
    internal DerSequenceReader ReadSequence();
    internal DerSequenceReader ReadSet();
    internal string ReadPrintableString();
    internal string ReadIA5String();
    internal string ReadT61String();
    internal DateTime ReadX509Date();
    internal DateTime ReadUtcTime();
    internal DateTime ReadGeneralizedTime();
    internal string ReadBMPString();
    private static string TrimTrailingNulls(string value);
    private DateTime ReadTime(DerTag timeTag, string formatString);
    private Byte[] ReadContentAsBytes();
    private void EatTag(DerTag expected);
    private static void CheckTag(DerTag expected, Byte[] data, int position);
    private int EatLength();
    private static int ScanContentLength(Byte[] data, int offset, int end, Int32& bytesConsumed);
}
internal static class System.Security.Cryptography.DSAImplementation : object {
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.DsaKeyBlobHelpers : object {
    private static Oid s_idDsa;
    private static DsaKeyBlobHelpers();
    [ExtensionAttribute]
internal static void ReadSubjectPublicKeyInfo(DerSequenceReader keyInfo, DSAParameters& parameters);
    [ExtensionAttribute]
internal static void ReadSubjectPublicKeyInfo(DerSequenceReader algParameters, Byte[] publicKeyBlob, DSAParameters& parameters);
    [ExtensionAttribute]
internal static Byte[] ToSubjectPublicKeyInfo(DSAParameters parameters);
    [ExtensionAttribute]
internal static void ReadPkcs8Blob(DerSequenceReader reader, DSAParameters& parameters);
    [ExtensionAttribute]
internal static Byte[] ToPrivateKeyBlob(DSAParameters parameters);
}
internal class System.Security.Cryptography.EccSecurityTransforms : object {
    private SecKeyPair _keys;
    public sealed virtual void Dispose();
    internal int GenerateKey(ECCurve curve);
    private SecKeyPair GenerateKey(int keySizeInBits);
    internal SecKeyPair GetOrGenerateKeys(int keySizeInBits);
    internal int SetKeyAndGetSize(SecKeyPair keyPair);
    private void SetKey(SecKeyPair keyPair);
    internal ECParameters ExportParameters(bool includePrivateParameters, int keySizeInBIts);
    public int ImportParameters(ECParameters parameters);
    private static int GetKeySize(SecKeyPair newKeys);
    private static SafeSecKeyRefHandle ImportKey(ECParameters parameters);
}
internal static class System.Security.Cryptography.ECDsaImplementation : object {
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.EcKeyBlobHelpers : object {
    private static Byte[] s_version1;
    private static Byte[][] s_encodedVersion1;
    private static Oid s_idEcPublicKey;
    private static Byte[][] s_encodedIdEcPublicKey;
    private static EcKeyBlobHelpers();
    [ExtensionAttribute]
internal static void ReadPkcs8Blob(DerSequenceReader reader, ECParameters& parameters);
    [ExtensionAttribute]
internal static void ReadSubjectPublicKeyInfo(DerSequenceReader keyInfo, ECParameters& parameters);
    [ExtensionAttribute]
internal static Byte[] ToSubjectPublicKeyInfo(ECParameters parameters);
    private static Byte[] GetPointBlob(ECParameters& parameters);
    [ExtensionAttribute]
internal static Byte[] ToPrivateKeyBlob(ECParameters parameters);
    private static void ReadEncodedPoint(Byte[] encodedPoint, ECParameters& parameters);
}
internal static class System.Security.Cryptography.KeyBlobHelpers : object {
    internal static Byte[] TrimPaddingByte(Byte[] data);
    internal static void TrimPaddingByte(Byte[]& data);
    internal static Byte[] PadOrTrim(Byte[] data, int length);
    internal static void PadOrTrim(Byte[]& data, int length);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeySizeHelpers : object {
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes);
}
internal static class System.Security.Cryptography.RSAImplementation : object {
    private static Exception HashAlgorithmNameNullOrEmpty();
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.RsaKeyBlobHelpers : object {
    private static Byte[] s_versionNumberBytes;
    private static Byte[][] s_encodedRsaAlgorithmIdentifier;
    private static RsaKeyBlobHelpers();
    [ExtensionAttribute]
internal static Byte[] ToPkcs1Blob(RSAParameters parameters);
    [ExtensionAttribute]
internal static void ReadPkcs8Blob(DerSequenceReader reader, RSAParameters& parameters);
    [ExtensionAttribute]
internal static Byte[] ToSubjectPublicKeyInfo(RSAParameters parameters);
    [ExtensionAttribute]
internal static void ReadSubjectPublicKeyInfo(DerSequenceReader keyInfo, RSAParameters& parameters);
    [ExtensionAttribute]
internal static void ReadPkcs1PublicBlob(DerSequenceReader subjectPublicKey, RSAParameters& parameters);
    private static void ReadPkcs1PrivateBlob(Byte[] privateKeyBytes, RSAParameters& parameters);
}
internal class System.Security.Cryptography.RsaPaddingProcessor : object {
    private static Byte[] s_eightZeros;
    private static ConcurrentDictionary`2<HashAlgorithmName, RsaPaddingProcessor> s_lookup;
    private HashAlgorithmName _hashAlgorithmName;
    private int _hLen;
    internal int HashLength { get; }
    private RsaPaddingProcessor(HashAlgorithmName hashAlgorithmName, int hLen);
    private static RsaPaddingProcessor();
    internal static int BytesRequiredForBitCount(int keySizeInBits);
    internal int get_HashLength();
    internal static RsaPaddingProcessor OpenProcessor(HashAlgorithmName hashAlgorithmName);
    internal static void PadPkcs1Encryption(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    internal void PadOaep(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    internal bool DepadOaep(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    internal void EncodePss(ReadOnlySpan`1<byte> mHash, Span`1<byte> destination, int keySize);
    internal bool VerifyPss(ReadOnlySpan`1<byte> mHash, ReadOnlySpan`1<byte> em, int keySize);
    private void Mgf1(IncrementalHash hasher, ReadOnlySpan`1<byte> mgfSeed, Span`1<byte> mask);
    private static void FillNonZeroBytes(Span`1<byte> data);
    private static void Xor(Span`1<byte> a, ReadOnlySpan`1<byte> b);
}
internal class System.Security.Cryptography.SecKeyPair : object {
    [CompilerGeneratedAttribute]
private SafeSecKeyRefHandle <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private SafeSecKeyRefHandle <PrivateKey>k__BackingField;
    internal SafeSecKeyRefHandle PublicKey { get; private set; }
    internal SafeSecKeyRefHandle PrivateKey { get; private set; }
    private SecKeyPair(SafeSecKeyRefHandle publicKey, SafeSecKeyRefHandle privateKey);
    [CompilerGeneratedAttribute]
internal SafeSecKeyRefHandle get_PublicKey();
    [CompilerGeneratedAttribute]
private void set_PublicKey(SafeSecKeyRefHandle value);
    [CompilerGeneratedAttribute]
internal SafeSecKeyRefHandle get_PrivateKey();
    [CompilerGeneratedAttribute]
private void set_PrivateKey(SafeSecKeyRefHandle value);
    public sealed virtual void Dispose();
    internal static SecKeyPair PublicPrivatePair(SafeSecKeyRefHandle publicKey, SafeSecKeyRefHandle privateKey);
    internal static SecKeyPair PublicOnly(SafeSecKeyRefHandle publicKey);
}
public class System.Security.Cryptography.X509Certificates.CertificateRequest : object {
    private AsymmetricAlgorithm _key;
    private X509SignatureGenerator _generator;
    private RSASignaturePadding _rsaPadding;
    [CompilerGeneratedAttribute]
private X500DistinguishedName <SubjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<X509Extension> <CertificateExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKey <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    public X500DistinguishedName SubjectName { get; }
    public Collection`1<X509Extension> CertificateExtensions { get; }
    public PublicKey PublicKey { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public CertificateRequest(string subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(X500DistinguishedName subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(string subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm);
    [CompilerGeneratedAttribute]
public X500DistinguishedName get_SubjectName();
    [CompilerGeneratedAttribute]
public Collection`1<X509Extension> get_CertificateExtensions();
    [CompilerGeneratedAttribute]
public PublicKey get_PublicKey();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    public Byte[] CreateSigningRequest();
    public Byte[] CreateSigningRequest(X509SignatureGenerator signatureGenerator);
    public X509Certificate2 CreateSelfSigned(DateTimeOffset notBefore, DateTimeOffset notAfter);
    public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.DSACertificateExtensions : object {
    [ExtensionAttribute]
public static DSA GetDSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static DSA GetDSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, DSA privateKey);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions : object {
    [ExtensionAttribute]
public static ECDsa GetECDsaPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static ECDsa GetECDsaPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, ECDsa privateKey);
    private static bool HasECDsaKeyUsage(X509Certificate2 certificate);
    private static bool IsSameKey(ECDsa a, ECDsa b);
}
internal class System.Security.Cryptography.X509Certificates.ECDsaX509SignatureGenerator : X509SignatureGenerator {
    private ECDsa _key;
    internal ECDsaX509SignatureGenerator(ECDsa key);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
}
internal class System.Security.Cryptography.X509Certificates.GeneralNameEncoder : object {
    private static IdnMapping s_idnMapping;
    private static GeneralNameEncoder();
    internal Byte[][] EncodeEmailAddress(string emailAddress);
    internal Byte[][] EncodeDnsName(string dnsName);
    internal Byte[][] EncodeUri(Uri uri);
    internal Byte[][] EncodeIpAddress(IPAddress address);
    internal Byte[][] EncodeUserPrincipalName(string upn);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
    public int value__;
    public static OpenFlags ReadOnly;
    public static OpenFlags ReadWrite;
    public static OpenFlags MaxAllowed;
    public static OpenFlags OpenExistingOnly;
    public static OpenFlags IncludeArchived;
}
internal class System.Security.Cryptography.X509Certificates.Pkcs10CertificationRequestInfo : object {
    private static Byte[][] s_encodedVersion;
    [CompilerGeneratedAttribute]
private X500DistinguishedName <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKey <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<X501Attribute> <Attributes>k__BackingField;
    internal X500DistinguishedName Subject { get; internal set; }
    internal PublicKey PublicKey { get; internal set; }
    internal Collection`1<X501Attribute> Attributes { get; }
    internal Pkcs10CertificationRequestInfo(X500DistinguishedName subject, PublicKey publicKey, IEnumerable`1<X501Attribute> attributes);
    private static Pkcs10CertificationRequestInfo();
    [CompilerGeneratedAttribute]
internal X500DistinguishedName get_Subject();
    [CompilerGeneratedAttribute]
internal void set_Subject(X500DistinguishedName value);
    [CompilerGeneratedAttribute]
internal PublicKey get_PublicKey();
    [CompilerGeneratedAttribute]
internal void set_PublicKey(PublicKey value);
    [CompilerGeneratedAttribute]
internal Collection`1<X501Attribute> get_Attributes();
    private Byte[] Encode();
    internal Byte[] ToPkcs10Request(X509SignatureGenerator signatureGenerator, HashAlgorithmName hashAlgorithm);
}
internal class System.Security.Cryptography.X509Certificates.Pkcs9ExtensionRequest : X501Attribute {
    internal Pkcs9ExtensionRequest(IEnumerable`1<X509Extension> extensions);
    private static Byte[] EncodeAttribute(IEnumerable`1<X509Extension> extensions);
}
public class System.Security.Cryptography.X509Certificates.PublicKey : object {
    private Oid _oid;
    private AsymmetricAlgorithm _key;
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedKeyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedParameters>k__BackingField;
    public AsnEncodedData EncodedKeyValue { get; private set; }
    public AsnEncodedData EncodedParameters { get; private set; }
    public AsymmetricAlgorithm Key { get; }
    public Oid Oid { get; }
    public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedKeyValue();
    [CompilerGeneratedAttribute]
private void set_EncodedKeyValue(AsnEncodedData value);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedParameters();
    [CompilerGeneratedAttribute]
private void set_EncodedParameters(AsnEncodedData value);
    public AsymmetricAlgorithm get_Key();
    public Oid get_Oid();
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.RSACertificateExtensions : object {
    [ExtensionAttribute]
public static RSA GetRSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static RSA GetRSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, RSA privateKey);
}
internal class System.Security.Cryptography.X509Certificates.RSAPkcs1X509SignatureGenerator : X509SignatureGenerator {
    private RSA _key;
    internal RSAPkcs1X509SignatureGenerator(RSA key);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
    internal static PublicKey BuildPublicKey(RSA rsa);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
}
internal class System.Security.Cryptography.X509Certificates.RSAPssX509SignatureGenerator : X509SignatureGenerator {
    private RSA _key;
    private RSASignaturePadding _padding;
    internal RSAPssX509SignatureGenerator(RSA key, RSASignaturePadding padding);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
}
internal class System.Security.Cryptography.X509Certificates.SafeSecCertificateHandle : SafeKeychainItemHandle {
}
internal class System.Security.Cryptography.X509Certificates.SafeSecIdentityHandle : SafeKeychainItemHandle {
}
public enum System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
    public int value__;
    public static StoreLocation CurrentUser;
    public static StoreLocation LocalMachine;
}
public enum System.Security.Cryptography.X509Certificates.StoreName : Enum {
    public int value__;
    public static StoreName AddressBook;
    public static StoreName AuthRoot;
    public static StoreName CertificateAuthority;
    public static StoreName Disallowed;
    public static StoreName My;
    public static StoreName Root;
    public static StoreName TrustedPeople;
    public static StoreName TrustedPublisher;
}
public class System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder : object {
    private List`1<Byte[][]> _encodedTlvs;
    private GeneralNameEncoder _generalNameEncoder;
    public void AddEmailAddress(string emailAddress);
    public void AddDnsName(string dnsName);
    public void AddUri(Uri uri);
    public void AddIpAddress(IPAddress ipAddress);
    public void AddUserPrincipalName(string upn);
    public X509Extension Build(bool critical);
}
internal class System.Security.Cryptography.X509Certificates.TbsCertificate : object {
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SerialNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SignatureAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X500DistinguishedName <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <NotAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private X500DistinguishedName <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKey <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<X509Extension> <Extensions>k__BackingField;
    public byte Version { get; public set; }
    public Byte[] SerialNumber { get; public set; }
    public Byte[] SignatureAlgorithm { get; }
    public X500DistinguishedName Issuer { get; public set; }
    public DateTimeOffset NotBefore { get; public set; }
    public DateTimeOffset NotAfter { get; public set; }
    public X500DistinguishedName Subject { get; public set; }
    public PublicKey PublicKey { get; public set; }
    public Collection`1<X509Extension> Extensions { get; }
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(byte value);
    [CompilerGeneratedAttribute]
public Byte[] get_SerialNumber();
    [CompilerGeneratedAttribute]
public void set_SerialNumber(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_SignatureAlgorithm();
    [CompilerGeneratedAttribute]
public X500DistinguishedName get_Issuer();
    [CompilerGeneratedAttribute]
public void set_Issuer(X500DistinguishedName value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_NotAfter();
    [CompilerGeneratedAttribute]
public void set_NotAfter(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public X500DistinguishedName get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(X500DistinguishedName value);
    [CompilerGeneratedAttribute]
public PublicKey get_PublicKey();
    [CompilerGeneratedAttribute]
public void set_PublicKey(PublicKey value);
    [CompilerGeneratedAttribute]
public Collection`1<X509Extension> get_Extensions();
    private Byte[] Encode(X509SignatureGenerator signatureGenerator, HashAlgorithmName hashAlgorithm);
    private static Byte[][] EncodeValidityField(DateTimeOffset validityField, string propertyName);
    internal Byte[] Sign(X509SignatureGenerator signatureGenerator, HashAlgorithmName hashAlgorithm);
}
public class System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDistinguishedName;
    public string Name { get; }
    public X500DistinguishedName(Byte[] encodedDistinguishedName);
    public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
    public X500DistinguishedName(X500DistinguishedName distinguishedName);
    public X500DistinguishedName(string distinguishedName);
    public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
    public string get_Name();
    public string Decode(X500DistinguishedNameFlags flag);
    public virtual string Format(bool multiLine);
    private static Byte[] Encode(string distinguishedName, X500DistinguishedNameFlags flags);
    private static void ThrowIfInvalid(X500DistinguishedNameFlags flags);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
    public int value__;
    public static X500DistinguishedNameFlags None;
    public static X500DistinguishedNameFlags Reversed;
    public static X500DistinguishedNameFlags UseSemicolons;
    public static X500DistinguishedNameFlags DoNotUsePlusSign;
    public static X500DistinguishedNameFlags DoNotUseQuotes;
    public static X500DistinguishedNameFlags UseCommas;
    public static X500DistinguishedNameFlags UseNewLines;
    public static X500DistinguishedNameFlags UseUTF8Encoding;
    public static X500DistinguishedNameFlags UseT61Encoding;
    public static X500DistinguishedNameFlags ForceUTF8Encoding;
}
internal class System.Security.Cryptography.X509Certificates.X501Attribute : AsnEncodedData {
    internal X501Attribute(string oid, Byte[] rawData);
}
public class System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
    private bool _certificateAuthority;
    private bool _hasPathLenConstraint;
    private int _pathLenConstraint;
    private bool _decoded;
    public bool CertificateAuthority { get; }
    public bool HasPathLengthConstraint { get; }
    public int PathLengthConstraint { get; }
    public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
    public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
    public bool get_CertificateAuthority();
    public bool get_HasPathLengthConstraint();
    public int get_PathLengthConstraint();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    private void DecodeExtension();
}
public class System.Security.Cryptography.X509Certificates.X509Certificate : object {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCertHash;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuer;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubject;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazySerialNumber;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithmParameters;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private DateTime _lazyNotBefore;
    private DateTime _lazyNotAfter;
    [CompilerGeneratedAttribute]
private ICertificatePal <Pal>k__BackingField;
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    internal ICertificatePal Pal { get; private set; }
    public X509Certificate(Byte[] data);
    public X509Certificate(Byte[] rawData, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password);
    public X509Certificate(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(IntPtr handle);
    internal X509Certificate(ICertificatePal pal);
    public X509Certificate(string fileName);
    public X509Certificate(string fileName, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password);
    public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(X509Certificate cert);
    public X509Certificate(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    public static X509Certificate CreateFromCertFile(string filename);
    public static X509Certificate CreateFromSignedFile(string filename);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public IntPtr get_Handle();
    public string get_Issuer();
    public string get_Subject();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool Equals(object obj);
    public virtual bool Equals(X509Certificate other);
    public virtual Byte[] Export(X509ContentType contentType);
    public virtual Byte[] Export(X509ContentType contentType, string password);
    [CLSCompliantAttribute("False")]
public virtual Byte[] Export(X509ContentType contentType, SecureString password);
    public virtual string GetRawCertDataString();
    public virtual Byte[] GetCertHash();
    public virtual Byte[] GetCertHash(HashAlgorithmName hashAlgorithm);
    public virtual bool TryGetCertHash(HashAlgorithmName hashAlgorithm, Span`1<byte> destination, Int32& bytesWritten);
    public virtual string GetCertHashString();
    public virtual string GetCertHashString(HashAlgorithmName hashAlgorithm);
    private Byte[] GetRawCertHash();
    public virtual string GetEffectiveDateString();
    public virtual string GetExpirationDateString();
    public virtual string GetFormat();
    public virtual string GetPublicKeyString();
    public virtual Byte[] GetRawCertData();
    public virtual int GetHashCode();
    public virtual string GetKeyAlgorithm();
    public virtual Byte[] GetKeyAlgorithmParameters();
    public virtual string GetKeyAlgorithmParametersString();
    public virtual Byte[] GetPublicKey();
    public virtual Byte[] GetSerialNumber();
    public virtual string GetSerialNumberString();
    private Byte[] GetRawSerialNumber();
    [ObsoleteAttribute("This method has been deprecated.  Please use the Subject property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public virtual string GetName();
    [ObsoleteAttribute("This method has been deprecated.  Please use the Issuer property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public virtual string GetIssuerName();
    public virtual string ToString();
    public virtual string ToString(bool fVerbose);
    public virtual void Import(Byte[] rawData);
    public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName);
    public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [CompilerGeneratedAttribute]
internal ICertificatePal get_Pal();
    [CompilerGeneratedAttribute]
private void set_Pal(ICertificatePal value);
    internal DateTime GetNotAfter();
    internal DateTime GetNotBefore();
    internal void ThrowIfInvalid();
    protected static string FormatDate(DateTime date);
    internal static void ValidateKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    private void VerifyContentType(X509ContentType contentType);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRawData;
    private Oid modreq(System.Runtime.CompilerServices.IsVolatile) _lazySignatureAlgorithm;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyVersion;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubjectName;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuerName;
    private PublicKey modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private AsymmetricAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPrivateKey;
    private X509ExtensionCollection modreq(System.Runtime.CompilerServices.IsVolatile) _lazyExtensions;
    public bool Archived { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public string FriendlyName { get; public set; }
    public bool HasPrivateKey { get; }
    public AsymmetricAlgorithm PrivateKey { get; public set; }
    public X500DistinguishedName IssuerName { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public PublicKey PublicKey { get; }
    public Byte[] RawData { get; }
    public string SerialNumber { get; }
    public Oid SignatureAlgorithm { get; }
    public X500DistinguishedName SubjectName { get; }
    public string Thumbprint { get; }
    public int Version { get; }
    public X509Certificate2(Byte[] rawData);
    public X509Certificate2(Byte[] rawData, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password);
    public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(IntPtr handle);
    internal X509Certificate2(ICertificatePal pal);
    public X509Certificate2(string fileName);
    public X509Certificate2(string fileName, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate2(string fileName, SecureString password);
    public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate2(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(X509Certificate certificate);
    protected X509Certificate2(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    public bool get_Archived();
    public void set_Archived(bool value);
    public X509ExtensionCollection get_Extensions();
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
    public bool get_HasPrivateKey();
    public AsymmetricAlgorithm get_PrivateKey();
    public void set_PrivateKey(AsymmetricAlgorithm value);
    public X500DistinguishedName get_IssuerName();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    public PublicKey get_PublicKey();
    public Byte[] get_RawData();
    public string get_SerialNumber();
    public Oid get_SignatureAlgorithm();
    public X500DistinguishedName get_SubjectName();
    public string get_Thumbprint();
    public int get_Version();
    public static X509ContentType GetCertContentType(Byte[] rawData);
    public static X509ContentType GetCertContentType(string fileName);
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    public virtual string ToString();
    public virtual string ToString(bool verbose);
    public virtual void Import(Byte[] rawData);
    public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName);
    public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public bool Verify();
    private static X509Extension CreateCustomExtensionIfAny(Oid oid);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
    public X509Certificate2 Item { get; public set; }
    public X509Certificate2Collection(X509Certificate2 certificate);
    public X509Certificate2Collection(X509Certificate2[] certificates);
    public X509Certificate2Collection(X509Certificate2Collection certificates);
    public X509Certificate2 get_Item(int index);
    public void set_Item(int index, X509Certificate2 value);
    public int Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2[] certificates);
    public void AddRange(X509Certificate2Collection certificates);
    public bool Contains(X509Certificate2 certificate);
    public Byte[] Export(X509ContentType contentType);
    public Byte[] Export(X509ContentType contentType, string password);
    public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
    public X509Certificate2Enumerator GetEnumerator();
    public void Import(Byte[] rawData);
    public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public void Import(string fileName);
    public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public void Insert(int index, X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2[] certificates);
    public void RemoveRange(X509Certificate2Collection certificates);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
    private IEnumerator _enumerator;
    public X509Certificate2 Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509Certificate2Enumerator(X509Certificate2Collection collection);
    public X509Certificate2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    public void Reset();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
    public X509Certificate Item { get; public set; }
    public X509CertificateCollection(X509Certificate[] value);
    public X509CertificateCollection(X509CertificateCollection value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509Certificate[] value);
    public void AddRange(X509CertificateCollection value);
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public X509CertificateEnumerator GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    public void Remove(X509Certificate value);
    protected virtual void OnValidate(object value);
}
public class System.Security.Cryptography.X509Certificates.X509Chain : object {
    private X509ChainPolicy _chainPolicy;
    private X509ChainStatus[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyChainStatus;
    private X509ChainElementCollection _chainElements;
    private IChainPal _pal;
    private bool _useMachineContext;
    private object _syncRoot;
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public IntPtr ChainContext { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public X509Chain(bool useMachineContext);
    public X509Chain(IntPtr chainContext);
    public static X509Chain Create();
    public X509ChainElementCollection get_ChainElements();
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    public IntPtr get_ChainContext();
    public SafeX509ChainHandle get_SafeHandle();
    public bool Build(X509Certificate2 certificate);
    internal bool Build(X509Certificate2 certificate, bool throwOnException);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElement : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainStatus[] <ChainElementStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Information>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public X509ChainStatus[] ChainElementStatus { get; private set; }
    public string Information { get; private set; }
    internal X509ChainElement(X509Certificate2 certificate, X509ChainStatus[] chainElementStatus, string information);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public X509ChainStatus[] get_ChainElementStatus();
    [CompilerGeneratedAttribute]
private void set_ChainElementStatus(X509ChainStatus[] value);
    [CompilerGeneratedAttribute]
public string get_Information();
    [CompilerGeneratedAttribute]
private void set_Information(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
    private X509ChainElement[] _elements;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public X509ChainElement Item { get; }
    internal X509ChainElementCollection(X509ChainElement[] chainElements);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public X509ChainElement get_Item(int index);
    public void CopyTo(X509ChainElement[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ChainElementEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
    private X509ChainElementCollection _chainElements;
    private int _current;
    public X509ChainElement Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ChainElementEnumerator(X509ChainElementCollection chainElements);
    public X509ChainElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
    [CompilerGeneratedAttribute]
private OidCollection <ApplicationPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private OidCollection <CertificatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <VerificationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <UrlRetrievalTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <ExtraStore>k__BackingField;
    private X509RevocationMode _revocationMode;
    private X509RevocationFlag _revocationFlag;
    private X509VerificationFlags _verificationFlags;
    public OidCollection ApplicationPolicy { get; private set; }
    public OidCollection CertificatePolicy { get; private set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public X509RevocationFlag RevocationFlag { get; public set; }
    public X509VerificationFlags VerificationFlags { get; public set; }
    public DateTime VerificationTime { get; public set; }
    public TimeSpan UrlRetrievalTimeout { get; public set; }
    public X509Certificate2Collection ExtraStore { get; private set; }
    [CompilerGeneratedAttribute]
public OidCollection get_ApplicationPolicy();
    [CompilerGeneratedAttribute]
private void set_ApplicationPolicy(OidCollection value);
    [CompilerGeneratedAttribute]
public OidCollection get_CertificatePolicy();
    [CompilerGeneratedAttribute]
private void set_CertificatePolicy(OidCollection value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public X509RevocationFlag get_RevocationFlag();
    public void set_RevocationFlag(X509RevocationFlag value);
    public X509VerificationFlags get_VerificationFlags();
    public void set_VerificationFlags(X509VerificationFlags value);
    [CompilerGeneratedAttribute]
public DateTime get_VerificationTime();
    [CompilerGeneratedAttribute]
public void set_VerificationTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_UrlRetrievalTimeout();
    [CompilerGeneratedAttribute]
public void set_UrlRetrievalTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_ExtraStore();
    [CompilerGeneratedAttribute]
private void set_ExtraStore(X509Certificate2Collection value);
    public void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
    [CompilerGeneratedAttribute]
private X509ChainStatusFlags <Status>k__BackingField;
    private string _statusInformation;
    public X509ChainStatusFlags Status { get; public set; }
    public string StatusInformation { get; public set; }
    [CompilerGeneratedAttribute]
public X509ChainStatusFlags get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(X509ChainStatusFlags value);
    public string get_StatusInformation();
    public void set_StatusInformation(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags Revoked;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotValidForUsage;
    public static X509ChainStatusFlags UntrustedRoot;
    public static X509ChainStatusFlags RevocationStatusUnknown;
    public static X509ChainStatusFlags Cyclic;
    public static X509ChainStatusFlags InvalidExtension;
    public static X509ChainStatusFlags InvalidPolicyConstraints;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags InvalidNameConstraints;
    public static X509ChainStatusFlags HasNotSupportedNameConstraint;
    public static X509ChainStatusFlags HasNotDefinedNameConstraint;
    public static X509ChainStatusFlags HasNotPermittedNameConstraint;
    public static X509ChainStatusFlags HasExcludedNameConstraint;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags CtlNotTimeValid;
    public static X509ChainStatusFlags CtlNotSignatureValid;
    public static X509ChainStatusFlags CtlNotValidForUsage;
    public static X509ChainStatusFlags OfflineRevocation;
    public static X509ChainStatusFlags NoIssuanceChainPolicy;
    public static X509ChainStatusFlags ExplicitDistrust;
    public static X509ChainStatusFlags HasNotSupportedCriticalExtension;
    public static X509ChainStatusFlags HasWeakSignature;
}
public enum System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
    public int value__;
    public static X509ContentType Unknown;
    public static X509ContentType Cert;
    public static X509ContentType SerializedCert;
    public static X509ContentType Pfx;
    public static X509ContentType Pkcs12;
    public static X509ContentType SerializedStore;
    public static X509ContentType Pkcs7;
    public static X509ContentType Authenticode;
}
public class System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
    private OidCollection _enhancedKeyUsages;
    private bool _decoded;
    public OidCollection EnhancedKeyUsages { get; }
    public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
    public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
    public OidCollection get_EnhancedKeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(OidCollection enhancedKeyUsages);
}
public class System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    public bool Critical { get; public set; }
    public X509Extension(AsnEncodedData encodedExtension, bool critical);
    public X509Extension(Oid oid, Byte[] rawData, bool critical);
    public X509Extension(string oid, Byte[] rawData, bool critical);
    internal X509Extension(string oidValue);
    [CompilerGeneratedAttribute]
public bool get_Critical();
    [CompilerGeneratedAttribute]
public void set_Critical(bool value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
    private List`1<X509Extension> _list;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public X509Extension Item { get; }
    public X509Extension Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public int Add(X509Extension extension);
    public void CopyTo(X509Extension[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ExtensionEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
    private X509ExtensionCollection _extensions;
    private int _current;
    public X509Extension Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ExtensionEnumerator(X509ExtensionCollection extensions);
    public X509Extension get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.X509Certificates.X509FindType : Enum {
    public int value__;
    public static X509FindType FindByThumbprint;
    public static X509FindType FindBySubjectName;
    public static X509FindType FindBySubjectDistinguishedName;
    public static X509FindType FindByIssuerName;
    public static X509FindType FindByIssuerDistinguishedName;
    public static X509FindType FindBySerialNumber;
    public static X509FindType FindByTimeValid;
    public static X509FindType FindByTimeNotYetValid;
    public static X509FindType FindByTimeExpired;
    public static X509FindType FindByTemplateName;
    public static X509FindType FindByApplicationPolicy;
    public static X509FindType FindByCertificatePolicy;
    public static X509FindType FindByExtension;
    public static X509FindType FindByKeyUsage;
    public static X509FindType FindBySubjectKeyIdentifier;
}
public enum System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
    public int value__;
    public static X509IncludeOption None;
    public static X509IncludeOption ExcludeRoot;
    public static X509IncludeOption EndCertOnly;
    public static X509IncludeOption WholeChain;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
    public int value__;
    public static X509KeyStorageFlags DefaultKeySet;
    public static X509KeyStorageFlags UserKeySet;
    public static X509KeyStorageFlags MachineKeySet;
    public static X509KeyStorageFlags Exportable;
    public static X509KeyStorageFlags UserProtected;
    public static X509KeyStorageFlags PersistKeySet;
    public static X509KeyStorageFlags EphemeralKeySet;
}
public class System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
    private bool _decoded;
    private X509KeyUsageFlags _keyUsages;
    public X509KeyUsageFlags KeyUsages { get; }
    public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
    public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
    public X509KeyUsageFlags get_KeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags NonRepudiation;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags DecipherOnly;
}
public enum System.Security.Cryptography.X509Certificates.X509NameType : Enum {
    public int value__;
    public static X509NameType SimpleName;
    public static X509NameType EmailName;
    public static X509NameType UpnName;
    public static X509NameType DnsName;
    public static X509NameType DnsFromAlternativeName;
    public static X509NameType UrlName;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
    public int value__;
    public static X509RevocationFlag EndCertificateOnly;
    public static X509RevocationFlag EntireChain;
    public static X509RevocationFlag ExcludeRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
    public int value__;
    public static X509RevocationMode NoCheck;
    public static X509RevocationMode Online;
    public static X509RevocationMode Offline;
}
public abstract class System.Security.Cryptography.X509Certificates.X509SignatureGenerator : object {
    private PublicKey _publicKey;
    public PublicKey PublicKey { get; }
    public PublicKey get_PublicKey();
    public abstract virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public abstract virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected abstract virtual PublicKey BuildPublicKey();
    public static X509SignatureGenerator CreateForECDsa(ECDsa key);
    public static X509SignatureGenerator CreateForRSA(RSA key, RSASignaturePadding signaturePadding);
}
public class System.Security.Cryptography.X509Certificates.X509Store : object {
    private IStorePal _storePal;
    [CompilerGeneratedAttribute]
private StoreLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IntPtr StoreHandle { get; }
    public StoreLocation Location { get; private set; }
    public string Name { get; private set; }
    public X509Certificate2Collection Certificates { get; }
    public bool IsOpen { get; }
    public X509Store(string storeName);
    public X509Store(StoreName storeName);
    public X509Store(StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Store(string storeName, StoreLocation storeLocation);
    public X509Store(string storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Store(IntPtr storeHandle);
    public IntPtr get_StoreHandle();
    [CompilerGeneratedAttribute]
public StoreLocation get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(StoreLocation value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public void Open(OpenFlags flags);
    public X509Certificate2Collection get_Certificates();
    public bool get_IsOpen();
    public void Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2Collection certificates);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2Collection certificates);
    public sealed virtual void Dispose();
    public void Close();
}
public class System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
    private string _subjectKeyIdentifier;
    private bool _decoded;
    public string SubjectKeyIdentifier { get; }
    public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
    public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
    public string get_SubjectKeyIdentifier();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(Byte[] subjectKeyIdentifier);
    private static Byte[] EncodeExtension(string subjectKeyIdentifier);
    private static Byte[] EncodeExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
    private static Byte[] GenerateSubjectKeyIdentifierFromPublicKey(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
    private static Byte[] ComputeSha1(Byte[] data);
}
public enum System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
    public int value__;
    public static X509SubjectKeyIdentifierHashAlgorithm Sha1;
    public static X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
    public static X509SubjectKeyIdentifierHashAlgorithm CapiSha1;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
    public int value__;
    public static X509VerificationFlags NoFlag;
    public static X509VerificationFlags IgnoreNotTimeValid;
    public static X509VerificationFlags IgnoreCtlNotTimeValid;
    public static X509VerificationFlags IgnoreNotTimeNested;
    public static X509VerificationFlags IgnoreInvalidBasicConstraints;
    public static X509VerificationFlags AllowUnknownCertificateAuthority;
    public static X509VerificationFlags IgnoreWrongUsage;
    public static X509VerificationFlags IgnoreInvalidName;
    public static X509VerificationFlags IgnoreInvalidPolicy;
    public static X509VerificationFlags IgnoreEndRevocationUnknown;
    public static X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
    public static X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
    public static X509VerificationFlags IgnoreRootRevocationUnknown;
    public static X509VerificationFlags AllFlags;
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string Arg_CryptographyException { get; }
    internal static string Arg_EmptyOrNullArray { get; }
    internal static string Arg_EmptyOrNullString { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidType { get; }
    internal static string Arg_OutOfRange_NeedNonNegNum { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string Cryptography_BadHashSize_ForAlgorithm { get; }
    internal static string Cryptography_Cert_AlreadyHasPrivateKey { get; }
    internal static string Cryptography_CertReq_AlgorithmMustMatch { get; }
    internal static string Cryptography_CertReq_BasicConstraintsRequired { get; }
    internal static string Cryptography_CertReq_DatesReversed { get; }
    internal static string Cryptography_CertReq_DateTooOld { get; }
    internal static string Cryptography_CertReq_DuplicateExtension { get; }
    internal static string Cryptography_CertReq_IssuerBasicConstraintsInvalid { get; }
    internal static string Cryptography_CertReq_IssuerKeyUsageInvalid { get; }
    internal static string Cryptography_CertReq_IssuerRequiresPrivateKey { get; }
    internal static string Cryptography_CertReq_NotAfterNotNested { get; }
    internal static string Cryptography_CertReq_NotBeforeNotNested { get; }
    internal static string Cryptography_CertReq_NoKeyProvided { get; }
    internal static string Cryptography_CertReq_RSAPaddingRequired { get; }
    internal static string Cryptography_CSP_NoPrivateKey { get; }
    internal static string Cryptography_CurveNotSupported { get; }
    internal static string Cryptography_ECC_NamedCurvesOnly { get; }
    internal static string Cryptography_Encryption_MessageTooLong { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_HashAlgorithmNameNullOrEmpty { get; }
    internal static string Cryptography_InvalidContextHandle { get; }
    internal static string Cryptography_InvalidHandle { get; }
    internal static string Cryptography_InvalidPaddingMode { get; }
    internal static string Cryptography_InvalidPublicKey_Object { get; }
    internal static string Cryptography_InvalidRsaParameters { get; }
    internal static string Cryptography_KeyTooSmall { get; }
    internal static string Cryptography_OAEP_Decryption_Failed { get; }
    internal static string Cryptography_OpenInvalidHandle { get; }
    internal static string Cryptography_PrivateKey_DoesNotMatch { get; }
    internal static string Cryptography_PrivateKey_WrongAlgorithm { get; }
    internal static string Cryptography_RSA_DecryptWrongSize { get; }
    internal static string Cryptography_SignHash_WrongSize { get; }
    internal static string Cryptography_Unix_X509_PropertyNotSettable { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_UnknownKeyAlgorithm { get; }
    internal static string Cryptography_Unix_X509_SerializedExport { get; }
    internal static string Cryptography_Unmapped_System_Typed_Error { get; }
    internal static string Cryptography_X509_ExtensionMismatch { get; }
    internal static string Cryptography_X509_InvalidContentType { get; }
    internal static string Cryptography_X509_InvalidFindType { get; }
    internal static string Cryptography_X509_InvalidFindValue { get; }
    internal static string Cryptography_X509_InvalidFlagCombination { get; }
    internal static string Cryptography_X509_PKCS7_NoSigner { get; }
    internal static string Cryptography_X509_StoreNotFound { get; }
    internal static string Cryptography_X509_StoreNotOpen { get; }
    internal static string Cryptography_X509_StoreReadOnly { get; }
    internal static string Cryptography_X509_StoreCannotCreate { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string NotSupported_KeyAlgorithm { get; }
    internal static string NotSupported_LegacyBasicConstraints { get; }
    internal static string NotSupported_ImmutableX509Certificate { get; }
    internal static string Security_AccessDenied { get; }
    internal static string Cryptography_Invalid_X500Name { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static string Cryptography_X509_NoEphemeralPfx { get; }
    internal static string Cryptography_X509Store_WouldModifyUserTrust { get; }
    internal static string Cryptography_X509Store_WouldModifyAdminTrust { get; }
    internal static string Cryptography_InvalidKeySize { get; }
    internal static string Cryptography_DSA_KeyGenNotSupported { get; }
    internal static string Cryptography_InvalidDsaParameters_MissingFields { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPGY { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedQX { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPJ { get; }
    internal static string Cryptography_InvalidDsaParameters_QRestriction_ShortKey { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_Arg_CryptographyException();
    internal static string get_Arg_EmptyOrNullArray();
    internal static string get_Arg_EmptyOrNullString();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidType();
    internal static string get_Arg_OutOfRange_NeedNonNegNum();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_Cryptography_BadHashSize_ForAlgorithm();
    internal static string get_Cryptography_Cert_AlreadyHasPrivateKey();
    internal static string get_Cryptography_CertReq_AlgorithmMustMatch();
    internal static string get_Cryptography_CertReq_BasicConstraintsRequired();
    internal static string get_Cryptography_CertReq_DatesReversed();
    internal static string get_Cryptography_CertReq_DateTooOld();
    internal static string get_Cryptography_CertReq_DuplicateExtension();
    internal static string get_Cryptography_CertReq_IssuerBasicConstraintsInvalid();
    internal static string get_Cryptography_CertReq_IssuerKeyUsageInvalid();
    internal static string get_Cryptography_CertReq_IssuerRequiresPrivateKey();
    internal static string get_Cryptography_CertReq_NotAfterNotNested();
    internal static string get_Cryptography_CertReq_NotBeforeNotNested();
    internal static string get_Cryptography_CertReq_NoKeyProvided();
    internal static string get_Cryptography_CertReq_RSAPaddingRequired();
    internal static string get_Cryptography_CSP_NoPrivateKey();
    internal static string get_Cryptography_CurveNotSupported();
    internal static string get_Cryptography_ECC_NamedCurvesOnly();
    internal static string get_Cryptography_Encryption_MessageTooLong();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_HashAlgorithmNameNullOrEmpty();
    internal static string get_Cryptography_InvalidContextHandle();
    internal static string get_Cryptography_InvalidHandle();
    internal static string get_Cryptography_InvalidPaddingMode();
    internal static string get_Cryptography_InvalidPublicKey_Object();
    internal static string get_Cryptography_InvalidRsaParameters();
    internal static string get_Cryptography_KeyTooSmall();
    internal static string get_Cryptography_OAEP_Decryption_Failed();
    internal static string get_Cryptography_OpenInvalidHandle();
    internal static string get_Cryptography_PrivateKey_DoesNotMatch();
    internal static string get_Cryptography_PrivateKey_WrongAlgorithm();
    internal static string get_Cryptography_RSA_DecryptWrongSize();
    internal static string get_Cryptography_SignHash_WrongSize();
    internal static string get_Cryptography_Unix_X509_PropertyNotSettable();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_UnknownKeyAlgorithm();
    internal static string get_Cryptography_Unix_X509_SerializedExport();
    internal static string get_Cryptography_Unmapped_System_Typed_Error();
    internal static string get_Cryptography_X509_ExtensionMismatch();
    internal static string get_Cryptography_X509_InvalidContentType();
    internal static string get_Cryptography_X509_InvalidFindType();
    internal static string get_Cryptography_X509_InvalidFindValue();
    internal static string get_Cryptography_X509_InvalidFlagCombination();
    internal static string get_Cryptography_X509_PKCS7_NoSigner();
    internal static string get_Cryptography_X509_StoreNotFound();
    internal static string get_Cryptography_X509_StoreNotOpen();
    internal static string get_Cryptography_X509_StoreReadOnly();
    internal static string get_Cryptography_X509_StoreCannotCreate();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_NotSupported_KeyAlgorithm();
    internal static string get_NotSupported_LegacyBasicConstraints();
    internal static string get_NotSupported_ImmutableX509Certificate();
    internal static string get_Security_AccessDenied();
    internal static string get_Cryptography_Invalid_X500Name();
    internal static string get_Cryptography_Invalid_IA5String();
    internal static string get_Cryptography_X509_NoEphemeralPfx();
    internal static string get_Cryptography_X509Store_WouldModifyUserTrust();
    internal static string get_Cryptography_X509Store_WouldModifyAdminTrust();
    internal static string get_Cryptography_InvalidKeySize();
    internal static string get_Cryptography_DSA_KeyGenNotSupported();
    internal static string get_Cryptography_InvalidDsaParameters_MissingFields();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPGY();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedQX();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPJ();
    internal static string get_Cryptography_InvalidDsaParameters_QRestriction_ShortKey();
}
