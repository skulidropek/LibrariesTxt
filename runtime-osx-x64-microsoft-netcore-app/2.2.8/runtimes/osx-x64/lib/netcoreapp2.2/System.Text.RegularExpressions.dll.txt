internal static class FxResources.System.Text.RegularExpressions.SR : object {
}
[DefaultMemberAttribute("Item")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Collections.Generic.ValueListBuilder`1 : ValueType {
    private Span`1<T> _span;
    private T[] _arrayFromPool;
    private int _pos;
    public int Length { get; }
    public T& Item { get; }
    public ValueListBuilder`1(Span`1<T> initialSpan);
    public T Pop();
    public int get_Length();
    public T& get_Item(int index);
    public void Append(T item);
    public ReadOnlySpan`1<T> AsSpan();
    public void Dispose();
    private void Grow();
}
[ExtensionAttribute]
internal static class System.Collections.HashtableExtensions : object {
    [ExtensionAttribute]
public static bool TryGetValue(Hashtable table, object key, T& value);
}
internal static class System.IO.StringBuilderCache : object {
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesignWithMessage(string message);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string AlternationCantCapture { get; }
    internal static string AlternationCantHaveComment { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string BadClassInCharRange { get; }
    internal static string BeginIndexNotNegative { get; }
    internal static string CaptureGroupOutOfRange { get; }
    internal static string CapnumNotZero { get; }
    internal static string CountTooSmall { get; }
    internal static string EnumNotStarted { get; }
    internal static string IllegalCondition { get; }
    internal static string IllegalDefaultRegexMatchTimeoutInAppDomain { get; }
    internal static string IllegalEndEscape { get; }
    internal static string IllegalRange { get; }
    internal static string IncompleteSlashP { get; }
    internal static string InternalError { get; }
    internal static string InvalidGroupName { get; }
    internal static string InvalidEmptyArgument { get; }
    internal static string LengthNotNegative { get; }
    internal static string MalformedNameRef { get; }
    internal static string MalformedReference { get; }
    internal static string MalformedSlashP { get; }
    internal static string MakeException { get; }
    internal static string MissingControl { get; }
    internal static string NestedQuantify { get; }
    internal static string NoResultOnFailed { get; }
    internal static string NotEnoughParens { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string OnlyAllowedOnce { get; }
    internal static string PlatformNotSupported_CompileToAssembly { get; }
    internal static string QuantifyAfterNothing { get; }
    internal static string RegexMatchTimeoutException_Occurred { get; }
    internal static string ReplacementError { get; }
    internal static string ReversedCharRange { get; }
    internal static string SubtractionMustBeLast { get; }
    internal static string TooFewHex { get; }
    internal static string TooManyAlternates { get; }
    internal static string TooManyParens { get; }
    internal static string UndefinedBackref { get; }
    internal static string UndefinedNameRef { get; }
    internal static string UndefinedReference { get; }
    internal static string UnexpectedOpcode { get; }
    internal static string UnimplementedState { get; }
    internal static string UnknownProperty { get; }
    internal static string UnrecognizedControl { get; }
    internal static string UnrecognizedEscape { get; }
    internal static string UnrecognizedGrouping { get; }
    internal static string UnterminatedBracket { get; }
    internal static string UnterminatedComment { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_AlternationCantCapture();
    internal static string get_AlternationCantHaveComment();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_BadClassInCharRange();
    internal static string get_BeginIndexNotNegative();
    internal static string get_CaptureGroupOutOfRange();
    internal static string get_CapnumNotZero();
    internal static string get_CountTooSmall();
    internal static string get_EnumNotStarted();
    internal static string get_IllegalCondition();
    internal static string get_IllegalDefaultRegexMatchTimeoutInAppDomain();
    internal static string get_IllegalEndEscape();
    internal static string get_IllegalRange();
    internal static string get_IncompleteSlashP();
    internal static string get_InternalError();
    internal static string get_InvalidGroupName();
    internal static string get_InvalidEmptyArgument();
    internal static string get_LengthNotNegative();
    internal static string get_MalformedNameRef();
    internal static string get_MalformedReference();
    internal static string get_MalformedSlashP();
    internal static string get_MakeException();
    internal static string get_MissingControl();
    internal static string get_NestedQuantify();
    internal static string get_NoResultOnFailed();
    internal static string get_NotEnoughParens();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_OnlyAllowedOnce();
    internal static string get_PlatformNotSupported_CompileToAssembly();
    internal static string get_QuantifyAfterNothing();
    internal static string get_RegexMatchTimeoutException_Occurred();
    internal static string get_ReplacementError();
    internal static string get_ReversedCharRange();
    internal static string get_SubtractionMustBeLast();
    internal static string get_TooFewHex();
    internal static string get_TooManyAlternates();
    internal static string get_TooManyParens();
    internal static string get_UndefinedBackref();
    internal static string get_UndefinedNameRef();
    internal static string get_UndefinedReference();
    internal static string get_UnexpectedOpcode();
    internal static string get_UnimplementedState();
    internal static string get_UnknownProperty();
    internal static string get_UnrecognizedControl();
    internal static string get_UnrecognizedEscape();
    internal static string get_UnrecognizedGrouping();
    internal static string get_UnterminatedBracket();
    internal static string get_UnterminatedComment();
}
public class System.Text.RegularExpressions.Capture : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public int Index { get; private protected set; }
    public int Length { get; private protected set; }
    internal string Text { get; private protected set; }
    public string Value { get; }
    internal Capture(string text, int index, int length);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private protected void set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private protected void set_Length(int value);
    [CompilerGeneratedAttribute]
internal string get_Text();
    [CompilerGeneratedAttribute]
private protected void set_Text(string value);
    public string get_Value();
    public virtual string ToString();
    internal ReadOnlySpan`1<char> GetLeftSubstring();
    internal ReadOnlySpan`1<char> GetRightSubstring();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Text.RegularExpressions.CollectionDebuggerProxy`1<System.Text.RegularExpressions.Capture>")]
[DefaultMemberAttribute("Item")]
public class System.Text.RegularExpressions.CaptureCollection : object {
    private Group _group;
    private int _capcount;
    private Capture[] _captures;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Capture Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private Capture System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal CaptureCollection(Group group);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual Capture get_Item(int i);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Capture> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Capture>.GetEnumerator();
    private Capture GetCapture(int i);
    internal void ForceInitialized();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Capture[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.IndexOf(Capture item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.Insert(int index, Capture item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.RemoveAt(int index);
    private sealed virtual override Capture System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Capture>.set_Item(int index, Capture value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Add(Capture item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Contains(Capture item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Capture>.Remove(Capture item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
internal class System.Text.RegularExpressions.CollectionDebuggerProxy`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public CollectionDebuggerProxy`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Text.RegularExpressions.CompiledRegexRunner : RegexRunner {
    private Action`1<RegexRunner> _goMethod;
    private Func`2<RegexRunner, bool> _findFirstCharMethod;
    private Action`1<RegexRunner> _initTrackCountMethod;
    public void SetDelegates(Action`1<RegexRunner> go, Func`2<RegexRunner, bool> firstChar, Action`1<RegexRunner> trackCount);
    protected virtual void Go();
    protected virtual bool FindFirstChar();
    protected virtual void InitTrackCount();
}
internal class System.Text.RegularExpressions.CompiledRegexRunnerFactory : RegexRunnerFactory {
    private DynamicMethod _goMethod;
    private DynamicMethod _findFirstCharMethod;
    private DynamicMethod _initTrackCountMethod;
    public CompiledRegexRunnerFactory(DynamicMethod go, DynamicMethod firstChar, DynamicMethod trackCount);
    protected internal virtual RegexRunner CreateInstance();
}
internal class System.Text.RegularExpressions.ExclusiveReference : object {
    private RegexRunner _ref;
    private RegexRunner _obj;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _locked;
    public RegexRunner Get();
    public void Release(RegexRunner obj);
}
public class System.Text.RegularExpressions.Group : Capture {
    internal static Group s_emptyGroup;
    internal Int32[] _caps;
    internal int _capcount;
    internal CaptureCollection _capcoll;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool Success { get; }
    public string Name { get; }
    public CaptureCollection Captures { get; }
    internal Group(string text, Int32[] caps, int capcount, string name);
    private static Group();
    public bool get_Success();
    [CompilerGeneratedAttribute]
public string get_Name();
    public CaptureCollection get_Captures();
    public static Group Synchronized(Group inner);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Text.RegularExpressions.CollectionDebuggerProxy`1<System.Text.RegularExpressions.Group>")]
public class System.Text.RegularExpressions.GroupCollection : object {
    private Match _match;
    private Hashtable _captureMap;
    private Group[] _groups;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Group Item { get; }
    public Group Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private Group System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal GroupCollection(Match match, Hashtable caps);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual Group get_Item(int groupnum);
    public Group get_Item(string groupname);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Group> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Group>.GetEnumerator();
    private Group GetGroup(int groupnum);
    private Group GetGroupImpl(int groupnum);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Group[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.IndexOf(Group item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.Insert(int index, Group item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.RemoveAt(int index);
    private sealed virtual override Group System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Group>.set_Item(int index, Group value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Add(Group item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Contains(Group item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Group>.Remove(Group item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
public class System.Text.RegularExpressions.Match : Group {
    internal GroupCollection _groupcoll;
    internal Regex _regex;
    internal int _textbeg;
    internal int _textpos;
    internal int _textend;
    internal int _textstart;
    internal Int32[][] _matches;
    internal Int32[] _matchcount;
    internal bool _balancing;
    [CompilerGeneratedAttribute]
private static Match <Empty>k__BackingField;
    public static Match Empty { get; }
    public GroupCollection Groups { get; }
    internal Match(Regex regex, int capcount, string text, int begpos, int len, int startpos);
    private static Match();
    [CompilerGeneratedAttribute]
public static Match get_Empty();
    internal virtual void Reset(Regex regex, string text, int textbeg, int textend, int textstart);
    public virtual GroupCollection get_Groups();
    public Match NextMatch();
    public virtual string Result(string replacement);
    internal virtual ReadOnlySpan`1<char> GroupToStringImpl(int groupnum);
    internal ReadOnlySpan`1<char> LastGroupToStringImpl();
    public static Match Synchronized(Match inner);
    internal virtual void AddMatch(int cap, int start, int len);
    internal virtual void BalanceMatch(int cap);
    internal virtual void RemoveMatch(int cap);
    internal virtual bool IsMatched(int cap);
    internal virtual int MatchIndex(int cap);
    internal virtual int MatchLength(int cap);
    internal virtual void Tidy(int textpos);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Text.RegularExpressions.CollectionDebuggerProxy`1<System.Text.RegularExpressions.Match>")]
public class System.Text.RegularExpressions.MatchCollection : object {
    private Regex _regex;
    private List`1<Match> _matches;
    private bool _done;
    private string _input;
    private int _beginning;
    private int _length;
    private int _startat;
    private int _prevlen;
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Match Item { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private Match System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal MatchCollection(Regex regex, string input, int beginning, int length, int startat);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public virtual Match get_Item(int i);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Match> System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Match>.GetEnumerator();
    private Match GetMatch(int i);
    private void EnsureInitialized();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual void CopyTo(Match[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.IndexOf(Match item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.Insert(int index, Match item);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.RemoveAt(int index);
    private sealed virtual override Match System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Text.RegularExpressions.Match>.set_Item(int index, Match value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Add(Match item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Contains(Match item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.RegularExpressions.Match>.Remove(Match item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
public class System.Text.RegularExpressions.MatchEvaluator : MulticastDelegate {
    public MatchEvaluator(object object, IntPtr method);
    public virtual string Invoke(Match match);
    public virtual IAsyncResult BeginInvoke(Match match, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class System.Text.RegularExpressions.MatchSparse : Match {
    internal Hashtable _caps;
    public GroupCollection Groups { get; }
    internal MatchSparse(Regex regex, Hashtable caps, int capcount, string text, int begpos, int len, int startpos);
    public virtual GroupCollection get_Groups();
}
public class System.Text.RegularExpressions.Regex : object {
    private static int s_cacheSize;
    private static Dictionary`2<CachedCodeEntryKey, CachedCodeEntry> s_cache;
    private static int s_cacheCount;
    private static CachedCodeEntry s_cacheFirst;
    private static CachedCodeEntry s_cacheLast;
    protected internal string pattern;
    protected internal RegexOptions roptions;
    protected internal RegexRunnerFactory factory;
    protected internal Hashtable caps;
    protected internal Hashtable capnames;
    protected internal String[] capslist;
    protected internal int capsize;
    internal ExclusiveReference _runnerref;
    internal WeakReference`1<RegexReplacement> _replref;
    internal RegexCode _code;
    internal bool _refsInitialized;
    private static TimeSpan s_maximumMatchTimeout;
    internal static TimeSpan s_defaultMatchTimeout;
    public static TimeSpan InfiniteMatchTimeout;
    protected internal TimeSpan internalMatchTimeout;
    public static int CacheSize { get; public set; }
    [CLSCompliantAttribute("False")]
protected IDictionary Caps { get; protected set; }
    [CLSCompliantAttribute("False")]
protected IDictionary CapNames { get; protected set; }
    public RegexOptions Options { get; }
    public bool RightToLeft { get; }
    public TimeSpan MatchTimeout { get; }
    public Regex(string pattern);
    public Regex(string pattern, RegexOptions options);
    public Regex(string pattern, RegexOptions options, TimeSpan matchTimeout);
    protected Regex(SerializationInfo info, StreamingContext context);
    private Regex(string pattern, RegexOptions options, TimeSpan matchTimeout, bool addToCache);
    private static Regex();
    public static int get_CacheSize();
    public static void set_CacheSize(int value);
    private CachedCodeEntry GetCachedCode(CachedCodeEntryKey key, bool isToAdd);
    private CachedCodeEntry GetCachedCodeEntryInternal(CachedCodeEntryKey key, bool isToAdd);
    private void FillCacheDictionary();
    private static bool TryGetCacheValue(CachedCodeEntryKey key, CachedCodeEntry& entry);
    private static bool TryGetCacheValueSmall(CachedCodeEntryKey key, CachedCodeEntry& entry);
    private static CachedCodeEntry LookupCachedAndPromote(CachedCodeEntryKey key);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    protected IDictionary get_Caps();
    protected void set_Caps(IDictionary value);
    protected IDictionary get_CapNames();
    protected void set_CapNames(IDictionary value);
    private RegexRunnerFactory Compile(RegexCode code, RegexOptions roptions);
    public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname);
    public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes);
    public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, string resourceFile);
    public static string Escape(string str);
    public static string Unescape(string str);
    public RegexOptions get_Options();
    public bool get_RightToLeft();
    public virtual string ToString();
    public String[] GetGroupNames();
    public Int32[] GetGroupNumbers();
    public string GroupNameFromNumber(int i);
    public int GroupNumberFromName(string name);
    protected void InitializeReferences();
    internal Match Run(bool quick, int prevlen, string input, int beginning, int length, int startat);
    protected bool UseOptionC();
    protected internal bool UseOptionR();
    internal bool UseOptionInvariant();
    public static bool IsMatch(string input, string pattern);
    public static bool IsMatch(string input, string pattern, RegexOptions options);
    public static bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public bool IsMatch(string input);
    public bool IsMatch(string input, int startat);
    public static Match Match(string input, string pattern);
    public static Match Match(string input, string pattern, RegexOptions options);
    public static Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public Match Match(string input);
    public Match Match(string input, int startat);
    public Match Match(string input, int beginning, int length);
    public static MatchCollection Matches(string input, string pattern);
    public static MatchCollection Matches(string input, string pattern, RegexOptions options);
    public static MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public MatchCollection Matches(string input);
    public MatchCollection Matches(string input, int startat);
    public static string Replace(string input, string pattern, string replacement);
    public static string Replace(string input, string pattern, string replacement, RegexOptions options);
    public static string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout);
    public string Replace(string input, string replacement);
    public string Replace(string input, string replacement, int count);
    public string Replace(string input, string replacement, int count, int startat);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout);
    public string Replace(string input, MatchEvaluator evaluator);
    public string Replace(string input, MatchEvaluator evaluator, int count);
    public string Replace(string input, MatchEvaluator evaluator, int count, int startat);
    private static string Replace(MatchEvaluator evaluator, Regex regex, string input, int count, int startat);
    public static String[] Split(string input, string pattern);
    public static String[] Split(string input, string pattern, RegexOptions options);
    public static String[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public String[] Split(string input);
    public String[] Split(string input, int count);
    public String[] Split(string input, int count, int startat);
    private static String[] Split(Regex regex, string input, int count, int startat);
    public TimeSpan get_MatchTimeout();
    protected internal static void ValidateMatchTimeout(TimeSpan matchTimeout);
    private static TimeSpan InitDefaultMatchTimeout();
}
internal class System.Text.RegularExpressions.RegexBoyerMoore : object {
    public Int32[] Positive;
    public Int32[] NegativeASCII;
    public Int32[][] NegativeUnicode;
    public string Pattern;
    public int LowASCII;
    public int HighASCII;
    public bool RightToLeft;
    public bool CaseInsensitive;
    private CultureInfo _culture;
    public RegexBoyerMoore(string pattern, bool caseInsensitive, bool rightToLeft, CultureInfo culture);
    private bool MatchPattern(string text, int index);
    public bool IsMatch(string text, int index, int beglimit, int endlimit);
    public int Scan(string text, int index, int beglimit, int endlimit);
}
internal class System.Text.RegularExpressions.RegexCharClass : object {
    private static string s_internalRegexIgnoreCase;
    private static string s_space;
    private static string s_notSpace;
    private static string s_word;
    private static string s_notWord;
    public static string SpaceClass;
    public static string NotSpaceClass;
    public static string WordClass;
    public static string NotWordClass;
    public static string DigitClass;
    public static string NotDigitClass;
    private static Dictionary`2<string, string> s_definedCategories;
    private static String[][] s_propTable;
    private static LowerCaseMapping[] s_lcTable;
    private List`1<SingleRange> _rangelist;
    private StringBuilder _categories;
    private bool _canonical;
    private bool _negate;
    private RegexCharClass _subtractor;
    public bool CanMerge { get; }
    unknown bool Negate {public set; }
    private RegexCharClass(bool negate, List`1<SingleRange> ranges, StringBuilder categories, RegexCharClass subtraction);
    private static RegexCharClass();
    public bool get_CanMerge();
    public void set_Negate(bool value);
    public void AddChar(char c);
    public void AddCharClass(RegexCharClass cc);
    private void AddSet(string set);
    public void AddSubtraction(RegexCharClass sub);
    public void AddRange(char first, char last);
    public void AddCategoryFromName(string categoryName, bool invert, bool caseInsensitive, string pattern);
    private void AddCategory(string category);
    public void AddLowercase(CultureInfo culture);
    private void AddLowercaseRange(char chMin, char chMax, CultureInfo culture);
    public void AddWord(bool ecma, bool negate);
    public void AddSpace(bool ecma, bool negate);
    public void AddDigit(bool ecma, bool negate, string pattern);
    public static string ConvertOldStringsToClass(string set, string category);
    public static char SingletonChar(string set);
    public static bool IsMergeable(string charClass);
    public static bool IsEmpty(string charClass);
    public static bool IsSingleton(string set);
    public static bool IsSingletonInverse(string set);
    private static bool IsSubtraction(string charClass);
    private static bool IsNegated(string set);
    public static bool IsECMAWordChar(char ch);
    public static bool IsWordChar(char ch);
    public static bool CharInClass(char ch, string set);
    private static bool CharInClassRecursive(char ch, string set, int start);
    private static bool CharInClassInternal(char ch, string set, int start, int mySetLength, int myCategoryLength);
    private static bool CharInCategory(char ch, string set, int start, int mySetLength, int myCategoryLength);
    private static bool CharInCategoryGroup(char ch, UnicodeCategory chcategory, string category, Int32& i);
    private static string NegateCategory(string category);
    public static RegexCharClass Parse(string charClass);
    private static RegexCharClass ParseRecursive(string charClass, int start);
    private int RangeCount();
    public string ToStringClass();
    private SingleRange GetRangeAt(int i);
    private void Canonicalize();
    private static string SetFromProperty(string capname, bool invert, string pattern);
}
internal class System.Text.RegularExpressions.RegexCode : object {
    public Int32[] Codes;
    public String[] Strings;
    public int TrackCount;
    public Hashtable Caps;
    public int CapSize;
    public Nullable`1<RegexPrefix> FCPrefix;
    public RegexBoyerMoore BMPrefix;
    public int Anchors;
    public bool RightToLeft;
    public RegexCode(Int32[] codes, List`1<string> stringlist, int trackcount, Hashtable caps, int capsize, RegexBoyerMoore bmPrefix, Nullable`1<RegexPrefix> fcPrefix, int anchors, bool rightToLeft);
    public static bool OpcodeBacktracks(int Op);
    public static int OpcodeSize(int opcode);
}
public class System.Text.RegularExpressions.RegexCompilationInfo : object {
    private string _pattern;
    private string _name;
    private string _nspace;
    private TimeSpan _matchTimeout;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexOptions <Options>k__BackingField;
    public bool IsPublic { get; public set; }
    public TimeSpan MatchTimeout { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public RegexOptions Options { get; public set; }
    public string Pattern { get; public set; }
    public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic);
    public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic, TimeSpan matchTimeout);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public void set_IsPublic(bool value);
    public TimeSpan get_MatchTimeout();
    public void set_MatchTimeout(TimeSpan value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public RegexOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(RegexOptions value);
    public string get_Pattern();
    public void set_Pattern(string value);
}
internal abstract class System.Text.RegularExpressions.RegexCompiler : object {
    private static FieldInfo s_textbegF;
    private static FieldInfo s_textendF;
    private static FieldInfo s_textstartF;
    private static FieldInfo s_textposF;
    private static FieldInfo s_textF;
    private static FieldInfo s_trackposF;
    private static FieldInfo s_trackF;
    private static FieldInfo s_stackposF;
    private static FieldInfo s_stackF;
    private static FieldInfo s_trackcountF;
    private static MethodInfo s_ensurestorageM;
    private static MethodInfo s_captureM;
    private static MethodInfo s_transferM;
    private static MethodInfo s_uncaptureM;
    private static MethodInfo s_ismatchedM;
    private static MethodInfo s_matchlengthM;
    private static MethodInfo s_matchindexM;
    private static MethodInfo s_isboundaryM;
    private static MethodInfo s_isECMABoundaryM;
    private static MethodInfo s_chartolowerM;
    private static MethodInfo s_getcharM;
    private static MethodInfo s_crawlposM;
    private static MethodInfo s_charInSetM;
    private static MethodInfo s_getCurrentCulture;
    private static MethodInfo s_getInvariantCulture;
    private static MethodInfo s_checkTimeoutM;
    protected ILGenerator _ilg;
    private LocalBuilder _textstartV;
    private LocalBuilder _textbegV;
    private LocalBuilder _textendV;
    private LocalBuilder _textposV;
    private LocalBuilder _textV;
    private LocalBuilder _trackposV;
    private LocalBuilder _trackV;
    private LocalBuilder _stackposV;
    private LocalBuilder _stackV;
    private LocalBuilder _tempV;
    private LocalBuilder _temp2V;
    private LocalBuilder _temp3V;
    private LocalBuilder _loopV;
    protected RegexCode _code;
    protected Int32[] _codes;
    protected String[] _strings;
    protected Nullable`1<RegexPrefix> _fcPrefix;
    protected RegexBoyerMoore _bmPrefix;
    protected int _anchors;
    private Label[] _labels;
    private BacktrackNote[] _notes;
    private int _notecount;
    protected int _trackcount;
    private Label _backtrack;
    private int _regexopcode;
    private int _codepos;
    private int _backpos;
    protected RegexOptions _options;
    private Int32[] _uniquenote;
    private Int32[] _goto;
    private static RegexCompiler();
    private static FieldInfo RegexRunnerField(string fieldname);
    private static MethodInfo RegexRunnerMethod(string methname);
    internal static RegexRunnerFactory Compile(RegexCode code, RegexOptions options);
    private int AddBacktrackNote(int flags, Label l, int codepos);
    private int AddTrack();
    private int AddTrack(int flags);
    private int AddGoto(int destpos);
    private int AddUniqueTrack(int i);
    private int AddUniqueTrack(int i, int flags);
    private Label DefineLabel();
    private void MarkLabel(Label l);
    private int Operand(int i);
    private bool IsRtl();
    private bool IsCi();
    private int Code();
    private void Ldstr(string str);
    private void Ldc(int i);
    private void Dup();
    private void Ret();
    private void Rem();
    private void Ceq();
    private void Pop();
    private void Add();
    private void Add(bool negate);
    private void Sub();
    private void Sub(bool negate);
    private void Ldloc(LocalBuilder lt);
    private void Stloc(LocalBuilder lt);
    private void Ldthis();
    private void Ldthisfld(FieldInfo ft);
    private void Mvfldloc(FieldInfo ft, LocalBuilder lt);
    private void Mvlocfld(LocalBuilder lt, FieldInfo ft);
    private void Stfld(FieldInfo ft);
    private void Callvirt(MethodInfo mt);
    private void Call(MethodInfo mt);
    private void BrfalseFar(Label l);
    private void BrtrueFar(Label l);
    private void BrFar(Label l);
    private void BleFar(Label l);
    private void BltFar(Label l);
    private void BgeFar(Label l);
    private void BgtFar(Label l);
    private void BneFar(Label l);
    private void BeqFar(Label l);
    private void Brfalse(Label l);
    private void Br(Label l);
    private void Ble(Label l);
    private void Blt(Label l);
    private void Bge(Label l);
    private void Bgt(Label l);
    private void Bgtun(Label l);
    private void Bne(Label l);
    private void Beq(Label l);
    private void Ldlen();
    private void Rightchar();
    private void Rightcharnext();
    private void Leftchar();
    private void Leftcharnext();
    private void Track();
    private void Trackagain();
    private void PushTrack(LocalBuilder lt);
    private void TrackUnique(int i);
    private void TrackUnique2(int i);
    private void ReadyPushTrack();
    private void PopTrack();
    private void TopTrack();
    private void PushStack(LocalBuilder lt);
    internal void ReadyReplaceStack(int i);
    private void ReadyPushStack();
    private void TopStack();
    private void PopStack();
    private void PopDiscardStack();
    private void PopDiscardStack(int i);
    private void DoReplace();
    private void DoPush();
    private void Back();
    private void Goto(int i);
    private int NextCodepos();
    private Label AdvanceLabel();
    private void Advance();
    private void CallToLower();
    private void GenerateForwardSection();
    private void GenerateMiddleSection();
    private void GenerateBacktrackSection();
    protected void GenerateFindFirstChar();
    protected void GenerateInitTrackCount();
    private LocalBuilder DeclareInt();
    private LocalBuilder DeclareIntArray();
    private LocalBuilder DeclareString();
    protected void GenerateGo();
    private void GenerateOneCode();
    private void EmitTimeoutCheck();
}
internal class System.Text.RegularExpressions.RegexFC : object {
    private RegexCharClass _cc;
    public bool _nullable;
    [CompilerGeneratedAttribute]
private bool <CaseInsensitive>k__BackingField;
    public bool CaseInsensitive { get; private set; }
    public RegexFC(bool nullable);
    public RegexFC(char ch, bool not, bool nullable, bool caseInsensitive);
    public RegexFC(string charClass, bool nullable, bool caseInsensitive);
    public bool AddFC(RegexFC fc, bool concatenate);
    [CompilerGeneratedAttribute]
public bool get_CaseInsensitive();
    [CompilerGeneratedAttribute]
private void set_CaseInsensitive(bool value);
    public string GetFirstChars(CultureInfo culture);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Text.RegularExpressions.RegexFCD : ValueType {
    private List`1<RegexFC> _fcStack;
    private ValueListBuilder`1<int> _intStack;
    private bool _skipAllChildren;
    private bool _skipchild;
    private bool _failed;
    private RegexFCD(Span`1<int> intStack);
    public static Nullable`1<RegexPrefix> FirstChars(RegexTree t);
    public static RegexPrefix Prefix(RegexTree tree);
    public static int Anchors(RegexTree tree);
    private static int AnchorFromType(int type);
    private void PushInt(int i);
    private bool IntIsEmpty();
    private int PopInt();
    private void PushFC(RegexFC fc);
    private bool FCIsEmpty();
    private RegexFC PopFC();
    private RegexFC TopFC();
    public void Dispose();
    private RegexFC RegexFCFromRegexTree(RegexTree tree);
    private void SkipChild();
    private void CalculateFC(int NodeType, RegexNode node, int CurIndex);
}
internal class System.Text.RegularExpressions.RegexInterpreter : RegexRunner {
    private RegexCode _code;
    private CultureInfo _culture;
    private int _operator;
    private int _codepos;
    private bool _rightToLeft;
    private bool _caseInsensitive;
    public RegexInterpreter(RegexCode code, CultureInfo culture);
    protected virtual void InitTrackCount();
    private void Advance(int i);
    private void Goto(int newpos);
    private void Textto(int newpos);
    private void Trackto(int newpos);
    private int Textstart();
    private int Textpos();
    private int Trackpos();
    private void TrackPush();
    private void TrackPush(int I1);
    private void TrackPush(int I1, int I2);
    private void TrackPush(int I1, int I2, int I3);
    private void TrackPush2(int I1);
    private void TrackPush2(int I1, int I2);
    private void Backtrack();
    private void SetOperator(int op);
    private void TrackPop();
    private void TrackPop(int framesize);
    private int TrackPeek();
    private int TrackPeek(int i);
    private void StackPush(int I1);
    private void StackPush(int I1, int I2);
    private void StackPop();
    private void StackPop(int framesize);
    private int StackPeek();
    private int StackPeek(int i);
    private int Operator();
    private int Operand(int i);
    private int Leftchars();
    private int Rightchars();
    private int Bump();
    private int Forwardchars();
    private char Forwardcharnext();
    private bool Stringmatch(string str);
    private bool Refmatch(int index, int len);
    private void Backwardnext();
    private char CharAt(int j);
    protected virtual bool FindFirstChar();
    protected virtual void Go();
}
internal class System.Text.RegularExpressions.RegexLWCGCompiler : RegexCompiler {
    private static int s_regexCount;
    private static Type[] s_paramTypes;
    private static RegexLWCGCompiler();
    public RegexRunnerFactory FactoryInstanceFromCode(RegexCode code, RegexOptions options);
    public DynamicMethod DefineDynamicMethod(string methname, Type returntype, Type hostType);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.RegularExpressions.RegexMatchTimeoutException : TimeoutException {
    [CompilerGeneratedAttribute]
private string <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MatchTimeout>k__BackingField;
    public string Input { get; }
    public string Pattern { get; }
    public TimeSpan MatchTimeout { get; }
    public RegexMatchTimeoutException(string regexInput, string regexPattern, TimeSpan matchTimeout);
    public RegexMatchTimeoutException(string message);
    public RegexMatchTimeoutException(string message, Exception inner);
    protected RegexMatchTimeoutException(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Input();
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public TimeSpan get_MatchTimeout();
}
internal class System.Text.RegularExpressions.RegexNode : object {
    public int NType;
    public List`1<RegexNode> Children;
    public string Str;
    public char Ch;
    public int M;
    public int N;
    public RegexOptions Options;
    public RegexNode Next;
    public RegexNode(int type, RegexOptions options);
    public RegexNode(int type, RegexOptions options, char ch);
    public RegexNode(int type, RegexOptions options, string str);
    public RegexNode(int type, RegexOptions options, int m);
    public RegexNode(int type, RegexOptions options, int m, int n);
    public bool UseOptionR();
    public RegexNode ReverseLeft();
    private void MakeRep(int type, int min, int max);
    private RegexNode Reduce();
    private RegexNode StripEnation(int emptyType);
    private RegexNode ReduceGroup();
    private RegexNode ReduceRep();
    private RegexNode ReduceSet();
    private RegexNode ReduceAlternation();
    private RegexNode ReduceConcatenation();
    public RegexNode MakeQuantifier(bool lazy, int min, int max);
    public void AddChild(RegexNode newChild);
    public RegexNode Child(int i);
    public int ChildCount();
    public int Type();
}
[FlagsAttribute]
public enum System.Text.RegularExpressions.RegexOptions : Enum {
    public int value__;
    public static RegexOptions None;
    public static RegexOptions IgnoreCase;
    public static RegexOptions Multiline;
    public static RegexOptions ExplicitCapture;
    public static RegexOptions Compiled;
    public static RegexOptions Singleline;
    public static RegexOptions IgnorePatternWhitespace;
    public static RegexOptions RightToLeft;
    public static RegexOptions ECMAScript;
    public static RegexOptions CultureInvariant;
}
internal class System.Text.RegularExpressions.RegexParser : object {
    private RegexNode _stack;
    private RegexNode _group;
    private RegexNode _alternation;
    private RegexNode _concatenation;
    private RegexNode _unit;
    private string _pattern;
    private int _currentPos;
    private CultureInfo _culture;
    private int _autocap;
    private int _capcount;
    private int _captop;
    private int _capsize;
    private Hashtable _caps;
    private Hashtable _capnames;
    private Int32[] _capnumlist;
    private List`1<string> _capnamelist;
    private RegexOptions _options;
    private List`1<RegexOptions> _optionsStack;
    private bool _ignoreNextParen;
    private static Byte[] s_category;
    private RegexParser(CultureInfo culture);
    private static RegexParser();
    public static RegexTree Parse(string re, RegexOptions op);
    public static RegexReplacement ParseReplacement(string rep, Hashtable caps, int capsize, Hashtable capnames, RegexOptions op);
    public static string Escape(string input);
    public static string Unescape(string input);
    private void SetPattern(string Re);
    private void Reset(RegexOptions topopts);
    private RegexNode ScanRegex();
    private RegexNode ScanReplacement();
    private RegexCharClass ScanCharClass(bool caseInsensitive, bool scanOnly);
    private RegexNode ScanGroupOpen();
    private void ScanBlank();
    private RegexNode ScanBackslash(bool scanOnly);
    private RegexNode ScanBasicBackslash(bool scanOnly);
    private RegexNode ScanDollar();
    private string ScanCapname();
    private char ScanOctal();
    private int ScanDecimal();
    private char ScanHex(int c);
    private static int HexDigit(char ch);
    private char ScanControl();
    private bool IsOnlyTopOption(RegexOptions option);
    private void ScanOptions();
    private char ScanCharEscape();
    private string ParseProperty();
    private int TypeFromCode(char ch);
    private static RegexOptions OptionFromCode(char ch);
    private void CountCaptures();
    private void NoteCaptureSlot(int i, int pos);
    private void NoteCaptureName(string name, int pos);
    private void NoteCaptures(Hashtable caps, int capsize, Hashtable capnames);
    private void AssignNameSlots();
    private int CaptureSlotFromName(string capname);
    private bool IsCaptureSlot(int i);
    private bool IsCaptureName(string capname);
    private bool UseOptionN();
    private bool UseOptionI();
    private bool UseOptionM();
    private bool UseOptionS();
    private bool UseOptionX();
    private bool UseOptionE();
    private static bool IsSpecial(char ch);
    private static bool IsStopperX(char ch);
    private static bool IsQuantifier(char ch);
    private bool IsTrueQuantifier();
    private static bool IsSpace(char ch);
    private static bool IsMetachar(char ch);
    private void AddConcatenate(int pos, int cch, bool isReplacement);
    private void PushGroup();
    private void PopGroup();
    private bool EmptyStack();
    private void StartGroup(RegexNode openGroup);
    private void AddAlternate();
    private void AddConcatenate();
    private void AddConcatenate(bool lazy, int min, int max);
    private RegexNode Unit();
    private void AddUnitOne(char ch);
    private void AddUnitNotone(char ch);
    private void AddUnitSet(string cc);
    private void AddUnitNode(RegexNode node);
    private void AddUnitType(int type);
    private void AddGroup();
    private void PushOptions();
    private void PopOptions();
    private bool EmptyOptionsStack();
    private void PopKeepOptions();
    private ArgumentException MakeException(string message);
    private int Textpos();
    private void Textto(int pos);
    private char RightCharMoveRight();
    private void MoveRight();
    private void MoveRight(int i);
    private void MoveLeft();
    private char CharAt(int i);
    internal char RightChar();
    private char RightChar(int i);
    private int CharsRight();
}
[IsReadOnlyAttribute]
internal class System.Text.RegularExpressions.RegexPrefix : ValueType {
    [CompilerGeneratedAttribute]
private bool <CaseInsensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private static RegexPrefix <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    internal bool CaseInsensitive { get; }
    internal static RegexPrefix Empty { get; }
    internal string Prefix { get; }
    internal RegexPrefix(string prefix, bool ci);
    private static RegexPrefix();
    [CompilerGeneratedAttribute]
internal bool get_CaseInsensitive();
    [CompilerGeneratedAttribute]
internal static RegexPrefix get_Empty();
    [CompilerGeneratedAttribute]
internal string get_Prefix();
}
internal class System.Text.RegularExpressions.RegexReplacement : object {
    private List`1<string> _strings;
    private List`1<int> _rules;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    public string Pattern { get; }
    public RegexReplacement(string rep, RegexNode concat, Hashtable _caps);
    public static RegexReplacement GetOrCreate(WeakReference`1<RegexReplacement> replRef, string replacement, Hashtable caps, int capsize, Hashtable capnames, RegexOptions roptions);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    private void ReplacementImpl(StringBuilder sb, Match match);
    private void ReplacementImplRTL(List`1<string> al, Match match);
    public string Replacement(Match match);
    public string Replace(Regex regex, string input, int count, int startat);
}
public abstract class System.Text.RegularExpressions.RegexRunner : object {
    protected internal int runtextbeg;
    protected internal int runtextend;
    protected internal int runtextstart;
    protected internal string runtext;
    protected internal int runtextpos;
    protected internal Int32[] runtrack;
    protected internal int runtrackpos;
    protected internal Int32[] runstack;
    protected internal int runstackpos;
    protected internal Int32[] runcrawl;
    protected internal int runcrawlpos;
    protected internal int runtrackcount;
    protected internal Match runmatch;
    protected internal Regex runregex;
    private int _timeout;
    private bool _ignoreTimeout;
    private int _timeoutOccursAt;
    private int _timeoutChecksToSkip;
    protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick);
    protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick, TimeSpan timeout);
    private void StartTimeoutWatch();
    protected void CheckTimeout();
    private void DoCheckTimeout();
    protected abstract virtual void Go();
    protected abstract virtual bool FindFirstChar();
    protected abstract virtual void InitTrackCount();
    private void InitMatch();
    private Match TidyMatch(bool quick);
    protected void EnsureStorage();
    protected bool IsBoundary(int index, int startpos, int endpos);
    protected bool IsECMABoundary(int index, int startpos, int endpos);
    protected static bool CharInSet(char ch, string set, string category);
    protected static bool CharInClass(char ch, string charClass);
    protected void DoubleTrack();
    protected void DoubleStack();
    protected void DoubleCrawl();
    protected void Crawl(int i);
    protected int Popcrawl();
    protected int Crawlpos();
    protected void Capture(int capnum, int start, int end);
    protected void TransferCapture(int capnum, int uncapnum, int start, int end);
    protected void Uncapture();
    protected bool IsMatched(int cap);
    protected int MatchIndex(int cap);
    protected int MatchLength(int cap);
}
public abstract class System.Text.RegularExpressions.RegexRunnerFactory : object {
    protected internal abstract virtual RegexRunner CreateInstance();
}
internal class System.Text.RegularExpressions.RegexTree : object {
    public RegexNode Root;
    public Hashtable Caps;
    public Int32[] CapNumList;
    public int CapTop;
    public Hashtable CapNames;
    public String[] CapsList;
    public RegexOptions Options;
    internal RegexTree(RegexNode root, Hashtable caps, Int32[] capNumList, int capTop, Hashtable capNames, String[] capsList, RegexOptions options);
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsByRefLikeAttribute]
internal class System.Text.RegularExpressions.RegexWriter : ValueType {
    private ValueListBuilder`1<int> _emitted;
    private ValueListBuilder`1<int> _intStack;
    private Dictionary`2<string, int> _stringHash;
    private List`1<string> _stringTable;
    private Hashtable _caps;
    private int _trackCount;
    private RegexWriter(Span`1<int> emittedSpan, Span`1<int> intStackSpan);
    public static RegexCode Write(RegexTree tree);
    public void Dispose();
    public RegexCode RegexCodeFromRegexTree(RegexTree tree);
    private void PatchJump(int offset, int jumpDest);
    private void Emit(int op);
    private void Emit(int op, int opd1);
    private void Emit(int op, int opd1, int opd2);
    private int StringCode(string str);
    private int MapCapnum(int capnum);
    private void EmitFragment(int nodetype, RegexNode node, int curIndex);
}
